/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "call_service.h"

gboolean
call_service_if_get_user_status (CallServiceIf *iface, UserStatus* _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_status (iface, _return, mid, e, error);
}

gboolean
call_service_if_update_profile_attribute_for_channel (CallServiceIf *iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->update_profile_attribute_for_channel (iface, profileAttribute, value, e, error);
}

gboolean
call_service_if_update_extended_profile_attribute (CallServiceIf *iface, const ExtendedProfileAttribute attr, const ExtendedProfile * extendedProfile, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->update_extended_profile_attribute (iface, attr, extendedProfile, e, error);
}

gboolean
call_service_if_get_all_simple_channel_contacts (CallServiceIf *iface, GPtrArray ** _return, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_all_simple_channel_contacts (iface, _return, statusSticonFallbackDisabled, e, error);
}

gboolean
call_service_if_get_user_identities (CallServiceIf *iface, GHashTable ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_identities (iface, _return, e, error);
}

gboolean
call_service_if_mark_paid_call_ad (CallServiceIf *iface, PaidCallDialing ** _return, const gchar * dialedNumber, const gchar * language, const gboolean disableCallerId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->mark_paid_call_ad (iface, _return, dialedNumber, language, disableCallerId, e, error);
}

gboolean
call_service_if_is_group_member (CallServiceIf *iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->is_group_member (iface, _return, groupId, e, error);
}

gboolean
call_service_if_get_phone_info_from_phone_number (CallServiceIf *iface, PhoneInfoForChannel ** _return, const gchar * region, const gchar * phoneNumber, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_phone_info_from_phone_number (iface, _return, region, phoneNumber, e, error);
}

gboolean
call_service_if_redeem_paid_call_voucher (CallServiceIf *iface, PaidCallRedeemResult ** _return, const gchar * serial, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->redeem_paid_call_voucher (iface, _return, serial, language, e, error);
}

gboolean
call_service_if_get_preferred_display_name (CallServiceIf *iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_preferred_display_name (iface, _return, mids, e, error);
}

gboolean
call_service_if_get_contacts_for_channel (CallServiceIf *iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_contacts_for_channel (iface, _return, ids, e, error);
}

gboolean
call_service_if_get_call_credit_products (CallServiceIf *iface, GPtrArray ** _return, const PaymentType appStoreCode, const PaymentPgType pgCode, const gchar * country, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_call_credit_products (iface, _return, appStoreCode, pgCode, country, language, e, error);
}

gboolean
call_service_if_get_compact_contacts (CallServiceIf *iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_compact_contacts (iface, _return, lastModifiedTimestamp, e, error);
}

gboolean
call_service_if_notify_noti_center_event (CallServiceIf *iface, const NotiCenterEventData * event, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->notify_noti_center_event (iface, event, e, error);
}

gboolean
call_service_if_is_in_contact (CallServiceIf *iface, gboolean* _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->is_in_contact (iface, _return, mid, e, error);
}

gboolean
call_service_if_lookup_group_members (CallServiceIf *iface, GPtrArray ** _return, const gchar * groupId, const GPtrArray * mids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->lookup_group_members (iface, _return, groupId, mids, e, error);
}

gboolean
call_service_if_get_room_information (CallServiceIf *iface, Room ** _return, const gchar * roomMid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_room_information (iface, _return, roomMid, e, error);
}

gboolean
call_service_if_get_group_call (CallServiceIf *iface, GroupCall ** _return, const gchar * chatMid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_group_call (iface, _return, chatMid, e, error);
}

gboolean
call_service_if_is_allow_secondary_device_login (CallServiceIf *iface, gboolean* _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->is_allow_secondary_device_login (iface, _return, e, error);
}

gboolean
call_service_if_get_primary_client_for_channel (CallServiceIf *iface, SimpleChannelClient ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_primary_client_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_create_room_with_buddy (CallServiceIf *iface, Room ** _return, const gint32 reqSeq, const gchar * buddyMid, const GPtrArray * contactIds, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->create_room_with_buddy (iface, _return, reqSeq, buddyMid, contactIds, e, error);
}

gboolean
call_service_if_get_display_name (CallServiceIf *iface, gchar ** _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_display_name (iface, _return, mid, e, error);
}

gboolean
call_service_if_get_paid_call_metadata (CallServiceIf *iface, PaidCallMetadataResult ** _return, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_paid_call_metadata (iface, _return, language, e, error);
}

gboolean
call_service_if_get_mid (CallServiceIf *iface, gchar ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_mid (iface, _return, e, error);
}

gboolean
call_service_if_get_user_country_for_billing (CallServiceIf *iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_country_for_billing (iface, _return, country, remoteIp, e, error);
}

gboolean
call_service_if_get_favorite_group_ids_for_channel (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_favorite_group_ids_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_get_paid_call_history (CallServiceIf *iface, PaidCallHistoryResult ** _return, const gint64 start, const gint32 size, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_paid_call_history (iface, _return, start, size, language, e, error);
}

gboolean
call_service_if_send_pin_code_operation (CallServiceIf *iface, const gchar * verifier, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->send_pin_code_operation (iface, verifier, e, error);
}

gboolean
call_service_if_invite_into_group_call (CallServiceIf *iface, const gchar * chatMid, const GPtrArray * memberMids, const GroupCallMediaType mediaType, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->invite_into_group_call (iface, chatMid, memberMids, mediaType, e, error);
}

gboolean
call_service_if_get_friend_mids (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_friend_mids (iface, _return, e, error);
}

gboolean
call_service_if_get_meta_profile (CallServiceIf *iface, MetaProfile ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_meta_profile (iface, _return, e, error);
}

gboolean
call_service_if_send_message_for_channel (CallServiceIf *iface, Message ** _return, const Message * message, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->send_message_for_channel (iface, _return, message, e, error);
}

gboolean
call_service_if_active_buddy_subscriber_count (CallServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->active_buddy_subscriber_count (iface, _return, e, error);
}

gboolean
call_service_if_get_call_credit_purchase_history (CallServiceIf *iface, CoinHistoryResult ** _return, const CoinHistoryCondition * request, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_call_credit_purchase_history (iface, _return, request, e, error);
}

gboolean
call_service_if_is_room_member (CallServiceIf *iface, gboolean* _return, const gchar * roomId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->is_room_member (iface, _return, roomId, e, error);
}

gboolean
call_service_if_send_system_o_a_message (CallServiceIf *iface, Message ** _return, const Message * message, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->send_system_o_a_message (iface, _return, message, e, error);
}

gboolean
call_service_if_acquire_paid_call_route (CallServiceIf *iface, PaidCallResponse ** _return, const PaidCallType paidCallType, const gchar * dialedNumber, const gchar * language, const gchar * networkCode, const gboolean disableCallerId, const gchar * referer, const gchar * adSessionId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->acquire_paid_call_route (iface, _return, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId, e, error);
}

gboolean
call_service_if_get_groups_for_channel (CallServiceIf *iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_groups_for_channel (iface, _return, groupIds, e, error);
}

gboolean
call_service_if_get_user_create_time (CallServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_create_time (iface, _return, e, error);
}

gboolean
call_service_if_register_channel_c_p (CallServiceIf *iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->register_channel_c_p (iface, _return, cpId, registerPassword, e, error);
}

gboolean
call_service_if_reserve_call_credit_purchase (CallServiceIf *iface, PaymentReservationResult ** _return, const CoinPurchaseReservation * request, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->reserve_call_credit_purchase (iface, _return, request, e, error);
}

gboolean
call_service_if_acquire_paid_call_currency_exchange_rate (CallServiceIf *iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->acquire_paid_call_currency_exchange_rate (iface, _return, language, e, error);
}

gboolean
call_service_if_get_room_member_mids_for_app_platform (CallServiceIf *iface, GPtrArray ** _return, const gchar * roomId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_room_member_mids_for_app_platform (iface, _return, roomId, e, error);
}

gboolean
call_service_if_get_paid_call_balance_list (CallServiceIf *iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_paid_call_balance_list (iface, _return, language, e, error);
}

gboolean
call_service_if_get_personal_infos (CallServiceIf *iface, GHashTable ** _return, const GHashTable * requiredPersonalInfos, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_personal_infos (iface, _return, requiredPersonalInfos, e, error);
}

gboolean
call_service_if_get_primary_clients_for_channel (CallServiceIf *iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_primary_clients_for_channel (iface, _return, userMids, e, error);
}

gboolean
call_service_if_add_buddy_to_contact (CallServiceIf *iface, ContactTransition ** _return, const gchar * buddyMid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->add_buddy_to_contact (iface, _return, buddyMid, e, error);
}

gboolean
call_service_if_get_group_member_mids_for_app_platform (CallServiceIf *iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_group_member_mids_for_app_platform (iface, _return, groupId, e, error);
}

gboolean
call_service_if_get_user_language (CallServiceIf *iface, gchar ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_language (iface, _return, e, error);
}

gboolean
call_service_if_lookup_paid_call (CallServiceIf *iface, PaidCallResponse ** _return, const gchar * dialedNumber, const gchar * language, const gchar * referer, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->lookup_paid_call (iface, _return, dialedNumber, language, referer, e, error);
}

gboolean
call_service_if_get_extended_profile (CallServiceIf *iface, ExtendedProfile ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_extended_profile (iface, _return, e, error);
}

gboolean
call_service_if_get_reverse_compact_contacts (CallServiceIf *iface, GHashTable ** _return, const GPtrArray * ids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_reverse_compact_contacts (iface, _return, ids, e, error);
}

gboolean
call_service_if_get_paid_call_ad_status (CallServiceIf *iface, PaidCallAdResult ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_paid_call_ad_status (iface, _return, e, error);
}

gboolean
call_service_if_find_contact_by_userid_without_abuse_block_for_channel (CallServiceIf *iface, Contact ** _return, const gchar * userid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->find_contact_by_userid_without_abuse_block_for_channel (iface, _return, userid, e, error);
}

gboolean
call_service_if_get_group_member_mids (CallServiceIf *iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_group_member_mids (iface, _return, groupId, e, error);
}

gboolean
call_service_if_send_message_without_relationship (CallServiceIf *iface, Message ** _return, const Message * message, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->send_message_without_relationship (iface, _return, message, e, error);
}

gboolean
call_service_if_display_buddy_subscriber_count_in_bulk (CallServiceIf *iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->display_buddy_subscriber_count_in_bulk (iface, _return, mids, e, error);
}

gboolean
call_service_if_lookup_room_members (CallServiceIf *iface, GPtrArray ** _return, const gchar * roomId, const GPtrArray * mids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->lookup_room_members (iface, _return, roomId, mids, e, error);
}

gboolean
call_service_if_get_favorite_mids_for_channel (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_favorite_mids_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_get_all_contact_ids_for_channel (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_all_contact_ids_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_display_buddy_subscriber_count (CallServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->display_buddy_subscriber_count (iface, _return, e, error);
}

gboolean
call_service_if_get_profile_for_channel (CallServiceIf *iface, Profile ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_profile_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_get_user_tickets (CallServiceIf *iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_tickets (iface, _return, userMids, e, error);
}

gboolean
call_service_if_get_o_a_friend_mids (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_o_a_friend_mids (iface, _return, e, error);
}

gboolean
call_service_if_search_paid_call_user_rate (CallServiceIf *iface, GPtrArray ** _return, const gchar * countryCode, const gchar * language, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->search_paid_call_user_rate (iface, _return, countryCode, language, e, error);
}

gboolean
call_service_if_get_joined_group_ids_for_channel (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_joined_group_ids_for_channel (iface, _return, e, error);
}

gboolean
call_service_if_acquire_group_call_route (CallServiceIf *iface, GroupCallRoute ** _return, const gchar * chatMid, const GroupCallMediaType mediaType, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->acquire_group_call_route (iface, _return, chatMid, mediaType, e, error);
}

gboolean
call_service_if_get_user_mids_who_added_me (CallServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_mids_who_added_me (iface, _return, e, error);
}

gboolean
call_service_if_get_identity_credential (CallServiceIf *iface, IdentityCredential ** _return, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_identity_credential (iface, _return, e, error);
}

gboolean
call_service_if_add_operation_for_channel (CallServiceIf *iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->add_operation_for_channel (iface, opType, param1, param2, param3, e, error);
}

gboolean
call_service_if_get_simple_channel_contacts (CallServiceIf *iface, GPtrArray ** _return, const GPtrArray * ids, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_simple_channel_contacts (iface, _return, ids, statusSticonFallbackDisabled, e, error);
}

gboolean
call_service_if_get_user_last_sent_message_time_stamp (CallServiceIf *iface, gint64* _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CALL_SERVICE_IF_GET_INTERFACE (iface)->get_user_last_sent_message_time_stamp (iface, _return, mid, e, error);
}

GType
call_service_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (CallServiceIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "CallServiceIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
call_service_if_interface_init (CallServiceIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (CallServiceClient, call_service_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_CALL_SERVICE_IF,
                                                call_service_if_interface_init))

enum _CallServiceClientProperties
{
  PROP_0,
  PROP_CALL_SERVICE_CLIENT_INPUT_PROTOCOL,
  PROP_CALL_SERVICE_CLIENT_OUTPUT_PROTOCOL
};

void
call_service_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  CallServiceClient *client = CALL_SERVICE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_CALL_SERVICE_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_CALL_SERVICE_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
call_service_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  CallServiceClient *client = CALL_SERVICE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_CALL_SERVICE_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_CALL_SERVICE_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean call_service_client_send_get_user_status (CallServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserStatus", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserStatus_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_status (CallServiceIf * iface, UserStatus* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserStatus", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserStatus", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            gint32 ecast1203;
            if ((ret = thrift_protocol_read_i32 (protocol, &ecast1203, error)) < 0)
              return 0;
            xfer += ret;
            *_return = (UserStatus)ecast1203;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_status (CallServiceIf * iface, UserStatus* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_status (iface, mid, error))
    return FALSE;
  if (!call_service_client_recv_get_user_status (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_update_profile_attribute_for_channel (CallServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateProfileAttributeForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateProfileAttributeForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "profileAttribute", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) profileAttribute, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_update_profile_attribute_for_channel (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateProfileAttributeForChannel", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateProfileAttributeForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_update_profile_attribute_for_channel (CallServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_update_profile_attribute_for_channel (iface, profileAttribute, value, error))
    return FALSE;
  if (!call_service_client_recv_update_profile_attribute_for_channel (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_update_extended_profile_attribute (CallServiceIf * iface, const ExtendedProfileAttribute attr, const ExtendedProfile * extendedProfile, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateExtendedProfileAttribute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateExtendedProfileAttribute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attr", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) attr, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "extendedProfile", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (extendedProfile), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_update_extended_profile_attribute (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateExtendedProfileAttribute", 30) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateExtendedProfileAttribute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_update_extended_profile_attribute (CallServiceIf * iface, const ExtendedProfileAttribute attr, const ExtendedProfile * extendedProfile, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_update_extended_profile_attribute (iface, attr, extendedProfile, error))
    return FALSE;
  if (!call_service_client_recv_update_extended_profile_attribute (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_all_simple_channel_contacts (CallServiceIf * iface, const gboolean statusSticonFallbackDisabled, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getAllSimpleChannelContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getAllSimpleChannelContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "statusSticonFallbackDisabled", T_BOOL, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, statusSticonFallbackDisabled, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_all_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getAllSimpleChannelContacts", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getAllSimpleChannelContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelContact * _elem1204 = NULL;
                if ( _elem1204 != NULL)
                {
                  g_object_unref (_elem1204);
                }
                _elem1204 = g_object_new (TYPE_SIMPLE_CHANNEL_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1204), protocol, error)) < 0)
                {
                  g_object_unref (_elem1204);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1204);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_all_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_all_simple_channel_contacts (iface, statusSticonFallbackDisabled, error))
    return FALSE;
  if (!call_service_client_recv_get_all_simple_channel_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_identities (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserIdentities", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserIdentities_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_identities (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserIdentities", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserIdentities", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                RegistrationType key1205;
                gchar * val1206 = NULL;
                gint32 ecast1207;
                if ((ret = thrift_protocol_read_i32 (protocol, &ecast1207, error)) < 0)
                  return 0;
                xfer += ret;
                key1205 = (RegistrationType)ecast1207;
                if (val1206 != NULL)
                {
                  g_free(val1206);
                  val1206 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val1206, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key1205)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key1205, (gpointer) val1206);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_identities (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_identities (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_user_identities (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_mark_paid_call_ad (CallServiceIf * iface, const gchar * dialedNumber, const gchar * language, const gboolean disableCallerId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "markPaidCallAd", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "markPaidCallAd_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "dialedNumber", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, dialedNumber, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "disableCallerId", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, disableCallerId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_mark_paid_call_ad (CallServiceIf * iface, PaidCallDialing ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "markPaidCallAd", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected markPaidCallAd", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_mark_paid_call_ad (CallServiceIf * iface, PaidCallDialing ** _return, const gchar * dialedNumber, const gchar * language, const gboolean disableCallerId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_mark_paid_call_ad (iface, dialedNumber, language, disableCallerId, error))
    return FALSE;
  if (!call_service_client_recv_mark_paid_call_ad (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_is_group_member (CallServiceIf * iface, const gchar * groupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isGroupMember", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isGroupMember_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_is_group_member (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isGroupMember", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isGroupMember", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_is_group_member (CallServiceIf * iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_is_group_member (iface, groupId, error))
    return FALSE;
  if (!call_service_client_recv_is_group_member (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_phone_info_from_phone_number (CallServiceIf * iface, const gchar * region, const gchar * phoneNumber, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPhoneInfoFromPhoneNumber", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPhoneInfoFromPhoneNumber_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "region", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, region, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "phoneNumber", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, phoneNumber, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_phone_info_from_phone_number (CallServiceIf * iface, PhoneInfoForChannel ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPhoneInfoFromPhoneNumber", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPhoneInfoFromPhoneNumber", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_phone_info_from_phone_number (CallServiceIf * iface, PhoneInfoForChannel ** _return, const gchar * region, const gchar * phoneNumber, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_phone_info_from_phone_number (iface, region, phoneNumber, error))
    return FALSE;
  if (!call_service_client_recv_get_phone_info_from_phone_number (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_redeem_paid_call_voucher (CallServiceIf * iface, const gchar * serial, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "redeemPaidCallVoucher", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "redeemPaidCallVoucher_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "serial", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, serial, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_redeem_paid_call_voucher (CallServiceIf * iface, PaidCallRedeemResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "redeemPaidCallVoucher", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected redeemPaidCallVoucher", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_redeem_paid_call_voucher (CallServiceIf * iface, PaidCallRedeemResult ** _return, const gchar * serial, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_redeem_paid_call_voucher (iface, serial, language, error))
    return FALSE;
  if (!call_service_client_recv_redeem_paid_call_voucher (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_preferred_display_name (CallServiceIf * iface, const GPtrArray * mids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPreferredDisplayName", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPreferredDisplayName_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1208;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (mids ? mids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1208 = 0; i1208 < (mids ? mids->len : 0); i1208++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) mids, i1208)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_preferred_display_name (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPreferredDisplayName", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPreferredDisplayName", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key1209 = NULL;
                gchar * val1210 = NULL;
                if (key1209 != NULL)
                {
                  g_free(key1209);
                  key1209 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key1209, error)) < 0)
                  return 0;
                xfer += ret;
                if (val1210 != NULL)
                {
                  g_free(val1210);
                  val1210 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val1210, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key1209)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key1209, (gpointer) val1210);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_preferred_display_name (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_preferred_display_name (iface, mids, error))
    return FALSE;
  if (!call_service_client_recv_get_preferred_display_name (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_contacts_for_channel (CallServiceIf * iface, const GPtrArray * ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getContactsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getContactsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1211;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (ids ? ids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1211 = 0; i1211 < (ids ? ids->len : 0); i1211++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ids, i1211)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_contacts_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getContactsForChannel", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getContactsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Contact * _elem1212 = NULL;
                if ( _elem1212 != NULL)
                {
                  g_object_unref (_elem1212);
                }
                _elem1212 = g_object_new (TYPE_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1212), protocol, error)) < 0)
                {
                  g_object_unref (_elem1212);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1212);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_contacts_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_contacts_for_channel (iface, ids, error))
    return FALSE;
  if (!call_service_client_recv_get_contacts_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_call_credit_products (CallServiceIf * iface, const PaymentType appStoreCode, const PaymentPgType pgCode, const gchar * country, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getCallCreditProducts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getCallCreditProducts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "appStoreCode", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) appStoreCode, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "pgCode", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) pgCode, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "country", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, country, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_call_credit_products (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getCallCreditProducts", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getCallCreditProducts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                CoinProductItem * _elem1213 = NULL;
                if ( _elem1213 != NULL)
                {
                  g_object_unref (_elem1213);
                }
                _elem1213 = g_object_new (TYPE_COIN_PRODUCT_ITEM, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1213), protocol, error)) < 0)
                {
                  g_object_unref (_elem1213);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1213);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_call_credit_products (CallServiceIf * iface, GPtrArray ** _return, const PaymentType appStoreCode, const PaymentPgType pgCode, const gchar * country, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_call_credit_products (iface, appStoreCode, pgCode, country, language, error))
    return FALSE;
  if (!call_service_client_recv_get_call_credit_products (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_compact_contacts (CallServiceIf * iface, const gint64 lastModifiedTimestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getCompactContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getCompactContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "lastModifiedTimestamp", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, lastModifiedTimestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_compact_contacts (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getCompactContacts", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getCompactContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                CompactContact * _elem1214 = NULL;
                if ( _elem1214 != NULL)
                {
                  g_object_unref (_elem1214);
                }
                _elem1214 = g_object_new (TYPE_COMPACT_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1214), protocol, error)) < 0)
                {
                  g_object_unref (_elem1214);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1214);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_compact_contacts (CallServiceIf * iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_compact_contacts (iface, lastModifiedTimestamp, error))
    return FALSE;
  if (!call_service_client_recv_get_compact_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_notify_noti_center_event (CallServiceIf * iface, const NotiCenterEventData * event, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "notifyNotiCenterEvent", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "notifyNotiCenterEvent_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "event", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (event), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_notify_noti_center_event (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "notifyNotiCenterEvent", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected notifyNotiCenterEvent", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_notify_noti_center_event (CallServiceIf * iface, const NotiCenterEventData * event, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_notify_noti_center_event (iface, event, error))
    return FALSE;
  if (!call_service_client_recv_notify_noti_center_event (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_is_in_contact (CallServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isInContact", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isInContact_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_is_in_contact (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isInContact", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isInContact", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_is_in_contact (CallServiceIf * iface, gboolean* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_is_in_contact (iface, mid, error))
    return FALSE;
  if (!call_service_client_recv_is_in_contact (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_lookup_group_members (CallServiceIf * iface, const gchar * groupId, const GPtrArray * mids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "lookupGroupMembers", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "lookupGroupMembers_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1215;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (mids ? mids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1215 = 0; i1215 < (mids ? mids->len : 0); i1215++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) mids, i1215)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_lookup_group_members (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "lookupGroupMembers", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected lookupGroupMembers", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelContact * _elem1216 = NULL;
                if ( _elem1216 != NULL)
                {
                  g_object_unref (_elem1216);
                }
                _elem1216 = g_object_new (TYPE_SIMPLE_CHANNEL_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1216), protocol, error)) < 0)
                {
                  g_object_unref (_elem1216);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1216);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_lookup_group_members (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_lookup_group_members (iface, groupId, mids, error))
    return FALSE;
  if (!call_service_client_recv_lookup_group_members (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_room_information (CallServiceIf * iface, const gchar * roomMid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRoomInformation", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRoomInformation_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomMid", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, roomMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_room_information (CallServiceIf * iface, Room ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRoomInformation", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRoomInformation", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_room_information (CallServiceIf * iface, Room ** _return, const gchar * roomMid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_room_information (iface, roomMid, error))
    return FALSE;
  if (!call_service_client_recv_get_room_information (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_group_call (CallServiceIf * iface, const gchar * chatMid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupCall", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupCall_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "chatMid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, chatMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_group_call (CallServiceIf * iface, GroupCall ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupCall", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupCall", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_group_call (CallServiceIf * iface, GroupCall ** _return, const gchar * chatMid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_group_call (iface, chatMid, error))
    return FALSE;
  if (!call_service_client_recv_get_group_call (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_is_allow_secondary_device_login (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isAllowSecondaryDeviceLogin", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isAllowSecondaryDeviceLogin_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_is_allow_secondary_device_login (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isAllowSecondaryDeviceLogin", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isAllowSecondaryDeviceLogin", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_is_allow_secondary_device_login (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_is_allow_secondary_device_login (iface, error))
    return FALSE;
  if (!call_service_client_recv_is_allow_secondary_device_login (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_primary_client_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPrimaryClientForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPrimaryClientForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_primary_client_for_channel (CallServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPrimaryClientForChannel", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPrimaryClientForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_primary_client_for_channel (CallServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_primary_client_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_primary_client_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_create_room_with_buddy (CallServiceIf * iface, const gint32 reqSeq, const gchar * buddyMid, const GPtrArray * contactIds, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createRoomWithBuddy", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createRoomWithBuddy_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "reqSeq", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, reqSeq, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "buddyMid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, buddyMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "contactIds", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1217;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (contactIds ? contactIds->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1217 = 0; i1217 < (contactIds ? contactIds->len : 0); i1217++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) contactIds, i1217)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_create_room_with_buddy (CallServiceIf * iface, Room ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createRoomWithBuddy", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createRoomWithBuddy", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_create_room_with_buddy (CallServiceIf * iface, Room ** _return, const gint32 reqSeq, const gchar * buddyMid, const GPtrArray * contactIds, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_create_room_with_buddy (iface, reqSeq, buddyMid, contactIds, error))
    return FALSE;
  if (!call_service_client_recv_create_room_with_buddy (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_display_name (CallServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDisplayName", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDisplayName_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_display_name (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDisplayName", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDisplayName", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_display_name (CallServiceIf * iface, gchar ** _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_display_name (iface, mid, error))
    return FALSE;
  if (!call_service_client_recv_get_display_name (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_paid_call_metadata (CallServiceIf * iface, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPaidCallMetadata", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPaidCallMetadata_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_paid_call_metadata (CallServiceIf * iface, PaidCallMetadataResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPaidCallMetadata", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPaidCallMetadata", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_paid_call_metadata (CallServiceIf * iface, PaidCallMetadataResult ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_paid_call_metadata (iface, language, error))
    return FALSE;
  if (!call_service_client_recv_get_paid_call_metadata (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_mid (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getMid", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getMid_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_mid (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getMid", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getMid", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_mid (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_mid (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_mid (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_country_for_billing (CallServiceIf * iface, const gchar * country, const gchar * remoteIp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserCountryForBilling", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserCountryForBilling_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "country", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, country, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "remoteIp", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, remoteIp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_country_for_billing (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserCountryForBilling", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserCountryForBilling", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_country_for_billing (CallServiceIf * iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_country_for_billing (iface, country, remoteIp, error))
    return FALSE;
  if (!call_service_client_recv_get_user_country_for_billing (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_favorite_group_ids_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFavoriteGroupIdsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFavoriteGroupIdsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_favorite_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFavoriteGroupIdsForChannel", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFavoriteGroupIdsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1218 = NULL;
                if (_elem1218 != NULL)
                {
                  g_free(_elem1218);
                  _elem1218 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1218, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1218);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_favorite_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_favorite_group_ids_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_favorite_group_ids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_paid_call_history (CallServiceIf * iface, const gint64 start, const gint32 size, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPaidCallHistory", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPaidCallHistory_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "start", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, start, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "size", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, size, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_paid_call_history (CallServiceIf * iface, PaidCallHistoryResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPaidCallHistory", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPaidCallHistory", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_paid_call_history (CallServiceIf * iface, PaidCallHistoryResult ** _return, const gint64 start, const gint32 size, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_paid_call_history (iface, start, size, language, error))
    return FALSE;
  if (!call_service_client_recv_get_paid_call_history (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_send_pin_code_operation (CallServiceIf * iface, const gchar * verifier, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendPinCodeOperation", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendPinCodeOperation_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifier", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, verifier, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_send_pin_code_operation (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendPinCodeOperation", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendPinCodeOperation", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_send_pin_code_operation (CallServiceIf * iface, const gchar * verifier, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_send_pin_code_operation (iface, verifier, error))
    return FALSE;
  if (!call_service_client_recv_send_pin_code_operation (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_invite_into_group_call (CallServiceIf * iface, const gchar * chatMid, const GPtrArray * memberMids, const GroupCallMediaType mediaType, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "inviteIntoGroupCall", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "inviteIntoGroupCall_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "chatMid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, chatMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "memberMids", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1219;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (memberMids ? memberMids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1219 = 0; i1219 < (memberMids ? memberMids->len : 0); i1219++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) memberMids, i1219)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mediaType", T_I32, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) mediaType, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_invite_into_group_call (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "inviteIntoGroupCall", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected inviteIntoGroupCall", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_invite_into_group_call (CallServiceIf * iface, const gchar * chatMid, const GPtrArray * memberMids, const GroupCallMediaType mediaType, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_invite_into_group_call (iface, chatMid, memberMids, mediaType, error))
    return FALSE;
  if (!call_service_client_recv_invite_into_group_call (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_friend_mids (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFriendMids", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFriendMids_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFriendMids", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFriendMids", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1220 = NULL;
                if (_elem1220 != NULL)
                {
                  g_free(_elem1220);
                  _elem1220 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1220, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1220);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_friend_mids (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_friend_mids (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_meta_profile (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getMetaProfile", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getMetaProfile_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_meta_profile (CallServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getMetaProfile", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getMetaProfile", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_meta_profile (CallServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_meta_profile (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_meta_profile (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_send_message_for_channel (CallServiceIf * iface, const Message * message, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendMessageForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendMessageForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (message), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_send_message_for_channel (CallServiceIf * iface, Message ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendMessageForChannel", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendMessageForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_send_message_for_channel (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_send_message_for_channel (iface, message, error))
    return FALSE;
  if (!call_service_client_recv_send_message_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_active_buddy_subscriber_count (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "activeBuddySubscriberCount", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "activeBuddySubscriberCount_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_active_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "activeBuddySubscriberCount", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected activeBuddySubscriberCount", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_active_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_active_buddy_subscriber_count (iface, error))
    return FALSE;
  if (!call_service_client_recv_active_buddy_subscriber_count (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_call_credit_purchase_history (CallServiceIf * iface, const CoinHistoryCondition * request, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getCallCreditPurchaseHistory", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getCallCreditPurchaseHistory_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (request), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_call_credit_purchase_history (CallServiceIf * iface, CoinHistoryResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getCallCreditPurchaseHistory", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getCallCreditPurchaseHistory", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_call_credit_purchase_history (CallServiceIf * iface, CoinHistoryResult ** _return, const CoinHistoryCondition * request, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_call_credit_purchase_history (iface, request, error))
    return FALSE;
  if (!call_service_client_recv_get_call_credit_purchase_history (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_is_room_member (CallServiceIf * iface, const gchar * roomId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isRoomMember", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isRoomMember_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, roomId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_is_room_member (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isRoomMember", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isRoomMember", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_is_room_member (CallServiceIf * iface, gboolean* _return, const gchar * roomId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_is_room_member (iface, roomId, error))
    return FALSE;
  if (!call_service_client_recv_is_room_member (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_send_system_o_a_message (CallServiceIf * iface, const Message * message, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendSystemOAMessage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendSystemOAMessage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (message), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_send_system_o_a_message (CallServiceIf * iface, Message ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendSystemOAMessage", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendSystemOAMessage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_send_system_o_a_message (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_send_system_o_a_message (iface, message, error))
    return FALSE;
  if (!call_service_client_recv_send_system_o_a_message (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_acquire_paid_call_route (CallServiceIf * iface, const PaidCallType paidCallType, const gchar * dialedNumber, const gchar * language, const gchar * networkCode, const gboolean disableCallerId, const gchar * referer, const gchar * adSessionId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "acquirePaidCallRoute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "acquirePaidCallRoute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "paidCallType", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) paidCallType, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "dialedNumber", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, dialedNumber, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "networkCode", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, networkCode, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "disableCallerId", T_BOOL, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, disableCallerId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "referer", T_STRING, 7, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, referer, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "adSessionId", T_STRING, 8, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, adSessionId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_acquire_paid_call_route (CallServiceIf * iface, PaidCallResponse ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "acquirePaidCallRoute", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected acquirePaidCallRoute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_acquire_paid_call_route (CallServiceIf * iface, PaidCallResponse ** _return, const PaidCallType paidCallType, const gchar * dialedNumber, const gchar * language, const gchar * networkCode, const gboolean disableCallerId, const gchar * referer, const gchar * adSessionId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_acquire_paid_call_route (iface, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId, error))
    return FALSE;
  if (!call_service_client_recv_acquire_paid_call_route (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_groups_for_channel (CallServiceIf * iface, const GPtrArray * groupIds, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupIds", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1221;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (groupIds ? groupIds->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1221 = 0; i1221 < (groupIds ? groupIds->len : 0); i1221++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) groupIds, i1221)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_groups_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupsForChannel", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Group * _elem1222 = NULL;
                if ( _elem1222 != NULL)
                {
                  g_object_unref (_elem1222);
                }
                _elem1222 = g_object_new (TYPE_GROUP, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1222), protocol, error)) < 0)
                {
                  g_object_unref (_elem1222);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1222);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_groups_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_groups_for_channel (iface, groupIds, error))
    return FALSE;
  if (!call_service_client_recv_get_groups_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_create_time (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserCreateTime", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserCreateTime_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_create_time (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserCreateTime", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserCreateTime", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_create_time (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_create_time (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_user_create_time (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_register_channel_c_p (CallServiceIf * iface, const gchar * cpId, const gchar * registerPassword, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "registerChannelCP", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "registerChannelCP_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "cpId", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, cpId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "registerPassword", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, registerPassword, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_register_channel_c_p (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "registerChannelCP", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected registerChannelCP", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_register_channel_c_p (CallServiceIf * iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_register_channel_c_p (iface, cpId, registerPassword, error))
    return FALSE;
  if (!call_service_client_recv_register_channel_c_p (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_reserve_call_credit_purchase (CallServiceIf * iface, const CoinPurchaseReservation * request, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "reserveCallCreditPurchase", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "reserveCallCreditPurchase_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (request), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_reserve_call_credit_purchase (CallServiceIf * iface, PaymentReservationResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "reserveCallCreditPurchase", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected reserveCallCreditPurchase", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_reserve_call_credit_purchase (CallServiceIf * iface, PaymentReservationResult ** _return, const CoinPurchaseReservation * request, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_reserve_call_credit_purchase (iface, request, error))
    return FALSE;
  if (!call_service_client_recv_reserve_call_credit_purchase (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_acquire_paid_call_currency_exchange_rate (CallServiceIf * iface, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "acquirePaidCallCurrencyExchangeRate", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "acquirePaidCallCurrencyExchangeRate_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_acquire_paid_call_currency_exchange_rate (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "acquirePaidCallCurrencyExchangeRate", 35) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected acquirePaidCallCurrencyExchangeRate", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PaidCallCurrencyExchangeRate * _elem1223 = NULL;
                if ( _elem1223 != NULL)
                {
                  g_object_unref (_elem1223);
                }
                _elem1223 = g_object_new (TYPE_PAID_CALL_CURRENCY_EXCHANGE_RATE, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1223), protocol, error)) < 0)
                {
                  g_object_unref (_elem1223);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1223);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_acquire_paid_call_currency_exchange_rate (CallServiceIf * iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_acquire_paid_call_currency_exchange_rate (iface, language, error))
    return FALSE;
  if (!call_service_client_recv_acquire_paid_call_currency_exchange_rate (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_room_member_mids_for_app_platform (CallServiceIf * iface, const gchar * roomId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRoomMemberMidsForAppPlatform", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRoomMemberMidsForAppPlatform_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, roomId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_room_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRoomMemberMidsForAppPlatform", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRoomMemberMidsForAppPlatform", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1224 = NULL;
                if (_elem1224 != NULL)
                {
                  g_free(_elem1224);
                  _elem1224 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1224, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1224);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_room_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, const gchar * roomId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_room_member_mids_for_app_platform (iface, roomId, error))
    return FALSE;
  if (!call_service_client_recv_get_room_member_mids_for_app_platform (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_paid_call_balance_list (CallServiceIf * iface, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPaidCallBalanceList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPaidCallBalanceList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_paid_call_balance_list (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPaidCallBalanceList", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPaidCallBalanceList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PaidCallBalance * _elem1225 = NULL;
                if ( _elem1225 != NULL)
                {
                  g_object_unref (_elem1225);
                }
                _elem1225 = g_object_new (TYPE_PAID_CALL_BALANCE, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1225), protocol, error)) < 0)
                {
                  g_object_unref (_elem1225);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1225);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_paid_call_balance_list (CallServiceIf * iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_paid_call_balance_list (iface, language, error))
    return FALSE;
  if (!call_service_client_recv_get_paid_call_balance_list (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_personal_infos (CallServiceIf * iface, const GHashTable * requiredPersonalInfos, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonalInfos", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonalInfos_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "requiredPersonalInfos", T_SET, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      PersonalInfo* keys;
      int i = 0, key_count;
      PersonalInfo elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, requiredPersonalInfos ? (gint32) g_hash_table_size ((GHashTable *) requiredPersonalInfos) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (requiredPersonalInfos)
        g_hash_table_foreach ((GHashTable *) requiredPersonalInfos, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (PersonalInfo, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (PersonalInfo) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) requiredPersonalInfos), (gpointer) elem);

        if ((ret = thrift_protocol_write_i32 (protocol, (gint32) elem, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_personal_infos (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonalInfos", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonalInfos", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                PersonalInfo key1226;
                gchar * val1227 = NULL;
                gint32 ecast1228;
                if ((ret = thrift_protocol_read_i32 (protocol, &ecast1228, error)) < 0)
                  return 0;
                xfer += ret;
                key1226 = (PersonalInfo)ecast1228;
                if (val1227 != NULL)
                {
                  g_free(val1227);
                  val1227 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val1227, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key1226)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key1226, (gpointer) val1227);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_personal_infos (CallServiceIf * iface, GHashTable ** _return, const GHashTable * requiredPersonalInfos, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_personal_infos (iface, requiredPersonalInfos, error))
    return FALSE;
  if (!call_service_client_recv_get_personal_infos (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_primary_clients_for_channel (CallServiceIf * iface, const GPtrArray * userMids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPrimaryClientsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPrimaryClientsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userMids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1229;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (userMids ? userMids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1229 = 0; i1229 < (userMids ? userMids->len : 0); i1229++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) userMids, i1229)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_primary_clients_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPrimaryClientsForChannel", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPrimaryClientsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelClient * _elem1230 = NULL;
                if ( _elem1230 != NULL)
                {
                  g_object_unref (_elem1230);
                }
                _elem1230 = g_object_new (TYPE_SIMPLE_CHANNEL_CLIENT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1230), protocol, error)) < 0)
                {
                  g_object_unref (_elem1230);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1230);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_primary_clients_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_primary_clients_for_channel (iface, userMids, error))
    return FALSE;
  if (!call_service_client_recv_get_primary_clients_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_add_buddy_to_contact (CallServiceIf * iface, const gchar * buddyMid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addBuddyToContact", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addBuddyToContact_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "buddyMid", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, buddyMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_add_buddy_to_contact (CallServiceIf * iface, ContactTransition ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addBuddyToContact", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addBuddyToContact", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_add_buddy_to_contact (CallServiceIf * iface, ContactTransition ** _return, const gchar * buddyMid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_add_buddy_to_contact (iface, buddyMid, error))
    return FALSE;
  if (!call_service_client_recv_add_buddy_to_contact (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_group_member_mids_for_app_platform (CallServiceIf * iface, const gchar * groupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupMemberMidsForAppPlatform", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupMemberMidsForAppPlatform_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_group_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupMemberMidsForAppPlatform", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupMemberMidsForAppPlatform", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1231 = NULL;
                if (_elem1231 != NULL)
                {
                  g_free(_elem1231);
                  _elem1231 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1231, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1231);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_group_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_group_member_mids_for_app_platform (iface, groupId, error))
    return FALSE;
  if (!call_service_client_recv_get_group_member_mids_for_app_platform (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_language (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserLanguage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserLanguage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_language (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserLanguage", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserLanguage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_language (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_language (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_user_language (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_lookup_paid_call (CallServiceIf * iface, const gchar * dialedNumber, const gchar * language, const gchar * referer, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "lookupPaidCall", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "lookupPaidCall_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "dialedNumber", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, dialedNumber, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "referer", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, referer, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_lookup_paid_call (CallServiceIf * iface, PaidCallResponse ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "lookupPaidCall", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected lookupPaidCall", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_lookup_paid_call (CallServiceIf * iface, PaidCallResponse ** _return, const gchar * dialedNumber, const gchar * language, const gchar * referer, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_lookup_paid_call (iface, dialedNumber, language, referer, error))
    return FALSE;
  if (!call_service_client_recv_lookup_paid_call (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_extended_profile (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getExtendedProfile", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getExtendedProfile_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_extended_profile (CallServiceIf * iface, ExtendedProfile ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getExtendedProfile", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getExtendedProfile", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_extended_profile (CallServiceIf * iface, ExtendedProfile ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_extended_profile (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_extended_profile (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_reverse_compact_contacts (CallServiceIf * iface, const GPtrArray * ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getReverseCompactContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getReverseCompactContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1232;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (ids ? ids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1232 = 0; i1232 < (ids ? ids->len : 0); i1232++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ids, i1232)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_reverse_compact_contacts (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getReverseCompactContacts", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getReverseCompactContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key1233 = NULL;
                CompactContact * val1234 = NULL;
                if (key1233 != NULL)
                {
                  g_free(key1233);
                  key1233 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key1233, error)) < 0)
                  return 0;
                xfer += ret;
                if ( val1234 != NULL)
                {
                  g_object_unref (val1234);
                }
                val1234 = g_object_new (TYPE_COMPACT_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (val1234), protocol, error)) < 0)
                {
                  g_object_unref (val1234);
                  return 0;
                }
                xfer += ret;
                if (*_return && key1233)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key1233, (gpointer) val1234);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_reverse_compact_contacts (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_reverse_compact_contacts (iface, ids, error))
    return FALSE;
  if (!call_service_client_recv_get_reverse_compact_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_paid_call_ad_status (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPaidCallAdStatus", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPaidCallAdStatus_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_paid_call_ad_status (CallServiceIf * iface, PaidCallAdResult ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPaidCallAdStatus", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPaidCallAdStatus", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_paid_call_ad_status (CallServiceIf * iface, PaidCallAdResult ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_paid_call_ad_status (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_paid_call_ad_status (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_find_contact_by_userid_without_abuse_block_for_channel (CallServiceIf * iface, const gchar * userid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findContactByUseridWithoutAbuseBlockForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findContactByUseridWithoutAbuseBlockForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, userid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_find_contact_by_userid_without_abuse_block_for_channel (CallServiceIf * iface, Contact ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findContactByUseridWithoutAbuseBlockForChannel", 46) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findContactByUseridWithoutAbuseBlockForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_find_contact_by_userid_without_abuse_block_for_channel (CallServiceIf * iface, Contact ** _return, const gchar * userid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_find_contact_by_userid_without_abuse_block_for_channel (iface, userid, error))
    return FALSE;
  if (!call_service_client_recv_find_contact_by_userid_without_abuse_block_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_group_member_mids (CallServiceIf * iface, const gchar * groupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupMemberMids", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupMemberMids_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_group_member_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupMemberMids", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupMemberMids", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1235 = NULL;
                if (_elem1235 != NULL)
                {
                  g_free(_elem1235);
                  _elem1235 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1235, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1235);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_group_member_mids (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_group_member_mids (iface, groupId, error))
    return FALSE;
  if (!call_service_client_recv_get_group_member_mids (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_send_message_without_relationship (CallServiceIf * iface, const Message * message, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendMessageWithoutRelationship", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendMessageWithoutRelationship_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (message), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_send_message_without_relationship (CallServiceIf * iface, Message ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendMessageWithoutRelationship", 30) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendMessageWithoutRelationship", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_send_message_without_relationship (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_send_message_without_relationship (iface, message, error))
    return FALSE;
  if (!call_service_client_recv_send_message_without_relationship (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_display_buddy_subscriber_count_in_bulk (CallServiceIf * iface, const GPtrArray * mids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "displayBuddySubscriberCountInBulk", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "displayBuddySubscriberCountInBulk_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1236;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (mids ? mids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1236 = 0; i1236 < (mids ? mids->len : 0); i1236++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) mids, i1236)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_display_buddy_subscriber_count_in_bulk (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "displayBuddySubscriberCountInBulk", 33) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected displayBuddySubscriberCountInBulk", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key1237 = NULL;
                gint64* val1238 = g_new (gint64, 1);
                if (key1237 != NULL)
                {
                  g_free(key1237);
                  key1237 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key1237, error)) < 0)
                  return 0;
                xfer += ret;
                if ((ret = thrift_protocol_read_i64 (protocol, &*val1238, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key1237)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key1237, (gpointer) val1238);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_display_buddy_subscriber_count_in_bulk (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_display_buddy_subscriber_count_in_bulk (iface, mids, error))
    return FALSE;
  if (!call_service_client_recv_display_buddy_subscriber_count_in_bulk (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_lookup_room_members (CallServiceIf * iface, const gchar * roomId, const GPtrArray * mids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "lookupRoomMembers", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "lookupRoomMembers_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "roomId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, roomId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1239;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (mids ? mids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1239 = 0; i1239 < (mids ? mids->len : 0); i1239++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) mids, i1239)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_lookup_room_members (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "lookupRoomMembers", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected lookupRoomMembers", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelContact * _elem1240 = NULL;
                if ( _elem1240 != NULL)
                {
                  g_object_unref (_elem1240);
                }
                _elem1240 = g_object_new (TYPE_SIMPLE_CHANNEL_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1240), protocol, error)) < 0)
                {
                  g_object_unref (_elem1240);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1240);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_lookup_room_members (CallServiceIf * iface, GPtrArray ** _return, const gchar * roomId, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_lookup_room_members (iface, roomId, mids, error))
    return FALSE;
  if (!call_service_client_recv_lookup_room_members (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_favorite_mids_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFavoriteMidsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFavoriteMidsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_favorite_mids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFavoriteMidsForChannel", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFavoriteMidsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1241 = NULL;
                if (_elem1241 != NULL)
                {
                  g_free(_elem1241);
                  _elem1241 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1241, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1241);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_favorite_mids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_favorite_mids_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_favorite_mids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_all_contact_ids_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getAllContactIdsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getAllContactIdsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_all_contact_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getAllContactIdsForChannel", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getAllContactIdsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1242 = NULL;
                if (_elem1242 != NULL)
                {
                  g_free(_elem1242);
                  _elem1242 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1242, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1242);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_all_contact_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_all_contact_ids_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_all_contact_ids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_display_buddy_subscriber_count (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "displayBuddySubscriberCount", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "displayBuddySubscriberCount_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_display_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "displayBuddySubscriberCount", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected displayBuddySubscriberCount", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_display_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_display_buddy_subscriber_count (iface, error))
    return FALSE;
  if (!call_service_client_recv_display_buddy_subscriber_count (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_profile_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getProfileForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getProfileForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_profile_for_channel (CallServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getProfileForChannel", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getProfileForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_profile_for_channel (CallServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_profile_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_profile_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_tickets (CallServiceIf * iface, const GPtrArray * userMids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserTickets", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserTickets_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userMids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1243;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (userMids ? userMids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1243 = 0; i1243 < (userMids ? userMids->len : 0); i1243++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) userMids, i1243)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_tickets (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserTickets", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserTickets", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                UserTicketResponse * _elem1244 = NULL;
                if ( _elem1244 != NULL)
                {
                  g_object_unref (_elem1244);
                }
                _elem1244 = g_object_new (TYPE_USER_TICKET_RESPONSE, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1244), protocol, error)) < 0)
                {
                  g_object_unref (_elem1244);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1244);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_tickets (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_tickets (iface, userMids, error))
    return FALSE;
  if (!call_service_client_recv_get_user_tickets (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_o_a_friend_mids (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getOAFriendMids", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getOAFriendMids_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_o_a_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getOAFriendMids", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getOAFriendMids", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1245 = NULL;
                if (_elem1245 != NULL)
                {
                  g_free(_elem1245);
                  _elem1245 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1245, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1245);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_o_a_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_o_a_friend_mids (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_o_a_friend_mids (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_search_paid_call_user_rate (CallServiceIf * iface, const gchar * countryCode, const gchar * language, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "searchPaidCallUserRate", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "searchPaidCallUserRate_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "countryCode", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, countryCode, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "language", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, language, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_search_paid_call_user_rate (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "searchPaidCallUserRate", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected searchPaidCallUserRate", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PaidCallUserRate * _elem1246 = NULL;
                if ( _elem1246 != NULL)
                {
                  g_object_unref (_elem1246);
                }
                _elem1246 = g_object_new (TYPE_PAID_CALL_USER_RATE, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1246), protocol, error)) < 0)
                {
                  g_object_unref (_elem1246);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1246);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_search_paid_call_user_rate (CallServiceIf * iface, GPtrArray ** _return, const gchar * countryCode, const gchar * language, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_search_paid_call_user_rate (iface, countryCode, language, error))
    return FALSE;
  if (!call_service_client_recv_search_paid_call_user_rate (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_joined_group_ids_for_channel (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getJoinedGroupIdsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getJoinedGroupIdsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_joined_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getJoinedGroupIdsForChannel", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getJoinedGroupIdsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1247 = NULL;
                if (_elem1247 != NULL)
                {
                  g_free(_elem1247);
                  _elem1247 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1247, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1247);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_joined_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_joined_group_ids_for_channel (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_joined_group_ids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_acquire_group_call_route (CallServiceIf * iface, const gchar * chatMid, const GroupCallMediaType mediaType, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "acquireGroupCallRoute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "acquireGroupCallRoute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "chatMid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, chatMid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mediaType", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) mediaType, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_acquire_group_call_route (CallServiceIf * iface, GroupCallRoute ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "acquireGroupCallRoute", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected acquireGroupCallRoute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_acquire_group_call_route (CallServiceIf * iface, GroupCallRoute ** _return, const gchar * chatMid, const GroupCallMediaType mediaType, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_acquire_group_call_route (iface, chatMid, mediaType, error))
    return FALSE;
  if (!call_service_client_recv_acquire_group_call_route (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_mids_who_added_me (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserMidsWhoAddedMe", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserMidsWhoAddedMe_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_mids_who_added_me (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserMidsWhoAddedMe", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserMidsWhoAddedMe", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem1248 = NULL;
                if (_elem1248 != NULL)
                {
                  g_free(_elem1248);
                  _elem1248 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem1248, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem1248);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_mids_who_added_me (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_mids_who_added_me (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_user_mids_who_added_me (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_identity_credential (CallServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getIdentityCredential", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getIdentityCredential_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_identity_credential (CallServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getIdentityCredential", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getIdentityCredential", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_identity_credential (CallServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_identity_credential (iface, error))
    return FALSE;
  if (!call_service_client_recv_get_identity_credential (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_add_operation_for_channel (CallServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addOperationForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addOperationForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "opType", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) opType, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param1", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param1, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param2", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param2, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param3", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param3, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_add_operation_for_channel (CallServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addOperationForChannel", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addOperationForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_add_operation_for_channel (CallServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_add_operation_for_channel (iface, opType, param1, param2, param3, error))
    return FALSE;
  if (!call_service_client_recv_add_operation_for_channel (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_simple_channel_contacts (CallServiceIf * iface, const GPtrArray * ids, const gboolean statusSticonFallbackDisabled, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSimpleChannelContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSimpleChannelContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i1249;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (ids ? ids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i1249 = 0; i1249 < (ids ? ids->len : 0); i1249++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ids, i1249)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "statusSticonFallbackDisabled", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, statusSticonFallbackDisabled, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSimpleChannelContacts", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSimpleChannelContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelContact * _elem1250 = NULL;
                if ( _elem1250 != NULL)
                {
                  g_object_unref (_elem1250);
                }
                _elem1250 = g_object_new (TYPE_SIMPLE_CHANNEL_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1250), protocol, error)) < 0)
                {
                  g_object_unref (_elem1250);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem1250);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_simple_channel_contacts (iface, ids, statusSticonFallbackDisabled, error))
    return FALSE;
  if (!call_service_client_recv_get_simple_channel_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean call_service_client_send_get_user_last_sent_message_time_stamp (CallServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserLastSentMessageTimeStamp", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserLastSentMessageTimeStamp_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean call_service_client_recv_get_user_last_sent_message_time_stamp (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CALL_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserLastSentMessageTimeStamp", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserLastSentMessageTimeStamp", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean call_service_client_get_user_last_sent_message_time_stamp (CallServiceIf * iface, gint64* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!call_service_client_send_get_user_last_sent_message_time_stamp (iface, mid, error))
    return FALSE;
  if (!call_service_client_recv_get_user_last_sent_message_time_stamp (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

static void
call_service_if_interface_init (CallServiceIfInterface *iface)
{
  iface->get_user_status = call_service_client_get_user_status;
  iface->update_profile_attribute_for_channel = call_service_client_update_profile_attribute_for_channel;
  iface->update_extended_profile_attribute = call_service_client_update_extended_profile_attribute;
  iface->get_all_simple_channel_contacts = call_service_client_get_all_simple_channel_contacts;
  iface->get_user_identities = call_service_client_get_user_identities;
  iface->mark_paid_call_ad = call_service_client_mark_paid_call_ad;
  iface->is_group_member = call_service_client_is_group_member;
  iface->get_phone_info_from_phone_number = call_service_client_get_phone_info_from_phone_number;
  iface->redeem_paid_call_voucher = call_service_client_redeem_paid_call_voucher;
  iface->get_preferred_display_name = call_service_client_get_preferred_display_name;
  iface->get_contacts_for_channel = call_service_client_get_contacts_for_channel;
  iface->get_call_credit_products = call_service_client_get_call_credit_products;
  iface->get_compact_contacts = call_service_client_get_compact_contacts;
  iface->notify_noti_center_event = call_service_client_notify_noti_center_event;
  iface->is_in_contact = call_service_client_is_in_contact;
  iface->lookup_group_members = call_service_client_lookup_group_members;
  iface->get_room_information = call_service_client_get_room_information;
  iface->get_group_call = call_service_client_get_group_call;
  iface->is_allow_secondary_device_login = call_service_client_is_allow_secondary_device_login;
  iface->get_primary_client_for_channel = call_service_client_get_primary_client_for_channel;
  iface->create_room_with_buddy = call_service_client_create_room_with_buddy;
  iface->get_display_name = call_service_client_get_display_name;
  iface->get_paid_call_metadata = call_service_client_get_paid_call_metadata;
  iface->get_mid = call_service_client_get_mid;
  iface->get_user_country_for_billing = call_service_client_get_user_country_for_billing;
  iface->get_favorite_group_ids_for_channel = call_service_client_get_favorite_group_ids_for_channel;
  iface->get_paid_call_history = call_service_client_get_paid_call_history;
  iface->send_pin_code_operation = call_service_client_send_pin_code_operation;
  iface->invite_into_group_call = call_service_client_invite_into_group_call;
  iface->get_friend_mids = call_service_client_get_friend_mids;
  iface->get_meta_profile = call_service_client_get_meta_profile;
  iface->send_message_for_channel = call_service_client_send_message_for_channel;
  iface->active_buddy_subscriber_count = call_service_client_active_buddy_subscriber_count;
  iface->get_call_credit_purchase_history = call_service_client_get_call_credit_purchase_history;
  iface->is_room_member = call_service_client_is_room_member;
  iface->send_system_o_a_message = call_service_client_send_system_o_a_message;
  iface->acquire_paid_call_route = call_service_client_acquire_paid_call_route;
  iface->get_groups_for_channel = call_service_client_get_groups_for_channel;
  iface->get_user_create_time = call_service_client_get_user_create_time;
  iface->register_channel_c_p = call_service_client_register_channel_c_p;
  iface->reserve_call_credit_purchase = call_service_client_reserve_call_credit_purchase;
  iface->acquire_paid_call_currency_exchange_rate = call_service_client_acquire_paid_call_currency_exchange_rate;
  iface->get_room_member_mids_for_app_platform = call_service_client_get_room_member_mids_for_app_platform;
  iface->get_paid_call_balance_list = call_service_client_get_paid_call_balance_list;
  iface->get_personal_infos = call_service_client_get_personal_infos;
  iface->get_primary_clients_for_channel = call_service_client_get_primary_clients_for_channel;
  iface->add_buddy_to_contact = call_service_client_add_buddy_to_contact;
  iface->get_group_member_mids_for_app_platform = call_service_client_get_group_member_mids_for_app_platform;
  iface->get_user_language = call_service_client_get_user_language;
  iface->lookup_paid_call = call_service_client_lookup_paid_call;
  iface->get_extended_profile = call_service_client_get_extended_profile;
  iface->get_reverse_compact_contacts = call_service_client_get_reverse_compact_contacts;
  iface->get_paid_call_ad_status = call_service_client_get_paid_call_ad_status;
  iface->find_contact_by_userid_without_abuse_block_for_channel = call_service_client_find_contact_by_userid_without_abuse_block_for_channel;
  iface->get_group_member_mids = call_service_client_get_group_member_mids;
  iface->send_message_without_relationship = call_service_client_send_message_without_relationship;
  iface->display_buddy_subscriber_count_in_bulk = call_service_client_display_buddy_subscriber_count_in_bulk;
  iface->lookup_room_members = call_service_client_lookup_room_members;
  iface->get_favorite_mids_for_channel = call_service_client_get_favorite_mids_for_channel;
  iface->get_all_contact_ids_for_channel = call_service_client_get_all_contact_ids_for_channel;
  iface->display_buddy_subscriber_count = call_service_client_display_buddy_subscriber_count;
  iface->get_profile_for_channel = call_service_client_get_profile_for_channel;
  iface->get_user_tickets = call_service_client_get_user_tickets;
  iface->get_o_a_friend_mids = call_service_client_get_o_a_friend_mids;
  iface->search_paid_call_user_rate = call_service_client_search_paid_call_user_rate;
  iface->get_joined_group_ids_for_channel = call_service_client_get_joined_group_ids_for_channel;
  iface->acquire_group_call_route = call_service_client_acquire_group_call_route;
  iface->get_user_mids_who_added_me = call_service_client_get_user_mids_who_added_me;
  iface->get_identity_credential = call_service_client_get_identity_credential;
  iface->add_operation_for_channel = call_service_client_add_operation_for_channel;
  iface->get_simple_channel_contacts = call_service_client_get_simple_channel_contacts;
  iface->get_user_last_sent_message_time_stamp = call_service_client_get_user_last_sent_message_time_stamp;
}

static void
call_service_client_init (CallServiceClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
call_service_client_class_init (CallServiceClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = call_service_client_set_property;
  gobject_class->get_property = call_service_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CALL_SERVICE_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CALL_SERVICE_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
call_service_handler_call_service_if_interface_init (CallServiceIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (CallServiceHandler, 
                         call_service_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_CALL_SERVICE_IF,
                                                call_service_handler_call_service_if_interface_init))

gboolean call_service_handler_get_user_status (CallServiceIf * iface, UserStatus* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_status (iface, _return, mid, e, error);
}

gboolean call_service_handler_update_profile_attribute_for_channel (CallServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->update_profile_attribute_for_channel (iface, profileAttribute, value, e, error);
}

gboolean call_service_handler_update_extended_profile_attribute (CallServiceIf * iface, const ExtendedProfileAttribute attr, const ExtendedProfile * extendedProfile, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->update_extended_profile_attribute (iface, attr, extendedProfile, e, error);
}

gboolean call_service_handler_get_all_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_all_simple_channel_contacts (iface, _return, statusSticonFallbackDisabled, e, error);
}

gboolean call_service_handler_get_user_identities (CallServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_identities (iface, _return, e, error);
}

gboolean call_service_handler_mark_paid_call_ad (CallServiceIf * iface, PaidCallDialing ** _return, const gchar * dialedNumber, const gchar * language, const gboolean disableCallerId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->mark_paid_call_ad (iface, _return, dialedNumber, language, disableCallerId, e, error);
}

gboolean call_service_handler_is_group_member (CallServiceIf * iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->is_group_member (iface, _return, groupId, e, error);
}

gboolean call_service_handler_get_phone_info_from_phone_number (CallServiceIf * iface, PhoneInfoForChannel ** _return, const gchar * region, const gchar * phoneNumber, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_phone_info_from_phone_number (iface, _return, region, phoneNumber, e, error);
}

gboolean call_service_handler_redeem_paid_call_voucher (CallServiceIf * iface, PaidCallRedeemResult ** _return, const gchar * serial, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->redeem_paid_call_voucher (iface, _return, serial, language, e, error);
}

gboolean call_service_handler_get_preferred_display_name (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_preferred_display_name (iface, _return, mids, e, error);
}

gboolean call_service_handler_get_contacts_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_contacts_for_channel (iface, _return, ids, e, error);
}

gboolean call_service_handler_get_call_credit_products (CallServiceIf * iface, GPtrArray ** _return, const PaymentType appStoreCode, const PaymentPgType pgCode, const gchar * country, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_call_credit_products (iface, _return, appStoreCode, pgCode, country, language, e, error);
}

gboolean call_service_handler_get_compact_contacts (CallServiceIf * iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_compact_contacts (iface, _return, lastModifiedTimestamp, e, error);
}

gboolean call_service_handler_notify_noti_center_event (CallServiceIf * iface, const NotiCenterEventData * event, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->notify_noti_center_event (iface, event, e, error);
}

gboolean call_service_handler_is_in_contact (CallServiceIf * iface, gboolean* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->is_in_contact (iface, _return, mid, e, error);
}

gboolean call_service_handler_lookup_group_members (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->lookup_group_members (iface, _return, groupId, mids, e, error);
}

gboolean call_service_handler_get_room_information (CallServiceIf * iface, Room ** _return, const gchar * roomMid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_room_information (iface, _return, roomMid, e, error);
}

gboolean call_service_handler_get_group_call (CallServiceIf * iface, GroupCall ** _return, const gchar * chatMid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_group_call (iface, _return, chatMid, e, error);
}

gboolean call_service_handler_is_allow_secondary_device_login (CallServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->is_allow_secondary_device_login (iface, _return, e, error);
}

gboolean call_service_handler_get_primary_client_for_channel (CallServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_primary_client_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_create_room_with_buddy (CallServiceIf * iface, Room ** _return, const gint32 reqSeq, const gchar * buddyMid, const GPtrArray * contactIds, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->create_room_with_buddy (iface, _return, reqSeq, buddyMid, contactIds, e, error);
}

gboolean call_service_handler_get_display_name (CallServiceIf * iface, gchar ** _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_display_name (iface, _return, mid, e, error);
}

gboolean call_service_handler_get_paid_call_metadata (CallServiceIf * iface, PaidCallMetadataResult ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_paid_call_metadata (iface, _return, language, e, error);
}

gboolean call_service_handler_get_mid (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_mid (iface, _return, e, error);
}

gboolean call_service_handler_get_user_country_for_billing (CallServiceIf * iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_country_for_billing (iface, _return, country, remoteIp, e, error);
}

gboolean call_service_handler_get_favorite_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_favorite_group_ids_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_get_paid_call_history (CallServiceIf * iface, PaidCallHistoryResult ** _return, const gint64 start, const gint32 size, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_paid_call_history (iface, _return, start, size, language, e, error);
}

gboolean call_service_handler_send_pin_code_operation (CallServiceIf * iface, const gchar * verifier, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->send_pin_code_operation (iface, verifier, e, error);
}

gboolean call_service_handler_invite_into_group_call (CallServiceIf * iface, const gchar * chatMid, const GPtrArray * memberMids, const GroupCallMediaType mediaType, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->invite_into_group_call (iface, chatMid, memberMids, mediaType, e, error);
}

gboolean call_service_handler_get_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_friend_mids (iface, _return, e, error);
}

gboolean call_service_handler_get_meta_profile (CallServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_meta_profile (iface, _return, e, error);
}

gboolean call_service_handler_send_message_for_channel (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->send_message_for_channel (iface, _return, message, e, error);
}

gboolean call_service_handler_active_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->active_buddy_subscriber_count (iface, _return, e, error);
}

gboolean call_service_handler_get_call_credit_purchase_history (CallServiceIf * iface, CoinHistoryResult ** _return, const CoinHistoryCondition * request, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_call_credit_purchase_history (iface, _return, request, e, error);
}

gboolean call_service_handler_is_room_member (CallServiceIf * iface, gboolean* _return, const gchar * roomId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->is_room_member (iface, _return, roomId, e, error);
}

gboolean call_service_handler_send_system_o_a_message (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->send_system_o_a_message (iface, _return, message, e, error);
}

gboolean call_service_handler_acquire_paid_call_route (CallServiceIf * iface, PaidCallResponse ** _return, const PaidCallType paidCallType, const gchar * dialedNumber, const gchar * language, const gchar * networkCode, const gboolean disableCallerId, const gchar * referer, const gchar * adSessionId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->acquire_paid_call_route (iface, _return, paidCallType, dialedNumber, language, networkCode, disableCallerId, referer, adSessionId, e, error);
}

gboolean call_service_handler_get_groups_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_groups_for_channel (iface, _return, groupIds, e, error);
}

gboolean call_service_handler_get_user_create_time (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_create_time (iface, _return, e, error);
}

gboolean call_service_handler_register_channel_c_p (CallServiceIf * iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->register_channel_c_p (iface, _return, cpId, registerPassword, e, error);
}

gboolean call_service_handler_reserve_call_credit_purchase (CallServiceIf * iface, PaymentReservationResult ** _return, const CoinPurchaseReservation * request, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->reserve_call_credit_purchase (iface, _return, request, e, error);
}

gboolean call_service_handler_acquire_paid_call_currency_exchange_rate (CallServiceIf * iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->acquire_paid_call_currency_exchange_rate (iface, _return, language, e, error);
}

gboolean call_service_handler_get_room_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, const gchar * roomId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_room_member_mids_for_app_platform (iface, _return, roomId, e, error);
}

gboolean call_service_handler_get_paid_call_balance_list (CallServiceIf * iface, GPtrArray ** _return, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_paid_call_balance_list (iface, _return, language, e, error);
}

gboolean call_service_handler_get_personal_infos (CallServiceIf * iface, GHashTable ** _return, const GHashTable * requiredPersonalInfos, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_personal_infos (iface, _return, requiredPersonalInfos, e, error);
}

gboolean call_service_handler_get_primary_clients_for_channel (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_primary_clients_for_channel (iface, _return, userMids, e, error);
}

gboolean call_service_handler_add_buddy_to_contact (CallServiceIf * iface, ContactTransition ** _return, const gchar * buddyMid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->add_buddy_to_contact (iface, _return, buddyMid, e, error);
}

gboolean call_service_handler_get_group_member_mids_for_app_platform (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_group_member_mids_for_app_platform (iface, _return, groupId, e, error);
}

gboolean call_service_handler_get_user_language (CallServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_language (iface, _return, e, error);
}

gboolean call_service_handler_lookup_paid_call (CallServiceIf * iface, PaidCallResponse ** _return, const gchar * dialedNumber, const gchar * language, const gchar * referer, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->lookup_paid_call (iface, _return, dialedNumber, language, referer, e, error);
}

gboolean call_service_handler_get_extended_profile (CallServiceIf * iface, ExtendedProfile ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_extended_profile (iface, _return, e, error);
}

gboolean call_service_handler_get_reverse_compact_contacts (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_reverse_compact_contacts (iface, _return, ids, e, error);
}

gboolean call_service_handler_get_paid_call_ad_status (CallServiceIf * iface, PaidCallAdResult ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_paid_call_ad_status (iface, _return, e, error);
}

gboolean call_service_handler_find_contact_by_userid_without_abuse_block_for_channel (CallServiceIf * iface, Contact ** _return, const gchar * userid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->find_contact_by_userid_without_abuse_block_for_channel (iface, _return, userid, e, error);
}

gboolean call_service_handler_get_group_member_mids (CallServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_group_member_mids (iface, _return, groupId, e, error);
}

gboolean call_service_handler_send_message_without_relationship (CallServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->send_message_without_relationship (iface, _return, message, e, error);
}

gboolean call_service_handler_display_buddy_subscriber_count_in_bulk (CallServiceIf * iface, GHashTable ** _return, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->display_buddy_subscriber_count_in_bulk (iface, _return, mids, e, error);
}

gboolean call_service_handler_lookup_room_members (CallServiceIf * iface, GPtrArray ** _return, const gchar * roomId, const GPtrArray * mids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->lookup_room_members (iface, _return, roomId, mids, e, error);
}

gboolean call_service_handler_get_favorite_mids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_favorite_mids_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_get_all_contact_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_all_contact_ids_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_display_buddy_subscriber_count (CallServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->display_buddy_subscriber_count (iface, _return, e, error);
}

gboolean call_service_handler_get_profile_for_channel (CallServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_profile_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_get_user_tickets (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * userMids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_tickets (iface, _return, userMids, e, error);
}

gboolean call_service_handler_get_o_a_friend_mids (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_o_a_friend_mids (iface, _return, e, error);
}

gboolean call_service_handler_search_paid_call_user_rate (CallServiceIf * iface, GPtrArray ** _return, const gchar * countryCode, const gchar * language, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->search_paid_call_user_rate (iface, _return, countryCode, language, e, error);
}

gboolean call_service_handler_get_joined_group_ids_for_channel (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_joined_group_ids_for_channel (iface, _return, e, error);
}

gboolean call_service_handler_acquire_group_call_route (CallServiceIf * iface, GroupCallRoute ** _return, const gchar * chatMid, const GroupCallMediaType mediaType, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->acquire_group_call_route (iface, _return, chatMid, mediaType, e, error);
}

gboolean call_service_handler_get_user_mids_who_added_me (CallServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_mids_who_added_me (iface, _return, e, error);
}

gboolean call_service_handler_get_identity_credential (CallServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_identity_credential (iface, _return, e, error);
}

gboolean call_service_handler_add_operation_for_channel (CallServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->add_operation_for_channel (iface, opType, param1, param2, param3, e, error);
}

gboolean call_service_handler_get_simple_channel_contacts (CallServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, const gboolean statusSticonFallbackDisabled, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_simple_channel_contacts (iface, _return, ids, statusSticonFallbackDisabled, e, error);
}

gboolean call_service_handler_get_user_last_sent_message_time_stamp (CallServiceIf * iface, gint64* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CALL_SERVICE_HANDLER (iface), FALSE);

  return CALL_SERVICE_HANDLER_GET_CLASS (iface)->get_user_last_sent_message_time_stamp (iface, _return, mid, e, error);
}

static void
call_service_handler_call_service_if_interface_init (CallServiceIfInterface *iface)
{
  iface->get_user_status = call_service_handler_get_user_status;
  iface->update_profile_attribute_for_channel = call_service_handler_update_profile_attribute_for_channel;
  iface->update_extended_profile_attribute = call_service_handler_update_extended_profile_attribute;
  iface->get_all_simple_channel_contacts = call_service_handler_get_all_simple_channel_contacts;
  iface->get_user_identities = call_service_handler_get_user_identities;
  iface->mark_paid_call_ad = call_service_handler_mark_paid_call_ad;
  iface->is_group_member = call_service_handler_is_group_member;
  iface->get_phone_info_from_phone_number = call_service_handler_get_phone_info_from_phone_number;
  iface->redeem_paid_call_voucher = call_service_handler_redeem_paid_call_voucher;
  iface->get_preferred_display_name = call_service_handler_get_preferred_display_name;
  iface->get_contacts_for_channel = call_service_handler_get_contacts_for_channel;
  iface->get_call_credit_products = call_service_handler_get_call_credit_products;
  iface->get_compact_contacts = call_service_handler_get_compact_contacts;
  iface->notify_noti_center_event = call_service_handler_notify_noti_center_event;
  iface->is_in_contact = call_service_handler_is_in_contact;
  iface->lookup_group_members = call_service_handler_lookup_group_members;
  iface->get_room_information = call_service_handler_get_room_information;
  iface->get_group_call = call_service_handler_get_group_call;
  iface->is_allow_secondary_device_login = call_service_handler_is_allow_secondary_device_login;
  iface->get_primary_client_for_channel = call_service_handler_get_primary_client_for_channel;
  iface->create_room_with_buddy = call_service_handler_create_room_with_buddy;
  iface->get_display_name = call_service_handler_get_display_name;
  iface->get_paid_call_metadata = call_service_handler_get_paid_call_metadata;
  iface->get_mid = call_service_handler_get_mid;
  iface->get_user_country_for_billing = call_service_handler_get_user_country_for_billing;
  iface->get_favorite_group_ids_for_channel = call_service_handler_get_favorite_group_ids_for_channel;
  iface->get_paid_call_history = call_service_handler_get_paid_call_history;
  iface->send_pin_code_operation = call_service_handler_send_pin_code_operation;
  iface->invite_into_group_call = call_service_handler_invite_into_group_call;
  iface->get_friend_mids = call_service_handler_get_friend_mids;
  iface->get_meta_profile = call_service_handler_get_meta_profile;
  iface->send_message_for_channel = call_service_handler_send_message_for_channel;
  iface->active_buddy_subscriber_count = call_service_handler_active_buddy_subscriber_count;
  iface->get_call_credit_purchase_history = call_service_handler_get_call_credit_purchase_history;
  iface->is_room_member = call_service_handler_is_room_member;
  iface->send_system_o_a_message = call_service_handler_send_system_o_a_message;
  iface->acquire_paid_call_route = call_service_handler_acquire_paid_call_route;
  iface->get_groups_for_channel = call_service_handler_get_groups_for_channel;
  iface->get_user_create_time = call_service_handler_get_user_create_time;
  iface->register_channel_c_p = call_service_handler_register_channel_c_p;
  iface->reserve_call_credit_purchase = call_service_handler_reserve_call_credit_purchase;
  iface->acquire_paid_call_currency_exchange_rate = call_service_handler_acquire_paid_call_currency_exchange_rate;
  iface->get_room_member_mids_for_app_platform = call_service_handler_get_room_member_mids_for_app_platform;
  iface->get_paid_call_balance_list = call_service_handler_get_paid_call_balance_list;
  iface->get_personal_infos = call_service_handler_get_personal_infos;
  iface->get_primary_clients_for_channel = call_service_handler_get_primary_clients_for_channel;
  iface->add_buddy_to_contact = call_service_handler_add_buddy_to_contact;
  iface->get_group_member_mids_for_app_platform = call_service_handler_get_group_member_mids_for_app_platform;
  iface->get_user_language = call_service_handler_get_user_language;
  iface->lookup_paid_call = call_service_handler_lookup_paid_call;
  iface->get_extended_profile = call_service_handler_get_extended_profile;
  iface->get_reverse_compact_contacts = call_service_handler_get_reverse_compact_contacts;
  iface->get_paid_call_ad_status = call_service_handler_get_paid_call_ad_status;
  iface->find_contact_by_userid_without_abuse_block_for_channel = call_service_handler_find_contact_by_userid_without_abuse_block_for_channel;
  iface->get_group_member_mids = call_service_handler_get_group_member_mids;
  iface->send_message_without_relationship = call_service_handler_send_message_without_relationship;
  iface->display_buddy_subscriber_count_in_bulk = call_service_handler_display_buddy_subscriber_count_in_bulk;
  iface->lookup_room_members = call_service_handler_lookup_room_members;
  iface->get_favorite_mids_for_channel = call_service_handler_get_favorite_mids_for_channel;
  iface->get_all_contact_ids_for_channel = call_service_handler_get_all_contact_ids_for_channel;
  iface->display_buddy_subscriber_count = call_service_handler_display_buddy_subscriber_count;
  iface->get_profile_for_channel = call_service_handler_get_profile_for_channel;
  iface->get_user_tickets = call_service_handler_get_user_tickets;
  iface->get_o_a_friend_mids = call_service_handler_get_o_a_friend_mids;
  iface->search_paid_call_user_rate = call_service_handler_search_paid_call_user_rate;
  iface->get_joined_group_ids_for_channel = call_service_handler_get_joined_group_ids_for_channel;
  iface->acquire_group_call_route = call_service_handler_acquire_group_call_route;
  iface->get_user_mids_who_added_me = call_service_handler_get_user_mids_who_added_me;
  iface->get_identity_credential = call_service_handler_get_identity_credential;
  iface->add_operation_for_channel = call_service_handler_add_operation_for_channel;
  iface->get_simple_channel_contacts = call_service_handler_get_simple_channel_contacts;
  iface->get_user_last_sent_message_time_stamp = call_service_handler_get_user_last_sent_message_time_stamp;
}

static void
call_service_handler_init (CallServiceHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
call_service_handler_class_init (CallServiceHandlerClass *cls)
{
  cls->get_user_status = NULL;
  cls->update_profile_attribute_for_channel = NULL;
  cls->update_extended_profile_attribute = NULL;
  cls->get_all_simple_channel_contacts = NULL;
  cls->get_user_identities = NULL;
  cls->mark_paid_call_ad = NULL;
  cls->is_group_member = NULL;
  cls->get_phone_info_from_phone_number = NULL;
  cls->redeem_paid_call_voucher = NULL;
  cls->get_preferred_display_name = NULL;
  cls->get_contacts_for_channel = NULL;
  cls->get_call_credit_products = NULL;
  cls->get_compact_contacts = NULL;
  cls->notify_noti_center_event = NULL;
  cls->is_in_contact = NULL;
  cls->lookup_group_members = NULL;
  cls->get_room_information = NULL;
  cls->get_group_call = NULL;
  cls->is_allow_secondary_device_login = NULL;
  cls->get_primary_client_for_channel = NULL;
  cls->create_room_with_buddy = NULL;
  cls->get_display_name = NULL;
  cls->get_paid_call_metadata = NULL;
  cls->get_mid = NULL;
  cls->get_user_country_for_billing = NULL;
  cls->get_favorite_group_ids_for_channel = NULL;
  cls->get_paid_call_history = NULL;
  cls->send_pin_code_operation = NULL;
  cls->invite_into_group_call = NULL;
  cls->get_friend_mids = NULL;
  cls->get_meta_profile = NULL;
  cls->send_message_for_channel = NULL;
  cls->active_buddy_subscriber_count = NULL;
  cls->get_call_credit_purchase_history = NULL;
  cls->is_room_member = NULL;
  cls->send_system_o_a_message = NULL;
  cls->acquire_paid_call_route = NULL;
  cls->get_groups_for_channel = NULL;
  cls->get_user_create_time = NULL;
  cls->register_channel_c_p = NULL;
  cls->reserve_call_credit_purchase = NULL;
  cls->acquire_paid_call_currency_exchange_rate = NULL;
  cls->get_room_member_mids_for_app_platform = NULL;
  cls->get_paid_call_balance_list = NULL;
  cls->get_personal_infos = NULL;
  cls->get_primary_clients_for_channel = NULL;
  cls->add_buddy_to_contact = NULL;
  cls->get_group_member_mids_for_app_platform = NULL;
  cls->get_user_language = NULL;
  cls->lookup_paid_call = NULL;
  cls->get_extended_profile = NULL;
  cls->get_reverse_compact_contacts = NULL;
  cls->get_paid_call_ad_status = NULL;
  cls->find_contact_by_userid_without_abuse_block_for_channel = NULL;
  cls->get_group_member_mids = NULL;
  cls->send_message_without_relationship = NULL;
  cls->display_buddy_subscriber_count_in_bulk = NULL;
  cls->lookup_room_members = NULL;
  cls->get_favorite_mids_for_channel = NULL;
  cls->get_all_contact_ids_for_channel = NULL;
  cls->display_buddy_subscriber_count = NULL;
  cls->get_profile_for_channel = NULL;
  cls->get_user_tickets = NULL;
  cls->get_o_a_friend_mids = NULL;
  cls->search_paid_call_user_rate = NULL;
  cls->get_joined_group_ids_for_channel = NULL;
  cls->acquire_group_call_route = NULL;
  cls->get_user_mids_who_added_me = NULL;
  cls->get_identity_credential = NULL;
  cls->add_operation_for_channel = NULL;
  cls->get_simple_channel_contacts = NULL;
  cls->get_user_last_sent_message_time_stamp = NULL;
}

enum _CallServiceProcessorProperties
{
  PROP_CALL_SERVICE_PROCESSOR_0,
  PROP_CALL_SERVICE_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (CallServiceProcessor,
               call_service_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* CallServiceProcessorProcessFunction) (CallServiceProcessor *, 
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);

typedef struct
{
  gchar *name;
  CallServiceProcessorProcessFunction function;
} call_service_processor_process_function_def;

static gboolean
call_service_processor_process_get_user_status (CallServiceProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
call_service_processor_process_update_profile_attribute_for_channel (CallServiceProcessor *,
                                                                     gint32,
                                                                     ThriftProtocol *,
                                                                     ThriftProtocol *,
                                                                     GError **);
static gboolean
call_service_processor_process_update_extended_profile_attribute (CallServiceProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
call_service_processor_process_get_all_simple_channel_contacts (CallServiceProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
call_service_processor_process_get_user_identities (CallServiceProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
call_service_processor_process_mark_paid_call_ad (CallServiceProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
call_service_processor_process_is_group_member (CallServiceProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
call_service_processor_process_get_phone_info_from_phone_number (CallServiceProcessor *,
                                                                 gint32,
                                                                 ThriftProtocol *,
                                                                 ThriftProtocol *,
                                                                 GError **);
static gboolean
call_service_processor_process_redeem_paid_call_voucher (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_get_preferred_display_name (CallServiceProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
call_service_processor_process_get_contacts_for_channel (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_get_call_credit_products (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_get_compact_contacts (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_notify_noti_center_event (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_is_in_contact (CallServiceProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
call_service_processor_process_lookup_group_members (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_get_room_information (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_get_group_call (CallServiceProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
call_service_processor_process_is_allow_secondary_device_login (CallServiceProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
call_service_processor_process_get_primary_client_for_channel (CallServiceProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
call_service_processor_process_create_room_with_buddy (CallServiceProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
call_service_processor_process_get_display_name (CallServiceProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
call_service_processor_process_get_paid_call_metadata (CallServiceProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
call_service_processor_process_get_mid (CallServiceProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
call_service_processor_process_get_user_country_for_billing (CallServiceProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
call_service_processor_process_get_favorite_group_ids_for_channel (CallServiceProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
call_service_processor_process_get_paid_call_history (CallServiceProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
call_service_processor_process_send_pin_code_operation (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_invite_into_group_call (CallServiceProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
call_service_processor_process_get_friend_mids (CallServiceProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
call_service_processor_process_get_meta_profile (CallServiceProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
call_service_processor_process_send_message_for_channel (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_active_buddy_subscriber_count (CallServiceProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
call_service_processor_process_get_call_credit_purchase_history (CallServiceProcessor *,
                                                                 gint32,
                                                                 ThriftProtocol *,
                                                                 ThriftProtocol *,
                                                                 GError **);
static gboolean
call_service_processor_process_is_room_member (CallServiceProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
call_service_processor_process_send_system_o_a_message (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_acquire_paid_call_route (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_get_groups_for_channel (CallServiceProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
call_service_processor_process_get_user_create_time (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_register_channel_c_p (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_reserve_call_credit_purchase (CallServiceProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
call_service_processor_process_acquire_paid_call_currency_exchange_rate (CallServiceProcessor *,
                                                                         gint32,
                                                                         ThriftProtocol *,
                                                                         ThriftProtocol *,
                                                                         GError **);
static gboolean
call_service_processor_process_get_room_member_mids_for_app_platform (CallServiceProcessor *,
                                                                      gint32,
                                                                      ThriftProtocol *,
                                                                      ThriftProtocol *,
                                                                      GError **);
static gboolean
call_service_processor_process_get_paid_call_balance_list (CallServiceProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
call_service_processor_process_get_personal_infos (CallServiceProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
call_service_processor_process_get_primary_clients_for_channel (CallServiceProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
call_service_processor_process_add_buddy_to_contact (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_get_group_member_mids_for_app_platform (CallServiceProcessor *,
                                                                       gint32,
                                                                       ThriftProtocol *,
                                                                       ThriftProtocol *,
                                                                       GError **);
static gboolean
call_service_processor_process_get_user_language (CallServiceProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
call_service_processor_process_lookup_paid_call (CallServiceProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
call_service_processor_process_get_extended_profile (CallServiceProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
call_service_processor_process_get_reverse_compact_contacts (CallServiceProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
call_service_processor_process_get_paid_call_ad_status (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel (CallServiceProcessor *,
                                                                                       gint32,
                                                                                       ThriftProtocol *,
                                                                                       ThriftProtocol *,
                                                                                       GError **);
static gboolean
call_service_processor_process_get_group_member_mids (CallServiceProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
call_service_processor_process_send_message_without_relationship (CallServiceProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
call_service_processor_process_display_buddy_subscriber_count_in_bulk (CallServiceProcessor *,
                                                                       gint32,
                                                                       ThriftProtocol *,
                                                                       ThriftProtocol *,
                                                                       GError **);
static gboolean
call_service_processor_process_lookup_room_members (CallServiceProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
call_service_processor_process_get_favorite_mids_for_channel (CallServiceProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
call_service_processor_process_get_all_contact_ids_for_channel (CallServiceProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
call_service_processor_process_display_buddy_subscriber_count (CallServiceProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
call_service_processor_process_get_profile_for_channel (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_get_user_tickets (CallServiceProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
call_service_processor_process_get_o_a_friend_mids (CallServiceProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
call_service_processor_process_search_paid_call_user_rate (CallServiceProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
call_service_processor_process_get_joined_group_ids_for_channel (CallServiceProcessor *,
                                                                 gint32,
                                                                 ThriftProtocol *,
                                                                 ThriftProtocol *,
                                                                 GError **);
static gboolean
call_service_processor_process_acquire_group_call_route (CallServiceProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
call_service_processor_process_get_user_mids_who_added_me (CallServiceProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
call_service_processor_process_get_identity_credential (CallServiceProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
call_service_processor_process_add_operation_for_channel (CallServiceProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
call_service_processor_process_get_simple_channel_contacts (CallServiceProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
call_service_processor_process_get_user_last_sent_message_time_stamp (CallServiceProcessor *,
                                                                      gint32,
                                                                      ThriftProtocol *,
                                                                      ThriftProtocol *,
                                                                      GError **);

static call_service_processor_process_function_def
call_service_processor_process_function_defs[72] = {
  {
    "getUserStatus",
    call_service_processor_process_get_user_status
  },
  {
    "updateProfileAttributeForChannel",
    call_service_processor_process_update_profile_attribute_for_channel
  },
  {
    "updateExtendedProfileAttribute",
    call_service_processor_process_update_extended_profile_attribute
  },
  {
    "getAllSimpleChannelContacts",
    call_service_processor_process_get_all_simple_channel_contacts
  },
  {
    "getUserIdentities",
    call_service_processor_process_get_user_identities
  },
  {
    "markPaidCallAd",
    call_service_processor_process_mark_paid_call_ad
  },
  {
    "isGroupMember",
    call_service_processor_process_is_group_member
  },
  {
    "getPhoneInfoFromPhoneNumber",
    call_service_processor_process_get_phone_info_from_phone_number
  },
  {
    "redeemPaidCallVoucher",
    call_service_processor_process_redeem_paid_call_voucher
  },
  {
    "getPreferredDisplayName",
    call_service_processor_process_get_preferred_display_name
  },
  {
    "getContactsForChannel",
    call_service_processor_process_get_contacts_for_channel
  },
  {
    "getCallCreditProducts",
    call_service_processor_process_get_call_credit_products
  },
  {
    "getCompactContacts",
    call_service_processor_process_get_compact_contacts
  },
  {
    "notifyNotiCenterEvent",
    call_service_processor_process_notify_noti_center_event
  },
  {
    "isInContact",
    call_service_processor_process_is_in_contact
  },
  {
    "lookupGroupMembers",
    call_service_processor_process_lookup_group_members
  },
  {
    "getRoomInformation",
    call_service_processor_process_get_room_information
  },
  {
    "getGroupCall",
    call_service_processor_process_get_group_call
  },
  {
    "isAllowSecondaryDeviceLogin",
    call_service_processor_process_is_allow_secondary_device_login
  },
  {
    "getPrimaryClientForChannel",
    call_service_processor_process_get_primary_client_for_channel
  },
  {
    "createRoomWithBuddy",
    call_service_processor_process_create_room_with_buddy
  },
  {
    "getDisplayName",
    call_service_processor_process_get_display_name
  },
  {
    "getPaidCallMetadata",
    call_service_processor_process_get_paid_call_metadata
  },
  {
    "getMid",
    call_service_processor_process_get_mid
  },
  {
    "getUserCountryForBilling",
    call_service_processor_process_get_user_country_for_billing
  },
  {
    "getFavoriteGroupIdsForChannel",
    call_service_processor_process_get_favorite_group_ids_for_channel
  },
  {
    "getPaidCallHistory",
    call_service_processor_process_get_paid_call_history
  },
  {
    "sendPinCodeOperation",
    call_service_processor_process_send_pin_code_operation
  },
  {
    "inviteIntoGroupCall",
    call_service_processor_process_invite_into_group_call
  },
  {
    "getFriendMids",
    call_service_processor_process_get_friend_mids
  },
  {
    "getMetaProfile",
    call_service_processor_process_get_meta_profile
  },
  {
    "sendMessageForChannel",
    call_service_processor_process_send_message_for_channel
  },
  {
    "activeBuddySubscriberCount",
    call_service_processor_process_active_buddy_subscriber_count
  },
  {
    "getCallCreditPurchaseHistory",
    call_service_processor_process_get_call_credit_purchase_history
  },
  {
    "isRoomMember",
    call_service_processor_process_is_room_member
  },
  {
    "sendSystemOAMessage",
    call_service_processor_process_send_system_o_a_message
  },
  {
    "acquirePaidCallRoute",
    call_service_processor_process_acquire_paid_call_route
  },
  {
    "getGroupsForChannel",
    call_service_processor_process_get_groups_for_channel
  },
  {
    "getUserCreateTime",
    call_service_processor_process_get_user_create_time
  },
  {
    "registerChannelCP",
    call_service_processor_process_register_channel_c_p
  },
  {
    "reserveCallCreditPurchase",
    call_service_processor_process_reserve_call_credit_purchase
  },
  {
    "acquirePaidCallCurrencyExchangeRate",
    call_service_processor_process_acquire_paid_call_currency_exchange_rate
  },
  {
    "getRoomMemberMidsForAppPlatform",
    call_service_processor_process_get_room_member_mids_for_app_platform
  },
  {
    "getPaidCallBalanceList",
    call_service_processor_process_get_paid_call_balance_list
  },
  {
    "getPersonalInfos",
    call_service_processor_process_get_personal_infos
  },
  {
    "getPrimaryClientsForChannel",
    call_service_processor_process_get_primary_clients_for_channel
  },
  {
    "addBuddyToContact",
    call_service_processor_process_add_buddy_to_contact
  },
  {
    "getGroupMemberMidsForAppPlatform",
    call_service_processor_process_get_group_member_mids_for_app_platform
  },
  {
    "getUserLanguage",
    call_service_processor_process_get_user_language
  },
  {
    "lookupPaidCall",
    call_service_processor_process_lookup_paid_call
  },
  {
    "getExtendedProfile",
    call_service_processor_process_get_extended_profile
  },
  {
    "getReverseCompactContacts",
    call_service_processor_process_get_reverse_compact_contacts
  },
  {
    "getPaidCallAdStatus",
    call_service_processor_process_get_paid_call_ad_status
  },
  {
    "findContactByUseridWithoutAbuseBlockForChannel",
    call_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel
  },
  {
    "getGroupMemberMids",
    call_service_processor_process_get_group_member_mids
  },
  {
    "sendMessageWithoutRelationship",
    call_service_processor_process_send_message_without_relationship
  },
  {
    "displayBuddySubscriberCountInBulk",
    call_service_processor_process_display_buddy_subscriber_count_in_bulk
  },
  {
    "lookupRoomMembers",
    call_service_processor_process_lookup_room_members
  },
  {
    "getFavoriteMidsForChannel",
    call_service_processor_process_get_favorite_mids_for_channel
  },
  {
    "getAllContactIdsForChannel",
    call_service_processor_process_get_all_contact_ids_for_channel
  },
  {
    "displayBuddySubscriberCount",
    call_service_processor_process_display_buddy_subscriber_count
  },
  {
    "getProfileForChannel",
    call_service_processor_process_get_profile_for_channel
  },
  {
    "getUserTickets",
    call_service_processor_process_get_user_tickets
  },
  {
    "getOAFriendMids",
    call_service_processor_process_get_o_a_friend_mids
  },
  {
    "searchPaidCallUserRate",
    call_service_processor_process_search_paid_call_user_rate
  },
  {
    "getJoinedGroupIdsForChannel",
    call_service_processor_process_get_joined_group_ids_for_channel
  },
  {
    "acquireGroupCallRoute",
    call_service_processor_process_acquire_group_call_route
  },
  {
    "getUserMidsWhoAddedMe",
    call_service_processor_process_get_user_mids_who_added_me
  },
  {
    "getIdentityCredential",
    call_service_processor_process_get_identity_credential
  },
  {
    "addOperationForChannel",
    call_service_processor_process_add_operation_for_channel
  },
  {
    "getSimpleChannelContacts",
    call_service_processor_process_get_simple_channel_contacts
  },
  {
    "getUserLastSentMessageTimeStamp",
    call_service_processor_process_get_user_last_sent_message_time_stamp
  }
};

static gboolean
call_service_processor_process_get_user_status (CallServiceProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserStatusArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_STATUS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    UserStatus return_value;
    CallServiceGetUserStatusResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_STATUS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_status (CALL_SERVICE_IF (self->handler),
                                              &return_value,
                                              mid,
                                              &e,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserStatus",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserStatus",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserStatus implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserStatus",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_update_profile_attribute_for_channel (CallServiceProcessor *self,
                                                                     gint32 sequence_id,
                                                                     ThriftProtocol *input_protocol,
                                                                     ThriftProtocol *output_protocol,
                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceUpdateProfileAttributeForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_UPDATE_PROFILE_ATTRIBUTE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ProfileAttribute profileAttribute;
    gchar * value;
    TalkException * e = NULL;
    CallServiceUpdateProfileAttributeForChannelResult * result_struct;

    g_object_get (args,
                  "profileAttribute", &profileAttribute,
                  "value", &value,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_UPDATE_PROFILE_ATTRIBUTE_FOR_CHANNEL_RESULT, NULL);

    if (call_service_handler_update_profile_attribute_for_channel (CALL_SERVICE_IF (self->handler),
                                                                   profileAttribute,
                                                                   value,
                                                                   &e,
                                                                   error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateProfileAttributeForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateProfileAttributeForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.updateProfileAttributeForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateProfileAttributeForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (value != NULL)
      g_free (value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_update_extended_profile_attribute (CallServiceProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceUpdateExtendedProfileAttributeArgs * args =
    g_object_new (TYPE_CALL_SERVICE_UPDATE_EXTENDED_PROFILE_ATTRIBUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ExtendedProfileAttribute attr;
    ExtendedProfile * extendedProfile;
    TalkException * e = NULL;
    CallServiceUpdateExtendedProfileAttributeResult * result_struct;

    g_object_get (args,
                  "attr", &attr,
                  "extendedProfile", &extendedProfile,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_UPDATE_EXTENDED_PROFILE_ATTRIBUTE_RESULT, NULL);

    if (call_service_handler_update_extended_profile_attribute (CALL_SERVICE_IF (self->handler),
                                                                attr,
                                                                extendedProfile,
                                                                &e,
                                                                error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateExtendedProfileAttribute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateExtendedProfileAttribute",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.updateExtendedProfileAttribute implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateExtendedProfileAttribute",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (extendedProfile != NULL)
      g_object_unref (extendedProfile);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_all_simple_channel_contacts (CallServiceProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetAllSimpleChannelContactsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_ALL_SIMPLE_CHANNEL_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gboolean statusSticonFallbackDisabled;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetAllSimpleChannelContactsResult * result_struct;

    g_object_get (args,
                  "statusSticonFallbackDisabled", &statusSticonFallbackDisabled,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_ALL_SIMPLE_CHANNEL_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_all_simple_channel_contacts (CALL_SERVICE_IF (self->handler),
                                                              &return_value,
                                                              statusSticonFallbackDisabled,
                                                              &e,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getAllSimpleChannelContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllSimpleChannelContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getAllSimpleChannelContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllSimpleChannelContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_identities (CallServiceProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserIdentitiesArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_IDENTITIES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GHashTable * return_value;
    CallServiceGetUserIdentitiesResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_IDENTITIES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_identities (CALL_SERVICE_IF (self->handler),
                                                  &return_value,
                                                  &e,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserIdentities",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserIdentities",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserIdentities implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserIdentities",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_mark_paid_call_ad (CallServiceProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceMarkPaidCallAdArgs * args =
    g_object_new (TYPE_CALL_SERVICE_MARK_PAID_CALL_AD_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * dialedNumber;
    gchar * language;
    gboolean disableCallerId;
    TalkException * e = NULL;
    PaidCallDialing * return_value;
    CallServiceMarkPaidCallAdResult * result_struct;

    g_object_get (args,
                  "dialedNumber", &dialedNumber,
                  "language", &language,
                  "disableCallerId", &disableCallerId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_MARK_PAID_CALL_AD_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_mark_paid_call_ad (CALL_SERVICE_IF (self->handler),
                                                &return_value,
                                                dialedNumber,
                                                language,
                                                disableCallerId,
                                                &e,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "markPaidCallAd",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "markPaidCallAd",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.markPaidCallAd implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "markPaidCallAd",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (dialedNumber != NULL)
      g_free (dialedNumber);
    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_is_group_member (CallServiceProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceIsGroupMemberArgs * args =
    g_object_new (TYPE_CALL_SERVICE_IS_GROUP_MEMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    TalkException * e = NULL;
    gboolean return_value;
    CallServiceIsGroupMemberResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_IS_GROUP_MEMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_is_group_member (CALL_SERVICE_IF (self->handler),
                                              &return_value,
                                              groupId,
                                              &e,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isGroupMember",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isGroupMember",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.isGroupMember implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isGroupMember",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_phone_info_from_phone_number (CallServiceProcessor *self,
                                                                 gint32 sequence_id,
                                                                 ThriftProtocol *input_protocol,
                                                                 ThriftProtocol *output_protocol,
                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPhoneInfoFromPhoneNumberArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PHONE_INFO_FROM_PHONE_NUMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * region;
    gchar * phoneNumber;
    TalkException * e = NULL;
    PhoneInfoForChannel * return_value;
    CallServiceGetPhoneInfoFromPhoneNumberResult * result_struct;

    g_object_get (args,
                  "region", &region,
                  "phoneNumber", &phoneNumber,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PHONE_INFO_FROM_PHONE_NUMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_phone_info_from_phone_number (CALL_SERVICE_IF (self->handler),
                                                               &return_value,
                                                               region,
                                                               phoneNumber,
                                                               &e,
                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPhoneInfoFromPhoneNumber",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPhoneInfoFromPhoneNumber",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPhoneInfoFromPhoneNumber implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPhoneInfoFromPhoneNumber",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (region != NULL)
      g_free (region);
    if (phoneNumber != NULL)
      g_free (phoneNumber);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_redeem_paid_call_voucher (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceRedeemPaidCallVoucherArgs * args =
    g_object_new (TYPE_CALL_SERVICE_REDEEM_PAID_CALL_VOUCHER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * serial;
    gchar * language;
    TalkException * e = NULL;
    PaidCallRedeemResult * return_value;
    CallServiceRedeemPaidCallVoucherResult * result_struct;

    g_object_get (args,
                  "serial", &serial,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_REDEEM_PAID_CALL_VOUCHER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_redeem_paid_call_voucher (CALL_SERVICE_IF (self->handler),
                                                       &return_value,
                                                       serial,
                                                       language,
                                                       &e,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "redeemPaidCallVoucher",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "redeemPaidCallVoucher",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.redeemPaidCallVoucher implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "redeemPaidCallVoucher",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (serial != NULL)
      g_free (serial);
    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_preferred_display_name (CallServiceProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPreferredDisplayNameArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PREFERRED_DISPLAY_NAME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * mids;
    TalkException * e = NULL;
    GHashTable * return_value;
    CallServiceGetPreferredDisplayNameResult * result_struct;

    g_object_get (args,
                  "mids", &mids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PREFERRED_DISPLAY_NAME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_preferred_display_name (CALL_SERVICE_IF (self->handler),
                                                         &return_value,
                                                         mids,
                                                         &e,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPreferredDisplayName",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPreferredDisplayName",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPreferredDisplayName implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPreferredDisplayName",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mids != NULL)
      g_ptr_array_unref (mids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_contacts_for_channel (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetContactsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_CONTACTS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * ids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetContactsForChannelResult * result_struct;

    g_object_get (args,
                  "ids", &ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_CONTACTS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_contacts_for_channel (CALL_SERVICE_IF (self->handler),
                                                       &return_value,
                                                       ids,
                                                       &e,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getContactsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getContactsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getContactsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getContactsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ids != NULL)
      g_ptr_array_unref (ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_call_credit_products (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetCallCreditProductsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_CALL_CREDIT_PRODUCTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PaymentType appStoreCode;
    PaymentPgType pgCode;
    gchar * country;
    gchar * language;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetCallCreditProductsResult * result_struct;

    g_object_get (args,
                  "appStoreCode", &appStoreCode,
                  "pgCode", &pgCode,
                  "country", &country,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_CALL_CREDIT_PRODUCTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_call_credit_products (CALL_SERVICE_IF (self->handler),
                                                       &return_value,
                                                       appStoreCode,
                                                       pgCode,
                                                       country,
                                                       language,
                                                       &e,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getCallCreditProducts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCallCreditProducts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getCallCreditProducts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCallCreditProducts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (country != NULL)
      g_free (country);
    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_compact_contacts (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetCompactContactsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_COMPACT_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 lastModifiedTimestamp;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetCompactContactsResult * result_struct;

    g_object_get (args,
                  "lastModifiedTimestamp", &lastModifiedTimestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_COMPACT_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_compact_contacts (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   lastModifiedTimestamp,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getCompactContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCompactContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getCompactContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCompactContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_notify_noti_center_event (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceNotifyNotiCenterEventArgs * args =
    g_object_new (TYPE_CALL_SERVICE_NOTIFY_NOTI_CENTER_EVENT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    NotiCenterEventData * event;
    TalkException * e = NULL;
    CallServiceNotifyNotiCenterEventResult * result_struct;

    g_object_get (args,
                  "event", &event,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_NOTIFY_NOTI_CENTER_EVENT_RESULT, NULL);

    if (call_service_handler_notify_noti_center_event (CALL_SERVICE_IF (self->handler),
                                                       event,
                                                       &e,
                                                       error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "notifyNotiCenterEvent",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "notifyNotiCenterEvent",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.notifyNotiCenterEvent implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "notifyNotiCenterEvent",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (event != NULL)
      g_object_unref (event);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_is_in_contact (CallServiceProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceIsInContactArgs * args =
    g_object_new (TYPE_CALL_SERVICE_IS_IN_CONTACT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    gboolean return_value;
    CallServiceIsInContactResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_IS_IN_CONTACT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_is_in_contact (CALL_SERVICE_IF (self->handler),
                                            &return_value,
                                            mid,
                                            &e,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isInContact",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isInContact",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.isInContact implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isInContact",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_lookup_group_members (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceLookupGroupMembersArgs * args =
    g_object_new (TYPE_CALL_SERVICE_LOOKUP_GROUP_MEMBERS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    GPtrArray * mids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceLookupGroupMembersResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  "mids", &mids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_LOOKUP_GROUP_MEMBERS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_lookup_group_members (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   groupId,
                                                   mids,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "lookupGroupMembers",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupGroupMembers",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.lookupGroupMembers implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupGroupMembers",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    if (mids != NULL)
      g_ptr_array_unref (mids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_room_information (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetRoomInformationArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_ROOM_INFORMATION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * roomMid;
    TalkException * e = NULL;
    Room * return_value;
    CallServiceGetRoomInformationResult * result_struct;

    g_object_get (args,
                  "roomMid", &roomMid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_ROOM_INFORMATION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_room_information (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   roomMid,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRoomInformation",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRoomInformation",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getRoomInformation implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRoomInformation",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (roomMid != NULL)
      g_free (roomMid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_group_call (CallServiceProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetGroupCallArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_GROUP_CALL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * chatMid;
    TalkException * e = NULL;
    GroupCall * return_value;
    CallServiceGetGroupCallResult * result_struct;

    g_object_get (args,
                  "chatMid", &chatMid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_GROUP_CALL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_group_call (CALL_SERVICE_IF (self->handler),
                                             &return_value,
                                             chatMid,
                                             &e,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupCall",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupCall",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getGroupCall implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupCall",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (chatMid != NULL)
      g_free (chatMid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_is_allow_secondary_device_login (CallServiceProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceIsAllowSecondaryDeviceLoginArgs * args =
    g_object_new (TYPE_CALL_SERVICE_IS_ALLOW_SECONDARY_DEVICE_LOGIN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gboolean return_value;
    CallServiceIsAllowSecondaryDeviceLoginResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_IS_ALLOW_SECONDARY_DEVICE_LOGIN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_is_allow_secondary_device_login (CALL_SERVICE_IF (self->handler),
                                                              &return_value,
                                                              &e,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isAllowSecondaryDeviceLogin",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isAllowSecondaryDeviceLogin",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.isAllowSecondaryDeviceLogin implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isAllowSecondaryDeviceLogin",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_primary_client_for_channel (CallServiceProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPrimaryClientForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PRIMARY_CLIENT_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    SimpleChannelClient * return_value;
    CallServiceGetPrimaryClientForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PRIMARY_CLIENT_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_primary_client_for_channel (CALL_SERVICE_IF (self->handler),
                                                             &return_value,
                                                             &e,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPrimaryClientForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPrimaryClientForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_create_room_with_buddy (CallServiceProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceCreateRoomWithBuddyArgs * args =
    g_object_new (TYPE_CALL_SERVICE_CREATE_ROOM_WITH_BUDDY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint reqSeq;
    gchar * buddyMid;
    GPtrArray * contactIds;
    TalkException * e = NULL;
    Room * return_value;
    CallServiceCreateRoomWithBuddyResult * result_struct;

    g_object_get (args,
                  "reqSeq", &reqSeq,
                  "buddyMid", &buddyMid,
                  "contactIds", &contactIds,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_CREATE_ROOM_WITH_BUDDY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_create_room_with_buddy (CALL_SERVICE_IF (self->handler),
                                                     &return_value,
                                                     reqSeq,
                                                     buddyMid,
                                                     contactIds,
                                                     &e,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createRoomWithBuddy",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createRoomWithBuddy",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.createRoomWithBuddy implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createRoomWithBuddy",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (buddyMid != NULL)
      g_free (buddyMid);
    if (contactIds != NULL)
      g_ptr_array_unref (contactIds);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_display_name (CallServiceProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetDisplayNameArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_DISPLAY_NAME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    gchar * return_value;
    CallServiceGetDisplayNameResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_DISPLAY_NAME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_display_name (CALL_SERVICE_IF (self->handler),
                                               &return_value,
                                               mid,
                                               &e,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDisplayName",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDisplayName",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getDisplayName implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDisplayName",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_paid_call_metadata (CallServiceProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPaidCallMetadataArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_METADATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * language;
    TalkException * e = NULL;
    PaidCallMetadataResult * return_value;
    CallServiceGetPaidCallMetadataResult * result_struct;

    g_object_get (args,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_METADATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_paid_call_metadata (CALL_SERVICE_IF (self->handler),
                                                     &return_value,
                                                     language,
                                                     &e,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPaidCallMetadata",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallMetadata",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPaidCallMetadata implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallMetadata",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_mid (CallServiceProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetMidArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_MID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gchar * return_value;
    CallServiceGetMidResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_MID_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_mid (CALL_SERVICE_IF (self->handler),
                                      &return_value,
                                      &e,
                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getMid",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMid",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getMid implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMid",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_country_for_billing (CallServiceProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserCountryForBillingArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_COUNTRY_FOR_BILLING_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * country;
    gchar * remoteIp;
    TalkException * e = NULL;
    gchar * return_value;
    CallServiceGetUserCountryForBillingResult * result_struct;

    g_object_get (args,
                  "country", &country,
                  "remoteIp", &remoteIp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_COUNTRY_FOR_BILLING_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_country_for_billing (CALL_SERVICE_IF (self->handler),
                                                           &return_value,
                                                           country,
                                                           remoteIp,
                                                           &e,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserCountryForBilling",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCountryForBilling",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserCountryForBilling implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCountryForBilling",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (country != NULL)
      g_free (country);
    if (remoteIp != NULL)
      g_free (remoteIp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_favorite_group_ids_for_channel (CallServiceProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetFavoriteGroupIdsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_FAVORITE_GROUP_IDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetFavoriteGroupIdsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_FAVORITE_GROUP_IDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_favorite_group_ids_for_channel (CALL_SERVICE_IF (self->handler),
                                                                 &return_value,
                                                                 &e,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFavoriteGroupIdsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteGroupIdsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getFavoriteGroupIdsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteGroupIdsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_paid_call_history (CallServiceProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPaidCallHistoryArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_HISTORY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 start;
    gint size;
    gchar * language;
    TalkException * e = NULL;
    PaidCallHistoryResult * return_value;
    CallServiceGetPaidCallHistoryResult * result_struct;

    g_object_get (args,
                  "start", &start,
                  "size", &size,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_HISTORY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_paid_call_history (CALL_SERVICE_IF (self->handler),
                                                    &return_value,
                                                    start,
                                                    size,
                                                    language,
                                                    &e,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPaidCallHistory",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallHistory",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPaidCallHistory implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallHistory",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_send_pin_code_operation (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceSendPinCodeOperationArgs * args =
    g_object_new (TYPE_CALL_SERVICE_SEND_PIN_CODE_OPERATION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * verifier;
    TalkException * e = NULL;
    CallServiceSendPinCodeOperationResult * result_struct;

    g_object_get (args,
                  "verifier", &verifier,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_SEND_PIN_CODE_OPERATION_RESULT, NULL);

    if (call_service_handler_send_pin_code_operation (CALL_SERVICE_IF (self->handler),
                                                      verifier,
                                                      &e,
                                                      error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendPinCodeOperation",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendPinCodeOperation",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.sendPinCodeOperation implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendPinCodeOperation",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (verifier != NULL)
      g_free (verifier);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_invite_into_group_call (CallServiceProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceInviteIntoGroupCallArgs * args =
    g_object_new (TYPE_CALL_SERVICE_INVITE_INTO_GROUP_CALL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * chatMid;
    GPtrArray * memberMids;
    GroupCallMediaType mediaType;
    TalkException * e = NULL;
    CallServiceInviteIntoGroupCallResult * result_struct;

    g_object_get (args,
                  "chatMid", &chatMid,
                  "memberMids", &memberMids,
                  "mediaType", &mediaType,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_INVITE_INTO_GROUP_CALL_RESULT, NULL);

    if (call_service_handler_invite_into_group_call (CALL_SERVICE_IF (self->handler),
                                                     chatMid,
                                                     memberMids,
                                                     mediaType,
                                                     &e,
                                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "inviteIntoGroupCall",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "inviteIntoGroupCall",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.inviteIntoGroupCall implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "inviteIntoGroupCall",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (chatMid != NULL)
      g_free (chatMid);
    if (memberMids != NULL)
      g_ptr_array_unref (memberMids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_friend_mids (CallServiceProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetFriendMidsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_FRIEND_MIDS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetFriendMidsResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_FRIEND_MIDS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_friend_mids (CALL_SERVICE_IF (self->handler),
                                              &return_value,
                                              &e,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFriendMids",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFriendMids",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getFriendMids implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFriendMids",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_meta_profile (CallServiceProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetMetaProfileArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_META_PROFILE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    MetaProfile * return_value;
    CallServiceGetMetaProfileResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_META_PROFILE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_meta_profile (CALL_SERVICE_IF (self->handler),
                                               &return_value,
                                               &e,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getMetaProfile",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMetaProfile",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getMetaProfile implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMetaProfile",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_send_message_for_channel (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceSendMessageForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_SEND_MESSAGE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Message * message;
    TalkException * e = NULL;
    Message * return_value;
    CallServiceSendMessageForChannelResult * result_struct;

    g_object_get (args,
                  "message", &message,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_SEND_MESSAGE_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_send_message_for_channel (CALL_SERVICE_IF (self->handler),
                                                       &return_value,
                                                       message,
                                                       &e,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendMessageForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.sendMessageForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (message != NULL)
      g_object_unref (message);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_active_buddy_subscriber_count (CallServiceProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceActiveBuddySubscriberCountArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ACTIVE_BUDDY_SUBSCRIBER_COUNT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    CallServiceActiveBuddySubscriberCountResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ACTIVE_BUDDY_SUBSCRIBER_COUNT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_active_buddy_subscriber_count (CALL_SERVICE_IF (self->handler),
                                                            &return_value,
                                                            &e,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "activeBuddySubscriberCount",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "activeBuddySubscriberCount",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.activeBuddySubscriberCount implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "activeBuddySubscriberCount",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_call_credit_purchase_history (CallServiceProcessor *self,
                                                                 gint32 sequence_id,
                                                                 ThriftProtocol *input_protocol,
                                                                 ThriftProtocol *output_protocol,
                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetCallCreditPurchaseHistoryArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_CALL_CREDIT_PURCHASE_HISTORY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    CoinHistoryCondition * request;
    TalkException * e = NULL;
    CoinHistoryResult * return_value;
    CallServiceGetCallCreditPurchaseHistoryResult * result_struct;

    g_object_get (args,
                  "request", &request,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_CALL_CREDIT_PURCHASE_HISTORY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_call_credit_purchase_history (CALL_SERVICE_IF (self->handler),
                                                               &return_value,
                                                               request,
                                                               &e,
                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getCallCreditPurchaseHistory",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCallCreditPurchaseHistory",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getCallCreditPurchaseHistory implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCallCreditPurchaseHistory",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (request != NULL)
      g_object_unref (request);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_is_room_member (CallServiceProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceIsRoomMemberArgs * args =
    g_object_new (TYPE_CALL_SERVICE_IS_ROOM_MEMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * roomId;
    TalkException * e = NULL;
    gboolean return_value;
    CallServiceIsRoomMemberResult * result_struct;

    g_object_get (args,
                  "roomId", &roomId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_IS_ROOM_MEMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_is_room_member (CALL_SERVICE_IF (self->handler),
                                             &return_value,
                                             roomId,
                                             &e,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isRoomMember",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isRoomMember",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.isRoomMember implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isRoomMember",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (roomId != NULL)
      g_free (roomId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_send_system_o_a_message (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceSendSystemOAMessageArgs * args =
    g_object_new (TYPE_CALL_SERVICE_SEND_SYSTEM_O_A_MESSAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Message * message;
    TalkException * e = NULL;
    Message * return_value;
    CallServiceSendSystemOAMessageResult * result_struct;

    g_object_get (args,
                  "message", &message,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_SEND_SYSTEM_O_A_MESSAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_send_system_o_a_message (CALL_SERVICE_IF (self->handler),
                                                      &return_value,
                                                      message,
                                                      &e,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendSystemOAMessage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendSystemOAMessage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.sendSystemOAMessage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendSystemOAMessage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (message != NULL)
      g_object_unref (message);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_acquire_paid_call_route (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceAcquirePaidCallRouteArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ACQUIRE_PAID_CALL_ROUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PaidCallType paidCallType;
    gchar * dialedNumber;
    gchar * language;
    gchar * networkCode;
    gboolean disableCallerId;
    gchar * referer;
    gchar * adSessionId;
    TalkException * e = NULL;
    PaidCallResponse * return_value;
    CallServiceAcquirePaidCallRouteResult * result_struct;

    g_object_get (args,
                  "paidCallType", &paidCallType,
                  "dialedNumber", &dialedNumber,
                  "language", &language,
                  "networkCode", &networkCode,
                  "disableCallerId", &disableCallerId,
                  "referer", &referer,
                  "adSessionId", &adSessionId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ACQUIRE_PAID_CALL_ROUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_acquire_paid_call_route (CALL_SERVICE_IF (self->handler),
                                                      &return_value,
                                                      paidCallType,
                                                      dialedNumber,
                                                      language,
                                                      networkCode,
                                                      disableCallerId,
                                                      referer,
                                                      adSessionId,
                                                      &e,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "acquirePaidCallRoute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquirePaidCallRoute",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.acquirePaidCallRoute implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquirePaidCallRoute",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (dialedNumber != NULL)
      g_free (dialedNumber);
    if (language != NULL)
      g_free (language);
    if (networkCode != NULL)
      g_free (networkCode);
    if (referer != NULL)
      g_free (referer);
    if (adSessionId != NULL)
      g_free (adSessionId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_groups_for_channel (CallServiceProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetGroupsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_GROUPS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * groupIds;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetGroupsForChannelResult * result_struct;

    g_object_get (args,
                  "groupIds", &groupIds,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_GROUPS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_groups_for_channel (CALL_SERVICE_IF (self->handler),
                                                     &return_value,
                                                     groupIds,
                                                     &e,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getGroupsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupIds != NULL)
      g_ptr_array_unref (groupIds);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_create_time (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserCreateTimeArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_CREATE_TIME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    CallServiceGetUserCreateTimeResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_CREATE_TIME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_create_time (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserCreateTime",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCreateTime",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserCreateTime implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCreateTime",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_register_channel_c_p (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceRegisterChannelCPArgs * args =
    g_object_new (TYPE_CALL_SERVICE_REGISTER_CHANNEL_C_P_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * cpId;
    gchar * registerPassword;
    TalkException * e = NULL;
    gchar * return_value;
    CallServiceRegisterChannelCPResult * result_struct;

    g_object_get (args,
                  "cpId", &cpId,
                  "registerPassword", &registerPassword,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_REGISTER_CHANNEL_C_P_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_register_channel_c_p (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   cpId,
                                                   registerPassword,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "registerChannelCP",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerChannelCP",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.registerChannelCP implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerChannelCP",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (cpId != NULL)
      g_free (cpId);
    if (registerPassword != NULL)
      g_free (registerPassword);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_reserve_call_credit_purchase (CallServiceProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceReserveCallCreditPurchaseArgs * args =
    g_object_new (TYPE_CALL_SERVICE_RESERVE_CALL_CREDIT_PURCHASE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    CoinPurchaseReservation * request;
    TalkException * e = NULL;
    PaymentReservationResult * return_value;
    CallServiceReserveCallCreditPurchaseResult * result_struct;

    g_object_get (args,
                  "request", &request,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_RESERVE_CALL_CREDIT_PURCHASE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_reserve_call_credit_purchase (CALL_SERVICE_IF (self->handler),
                                                           &return_value,
                                                           request,
                                                           &e,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "reserveCallCreditPurchase",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "reserveCallCreditPurchase",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.reserveCallCreditPurchase implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "reserveCallCreditPurchase",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (request != NULL)
      g_object_unref (request);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_acquire_paid_call_currency_exchange_rate (CallServiceProcessor *self,
                                                                         gint32 sequence_id,
                                                                         ThriftProtocol *input_protocol,
                                                                         ThriftProtocol *output_protocol,
                                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceAcquirePaidCallCurrencyExchangeRateArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ACQUIRE_PAID_CALL_CURRENCY_EXCHANGE_RATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * language;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceAcquirePaidCallCurrencyExchangeRateResult * result_struct;

    g_object_get (args,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ACQUIRE_PAID_CALL_CURRENCY_EXCHANGE_RATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_acquire_paid_call_currency_exchange_rate (CALL_SERVICE_IF (self->handler),
                                                                       &return_value,
                                                                       language,
                                                                       &e,
                                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "acquirePaidCallCurrencyExchangeRate",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquirePaidCallCurrencyExchangeRate",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.acquirePaidCallCurrencyExchangeRate implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquirePaidCallCurrencyExchangeRate",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_room_member_mids_for_app_platform (CallServiceProcessor *self,
                                                                      gint32 sequence_id,
                                                                      ThriftProtocol *input_protocol,
                                                                      ThriftProtocol *output_protocol,
                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetRoomMemberMidsForAppPlatformArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_ROOM_MEMBER_MIDS_FOR_APP_PLATFORM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * roomId;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetRoomMemberMidsForAppPlatformResult * result_struct;

    g_object_get (args,
                  "roomId", &roomId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_ROOM_MEMBER_MIDS_FOR_APP_PLATFORM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_room_member_mids_for_app_platform (CALL_SERVICE_IF (self->handler),
                                                                    &return_value,
                                                                    roomId,
                                                                    &e,
                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRoomMemberMidsForAppPlatform",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRoomMemberMidsForAppPlatform",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getRoomMemberMidsForAppPlatform implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRoomMemberMidsForAppPlatform",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (roomId != NULL)
      g_free (roomId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_paid_call_balance_list (CallServiceProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPaidCallBalanceListArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_BALANCE_LIST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * language;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetPaidCallBalanceListResult * result_struct;

    g_object_get (args,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_BALANCE_LIST_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_paid_call_balance_list (CALL_SERVICE_IF (self->handler),
                                                         &return_value,
                                                         language,
                                                         &e,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPaidCallBalanceList",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallBalanceList",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPaidCallBalanceList implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallBalanceList",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_personal_infos (CallServiceProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPersonalInfosArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PERSONAL_INFOS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GHashTable * requiredPersonalInfos;
    TalkException * e = NULL;
    GHashTable * return_value;
    CallServiceGetPersonalInfosResult * result_struct;

    g_object_get (args,
                  "requiredPersonalInfos", &requiredPersonalInfos,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PERSONAL_INFOS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_personal_infos (CALL_SERVICE_IF (self->handler),
                                                 &return_value,
                                                 requiredPersonalInfos,
                                                 &e,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonalInfos",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonalInfos",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPersonalInfos implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonalInfos",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (requiredPersonalInfos != NULL)
      g_hash_table_unref (requiredPersonalInfos);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_primary_clients_for_channel (CallServiceProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPrimaryClientsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PRIMARY_CLIENTS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * userMids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetPrimaryClientsForChannelResult * result_struct;

    g_object_get (args,
                  "userMids", &userMids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PRIMARY_CLIENTS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_primary_clients_for_channel (CALL_SERVICE_IF (self->handler),
                                                              &return_value,
                                                              userMids,
                                                              &e,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPrimaryClientsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPrimaryClientsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (userMids != NULL)
      g_ptr_array_unref (userMids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_add_buddy_to_contact (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceAddBuddyToContactArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ADD_BUDDY_TO_CONTACT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * buddyMid;
    TalkException * e = NULL;
    ContactTransition * return_value;
    CallServiceAddBuddyToContactResult * result_struct;

    g_object_get (args,
                  "buddyMid", &buddyMid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ADD_BUDDY_TO_CONTACT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_add_buddy_to_contact (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   buddyMid,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addBuddyToContact",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addBuddyToContact",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.addBuddyToContact implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addBuddyToContact",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (buddyMid != NULL)
      g_free (buddyMid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_group_member_mids_for_app_platform (CallServiceProcessor *self,
                                                                       gint32 sequence_id,
                                                                       ThriftProtocol *input_protocol,
                                                                       ThriftProtocol *output_protocol,
                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetGroupMemberMidsForAppPlatformArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_GROUP_MEMBER_MIDS_FOR_APP_PLATFORM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetGroupMemberMidsForAppPlatformResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_GROUP_MEMBER_MIDS_FOR_APP_PLATFORM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_group_member_mids_for_app_platform (CALL_SERVICE_IF (self->handler),
                                                                     &return_value,
                                                                     groupId,
                                                                     &e,
                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupMemberMidsForAppPlatform",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMidsForAppPlatform",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getGroupMemberMidsForAppPlatform implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMidsForAppPlatform",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_language (CallServiceProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserLanguageArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_LANGUAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gchar * return_value;
    CallServiceGetUserLanguageResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_LANGUAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_language (CALL_SERVICE_IF (self->handler),
                                                &return_value,
                                                &e,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserLanguage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLanguage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserLanguage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLanguage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_lookup_paid_call (CallServiceProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceLookupPaidCallArgs * args =
    g_object_new (TYPE_CALL_SERVICE_LOOKUP_PAID_CALL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * dialedNumber;
    gchar * language;
    gchar * referer;
    TalkException * e = NULL;
    PaidCallResponse * return_value;
    CallServiceLookupPaidCallResult * result_struct;

    g_object_get (args,
                  "dialedNumber", &dialedNumber,
                  "language", &language,
                  "referer", &referer,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_LOOKUP_PAID_CALL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_lookup_paid_call (CALL_SERVICE_IF (self->handler),
                                               &return_value,
                                               dialedNumber,
                                               language,
                                               referer,
                                               &e,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "lookupPaidCall",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupPaidCall",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.lookupPaidCall implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupPaidCall",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (dialedNumber != NULL)
      g_free (dialedNumber);
    if (language != NULL)
      g_free (language);
    if (referer != NULL)
      g_free (referer);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_extended_profile (CallServiceProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetExtendedProfileArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_EXTENDED_PROFILE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    ExtendedProfile * return_value;
    CallServiceGetExtendedProfileResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_EXTENDED_PROFILE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_extended_profile (CALL_SERVICE_IF (self->handler),
                                                   &return_value,
                                                   &e,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getExtendedProfile",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getExtendedProfile",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getExtendedProfile implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getExtendedProfile",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_reverse_compact_contacts (CallServiceProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetReverseCompactContactsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_REVERSE_COMPACT_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * ids;
    TalkException * e = NULL;
    GHashTable * return_value;
    CallServiceGetReverseCompactContactsResult * result_struct;

    g_object_get (args,
                  "ids", &ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_REVERSE_COMPACT_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_reverse_compact_contacts (CALL_SERVICE_IF (self->handler),
                                                           &return_value,
                                                           ids,
                                                           &e,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getReverseCompactContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getReverseCompactContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getReverseCompactContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getReverseCompactContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ids != NULL)
      g_ptr_array_unref (ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_paid_call_ad_status (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetPaidCallAdStatusArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_AD_STATUS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    PaidCallAdResult * return_value;
    CallServiceGetPaidCallAdStatusResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PAID_CALL_AD_STATUS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_paid_call_ad_status (CALL_SERVICE_IF (self->handler),
                                                      &return_value,
                                                      &e,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPaidCallAdStatus",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallAdStatus",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getPaidCallAdStatus implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPaidCallAdStatus",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel (CallServiceProcessor *self,
                                                                                       gint32 sequence_id,
                                                                                       ThriftProtocol *input_protocol,
                                                                                       ThriftProtocol *output_protocol,
                                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceFindContactByUseridWithoutAbuseBlockForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_FIND_CONTACT_BY_USERID_WITHOUT_ABUSE_BLOCK_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * userid;
    TalkException * e = NULL;
    Contact * return_value;
    CallServiceFindContactByUseridWithoutAbuseBlockForChannelResult * result_struct;

    g_object_get (args,
                  "userid", &userid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_FIND_CONTACT_BY_USERID_WITHOUT_ABUSE_BLOCK_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_find_contact_by_userid_without_abuse_block_for_channel (CALL_SERVICE_IF (self->handler),
                                                                                     &return_value,
                                                                                     userid,
                                                                                     &e,
                                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findContactByUseridWithoutAbuseBlockForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findContactByUseridWithoutAbuseBlockForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.findContactByUseridWithoutAbuseBlockForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findContactByUseridWithoutAbuseBlockForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (userid != NULL)
      g_free (userid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_group_member_mids (CallServiceProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetGroupMemberMidsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_GROUP_MEMBER_MIDS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetGroupMemberMidsResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_GROUP_MEMBER_MIDS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_group_member_mids (CALL_SERVICE_IF (self->handler),
                                                    &return_value,
                                                    groupId,
                                                    &e,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupMemberMids",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMids",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getGroupMemberMids implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMids",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_send_message_without_relationship (CallServiceProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceSendMessageWithoutRelationshipArgs * args =
    g_object_new (TYPE_CALL_SERVICE_SEND_MESSAGE_WITHOUT_RELATIONSHIP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Message * message;
    TalkException * e = NULL;
    Message * return_value;
    CallServiceSendMessageWithoutRelationshipResult * result_struct;

    g_object_get (args,
                  "message", &message,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_SEND_MESSAGE_WITHOUT_RELATIONSHIP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_send_message_without_relationship (CALL_SERVICE_IF (self->handler),
                                                                &return_value,
                                                                message,
                                                                &e,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendMessageWithoutRelationship",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageWithoutRelationship",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.sendMessageWithoutRelationship implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageWithoutRelationship",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (message != NULL)
      g_object_unref (message);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_display_buddy_subscriber_count_in_bulk (CallServiceProcessor *self,
                                                                       gint32 sequence_id,
                                                                       ThriftProtocol *input_protocol,
                                                                       ThriftProtocol *output_protocol,
                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceDisplayBuddySubscriberCountInBulkArgs * args =
    g_object_new (TYPE_CALL_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_IN_BULK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * mids;
    TalkException * e = NULL;
    GHashTable * return_value;
    CallServiceDisplayBuddySubscriberCountInBulkResult * result_struct;

    g_object_get (args,
                  "mids", &mids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_IN_BULK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_display_buddy_subscriber_count_in_bulk (CALL_SERVICE_IF (self->handler),
                                                                     &return_value,
                                                                     mids,
                                                                     &e,
                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "displayBuddySubscriberCountInBulk",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCountInBulk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.displayBuddySubscriberCountInBulk implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCountInBulk",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mids != NULL)
      g_ptr_array_unref (mids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_lookup_room_members (CallServiceProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceLookupRoomMembersArgs * args =
    g_object_new (TYPE_CALL_SERVICE_LOOKUP_ROOM_MEMBERS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * roomId;
    GPtrArray * mids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceLookupRoomMembersResult * result_struct;

    g_object_get (args,
                  "roomId", &roomId,
                  "mids", &mids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_LOOKUP_ROOM_MEMBERS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_lookup_room_members (CALL_SERVICE_IF (self->handler),
                                                  &return_value,
                                                  roomId,
                                                  mids,
                                                  &e,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "lookupRoomMembers",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupRoomMembers",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.lookupRoomMembers implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "lookupRoomMembers",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (roomId != NULL)
      g_free (roomId);
    if (mids != NULL)
      g_ptr_array_unref (mids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_favorite_mids_for_channel (CallServiceProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetFavoriteMidsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_FAVORITE_MIDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetFavoriteMidsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_FAVORITE_MIDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_favorite_mids_for_channel (CALL_SERVICE_IF (self->handler),
                                                            &return_value,
                                                            &e,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFavoriteMidsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteMidsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getFavoriteMidsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteMidsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_all_contact_ids_for_channel (CallServiceProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetAllContactIdsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_ALL_CONTACT_IDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetAllContactIdsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_ALL_CONTACT_IDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_all_contact_ids_for_channel (CALL_SERVICE_IF (self->handler),
                                                              &return_value,
                                                              &e,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getAllContactIdsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllContactIdsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getAllContactIdsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllContactIdsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_display_buddy_subscriber_count (CallServiceProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceDisplayBuddySubscriberCountArgs * args =
    g_object_new (TYPE_CALL_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    CallServiceDisplayBuddySubscriberCountResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_display_buddy_subscriber_count (CALL_SERVICE_IF (self->handler),
                                                             &return_value,
                                                             &e,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "displayBuddySubscriberCount",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCount",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.displayBuddySubscriberCount implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCount",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_profile_for_channel (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetProfileForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_PROFILE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    Profile * return_value;
    CallServiceGetProfileForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_PROFILE_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_profile_for_channel (CALL_SERVICE_IF (self->handler),
                                                      &return_value,
                                                      &e,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getProfileForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProfileForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getProfileForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProfileForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_tickets (CallServiceProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserTicketsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_TICKETS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * userMids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetUserTicketsResult * result_struct;

    g_object_get (args,
                  "userMids", &userMids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_TICKETS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_tickets (CALL_SERVICE_IF (self->handler),
                                               &return_value,
                                               userMids,
                                               &e,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserTickets",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserTickets",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserTickets implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserTickets",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (userMids != NULL)
      g_ptr_array_unref (userMids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_o_a_friend_mids (CallServiceProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetOAFriendMidsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_O_A_FRIEND_MIDS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetOAFriendMidsResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_O_A_FRIEND_MIDS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_o_a_friend_mids (CALL_SERVICE_IF (self->handler),
                                                  &return_value,
                                                  &e,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getOAFriendMids",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getOAFriendMids",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getOAFriendMids implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getOAFriendMids",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_search_paid_call_user_rate (CallServiceProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceSearchPaidCallUserRateArgs * args =
    g_object_new (TYPE_CALL_SERVICE_SEARCH_PAID_CALL_USER_RATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * countryCode;
    gchar * language;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceSearchPaidCallUserRateResult * result_struct;

    g_object_get (args,
                  "countryCode", &countryCode,
                  "language", &language,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_SEARCH_PAID_CALL_USER_RATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_search_paid_call_user_rate (CALL_SERVICE_IF (self->handler),
                                                         &return_value,
                                                         countryCode,
                                                         language,
                                                         &e,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "searchPaidCallUserRate",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "searchPaidCallUserRate",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.searchPaidCallUserRate implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "searchPaidCallUserRate",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (countryCode != NULL)
      g_free (countryCode);
    if (language != NULL)
      g_free (language);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_joined_group_ids_for_channel (CallServiceProcessor *self,
                                                                 gint32 sequence_id,
                                                                 ThriftProtocol *input_protocol,
                                                                 ThriftProtocol *output_protocol,
                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetJoinedGroupIdsForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_JOINED_GROUP_IDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetJoinedGroupIdsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_JOINED_GROUP_IDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_joined_group_ids_for_channel (CALL_SERVICE_IF (self->handler),
                                                               &return_value,
                                                               &e,
                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getJoinedGroupIdsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getJoinedGroupIdsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getJoinedGroupIdsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getJoinedGroupIdsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_acquire_group_call_route (CallServiceProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceAcquireGroupCallRouteArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ACQUIRE_GROUP_CALL_ROUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * chatMid;
    GroupCallMediaType mediaType;
    TalkException * e = NULL;
    GroupCallRoute * return_value;
    CallServiceAcquireGroupCallRouteResult * result_struct;

    g_object_get (args,
                  "chatMid", &chatMid,
                  "mediaType", &mediaType,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ACQUIRE_GROUP_CALL_ROUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_acquire_group_call_route (CALL_SERVICE_IF (self->handler),
                                                       &return_value,
                                                       chatMid,
                                                       mediaType,
                                                       &e,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "acquireGroupCallRoute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquireGroupCallRoute",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.acquireGroupCallRoute implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "acquireGroupCallRoute",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (chatMid != NULL)
      g_free (chatMid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_mids_who_added_me (CallServiceProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserMidsWhoAddedMeArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_MIDS_WHO_ADDED_ME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetUserMidsWhoAddedMeResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_MIDS_WHO_ADDED_ME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_mids_who_added_me (CALL_SERVICE_IF (self->handler),
                                                         &return_value,
                                                         &e,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserMidsWhoAddedMe",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserMidsWhoAddedMe",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserMidsWhoAddedMe implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserMidsWhoAddedMe",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_identity_credential (CallServiceProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetIdentityCredentialArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_IDENTITY_CREDENTIAL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    IdentityCredential * return_value;
    CallServiceGetIdentityCredentialResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_IDENTITY_CREDENTIAL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_identity_credential (CALL_SERVICE_IF (self->handler),
                                                      &return_value,
                                                      &e,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getIdentityCredential",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getIdentityCredential",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getIdentityCredential implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getIdentityCredential",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_add_operation_for_channel (CallServiceProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceAddOperationForChannelArgs * args =
    g_object_new (TYPE_CALL_SERVICE_ADD_OPERATION_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    OpType opType;
    gchar * param1;
    gchar * param2;
    gchar * param3;
    TalkException * e = NULL;
    CallServiceAddOperationForChannelResult * result_struct;

    g_object_get (args,
                  "opType", &opType,
                  "param1", &param1,
                  "param2", &param2,
                  "param3", &param3,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_ADD_OPERATION_FOR_CHANNEL_RESULT, NULL);

    if (call_service_handler_add_operation_for_channel (CALL_SERVICE_IF (self->handler),
                                                        opType,
                                                        param1,
                                                        param2,
                                                        param3,
                                                        &e,
                                                        error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addOperationForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addOperationForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.addOperationForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addOperationForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (param1 != NULL)
      g_free (param1);
    if (param2 != NULL)
      g_free (param2);
    if (param3 != NULL)
      g_free (param3);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_simple_channel_contacts (CallServiceProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetSimpleChannelContactsArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_SIMPLE_CHANNEL_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * ids;
    gboolean statusSticonFallbackDisabled;
    TalkException * e = NULL;
    GPtrArray * return_value;
    CallServiceGetSimpleChannelContactsResult * result_struct;

    g_object_get (args,
                  "ids", &ids,
                  "statusSticonFallbackDisabled", &statusSticonFallbackDisabled,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_SIMPLE_CHANNEL_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_simple_channel_contacts (CALL_SERVICE_IF (self->handler),
                                                          &return_value,
                                                          ids,
                                                          statusSticonFallbackDisabled,
                                                          &e,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSimpleChannelContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSimpleChannelContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getSimpleChannelContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSimpleChannelContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ids != NULL)
      g_ptr_array_unref (ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_process_get_user_last_sent_message_time_stamp (CallServiceProcessor *self,
                                                                      gint32 sequence_id,
                                                                      ThriftProtocol *input_protocol,
                                                                      ThriftProtocol *output_protocol,
                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  CallServiceGetUserLastSentMessageTimeStampArgs * args =
    g_object_new (TYPE_CALL_SERVICE_GET_USER_LAST_SENT_MESSAGE_TIME_STAMP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    gint64 return_value;
    CallServiceGetUserLastSentMessageTimeStampResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CALL_SERVICE_GET_USER_LAST_SENT_MESSAGE_TIME_STAMP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (call_service_handler_get_user_last_sent_message_time_stamp (CALL_SERVICE_IF (self->handler),
                                                                    &return_value,
                                                                    mid,
                                                                    &e,
                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserLastSentMessageTimeStamp",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLastSentMessageTimeStamp",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("CallService.getUserLastSentMessageTimeStamp implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLastSentMessageTimeStamp",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
call_service_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      gchar *method_name,
                                      gint32 sequence_id,
                                      GError **error)
{
  call_service_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  CallServiceProcessor *self = CALL_SERVICE_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (CALL_SERVICE_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    g_free (method_name);
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
call_service_processor_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  CallServiceProcessor *self = CALL_SERVICE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_CALL_SERVICE_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
call_service_processor_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  CallServiceProcessor *self = CALL_SERVICE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_CALL_SERVICE_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
call_service_processor_dispose (GObject *gobject)
{
  CallServiceProcessor *self = CALL_SERVICE_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (call_service_processor_parent_class)->dispose (gobject);
}

static void
call_service_processor_finalize (GObject *gobject)
{
  CallServiceProcessor *self = CALL_SERVICE_PROCESSOR (gobject);

  thrift_safe_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (call_service_processor_parent_class)->finalize (gobject);
}

static void
call_service_processor_init (CallServiceProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 72; index += 1)
    g_hash_table_insert (self->process_map,
                         call_service_processor_process_function_defs[index].name,
                         &call_service_processor_process_function_defs[index]);
}

static void
call_service_processor_class_init (CallServiceProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = call_service_processor_dispose;
  gobject_class->finalize = call_service_processor_finalize;
  gobject_class->set_property = call_service_processor_set_property;
  gobject_class->get_property = call_service_processor_get_property;

  dispatch_processor_class->dispatch_call = call_service_processor_dispatch_call;
  cls->dispatch_call = call_service_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_CALL_SERVICE_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CALL_SERVICE_PROCESSOR_HANDLER,
                                   param_spec);
}
