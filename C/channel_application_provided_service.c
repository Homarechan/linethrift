/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "channel_application_provided_service.h"

gboolean
channel_application_provided_service_if_active_buddy_subscriber_count (ChannelApplicationProvidedServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->active_buddy_subscriber_count (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_add_operation_for_channel (ChannelApplicationProvidedServiceIf *iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->add_operation_for_channel (iface, opType, param1, param2, param3, e, error);
}

gboolean
channel_application_provided_service_if_display_buddy_subscriber_count (ChannelApplicationProvidedServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->display_buddy_subscriber_count (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceIf *iface, Contact ** _return, const gchar * userid, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->find_contact_by_userid_without_abuse_block_for_channel (iface, _return, userid, e, error);
}

gboolean
channel_application_provided_service_if_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_all_contact_ids_for_channel (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_compact_contacts (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_compact_contacts (iface, _return, lastModifiedTimestamp, e, error);
}

gboolean
channel_application_provided_service_if_get_contacts_for_channel (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_contacts_for_channel (iface, _return, ids, e, error);
}

gboolean
channel_application_provided_service_if_get_display_name (ChannelApplicationProvidedServiceIf *iface, gchar ** _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_display_name (iface, _return, mid, e, error);
}

gboolean
channel_application_provided_service_if_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_favorite_mids_for_channel (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_friend_mids (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_friend_mids (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_group_member_mids (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_group_member_mids (iface, _return, groupId, e, error);
}

gboolean
channel_application_provided_service_if_get_groups_for_channel (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_groups_for_channel (iface, _return, groupIds, e, error);
}

gboolean
channel_application_provided_service_if_get_identity_credential (ChannelApplicationProvidedServiceIf *iface, IdentityCredential ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_identity_credential (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_joined_group_ids_for_channel (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_meta_profile (ChannelApplicationProvidedServiceIf *iface, MetaProfile ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_meta_profile (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_mid (ChannelApplicationProvidedServiceIf *iface, gchar ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_mid (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_primary_client_for_channel (ChannelApplicationProvidedServiceIf *iface, SimpleChannelClient ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_primary_client_for_channel (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_profile_for_channel (ChannelApplicationProvidedServiceIf *iface, Profile ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_profile_for_channel (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_simple_channel_contacts (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_simple_channel_contacts (iface, _return, ids, e, error);
}

gboolean
channel_application_provided_service_if_get_user_country_for_billing (ChannelApplicationProvidedServiceIf *iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_user_country_for_billing (iface, _return, country, remoteIp, e, error);
}

gboolean
channel_application_provided_service_if_get_user_create_time (ChannelApplicationProvidedServiceIf *iface, gint64* _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_user_create_time (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_user_identities (ChannelApplicationProvidedServiceIf *iface, GHashTable ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_user_identities (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_user_language (ChannelApplicationProvidedServiceIf *iface, gchar ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_user_language (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_get_user_mids_who_added_me (ChannelApplicationProvidedServiceIf *iface, GPtrArray ** _return, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->get_user_mids_who_added_me (iface, _return, e, error);
}

gboolean
channel_application_provided_service_if_is_group_member (ChannelApplicationProvidedServiceIf *iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->is_group_member (iface, _return, groupId, e, error);
}

gboolean
channel_application_provided_service_if_is_in_contact (ChannelApplicationProvidedServiceIf *iface, gboolean* _return, const gchar * mid, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->is_in_contact (iface, _return, mid, e, error);
}

gboolean
channel_application_provided_service_if_register_channel_c_p (ChannelApplicationProvidedServiceIf *iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->register_channel_c_p (iface, _return, cpId, registerPassword, e, error);
}

gboolean
channel_application_provided_service_if_remove_notification_status (ChannelApplicationProvidedServiceIf *iface, const NotificationStatus notificationStatus, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->remove_notification_status (iface, notificationStatus, e, error);
}

gboolean
channel_application_provided_service_if_send_message_for_channel (ChannelApplicationProvidedServiceIf *iface, Message ** _return, const Message * message, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->send_message_for_channel (iface, _return, message, e, error);
}

gboolean
channel_application_provided_service_if_send_pin_code_operation (ChannelApplicationProvidedServiceIf *iface, const gchar * verifier, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->send_pin_code_operation (iface, verifier, e, error);
}

gboolean
channel_application_provided_service_if_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceIf *iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError **error)
{
  return CHANNEL_APPLICATION_PROVIDED_SERVICE_IF_GET_INTERFACE (iface)->update_profile_attribute_for_channel (iface, profileAttribute, value, e, error);
}

GType
channel_application_provided_service_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (ChannelApplicationProvidedServiceIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "ChannelApplicationProvidedServiceIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
channel_application_provided_service_if_interface_init (ChannelApplicationProvidedServiceIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (ChannelApplicationProvidedServiceClient, channel_application_provided_service_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IF,
                                                channel_application_provided_service_if_interface_init))

enum _ChannelApplicationProvidedServiceClientProperties
{
  PROP_0,
  PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_INPUT_PROTOCOL,
  PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_OUTPUT_PROTOCOL
};

void
channel_application_provided_service_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  ChannelApplicationProvidedServiceClient *client = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
channel_application_provided_service_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  ChannelApplicationProvidedServiceClient *client = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean channel_application_provided_service_client_send_active_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "activeBuddySubscriberCount", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "activeBuddySubscriberCount_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_active_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "activeBuddySubscriberCount", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected activeBuddySubscriberCount", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_active_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_active_buddy_subscriber_count (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_active_buddy_subscriber_count (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_add_operation_for_channel (ChannelApplicationProvidedServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addOperationForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addOperationForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "opType", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) opType, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param1", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param1, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param2", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param2, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "param3", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, param3, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_add_operation_for_channel (ChannelApplicationProvidedServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addOperationForChannel", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addOperationForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_add_operation_for_channel (ChannelApplicationProvidedServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_add_operation_for_channel (iface, opType, param1, param2, param3, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_add_operation_for_channel (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_display_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "displayBuddySubscriberCount", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "displayBuddySubscriberCount_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_display_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "displayBuddySubscriberCount", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected displayBuddySubscriberCount", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_display_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_display_buddy_subscriber_count (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_display_buddy_subscriber_count (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceIf * iface, const gchar * userid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findContactByUseridWithoutAbuseBlockForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findContactByUseridWithoutAbuseBlockForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, userid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceIf * iface, Contact ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findContactByUseridWithoutAbuseBlockForChannel", 46) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findContactByUseridWithoutAbuseBlockForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceIf * iface, Contact ** _return, const gchar * userid, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_find_contact_by_userid_without_abuse_block_for_channel (iface, userid, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_find_contact_by_userid_without_abuse_block_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getAllContactIdsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getAllContactIdsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getAllContactIdsForChannel", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getAllContactIdsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem646 = NULL;
                if (_elem646 != NULL)
                {
                  g_free(_elem646);
                  _elem646 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem646, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem646);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_all_contact_ids_for_channel (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_all_contact_ids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_compact_contacts (ChannelApplicationProvidedServiceIf * iface, const gint64 lastModifiedTimestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getCompactContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getCompactContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "lastModifiedTimestamp", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, lastModifiedTimestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_compact_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getCompactContacts", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getCompactContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                CompactContact * _elem647 = NULL;
                if ( _elem647 != NULL)
                {
                  g_object_unref (_elem647);
                }
                _elem647 = g_object_new (TYPE_COMPACT_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem647), protocol, error)) < 0)
                {
                  g_object_unref (_elem647);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem647);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_compact_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_compact_contacts (iface, lastModifiedTimestamp, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_compact_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_contacts_for_channel (ChannelApplicationProvidedServiceIf * iface, const GPtrArray * ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getContactsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getContactsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i648;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (ids ? ids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i648 = 0; i648 < (ids ? ids->len : 0); i648++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ids, i648)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_contacts_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getContactsForChannel", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getContactsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Contact * _elem649 = NULL;
                if ( _elem649 != NULL)
                {
                  g_object_unref (_elem649);
                }
                _elem649 = g_object_new (TYPE_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem649), protocol, error)) < 0)
                {
                  g_object_unref (_elem649);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem649);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_contacts_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_contacts_for_channel (iface, ids, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_contacts_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_display_name (ChannelApplicationProvidedServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDisplayName", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDisplayName_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_display_name (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDisplayName", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDisplayName", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_display_name (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_display_name (iface, mid, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_display_name (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFavoriteMidsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFavoriteMidsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFavoriteMidsForChannel", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFavoriteMidsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem650 = NULL;
                if (_elem650 != NULL)
                {
                  g_free(_elem650);
                  _elem650 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem650, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem650);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_favorite_mids_for_channel (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_favorite_mids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_friend_mids (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFriendMids", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFriendMids_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_friend_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFriendMids", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFriendMids", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem651 = NULL;
                if (_elem651 != NULL)
                {
                  g_free(_elem651);
                  _elem651 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem651, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem651);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_friend_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_friend_mids (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_friend_mids (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_group_member_mids (ChannelApplicationProvidedServiceIf * iface, const gchar * groupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupMemberMids", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupMemberMids_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_group_member_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupMemberMids", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupMemberMids", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem652 = NULL;
                if (_elem652 != NULL)
                {
                  g_free(_elem652);
                  _elem652 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem652, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem652);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_group_member_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_group_member_mids (iface, groupId, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_group_member_mids (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_groups_for_channel (ChannelApplicationProvidedServiceIf * iface, const GPtrArray * groupIds, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupIds", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i653;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (groupIds ? groupIds->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i653 = 0; i653 < (groupIds ? groupIds->len : 0); i653++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) groupIds, i653)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_groups_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupsForChannel", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Group * _elem654 = NULL;
                if ( _elem654 != NULL)
                {
                  g_object_unref (_elem654);
                }
                _elem654 = g_object_new (TYPE_GROUP, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem654), protocol, error)) < 0)
                {
                  g_object_unref (_elem654);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem654);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_groups_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_groups_for_channel (iface, groupIds, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_groups_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_identity_credential (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getIdentityCredential", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getIdentityCredential_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_identity_credential (ChannelApplicationProvidedServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getIdentityCredential", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getIdentityCredential", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_identity_credential (ChannelApplicationProvidedServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_identity_credential (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_identity_credential (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getJoinedGroupIdsForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getJoinedGroupIdsForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getJoinedGroupIdsForChannel", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getJoinedGroupIdsForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem655 = NULL;
                if (_elem655 != NULL)
                {
                  g_free(_elem655);
                  _elem655 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem655, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem655);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_joined_group_ids_for_channel (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_joined_group_ids_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_meta_profile (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getMetaProfile", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getMetaProfile_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_meta_profile (ChannelApplicationProvidedServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getMetaProfile", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getMetaProfile", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_meta_profile (ChannelApplicationProvidedServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_meta_profile (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_meta_profile (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_mid (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getMid", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getMid_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_mid (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getMid", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getMid", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_mid (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_mid (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_mid (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_primary_client_for_channel (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPrimaryClientForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPrimaryClientForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_primary_client_for_channel (ChannelApplicationProvidedServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPrimaryClientForChannel", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPrimaryClientForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_primary_client_for_channel (ChannelApplicationProvidedServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_primary_client_for_channel (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_primary_client_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_profile_for_channel (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getProfileForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getProfileForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_profile_for_channel (ChannelApplicationProvidedServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getProfileForChannel", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getProfileForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_profile_for_channel (ChannelApplicationProvidedServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_profile_for_channel (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_profile_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_simple_channel_contacts (ChannelApplicationProvidedServiceIf * iface, const GPtrArray * ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSimpleChannelContacts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSimpleChannelContacts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ids", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i656;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (ids ? ids->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i656 = 0; i656 < (ids ? ids->len : 0); i656++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) ids, i656)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_simple_channel_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSimpleChannelContacts", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSimpleChannelContacts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SimpleChannelContact * _elem657 = NULL;
                if ( _elem657 != NULL)
                {
                  g_object_unref (_elem657);
                }
                _elem657 = g_object_new (TYPE_SIMPLE_CHANNEL_CONTACT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem657), protocol, error)) < 0)
                {
                  g_object_unref (_elem657);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem657);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_simple_channel_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_simple_channel_contacts (iface, ids, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_simple_channel_contacts (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_user_country_for_billing (ChannelApplicationProvidedServiceIf * iface, const gchar * country, const gchar * remoteIp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserCountryForBilling", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserCountryForBilling_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "country", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, country, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "remoteIp", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, remoteIp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_user_country_for_billing (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserCountryForBilling", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserCountryForBilling", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_user_country_for_billing (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_user_country_for_billing (iface, country, remoteIp, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_user_country_for_billing (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_user_create_time (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserCreateTime", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserCreateTime_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_user_create_time (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserCreateTime", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserCreateTime", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_user_create_time (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_user_create_time (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_user_create_time (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_user_identities (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserIdentities", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserIdentities_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_user_identities (ChannelApplicationProvidedServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserIdentities", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserIdentities", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                RegistrationType key658;
                gchar * val659 = NULL;
                gint32 ecast660;
                if ((ret = thrift_protocol_read_i32 (protocol, &ecast660, error)) < 0)
                  return 0;
                xfer += ret;
                key658 = (RegistrationType)ecast660;
                if (val659 != NULL)
                {
                  g_free(val659);
                  val659 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val659, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key658)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key658, (gpointer) val659);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_user_identities (ChannelApplicationProvidedServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_user_identities (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_user_identities (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_user_language (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserLanguage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserLanguage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_user_language (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserLanguage", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserLanguage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_user_language (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_user_language (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_user_language (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_get_user_mids_who_added_me (ChannelApplicationProvidedServiceIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getUserMidsWhoAddedMe", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getUserMidsWhoAddedMe_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_get_user_mids_who_added_me (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getUserMidsWhoAddedMe", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getUserMidsWhoAddedMe", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem661 = NULL;
                if (_elem661 != NULL)
                {
                  g_free(_elem661);
                  _elem661 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem661, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem661);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_get_user_mids_who_added_me (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_get_user_mids_who_added_me (iface, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_get_user_mids_who_added_me (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_is_group_member (ChannelApplicationProvidedServiceIf * iface, const gchar * groupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isGroupMember", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isGroupMember_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, groupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_is_group_member (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isGroupMember", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isGroupMember", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_is_group_member (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_is_group_member (iface, groupId, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_is_group_member (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_is_in_contact (ChannelApplicationProvidedServiceIf * iface, const gchar * mid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isInContact", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isInContact_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_is_in_contact (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isInContact", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isInContact", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_is_in_contact (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_is_in_contact (iface, mid, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_is_in_contact (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_register_channel_c_p (ChannelApplicationProvidedServiceIf * iface, const gchar * cpId, const gchar * registerPassword, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "registerChannelCP", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "registerChannelCP_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "cpId", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, cpId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "registerPassword", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, registerPassword, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_register_channel_c_p (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "registerChannelCP", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected registerChannelCP", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_register_channel_c_p (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_register_channel_c_p (iface, cpId, registerPassword, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_register_channel_c_p (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_remove_notification_status (ChannelApplicationProvidedServiceIf * iface, const NotificationStatus notificationStatus, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "removeNotificationStatus", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "removeNotificationStatus_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notificationStatus", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) notificationStatus, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_remove_notification_status (ChannelApplicationProvidedServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "removeNotificationStatus", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected removeNotificationStatus", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_remove_notification_status (ChannelApplicationProvidedServiceIf * iface, const NotificationStatus notificationStatus, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_remove_notification_status (iface, notificationStatus, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_remove_notification_status (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_send_message_for_channel (ChannelApplicationProvidedServiceIf * iface, const Message * message, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendMessageForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendMessageForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (message), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_send_message_for_channel (ChannelApplicationProvidedServiceIf * iface, Message ** _return, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendMessageForChannel", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendMessageForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_send_message_for_channel (ChannelApplicationProvidedServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_send_message_for_channel (iface, message, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_send_message_for_channel (iface, _return, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_send_pin_code_operation (ChannelApplicationProvidedServiceIf * iface, const gchar * verifier, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sendPinCodeOperation", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sendPinCodeOperation_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifier", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, verifier, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_send_pin_code_operation (ChannelApplicationProvidedServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sendPinCodeOperation", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sendPinCodeOperation", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_send_pin_code_operation (ChannelApplicationProvidedServiceIf * iface, const gchar * verifier, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_send_pin_code_operation (iface, verifier, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_send_pin_code_operation (iface, e, error))
    return FALSE;
  return TRUE;
}

gboolean channel_application_provided_service_client_send_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateProfileAttributeForChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateProfileAttributeForChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "profileAttribute", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) profileAttribute, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean channel_application_provided_service_client_recv_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceIf * iface, TalkException ** e, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateProfileAttributeForChannel", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateProfileAttributeForChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *e != NULL)
            {
              g_object_unref (*e);
            }
            *e = g_object_new (TYPE_TALK_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*e), protocol, error)) < 0)
            {
              g_object_unref (*e);
              *e = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*e != NULL)
  {
      g_set_error (error, TALK_EXCEPTION_ERROR, TALK_EXCEPTION_ERROR_CODE, "TalkException");
      return FALSE;
  }
  return TRUE;
}

gboolean channel_application_provided_service_client_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError ** error)
{
  if (!channel_application_provided_service_client_send_update_profile_attribute_for_channel (iface, profileAttribute, value, error))
    return FALSE;
  if (!channel_application_provided_service_client_recv_update_profile_attribute_for_channel (iface, e, error))
    return FALSE;
  return TRUE;
}

static void
channel_application_provided_service_if_interface_init (ChannelApplicationProvidedServiceIfInterface *iface)
{
  iface->active_buddy_subscriber_count = channel_application_provided_service_client_active_buddy_subscriber_count;
  iface->add_operation_for_channel = channel_application_provided_service_client_add_operation_for_channel;
  iface->display_buddy_subscriber_count = channel_application_provided_service_client_display_buddy_subscriber_count;
  iface->find_contact_by_userid_without_abuse_block_for_channel = channel_application_provided_service_client_find_contact_by_userid_without_abuse_block_for_channel;
  iface->get_all_contact_ids_for_channel = channel_application_provided_service_client_get_all_contact_ids_for_channel;
  iface->get_compact_contacts = channel_application_provided_service_client_get_compact_contacts;
  iface->get_contacts_for_channel = channel_application_provided_service_client_get_contacts_for_channel;
  iface->get_display_name = channel_application_provided_service_client_get_display_name;
  iface->get_favorite_mids_for_channel = channel_application_provided_service_client_get_favorite_mids_for_channel;
  iface->get_friend_mids = channel_application_provided_service_client_get_friend_mids;
  iface->get_group_member_mids = channel_application_provided_service_client_get_group_member_mids;
  iface->get_groups_for_channel = channel_application_provided_service_client_get_groups_for_channel;
  iface->get_identity_credential = channel_application_provided_service_client_get_identity_credential;
  iface->get_joined_group_ids_for_channel = channel_application_provided_service_client_get_joined_group_ids_for_channel;
  iface->get_meta_profile = channel_application_provided_service_client_get_meta_profile;
  iface->get_mid = channel_application_provided_service_client_get_mid;
  iface->get_primary_client_for_channel = channel_application_provided_service_client_get_primary_client_for_channel;
  iface->get_profile_for_channel = channel_application_provided_service_client_get_profile_for_channel;
  iface->get_simple_channel_contacts = channel_application_provided_service_client_get_simple_channel_contacts;
  iface->get_user_country_for_billing = channel_application_provided_service_client_get_user_country_for_billing;
  iface->get_user_create_time = channel_application_provided_service_client_get_user_create_time;
  iface->get_user_identities = channel_application_provided_service_client_get_user_identities;
  iface->get_user_language = channel_application_provided_service_client_get_user_language;
  iface->get_user_mids_who_added_me = channel_application_provided_service_client_get_user_mids_who_added_me;
  iface->is_group_member = channel_application_provided_service_client_is_group_member;
  iface->is_in_contact = channel_application_provided_service_client_is_in_contact;
  iface->register_channel_c_p = channel_application_provided_service_client_register_channel_c_p;
  iface->remove_notification_status = channel_application_provided_service_client_remove_notification_status;
  iface->send_message_for_channel = channel_application_provided_service_client_send_message_for_channel;
  iface->send_pin_code_operation = channel_application_provided_service_client_send_pin_code_operation;
  iface->update_profile_attribute_for_channel = channel_application_provided_service_client_update_profile_attribute_for_channel;
}

static void
channel_application_provided_service_client_init (ChannelApplicationProvidedServiceClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
channel_application_provided_service_client_class_init (ChannelApplicationProvidedServiceClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = channel_application_provided_service_client_set_property;
  gobject_class->get_property = channel_application_provided_service_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
channel_application_provided_service_handler_channel_application_provided_service_if_interface_init (ChannelApplicationProvidedServiceIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (ChannelApplicationProvidedServiceHandler, 
                         channel_application_provided_service_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IF,
                                                channel_application_provided_service_handler_channel_application_provided_service_if_interface_init))

gboolean channel_application_provided_service_handler_active_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->active_buddy_subscriber_count (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_add_operation_for_channel (ChannelApplicationProvidedServiceIf * iface, const OpType opType, const gchar * param1, const gchar * param2, const gchar * param3, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->add_operation_for_channel (iface, opType, param1, param2, param3, e, error);
}

gboolean channel_application_provided_service_handler_display_buddy_subscriber_count (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->display_buddy_subscriber_count (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceIf * iface, Contact ** _return, const gchar * userid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->find_contact_by_userid_without_abuse_block_for_channel (iface, _return, userid, e, error);
}

gboolean channel_application_provided_service_handler_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_all_contact_ids_for_channel (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_compact_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const gint64 lastModifiedTimestamp, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_compact_contacts (iface, _return, lastModifiedTimestamp, e, error);
}

gboolean channel_application_provided_service_handler_get_contacts_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_contacts_for_channel (iface, _return, ids, e, error);
}

gboolean channel_application_provided_service_handler_get_display_name (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_display_name (iface, _return, mid, e, error);
}

gboolean channel_application_provided_service_handler_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_favorite_mids_for_channel (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_friend_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_friend_mids (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_group_member_mids (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_group_member_mids (iface, _return, groupId, e, error);
}

gboolean channel_application_provided_service_handler_get_groups_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * groupIds, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_groups_for_channel (iface, _return, groupIds, e, error);
}

gboolean channel_application_provided_service_handler_get_identity_credential (ChannelApplicationProvidedServiceIf * iface, IdentityCredential ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_identity_credential (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_joined_group_ids_for_channel (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_meta_profile (ChannelApplicationProvidedServiceIf * iface, MetaProfile ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_meta_profile (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_mid (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_mid (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_primary_client_for_channel (ChannelApplicationProvidedServiceIf * iface, SimpleChannelClient ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_primary_client_for_channel (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_profile_for_channel (ChannelApplicationProvidedServiceIf * iface, Profile ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_profile_for_channel (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_simple_channel_contacts (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, const GPtrArray * ids, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_simple_channel_contacts (iface, _return, ids, e, error);
}

gboolean channel_application_provided_service_handler_get_user_country_for_billing (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * country, const gchar * remoteIp, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_user_country_for_billing (iface, _return, country, remoteIp, e, error);
}

gboolean channel_application_provided_service_handler_get_user_create_time (ChannelApplicationProvidedServiceIf * iface, gint64* _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_user_create_time (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_user_identities (ChannelApplicationProvidedServiceIf * iface, GHashTable ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_user_identities (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_user_language (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_user_language (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_get_user_mids_who_added_me (ChannelApplicationProvidedServiceIf * iface, GPtrArray ** _return, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->get_user_mids_who_added_me (iface, _return, e, error);
}

gboolean channel_application_provided_service_handler_is_group_member (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, const gchar * groupId, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->is_group_member (iface, _return, groupId, e, error);
}

gboolean channel_application_provided_service_handler_is_in_contact (ChannelApplicationProvidedServiceIf * iface, gboolean* _return, const gchar * mid, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->is_in_contact (iface, _return, mid, e, error);
}

gboolean channel_application_provided_service_handler_register_channel_c_p (ChannelApplicationProvidedServiceIf * iface, gchar ** _return, const gchar * cpId, const gchar * registerPassword, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->register_channel_c_p (iface, _return, cpId, registerPassword, e, error);
}

gboolean channel_application_provided_service_handler_remove_notification_status (ChannelApplicationProvidedServiceIf * iface, const NotificationStatus notificationStatus, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->remove_notification_status (iface, notificationStatus, e, error);
}

gboolean channel_application_provided_service_handler_send_message_for_channel (ChannelApplicationProvidedServiceIf * iface, Message ** _return, const Message * message, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->send_message_for_channel (iface, _return, message, e, error);
}

gboolean channel_application_provided_service_handler_send_pin_code_operation (ChannelApplicationProvidedServiceIf * iface, const gchar * verifier, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->send_pin_code_operation (iface, verifier, e, error);
}

gboolean channel_application_provided_service_handler_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceIf * iface, const ProfileAttribute profileAttribute, const gchar * value, TalkException ** e, GError ** error)
{
  g_return_val_if_fail (IS_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER (iface), FALSE);

  return CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER_GET_CLASS (iface)->update_profile_attribute_for_channel (iface, profileAttribute, value, e, error);
}

static void
channel_application_provided_service_handler_channel_application_provided_service_if_interface_init (ChannelApplicationProvidedServiceIfInterface *iface)
{
  iface->active_buddy_subscriber_count = channel_application_provided_service_handler_active_buddy_subscriber_count;
  iface->add_operation_for_channel = channel_application_provided_service_handler_add_operation_for_channel;
  iface->display_buddy_subscriber_count = channel_application_provided_service_handler_display_buddy_subscriber_count;
  iface->find_contact_by_userid_without_abuse_block_for_channel = channel_application_provided_service_handler_find_contact_by_userid_without_abuse_block_for_channel;
  iface->get_all_contact_ids_for_channel = channel_application_provided_service_handler_get_all_contact_ids_for_channel;
  iface->get_compact_contacts = channel_application_provided_service_handler_get_compact_contacts;
  iface->get_contacts_for_channel = channel_application_provided_service_handler_get_contacts_for_channel;
  iface->get_display_name = channel_application_provided_service_handler_get_display_name;
  iface->get_favorite_mids_for_channel = channel_application_provided_service_handler_get_favorite_mids_for_channel;
  iface->get_friend_mids = channel_application_provided_service_handler_get_friend_mids;
  iface->get_group_member_mids = channel_application_provided_service_handler_get_group_member_mids;
  iface->get_groups_for_channel = channel_application_provided_service_handler_get_groups_for_channel;
  iface->get_identity_credential = channel_application_provided_service_handler_get_identity_credential;
  iface->get_joined_group_ids_for_channel = channel_application_provided_service_handler_get_joined_group_ids_for_channel;
  iface->get_meta_profile = channel_application_provided_service_handler_get_meta_profile;
  iface->get_mid = channel_application_provided_service_handler_get_mid;
  iface->get_primary_client_for_channel = channel_application_provided_service_handler_get_primary_client_for_channel;
  iface->get_profile_for_channel = channel_application_provided_service_handler_get_profile_for_channel;
  iface->get_simple_channel_contacts = channel_application_provided_service_handler_get_simple_channel_contacts;
  iface->get_user_country_for_billing = channel_application_provided_service_handler_get_user_country_for_billing;
  iface->get_user_create_time = channel_application_provided_service_handler_get_user_create_time;
  iface->get_user_identities = channel_application_provided_service_handler_get_user_identities;
  iface->get_user_language = channel_application_provided_service_handler_get_user_language;
  iface->get_user_mids_who_added_me = channel_application_provided_service_handler_get_user_mids_who_added_me;
  iface->is_group_member = channel_application_provided_service_handler_is_group_member;
  iface->is_in_contact = channel_application_provided_service_handler_is_in_contact;
  iface->register_channel_c_p = channel_application_provided_service_handler_register_channel_c_p;
  iface->remove_notification_status = channel_application_provided_service_handler_remove_notification_status;
  iface->send_message_for_channel = channel_application_provided_service_handler_send_message_for_channel;
  iface->send_pin_code_operation = channel_application_provided_service_handler_send_pin_code_operation;
  iface->update_profile_attribute_for_channel = channel_application_provided_service_handler_update_profile_attribute_for_channel;
}

static void
channel_application_provided_service_handler_init (ChannelApplicationProvidedServiceHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
channel_application_provided_service_handler_class_init (ChannelApplicationProvidedServiceHandlerClass *cls)
{
  cls->active_buddy_subscriber_count = NULL;
  cls->add_operation_for_channel = NULL;
  cls->display_buddy_subscriber_count = NULL;
  cls->find_contact_by_userid_without_abuse_block_for_channel = NULL;
  cls->get_all_contact_ids_for_channel = NULL;
  cls->get_compact_contacts = NULL;
  cls->get_contacts_for_channel = NULL;
  cls->get_display_name = NULL;
  cls->get_favorite_mids_for_channel = NULL;
  cls->get_friend_mids = NULL;
  cls->get_group_member_mids = NULL;
  cls->get_groups_for_channel = NULL;
  cls->get_identity_credential = NULL;
  cls->get_joined_group_ids_for_channel = NULL;
  cls->get_meta_profile = NULL;
  cls->get_mid = NULL;
  cls->get_primary_client_for_channel = NULL;
  cls->get_profile_for_channel = NULL;
  cls->get_simple_channel_contacts = NULL;
  cls->get_user_country_for_billing = NULL;
  cls->get_user_create_time = NULL;
  cls->get_user_identities = NULL;
  cls->get_user_language = NULL;
  cls->get_user_mids_who_added_me = NULL;
  cls->is_group_member = NULL;
  cls->is_in_contact = NULL;
  cls->register_channel_c_p = NULL;
  cls->remove_notification_status = NULL;
  cls->send_message_for_channel = NULL;
  cls->send_pin_code_operation = NULL;
  cls->update_profile_attribute_for_channel = NULL;
}

enum _ChannelApplicationProvidedServiceProcessorProperties
{
  PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_0,
  PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (ChannelApplicationProvidedServiceProcessor,
               channel_application_provided_service_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* ChannelApplicationProvidedServiceProcessorProcessFunction) (ChannelApplicationProvidedServiceProcessor *, 
                                                                                gint32,
                                                                                ThriftProtocol *,
                                                                                ThriftProtocol *,
                                                                                GError **);

typedef struct
{
  gchar *name;
  ChannelApplicationProvidedServiceProcessorProcessFunction function;
} channel_application_provided_service_processor_process_function_def;

static gboolean
channel_application_provided_service_processor_process_active_buddy_subscriber_count (ChannelApplicationProvidedServiceProcessor *,
                                                                                      gint32,
                                                                                      ThriftProtocol *,
                                                                                      ThriftProtocol *,
                                                                                      GError **);
static gboolean
channel_application_provided_service_processor_process_add_operation_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                  gint32,
                                                                                  ThriftProtocol *,
                                                                                  ThriftProtocol *,
                                                                                  GError **);
static gboolean
channel_application_provided_service_processor_process_display_buddy_subscriber_count (ChannelApplicationProvidedServiceProcessor *,
                                                                                       gint32,
                                                                                       ThriftProtocol *,
                                                                                       ThriftProtocol *,
                                                                                       GError **);
static gboolean
channel_application_provided_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                                               gint32,
                                                                                                               ThriftProtocol *,
                                                                                                               ThriftProtocol *,
                                                                                                               GError **);
static gboolean
channel_application_provided_service_processor_process_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                        gint32,
                                                                                        ThriftProtocol *,
                                                                                        ThriftProtocol *,
                                                                                        GError **);
static gboolean
channel_application_provided_service_processor_process_get_compact_contacts (ChannelApplicationProvidedServiceProcessor *,
                                                                             gint32,
                                                                             ThriftProtocol *,
                                                                             ThriftProtocol *,
                                                                             GError **);
static gboolean
channel_application_provided_service_processor_process_get_contacts_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                 gint32,
                                                                                 ThriftProtocol *,
                                                                                 ThriftProtocol *,
                                                                                 GError **);
static gboolean
channel_application_provided_service_processor_process_get_display_name (ChannelApplicationProvidedServiceProcessor *,
                                                                         gint32,
                                                                         ThriftProtocol *,
                                                                         ThriftProtocol *,
                                                                         GError **);
static gboolean
channel_application_provided_service_processor_process_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                      gint32,
                                                                                      ThriftProtocol *,
                                                                                      ThriftProtocol *,
                                                                                      GError **);
static gboolean
channel_application_provided_service_processor_process_get_friend_mids (ChannelApplicationProvidedServiceProcessor *,
                                                                        gint32,
                                                                        ThriftProtocol *,
                                                                        ThriftProtocol *,
                                                                        GError **);
static gboolean
channel_application_provided_service_processor_process_get_group_member_mids (ChannelApplicationProvidedServiceProcessor *,
                                                                              gint32,
                                                                              ThriftProtocol *,
                                                                              ThriftProtocol *,
                                                                              GError **);
static gboolean
channel_application_provided_service_processor_process_get_groups_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                               gint32,
                                                                               ThriftProtocol *,
                                                                               ThriftProtocol *,
                                                                               GError **);
static gboolean
channel_application_provided_service_processor_process_get_identity_credential (ChannelApplicationProvidedServiceProcessor *,
                                                                                gint32,
                                                                                ThriftProtocol *,
                                                                                ThriftProtocol *,
                                                                                GError **);
static gboolean
channel_application_provided_service_processor_process_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                         gint32,
                                                                                         ThriftProtocol *,
                                                                                         ThriftProtocol *,
                                                                                         GError **);
static gboolean
channel_application_provided_service_processor_process_get_meta_profile (ChannelApplicationProvidedServiceProcessor *,
                                                                         gint32,
                                                                         ThriftProtocol *,
                                                                         ThriftProtocol *,
                                                                         GError **);
static gboolean
channel_application_provided_service_processor_process_get_mid (ChannelApplicationProvidedServiceProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
channel_application_provided_service_processor_process_get_primary_client_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                       gint32,
                                                                                       ThriftProtocol *,
                                                                                       ThriftProtocol *,
                                                                                       GError **);
static gboolean
channel_application_provided_service_processor_process_get_profile_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                gint32,
                                                                                ThriftProtocol *,
                                                                                ThriftProtocol *,
                                                                                GError **);
static gboolean
channel_application_provided_service_processor_process_get_simple_channel_contacts (ChannelApplicationProvidedServiceProcessor *,
                                                                                    gint32,
                                                                                    ThriftProtocol *,
                                                                                    ThriftProtocol *,
                                                                                    GError **);
static gboolean
channel_application_provided_service_processor_process_get_user_country_for_billing (ChannelApplicationProvidedServiceProcessor *,
                                                                                     gint32,
                                                                                     ThriftProtocol *,
                                                                                     ThriftProtocol *,
                                                                                     GError **);
static gboolean
channel_application_provided_service_processor_process_get_user_create_time (ChannelApplicationProvidedServiceProcessor *,
                                                                             gint32,
                                                                             ThriftProtocol *,
                                                                             ThriftProtocol *,
                                                                             GError **);
static gboolean
channel_application_provided_service_processor_process_get_user_identities (ChannelApplicationProvidedServiceProcessor *,
                                                                            gint32,
                                                                            ThriftProtocol *,
                                                                            ThriftProtocol *,
                                                                            GError **);
static gboolean
channel_application_provided_service_processor_process_get_user_language (ChannelApplicationProvidedServiceProcessor *,
                                                                          gint32,
                                                                          ThriftProtocol *,
                                                                          ThriftProtocol *,
                                                                          GError **);
static gboolean
channel_application_provided_service_processor_process_get_user_mids_who_added_me (ChannelApplicationProvidedServiceProcessor *,
                                                                                   gint32,
                                                                                   ThriftProtocol *,
                                                                                   ThriftProtocol *,
                                                                                   GError **);
static gboolean
channel_application_provided_service_processor_process_is_group_member (ChannelApplicationProvidedServiceProcessor *,
                                                                        gint32,
                                                                        ThriftProtocol *,
                                                                        ThriftProtocol *,
                                                                        GError **);
static gboolean
channel_application_provided_service_processor_process_is_in_contact (ChannelApplicationProvidedServiceProcessor *,
                                                                      gint32,
                                                                      ThriftProtocol *,
                                                                      ThriftProtocol *,
                                                                      GError **);
static gboolean
channel_application_provided_service_processor_process_register_channel_c_p (ChannelApplicationProvidedServiceProcessor *,
                                                                             gint32,
                                                                             ThriftProtocol *,
                                                                             ThriftProtocol *,
                                                                             GError **);
static gboolean
channel_application_provided_service_processor_process_remove_notification_status (ChannelApplicationProvidedServiceProcessor *,
                                                                                   gint32,
                                                                                   ThriftProtocol *,
                                                                                   ThriftProtocol *,
                                                                                   GError **);
static gboolean
channel_application_provided_service_processor_process_send_message_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                 gint32,
                                                                                 ThriftProtocol *,
                                                                                 ThriftProtocol *,
                                                                                 GError **);
static gboolean
channel_application_provided_service_processor_process_send_pin_code_operation (ChannelApplicationProvidedServiceProcessor *,
                                                                                gint32,
                                                                                ThriftProtocol *,
                                                                                ThriftProtocol *,
                                                                                GError **);
static gboolean
channel_application_provided_service_processor_process_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceProcessor *,
                                                                                             gint32,
                                                                                             ThriftProtocol *,
                                                                                             ThriftProtocol *,
                                                                                             GError **);

static channel_application_provided_service_processor_process_function_def
channel_application_provided_service_processor_process_function_defs[31] = {
  {
    "activeBuddySubscriberCount",
    channel_application_provided_service_processor_process_active_buddy_subscriber_count
  },
  {
    "addOperationForChannel",
    channel_application_provided_service_processor_process_add_operation_for_channel
  },
  {
    "displayBuddySubscriberCount",
    channel_application_provided_service_processor_process_display_buddy_subscriber_count
  },
  {
    "findContactByUseridWithoutAbuseBlockForChannel",
    channel_application_provided_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel
  },
  {
    "getAllContactIdsForChannel",
    channel_application_provided_service_processor_process_get_all_contact_ids_for_channel
  },
  {
    "getCompactContacts",
    channel_application_provided_service_processor_process_get_compact_contacts
  },
  {
    "getContactsForChannel",
    channel_application_provided_service_processor_process_get_contacts_for_channel
  },
  {
    "getDisplayName",
    channel_application_provided_service_processor_process_get_display_name
  },
  {
    "getFavoriteMidsForChannel",
    channel_application_provided_service_processor_process_get_favorite_mids_for_channel
  },
  {
    "getFriendMids",
    channel_application_provided_service_processor_process_get_friend_mids
  },
  {
    "getGroupMemberMids",
    channel_application_provided_service_processor_process_get_group_member_mids
  },
  {
    "getGroupsForChannel",
    channel_application_provided_service_processor_process_get_groups_for_channel
  },
  {
    "getIdentityCredential",
    channel_application_provided_service_processor_process_get_identity_credential
  },
  {
    "getJoinedGroupIdsForChannel",
    channel_application_provided_service_processor_process_get_joined_group_ids_for_channel
  },
  {
    "getMetaProfile",
    channel_application_provided_service_processor_process_get_meta_profile
  },
  {
    "getMid",
    channel_application_provided_service_processor_process_get_mid
  },
  {
    "getPrimaryClientForChannel",
    channel_application_provided_service_processor_process_get_primary_client_for_channel
  },
  {
    "getProfileForChannel",
    channel_application_provided_service_processor_process_get_profile_for_channel
  },
  {
    "getSimpleChannelContacts",
    channel_application_provided_service_processor_process_get_simple_channel_contacts
  },
  {
    "getUserCountryForBilling",
    channel_application_provided_service_processor_process_get_user_country_for_billing
  },
  {
    "getUserCreateTime",
    channel_application_provided_service_processor_process_get_user_create_time
  },
  {
    "getUserIdentities",
    channel_application_provided_service_processor_process_get_user_identities
  },
  {
    "getUserLanguage",
    channel_application_provided_service_processor_process_get_user_language
  },
  {
    "getUserMidsWhoAddedMe",
    channel_application_provided_service_processor_process_get_user_mids_who_added_me
  },
  {
    "isGroupMember",
    channel_application_provided_service_processor_process_is_group_member
  },
  {
    "isInContact",
    channel_application_provided_service_processor_process_is_in_contact
  },
  {
    "registerChannelCP",
    channel_application_provided_service_processor_process_register_channel_c_p
  },
  {
    "removeNotificationStatus",
    channel_application_provided_service_processor_process_remove_notification_status
  },
  {
    "sendMessageForChannel",
    channel_application_provided_service_processor_process_send_message_for_channel
  },
  {
    "sendPinCodeOperation",
    channel_application_provided_service_processor_process_send_pin_code_operation
  },
  {
    "updateProfileAttributeForChannel",
    channel_application_provided_service_processor_process_update_profile_attribute_for_channel
  }
};

static gboolean
channel_application_provided_service_processor_process_active_buddy_subscriber_count (ChannelApplicationProvidedServiceProcessor *self,
                                                                                      gint32 sequence_id,
                                                                                      ThriftProtocol *input_protocol,
                                                                                      ThriftProtocol *output_protocol,
                                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceActiveBuddySubscriberCountArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_ACTIVE_BUDDY_SUBSCRIBER_COUNT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    ChannelApplicationProvidedServiceActiveBuddySubscriberCountResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_ACTIVE_BUDDY_SUBSCRIBER_COUNT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_active_buddy_subscriber_count (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                    &return_value,
                                                                                    &e,
                                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "activeBuddySubscriberCount",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "activeBuddySubscriberCount",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.activeBuddySubscriberCount implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "activeBuddySubscriberCount",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_add_operation_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                  gint32 sequence_id,
                                                                                  ThriftProtocol *input_protocol,
                                                                                  ThriftProtocol *output_protocol,
                                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceAddOperationForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_ADD_OPERATION_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    OpType opType;
    gchar * param1;
    gchar * param2;
    gchar * param3;
    TalkException * e = NULL;
    ChannelApplicationProvidedServiceAddOperationForChannelResult * result_struct;

    g_object_get (args,
                  "opType", &opType,
                  "param1", &param1,
                  "param2", &param2,
                  "param3", &param3,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_ADD_OPERATION_FOR_CHANNEL_RESULT, NULL);

    if (channel_application_provided_service_handler_add_operation_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                opType,
                                                                                param1,
                                                                                param2,
                                                                                param3,
                                                                                &e,
                                                                                error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addOperationForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addOperationForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.addOperationForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addOperationForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (param1 != NULL)
      g_free (param1);
    if (param2 != NULL)
      g_free (param2);
    if (param3 != NULL)
      g_free (param3);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_display_buddy_subscriber_count (ChannelApplicationProvidedServiceProcessor *self,
                                                                                       gint32 sequence_id,
                                                                                       ThriftProtocol *input_protocol,
                                                                                       ThriftProtocol *output_protocol,
                                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceDisplayBuddySubscriberCountArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    ChannelApplicationProvidedServiceDisplayBuddySubscriberCountResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_DISPLAY_BUDDY_SUBSCRIBER_COUNT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_display_buddy_subscriber_count (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                     &return_value,
                                                                                     &e,
                                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "displayBuddySubscriberCount",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCount",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.displayBuddySubscriberCount implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "displayBuddySubscriberCount",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_find_contact_by_userid_without_abuse_block_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                                               gint32 sequence_id,
                                                                                                               ThriftProtocol *input_protocol,
                                                                                                               ThriftProtocol *output_protocol,
                                                                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_FIND_CONTACT_BY_USERID_WITHOUT_ABUSE_BLOCK_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * userid;
    TalkException * e = NULL;
    Contact * return_value;
    ChannelApplicationProvidedServiceFindContactByUseridWithoutAbuseBlockForChannelResult * result_struct;

    g_object_get (args,
                  "userid", &userid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_FIND_CONTACT_BY_USERID_WITHOUT_ABUSE_BLOCK_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_find_contact_by_userid_without_abuse_block_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                                             &return_value,
                                                                                                             userid,
                                                                                                             &e,
                                                                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findContactByUseridWithoutAbuseBlockForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findContactByUseridWithoutAbuseBlockForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.findContactByUseridWithoutAbuseBlockForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findContactByUseridWithoutAbuseBlockForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (userid != NULL)
      g_free (userid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_all_contact_ids_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                        gint32 sequence_id,
                                                                                        ThriftProtocol *input_protocol,
                                                                                        ThriftProtocol *output_protocol,
                                                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetAllContactIdsForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_ALL_CONTACT_IDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetAllContactIdsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_ALL_CONTACT_IDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_all_contact_ids_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                      &return_value,
                                                                                      &e,
                                                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getAllContactIdsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllContactIdsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getAllContactIdsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getAllContactIdsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_compact_contacts (ChannelApplicationProvidedServiceProcessor *self,
                                                                             gint32 sequence_id,
                                                                             ThriftProtocol *input_protocol,
                                                                             ThriftProtocol *output_protocol,
                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetCompactContactsArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_COMPACT_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 lastModifiedTimestamp;
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetCompactContactsResult * result_struct;

    g_object_get (args,
                  "lastModifiedTimestamp", &lastModifiedTimestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_COMPACT_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_compact_contacts (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                           &return_value,
                                                                           lastModifiedTimestamp,
                                                                           &e,
                                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getCompactContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCompactContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getCompactContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getCompactContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_contacts_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                 gint32 sequence_id,
                                                                                 ThriftProtocol *input_protocol,
                                                                                 ThriftProtocol *output_protocol,
                                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetContactsForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_CONTACTS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * ids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetContactsForChannelResult * result_struct;

    g_object_get (args,
                  "ids", &ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_CONTACTS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_contacts_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                               &return_value,
                                                                               ids,
                                                                               &e,
                                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getContactsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getContactsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getContactsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getContactsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ids != NULL)
      g_ptr_array_unref (ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_display_name (ChannelApplicationProvidedServiceProcessor *self,
                                                                         gint32 sequence_id,
                                                                         ThriftProtocol *input_protocol,
                                                                         ThriftProtocol *output_protocol,
                                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetDisplayNameArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_DISPLAY_NAME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    gchar * return_value;
    ChannelApplicationProvidedServiceGetDisplayNameResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_DISPLAY_NAME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_display_name (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                       &return_value,
                                                                       mid,
                                                                       &e,
                                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDisplayName",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDisplayName",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getDisplayName implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDisplayName",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_favorite_mids_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                      gint32 sequence_id,
                                                                                      ThriftProtocol *input_protocol,
                                                                                      ThriftProtocol *output_protocol,
                                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetFavoriteMidsForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_FAVORITE_MIDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetFavoriteMidsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_FAVORITE_MIDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_favorite_mids_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                    &return_value,
                                                                                    &e,
                                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFavoriteMidsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteMidsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getFavoriteMidsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFavoriteMidsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_friend_mids (ChannelApplicationProvidedServiceProcessor *self,
                                                                        gint32 sequence_id,
                                                                        ThriftProtocol *input_protocol,
                                                                        ThriftProtocol *output_protocol,
                                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetFriendMidsArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_FRIEND_MIDS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetFriendMidsResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_FRIEND_MIDS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_friend_mids (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                      &return_value,
                                                                      &e,
                                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFriendMids",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFriendMids",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getFriendMids implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFriendMids",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_group_member_mids (ChannelApplicationProvidedServiceProcessor *self,
                                                                              gint32 sequence_id,
                                                                              ThriftProtocol *input_protocol,
                                                                              ThriftProtocol *output_protocol,
                                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetGroupMemberMidsArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_GROUP_MEMBER_MIDS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetGroupMemberMidsResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_GROUP_MEMBER_MIDS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_group_member_mids (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                            &return_value,
                                                                            groupId,
                                                                            &e,
                                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupMemberMids",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMids",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getGroupMemberMids implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupMemberMids",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_groups_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                               gint32 sequence_id,
                                                                               ThriftProtocol *input_protocol,
                                                                               ThriftProtocol *output_protocol,
                                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetGroupsForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_GROUPS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * groupIds;
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetGroupsForChannelResult * result_struct;

    g_object_get (args,
                  "groupIds", &groupIds,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_GROUPS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_groups_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                             &return_value,
                                                                             groupIds,
                                                                             &e,
                                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getGroupsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupIds != NULL)
      g_ptr_array_unref (groupIds);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_identity_credential (ChannelApplicationProvidedServiceProcessor *self,
                                                                                gint32 sequence_id,
                                                                                ThriftProtocol *input_protocol,
                                                                                ThriftProtocol *output_protocol,
                                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetIdentityCredentialArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_IDENTITY_CREDENTIAL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    IdentityCredential * return_value;
    ChannelApplicationProvidedServiceGetIdentityCredentialResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_IDENTITY_CREDENTIAL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_identity_credential (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                              &return_value,
                                                                              &e,
                                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getIdentityCredential",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getIdentityCredential",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getIdentityCredential implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getIdentityCredential",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_joined_group_ids_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                         gint32 sequence_id,
                                                                                         ThriftProtocol *input_protocol,
                                                                                         ThriftProtocol *output_protocol,
                                                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_JOINED_GROUP_IDS_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetJoinedGroupIdsForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_JOINED_GROUP_IDS_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_joined_group_ids_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                       &return_value,
                                                                                       &e,
                                                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getJoinedGroupIdsForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getJoinedGroupIdsForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getJoinedGroupIdsForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getJoinedGroupIdsForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_meta_profile (ChannelApplicationProvidedServiceProcessor *self,
                                                                         gint32 sequence_id,
                                                                         ThriftProtocol *input_protocol,
                                                                         ThriftProtocol *output_protocol,
                                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetMetaProfileArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_META_PROFILE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    MetaProfile * return_value;
    ChannelApplicationProvidedServiceGetMetaProfileResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_META_PROFILE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_meta_profile (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                       &return_value,
                                                                       &e,
                                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getMetaProfile",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMetaProfile",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getMetaProfile implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMetaProfile",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_mid (ChannelApplicationProvidedServiceProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetMidArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_MID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gchar * return_value;
    ChannelApplicationProvidedServiceGetMidResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_MID_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_mid (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                              &return_value,
                                                              &e,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getMid",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMid",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getMid implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getMid",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_primary_client_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                       gint32 sequence_id,
                                                                                       ThriftProtocol *input_protocol,
                                                                                       ThriftProtocol *output_protocol,
                                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetPrimaryClientForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_PRIMARY_CLIENT_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    SimpleChannelClient * return_value;
    ChannelApplicationProvidedServiceGetPrimaryClientForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_PRIMARY_CLIENT_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_primary_client_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                     &return_value,
                                                                                     &e,
                                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPrimaryClientForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getPrimaryClientForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPrimaryClientForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_profile_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                gint32 sequence_id,
                                                                                ThriftProtocol *input_protocol,
                                                                                ThriftProtocol *output_protocol,
                                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetProfileForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_PROFILE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    Profile * return_value;
    ChannelApplicationProvidedServiceGetProfileForChannelResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_PROFILE_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_profile_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                              &return_value,
                                                                              &e,
                                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getProfileForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProfileForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getProfileForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProfileForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_simple_channel_contacts (ChannelApplicationProvidedServiceProcessor *self,
                                                                                    gint32 sequence_id,
                                                                                    ThriftProtocol *input_protocol,
                                                                                    ThriftProtocol *output_protocol,
                                                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetSimpleChannelContactsArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_SIMPLE_CHANNEL_CONTACTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * ids;
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetSimpleChannelContactsResult * result_struct;

    g_object_get (args,
                  "ids", &ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_SIMPLE_CHANNEL_CONTACTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_simple_channel_contacts (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                  &return_value,
                                                                                  ids,
                                                                                  &e,
                                                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSimpleChannelContacts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSimpleChannelContacts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getSimpleChannelContacts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSimpleChannelContacts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ids != NULL)
      g_ptr_array_unref (ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_user_country_for_billing (ChannelApplicationProvidedServiceProcessor *self,
                                                                                     gint32 sequence_id,
                                                                                     ThriftProtocol *input_protocol,
                                                                                     ThriftProtocol *output_protocol,
                                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetUserCountryForBillingArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_COUNTRY_FOR_BILLING_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * country;
    gchar * remoteIp;
    TalkException * e = NULL;
    gchar * return_value;
    ChannelApplicationProvidedServiceGetUserCountryForBillingResult * result_struct;

    g_object_get (args,
                  "country", &country,
                  "remoteIp", &remoteIp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_COUNTRY_FOR_BILLING_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_user_country_for_billing (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                   &return_value,
                                                                                   country,
                                                                                   remoteIp,
                                                                                   &e,
                                                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserCountryForBilling",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCountryForBilling",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getUserCountryForBilling implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCountryForBilling",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (country != NULL)
      g_free (country);
    if (remoteIp != NULL)
      g_free (remoteIp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_user_create_time (ChannelApplicationProvidedServiceProcessor *self,
                                                                             gint32 sequence_id,
                                                                             ThriftProtocol *input_protocol,
                                                                             ThriftProtocol *output_protocol,
                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetUserCreateTimeArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_CREATE_TIME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gint64 return_value;
    ChannelApplicationProvidedServiceGetUserCreateTimeResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_CREATE_TIME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_user_create_time (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                           &return_value,
                                                                           &e,
                                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserCreateTime",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCreateTime",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getUserCreateTime implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserCreateTime",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_user_identities (ChannelApplicationProvidedServiceProcessor *self,
                                                                            gint32 sequence_id,
                                                                            ThriftProtocol *input_protocol,
                                                                            ThriftProtocol *output_protocol,
                                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetUserIdentitiesArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_IDENTITIES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GHashTable * return_value;
    ChannelApplicationProvidedServiceGetUserIdentitiesResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_IDENTITIES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_user_identities (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                          &return_value,
                                                                          &e,
                                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserIdentities",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserIdentities",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getUserIdentities implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserIdentities",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_user_language (ChannelApplicationProvidedServiceProcessor *self,
                                                                          gint32 sequence_id,
                                                                          ThriftProtocol *input_protocol,
                                                                          ThriftProtocol *output_protocol,
                                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetUserLanguageArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_LANGUAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    gchar * return_value;
    ChannelApplicationProvidedServiceGetUserLanguageResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_LANGUAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_user_language (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                        &return_value,
                                                                        &e,
                                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserLanguage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLanguage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getUserLanguage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserLanguage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_get_user_mids_who_added_me (ChannelApplicationProvidedServiceProcessor *self,
                                                                                   gint32 sequence_id,
                                                                                   ThriftProtocol *input_protocol,
                                                                                   ThriftProtocol *output_protocol,
                                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_MIDS_WHO_ADDED_ME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TalkException * e = NULL;
    GPtrArray * return_value;
    ChannelApplicationProvidedServiceGetUserMidsWhoAddedMeResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_GET_USER_MIDS_WHO_ADDED_ME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_get_user_mids_who_added_me (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                 &return_value,
                                                                                 &e,
                                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getUserMidsWhoAddedMe",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserMidsWhoAddedMe",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.getUserMidsWhoAddedMe implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getUserMidsWhoAddedMe",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_is_group_member (ChannelApplicationProvidedServiceProcessor *self,
                                                                        gint32 sequence_id,
                                                                        ThriftProtocol *input_protocol,
                                                                        ThriftProtocol *output_protocol,
                                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceIsGroupMemberArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IS_GROUP_MEMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * groupId;
    TalkException * e = NULL;
    gboolean return_value;
    ChannelApplicationProvidedServiceIsGroupMemberResult * result_struct;

    g_object_get (args,
                  "groupId", &groupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IS_GROUP_MEMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_is_group_member (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                      &return_value,
                                                                      groupId,
                                                                      &e,
                                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isGroupMember",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isGroupMember",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.isGroupMember implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isGroupMember",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupId != NULL)
      g_free (groupId);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_is_in_contact (ChannelApplicationProvidedServiceProcessor *self,
                                                                      gint32 sequence_id,
                                                                      ThriftProtocol *input_protocol,
                                                                      ThriftProtocol *output_protocol,
                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceIsInContactArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IS_IN_CONTACT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mid;
    TalkException * e = NULL;
    gboolean return_value;
    ChannelApplicationProvidedServiceIsInContactResult * result_struct;

    g_object_get (args,
                  "mid", &mid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_IS_IN_CONTACT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_is_in_contact (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                    &return_value,
                                                                    mid,
                                                                    &e,
                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isInContact",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isInContact",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.isInContact implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isInContact",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mid != NULL)
      g_free (mid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_register_channel_c_p (ChannelApplicationProvidedServiceProcessor *self,
                                                                             gint32 sequence_id,
                                                                             ThriftProtocol *input_protocol,
                                                                             ThriftProtocol *output_protocol,
                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceRegisterChannelCPArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_REGISTER_CHANNEL_C_P_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * cpId;
    gchar * registerPassword;
    TalkException * e = NULL;
    gchar * return_value;
    ChannelApplicationProvidedServiceRegisterChannelCPResult * result_struct;

    g_object_get (args,
                  "cpId", &cpId,
                  "registerPassword", &registerPassword,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_REGISTER_CHANNEL_C_P_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_register_channel_c_p (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                           &return_value,
                                                                           cpId,
                                                                           registerPassword,
                                                                           &e,
                                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "registerChannelCP",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerChannelCP",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.registerChannelCP implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerChannelCP",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (cpId != NULL)
      g_free (cpId);
    if (registerPassword != NULL)
      g_free (registerPassword);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_remove_notification_status (ChannelApplicationProvidedServiceProcessor *self,
                                                                                   gint32 sequence_id,
                                                                                   ThriftProtocol *input_protocol,
                                                                                   ThriftProtocol *output_protocol,
                                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceRemoveNotificationStatusArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_REMOVE_NOTIFICATION_STATUS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    NotificationStatus notificationStatus;
    TalkException * e = NULL;
    ChannelApplicationProvidedServiceRemoveNotificationStatusResult * result_struct;

    g_object_get (args,
                  "notificationStatus", &notificationStatus,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_REMOVE_NOTIFICATION_STATUS_RESULT, NULL);

    if (channel_application_provided_service_handler_remove_notification_status (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                 notificationStatus,
                                                                                 &e,
                                                                                 error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "removeNotificationStatus",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "removeNotificationStatus",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.removeNotificationStatus implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "removeNotificationStatus",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_send_message_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                 gint32 sequence_id,
                                                                                 ThriftProtocol *input_protocol,
                                                                                 ThriftProtocol *output_protocol,
                                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceSendMessageForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_SEND_MESSAGE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Message * message;
    TalkException * e = NULL;
    Message * return_value;
    ChannelApplicationProvidedServiceSendMessageForChannelResult * result_struct;

    g_object_get (args,
                  "message", &message,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_SEND_MESSAGE_FOR_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (channel_application_provided_service_handler_send_message_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                               &return_value,
                                                                               message,
                                                                               &e,
                                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendMessageForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.sendMessageForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendMessageForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (message != NULL)
      g_object_unref (message);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_send_pin_code_operation (ChannelApplicationProvidedServiceProcessor *self,
                                                                                gint32 sequence_id,
                                                                                ThriftProtocol *input_protocol,
                                                                                ThriftProtocol *output_protocol,
                                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceSendPinCodeOperationArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_SEND_PIN_CODE_OPERATION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * verifier;
    TalkException * e = NULL;
    ChannelApplicationProvidedServiceSendPinCodeOperationResult * result_struct;

    g_object_get (args,
                  "verifier", &verifier,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_SEND_PIN_CODE_OPERATION_RESULT, NULL);

    if (channel_application_provided_service_handler_send_pin_code_operation (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                              verifier,
                                                                              &e,
                                                                              error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sendPinCodeOperation",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendPinCodeOperation",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.sendPinCodeOperation implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sendPinCodeOperation",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (verifier != NULL)
      g_free (verifier);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_process_update_profile_attribute_for_channel (ChannelApplicationProvidedServiceProcessor *self,
                                                                                             gint32 sequence_id,
                                                                                             ThriftProtocol *input_protocol,
                                                                                             ThriftProtocol *output_protocol,
                                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelArgs * args =
    g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_UPDATE_PROFILE_ATTRIBUTE_FOR_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ProfileAttribute profileAttribute;
    gchar * value;
    TalkException * e = NULL;
    ChannelApplicationProvidedServiceUpdateProfileAttributeForChannelResult * result_struct;

    g_object_get (args,
                  "profileAttribute", &profileAttribute,
                  "value", &value,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_UPDATE_PROFILE_ATTRIBUTE_FOR_CHANNEL_RESULT, NULL);

    if (channel_application_provided_service_handler_update_profile_attribute_for_channel (CHANNEL_APPLICATION_PROVIDED_SERVICE_IF (self->handler),
                                                                                           profileAttribute,
                                                                                           value,
                                                                                           &e,
                                                                                           error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateProfileAttributeForChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (e != NULL)
      {
        g_object_set (result_struct,
                      "e", e,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateProfileAttributeForChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("ChannelApplicationProvidedService.updateProfileAttributeForChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateProfileAttributeForChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (value != NULL)
      g_free (value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
channel_application_provided_service_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              gchar *method_name,
                                                              gint32 sequence_id,
                                                              GError **error)
{
  channel_application_provided_service_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  ChannelApplicationProvidedServiceProcessor *self = CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    g_free (method_name);
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
channel_application_provided_service_processor_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  ChannelApplicationProvidedServiceProcessor *self = CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
channel_application_provided_service_processor_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  ChannelApplicationProvidedServiceProcessor *self = CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
channel_application_provided_service_processor_dispose (GObject *gobject)
{
  ChannelApplicationProvidedServiceProcessor *self = CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (channel_application_provided_service_processor_parent_class)->dispose (gobject);
}

static void
channel_application_provided_service_processor_finalize (GObject *gobject)
{
  ChannelApplicationProvidedServiceProcessor *self = CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR (gobject);

  thrift_safe_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (channel_application_provided_service_processor_parent_class)->finalize (gobject);
}

static void
channel_application_provided_service_processor_init (ChannelApplicationProvidedServiceProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 31; index += 1)
    g_hash_table_insert (self->process_map,
                         channel_application_provided_service_processor_process_function_defs[index].name,
                         &channel_application_provided_service_processor_process_function_defs[index]);
}

static void
channel_application_provided_service_processor_class_init (ChannelApplicationProvidedServiceProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = channel_application_provided_service_processor_dispose;
  gobject_class->finalize = channel_application_provided_service_processor_finalize;
  gobject_class->set_property = channel_application_provided_service_processor_set_property;
  gobject_class->get_property = channel_application_provided_service_processor_get_property;

  dispatch_processor_class->dispatch_call = channel_application_provided_service_processor_dispatch_call;
  cls->dispatch_call = channel_application_provided_service_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_CHANNEL_APPLICATION_PROVIDED_SERVICE_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_CHANNEL_APPLICATION_PROVIDED_SERVICE_PROCESSOR_HANDLER,
                                   param_spec);
}
