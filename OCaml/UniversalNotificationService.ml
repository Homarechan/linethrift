(*
 Autogenerated by Thrift Compiler (0.13.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Line_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class notify_args =
object (self)
  val mutable _event : globalEvent option = None
  method get_event = _event
  method grab_event = match _event with None->raise (Field_empty "notify_args.event") | Some _x10393 -> _x10393
  method set_event _x10393 = _event <- Some _x10393
  method unset_event = _event <- None
  method reset_event = _event <- None

  method copy =
      let _new = Oo.copy self in
      if _event <> None then
        _new#set_event self#grab_event#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "notify_args";
    (match _event with None -> () | Some _v -> 
      oprot#writeFieldBegin("event",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_notify_args (iprot : Protocol.t) =
  let _str10396 = new notify_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t10397,_id10398) = iprot#readFieldBegin in
        if _t10397 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id10398 with 
          | 2 -> (if _t10397 = Protocol.T_STRUCT then
              _str10396#set_event (read_globalEvent iprot)
            else
              iprot#skip _t10397)
          | _ -> iprot#skip _t10397);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str10396

class notify_result =
object (self)
  val mutable _e : universalNotificationServiceException option = None
  method get_e = _e
  method grab_e = match _e with None->raise (Field_empty "notify_result.e") | Some _x10399 -> _x10399
  method set_e _x10399 = _e <- Some _x10399
  method unset_e = _e <- None
  method reset_e = _e <- None

  method copy =
      let _new = Oo.copy self in
      if _e <> None then
        _new#set_e self#grab_e#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "notify_result";
    (match _e with None -> () | Some _v -> 
      oprot#writeFieldBegin("e",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_notify_result (iprot : Protocol.t) =
  let _str10402 = new notify_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t10403,_id10404) = iprot#readFieldBegin in
        if _t10403 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id10404 with 
          | 1 -> (if _t10403 = Protocol.T_STRUCT then
              _str10402#set_e (read_universalNotificationServiceException iprot)
            else
              iprot#skip _t10403)
          | _ -> iprot#skip _t10403);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str10402

class virtual iface =
object (self)
  method virtual notify : globalEvent option -> unit
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method notify event = 
    self#send_notify event;
    self#recv_notify
  method private send_notify event = 
    oprot#writeMessageBegin ("notify", Protocol.CALL, seqid);
    let args = new notify_args in
      args#set_event event;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_notify  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_notify_result iprot in
        iprot#readMessageEnd;
        (match result#get_e with None -> () | Some _v ->
          raise (UniversalNotificationServiceException _v));
        ()
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 1
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_notify (seqid, iprot, oprot) =
    let args = read_notify_args iprot in
      iprot#readMessageEnd;
      let result = new notify_result in
        (try
          (handler#notify args#get_event);
        with
          | UniversalNotificationServiceException e -> 
              result#set_e e
        );
        oprot#writeMessageBegin ("notify", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "notify" self#process_notify;
end

