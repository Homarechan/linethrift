{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ChannelService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ChannelService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data IssueOTP_args = IssueOTP_args  { issueOTP_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueOTP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueOTP_args_channelId record  
instance QC.Arbitrary IssueOTP_args where 
  arbitrary = M.liftM IssueOTP_args (QC.arbitrary)
  shrink obj | obj == default_IssueOTP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueOTP_args{issueOTP_args_channelId = issueOTP_args_channelId obj} then P.Nothing else P.Just $ default_IssueOTP_args{issueOTP_args_channelId = issueOTP_args_channelId obj}
    ]
from_IssueOTP_args :: IssueOTP_args -> T.ThriftVal
from_IssueOTP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5647 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5647))) $ issueOTP_args_channelId record
  ]
write_IssueOTP_args :: T.Protocol p => p -> IssueOTP_args -> P.IO ()
write_IssueOTP_args oprot record = T.writeVal oprot $ from_IssueOTP_args record
encode_IssueOTP_args :: T.StatelessProtocol p => p -> IssueOTP_args -> LBS.ByteString
encode_IssueOTP_args oprot record = T.serializeVal oprot $ from_IssueOTP_args record
to_IssueOTP_args :: T.ThriftVal -> IssueOTP_args
to_IssueOTP_args (T.TStruct fields) = IssueOTP_args{
  issueOTP_args_channelId = P.maybe (issueOTP_args_channelId default_IssueOTP_args) (\(_,_val5649) -> (case _val5649 of {T.TString _val5650 -> E.decodeUtf8 _val5650; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueOTP_args _ = P.error "not a struct"
read_IssueOTP_args :: T.Protocol p => p -> P.IO IssueOTP_args
read_IssueOTP_args iprot = to_IssueOTP_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueOTP_args)
decode_IssueOTP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueOTP_args
decode_IssueOTP_args iprot bs = to_IssueOTP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueOTP_args) bs
typemap_IssueOTP_args :: T.TypeMap
typemap_IssueOTP_args = Map.fromList [(2,("channelId",T.T_STRING))]
default_IssueOTP_args :: IssueOTP_args
default_IssueOTP_args = IssueOTP_args{
  issueOTP_args_channelId = ""}
data IssueOTP_result = IssueOTP_result  { issueOTP_result_success :: OTPResult
  , issueOTP_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueOTP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueOTP_result_success record   `H.hashWithSalt` issueOTP_result_e record  
instance QC.Arbitrary IssueOTP_result where 
  arbitrary = M.liftM IssueOTP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueOTP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueOTP_result{issueOTP_result_success = issueOTP_result_success obj} then P.Nothing else P.Just $ default_IssueOTP_result{issueOTP_result_success = issueOTP_result_success obj}
    , if obj == default_IssueOTP_result{issueOTP_result_e = issueOTP_result_e obj} then P.Nothing else P.Just $ default_IssueOTP_result{issueOTP_result_e = issueOTP_result_e obj}
    ]
from_IssueOTP_result :: IssueOTP_result -> T.ThriftVal
from_IssueOTP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5653 -> (1, ("e",from_ChannelException _v5653))) <$> issueOTP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5653 -> P.Just (0, ("success",from_OTPResult _v5653))) $ issueOTP_result_success record
    , (\_v5653 -> (1, ("e",from_ChannelException _v5653))) <$> issueOTP_result_e record
    ]
    )
write_IssueOTP_result :: T.Protocol p => p -> IssueOTP_result -> P.IO ()
write_IssueOTP_result oprot record = T.writeVal oprot $ from_IssueOTP_result record
encode_IssueOTP_result :: T.StatelessProtocol p => p -> IssueOTP_result -> LBS.ByteString
encode_IssueOTP_result oprot record = T.serializeVal oprot $ from_IssueOTP_result record
to_IssueOTP_result :: T.ThriftVal -> IssueOTP_result
to_IssueOTP_result (T.TStruct fields) = IssueOTP_result{
  issueOTP_result_success = P.maybe (issueOTP_result_success default_IssueOTP_result) (\(_,_val5655) -> (case _val5655 of {T.TStruct _val5656 -> (to_OTPResult (T.TStruct _val5656)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueOTP_result_e = P.maybe (P.Nothing) (\(_,_val5655) -> P.Just (case _val5655 of {T.TStruct _val5657 -> (to_ChannelException (T.TStruct _val5657)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueOTP_result _ = P.error "not a struct"
read_IssueOTP_result :: T.Protocol p => p -> P.IO IssueOTP_result
read_IssueOTP_result iprot = to_IssueOTP_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueOTP_result)
decode_IssueOTP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueOTP_result
decode_IssueOTP_result iprot bs = to_IssueOTP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueOTP_result) bs
typemap_IssueOTP_result :: T.TypeMap
typemap_IssueOTP_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_OTPResult))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueOTP_result :: IssueOTP_result
default_IssueOTP_result = IssueOTP_result{
  issueOTP_result_success = default_OTPResult,
  issueOTP_result_e = P.Nothing}
data ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args  { approveChannelAndIssueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_args_channelId record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj}
    ]
from_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5660 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5660))) $ approveChannelAndIssueChannelToken_args_channelId record
  ]
write_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_args -> P.IO ()
write_ApproveChannelAndIssueChannelToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
encode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
to_ApproveChannelAndIssueChannelToken_args :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_args
to_ApproveChannelAndIssueChannelToken_args (T.TStruct fields) = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = P.maybe (approveChannelAndIssueChannelToken_args_channelId default_ApproveChannelAndIssueChannelToken_args) (\(_,_val5662) -> (case _val5662 of {T.TString _val5663 -> E.decodeUtf8 _val5663; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_args
read_ApproveChannelAndIssueChannelToken_args iprot = to_ApproveChannelAndIssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args)
decode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_args
decode_ApproveChannelAndIssueChannelToken_args iprot bs = to_ApproveChannelAndIssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args) bs
typemap_ApproveChannelAndIssueChannelToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args
default_ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = ""}
data ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result  { approveChannelAndIssueChannelToken_result_success :: ChannelToken
  , approveChannelAndIssueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_success record   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj}
    ]
from_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5666 -> (1, ("e",from_ChannelException _v5666))) <$> approveChannelAndIssueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5666 -> P.Just (0, ("success",from_ChannelToken _v5666))) $ approveChannelAndIssueChannelToken_result_success record
    , (\_v5666 -> (1, ("e",from_ChannelException _v5666))) <$> approveChannelAndIssueChannelToken_result_e record
    ]
    )
write_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_result -> P.IO ()
write_ApproveChannelAndIssueChannelToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
encode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
to_ApproveChannelAndIssueChannelToken_result :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_result
to_ApproveChannelAndIssueChannelToken_result (T.TStruct fields) = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = P.maybe (approveChannelAndIssueChannelToken_result_success default_ApproveChannelAndIssueChannelToken_result) (\(_,_val5668) -> (case _val5668 of {T.TStruct _val5669 -> (to_ChannelToken (T.TStruct _val5669)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val5668) -> P.Just (case _val5668 of {T.TStruct _val5670 -> (to_ChannelException (T.TStruct _val5670)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_result
read_ApproveChannelAndIssueChannelToken_result iprot = to_ApproveChannelAndIssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result)
decode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_result
decode_ApproveChannelAndIssueChannelToken_result iprot bs = to_ApproveChannelAndIssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result) bs
typemap_ApproveChannelAndIssueChannelToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result
default_ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = default_ChannelToken,
  approveChannelAndIssueChannelToken_result_e = P.Nothing}
data ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args  { approveChannelAndIssueRequestToken_args_channelId :: LT.Text
  , approveChannelAndIssueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_channelId record   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_otpId record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj}
    ]
from_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5673 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5673))) $ approveChannelAndIssueRequestToken_args_channelId record
  , (\_v5673 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5673))) $ approveChannelAndIssueRequestToken_args_otpId record
  ]
write_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_args -> P.IO ()
write_ApproveChannelAndIssueRequestToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
encode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
to_ApproveChannelAndIssueRequestToken_args :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_args
to_ApproveChannelAndIssueRequestToken_args (T.TStruct fields) = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = P.maybe (approveChannelAndIssueRequestToken_args_channelId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val5675) -> (case _val5675 of {T.TString _val5676 -> E.decodeUtf8 _val5676; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approveChannelAndIssueRequestToken_args_otpId = P.maybe (approveChannelAndIssueRequestToken_args_otpId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val5675) -> (case _val5675 of {T.TString _val5677 -> E.decodeUtf8 _val5677; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApproveChannelAndIssueRequestToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_args
read_ApproveChannelAndIssueRequestToken_args iprot = to_ApproveChannelAndIssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args)
decode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_args
decode_ApproveChannelAndIssueRequestToken_args iprot bs = to_ApproveChannelAndIssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args) bs
typemap_ApproveChannelAndIssueRequestToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args
default_ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = "",
  approveChannelAndIssueRequestToken_args_otpId = ""}
data ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result  { approveChannelAndIssueRequestToken_result_success :: LT.Text
  , approveChannelAndIssueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_success record   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj}
    ]
from_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5680 -> (1, ("e",from_ChannelException _v5680))) <$> approveChannelAndIssueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5680 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5680))) $ approveChannelAndIssueRequestToken_result_success record
    , (\_v5680 -> (1, ("e",from_ChannelException _v5680))) <$> approveChannelAndIssueRequestToken_result_e record
    ]
    )
write_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_result -> P.IO ()
write_ApproveChannelAndIssueRequestToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
encode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
to_ApproveChannelAndIssueRequestToken_result :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_result
to_ApproveChannelAndIssueRequestToken_result (T.TStruct fields) = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = P.maybe (approveChannelAndIssueRequestToken_result_success default_ApproveChannelAndIssueRequestToken_result) (\(_,_val5682) -> (case _val5682 of {T.TString _val5683 -> E.decodeUtf8 _val5683; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val5682) -> P.Just (case _val5682 of {T.TStruct _val5684 -> (to_ChannelException (T.TStruct _val5684)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueRequestToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_result
read_ApproveChannelAndIssueRequestToken_result iprot = to_ApproveChannelAndIssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result)
decode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_result
decode_ApproveChannelAndIssueRequestToken_result iprot bs = to_ApproveChannelAndIssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result) bs
typemap_ApproveChannelAndIssueRequestToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result
default_ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = "",
  approveChannelAndIssueRequestToken_result_e = P.Nothing}
data FetchNotificationItems_args = FetchNotificationItems_args  { fetchNotificationItems_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_args_localRev record  
instance QC.Arbitrary FetchNotificationItems_args where 
  arbitrary = M.liftM FetchNotificationItems_args (QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj} then P.Nothing else P.Just $ default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj}
    ]
from_FetchNotificationItems_args :: FetchNotificationItems_args -> T.ThriftVal
from_FetchNotificationItems_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5687 -> P.Just (2, ("localRev",T.TI64 _v5687))) $ fetchNotificationItems_args_localRev record
  ]
write_FetchNotificationItems_args :: T.Protocol p => p -> FetchNotificationItems_args -> P.IO ()
write_FetchNotificationItems_args oprot record = T.writeVal oprot $ from_FetchNotificationItems_args record
encode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> FetchNotificationItems_args -> LBS.ByteString
encode_FetchNotificationItems_args oprot record = T.serializeVal oprot $ from_FetchNotificationItems_args record
to_FetchNotificationItems_args :: T.ThriftVal -> FetchNotificationItems_args
to_FetchNotificationItems_args (T.TStruct fields) = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = P.maybe (fetchNotificationItems_args_localRev default_FetchNotificationItems_args) (\(_,_val5689) -> (case _val5689 of {T.TI64 _val5690 -> _val5690; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FetchNotificationItems_args _ = P.error "not a struct"
read_FetchNotificationItems_args :: T.Protocol p => p -> P.IO FetchNotificationItems_args
read_FetchNotificationItems_args iprot = to_FetchNotificationItems_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args)
decode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_args
decode_FetchNotificationItems_args iprot bs = to_FetchNotificationItems_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args) bs
typemap_FetchNotificationItems_args :: T.TypeMap
typemap_FetchNotificationItems_args = Map.fromList [(2,("localRev",T.T_I64))]
default_FetchNotificationItems_args :: FetchNotificationItems_args
default_FetchNotificationItems_args = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = 0}
data FetchNotificationItems_result = FetchNotificationItems_result  { fetchNotificationItems_result_success :: NotificationFetchResult
  , fetchNotificationItems_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_result_success record   `H.hashWithSalt` fetchNotificationItems_result_e record  
instance QC.Arbitrary FetchNotificationItems_result where 
  arbitrary = M.liftM FetchNotificationItems_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj}
    , if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj}
    ]
from_FetchNotificationItems_result :: FetchNotificationItems_result -> T.ThriftVal
from_FetchNotificationItems_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5693 -> (1, ("e",from_ChannelException _v5693))) <$> fetchNotificationItems_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5693 -> P.Just (0, ("success",from_NotificationFetchResult _v5693))) $ fetchNotificationItems_result_success record
    , (\_v5693 -> (1, ("e",from_ChannelException _v5693))) <$> fetchNotificationItems_result_e record
    ]
    )
write_FetchNotificationItems_result :: T.Protocol p => p -> FetchNotificationItems_result -> P.IO ()
write_FetchNotificationItems_result oprot record = T.writeVal oprot $ from_FetchNotificationItems_result record
encode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> FetchNotificationItems_result -> LBS.ByteString
encode_FetchNotificationItems_result oprot record = T.serializeVal oprot $ from_FetchNotificationItems_result record
to_FetchNotificationItems_result :: T.ThriftVal -> FetchNotificationItems_result
to_FetchNotificationItems_result (T.TStruct fields) = FetchNotificationItems_result{
  fetchNotificationItems_result_success = P.maybe (fetchNotificationItems_result_success default_FetchNotificationItems_result) (\(_,_val5695) -> (case _val5695 of {T.TStruct _val5696 -> (to_NotificationFetchResult (T.TStruct _val5696)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchNotificationItems_result_e = P.maybe (P.Nothing) (\(_,_val5695) -> P.Just (case _val5695 of {T.TStruct _val5697 -> (to_ChannelException (T.TStruct _val5697)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchNotificationItems_result _ = P.error "not a struct"
read_FetchNotificationItems_result :: T.Protocol p => p -> P.IO FetchNotificationItems_result
read_FetchNotificationItems_result iprot = to_FetchNotificationItems_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result)
decode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_result
decode_FetchNotificationItems_result iprot bs = to_FetchNotificationItems_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result) bs
typemap_FetchNotificationItems_result :: T.TypeMap
typemap_FetchNotificationItems_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_NotificationFetchResult))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_FetchNotificationItems_result :: FetchNotificationItems_result
default_FetchNotificationItems_result = FetchNotificationItems_result{
  fetchNotificationItems_result_success = default_NotificationFetchResult,
  fetchNotificationItems_result_e = P.Nothing}
data GetApprovedChannels_args = GetApprovedChannels_args  { getApprovedChannels_args_lastSynced :: I.Int64
  , getApprovedChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_args_lastSynced record   `H.hashWithSalt` getApprovedChannels_args_locale record  
instance QC.Arbitrary GetApprovedChannels_args where 
  arbitrary = M.liftM GetApprovedChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj}
    , if obj == default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj}
    ]
from_GetApprovedChannels_args :: GetApprovedChannels_args -> T.ThriftVal
from_GetApprovedChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5700 -> P.Just (2, ("lastSynced",T.TI64 _v5700))) $ getApprovedChannels_args_lastSynced record
  , (\_v5700 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5700))) $ getApprovedChannels_args_locale record
  ]
write_GetApprovedChannels_args :: T.Protocol p => p -> GetApprovedChannels_args -> P.IO ()
write_GetApprovedChannels_args oprot record = T.writeVal oprot $ from_GetApprovedChannels_args record
encode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> GetApprovedChannels_args -> LBS.ByteString
encode_GetApprovedChannels_args oprot record = T.serializeVal oprot $ from_GetApprovedChannels_args record
to_GetApprovedChannels_args :: T.ThriftVal -> GetApprovedChannels_args
to_GetApprovedChannels_args (T.TStruct fields) = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = P.maybe (getApprovedChannels_args_lastSynced default_GetApprovedChannels_args) (\(_,_val5702) -> (case _val5702 of {T.TI64 _val5703 -> _val5703; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getApprovedChannels_args_locale = P.maybe (getApprovedChannels_args_locale default_GetApprovedChannels_args) (\(_,_val5702) -> (case _val5702 of {T.TString _val5704 -> E.decodeUtf8 _val5704; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetApprovedChannels_args _ = P.error "not a struct"
read_GetApprovedChannels_args :: T.Protocol p => p -> P.IO GetApprovedChannels_args
read_GetApprovedChannels_args iprot = to_GetApprovedChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args)
decode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_args
decode_GetApprovedChannels_args iprot bs = to_GetApprovedChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args) bs
typemap_GetApprovedChannels_args :: T.TypeMap
typemap_GetApprovedChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetApprovedChannels_args :: GetApprovedChannels_args
default_GetApprovedChannels_args = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = 0,
  getApprovedChannels_args_locale = ""}
data GetApprovedChannels_result = GetApprovedChannels_result  { getApprovedChannels_result_success :: ApprovedChannelInfos
  , getApprovedChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_result_success record   `H.hashWithSalt` getApprovedChannels_result_e record  
instance QC.Arbitrary GetApprovedChannels_result where 
  arbitrary = M.liftM GetApprovedChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj}
    , if obj == default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj}
    ]
from_GetApprovedChannels_result :: GetApprovedChannels_result -> T.ThriftVal
from_GetApprovedChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5707 -> (1, ("e",from_ChannelException _v5707))) <$> getApprovedChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5707 -> P.Just (0, ("success",from_ApprovedChannelInfos _v5707))) $ getApprovedChannels_result_success record
    , (\_v5707 -> (1, ("e",from_ChannelException _v5707))) <$> getApprovedChannels_result_e record
    ]
    )
write_GetApprovedChannels_result :: T.Protocol p => p -> GetApprovedChannels_result -> P.IO ()
write_GetApprovedChannels_result oprot record = T.writeVal oprot $ from_GetApprovedChannels_result record
encode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> GetApprovedChannels_result -> LBS.ByteString
encode_GetApprovedChannels_result oprot record = T.serializeVal oprot $ from_GetApprovedChannels_result record
to_GetApprovedChannels_result :: T.ThriftVal -> GetApprovedChannels_result
to_GetApprovedChannels_result (T.TStruct fields) = GetApprovedChannels_result{
  getApprovedChannels_result_success = P.maybe (getApprovedChannels_result_success default_GetApprovedChannels_result) (\(_,_val5709) -> (case _val5709 of {T.TStruct _val5710 -> (to_ApprovedChannelInfos (T.TStruct _val5710)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getApprovedChannels_result_e = P.maybe (P.Nothing) (\(_,_val5709) -> P.Just (case _val5709 of {T.TStruct _val5711 -> (to_ChannelException (T.TStruct _val5711)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetApprovedChannels_result _ = P.error "not a struct"
read_GetApprovedChannels_result :: T.Protocol p => p -> P.IO GetApprovedChannels_result
read_GetApprovedChannels_result iprot = to_GetApprovedChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result)
decode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_result
decode_GetApprovedChannels_result iprot bs = to_GetApprovedChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result) bs
typemap_GetApprovedChannels_result :: T.TypeMap
typemap_GetApprovedChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ApprovedChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetApprovedChannels_result :: GetApprovedChannels_result
default_GetApprovedChannels_result = GetApprovedChannels_result{
  getApprovedChannels_result_success = default_ApprovedChannelInfos,
  getApprovedChannels_result_e = P.Nothing}
data GetChannelInfo_args = GetChannelInfo_args  { getChannelInfo_args_channelId :: LT.Text
  , getChannelInfo_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_args_channelId record   `H.hashWithSalt` getChannelInfo_args_locale record  
instance QC.Arbitrary GetChannelInfo_args where 
  arbitrary = M.liftM GetChannelInfo_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj}
    , if obj == default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj}
    ]
from_GetChannelInfo_args :: GetChannelInfo_args -> T.ThriftVal
from_GetChannelInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5714 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5714))) $ getChannelInfo_args_channelId record
  , (\_v5714 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5714))) $ getChannelInfo_args_locale record
  ]
write_GetChannelInfo_args :: T.Protocol p => p -> GetChannelInfo_args -> P.IO ()
write_GetChannelInfo_args oprot record = T.writeVal oprot $ from_GetChannelInfo_args record
encode_GetChannelInfo_args :: T.StatelessProtocol p => p -> GetChannelInfo_args -> LBS.ByteString
encode_GetChannelInfo_args oprot record = T.serializeVal oprot $ from_GetChannelInfo_args record
to_GetChannelInfo_args :: T.ThriftVal -> GetChannelInfo_args
to_GetChannelInfo_args (T.TStruct fields) = GetChannelInfo_args{
  getChannelInfo_args_channelId = P.maybe (getChannelInfo_args_channelId default_GetChannelInfo_args) (\(_,_val5716) -> (case _val5716 of {T.TString _val5717 -> E.decodeUtf8 _val5717; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannelInfo_args_locale = P.maybe (getChannelInfo_args_locale default_GetChannelInfo_args) (\(_,_val5716) -> (case _val5716 of {T.TString _val5718 -> E.decodeUtf8 _val5718; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannelInfo_args _ = P.error "not a struct"
read_GetChannelInfo_args :: T.Protocol p => p -> P.IO GetChannelInfo_args
read_GetChannelInfo_args iprot = to_GetChannelInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_args)
decode_GetChannelInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_args
decode_GetChannelInfo_args iprot bs = to_GetChannelInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_args) bs
typemap_GetChannelInfo_args :: T.TypeMap
typemap_GetChannelInfo_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("locale",T.T_STRING))]
default_GetChannelInfo_args :: GetChannelInfo_args
default_GetChannelInfo_args = GetChannelInfo_args{
  getChannelInfo_args_channelId = "",
  getChannelInfo_args_locale = ""}
data GetChannelInfo_result = GetChannelInfo_result  { getChannelInfo_result_success :: ChannelInfo
  , getChannelInfo_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_result_success record   `H.hashWithSalt` getChannelInfo_result_e record  
instance QC.Arbitrary GetChannelInfo_result where 
  arbitrary = M.liftM GetChannelInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj}
    , if obj == default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj}
    ]
from_GetChannelInfo_result :: GetChannelInfo_result -> T.ThriftVal
from_GetChannelInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5721 -> (1, ("e",from_ChannelException _v5721))) <$> getChannelInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5721 -> P.Just (0, ("success",from_ChannelInfo _v5721))) $ getChannelInfo_result_success record
    , (\_v5721 -> (1, ("e",from_ChannelException _v5721))) <$> getChannelInfo_result_e record
    ]
    )
write_GetChannelInfo_result :: T.Protocol p => p -> GetChannelInfo_result -> P.IO ()
write_GetChannelInfo_result oprot record = T.writeVal oprot $ from_GetChannelInfo_result record
encode_GetChannelInfo_result :: T.StatelessProtocol p => p -> GetChannelInfo_result -> LBS.ByteString
encode_GetChannelInfo_result oprot record = T.serializeVal oprot $ from_GetChannelInfo_result record
to_GetChannelInfo_result :: T.ThriftVal -> GetChannelInfo_result
to_GetChannelInfo_result (T.TStruct fields) = GetChannelInfo_result{
  getChannelInfo_result_success = P.maybe (getChannelInfo_result_success default_GetChannelInfo_result) (\(_,_val5723) -> (case _val5723 of {T.TStruct _val5724 -> (to_ChannelInfo (T.TStruct _val5724)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelInfo_result_e = P.maybe (P.Nothing) (\(_,_val5723) -> P.Just (case _val5723 of {T.TStruct _val5725 -> (to_ChannelException (T.TStruct _val5725)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelInfo_result _ = P.error "not a struct"
read_GetChannelInfo_result :: T.Protocol p => p -> P.IO GetChannelInfo_result
read_GetChannelInfo_result iprot = to_GetChannelInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_result)
decode_GetChannelInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_result
decode_GetChannelInfo_result iprot bs = to_GetChannelInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_result) bs
typemap_GetChannelInfo_result :: T.TypeMap
typemap_GetChannelInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfo))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelInfo_result :: GetChannelInfo_result
default_GetChannelInfo_result = GetChannelInfo_result{
  getChannelInfo_result_success = default_ChannelInfo,
  getChannelInfo_result_e = P.Nothing}
data GetChannelNotificationSetting_args = GetChannelNotificationSetting_args  { getChannelNotificationSetting_args_channelId :: LT.Text
  , getChannelNotificationSetting_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_args_channelId record   `H.hashWithSalt` getChannelNotificationSetting_args_locale record  
instance QC.Arbitrary GetChannelNotificationSetting_args where 
  arbitrary = M.liftM GetChannelNotificationSetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj}
    , if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj}
    ]
from_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args -> T.ThriftVal
from_GetChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5728 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5728))) $ getChannelNotificationSetting_args_channelId record
  , (\_v5728 -> P.Just (2, ("locale",T.TString $ E.encodeUtf8 _v5728))) $ getChannelNotificationSetting_args_locale record
  ]
write_GetChannelNotificationSetting_args :: T.Protocol p => p -> GetChannelNotificationSetting_args -> P.IO ()
write_GetChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_args record
encode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_args -> LBS.ByteString
encode_GetChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_args record
to_GetChannelNotificationSetting_args :: T.ThriftVal -> GetChannelNotificationSetting_args
to_GetChannelNotificationSetting_args (T.TStruct fields) = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = P.maybe (getChannelNotificationSetting_args_channelId default_GetChannelNotificationSetting_args) (\(_,_val5730) -> (case _val5730 of {T.TString _val5731 -> E.decodeUtf8 _val5731; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getChannelNotificationSetting_args_locale = P.maybe (getChannelNotificationSetting_args_locale default_GetChannelNotificationSetting_args) (\(_,_val5730) -> (case _val5730 of {T.TString _val5732 -> E.decodeUtf8 _val5732; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetChannelNotificationSetting_args _ = P.error "not a struct"
read_GetChannelNotificationSetting_args :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_args
read_GetChannelNotificationSetting_args iprot = to_GetChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args)
decode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_args
decode_GetChannelNotificationSetting_args iprot bs = to_GetChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args) bs
typemap_GetChannelNotificationSetting_args :: T.TypeMap
typemap_GetChannelNotificationSetting_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("locale",T.T_STRING))]
default_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args
default_GetChannelNotificationSetting_args = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = "",
  getChannelNotificationSetting_args_locale = ""}
data GetChannelNotificationSetting_result = GetChannelNotificationSetting_result  { getChannelNotificationSetting_result_success :: ChannelNotificationSetting
  , getChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_result_success record   `H.hashWithSalt` getChannelNotificationSetting_result_e record  
instance QC.Arbitrary GetChannelNotificationSetting_result where 
  arbitrary = M.liftM GetChannelNotificationSetting_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj}
    , if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj}
    ]
from_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result -> T.ThriftVal
from_GetChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5735 -> (1, ("e",from_ChannelException _v5735))) <$> getChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5735 -> P.Just (0, ("success",from_ChannelNotificationSetting _v5735))) $ getChannelNotificationSetting_result_success record
    , (\_v5735 -> (1, ("e",from_ChannelException _v5735))) <$> getChannelNotificationSetting_result_e record
    ]
    )
write_GetChannelNotificationSetting_result :: T.Protocol p => p -> GetChannelNotificationSetting_result -> P.IO ()
write_GetChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_result record
encode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_result -> LBS.ByteString
encode_GetChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_result record
to_GetChannelNotificationSetting_result :: T.ThriftVal -> GetChannelNotificationSetting_result
to_GetChannelNotificationSetting_result (T.TStruct fields) = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = P.maybe (getChannelNotificationSetting_result_success default_GetChannelNotificationSetting_result) (\(_,_val5737) -> (case _val5737 of {T.TStruct _val5738 -> (to_ChannelNotificationSetting (T.TStruct _val5738)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val5737) -> P.Just (case _val5737 of {T.TStruct _val5739 -> (to_ChannelException (T.TStruct _val5739)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSetting_result _ = P.error "not a struct"
read_GetChannelNotificationSetting_result :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_result
read_GetChannelNotificationSetting_result iprot = to_GetChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result)
decode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_result
decode_GetChannelNotificationSetting_result iprot bs = to_GetChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result) bs
typemap_GetChannelNotificationSetting_result :: T.TypeMap
typemap_GetChannelNotificationSetting_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelNotificationSetting))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result
default_GetChannelNotificationSetting_result = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = default_ChannelNotificationSetting,
  getChannelNotificationSetting_result_e = P.Nothing}
data GetChannelNotificationSettings_args = GetChannelNotificationSettings_args  { getChannelNotificationSettings_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_args_locale record  
instance QC.Arbitrary GetChannelNotificationSettings_args where 
  arbitrary = M.liftM GetChannelNotificationSettings_args (QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj}
    ]
from_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args -> T.ThriftVal
from_GetChannelNotificationSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5742 -> P.Just (1, ("locale",T.TString $ E.encodeUtf8 _v5742))) $ getChannelNotificationSettings_args_locale record
  ]
write_GetChannelNotificationSettings_args :: T.Protocol p => p -> GetChannelNotificationSettings_args -> P.IO ()
write_GetChannelNotificationSettings_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_args record
encode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_args -> LBS.ByteString
encode_GetChannelNotificationSettings_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_args record
to_GetChannelNotificationSettings_args :: T.ThriftVal -> GetChannelNotificationSettings_args
to_GetChannelNotificationSettings_args (T.TStruct fields) = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = P.maybe (getChannelNotificationSettings_args_locale default_GetChannelNotificationSettings_args) (\(_,_val5744) -> (case _val5744 of {T.TString _val5745 -> E.decodeUtf8 _val5745; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_args _ = P.error "not a struct"
read_GetChannelNotificationSettings_args :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_args
read_GetChannelNotificationSettings_args iprot = to_GetChannelNotificationSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args)
decode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_args
decode_GetChannelNotificationSettings_args iprot bs = to_GetChannelNotificationSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args) bs
typemap_GetChannelNotificationSettings_args :: T.TypeMap
typemap_GetChannelNotificationSettings_args = Map.fromList [(1,("locale",T.T_STRING))]
default_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args
default_GetChannelNotificationSettings_args = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = ""}
data GetChannelNotificationSettings_result = GetChannelNotificationSettings_result  { getChannelNotificationSettings_result_success :: (Vector.Vector ChannelNotificationSetting)
  , getChannelNotificationSettings_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_result_success record   `H.hashWithSalt` getChannelNotificationSettings_result_e record  
instance QC.Arbitrary GetChannelNotificationSettings_result where 
  arbitrary = M.liftM GetChannelNotificationSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj}
    , if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj}
    ]
from_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result -> T.ThriftVal
from_GetChannelNotificationSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5748 -> (1, ("e",from_ChannelException _v5748))) <$> getChannelNotificationSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5748 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v5750 -> from_ChannelNotificationSetting _v5750) $ Vector.toList _v5748))) $ getChannelNotificationSettings_result_success record
    , (\_v5748 -> (1, ("e",from_ChannelException _v5748))) <$> getChannelNotificationSettings_result_e record
    ]
    )
write_GetChannelNotificationSettings_result :: T.Protocol p => p -> GetChannelNotificationSettings_result -> P.IO ()
write_GetChannelNotificationSettings_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_result record
encode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_result -> LBS.ByteString
encode_GetChannelNotificationSettings_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_result record
to_GetChannelNotificationSettings_result :: T.ThriftVal -> GetChannelNotificationSettings_result
to_GetChannelNotificationSettings_result (T.TStruct fields) = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = P.maybe (getChannelNotificationSettings_result_success default_GetChannelNotificationSettings_result) (\(_,_val5752) -> (case _val5752 of {T.TList _ _val5753 -> (Vector.fromList $ P.map (\_v5754 -> (case _v5754 of {T.TStruct _val5755 -> (to_ChannelNotificationSetting (T.TStruct _val5755)); _ -> P.error "wrong type"})) _val5753); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSettings_result_e = P.maybe (P.Nothing) (\(_,_val5752) -> P.Just (case _val5752 of {T.TStruct _val5756 -> (to_ChannelException (T.TStruct _val5756)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_result _ = P.error "not a struct"
read_GetChannelNotificationSettings_result :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_result
read_GetChannelNotificationSettings_result iprot = to_GetChannelNotificationSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result)
decode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_result
decode_GetChannelNotificationSettings_result iprot bs = to_GetChannelNotificationSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result) bs
typemap_GetChannelNotificationSettings_result :: T.TypeMap
typemap_GetChannelNotificationSettings_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting)))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result
default_GetChannelNotificationSettings_result = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = Vector.empty,
  getChannelNotificationSettings_result_e = P.Nothing}
data GetChannels_args = GetChannels_args  { getChannels_args_lastSynced :: I.Int64
  , getChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_args_lastSynced record   `H.hashWithSalt` getChannels_args_locale record  
instance QC.Arbitrary GetChannels_args where 
  arbitrary = M.liftM GetChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj}
    , if obj == default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj}
    ]
from_GetChannels_args :: GetChannels_args -> T.ThriftVal
from_GetChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5759 -> P.Just (2, ("lastSynced",T.TI64 _v5759))) $ getChannels_args_lastSynced record
  , (\_v5759 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5759))) $ getChannels_args_locale record
  ]
write_GetChannels_args :: T.Protocol p => p -> GetChannels_args -> P.IO ()
write_GetChannels_args oprot record = T.writeVal oprot $ from_GetChannels_args record
encode_GetChannels_args :: T.StatelessProtocol p => p -> GetChannels_args -> LBS.ByteString
encode_GetChannels_args oprot record = T.serializeVal oprot $ from_GetChannels_args record
to_GetChannels_args :: T.ThriftVal -> GetChannels_args
to_GetChannels_args (T.TStruct fields) = GetChannels_args{
  getChannels_args_lastSynced = P.maybe (getChannels_args_lastSynced default_GetChannels_args) (\(_,_val5761) -> (case _val5761 of {T.TI64 _val5762 -> _val5762; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannels_args_locale = P.maybe (getChannels_args_locale default_GetChannels_args) (\(_,_val5761) -> (case _val5761 of {T.TString _val5763 -> E.decodeUtf8 _val5763; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannels_args _ = P.error "not a struct"
read_GetChannels_args :: T.Protocol p => p -> P.IO GetChannels_args
read_GetChannels_args iprot = to_GetChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_args)
decode_GetChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_args
decode_GetChannels_args iprot bs = to_GetChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_args) bs
typemap_GetChannels_args :: T.TypeMap
typemap_GetChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetChannels_args :: GetChannels_args
default_GetChannels_args = GetChannels_args{
  getChannels_args_lastSynced = 0,
  getChannels_args_locale = ""}
data GetChannels_result = GetChannels_result  { getChannels_result_success :: ChannelInfos
  , getChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_result_success record   `H.hashWithSalt` getChannels_result_e record  
instance QC.Arbitrary GetChannels_result where 
  arbitrary = M.liftM GetChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_result{getChannels_result_success = getChannels_result_success obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_success = getChannels_result_success obj}
    , if obj == default_GetChannels_result{getChannels_result_e = getChannels_result_e obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_e = getChannels_result_e obj}
    ]
from_GetChannels_result :: GetChannels_result -> T.ThriftVal
from_GetChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5766 -> (1, ("e",from_ChannelException _v5766))) <$> getChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5766 -> P.Just (0, ("success",from_ChannelInfos _v5766))) $ getChannels_result_success record
    , (\_v5766 -> (1, ("e",from_ChannelException _v5766))) <$> getChannels_result_e record
    ]
    )
write_GetChannels_result :: T.Protocol p => p -> GetChannels_result -> P.IO ()
write_GetChannels_result oprot record = T.writeVal oprot $ from_GetChannels_result record
encode_GetChannels_result :: T.StatelessProtocol p => p -> GetChannels_result -> LBS.ByteString
encode_GetChannels_result oprot record = T.serializeVal oprot $ from_GetChannels_result record
to_GetChannels_result :: T.ThriftVal -> GetChannels_result
to_GetChannels_result (T.TStruct fields) = GetChannels_result{
  getChannels_result_success = P.maybe (getChannels_result_success default_GetChannels_result) (\(_,_val5768) -> (case _val5768 of {T.TStruct _val5769 -> (to_ChannelInfos (T.TStruct _val5769)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannels_result_e = P.maybe (P.Nothing) (\(_,_val5768) -> P.Just (case _val5768 of {T.TStruct _val5770 -> (to_ChannelException (T.TStruct _val5770)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannels_result _ = P.error "not a struct"
read_GetChannels_result :: T.Protocol p => p -> P.IO GetChannels_result
read_GetChannels_result iprot = to_GetChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_result)
decode_GetChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_result
decode_GetChannels_result iprot bs = to_GetChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_result) bs
typemap_GetChannels_result :: T.TypeMap
typemap_GetChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannels_result :: GetChannels_result
default_GetChannels_result = GetChannels_result{
  getChannels_result_success = default_ChannelInfos,
  getChannels_result_e = P.Nothing}
data GetDomains_args = GetDomains_args  { getDomains_args_lastSynced :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_args_lastSynced record  
instance QC.Arbitrary GetDomains_args where 
  arbitrary = M.liftM GetDomains_args (QC.arbitrary)
  shrink obj | obj == default_GetDomains_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj} then P.Nothing else P.Just $ default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj}
    ]
from_GetDomains_args :: GetDomains_args -> T.ThriftVal
from_GetDomains_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5773 -> P.Just (2, ("lastSynced",T.TI64 _v5773))) $ getDomains_args_lastSynced record
  ]
write_GetDomains_args :: T.Protocol p => p -> GetDomains_args -> P.IO ()
write_GetDomains_args oprot record = T.writeVal oprot $ from_GetDomains_args record
encode_GetDomains_args :: T.StatelessProtocol p => p -> GetDomains_args -> LBS.ByteString
encode_GetDomains_args oprot record = T.serializeVal oprot $ from_GetDomains_args record
to_GetDomains_args :: T.ThriftVal -> GetDomains_args
to_GetDomains_args (T.TStruct fields) = GetDomains_args{
  getDomains_args_lastSynced = P.maybe (getDomains_args_lastSynced default_GetDomains_args) (\(_,_val5775) -> (case _val5775 of {T.TI64 _val5776 -> _val5776; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDomains_args _ = P.error "not a struct"
read_GetDomains_args :: T.Protocol p => p -> P.IO GetDomains_args
read_GetDomains_args iprot = to_GetDomains_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_args)
decode_GetDomains_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_args
decode_GetDomains_args iprot bs = to_GetDomains_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_args) bs
typemap_GetDomains_args :: T.TypeMap
typemap_GetDomains_args = Map.fromList [(2,("lastSynced",T.T_I64))]
default_GetDomains_args :: GetDomains_args
default_GetDomains_args = GetDomains_args{
  getDomains_args_lastSynced = 0}
data GetDomains_result = GetDomains_result  { getDomains_result_success :: ChannelDomains
  , getDomains_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_result_success record   `H.hashWithSalt` getDomains_result_e record  
instance QC.Arbitrary GetDomains_result where 
  arbitrary = M.liftM GetDomains_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDomains_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_result{getDomains_result_success = getDomains_result_success obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_success = getDomains_result_success obj}
    , if obj == default_GetDomains_result{getDomains_result_e = getDomains_result_e obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_e = getDomains_result_e obj}
    ]
from_GetDomains_result :: GetDomains_result -> T.ThriftVal
from_GetDomains_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5779 -> (1, ("e",from_ChannelException _v5779))) <$> getDomains_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5779 -> P.Just (0, ("success",from_ChannelDomains _v5779))) $ getDomains_result_success record
    , (\_v5779 -> (1, ("e",from_ChannelException _v5779))) <$> getDomains_result_e record
    ]
    )
write_GetDomains_result :: T.Protocol p => p -> GetDomains_result -> P.IO ()
write_GetDomains_result oprot record = T.writeVal oprot $ from_GetDomains_result record
encode_GetDomains_result :: T.StatelessProtocol p => p -> GetDomains_result -> LBS.ByteString
encode_GetDomains_result oprot record = T.serializeVal oprot $ from_GetDomains_result record
to_GetDomains_result :: T.ThriftVal -> GetDomains_result
to_GetDomains_result (T.TStruct fields) = GetDomains_result{
  getDomains_result_success = P.maybe (getDomains_result_success default_GetDomains_result) (\(_,_val5781) -> (case _val5781 of {T.TStruct _val5782 -> (to_ChannelDomains (T.TStruct _val5782)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDomains_result_e = P.maybe (P.Nothing) (\(_,_val5781) -> P.Just (case _val5781 of {T.TStruct _val5783 -> (to_ChannelException (T.TStruct _val5783)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDomains_result _ = P.error "not a struct"
read_GetDomains_result :: T.Protocol p => p -> P.IO GetDomains_result
read_GetDomains_result iprot = to_GetDomains_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_result)
decode_GetDomains_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_result
decode_GetDomains_result iprot bs = to_GetDomains_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_result) bs
typemap_GetDomains_result :: T.TypeMap
typemap_GetDomains_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelDomains))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetDomains_result :: GetDomains_result
default_GetDomains_result = GetDomains_result{
  getDomains_result_success = default_ChannelDomains,
  getDomains_result_e = P.Nothing}
data GetFriendChannelMatrices_args = GetFriendChannelMatrices_args  { getFriendChannelMatrices_args_channelIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_args_channelIds record  
instance QC.Arbitrary GetFriendChannelMatrices_args where 
  arbitrary = M.liftM GetFriendChannelMatrices_args (QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj}
    ]
from_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args -> T.ThriftVal
from_GetFriendChannelMatrices_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5786 -> P.Just (1, ("channelIds",T.TList T.T_STRING $ P.map (\_v5788 -> T.TString $ E.encodeUtf8 _v5788) $ Vector.toList _v5786))) $ getFriendChannelMatrices_args_channelIds record
  ]
write_GetFriendChannelMatrices_args :: T.Protocol p => p -> GetFriendChannelMatrices_args -> P.IO ()
write_GetFriendChannelMatrices_args oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_args record
encode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_args -> LBS.ByteString
encode_GetFriendChannelMatrices_args oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_args record
to_GetFriendChannelMatrices_args :: T.ThriftVal -> GetFriendChannelMatrices_args
to_GetFriendChannelMatrices_args (T.TStruct fields) = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = P.maybe (getFriendChannelMatrices_args_channelIds default_GetFriendChannelMatrices_args) (\(_,_val5790) -> (case _val5790 of {T.TList _ _val5791 -> (Vector.fromList $ P.map (\_v5792 -> (case _v5792 of {T.TString _val5793 -> E.decodeUtf8 _val5793; _ -> P.error "wrong type"})) _val5791); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_args _ = P.error "not a struct"
read_GetFriendChannelMatrices_args :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_args
read_GetFriendChannelMatrices_args iprot = to_GetFriendChannelMatrices_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args)
decode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_args
decode_GetFriendChannelMatrices_args iprot bs = to_GetFriendChannelMatrices_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args) bs
typemap_GetFriendChannelMatrices_args :: T.TypeMap
typemap_GetFriendChannelMatrices_args = Map.fromList [(1,("channelIds",(T.T_LIST T.T_STRING)))]
default_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args
default_GetFriendChannelMatrices_args = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = Vector.empty}
data GetFriendChannelMatrices_result = GetFriendChannelMatrices_result  { getFriendChannelMatrices_result_success :: FriendChannelMatricesResponse
  , getFriendChannelMatrices_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_result_success record   `H.hashWithSalt` getFriendChannelMatrices_result_e record  
instance QC.Arbitrary GetFriendChannelMatrices_result where 
  arbitrary = M.liftM GetFriendChannelMatrices_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj}
    , if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj}
    ]
from_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result -> T.ThriftVal
from_GetFriendChannelMatrices_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5796 -> (1, ("e",from_ChannelException _v5796))) <$> getFriendChannelMatrices_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5796 -> P.Just (0, ("success",from_FriendChannelMatricesResponse _v5796))) $ getFriendChannelMatrices_result_success record
    , (\_v5796 -> (1, ("e",from_ChannelException _v5796))) <$> getFriendChannelMatrices_result_e record
    ]
    )
write_GetFriendChannelMatrices_result :: T.Protocol p => p -> GetFriendChannelMatrices_result -> P.IO ()
write_GetFriendChannelMatrices_result oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_result record
encode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_result -> LBS.ByteString
encode_GetFriendChannelMatrices_result oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_result record
to_GetFriendChannelMatrices_result :: T.ThriftVal -> GetFriendChannelMatrices_result
to_GetFriendChannelMatrices_result (T.TStruct fields) = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = P.maybe (getFriendChannelMatrices_result_success default_GetFriendChannelMatrices_result) (\(_,_val5798) -> (case _val5798 of {T.TStruct _val5799 -> (to_FriendChannelMatricesResponse (T.TStruct _val5799)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendChannelMatrices_result_e = P.maybe (P.Nothing) (\(_,_val5798) -> P.Just (case _val5798 of {T.TStruct _val5800 -> (to_ChannelException (T.TStruct _val5800)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_result _ = P.error "not a struct"
read_GetFriendChannelMatrices_result :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_result
read_GetFriendChannelMatrices_result iprot = to_GetFriendChannelMatrices_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result)
decode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_result
decode_GetFriendChannelMatrices_result iprot bs = to_GetFriendChannelMatrices_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result) bs
typemap_GetFriendChannelMatrices_result :: T.TypeMap
typemap_GetFriendChannelMatrices_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FriendChannelMatricesResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result
default_GetFriendChannelMatrices_result = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = default_FriendChannelMatricesResponse,
  getFriendChannelMatrices_result_e = P.Nothing}
data UpdateChannelSettings_args = UpdateChannelSettings_args  { updateChannelSettings_args_channelSettings :: ChannelSettings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelSettings_args_channelSettings record  
instance QC.Arbitrary UpdateChannelSettings_args where 
  arbitrary = M.liftM UpdateChannelSettings_args (QC.arbitrary)
  shrink obj | obj == default_UpdateChannelSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelSettings_args{updateChannelSettings_args_channelSettings = updateChannelSettings_args_channelSettings obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_args{updateChannelSettings_args_channelSettings = updateChannelSettings_args_channelSettings obj}
    ]
from_UpdateChannelSettings_args :: UpdateChannelSettings_args -> T.ThriftVal
from_UpdateChannelSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5803 -> P.Just (1, ("channelSettings",from_ChannelSettings _v5803))) $ updateChannelSettings_args_channelSettings record
  ]
write_UpdateChannelSettings_args :: T.Protocol p => p -> UpdateChannelSettings_args -> P.IO ()
write_UpdateChannelSettings_args oprot record = T.writeVal oprot $ from_UpdateChannelSettings_args record
encode_UpdateChannelSettings_args :: T.StatelessProtocol p => p -> UpdateChannelSettings_args -> LBS.ByteString
encode_UpdateChannelSettings_args oprot record = T.serializeVal oprot $ from_UpdateChannelSettings_args record
to_UpdateChannelSettings_args :: T.ThriftVal -> UpdateChannelSettings_args
to_UpdateChannelSettings_args (T.TStruct fields) = UpdateChannelSettings_args{
  updateChannelSettings_args_channelSettings = P.maybe (updateChannelSettings_args_channelSettings default_UpdateChannelSettings_args) (\(_,_val5805) -> (case _val5805 of {T.TStruct _val5806 -> (to_ChannelSettings (T.TStruct _val5806)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelSettings_args _ = P.error "not a struct"
read_UpdateChannelSettings_args :: T.Protocol p => p -> P.IO UpdateChannelSettings_args
read_UpdateChannelSettings_args iprot = to_UpdateChannelSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_args)
decode_UpdateChannelSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelSettings_args
decode_UpdateChannelSettings_args iprot bs = to_UpdateChannelSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_args) bs
typemap_UpdateChannelSettings_args :: T.TypeMap
typemap_UpdateChannelSettings_args = Map.fromList [(1,("channelSettings",(T.T_STRUCT typemap_ChannelSettings)))]
default_UpdateChannelSettings_args :: UpdateChannelSettings_args
default_UpdateChannelSettings_args = UpdateChannelSettings_args{
  updateChannelSettings_args_channelSettings = default_ChannelSettings}
data UpdateChannelSettings_result = UpdateChannelSettings_result  { updateChannelSettings_result_success :: P.Bool
  , updateChannelSettings_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelSettings_result_success record   `H.hashWithSalt` updateChannelSettings_result_e record  
instance QC.Arbitrary UpdateChannelSettings_result where 
  arbitrary = M.liftM UpdateChannelSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateChannelSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelSettings_result{updateChannelSettings_result_success = updateChannelSettings_result_success obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_result{updateChannelSettings_result_success = updateChannelSettings_result_success obj}
    , if obj == default_UpdateChannelSettings_result{updateChannelSettings_result_e = updateChannelSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_result{updateChannelSettings_result_e = updateChannelSettings_result_e obj}
    ]
from_UpdateChannelSettings_result :: UpdateChannelSettings_result -> T.ThriftVal
from_UpdateChannelSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5809 -> (1, ("e",from_ChannelException _v5809))) <$> updateChannelSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5809 -> P.Just (0, ("success",T.TBool _v5809))) $ updateChannelSettings_result_success record
    , (\_v5809 -> (1, ("e",from_ChannelException _v5809))) <$> updateChannelSettings_result_e record
    ]
    )
write_UpdateChannelSettings_result :: T.Protocol p => p -> UpdateChannelSettings_result -> P.IO ()
write_UpdateChannelSettings_result oprot record = T.writeVal oprot $ from_UpdateChannelSettings_result record
encode_UpdateChannelSettings_result :: T.StatelessProtocol p => p -> UpdateChannelSettings_result -> LBS.ByteString
encode_UpdateChannelSettings_result oprot record = T.serializeVal oprot $ from_UpdateChannelSettings_result record
to_UpdateChannelSettings_result :: T.ThriftVal -> UpdateChannelSettings_result
to_UpdateChannelSettings_result (T.TStruct fields) = UpdateChannelSettings_result{
  updateChannelSettings_result_success = P.maybe (updateChannelSettings_result_success default_UpdateChannelSettings_result) (\(_,_val5811) -> (case _val5811 of {T.TBool _val5812 -> _val5812; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateChannelSettings_result_e = P.maybe (P.Nothing) (\(_,_val5811) -> P.Just (case _val5811 of {T.TStruct _val5813 -> (to_ChannelException (T.TStruct _val5813)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelSettings_result _ = P.error "not a struct"
read_UpdateChannelSettings_result :: T.Protocol p => p -> P.IO UpdateChannelSettings_result
read_UpdateChannelSettings_result iprot = to_UpdateChannelSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_result)
decode_UpdateChannelSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelSettings_result
decode_UpdateChannelSettings_result iprot bs = to_UpdateChannelSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_result) bs
typemap_UpdateChannelSettings_result :: T.TypeMap
typemap_UpdateChannelSettings_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_UpdateChannelSettings_result :: UpdateChannelSettings_result
default_UpdateChannelSettings_result = UpdateChannelSettings_result{
  updateChannelSettings_result_success = P.False,
  updateChannelSettings_result_e = P.Nothing}
data GetCommonDomains_args = GetCommonDomains_args  { getCommonDomains_args_lastSynced :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCommonDomains_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCommonDomains_args_lastSynced record  
instance QC.Arbitrary GetCommonDomains_args where 
  arbitrary = M.liftM GetCommonDomains_args (QC.arbitrary)
  shrink obj | obj == default_GetCommonDomains_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCommonDomains_args{getCommonDomains_args_lastSynced = getCommonDomains_args_lastSynced obj} then P.Nothing else P.Just $ default_GetCommonDomains_args{getCommonDomains_args_lastSynced = getCommonDomains_args_lastSynced obj}
    ]
from_GetCommonDomains_args :: GetCommonDomains_args -> T.ThriftVal
from_GetCommonDomains_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5816 -> P.Just (1, ("lastSynced",T.TI64 _v5816))) $ getCommonDomains_args_lastSynced record
  ]
write_GetCommonDomains_args :: T.Protocol p => p -> GetCommonDomains_args -> P.IO ()
write_GetCommonDomains_args oprot record = T.writeVal oprot $ from_GetCommonDomains_args record
encode_GetCommonDomains_args :: T.StatelessProtocol p => p -> GetCommonDomains_args -> LBS.ByteString
encode_GetCommonDomains_args oprot record = T.serializeVal oprot $ from_GetCommonDomains_args record
to_GetCommonDomains_args :: T.ThriftVal -> GetCommonDomains_args
to_GetCommonDomains_args (T.TStruct fields) = GetCommonDomains_args{
  getCommonDomains_args_lastSynced = P.maybe (getCommonDomains_args_lastSynced default_GetCommonDomains_args) (\(_,_val5818) -> (case _val5818 of {T.TI64 _val5819 -> _val5819; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCommonDomains_args _ = P.error "not a struct"
read_GetCommonDomains_args :: T.Protocol p => p -> P.IO GetCommonDomains_args
read_GetCommonDomains_args iprot = to_GetCommonDomains_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCommonDomains_args)
decode_GetCommonDomains_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCommonDomains_args
decode_GetCommonDomains_args iprot bs = to_GetCommonDomains_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCommonDomains_args) bs
typemap_GetCommonDomains_args :: T.TypeMap
typemap_GetCommonDomains_args = Map.fromList [(1,("lastSynced",T.T_I64))]
default_GetCommonDomains_args :: GetCommonDomains_args
default_GetCommonDomains_args = GetCommonDomains_args{
  getCommonDomains_args_lastSynced = 0}
data GetCommonDomains_result = GetCommonDomains_result  { getCommonDomains_result_success :: ChannelDomains
  , getCommonDomains_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCommonDomains_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCommonDomains_result_success record   `H.hashWithSalt` getCommonDomains_result_e record  
instance QC.Arbitrary GetCommonDomains_result where 
  arbitrary = M.liftM GetCommonDomains_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCommonDomains_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCommonDomains_result{getCommonDomains_result_success = getCommonDomains_result_success obj} then P.Nothing else P.Just $ default_GetCommonDomains_result{getCommonDomains_result_success = getCommonDomains_result_success obj}
    , if obj == default_GetCommonDomains_result{getCommonDomains_result_e = getCommonDomains_result_e obj} then P.Nothing else P.Just $ default_GetCommonDomains_result{getCommonDomains_result_e = getCommonDomains_result_e obj}
    ]
from_GetCommonDomains_result :: GetCommonDomains_result -> T.ThriftVal
from_GetCommonDomains_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5822 -> (1, ("e",from_ChannelException _v5822))) <$> getCommonDomains_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5822 -> P.Just (0, ("success",from_ChannelDomains _v5822))) $ getCommonDomains_result_success record
    , (\_v5822 -> (1, ("e",from_ChannelException _v5822))) <$> getCommonDomains_result_e record
    ]
    )
write_GetCommonDomains_result :: T.Protocol p => p -> GetCommonDomains_result -> P.IO ()
write_GetCommonDomains_result oprot record = T.writeVal oprot $ from_GetCommonDomains_result record
encode_GetCommonDomains_result :: T.StatelessProtocol p => p -> GetCommonDomains_result -> LBS.ByteString
encode_GetCommonDomains_result oprot record = T.serializeVal oprot $ from_GetCommonDomains_result record
to_GetCommonDomains_result :: T.ThriftVal -> GetCommonDomains_result
to_GetCommonDomains_result (T.TStruct fields) = GetCommonDomains_result{
  getCommonDomains_result_success = P.maybe (getCommonDomains_result_success default_GetCommonDomains_result) (\(_,_val5824) -> (case _val5824 of {T.TStruct _val5825 -> (to_ChannelDomains (T.TStruct _val5825)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCommonDomains_result_e = P.maybe (P.Nothing) (\(_,_val5824) -> P.Just (case _val5824 of {T.TStruct _val5826 -> (to_ChannelException (T.TStruct _val5826)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCommonDomains_result _ = P.error "not a struct"
read_GetCommonDomains_result :: T.Protocol p => p -> P.IO GetCommonDomains_result
read_GetCommonDomains_result iprot = to_GetCommonDomains_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCommonDomains_result)
decode_GetCommonDomains_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCommonDomains_result
decode_GetCommonDomains_result iprot bs = to_GetCommonDomains_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCommonDomains_result) bs
typemap_GetCommonDomains_result :: T.TypeMap
typemap_GetCommonDomains_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelDomains))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetCommonDomains_result :: GetCommonDomains_result
default_GetCommonDomains_result = GetCommonDomains_result{
  getCommonDomains_result_success = default_ChannelDomains,
  getCommonDomains_result_e = P.Nothing}
data GetNotificationBadgeCount_args = GetNotificationBadgeCount_args  { getNotificationBadgeCount_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_args_localRev record  
instance QC.Arbitrary GetNotificationBadgeCount_args where 
  arbitrary = M.liftM GetNotificationBadgeCount_args (QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj}
    ]
from_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args -> T.ThriftVal
from_GetNotificationBadgeCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5829 -> P.Just (2, ("localRev",T.TI64 _v5829))) $ getNotificationBadgeCount_args_localRev record
  ]
write_GetNotificationBadgeCount_args :: T.Protocol p => p -> GetNotificationBadgeCount_args -> P.IO ()
write_GetNotificationBadgeCount_args oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_args record
encode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_args -> LBS.ByteString
encode_GetNotificationBadgeCount_args oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_args record
to_GetNotificationBadgeCount_args :: T.ThriftVal -> GetNotificationBadgeCount_args
to_GetNotificationBadgeCount_args (T.TStruct fields) = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = P.maybe (getNotificationBadgeCount_args_localRev default_GetNotificationBadgeCount_args) (\(_,_val5831) -> (case _val5831 of {T.TI64 _val5832 -> _val5832; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotificationBadgeCount_args _ = P.error "not a struct"
read_GetNotificationBadgeCount_args :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_args
read_GetNotificationBadgeCount_args iprot = to_GetNotificationBadgeCount_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args)
decode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_args
decode_GetNotificationBadgeCount_args iprot bs = to_GetNotificationBadgeCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args) bs
typemap_GetNotificationBadgeCount_args :: T.TypeMap
typemap_GetNotificationBadgeCount_args = Map.fromList [(2,("localRev",T.T_I64))]
default_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args
default_GetNotificationBadgeCount_args = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = 0}
data GetNotificationBadgeCount_result = GetNotificationBadgeCount_result  { getNotificationBadgeCount_result_success :: I.Int32
  , getNotificationBadgeCount_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_result_success record   `H.hashWithSalt` getNotificationBadgeCount_result_e record  
instance QC.Arbitrary GetNotificationBadgeCount_result where 
  arbitrary = M.liftM GetNotificationBadgeCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj}
    , if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj}
    ]
from_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result -> T.ThriftVal
from_GetNotificationBadgeCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5835 -> (1, ("e",from_ChannelException _v5835))) <$> getNotificationBadgeCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5835 -> P.Just (0, ("success",T.TI32 _v5835))) $ getNotificationBadgeCount_result_success record
    , (\_v5835 -> (1, ("e",from_ChannelException _v5835))) <$> getNotificationBadgeCount_result_e record
    ]
    )
write_GetNotificationBadgeCount_result :: T.Protocol p => p -> GetNotificationBadgeCount_result -> P.IO ()
write_GetNotificationBadgeCount_result oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_result record
encode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_result -> LBS.ByteString
encode_GetNotificationBadgeCount_result oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_result record
to_GetNotificationBadgeCount_result :: T.ThriftVal -> GetNotificationBadgeCount_result
to_GetNotificationBadgeCount_result (T.TStruct fields) = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = P.maybe (getNotificationBadgeCount_result_success default_GetNotificationBadgeCount_result) (\(_,_val5837) -> (case _val5837 of {T.TI32 _val5838 -> _val5838; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotificationBadgeCount_result_e = P.maybe (P.Nothing) (\(_,_val5837) -> P.Just (case _val5837 of {T.TStruct _val5839 -> (to_ChannelException (T.TStruct _val5839)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNotificationBadgeCount_result _ = P.error "not a struct"
read_GetNotificationBadgeCount_result :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_result
read_GetNotificationBadgeCount_result iprot = to_GetNotificationBadgeCount_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result)
decode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_result
decode_GetNotificationBadgeCount_result iprot bs = to_GetNotificationBadgeCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result) bs
typemap_GetNotificationBadgeCount_result :: T.TypeMap
typemap_GetNotificationBadgeCount_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result
default_GetNotificationBadgeCount_result = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = 0,
  getNotificationBadgeCount_result_e = P.Nothing}
data IssueChannelToken_args = IssueChannelToken_args  { issueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_args_channelId record  
instance QC.Arbitrary IssueChannelToken_args where 
  arbitrary = M.liftM IssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj}
    ]
from_IssueChannelToken_args :: IssueChannelToken_args -> T.ThriftVal
from_IssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5842 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5842))) $ issueChannelToken_args_channelId record
  ]
write_IssueChannelToken_args :: T.Protocol p => p -> IssueChannelToken_args -> P.IO ()
write_IssueChannelToken_args oprot record = T.writeVal oprot $ from_IssueChannelToken_args record
encode_IssueChannelToken_args :: T.StatelessProtocol p => p -> IssueChannelToken_args -> LBS.ByteString
encode_IssueChannelToken_args oprot record = T.serializeVal oprot $ from_IssueChannelToken_args record
to_IssueChannelToken_args :: T.ThriftVal -> IssueChannelToken_args
to_IssueChannelToken_args (T.TStruct fields) = IssueChannelToken_args{
  issueChannelToken_args_channelId = P.maybe (issueChannelToken_args_channelId default_IssueChannelToken_args) (\(_,_val5844) -> (case _val5844 of {T.TString _val5845 -> E.decodeUtf8 _val5845; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_args _ = P.error "not a struct"
read_IssueChannelToken_args :: T.Protocol p => p -> P.IO IssueChannelToken_args
read_IssueChannelToken_args iprot = to_IssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_args)
decode_IssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_args
decode_IssueChannelToken_args iprot bs = to_IssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_args) bs
typemap_IssueChannelToken_args :: T.TypeMap
typemap_IssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_IssueChannelToken_args :: IssueChannelToken_args
default_IssueChannelToken_args = IssueChannelToken_args{
  issueChannelToken_args_channelId = ""}
data IssueChannelToken_result = IssueChannelToken_result  { issueChannelToken_result_success :: ChannelToken
  , issueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_result_success record   `H.hashWithSalt` issueChannelToken_result_e record  
instance QC.Arbitrary IssueChannelToken_result where 
  arbitrary = M.liftM IssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj}
    , if obj == default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj}
    ]
from_IssueChannelToken_result :: IssueChannelToken_result -> T.ThriftVal
from_IssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5848 -> (1, ("e",from_ChannelException _v5848))) <$> issueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5848 -> P.Just (0, ("success",from_ChannelToken _v5848))) $ issueChannelToken_result_success record
    , (\_v5848 -> (1, ("e",from_ChannelException _v5848))) <$> issueChannelToken_result_e record
    ]
    )
write_IssueChannelToken_result :: T.Protocol p => p -> IssueChannelToken_result -> P.IO ()
write_IssueChannelToken_result oprot record = T.writeVal oprot $ from_IssueChannelToken_result record
encode_IssueChannelToken_result :: T.StatelessProtocol p => p -> IssueChannelToken_result -> LBS.ByteString
encode_IssueChannelToken_result oprot record = T.serializeVal oprot $ from_IssueChannelToken_result record
to_IssueChannelToken_result :: T.ThriftVal -> IssueChannelToken_result
to_IssueChannelToken_result (T.TStruct fields) = IssueChannelToken_result{
  issueChannelToken_result_success = P.maybe (issueChannelToken_result_success default_IssueChannelToken_result) (\(_,_val5850) -> (case _val5850 of {T.TStruct _val5851 -> (to_ChannelToken (T.TStruct _val5851)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val5850) -> P.Just (case _val5850 of {T.TStruct _val5852 -> (to_ChannelException (T.TStruct _val5852)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_result _ = P.error "not a struct"
read_IssueChannelToken_result :: T.Protocol p => p -> P.IO IssueChannelToken_result
read_IssueChannelToken_result iprot = to_IssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_result)
decode_IssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_result
decode_IssueChannelToken_result iprot bs = to_IssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_result) bs
typemap_IssueChannelToken_result :: T.TypeMap
typemap_IssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueChannelToken_result :: IssueChannelToken_result
default_IssueChannelToken_result = IssueChannelToken_result{
  issueChannelToken_result_success = default_ChannelToken,
  issueChannelToken_result_e = P.Nothing}
data IssueRequestToken_args = IssueRequestToken_args  { issueRequestToken_args_channelId :: LT.Text
  , issueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_args_channelId record   `H.hashWithSalt` issueRequestToken_args_otpId record  
instance QC.Arbitrary IssueRequestToken_args where 
  arbitrary = M.liftM IssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj}
    , if obj == default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj}
    ]
from_IssueRequestToken_args :: IssueRequestToken_args -> T.ThriftVal
from_IssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5855 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5855))) $ issueRequestToken_args_channelId record
  , (\_v5855 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5855))) $ issueRequestToken_args_otpId record
  ]
write_IssueRequestToken_args :: T.Protocol p => p -> IssueRequestToken_args -> P.IO ()
write_IssueRequestToken_args oprot record = T.writeVal oprot $ from_IssueRequestToken_args record
encode_IssueRequestToken_args :: T.StatelessProtocol p => p -> IssueRequestToken_args -> LBS.ByteString
encode_IssueRequestToken_args oprot record = T.serializeVal oprot $ from_IssueRequestToken_args record
to_IssueRequestToken_args :: T.ThriftVal -> IssueRequestToken_args
to_IssueRequestToken_args (T.TStruct fields) = IssueRequestToken_args{
  issueRequestToken_args_channelId = P.maybe (issueRequestToken_args_channelId default_IssueRequestToken_args) (\(_,_val5857) -> (case _val5857 of {T.TString _val5858 -> E.decodeUtf8 _val5858; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestToken_args_otpId = P.maybe (issueRequestToken_args_otpId default_IssueRequestToken_args) (\(_,_val5857) -> (case _val5857 of {T.TString _val5859 -> E.decodeUtf8 _val5859; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueRequestToken_args _ = P.error "not a struct"
read_IssueRequestToken_args :: T.Protocol p => p -> P.IO IssueRequestToken_args
read_IssueRequestToken_args iprot = to_IssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_args)
decode_IssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_args
decode_IssueRequestToken_args iprot bs = to_IssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_args) bs
typemap_IssueRequestToken_args :: T.TypeMap
typemap_IssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_IssueRequestToken_args :: IssueRequestToken_args
default_IssueRequestToken_args = IssueRequestToken_args{
  issueRequestToken_args_channelId = "",
  issueRequestToken_args_otpId = ""}
data IssueRequestToken_result = IssueRequestToken_result  { issueRequestToken_result_success :: LT.Text
  , issueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_result_success record   `H.hashWithSalt` issueRequestToken_result_e record  
instance QC.Arbitrary IssueRequestToken_result where 
  arbitrary = M.liftM IssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj}
    , if obj == default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj}
    ]
from_IssueRequestToken_result :: IssueRequestToken_result -> T.ThriftVal
from_IssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5862 -> (1, ("e",from_ChannelException _v5862))) <$> issueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5862 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5862))) $ issueRequestToken_result_success record
    , (\_v5862 -> (1, ("e",from_ChannelException _v5862))) <$> issueRequestToken_result_e record
    ]
    )
write_IssueRequestToken_result :: T.Protocol p => p -> IssueRequestToken_result -> P.IO ()
write_IssueRequestToken_result oprot record = T.writeVal oprot $ from_IssueRequestToken_result record
encode_IssueRequestToken_result :: T.StatelessProtocol p => p -> IssueRequestToken_result -> LBS.ByteString
encode_IssueRequestToken_result oprot record = T.serializeVal oprot $ from_IssueRequestToken_result record
to_IssueRequestToken_result :: T.ThriftVal -> IssueRequestToken_result
to_IssueRequestToken_result (T.TStruct fields) = IssueRequestToken_result{
  issueRequestToken_result_success = P.maybe (issueRequestToken_result_success default_IssueRequestToken_result) (\(_,_val5864) -> (case _val5864 of {T.TString _val5865 -> E.decodeUtf8 _val5865; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val5864) -> P.Just (case _val5864 of {T.TStruct _val5866 -> (to_ChannelException (T.TStruct _val5866)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestToken_result _ = P.error "not a struct"
read_IssueRequestToken_result :: T.Protocol p => p -> P.IO IssueRequestToken_result
read_IssueRequestToken_result iprot = to_IssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_result)
decode_IssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_result
decode_IssueRequestToken_result iprot bs = to_IssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_result) bs
typemap_IssueRequestToken_result :: T.TypeMap
typemap_IssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestToken_result :: IssueRequestToken_result
default_IssueRequestToken_result = IssueRequestToken_result{
  issueRequestToken_result_success = "",
  issueRequestToken_result_e = P.Nothing}
data IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args  { issueRequestTokenWithAuthScheme_args_channelId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_otpId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_authScheme :: (Vector.Vector LT.Text)
  , issueRequestTokenWithAuthScheme_args_returnUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_channelId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_otpId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_authScheme record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_returnUrl record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_args where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj}
    ]
from_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5869 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5869))) $ issueRequestTokenWithAuthScheme_args_channelId record
  , (\_v5869 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5869))) $ issueRequestTokenWithAuthScheme_args_otpId record
  , (\_v5869 -> P.Just (3, ("authScheme",T.TList T.T_STRING $ P.map (\_v5871 -> T.TString $ E.encodeUtf8 _v5871) $ Vector.toList _v5869))) $ issueRequestTokenWithAuthScheme_args_authScheme record
  , (\_v5869 -> P.Just (4, ("returnUrl",T.TString $ E.encodeUtf8 _v5869))) $ issueRequestTokenWithAuthScheme_args_returnUrl record
  ]
write_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_args -> P.IO ()
write_IssueRequestTokenWithAuthScheme_args oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
encode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_args -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_args oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
to_IssueRequestTokenWithAuthScheme_args :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_args
to_IssueRequestTokenWithAuthScheme_args (T.TStruct fields) = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = P.maybe (issueRequestTokenWithAuthScheme_args_channelId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5873) -> (case _val5873 of {T.TString _val5874 -> E.decodeUtf8 _val5874; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestTokenWithAuthScheme_args_otpId = P.maybe (issueRequestTokenWithAuthScheme_args_otpId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5873) -> (case _val5873 of {T.TString _val5875 -> E.decodeUtf8 _val5875; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  issueRequestTokenWithAuthScheme_args_authScheme = P.maybe (issueRequestTokenWithAuthScheme_args_authScheme default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5873) -> (case _val5873 of {T.TList _ _val5876 -> (Vector.fromList $ P.map (\_v5877 -> (case _v5877 of {T.TString _val5878 -> E.decodeUtf8 _val5878; _ -> P.error "wrong type"})) _val5876); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  issueRequestTokenWithAuthScheme_args_returnUrl = P.maybe (issueRequestTokenWithAuthScheme_args_returnUrl default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5873) -> (case _val5873 of {T.TString _val5879 -> E.decodeUtf8 _val5879; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IssueRequestTokenWithAuthScheme_args _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_args
read_IssueRequestTokenWithAuthScheme_args iprot = to_IssueRequestTokenWithAuthScheme_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args)
decode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_args
decode_IssueRequestTokenWithAuthScheme_args iprot bs = to_IssueRequestTokenWithAuthScheme_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args) bs
typemap_IssueRequestTokenWithAuthScheme_args :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING)),(3,("authScheme",(T.T_LIST T.T_STRING))),(4,("returnUrl",T.T_STRING))]
default_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args
default_IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = "",
  issueRequestTokenWithAuthScheme_args_otpId = "",
  issueRequestTokenWithAuthScheme_args_authScheme = Vector.empty,
  issueRequestTokenWithAuthScheme_args_returnUrl = ""}
data IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result  { issueRequestTokenWithAuthScheme_result_success :: RequestTokenResponse
  , issueRequestTokenWithAuthScheme_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_success record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_e record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_result where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj}
    ]
from_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5882 -> (1, ("e",from_ChannelException _v5882))) <$> issueRequestTokenWithAuthScheme_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5882 -> P.Just (0, ("success",from_RequestTokenResponse _v5882))) $ issueRequestTokenWithAuthScheme_result_success record
    , (\_v5882 -> (1, ("e",from_ChannelException _v5882))) <$> issueRequestTokenWithAuthScheme_result_e record
    ]
    )
write_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_result -> P.IO ()
write_IssueRequestTokenWithAuthScheme_result oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
encode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_result -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_result oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
to_IssueRequestTokenWithAuthScheme_result :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_result
to_IssueRequestTokenWithAuthScheme_result (T.TStruct fields) = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = P.maybe (issueRequestTokenWithAuthScheme_result_success default_IssueRequestTokenWithAuthScheme_result) (\(_,_val5884) -> (case _val5884 of {T.TStruct _val5885 -> (to_RequestTokenResponse (T.TStruct _val5885)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestTokenWithAuthScheme_result_e = P.maybe (P.Nothing) (\(_,_val5884) -> P.Just (case _val5884 of {T.TStruct _val5886 -> (to_ChannelException (T.TStruct _val5886)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestTokenWithAuthScheme_result _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_result
read_IssueRequestTokenWithAuthScheme_result iprot = to_IssueRequestTokenWithAuthScheme_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result)
decode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_result
decode_IssueRequestTokenWithAuthScheme_result iprot bs = to_IssueRequestTokenWithAuthScheme_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result) bs
typemap_IssueRequestTokenWithAuthScheme_result :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RequestTokenResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result
default_IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = default_RequestTokenResponse,
  issueRequestTokenWithAuthScheme_result_e = P.Nothing}
data IssueRequestTokenForAutoLogin_args = IssueRequestTokenForAutoLogin_args  { issueRequestTokenForAutoLogin_args_channelId :: LT.Text
  , issueRequestTokenForAutoLogin_args_otpId :: LT.Text
  , issueRequestTokenForAutoLogin_args_redirectUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenForAutoLogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_channelId record   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_otpId record   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_redirectUrl record  
instance QC.Arbitrary IssueRequestTokenForAutoLogin_args where 
  arbitrary = M.liftM IssueRequestTokenForAutoLogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenForAutoLogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_channelId = issueRequestTokenForAutoLogin_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_channelId = issueRequestTokenForAutoLogin_args_channelId obj}
    , if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_otpId = issueRequestTokenForAutoLogin_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_otpId = issueRequestTokenForAutoLogin_args_otpId obj}
    , if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_redirectUrl = issueRequestTokenForAutoLogin_args_redirectUrl obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_redirectUrl = issueRequestTokenForAutoLogin_args_redirectUrl obj}
    ]
from_IssueRequestTokenForAutoLogin_args :: IssueRequestTokenForAutoLogin_args -> T.ThriftVal
from_IssueRequestTokenForAutoLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5889 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5889))) $ issueRequestTokenForAutoLogin_args_channelId record
  , (\_v5889 -> P.Just (3, ("otpId",T.TString $ E.encodeUtf8 _v5889))) $ issueRequestTokenForAutoLogin_args_otpId record
  , (\_v5889 -> P.Just (4, ("redirectUrl",T.TString $ E.encodeUtf8 _v5889))) $ issueRequestTokenForAutoLogin_args_redirectUrl record
  ]
write_IssueRequestTokenForAutoLogin_args :: T.Protocol p => p -> IssueRequestTokenForAutoLogin_args -> P.IO ()
write_IssueRequestTokenForAutoLogin_args oprot record = T.writeVal oprot $ from_IssueRequestTokenForAutoLogin_args record
encode_IssueRequestTokenForAutoLogin_args :: T.StatelessProtocol p => p -> IssueRequestTokenForAutoLogin_args -> LBS.ByteString
encode_IssueRequestTokenForAutoLogin_args oprot record = T.serializeVal oprot $ from_IssueRequestTokenForAutoLogin_args record
to_IssueRequestTokenForAutoLogin_args :: T.ThriftVal -> IssueRequestTokenForAutoLogin_args
to_IssueRequestTokenForAutoLogin_args (T.TStruct fields) = IssueRequestTokenForAutoLogin_args{
  issueRequestTokenForAutoLogin_args_channelId = P.maybe (issueRequestTokenForAutoLogin_args_channelId default_IssueRequestTokenForAutoLogin_args) (\(_,_val5891) -> (case _val5891 of {T.TString _val5892 -> E.decodeUtf8 _val5892; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  issueRequestTokenForAutoLogin_args_otpId = P.maybe (issueRequestTokenForAutoLogin_args_otpId default_IssueRequestTokenForAutoLogin_args) (\(_,_val5891) -> (case _val5891 of {T.TString _val5893 -> E.decodeUtf8 _val5893; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  issueRequestTokenForAutoLogin_args_redirectUrl = P.maybe (issueRequestTokenForAutoLogin_args_redirectUrl default_IssueRequestTokenForAutoLogin_args) (\(_,_val5891) -> (case _val5891 of {T.TString _val5894 -> E.decodeUtf8 _val5894; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IssueRequestTokenForAutoLogin_args _ = P.error "not a struct"
read_IssueRequestTokenForAutoLogin_args :: T.Protocol p => p -> P.IO IssueRequestTokenForAutoLogin_args
read_IssueRequestTokenForAutoLogin_args iprot = to_IssueRequestTokenForAutoLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_args)
decode_IssueRequestTokenForAutoLogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenForAutoLogin_args
decode_IssueRequestTokenForAutoLogin_args iprot bs = to_IssueRequestTokenForAutoLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_args) bs
typemap_IssueRequestTokenForAutoLogin_args :: T.TypeMap
typemap_IssueRequestTokenForAutoLogin_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("otpId",T.T_STRING)),(4,("redirectUrl",T.T_STRING))]
default_IssueRequestTokenForAutoLogin_args :: IssueRequestTokenForAutoLogin_args
default_IssueRequestTokenForAutoLogin_args = IssueRequestTokenForAutoLogin_args{
  issueRequestTokenForAutoLogin_args_channelId = "",
  issueRequestTokenForAutoLogin_args_otpId = "",
  issueRequestTokenForAutoLogin_args_redirectUrl = ""}
data IssueRequestTokenForAutoLogin_result = IssueRequestTokenForAutoLogin_result  { issueRequestTokenForAutoLogin_result_success :: LT.Text
  , issueRequestTokenForAutoLogin_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenForAutoLogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenForAutoLogin_result_success record   `H.hashWithSalt` issueRequestTokenForAutoLogin_result_e record  
instance QC.Arbitrary IssueRequestTokenForAutoLogin_result where 
  arbitrary = M.liftM IssueRequestTokenForAutoLogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenForAutoLogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = issueRequestTokenForAutoLogin_result_success obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = issueRequestTokenForAutoLogin_result_success obj}
    , if obj == default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = issueRequestTokenForAutoLogin_result_e obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = issueRequestTokenForAutoLogin_result_e obj}
    ]
from_IssueRequestTokenForAutoLogin_result :: IssueRequestTokenForAutoLogin_result -> T.ThriftVal
from_IssueRequestTokenForAutoLogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5897 -> (1, ("e",from_ChannelException _v5897))) <$> issueRequestTokenForAutoLogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5897 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5897))) $ issueRequestTokenForAutoLogin_result_success record
    , (\_v5897 -> (1, ("e",from_ChannelException _v5897))) <$> issueRequestTokenForAutoLogin_result_e record
    ]
    )
write_IssueRequestTokenForAutoLogin_result :: T.Protocol p => p -> IssueRequestTokenForAutoLogin_result -> P.IO ()
write_IssueRequestTokenForAutoLogin_result oprot record = T.writeVal oprot $ from_IssueRequestTokenForAutoLogin_result record
encode_IssueRequestTokenForAutoLogin_result :: T.StatelessProtocol p => p -> IssueRequestTokenForAutoLogin_result -> LBS.ByteString
encode_IssueRequestTokenForAutoLogin_result oprot record = T.serializeVal oprot $ from_IssueRequestTokenForAutoLogin_result record
to_IssueRequestTokenForAutoLogin_result :: T.ThriftVal -> IssueRequestTokenForAutoLogin_result
to_IssueRequestTokenForAutoLogin_result (T.TStruct fields) = IssueRequestTokenForAutoLogin_result{
  issueRequestTokenForAutoLogin_result_success = P.maybe (issueRequestTokenForAutoLogin_result_success default_IssueRequestTokenForAutoLogin_result) (\(_,_val5899) -> (case _val5899 of {T.TString _val5900 -> E.decodeUtf8 _val5900; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestTokenForAutoLogin_result_e = P.maybe (P.Nothing) (\(_,_val5899) -> P.Just (case _val5899 of {T.TStruct _val5901 -> (to_ChannelException (T.TStruct _val5901)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestTokenForAutoLogin_result _ = P.error "not a struct"
read_IssueRequestTokenForAutoLogin_result :: T.Protocol p => p -> P.IO IssueRequestTokenForAutoLogin_result
read_IssueRequestTokenForAutoLogin_result iprot = to_IssueRequestTokenForAutoLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_result)
decode_IssueRequestTokenForAutoLogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenForAutoLogin_result
decode_IssueRequestTokenForAutoLogin_result iprot bs = to_IssueRequestTokenForAutoLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_result) bs
typemap_IssueRequestTokenForAutoLogin_result :: T.TypeMap
typemap_IssueRequestTokenForAutoLogin_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestTokenForAutoLogin_result :: IssueRequestTokenForAutoLogin_result
default_IssueRequestTokenForAutoLogin_result = IssueRequestTokenForAutoLogin_result{
  issueRequestTokenForAutoLogin_result_success = "",
  issueRequestTokenForAutoLogin_result_e = P.Nothing}
data GetUpdatedChannelIds_args = GetUpdatedChannelIds_args  { getUpdatedChannelIds_args_channelIds :: (Vector.Vector ChannelIdWithLastUpdated)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUpdatedChannelIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUpdatedChannelIds_args_channelIds record  
instance QC.Arbitrary GetUpdatedChannelIds_args where 
  arbitrary = M.liftM GetUpdatedChannelIds_args (QC.arbitrary)
  shrink obj | obj == default_GetUpdatedChannelIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUpdatedChannelIds_args{getUpdatedChannelIds_args_channelIds = getUpdatedChannelIds_args_channelIds obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_args{getUpdatedChannelIds_args_channelIds = getUpdatedChannelIds_args_channelIds obj}
    ]
from_GetUpdatedChannelIds_args :: GetUpdatedChannelIds_args -> T.ThriftVal
from_GetUpdatedChannelIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5904 -> P.Just (1, ("channelIds",T.TList (T.T_STRUCT typemap_ChannelIdWithLastUpdated) $ P.map (\_v5906 -> from_ChannelIdWithLastUpdated _v5906) $ Vector.toList _v5904))) $ getUpdatedChannelIds_args_channelIds record
  ]
write_GetUpdatedChannelIds_args :: T.Protocol p => p -> GetUpdatedChannelIds_args -> P.IO ()
write_GetUpdatedChannelIds_args oprot record = T.writeVal oprot $ from_GetUpdatedChannelIds_args record
encode_GetUpdatedChannelIds_args :: T.StatelessProtocol p => p -> GetUpdatedChannelIds_args -> LBS.ByteString
encode_GetUpdatedChannelIds_args oprot record = T.serializeVal oprot $ from_GetUpdatedChannelIds_args record
to_GetUpdatedChannelIds_args :: T.ThriftVal -> GetUpdatedChannelIds_args
to_GetUpdatedChannelIds_args (T.TStruct fields) = GetUpdatedChannelIds_args{
  getUpdatedChannelIds_args_channelIds = P.maybe (getUpdatedChannelIds_args_channelIds default_GetUpdatedChannelIds_args) (\(_,_val5908) -> (case _val5908 of {T.TList _ _val5909 -> (Vector.fromList $ P.map (\_v5910 -> (case _v5910 of {T.TStruct _val5911 -> (to_ChannelIdWithLastUpdated (T.TStruct _val5911)); _ -> P.error "wrong type"})) _val5909); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUpdatedChannelIds_args _ = P.error "not a struct"
read_GetUpdatedChannelIds_args :: T.Protocol p => p -> P.IO GetUpdatedChannelIds_args
read_GetUpdatedChannelIds_args iprot = to_GetUpdatedChannelIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_args)
decode_GetUpdatedChannelIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUpdatedChannelIds_args
decode_GetUpdatedChannelIds_args iprot bs = to_GetUpdatedChannelIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_args) bs
typemap_GetUpdatedChannelIds_args :: T.TypeMap
typemap_GetUpdatedChannelIds_args = Map.fromList [(1,("channelIds",(T.T_LIST (T.T_STRUCT typemap_ChannelIdWithLastUpdated))))]
default_GetUpdatedChannelIds_args :: GetUpdatedChannelIds_args
default_GetUpdatedChannelIds_args = GetUpdatedChannelIds_args{
  getUpdatedChannelIds_args_channelIds = Vector.empty}
data GetUpdatedChannelIds_result = GetUpdatedChannelIds_result  { getUpdatedChannelIds_result_success :: (Vector.Vector LT.Text)
  , getUpdatedChannelIds_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUpdatedChannelIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUpdatedChannelIds_result_success record   `H.hashWithSalt` getUpdatedChannelIds_result_e record  
instance QC.Arbitrary GetUpdatedChannelIds_result where 
  arbitrary = M.liftM GetUpdatedChannelIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUpdatedChannelIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = getUpdatedChannelIds_result_success obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = getUpdatedChannelIds_result_success obj}
    , if obj == default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = getUpdatedChannelIds_result_e obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = getUpdatedChannelIds_result_e obj}
    ]
from_GetUpdatedChannelIds_result :: GetUpdatedChannelIds_result -> T.ThriftVal
from_GetUpdatedChannelIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5914 -> (1, ("e",from_ChannelException _v5914))) <$> getUpdatedChannelIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5914 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v5916 -> T.TString $ E.encodeUtf8 _v5916) $ Vector.toList _v5914))) $ getUpdatedChannelIds_result_success record
    , (\_v5914 -> (1, ("e",from_ChannelException _v5914))) <$> getUpdatedChannelIds_result_e record
    ]
    )
write_GetUpdatedChannelIds_result :: T.Protocol p => p -> GetUpdatedChannelIds_result -> P.IO ()
write_GetUpdatedChannelIds_result oprot record = T.writeVal oprot $ from_GetUpdatedChannelIds_result record
encode_GetUpdatedChannelIds_result :: T.StatelessProtocol p => p -> GetUpdatedChannelIds_result -> LBS.ByteString
encode_GetUpdatedChannelIds_result oprot record = T.serializeVal oprot $ from_GetUpdatedChannelIds_result record
to_GetUpdatedChannelIds_result :: T.ThriftVal -> GetUpdatedChannelIds_result
to_GetUpdatedChannelIds_result (T.TStruct fields) = GetUpdatedChannelIds_result{
  getUpdatedChannelIds_result_success = P.maybe (getUpdatedChannelIds_result_success default_GetUpdatedChannelIds_result) (\(_,_val5918) -> (case _val5918 of {T.TList _ _val5919 -> (Vector.fromList $ P.map (\_v5920 -> (case _v5920 of {T.TString _val5921 -> E.decodeUtf8 _val5921; _ -> P.error "wrong type"})) _val5919); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUpdatedChannelIds_result_e = P.maybe (P.Nothing) (\(_,_val5918) -> P.Just (case _val5918 of {T.TStruct _val5922 -> (to_ChannelException (T.TStruct _val5922)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUpdatedChannelIds_result _ = P.error "not a struct"
read_GetUpdatedChannelIds_result :: T.Protocol p => p -> P.IO GetUpdatedChannelIds_result
read_GetUpdatedChannelIds_result iprot = to_GetUpdatedChannelIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_result)
decode_GetUpdatedChannelIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUpdatedChannelIds_result
decode_GetUpdatedChannelIds_result iprot bs = to_GetUpdatedChannelIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_result) bs
typemap_GetUpdatedChannelIds_result :: T.TypeMap
typemap_GetUpdatedChannelIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetUpdatedChannelIds_result :: GetUpdatedChannelIds_result
default_GetUpdatedChannelIds_result = GetUpdatedChannelIds_result{
  getUpdatedChannelIds_result_success = Vector.empty,
  getUpdatedChannelIds_result_e = P.Nothing}
data ReserveCoinUse_args = ReserveCoinUse_args  { reserveCoinUse_args_request :: CoinUseReservation
  , reserveCoinUse_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_args_request record   `H.hashWithSalt` reserveCoinUse_args_locale record  
instance QC.Arbitrary ReserveCoinUse_args where 
  arbitrary = M.liftM ReserveCoinUse_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj}
    , if obj == default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj}
    ]
from_ReserveCoinUse_args :: ReserveCoinUse_args -> T.ThriftVal
from_ReserveCoinUse_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5925 -> P.Just (2, ("request",from_CoinUseReservation _v5925))) $ reserveCoinUse_args_request record
  , (\_v5925 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5925))) $ reserveCoinUse_args_locale record
  ]
write_ReserveCoinUse_args :: T.Protocol p => p -> ReserveCoinUse_args -> P.IO ()
write_ReserveCoinUse_args oprot record = T.writeVal oprot $ from_ReserveCoinUse_args record
encode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> ReserveCoinUse_args -> LBS.ByteString
encode_ReserveCoinUse_args oprot record = T.serializeVal oprot $ from_ReserveCoinUse_args record
to_ReserveCoinUse_args :: T.ThriftVal -> ReserveCoinUse_args
to_ReserveCoinUse_args (T.TStruct fields) = ReserveCoinUse_args{
  reserveCoinUse_args_request = P.maybe (reserveCoinUse_args_request default_ReserveCoinUse_args) (\(_,_val5927) -> (case _val5927 of {T.TStruct _val5928 -> (to_CoinUseReservation (T.TStruct _val5928)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reserveCoinUse_args_locale = P.maybe (reserveCoinUse_args_locale default_ReserveCoinUse_args) (\(_,_val5927) -> (case _val5927 of {T.TString _val5929 -> E.decodeUtf8 _val5929; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReserveCoinUse_args _ = P.error "not a struct"
read_ReserveCoinUse_args :: T.Protocol p => p -> P.IO ReserveCoinUse_args
read_ReserveCoinUse_args iprot = to_ReserveCoinUse_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args)
decode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_args
decode_ReserveCoinUse_args iprot bs = to_ReserveCoinUse_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args) bs
typemap_ReserveCoinUse_args :: T.TypeMap
typemap_ReserveCoinUse_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinUseReservation))),(3,("locale",T.T_STRING))]
default_ReserveCoinUse_args :: ReserveCoinUse_args
default_ReserveCoinUse_args = ReserveCoinUse_args{
  reserveCoinUse_args_request = default_CoinUseReservation,
  reserveCoinUse_args_locale = ""}
data ReserveCoinUse_result = ReserveCoinUse_result  { reserveCoinUse_result_success :: LT.Text
  , reserveCoinUse_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_result_success record   `H.hashWithSalt` reserveCoinUse_result_e record  
instance QC.Arbitrary ReserveCoinUse_result where 
  arbitrary = M.liftM ReserveCoinUse_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj}
    , if obj == default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj}
    ]
from_ReserveCoinUse_result :: ReserveCoinUse_result -> T.ThriftVal
from_ReserveCoinUse_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5932 -> (1, ("e",from_ChannelException _v5932))) <$> reserveCoinUse_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5932 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5932))) $ reserveCoinUse_result_success record
    , (\_v5932 -> (1, ("e",from_ChannelException _v5932))) <$> reserveCoinUse_result_e record
    ]
    )
write_ReserveCoinUse_result :: T.Protocol p => p -> ReserveCoinUse_result -> P.IO ()
write_ReserveCoinUse_result oprot record = T.writeVal oprot $ from_ReserveCoinUse_result record
encode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> ReserveCoinUse_result -> LBS.ByteString
encode_ReserveCoinUse_result oprot record = T.serializeVal oprot $ from_ReserveCoinUse_result record
to_ReserveCoinUse_result :: T.ThriftVal -> ReserveCoinUse_result
to_ReserveCoinUse_result (T.TStruct fields) = ReserveCoinUse_result{
  reserveCoinUse_result_success = P.maybe (reserveCoinUse_result_success default_ReserveCoinUse_result) (\(_,_val5934) -> (case _val5934 of {T.TString _val5935 -> E.decodeUtf8 _val5935; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCoinUse_result_e = P.maybe (P.Nothing) (\(_,_val5934) -> P.Just (case _val5934 of {T.TStruct _val5936 -> (to_ChannelException (T.TStruct _val5936)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCoinUse_result _ = P.error "not a struct"
read_ReserveCoinUse_result :: T.Protocol p => p -> P.IO ReserveCoinUse_result
read_ReserveCoinUse_result iprot = to_ReserveCoinUse_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result)
decode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_result
decode_ReserveCoinUse_result iprot bs = to_ReserveCoinUse_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result) bs
typemap_ReserveCoinUse_result :: T.TypeMap
typemap_ReserveCoinUse_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ReserveCoinUse_result :: ReserveCoinUse_result
default_ReserveCoinUse_result = ReserveCoinUse_result{
  reserveCoinUse_result_success = "",
  reserveCoinUse_result_e = P.Nothing}
data RevokeChannel_args = RevokeChannel_args  { revokeChannel_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_args_channelId record  
instance QC.Arbitrary RevokeChannel_args where 
  arbitrary = M.liftM RevokeChannel_args (QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj} then P.Nothing else P.Just $ default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj}
    ]
from_RevokeChannel_args :: RevokeChannel_args -> T.ThriftVal
from_RevokeChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5939 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5939))) $ revokeChannel_args_channelId record
  ]
write_RevokeChannel_args :: T.Protocol p => p -> RevokeChannel_args -> P.IO ()
write_RevokeChannel_args oprot record = T.writeVal oprot $ from_RevokeChannel_args record
encode_RevokeChannel_args :: T.StatelessProtocol p => p -> RevokeChannel_args -> LBS.ByteString
encode_RevokeChannel_args oprot record = T.serializeVal oprot $ from_RevokeChannel_args record
to_RevokeChannel_args :: T.ThriftVal -> RevokeChannel_args
to_RevokeChannel_args (T.TStruct fields) = RevokeChannel_args{
  revokeChannel_args_channelId = P.maybe (revokeChannel_args_channelId default_RevokeChannel_args) (\(_,_val5941) -> (case _val5941 of {T.TString _val5942 -> E.decodeUtf8 _val5942; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_args _ = P.error "not a struct"
read_RevokeChannel_args :: T.Protocol p => p -> P.IO RevokeChannel_args
read_RevokeChannel_args iprot = to_RevokeChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_args)
decode_RevokeChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_args
decode_RevokeChannel_args iprot bs = to_RevokeChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_args) bs
typemap_RevokeChannel_args :: T.TypeMap
typemap_RevokeChannel_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_RevokeChannel_args :: RevokeChannel_args
default_RevokeChannel_args = RevokeChannel_args{
  revokeChannel_args_channelId = ""}
data RevokeChannel_result = RevokeChannel_result  { revokeChannel_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_result_e record  
instance QC.Arbitrary RevokeChannel_result where 
  arbitrary = M.liftM RevokeChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj} then P.Nothing else P.Just $ default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj}
    ]
from_RevokeChannel_result :: RevokeChannel_result -> T.ThriftVal
from_RevokeChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5945 -> (1, ("e",from_ChannelException _v5945))) <$> revokeChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5945 -> (1, ("e",from_ChannelException _v5945))) <$> revokeChannel_result_e record
    ]
    )
write_RevokeChannel_result :: T.Protocol p => p -> RevokeChannel_result -> P.IO ()
write_RevokeChannel_result oprot record = T.writeVal oprot $ from_RevokeChannel_result record
encode_RevokeChannel_result :: T.StatelessProtocol p => p -> RevokeChannel_result -> LBS.ByteString
encode_RevokeChannel_result oprot record = T.serializeVal oprot $ from_RevokeChannel_result record
to_RevokeChannel_result :: T.ThriftVal -> RevokeChannel_result
to_RevokeChannel_result (T.TStruct fields) = RevokeChannel_result{
  revokeChannel_result_e = P.maybe (P.Nothing) (\(_,_val5947) -> P.Just (case _val5947 of {T.TStruct _val5948 -> (to_ChannelException (T.TStruct _val5948)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_result _ = P.error "not a struct"
read_RevokeChannel_result :: T.Protocol p => p -> P.IO RevokeChannel_result
read_RevokeChannel_result iprot = to_RevokeChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_result)
decode_RevokeChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_result
decode_RevokeChannel_result iprot bs = to_RevokeChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_result) bs
typemap_RevokeChannel_result :: T.TypeMap
typemap_RevokeChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_RevokeChannel_result :: RevokeChannel_result
default_RevokeChannel_result = RevokeChannel_result{
  revokeChannel_result_e = P.Nothing}
data SyncChannelData_args = SyncChannelData_args  { syncChannelData_args_lastSynced :: I.Int64
  , syncChannelData_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_args_lastSynced record   `H.hashWithSalt` syncChannelData_args_locale record  
instance QC.Arbitrary SyncChannelData_args where 
  arbitrary = M.liftM SyncChannelData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj}
    , if obj == default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj}
    ]
from_SyncChannelData_args :: SyncChannelData_args -> T.ThriftVal
from_SyncChannelData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5951 -> P.Just (2, ("lastSynced",T.TI64 _v5951))) $ syncChannelData_args_lastSynced record
  , (\_v5951 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5951))) $ syncChannelData_args_locale record
  ]
write_SyncChannelData_args :: T.Protocol p => p -> SyncChannelData_args -> P.IO ()
write_SyncChannelData_args oprot record = T.writeVal oprot $ from_SyncChannelData_args record
encode_SyncChannelData_args :: T.StatelessProtocol p => p -> SyncChannelData_args -> LBS.ByteString
encode_SyncChannelData_args oprot record = T.serializeVal oprot $ from_SyncChannelData_args record
to_SyncChannelData_args :: T.ThriftVal -> SyncChannelData_args
to_SyncChannelData_args (T.TStruct fields) = SyncChannelData_args{
  syncChannelData_args_lastSynced = P.maybe (syncChannelData_args_lastSynced default_SyncChannelData_args) (\(_,_val5953) -> (case _val5953 of {T.TI64 _val5954 -> _val5954; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncChannelData_args_locale = P.maybe (syncChannelData_args_locale default_SyncChannelData_args) (\(_,_val5953) -> (case _val5953 of {T.TString _val5955 -> E.decodeUtf8 _val5955; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SyncChannelData_args _ = P.error "not a struct"
read_SyncChannelData_args :: T.Protocol p => p -> P.IO SyncChannelData_args
read_SyncChannelData_args iprot = to_SyncChannelData_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_args)
decode_SyncChannelData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_args
decode_SyncChannelData_args iprot bs = to_SyncChannelData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_args) bs
typemap_SyncChannelData_args :: T.TypeMap
typemap_SyncChannelData_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_SyncChannelData_args :: SyncChannelData_args
default_SyncChannelData_args = SyncChannelData_args{
  syncChannelData_args_lastSynced = 0,
  syncChannelData_args_locale = ""}
data SyncChannelData_result = SyncChannelData_result  { syncChannelData_result_success :: ChannelSyncDatas
  , syncChannelData_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_result_success record   `H.hashWithSalt` syncChannelData_result_e record  
instance QC.Arbitrary SyncChannelData_result where 
  arbitrary = M.liftM SyncChannelData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj}
    , if obj == default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj}
    ]
from_SyncChannelData_result :: SyncChannelData_result -> T.ThriftVal
from_SyncChannelData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5958 -> (1, ("e",from_ChannelException _v5958))) <$> syncChannelData_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5958 -> P.Just (0, ("success",from_ChannelSyncDatas _v5958))) $ syncChannelData_result_success record
    , (\_v5958 -> (1, ("e",from_ChannelException _v5958))) <$> syncChannelData_result_e record
    ]
    )
write_SyncChannelData_result :: T.Protocol p => p -> SyncChannelData_result -> P.IO ()
write_SyncChannelData_result oprot record = T.writeVal oprot $ from_SyncChannelData_result record
encode_SyncChannelData_result :: T.StatelessProtocol p => p -> SyncChannelData_result -> LBS.ByteString
encode_SyncChannelData_result oprot record = T.serializeVal oprot $ from_SyncChannelData_result record
to_SyncChannelData_result :: T.ThriftVal -> SyncChannelData_result
to_SyncChannelData_result (T.TStruct fields) = SyncChannelData_result{
  syncChannelData_result_success = P.maybe (syncChannelData_result_success default_SyncChannelData_result) (\(_,_val5960) -> (case _val5960 of {T.TStruct _val5961 -> (to_ChannelSyncDatas (T.TStruct _val5961)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncChannelData_result_e = P.maybe (P.Nothing) (\(_,_val5960) -> P.Just (case _val5960 of {T.TStruct _val5962 -> (to_ChannelException (T.TStruct _val5962)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncChannelData_result _ = P.error "not a struct"
read_SyncChannelData_result :: T.Protocol p => p -> P.IO SyncChannelData_result
read_SyncChannelData_result iprot = to_SyncChannelData_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_result)
decode_SyncChannelData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_result
decode_SyncChannelData_result iprot bs = to_SyncChannelData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_result) bs
typemap_SyncChannelData_result :: T.TypeMap
typemap_SyncChannelData_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelSyncDatas))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_SyncChannelData_result :: SyncChannelData_result
default_SyncChannelData_result = SyncChannelData_result{
  syncChannelData_result_success = default_ChannelSyncDatas,
  syncChannelData_result_e = P.Nothing}
data UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args  { updateChannelNotificationSetting_args_setting :: (Vector.Vector ChannelNotificationSetting)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_args_setting record  
instance QC.Arbitrary UpdateChannelNotificationSetting_args where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_args (QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj}
    ]
from_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args -> T.ThriftVal
from_UpdateChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5965 -> P.Just (1, ("setting",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v5967 -> from_ChannelNotificationSetting _v5967) $ Vector.toList _v5965))) $ updateChannelNotificationSetting_args_setting record
  ]
write_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> UpdateChannelNotificationSetting_args -> P.IO ()
write_UpdateChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_args record
encode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_args -> LBS.ByteString
encode_UpdateChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_args record
to_UpdateChannelNotificationSetting_args :: T.ThriftVal -> UpdateChannelNotificationSetting_args
to_UpdateChannelNotificationSetting_args (T.TStruct fields) = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = P.maybe (updateChannelNotificationSetting_args_setting default_UpdateChannelNotificationSetting_args) (\(_,_val5969) -> (case _val5969 of {T.TList _ _val5970 -> (Vector.fromList $ P.map (\_v5971 -> (case _v5971 of {T.TStruct _val5972 -> (to_ChannelNotificationSetting (T.TStruct _val5972)); _ -> P.error "wrong type"})) _val5970); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_args _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_args
read_UpdateChannelNotificationSetting_args iprot = to_UpdateChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args)
decode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_args
decode_UpdateChannelNotificationSetting_args iprot bs = to_UpdateChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args) bs
typemap_UpdateChannelNotificationSetting_args :: T.TypeMap
typemap_UpdateChannelNotificationSetting_args = Map.fromList [(1,("setting",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting))))]
default_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args
default_UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = Vector.empty}
data UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result  { updateChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_result_e record  
instance QC.Arbitrary UpdateChannelNotificationSetting_result where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj}
    ]
from_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result -> T.ThriftVal
from_UpdateChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5975 -> (1, ("e",from_ChannelException _v5975))) <$> updateChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5975 -> (1, ("e",from_ChannelException _v5975))) <$> updateChannelNotificationSetting_result_e record
    ]
    )
write_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> UpdateChannelNotificationSetting_result -> P.IO ()
write_UpdateChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_result record
encode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_result -> LBS.ByteString
encode_UpdateChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_result record
to_UpdateChannelNotificationSetting_result :: T.ThriftVal -> UpdateChannelNotificationSetting_result
to_UpdateChannelNotificationSetting_result (T.TStruct fields) = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val5977) -> P.Just (case _val5977 of {T.TStruct _val5978 -> (to_ChannelException (T.TStruct _val5978)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_result _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_result
read_UpdateChannelNotificationSetting_result iprot = to_UpdateChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result)
decode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_result
decode_UpdateChannelNotificationSetting_result iprot bs = to_UpdateChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result) bs
typemap_UpdateChannelNotificationSetting_result :: T.TypeMap
typemap_UpdateChannelNotificationSetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result
default_UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.Nothing}
process_issueOTP (seqid, iprot, oprot, handler) = do
  args <- read_IssueOTP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueOTP handler (issueOTP_args_channelId args)
        let res = default_IssueOTP_result{issueOTP_result_success = val}
        T.writeMessage oprot ("issueOTP", T.M_REPLY, seqid) $
          write_IssueOTP_result oprot res)
      (\e  -> do
        let res = default_IssueOTP_result{issueOTP_result_e = P.Just e}
        T.writeMessage oprot ("issueOTP", T.M_REPLY, seqid) $
          write_IssueOTP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueOTP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveChannelAndIssueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueChannelToken handler (approveChannelAndIssueChannelToken_args_channelId args)
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveChannelAndIssueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueRequestToken handler (approveChannelAndIssueRequestToken_args_channelId args) (approveChannelAndIssueRequestToken_args_otpId args)
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchNotificationItems (seqid, iprot, oprot, handler) = do
  args <- read_FetchNotificationItems_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchNotificationItems handler (fetchNotificationItems_args_localRev args)
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_success = val}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res)
      (\e  -> do
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_e = P.Just e}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchNotificationItems", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getApprovedChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetApprovedChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getApprovedChannels handler (getApprovedChannels_args_lastSynced args) (getApprovedChannels_args_locale args)
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_success = val}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res)
      (\e  -> do
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_e = P.Just e}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getApprovedChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelInfo handler (getChannelInfo_args_channelId args) (getChannelInfo_args_locale args)
        let res = default_GetChannelInfo_result{getChannelInfo_result_success = val}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res)
      (\e  -> do
        let res = default_GetChannelInfo_result{getChannelInfo_result_e = P.Just e}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSetting handler (getChannelNotificationSetting_args_channelId args) (getChannelNotificationSetting_args_locale args)
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSettings (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSettings handler (getChannelNotificationSettings_args_locale args)
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannels handler (getChannels_args_lastSynced args) (getChannels_args_locale args)
        let res = default_GetChannels_result{getChannels_result_success = val}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res)
      (\e  -> do
        let res = default_GetChannels_result{getChannels_result_e = P.Just e}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDomains (seqid, iprot, oprot, handler) = do
  args <- read_GetDomains_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDomains handler (getDomains_args_lastSynced args)
        let res = default_GetDomains_result{getDomains_result_success = val}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res)
      (\e  -> do
        let res = default_GetDomains_result{getDomains_result_e = P.Just e}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDomains", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendChannelMatrices (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendChannelMatrices_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendChannelMatrices handler (getFriendChannelMatrices_args_channelIds args)
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = val}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res)
      (\e  -> do
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = P.Just e}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendChannelMatrices", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateChannelSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateChannelSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateChannelSettings handler (updateChannelSettings_args_channelSettings args)
        let res = default_UpdateChannelSettings_result{updateChannelSettings_result_success = val}
        T.writeMessage oprot ("updateChannelSettings", T.M_REPLY, seqid) $
          write_UpdateChannelSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateChannelSettings_result{updateChannelSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateChannelSettings", T.M_REPLY, seqid) $
          write_UpdateChannelSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateChannelSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCommonDomains (seqid, iprot, oprot, handler) = do
  args <- read_GetCommonDomains_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCommonDomains handler (getCommonDomains_args_lastSynced args)
        let res = default_GetCommonDomains_result{getCommonDomains_result_success = val}
        T.writeMessage oprot ("getCommonDomains", T.M_REPLY, seqid) $
          write_GetCommonDomains_result oprot res)
      (\e  -> do
        let res = default_GetCommonDomains_result{getCommonDomains_result_e = P.Just e}
        T.writeMessage oprot ("getCommonDomains", T.M_REPLY, seqid) $
          write_GetCommonDomains_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCommonDomains", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotificationBadgeCount (seqid, iprot, oprot, handler) = do
  args <- read_GetNotificationBadgeCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNotificationBadgeCount handler (getNotificationBadgeCount_args_localRev args)
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = val}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res)
      (\e  -> do
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = P.Just e}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotificationBadgeCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueChannelToken handler (issueChannelToken_args_channelId args)
        let res = default_IssueChannelToken_result{issueChannelToken_result_success = val}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_IssueChannelToken_result{issueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestToken handler (issueRequestToken_args_channelId args) (issueRequestToken_args_otpId args)
        let res = default_IssueRequestToken_result{issueRequestToken_result_success = val}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_IssueRequestToken_result{issueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestTokenWithAuthScheme (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestTokenWithAuthScheme_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestTokenWithAuthScheme handler (issueRequestTokenWithAuthScheme_args_channelId args) (issueRequestTokenWithAuthScheme_args_otpId args) (issueRequestTokenWithAuthScheme_args_authScheme args) (issueRequestTokenWithAuthScheme_args_returnUrl args)
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = val}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res)
      (\e  -> do
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestTokenForAutoLogin (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestTokenForAutoLogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestTokenForAutoLogin handler (issueRequestTokenForAutoLogin_args_channelId args) (issueRequestTokenForAutoLogin_args_otpId args) (issueRequestTokenForAutoLogin_args_redirectUrl args)
        let res = default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = val}
        T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_REPLY, seqid) $
          write_IssueRequestTokenForAutoLogin_result oprot res)
      (\e  -> do
        let res = default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_REPLY, seqid) $
          write_IssueRequestTokenForAutoLogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUpdatedChannelIds (seqid, iprot, oprot, handler) = do
  args <- read_GetUpdatedChannelIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUpdatedChannelIds handler (getUpdatedChannelIds_args_channelIds args)
        let res = default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = val}
        T.writeMessage oprot ("getUpdatedChannelIds", T.M_REPLY, seqid) $
          write_GetUpdatedChannelIds_result oprot res)
      (\e  -> do
        let res = default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = P.Just e}
        T.writeMessage oprot ("getUpdatedChannelIds", T.M_REPLY, seqid) $
          write_GetUpdatedChannelIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUpdatedChannelIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCoinUse (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCoinUse_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCoinUse handler (reserveCoinUse_args_request args) (reserveCoinUse_args_locale args)
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_success = val}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res)
      (\e  -> do
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_e = P.Just e}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCoinUse", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_revokeChannel (seqid, iprot, oprot, handler) = do
  args <- read_RevokeChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.revokeChannel handler (revokeChannel_args_channelId args)
        let res = default_RevokeChannel_result
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res)
      (\e  -> do
        let res = default_RevokeChannel_result{revokeChannel_result_e = P.Just e}
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("revokeChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncChannelData (seqid, iprot, oprot, handler) = do
  args <- read_SyncChannelData_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncChannelData handler (syncChannelData_args_lastSynced args) (syncChannelData_args_locale args)
        let res = default_SyncChannelData_result{syncChannelData_result_success = val}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res)
      (\e  -> do
        let res = default_SyncChannelData_result{syncChannelData_result_e = P.Just e}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncChannelData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateChannelNotificationSetting handler (updateChannelNotificationSetting_args_setting args)
        let res = default_UpdateChannelNotificationSetting_result
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "issueOTP" -> process_issueOTP (seqid,iprot,oprot,handler)
  "approveChannelAndIssueChannelToken" -> process_approveChannelAndIssueChannelToken (seqid,iprot,oprot,handler)
  "approveChannelAndIssueRequestToken" -> process_approveChannelAndIssueRequestToken (seqid,iprot,oprot,handler)
  "fetchNotificationItems" -> process_fetchNotificationItems (seqid,iprot,oprot,handler)
  "getApprovedChannels" -> process_getApprovedChannels (seqid,iprot,oprot,handler)
  "getChannelInfo" -> process_getChannelInfo (seqid,iprot,oprot,handler)
  "getChannelNotificationSetting" -> process_getChannelNotificationSetting (seqid,iprot,oprot,handler)
  "getChannelNotificationSettings" -> process_getChannelNotificationSettings (seqid,iprot,oprot,handler)
  "getChannels" -> process_getChannels (seqid,iprot,oprot,handler)
  "getDomains" -> process_getDomains (seqid,iprot,oprot,handler)
  "getFriendChannelMatrices" -> process_getFriendChannelMatrices (seqid,iprot,oprot,handler)
  "updateChannelSettings" -> process_updateChannelSettings (seqid,iprot,oprot,handler)
  "getCommonDomains" -> process_getCommonDomains (seqid,iprot,oprot,handler)
  "getNotificationBadgeCount" -> process_getNotificationBadgeCount (seqid,iprot,oprot,handler)
  "issueChannelToken" -> process_issueChannelToken (seqid,iprot,oprot,handler)
  "issueRequestToken" -> process_issueRequestToken (seqid,iprot,oprot,handler)
  "issueRequestTokenWithAuthScheme" -> process_issueRequestTokenWithAuthScheme (seqid,iprot,oprot,handler)
  "issueRequestTokenForAutoLogin" -> process_issueRequestTokenForAutoLogin (seqid,iprot,oprot,handler)
  "getUpdatedChannelIds" -> process_getUpdatedChannelIds (seqid,iprot,oprot,handler)
  "reserveCoinUse" -> process_reserveCoinUse (seqid,iprot,oprot,handler)
  "revokeChannel" -> process_revokeChannel (seqid,iprot,oprot,handler)
  "syncChannelData" -> process_syncChannelData (seqid,iprot,oprot,handler)
  "updateChannelNotificationSetting" -> process_updateChannelNotificationSetting (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
