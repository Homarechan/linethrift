{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ChannelService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ChannelService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data IssueOTP_args = IssueOTP_args  { issueOTP_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueOTP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueOTP_args_channelId record  
instance QC.Arbitrary IssueOTP_args where 
  arbitrary = M.liftM IssueOTP_args (QC.arbitrary)
  shrink obj | obj == default_IssueOTP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueOTP_args{issueOTP_args_channelId = issueOTP_args_channelId obj} then P.Nothing else P.Just $ default_IssueOTP_args{issueOTP_args_channelId = issueOTP_args_channelId obj}
    ]
from_IssueOTP_args :: IssueOTP_args -> T.ThriftVal
from_IssueOTP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5124 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5124))) $ issueOTP_args_channelId record
  ]
write_IssueOTP_args :: T.Protocol p => p -> IssueOTP_args -> P.IO ()
write_IssueOTP_args oprot record = T.writeVal oprot $ from_IssueOTP_args record
encode_IssueOTP_args :: T.StatelessProtocol p => p -> IssueOTP_args -> LBS.ByteString
encode_IssueOTP_args oprot record = T.serializeVal oprot $ from_IssueOTP_args record
to_IssueOTP_args :: T.ThriftVal -> IssueOTP_args
to_IssueOTP_args (T.TStruct fields) = IssueOTP_args{
  issueOTP_args_channelId = P.maybe (issueOTP_args_channelId default_IssueOTP_args) (\(_,_val5126) -> (case _val5126 of {T.TString _val5127 -> E.decodeUtf8 _val5127; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueOTP_args _ = P.error "not a struct"
read_IssueOTP_args :: T.Protocol p => p -> P.IO IssueOTP_args
read_IssueOTP_args iprot = to_IssueOTP_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueOTP_args)
decode_IssueOTP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueOTP_args
decode_IssueOTP_args iprot bs = to_IssueOTP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueOTP_args) bs
typemap_IssueOTP_args :: T.TypeMap
typemap_IssueOTP_args = Map.fromList [(2,("channelId",T.T_STRING))]
default_IssueOTP_args :: IssueOTP_args
default_IssueOTP_args = IssueOTP_args{
  issueOTP_args_channelId = ""}
data IssueOTP_result = IssueOTP_result  { issueOTP_result_success :: OTPResult
  , issueOTP_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueOTP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueOTP_result_success record   `H.hashWithSalt` issueOTP_result_e record  
instance QC.Arbitrary IssueOTP_result where 
  arbitrary = M.liftM IssueOTP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueOTP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueOTP_result{issueOTP_result_success = issueOTP_result_success obj} then P.Nothing else P.Just $ default_IssueOTP_result{issueOTP_result_success = issueOTP_result_success obj}
    , if obj == default_IssueOTP_result{issueOTP_result_e = issueOTP_result_e obj} then P.Nothing else P.Just $ default_IssueOTP_result{issueOTP_result_e = issueOTP_result_e obj}
    ]
from_IssueOTP_result :: IssueOTP_result -> T.ThriftVal
from_IssueOTP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5130 -> (1, ("e",from_ChannelException _v5130))) <$> issueOTP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5130 -> P.Just (0, ("success",from_OTPResult _v5130))) $ issueOTP_result_success record
    , (\_v5130 -> (1, ("e",from_ChannelException _v5130))) <$> issueOTP_result_e record
    ]
    )
write_IssueOTP_result :: T.Protocol p => p -> IssueOTP_result -> P.IO ()
write_IssueOTP_result oprot record = T.writeVal oprot $ from_IssueOTP_result record
encode_IssueOTP_result :: T.StatelessProtocol p => p -> IssueOTP_result -> LBS.ByteString
encode_IssueOTP_result oprot record = T.serializeVal oprot $ from_IssueOTP_result record
to_IssueOTP_result :: T.ThriftVal -> IssueOTP_result
to_IssueOTP_result (T.TStruct fields) = IssueOTP_result{
  issueOTP_result_success = P.maybe (issueOTP_result_success default_IssueOTP_result) (\(_,_val5132) -> (case _val5132 of {T.TStruct _val5133 -> (to_OTPResult (T.TStruct _val5133)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueOTP_result_e = P.maybe (P.Nothing) (\(_,_val5132) -> P.Just (case _val5132 of {T.TStruct _val5134 -> (to_ChannelException (T.TStruct _val5134)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueOTP_result _ = P.error "not a struct"
read_IssueOTP_result :: T.Protocol p => p -> P.IO IssueOTP_result
read_IssueOTP_result iprot = to_IssueOTP_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueOTP_result)
decode_IssueOTP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueOTP_result
decode_IssueOTP_result iprot bs = to_IssueOTP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueOTP_result) bs
typemap_IssueOTP_result :: T.TypeMap
typemap_IssueOTP_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_OTPResult))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueOTP_result :: IssueOTP_result
default_IssueOTP_result = IssueOTP_result{
  issueOTP_result_success = default_OTPResult,
  issueOTP_result_e = P.Nothing}
data ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args  { approveChannelAndIssueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_args_channelId record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_args{approveChannelAndIssueChannelToken_args_channelId = approveChannelAndIssueChannelToken_args_channelId obj}
    ]
from_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5137 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5137))) $ approveChannelAndIssueChannelToken_args_channelId record
  ]
write_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_args -> P.IO ()
write_ApproveChannelAndIssueChannelToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
encode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_args record
to_ApproveChannelAndIssueChannelToken_args :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_args
to_ApproveChannelAndIssueChannelToken_args (T.TStruct fields) = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = P.maybe (approveChannelAndIssueChannelToken_args_channelId default_ApproveChannelAndIssueChannelToken_args) (\(_,_val5139) -> (case _val5139 of {T.TString _val5140 -> E.decodeUtf8 _val5140; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_args
read_ApproveChannelAndIssueChannelToken_args iprot = to_ApproveChannelAndIssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args)
decode_ApproveChannelAndIssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_args
decode_ApproveChannelAndIssueChannelToken_args iprot bs = to_ApproveChannelAndIssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_args) bs
typemap_ApproveChannelAndIssueChannelToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_ApproveChannelAndIssueChannelToken_args :: ApproveChannelAndIssueChannelToken_args
default_ApproveChannelAndIssueChannelToken_args = ApproveChannelAndIssueChannelToken_args{
  approveChannelAndIssueChannelToken_args_channelId = ""}
data ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result  { approveChannelAndIssueChannelToken_result_success :: ChannelToken
  , approveChannelAndIssueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_success record   `H.hashWithSalt` approveChannelAndIssueChannelToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueChannelToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = approveChannelAndIssueChannelToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = approveChannelAndIssueChannelToken_result_e obj}
    ]
from_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result -> T.ThriftVal
from_ApproveChannelAndIssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5143 -> (1, ("e",from_ChannelException _v5143))) <$> approveChannelAndIssueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5143 -> P.Just (0, ("success",from_ChannelToken _v5143))) $ approveChannelAndIssueChannelToken_result_success record
    , (\_v5143 -> (1, ("e",from_ChannelException _v5143))) <$> approveChannelAndIssueChannelToken_result_e record
    ]
    )
write_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> ApproveChannelAndIssueChannelToken_result -> P.IO ()
write_ApproveChannelAndIssueChannelToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
encode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueChannelToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueChannelToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueChannelToken_result record
to_ApproveChannelAndIssueChannelToken_result :: T.ThriftVal -> ApproveChannelAndIssueChannelToken_result
to_ApproveChannelAndIssueChannelToken_result (T.TStruct fields) = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = P.maybe (approveChannelAndIssueChannelToken_result_success default_ApproveChannelAndIssueChannelToken_result) (\(_,_val5145) -> (case _val5145 of {T.TStruct _val5146 -> (to_ChannelToken (T.TStruct _val5146)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val5145) -> P.Just (case _val5145 of {T.TStruct _val5147 -> (to_ChannelException (T.TStruct _val5147)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueChannelToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueChannelToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueChannelToken_result
read_ApproveChannelAndIssueChannelToken_result iprot = to_ApproveChannelAndIssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result)
decode_ApproveChannelAndIssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueChannelToken_result
decode_ApproveChannelAndIssueChannelToken_result iprot bs = to_ApproveChannelAndIssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueChannelToken_result) bs
typemap_ApproveChannelAndIssueChannelToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueChannelToken_result :: ApproveChannelAndIssueChannelToken_result
default_ApproveChannelAndIssueChannelToken_result = ApproveChannelAndIssueChannelToken_result{
  approveChannelAndIssueChannelToken_result_success = default_ChannelToken,
  approveChannelAndIssueChannelToken_result_e = P.Nothing}
data ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args  { approveChannelAndIssueRequestToken_args_channelId :: LT.Text
  , approveChannelAndIssueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_channelId record   `H.hashWithSalt` approveChannelAndIssueRequestToken_args_otpId record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_args where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_channelId = approveChannelAndIssueRequestToken_args_channelId obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_args{approveChannelAndIssueRequestToken_args_otpId = approveChannelAndIssueRequestToken_args_otpId obj}
    ]
from_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5150 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5150))) $ approveChannelAndIssueRequestToken_args_channelId record
  , (\_v5150 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5150))) $ approveChannelAndIssueRequestToken_args_otpId record
  ]
write_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_args -> P.IO ()
write_ApproveChannelAndIssueRequestToken_args oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
encode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_args -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_args oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_args record
to_ApproveChannelAndIssueRequestToken_args :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_args
to_ApproveChannelAndIssueRequestToken_args (T.TStruct fields) = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = P.maybe (approveChannelAndIssueRequestToken_args_channelId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val5152) -> (case _val5152 of {T.TString _val5153 -> E.decodeUtf8 _val5153; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approveChannelAndIssueRequestToken_args_otpId = P.maybe (approveChannelAndIssueRequestToken_args_otpId default_ApproveChannelAndIssueRequestToken_args) (\(_,_val5152) -> (case _val5152 of {T.TString _val5154 -> E.decodeUtf8 _val5154; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApproveChannelAndIssueRequestToken_args _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_args :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_args
read_ApproveChannelAndIssueRequestToken_args iprot = to_ApproveChannelAndIssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args)
decode_ApproveChannelAndIssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_args
decode_ApproveChannelAndIssueRequestToken_args iprot bs = to_ApproveChannelAndIssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_args) bs
typemap_ApproveChannelAndIssueRequestToken_args :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_ApproveChannelAndIssueRequestToken_args :: ApproveChannelAndIssueRequestToken_args
default_ApproveChannelAndIssueRequestToken_args = ApproveChannelAndIssueRequestToken_args{
  approveChannelAndIssueRequestToken_args_channelId = "",
  approveChannelAndIssueRequestToken_args_otpId = ""}
data ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result  { approveChannelAndIssueRequestToken_result_success :: LT.Text
  , approveChannelAndIssueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveChannelAndIssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_success record   `H.hashWithSalt` approveChannelAndIssueRequestToken_result_e record  
instance QC.Arbitrary ApproveChannelAndIssueRequestToken_result where 
  arbitrary = M.liftM ApproveChannelAndIssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveChannelAndIssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = approveChannelAndIssueRequestToken_result_success obj}
    , if obj == default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj} then P.Nothing else P.Just $ default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = approveChannelAndIssueRequestToken_result_e obj}
    ]
from_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result -> T.ThriftVal
from_ApproveChannelAndIssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5157 -> (1, ("e",from_ChannelException _v5157))) <$> approveChannelAndIssueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5157 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5157))) $ approveChannelAndIssueRequestToken_result_success record
    , (\_v5157 -> (1, ("e",from_ChannelException _v5157))) <$> approveChannelAndIssueRequestToken_result_e record
    ]
    )
write_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> ApproveChannelAndIssueRequestToken_result -> P.IO ()
write_ApproveChannelAndIssueRequestToken_result oprot record = T.writeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
encode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> ApproveChannelAndIssueRequestToken_result -> LBS.ByteString
encode_ApproveChannelAndIssueRequestToken_result oprot record = T.serializeVal oprot $ from_ApproveChannelAndIssueRequestToken_result record
to_ApproveChannelAndIssueRequestToken_result :: T.ThriftVal -> ApproveChannelAndIssueRequestToken_result
to_ApproveChannelAndIssueRequestToken_result (T.TStruct fields) = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = P.maybe (approveChannelAndIssueRequestToken_result_success default_ApproveChannelAndIssueRequestToken_result) (\(_,_val5159) -> (case _val5159 of {T.TString _val5160 -> E.decodeUtf8 _val5160; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveChannelAndIssueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val5159) -> P.Just (case _val5159 of {T.TStruct _val5161 -> (to_ChannelException (T.TStruct _val5161)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveChannelAndIssueRequestToken_result _ = P.error "not a struct"
read_ApproveChannelAndIssueRequestToken_result :: T.Protocol p => p -> P.IO ApproveChannelAndIssueRequestToken_result
read_ApproveChannelAndIssueRequestToken_result iprot = to_ApproveChannelAndIssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result)
decode_ApproveChannelAndIssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveChannelAndIssueRequestToken_result
decode_ApproveChannelAndIssueRequestToken_result iprot bs = to_ApproveChannelAndIssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveChannelAndIssueRequestToken_result) bs
typemap_ApproveChannelAndIssueRequestToken_result :: T.TypeMap
typemap_ApproveChannelAndIssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ApproveChannelAndIssueRequestToken_result :: ApproveChannelAndIssueRequestToken_result
default_ApproveChannelAndIssueRequestToken_result = ApproveChannelAndIssueRequestToken_result{
  approveChannelAndIssueRequestToken_result_success = "",
  approveChannelAndIssueRequestToken_result_e = P.Nothing}
data FetchNotificationItems_args = FetchNotificationItems_args  { fetchNotificationItems_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_args_localRev record  
instance QC.Arbitrary FetchNotificationItems_args where 
  arbitrary = M.liftM FetchNotificationItems_args (QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj} then P.Nothing else P.Just $ default_FetchNotificationItems_args{fetchNotificationItems_args_localRev = fetchNotificationItems_args_localRev obj}
    ]
from_FetchNotificationItems_args :: FetchNotificationItems_args -> T.ThriftVal
from_FetchNotificationItems_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5164 -> P.Just (2, ("localRev",T.TI64 _v5164))) $ fetchNotificationItems_args_localRev record
  ]
write_FetchNotificationItems_args :: T.Protocol p => p -> FetchNotificationItems_args -> P.IO ()
write_FetchNotificationItems_args oprot record = T.writeVal oprot $ from_FetchNotificationItems_args record
encode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> FetchNotificationItems_args -> LBS.ByteString
encode_FetchNotificationItems_args oprot record = T.serializeVal oprot $ from_FetchNotificationItems_args record
to_FetchNotificationItems_args :: T.ThriftVal -> FetchNotificationItems_args
to_FetchNotificationItems_args (T.TStruct fields) = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = P.maybe (fetchNotificationItems_args_localRev default_FetchNotificationItems_args) (\(_,_val5166) -> (case _val5166 of {T.TI64 _val5167 -> _val5167; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FetchNotificationItems_args _ = P.error "not a struct"
read_FetchNotificationItems_args :: T.Protocol p => p -> P.IO FetchNotificationItems_args
read_FetchNotificationItems_args iprot = to_FetchNotificationItems_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args)
decode_FetchNotificationItems_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_args
decode_FetchNotificationItems_args iprot bs = to_FetchNotificationItems_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_args) bs
typemap_FetchNotificationItems_args :: T.TypeMap
typemap_FetchNotificationItems_args = Map.fromList [(2,("localRev",T.T_I64))]
default_FetchNotificationItems_args :: FetchNotificationItems_args
default_FetchNotificationItems_args = FetchNotificationItems_args{
  fetchNotificationItems_args_localRev = 0}
data FetchNotificationItems_result = FetchNotificationItems_result  { fetchNotificationItems_result_success :: NotificationFetchResult
  , fetchNotificationItems_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchNotificationItems_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchNotificationItems_result_success record   `H.hashWithSalt` fetchNotificationItems_result_e record  
instance QC.Arbitrary FetchNotificationItems_result where 
  arbitrary = M.liftM FetchNotificationItems_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchNotificationItems_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_success = fetchNotificationItems_result_success obj}
    , if obj == default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj} then P.Nothing else P.Just $ default_FetchNotificationItems_result{fetchNotificationItems_result_e = fetchNotificationItems_result_e obj}
    ]
from_FetchNotificationItems_result :: FetchNotificationItems_result -> T.ThriftVal
from_FetchNotificationItems_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5170 -> (1, ("e",from_ChannelException _v5170))) <$> fetchNotificationItems_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5170 -> P.Just (0, ("success",from_NotificationFetchResult _v5170))) $ fetchNotificationItems_result_success record
    , (\_v5170 -> (1, ("e",from_ChannelException _v5170))) <$> fetchNotificationItems_result_e record
    ]
    )
write_FetchNotificationItems_result :: T.Protocol p => p -> FetchNotificationItems_result -> P.IO ()
write_FetchNotificationItems_result oprot record = T.writeVal oprot $ from_FetchNotificationItems_result record
encode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> FetchNotificationItems_result -> LBS.ByteString
encode_FetchNotificationItems_result oprot record = T.serializeVal oprot $ from_FetchNotificationItems_result record
to_FetchNotificationItems_result :: T.ThriftVal -> FetchNotificationItems_result
to_FetchNotificationItems_result (T.TStruct fields) = FetchNotificationItems_result{
  fetchNotificationItems_result_success = P.maybe (fetchNotificationItems_result_success default_FetchNotificationItems_result) (\(_,_val5172) -> (case _val5172 of {T.TStruct _val5173 -> (to_NotificationFetchResult (T.TStruct _val5173)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchNotificationItems_result_e = P.maybe (P.Nothing) (\(_,_val5172) -> P.Just (case _val5172 of {T.TStruct _val5174 -> (to_ChannelException (T.TStruct _val5174)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchNotificationItems_result _ = P.error "not a struct"
read_FetchNotificationItems_result :: T.Protocol p => p -> P.IO FetchNotificationItems_result
read_FetchNotificationItems_result iprot = to_FetchNotificationItems_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result)
decode_FetchNotificationItems_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchNotificationItems_result
decode_FetchNotificationItems_result iprot bs = to_FetchNotificationItems_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchNotificationItems_result) bs
typemap_FetchNotificationItems_result :: T.TypeMap
typemap_FetchNotificationItems_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_NotificationFetchResult))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_FetchNotificationItems_result :: FetchNotificationItems_result
default_FetchNotificationItems_result = FetchNotificationItems_result{
  fetchNotificationItems_result_success = default_NotificationFetchResult,
  fetchNotificationItems_result_e = P.Nothing}
data GetApprovedChannels_args = GetApprovedChannels_args  { getApprovedChannels_args_lastSynced :: I.Int64
  , getApprovedChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_args_lastSynced record   `H.hashWithSalt` getApprovedChannels_args_locale record  
instance QC.Arbitrary GetApprovedChannels_args where 
  arbitrary = M.liftM GetApprovedChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_lastSynced = getApprovedChannels_args_lastSynced obj}
    , if obj == default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj} then P.Nothing else P.Just $ default_GetApprovedChannels_args{getApprovedChannels_args_locale = getApprovedChannels_args_locale obj}
    ]
from_GetApprovedChannels_args :: GetApprovedChannels_args -> T.ThriftVal
from_GetApprovedChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5177 -> P.Just (2, ("lastSynced",T.TI64 _v5177))) $ getApprovedChannels_args_lastSynced record
  , (\_v5177 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5177))) $ getApprovedChannels_args_locale record
  ]
write_GetApprovedChannels_args :: T.Protocol p => p -> GetApprovedChannels_args -> P.IO ()
write_GetApprovedChannels_args oprot record = T.writeVal oprot $ from_GetApprovedChannels_args record
encode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> GetApprovedChannels_args -> LBS.ByteString
encode_GetApprovedChannels_args oprot record = T.serializeVal oprot $ from_GetApprovedChannels_args record
to_GetApprovedChannels_args :: T.ThriftVal -> GetApprovedChannels_args
to_GetApprovedChannels_args (T.TStruct fields) = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = P.maybe (getApprovedChannels_args_lastSynced default_GetApprovedChannels_args) (\(_,_val5179) -> (case _val5179 of {T.TI64 _val5180 -> _val5180; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getApprovedChannels_args_locale = P.maybe (getApprovedChannels_args_locale default_GetApprovedChannels_args) (\(_,_val5179) -> (case _val5179 of {T.TString _val5181 -> E.decodeUtf8 _val5181; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetApprovedChannels_args _ = P.error "not a struct"
read_GetApprovedChannels_args :: T.Protocol p => p -> P.IO GetApprovedChannels_args
read_GetApprovedChannels_args iprot = to_GetApprovedChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args)
decode_GetApprovedChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_args
decode_GetApprovedChannels_args iprot bs = to_GetApprovedChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_args) bs
typemap_GetApprovedChannels_args :: T.TypeMap
typemap_GetApprovedChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetApprovedChannels_args :: GetApprovedChannels_args
default_GetApprovedChannels_args = GetApprovedChannels_args{
  getApprovedChannels_args_lastSynced = 0,
  getApprovedChannels_args_locale = ""}
data GetApprovedChannels_result = GetApprovedChannels_result  { getApprovedChannels_result_success :: ApprovedChannelInfos
  , getApprovedChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetApprovedChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getApprovedChannels_result_success record   `H.hashWithSalt` getApprovedChannels_result_e record  
instance QC.Arbitrary GetApprovedChannels_result where 
  arbitrary = M.liftM GetApprovedChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetApprovedChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_success = getApprovedChannels_result_success obj}
    , if obj == default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj} then P.Nothing else P.Just $ default_GetApprovedChannels_result{getApprovedChannels_result_e = getApprovedChannels_result_e obj}
    ]
from_GetApprovedChannels_result :: GetApprovedChannels_result -> T.ThriftVal
from_GetApprovedChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5184 -> (1, ("e",from_ChannelException _v5184))) <$> getApprovedChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5184 -> P.Just (0, ("success",from_ApprovedChannelInfos _v5184))) $ getApprovedChannels_result_success record
    , (\_v5184 -> (1, ("e",from_ChannelException _v5184))) <$> getApprovedChannels_result_e record
    ]
    )
write_GetApprovedChannels_result :: T.Protocol p => p -> GetApprovedChannels_result -> P.IO ()
write_GetApprovedChannels_result oprot record = T.writeVal oprot $ from_GetApprovedChannels_result record
encode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> GetApprovedChannels_result -> LBS.ByteString
encode_GetApprovedChannels_result oprot record = T.serializeVal oprot $ from_GetApprovedChannels_result record
to_GetApprovedChannels_result :: T.ThriftVal -> GetApprovedChannels_result
to_GetApprovedChannels_result (T.TStruct fields) = GetApprovedChannels_result{
  getApprovedChannels_result_success = P.maybe (getApprovedChannels_result_success default_GetApprovedChannels_result) (\(_,_val5186) -> (case _val5186 of {T.TStruct _val5187 -> (to_ApprovedChannelInfos (T.TStruct _val5187)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getApprovedChannels_result_e = P.maybe (P.Nothing) (\(_,_val5186) -> P.Just (case _val5186 of {T.TStruct _val5188 -> (to_ChannelException (T.TStruct _val5188)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetApprovedChannels_result _ = P.error "not a struct"
read_GetApprovedChannels_result :: T.Protocol p => p -> P.IO GetApprovedChannels_result
read_GetApprovedChannels_result iprot = to_GetApprovedChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result)
decode_GetApprovedChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetApprovedChannels_result
decode_GetApprovedChannels_result iprot bs = to_GetApprovedChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetApprovedChannels_result) bs
typemap_GetApprovedChannels_result :: T.TypeMap
typemap_GetApprovedChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ApprovedChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetApprovedChannels_result :: GetApprovedChannels_result
default_GetApprovedChannels_result = GetApprovedChannels_result{
  getApprovedChannels_result_success = default_ApprovedChannelInfos,
  getApprovedChannels_result_e = P.Nothing}
data GetChannelInfo_args = GetChannelInfo_args  { getChannelInfo_args_channelId :: LT.Text
  , getChannelInfo_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_args_channelId record   `H.hashWithSalt` getChannelInfo_args_locale record  
instance QC.Arbitrary GetChannelInfo_args where 
  arbitrary = M.liftM GetChannelInfo_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_channelId = getChannelInfo_args_channelId obj}
    , if obj == default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj} then P.Nothing else P.Just $ default_GetChannelInfo_args{getChannelInfo_args_locale = getChannelInfo_args_locale obj}
    ]
from_GetChannelInfo_args :: GetChannelInfo_args -> T.ThriftVal
from_GetChannelInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5191 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5191))) $ getChannelInfo_args_channelId record
  , (\_v5191 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5191))) $ getChannelInfo_args_locale record
  ]
write_GetChannelInfo_args :: T.Protocol p => p -> GetChannelInfo_args -> P.IO ()
write_GetChannelInfo_args oprot record = T.writeVal oprot $ from_GetChannelInfo_args record
encode_GetChannelInfo_args :: T.StatelessProtocol p => p -> GetChannelInfo_args -> LBS.ByteString
encode_GetChannelInfo_args oprot record = T.serializeVal oprot $ from_GetChannelInfo_args record
to_GetChannelInfo_args :: T.ThriftVal -> GetChannelInfo_args
to_GetChannelInfo_args (T.TStruct fields) = GetChannelInfo_args{
  getChannelInfo_args_channelId = P.maybe (getChannelInfo_args_channelId default_GetChannelInfo_args) (\(_,_val5193) -> (case _val5193 of {T.TString _val5194 -> E.decodeUtf8 _val5194; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannelInfo_args_locale = P.maybe (getChannelInfo_args_locale default_GetChannelInfo_args) (\(_,_val5193) -> (case _val5193 of {T.TString _val5195 -> E.decodeUtf8 _val5195; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannelInfo_args _ = P.error "not a struct"
read_GetChannelInfo_args :: T.Protocol p => p -> P.IO GetChannelInfo_args
read_GetChannelInfo_args iprot = to_GetChannelInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_args)
decode_GetChannelInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_args
decode_GetChannelInfo_args iprot bs = to_GetChannelInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_args) bs
typemap_GetChannelInfo_args :: T.TypeMap
typemap_GetChannelInfo_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("locale",T.T_STRING))]
default_GetChannelInfo_args :: GetChannelInfo_args
default_GetChannelInfo_args = GetChannelInfo_args{
  getChannelInfo_args_channelId = "",
  getChannelInfo_args_locale = ""}
data GetChannelInfo_result = GetChannelInfo_result  { getChannelInfo_result_success :: ChannelInfo
  , getChannelInfo_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelInfo_result_success record   `H.hashWithSalt` getChannelInfo_result_e record  
instance QC.Arbitrary GetChannelInfo_result where 
  arbitrary = M.liftM GetChannelInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_success = getChannelInfo_result_success obj}
    , if obj == default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj} then P.Nothing else P.Just $ default_GetChannelInfo_result{getChannelInfo_result_e = getChannelInfo_result_e obj}
    ]
from_GetChannelInfo_result :: GetChannelInfo_result -> T.ThriftVal
from_GetChannelInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5198 -> (1, ("e",from_ChannelException _v5198))) <$> getChannelInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5198 -> P.Just (0, ("success",from_ChannelInfo _v5198))) $ getChannelInfo_result_success record
    , (\_v5198 -> (1, ("e",from_ChannelException _v5198))) <$> getChannelInfo_result_e record
    ]
    )
write_GetChannelInfo_result :: T.Protocol p => p -> GetChannelInfo_result -> P.IO ()
write_GetChannelInfo_result oprot record = T.writeVal oprot $ from_GetChannelInfo_result record
encode_GetChannelInfo_result :: T.StatelessProtocol p => p -> GetChannelInfo_result -> LBS.ByteString
encode_GetChannelInfo_result oprot record = T.serializeVal oprot $ from_GetChannelInfo_result record
to_GetChannelInfo_result :: T.ThriftVal -> GetChannelInfo_result
to_GetChannelInfo_result (T.TStruct fields) = GetChannelInfo_result{
  getChannelInfo_result_success = P.maybe (getChannelInfo_result_success default_GetChannelInfo_result) (\(_,_val5200) -> (case _val5200 of {T.TStruct _val5201 -> (to_ChannelInfo (T.TStruct _val5201)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelInfo_result_e = P.maybe (P.Nothing) (\(_,_val5200) -> P.Just (case _val5200 of {T.TStruct _val5202 -> (to_ChannelException (T.TStruct _val5202)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelInfo_result _ = P.error "not a struct"
read_GetChannelInfo_result :: T.Protocol p => p -> P.IO GetChannelInfo_result
read_GetChannelInfo_result iprot = to_GetChannelInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelInfo_result)
decode_GetChannelInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelInfo_result
decode_GetChannelInfo_result iprot bs = to_GetChannelInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelInfo_result) bs
typemap_GetChannelInfo_result :: T.TypeMap
typemap_GetChannelInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfo))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelInfo_result :: GetChannelInfo_result
default_GetChannelInfo_result = GetChannelInfo_result{
  getChannelInfo_result_success = default_ChannelInfo,
  getChannelInfo_result_e = P.Nothing}
data GetChannelNotificationSetting_args = GetChannelNotificationSetting_args  { getChannelNotificationSetting_args_channelId :: LT.Text
  , getChannelNotificationSetting_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_args_channelId record   `H.hashWithSalt` getChannelNotificationSetting_args_locale record  
instance QC.Arbitrary GetChannelNotificationSetting_args where 
  arbitrary = M.liftM GetChannelNotificationSetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_channelId = getChannelNotificationSetting_args_channelId obj}
    , if obj == default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_args{getChannelNotificationSetting_args_locale = getChannelNotificationSetting_args_locale obj}
    ]
from_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args -> T.ThriftVal
from_GetChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5205 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5205))) $ getChannelNotificationSetting_args_channelId record
  , (\_v5205 -> P.Just (2, ("locale",T.TString $ E.encodeUtf8 _v5205))) $ getChannelNotificationSetting_args_locale record
  ]
write_GetChannelNotificationSetting_args :: T.Protocol p => p -> GetChannelNotificationSetting_args -> P.IO ()
write_GetChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_args record
encode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_args -> LBS.ByteString
encode_GetChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_args record
to_GetChannelNotificationSetting_args :: T.ThriftVal -> GetChannelNotificationSetting_args
to_GetChannelNotificationSetting_args (T.TStruct fields) = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = P.maybe (getChannelNotificationSetting_args_channelId default_GetChannelNotificationSetting_args) (\(_,_val5207) -> (case _val5207 of {T.TString _val5208 -> E.decodeUtf8 _val5208; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getChannelNotificationSetting_args_locale = P.maybe (getChannelNotificationSetting_args_locale default_GetChannelNotificationSetting_args) (\(_,_val5207) -> (case _val5207 of {T.TString _val5209 -> E.decodeUtf8 _val5209; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetChannelNotificationSetting_args _ = P.error "not a struct"
read_GetChannelNotificationSetting_args :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_args
read_GetChannelNotificationSetting_args iprot = to_GetChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args)
decode_GetChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_args
decode_GetChannelNotificationSetting_args iprot bs = to_GetChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_args) bs
typemap_GetChannelNotificationSetting_args :: T.TypeMap
typemap_GetChannelNotificationSetting_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("locale",T.T_STRING))]
default_GetChannelNotificationSetting_args :: GetChannelNotificationSetting_args
default_GetChannelNotificationSetting_args = GetChannelNotificationSetting_args{
  getChannelNotificationSetting_args_channelId = "",
  getChannelNotificationSetting_args_locale = ""}
data GetChannelNotificationSetting_result = GetChannelNotificationSetting_result  { getChannelNotificationSetting_result_success :: ChannelNotificationSetting
  , getChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSetting_result_success record   `H.hashWithSalt` getChannelNotificationSetting_result_e record  
instance QC.Arbitrary GetChannelNotificationSetting_result where 
  arbitrary = M.liftM GetChannelNotificationSetting_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = getChannelNotificationSetting_result_success obj}
    , if obj == default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = getChannelNotificationSetting_result_e obj}
    ]
from_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result -> T.ThriftVal
from_GetChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5212 -> (1, ("e",from_ChannelException _v5212))) <$> getChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5212 -> P.Just (0, ("success",from_ChannelNotificationSetting _v5212))) $ getChannelNotificationSetting_result_success record
    , (\_v5212 -> (1, ("e",from_ChannelException _v5212))) <$> getChannelNotificationSetting_result_e record
    ]
    )
write_GetChannelNotificationSetting_result :: T.Protocol p => p -> GetChannelNotificationSetting_result -> P.IO ()
write_GetChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSetting_result record
encode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> GetChannelNotificationSetting_result -> LBS.ByteString
encode_GetChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSetting_result record
to_GetChannelNotificationSetting_result :: T.ThriftVal -> GetChannelNotificationSetting_result
to_GetChannelNotificationSetting_result (T.TStruct fields) = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = P.maybe (getChannelNotificationSetting_result_success default_GetChannelNotificationSetting_result) (\(_,_val5214) -> (case _val5214 of {T.TStruct _val5215 -> (to_ChannelNotificationSetting (T.TStruct _val5215)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val5214) -> P.Just (case _val5214 of {T.TStruct _val5216 -> (to_ChannelException (T.TStruct _val5216)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSetting_result _ = P.error "not a struct"
read_GetChannelNotificationSetting_result :: T.Protocol p => p -> P.IO GetChannelNotificationSetting_result
read_GetChannelNotificationSetting_result iprot = to_GetChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result)
decode_GetChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSetting_result
decode_GetChannelNotificationSetting_result iprot bs = to_GetChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSetting_result) bs
typemap_GetChannelNotificationSetting_result :: T.TypeMap
typemap_GetChannelNotificationSetting_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelNotificationSetting))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSetting_result :: GetChannelNotificationSetting_result
default_GetChannelNotificationSetting_result = GetChannelNotificationSetting_result{
  getChannelNotificationSetting_result_success = default_ChannelNotificationSetting,
  getChannelNotificationSetting_result_e = P.Nothing}
data GetChannelNotificationSettings_args = GetChannelNotificationSettings_args  { getChannelNotificationSettings_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_args_locale record  
instance QC.Arbitrary GetChannelNotificationSettings_args where 
  arbitrary = M.liftM GetChannelNotificationSettings_args (QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_args{getChannelNotificationSettings_args_locale = getChannelNotificationSettings_args_locale obj}
    ]
from_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args -> T.ThriftVal
from_GetChannelNotificationSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5219 -> P.Just (1, ("locale",T.TString $ E.encodeUtf8 _v5219))) $ getChannelNotificationSettings_args_locale record
  ]
write_GetChannelNotificationSettings_args :: T.Protocol p => p -> GetChannelNotificationSettings_args -> P.IO ()
write_GetChannelNotificationSettings_args oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_args record
encode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_args -> LBS.ByteString
encode_GetChannelNotificationSettings_args oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_args record
to_GetChannelNotificationSettings_args :: T.ThriftVal -> GetChannelNotificationSettings_args
to_GetChannelNotificationSettings_args (T.TStruct fields) = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = P.maybe (getChannelNotificationSettings_args_locale default_GetChannelNotificationSettings_args) (\(_,_val5221) -> (case _val5221 of {T.TString _val5222 -> E.decodeUtf8 _val5222; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_args _ = P.error "not a struct"
read_GetChannelNotificationSettings_args :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_args
read_GetChannelNotificationSettings_args iprot = to_GetChannelNotificationSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args)
decode_GetChannelNotificationSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_args
decode_GetChannelNotificationSettings_args iprot bs = to_GetChannelNotificationSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_args) bs
typemap_GetChannelNotificationSettings_args :: T.TypeMap
typemap_GetChannelNotificationSettings_args = Map.fromList [(1,("locale",T.T_STRING))]
default_GetChannelNotificationSettings_args :: GetChannelNotificationSettings_args
default_GetChannelNotificationSettings_args = GetChannelNotificationSettings_args{
  getChannelNotificationSettings_args_locale = ""}
data GetChannelNotificationSettings_result = GetChannelNotificationSettings_result  { getChannelNotificationSettings_result_success :: (Vector.Vector ChannelNotificationSetting)
  , getChannelNotificationSettings_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannelNotificationSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannelNotificationSettings_result_success record   `H.hashWithSalt` getChannelNotificationSettings_result_e record  
instance QC.Arbitrary GetChannelNotificationSettings_result where 
  arbitrary = M.liftM GetChannelNotificationSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannelNotificationSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = getChannelNotificationSettings_result_success obj}
    , if obj == default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj} then P.Nothing else P.Just $ default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = getChannelNotificationSettings_result_e obj}
    ]
from_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result -> T.ThriftVal
from_GetChannelNotificationSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5225 -> (1, ("e",from_ChannelException _v5225))) <$> getChannelNotificationSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5225 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v5227 -> from_ChannelNotificationSetting _v5227) $ Vector.toList _v5225))) $ getChannelNotificationSettings_result_success record
    , (\_v5225 -> (1, ("e",from_ChannelException _v5225))) <$> getChannelNotificationSettings_result_e record
    ]
    )
write_GetChannelNotificationSettings_result :: T.Protocol p => p -> GetChannelNotificationSettings_result -> P.IO ()
write_GetChannelNotificationSettings_result oprot record = T.writeVal oprot $ from_GetChannelNotificationSettings_result record
encode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> GetChannelNotificationSettings_result -> LBS.ByteString
encode_GetChannelNotificationSettings_result oprot record = T.serializeVal oprot $ from_GetChannelNotificationSettings_result record
to_GetChannelNotificationSettings_result :: T.ThriftVal -> GetChannelNotificationSettings_result
to_GetChannelNotificationSettings_result (T.TStruct fields) = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = P.maybe (getChannelNotificationSettings_result_success default_GetChannelNotificationSettings_result) (\(_,_val5229) -> (case _val5229 of {T.TList _ _val5230 -> (Vector.fromList $ P.map (\_v5231 -> (case _v5231 of {T.TStruct _val5232 -> (to_ChannelNotificationSetting (T.TStruct _val5232)); _ -> P.error "wrong type"})) _val5230); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannelNotificationSettings_result_e = P.maybe (P.Nothing) (\(_,_val5229) -> P.Just (case _val5229 of {T.TStruct _val5233 -> (to_ChannelException (T.TStruct _val5233)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannelNotificationSettings_result _ = P.error "not a struct"
read_GetChannelNotificationSettings_result :: T.Protocol p => p -> P.IO GetChannelNotificationSettings_result
read_GetChannelNotificationSettings_result iprot = to_GetChannelNotificationSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result)
decode_GetChannelNotificationSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannelNotificationSettings_result
decode_GetChannelNotificationSettings_result iprot bs = to_GetChannelNotificationSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannelNotificationSettings_result) bs
typemap_GetChannelNotificationSettings_result :: T.TypeMap
typemap_GetChannelNotificationSettings_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting)))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannelNotificationSettings_result :: GetChannelNotificationSettings_result
default_GetChannelNotificationSettings_result = GetChannelNotificationSettings_result{
  getChannelNotificationSettings_result_success = Vector.empty,
  getChannelNotificationSettings_result_e = P.Nothing}
data GetChannels_args = GetChannels_args  { getChannels_args_lastSynced :: I.Int64
  , getChannels_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_args_lastSynced record   `H.hashWithSalt` getChannels_args_locale record  
instance QC.Arbitrary GetChannels_args where 
  arbitrary = M.liftM GetChannels_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetChannels_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_lastSynced = getChannels_args_lastSynced obj}
    , if obj == default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj} then P.Nothing else P.Just $ default_GetChannels_args{getChannels_args_locale = getChannels_args_locale obj}
    ]
from_GetChannels_args :: GetChannels_args -> T.ThriftVal
from_GetChannels_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5236 -> P.Just (2, ("lastSynced",T.TI64 _v5236))) $ getChannels_args_lastSynced record
  , (\_v5236 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5236))) $ getChannels_args_locale record
  ]
write_GetChannels_args :: T.Protocol p => p -> GetChannels_args -> P.IO ()
write_GetChannels_args oprot record = T.writeVal oprot $ from_GetChannels_args record
encode_GetChannels_args :: T.StatelessProtocol p => p -> GetChannels_args -> LBS.ByteString
encode_GetChannels_args oprot record = T.serializeVal oprot $ from_GetChannels_args record
to_GetChannels_args :: T.ThriftVal -> GetChannels_args
to_GetChannels_args (T.TStruct fields) = GetChannels_args{
  getChannels_args_lastSynced = P.maybe (getChannels_args_lastSynced default_GetChannels_args) (\(_,_val5238) -> (case _val5238 of {T.TI64 _val5239 -> _val5239; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getChannels_args_locale = P.maybe (getChannels_args_locale default_GetChannels_args) (\(_,_val5238) -> (case _val5238 of {T.TString _val5240 -> E.decodeUtf8 _val5240; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetChannels_args _ = P.error "not a struct"
read_GetChannels_args :: T.Protocol p => p -> P.IO GetChannels_args
read_GetChannels_args iprot = to_GetChannels_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_args)
decode_GetChannels_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_args
decode_GetChannels_args iprot bs = to_GetChannels_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_args) bs
typemap_GetChannels_args :: T.TypeMap
typemap_GetChannels_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_GetChannels_args :: GetChannels_args
default_GetChannels_args = GetChannels_args{
  getChannels_args_lastSynced = 0,
  getChannels_args_locale = ""}
data GetChannels_result = GetChannels_result  { getChannels_result_success :: ChannelInfos
  , getChannels_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChannels_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChannels_result_success record   `H.hashWithSalt` getChannels_result_e record  
instance QC.Arbitrary GetChannels_result where 
  arbitrary = M.liftM GetChannels_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChannels_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChannels_result{getChannels_result_success = getChannels_result_success obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_success = getChannels_result_success obj}
    , if obj == default_GetChannels_result{getChannels_result_e = getChannels_result_e obj} then P.Nothing else P.Just $ default_GetChannels_result{getChannels_result_e = getChannels_result_e obj}
    ]
from_GetChannels_result :: GetChannels_result -> T.ThriftVal
from_GetChannels_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5243 -> (1, ("e",from_ChannelException _v5243))) <$> getChannels_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5243 -> P.Just (0, ("success",from_ChannelInfos _v5243))) $ getChannels_result_success record
    , (\_v5243 -> (1, ("e",from_ChannelException _v5243))) <$> getChannels_result_e record
    ]
    )
write_GetChannels_result :: T.Protocol p => p -> GetChannels_result -> P.IO ()
write_GetChannels_result oprot record = T.writeVal oprot $ from_GetChannels_result record
encode_GetChannels_result :: T.StatelessProtocol p => p -> GetChannels_result -> LBS.ByteString
encode_GetChannels_result oprot record = T.serializeVal oprot $ from_GetChannels_result record
to_GetChannels_result :: T.ThriftVal -> GetChannels_result
to_GetChannels_result (T.TStruct fields) = GetChannels_result{
  getChannels_result_success = P.maybe (getChannels_result_success default_GetChannels_result) (\(_,_val5245) -> (case _val5245 of {T.TStruct _val5246 -> (to_ChannelInfos (T.TStruct _val5246)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChannels_result_e = P.maybe (P.Nothing) (\(_,_val5245) -> P.Just (case _val5245 of {T.TStruct _val5247 -> (to_ChannelException (T.TStruct _val5247)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChannels_result _ = P.error "not a struct"
read_GetChannels_result :: T.Protocol p => p -> P.IO GetChannels_result
read_GetChannels_result iprot = to_GetChannels_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChannels_result)
decode_GetChannels_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChannels_result
decode_GetChannels_result iprot bs = to_GetChannels_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChannels_result) bs
typemap_GetChannels_result :: T.TypeMap
typemap_GetChannels_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelInfos))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetChannels_result :: GetChannels_result
default_GetChannels_result = GetChannels_result{
  getChannels_result_success = default_ChannelInfos,
  getChannels_result_e = P.Nothing}
data GetDomains_args = GetDomains_args  { getDomains_args_lastSynced :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_args_lastSynced record  
instance QC.Arbitrary GetDomains_args where 
  arbitrary = M.liftM GetDomains_args (QC.arbitrary)
  shrink obj | obj == default_GetDomains_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj} then P.Nothing else P.Just $ default_GetDomains_args{getDomains_args_lastSynced = getDomains_args_lastSynced obj}
    ]
from_GetDomains_args :: GetDomains_args -> T.ThriftVal
from_GetDomains_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5250 -> P.Just (2, ("lastSynced",T.TI64 _v5250))) $ getDomains_args_lastSynced record
  ]
write_GetDomains_args :: T.Protocol p => p -> GetDomains_args -> P.IO ()
write_GetDomains_args oprot record = T.writeVal oprot $ from_GetDomains_args record
encode_GetDomains_args :: T.StatelessProtocol p => p -> GetDomains_args -> LBS.ByteString
encode_GetDomains_args oprot record = T.serializeVal oprot $ from_GetDomains_args record
to_GetDomains_args :: T.ThriftVal -> GetDomains_args
to_GetDomains_args (T.TStruct fields) = GetDomains_args{
  getDomains_args_lastSynced = P.maybe (getDomains_args_lastSynced default_GetDomains_args) (\(_,_val5252) -> (case _val5252 of {T.TI64 _val5253 -> _val5253; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDomains_args _ = P.error "not a struct"
read_GetDomains_args :: T.Protocol p => p -> P.IO GetDomains_args
read_GetDomains_args iprot = to_GetDomains_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_args)
decode_GetDomains_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_args
decode_GetDomains_args iprot bs = to_GetDomains_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_args) bs
typemap_GetDomains_args :: T.TypeMap
typemap_GetDomains_args = Map.fromList [(2,("lastSynced",T.T_I64))]
default_GetDomains_args :: GetDomains_args
default_GetDomains_args = GetDomains_args{
  getDomains_args_lastSynced = 0}
data GetDomains_result = GetDomains_result  { getDomains_result_success :: ChannelDomains
  , getDomains_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDomains_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDomains_result_success record   `H.hashWithSalt` getDomains_result_e record  
instance QC.Arbitrary GetDomains_result where 
  arbitrary = M.liftM GetDomains_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDomains_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDomains_result{getDomains_result_success = getDomains_result_success obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_success = getDomains_result_success obj}
    , if obj == default_GetDomains_result{getDomains_result_e = getDomains_result_e obj} then P.Nothing else P.Just $ default_GetDomains_result{getDomains_result_e = getDomains_result_e obj}
    ]
from_GetDomains_result :: GetDomains_result -> T.ThriftVal
from_GetDomains_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5256 -> (1, ("e",from_ChannelException _v5256))) <$> getDomains_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5256 -> P.Just (0, ("success",from_ChannelDomains _v5256))) $ getDomains_result_success record
    , (\_v5256 -> (1, ("e",from_ChannelException _v5256))) <$> getDomains_result_e record
    ]
    )
write_GetDomains_result :: T.Protocol p => p -> GetDomains_result -> P.IO ()
write_GetDomains_result oprot record = T.writeVal oprot $ from_GetDomains_result record
encode_GetDomains_result :: T.StatelessProtocol p => p -> GetDomains_result -> LBS.ByteString
encode_GetDomains_result oprot record = T.serializeVal oprot $ from_GetDomains_result record
to_GetDomains_result :: T.ThriftVal -> GetDomains_result
to_GetDomains_result (T.TStruct fields) = GetDomains_result{
  getDomains_result_success = P.maybe (getDomains_result_success default_GetDomains_result) (\(_,_val5258) -> (case _val5258 of {T.TStruct _val5259 -> (to_ChannelDomains (T.TStruct _val5259)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDomains_result_e = P.maybe (P.Nothing) (\(_,_val5258) -> P.Just (case _val5258 of {T.TStruct _val5260 -> (to_ChannelException (T.TStruct _val5260)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDomains_result _ = P.error "not a struct"
read_GetDomains_result :: T.Protocol p => p -> P.IO GetDomains_result
read_GetDomains_result iprot = to_GetDomains_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDomains_result)
decode_GetDomains_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDomains_result
decode_GetDomains_result iprot bs = to_GetDomains_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDomains_result) bs
typemap_GetDomains_result :: T.TypeMap
typemap_GetDomains_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelDomains))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetDomains_result :: GetDomains_result
default_GetDomains_result = GetDomains_result{
  getDomains_result_success = default_ChannelDomains,
  getDomains_result_e = P.Nothing}
data GetFriendChannelMatrices_args = GetFriendChannelMatrices_args  { getFriendChannelMatrices_args_channelIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_args_channelIds record  
instance QC.Arbitrary GetFriendChannelMatrices_args where 
  arbitrary = M.liftM GetFriendChannelMatrices_args (QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_args{getFriendChannelMatrices_args_channelIds = getFriendChannelMatrices_args_channelIds obj}
    ]
from_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args -> T.ThriftVal
from_GetFriendChannelMatrices_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5263 -> P.Just (1, ("channelIds",T.TList T.T_STRING $ P.map (\_v5265 -> T.TString $ E.encodeUtf8 _v5265) $ Vector.toList _v5263))) $ getFriendChannelMatrices_args_channelIds record
  ]
write_GetFriendChannelMatrices_args :: T.Protocol p => p -> GetFriendChannelMatrices_args -> P.IO ()
write_GetFriendChannelMatrices_args oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_args record
encode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_args -> LBS.ByteString
encode_GetFriendChannelMatrices_args oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_args record
to_GetFriendChannelMatrices_args :: T.ThriftVal -> GetFriendChannelMatrices_args
to_GetFriendChannelMatrices_args (T.TStruct fields) = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = P.maybe (getFriendChannelMatrices_args_channelIds default_GetFriendChannelMatrices_args) (\(_,_val5267) -> (case _val5267 of {T.TList _ _val5268 -> (Vector.fromList $ P.map (\_v5269 -> (case _v5269 of {T.TString _val5270 -> E.decodeUtf8 _val5270; _ -> P.error "wrong type"})) _val5268); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_args _ = P.error "not a struct"
read_GetFriendChannelMatrices_args :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_args
read_GetFriendChannelMatrices_args iprot = to_GetFriendChannelMatrices_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args)
decode_GetFriendChannelMatrices_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_args
decode_GetFriendChannelMatrices_args iprot bs = to_GetFriendChannelMatrices_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_args) bs
typemap_GetFriendChannelMatrices_args :: T.TypeMap
typemap_GetFriendChannelMatrices_args = Map.fromList [(1,("channelIds",(T.T_LIST T.T_STRING)))]
default_GetFriendChannelMatrices_args :: GetFriendChannelMatrices_args
default_GetFriendChannelMatrices_args = GetFriendChannelMatrices_args{
  getFriendChannelMatrices_args_channelIds = Vector.empty}
data GetFriendChannelMatrices_result = GetFriendChannelMatrices_result  { getFriendChannelMatrices_result_success :: FriendChannelMatricesResponse
  , getFriendChannelMatrices_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendChannelMatrices_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendChannelMatrices_result_success record   `H.hashWithSalt` getFriendChannelMatrices_result_e record  
instance QC.Arbitrary GetFriendChannelMatrices_result where 
  arbitrary = M.liftM GetFriendChannelMatrices_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendChannelMatrices_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = getFriendChannelMatrices_result_success obj}
    , if obj == default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj} then P.Nothing else P.Just $ default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = getFriendChannelMatrices_result_e obj}
    ]
from_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result -> T.ThriftVal
from_GetFriendChannelMatrices_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5273 -> (1, ("e",from_ChannelException _v5273))) <$> getFriendChannelMatrices_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5273 -> P.Just (0, ("success",from_FriendChannelMatricesResponse _v5273))) $ getFriendChannelMatrices_result_success record
    , (\_v5273 -> (1, ("e",from_ChannelException _v5273))) <$> getFriendChannelMatrices_result_e record
    ]
    )
write_GetFriendChannelMatrices_result :: T.Protocol p => p -> GetFriendChannelMatrices_result -> P.IO ()
write_GetFriendChannelMatrices_result oprot record = T.writeVal oprot $ from_GetFriendChannelMatrices_result record
encode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> GetFriendChannelMatrices_result -> LBS.ByteString
encode_GetFriendChannelMatrices_result oprot record = T.serializeVal oprot $ from_GetFriendChannelMatrices_result record
to_GetFriendChannelMatrices_result :: T.ThriftVal -> GetFriendChannelMatrices_result
to_GetFriendChannelMatrices_result (T.TStruct fields) = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = P.maybe (getFriendChannelMatrices_result_success default_GetFriendChannelMatrices_result) (\(_,_val5275) -> (case _val5275 of {T.TStruct _val5276 -> (to_FriendChannelMatricesResponse (T.TStruct _val5276)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendChannelMatrices_result_e = P.maybe (P.Nothing) (\(_,_val5275) -> P.Just (case _val5275 of {T.TStruct _val5277 -> (to_ChannelException (T.TStruct _val5277)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendChannelMatrices_result _ = P.error "not a struct"
read_GetFriendChannelMatrices_result :: T.Protocol p => p -> P.IO GetFriendChannelMatrices_result
read_GetFriendChannelMatrices_result iprot = to_GetFriendChannelMatrices_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result)
decode_GetFriendChannelMatrices_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendChannelMatrices_result
decode_GetFriendChannelMatrices_result iprot bs = to_GetFriendChannelMatrices_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendChannelMatrices_result) bs
typemap_GetFriendChannelMatrices_result :: T.TypeMap
typemap_GetFriendChannelMatrices_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FriendChannelMatricesResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetFriendChannelMatrices_result :: GetFriendChannelMatrices_result
default_GetFriendChannelMatrices_result = GetFriendChannelMatrices_result{
  getFriendChannelMatrices_result_success = default_FriendChannelMatricesResponse,
  getFriendChannelMatrices_result_e = P.Nothing}
data UpdateChannelSettings_args = UpdateChannelSettings_args  { updateChannelSettings_args_channelSettings :: ChannelSettings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelSettings_args_channelSettings record  
instance QC.Arbitrary UpdateChannelSettings_args where 
  arbitrary = M.liftM UpdateChannelSettings_args (QC.arbitrary)
  shrink obj | obj == default_UpdateChannelSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelSettings_args{updateChannelSettings_args_channelSettings = updateChannelSettings_args_channelSettings obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_args{updateChannelSettings_args_channelSettings = updateChannelSettings_args_channelSettings obj}
    ]
from_UpdateChannelSettings_args :: UpdateChannelSettings_args -> T.ThriftVal
from_UpdateChannelSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5280 -> P.Just (1, ("channelSettings",from_ChannelSettings _v5280))) $ updateChannelSettings_args_channelSettings record
  ]
write_UpdateChannelSettings_args :: T.Protocol p => p -> UpdateChannelSettings_args -> P.IO ()
write_UpdateChannelSettings_args oprot record = T.writeVal oprot $ from_UpdateChannelSettings_args record
encode_UpdateChannelSettings_args :: T.StatelessProtocol p => p -> UpdateChannelSettings_args -> LBS.ByteString
encode_UpdateChannelSettings_args oprot record = T.serializeVal oprot $ from_UpdateChannelSettings_args record
to_UpdateChannelSettings_args :: T.ThriftVal -> UpdateChannelSettings_args
to_UpdateChannelSettings_args (T.TStruct fields) = UpdateChannelSettings_args{
  updateChannelSettings_args_channelSettings = P.maybe (updateChannelSettings_args_channelSettings default_UpdateChannelSettings_args) (\(_,_val5282) -> (case _val5282 of {T.TStruct _val5283 -> (to_ChannelSettings (T.TStruct _val5283)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelSettings_args _ = P.error "not a struct"
read_UpdateChannelSettings_args :: T.Protocol p => p -> P.IO UpdateChannelSettings_args
read_UpdateChannelSettings_args iprot = to_UpdateChannelSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_args)
decode_UpdateChannelSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelSettings_args
decode_UpdateChannelSettings_args iprot bs = to_UpdateChannelSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_args) bs
typemap_UpdateChannelSettings_args :: T.TypeMap
typemap_UpdateChannelSettings_args = Map.fromList [(1,("channelSettings",(T.T_STRUCT typemap_ChannelSettings)))]
default_UpdateChannelSettings_args :: UpdateChannelSettings_args
default_UpdateChannelSettings_args = UpdateChannelSettings_args{
  updateChannelSettings_args_channelSettings = default_ChannelSettings}
data UpdateChannelSettings_result = UpdateChannelSettings_result  { updateChannelSettings_result_success :: P.Bool
  , updateChannelSettings_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelSettings_result_success record   `H.hashWithSalt` updateChannelSettings_result_e record  
instance QC.Arbitrary UpdateChannelSettings_result where 
  arbitrary = M.liftM UpdateChannelSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateChannelSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelSettings_result{updateChannelSettings_result_success = updateChannelSettings_result_success obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_result{updateChannelSettings_result_success = updateChannelSettings_result_success obj}
    , if obj == default_UpdateChannelSettings_result{updateChannelSettings_result_e = updateChannelSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateChannelSettings_result{updateChannelSettings_result_e = updateChannelSettings_result_e obj}
    ]
from_UpdateChannelSettings_result :: UpdateChannelSettings_result -> T.ThriftVal
from_UpdateChannelSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5286 -> (1, ("e",from_ChannelException _v5286))) <$> updateChannelSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5286 -> P.Just (0, ("success",T.TBool _v5286))) $ updateChannelSettings_result_success record
    , (\_v5286 -> (1, ("e",from_ChannelException _v5286))) <$> updateChannelSettings_result_e record
    ]
    )
write_UpdateChannelSettings_result :: T.Protocol p => p -> UpdateChannelSettings_result -> P.IO ()
write_UpdateChannelSettings_result oprot record = T.writeVal oprot $ from_UpdateChannelSettings_result record
encode_UpdateChannelSettings_result :: T.StatelessProtocol p => p -> UpdateChannelSettings_result -> LBS.ByteString
encode_UpdateChannelSettings_result oprot record = T.serializeVal oprot $ from_UpdateChannelSettings_result record
to_UpdateChannelSettings_result :: T.ThriftVal -> UpdateChannelSettings_result
to_UpdateChannelSettings_result (T.TStruct fields) = UpdateChannelSettings_result{
  updateChannelSettings_result_success = P.maybe (updateChannelSettings_result_success default_UpdateChannelSettings_result) (\(_,_val5288) -> (case _val5288 of {T.TBool _val5289 -> _val5289; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateChannelSettings_result_e = P.maybe (P.Nothing) (\(_,_val5288) -> P.Just (case _val5288 of {T.TStruct _val5290 -> (to_ChannelException (T.TStruct _val5290)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelSettings_result _ = P.error "not a struct"
read_UpdateChannelSettings_result :: T.Protocol p => p -> P.IO UpdateChannelSettings_result
read_UpdateChannelSettings_result iprot = to_UpdateChannelSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_result)
decode_UpdateChannelSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelSettings_result
decode_UpdateChannelSettings_result iprot bs = to_UpdateChannelSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelSettings_result) bs
typemap_UpdateChannelSettings_result :: T.TypeMap
typemap_UpdateChannelSettings_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_UpdateChannelSettings_result :: UpdateChannelSettings_result
default_UpdateChannelSettings_result = UpdateChannelSettings_result{
  updateChannelSettings_result_success = P.False,
  updateChannelSettings_result_e = P.Nothing}
data GetCommonDomains_args = GetCommonDomains_args  { getCommonDomains_args_lastSynced :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCommonDomains_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCommonDomains_args_lastSynced record  
instance QC.Arbitrary GetCommonDomains_args where 
  arbitrary = M.liftM GetCommonDomains_args (QC.arbitrary)
  shrink obj | obj == default_GetCommonDomains_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCommonDomains_args{getCommonDomains_args_lastSynced = getCommonDomains_args_lastSynced obj} then P.Nothing else P.Just $ default_GetCommonDomains_args{getCommonDomains_args_lastSynced = getCommonDomains_args_lastSynced obj}
    ]
from_GetCommonDomains_args :: GetCommonDomains_args -> T.ThriftVal
from_GetCommonDomains_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5293 -> P.Just (1, ("lastSynced",T.TI64 _v5293))) $ getCommonDomains_args_lastSynced record
  ]
write_GetCommonDomains_args :: T.Protocol p => p -> GetCommonDomains_args -> P.IO ()
write_GetCommonDomains_args oprot record = T.writeVal oprot $ from_GetCommonDomains_args record
encode_GetCommonDomains_args :: T.StatelessProtocol p => p -> GetCommonDomains_args -> LBS.ByteString
encode_GetCommonDomains_args oprot record = T.serializeVal oprot $ from_GetCommonDomains_args record
to_GetCommonDomains_args :: T.ThriftVal -> GetCommonDomains_args
to_GetCommonDomains_args (T.TStruct fields) = GetCommonDomains_args{
  getCommonDomains_args_lastSynced = P.maybe (getCommonDomains_args_lastSynced default_GetCommonDomains_args) (\(_,_val5295) -> (case _val5295 of {T.TI64 _val5296 -> _val5296; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCommonDomains_args _ = P.error "not a struct"
read_GetCommonDomains_args :: T.Protocol p => p -> P.IO GetCommonDomains_args
read_GetCommonDomains_args iprot = to_GetCommonDomains_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCommonDomains_args)
decode_GetCommonDomains_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCommonDomains_args
decode_GetCommonDomains_args iprot bs = to_GetCommonDomains_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCommonDomains_args) bs
typemap_GetCommonDomains_args :: T.TypeMap
typemap_GetCommonDomains_args = Map.fromList [(1,("lastSynced",T.T_I64))]
default_GetCommonDomains_args :: GetCommonDomains_args
default_GetCommonDomains_args = GetCommonDomains_args{
  getCommonDomains_args_lastSynced = 0}
data GetCommonDomains_result = GetCommonDomains_result  { getCommonDomains_result_success :: ChannelDomains
  , getCommonDomains_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCommonDomains_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCommonDomains_result_success record   `H.hashWithSalt` getCommonDomains_result_e record  
instance QC.Arbitrary GetCommonDomains_result where 
  arbitrary = M.liftM GetCommonDomains_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCommonDomains_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCommonDomains_result{getCommonDomains_result_success = getCommonDomains_result_success obj} then P.Nothing else P.Just $ default_GetCommonDomains_result{getCommonDomains_result_success = getCommonDomains_result_success obj}
    , if obj == default_GetCommonDomains_result{getCommonDomains_result_e = getCommonDomains_result_e obj} then P.Nothing else P.Just $ default_GetCommonDomains_result{getCommonDomains_result_e = getCommonDomains_result_e obj}
    ]
from_GetCommonDomains_result :: GetCommonDomains_result -> T.ThriftVal
from_GetCommonDomains_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5299 -> (1, ("e",from_ChannelException _v5299))) <$> getCommonDomains_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5299 -> P.Just (0, ("success",from_ChannelDomains _v5299))) $ getCommonDomains_result_success record
    , (\_v5299 -> (1, ("e",from_ChannelException _v5299))) <$> getCommonDomains_result_e record
    ]
    )
write_GetCommonDomains_result :: T.Protocol p => p -> GetCommonDomains_result -> P.IO ()
write_GetCommonDomains_result oprot record = T.writeVal oprot $ from_GetCommonDomains_result record
encode_GetCommonDomains_result :: T.StatelessProtocol p => p -> GetCommonDomains_result -> LBS.ByteString
encode_GetCommonDomains_result oprot record = T.serializeVal oprot $ from_GetCommonDomains_result record
to_GetCommonDomains_result :: T.ThriftVal -> GetCommonDomains_result
to_GetCommonDomains_result (T.TStruct fields) = GetCommonDomains_result{
  getCommonDomains_result_success = P.maybe (getCommonDomains_result_success default_GetCommonDomains_result) (\(_,_val5301) -> (case _val5301 of {T.TStruct _val5302 -> (to_ChannelDomains (T.TStruct _val5302)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCommonDomains_result_e = P.maybe (P.Nothing) (\(_,_val5301) -> P.Just (case _val5301 of {T.TStruct _val5303 -> (to_ChannelException (T.TStruct _val5303)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCommonDomains_result _ = P.error "not a struct"
read_GetCommonDomains_result :: T.Protocol p => p -> P.IO GetCommonDomains_result
read_GetCommonDomains_result iprot = to_GetCommonDomains_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCommonDomains_result)
decode_GetCommonDomains_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCommonDomains_result
decode_GetCommonDomains_result iprot bs = to_GetCommonDomains_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCommonDomains_result) bs
typemap_GetCommonDomains_result :: T.TypeMap
typemap_GetCommonDomains_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelDomains))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetCommonDomains_result :: GetCommonDomains_result
default_GetCommonDomains_result = GetCommonDomains_result{
  getCommonDomains_result_success = default_ChannelDomains,
  getCommonDomains_result_e = P.Nothing}
data GetNotificationBadgeCount_args = GetNotificationBadgeCount_args  { getNotificationBadgeCount_args_localRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_args_localRev record  
instance QC.Arbitrary GetNotificationBadgeCount_args where 
  arbitrary = M.liftM GetNotificationBadgeCount_args (QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_args{getNotificationBadgeCount_args_localRev = getNotificationBadgeCount_args_localRev obj}
    ]
from_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args -> T.ThriftVal
from_GetNotificationBadgeCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5306 -> P.Just (2, ("localRev",T.TI64 _v5306))) $ getNotificationBadgeCount_args_localRev record
  ]
write_GetNotificationBadgeCount_args :: T.Protocol p => p -> GetNotificationBadgeCount_args -> P.IO ()
write_GetNotificationBadgeCount_args oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_args record
encode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_args -> LBS.ByteString
encode_GetNotificationBadgeCount_args oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_args record
to_GetNotificationBadgeCount_args :: T.ThriftVal -> GetNotificationBadgeCount_args
to_GetNotificationBadgeCount_args (T.TStruct fields) = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = P.maybe (getNotificationBadgeCount_args_localRev default_GetNotificationBadgeCount_args) (\(_,_val5308) -> (case _val5308 of {T.TI64 _val5309 -> _val5309; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotificationBadgeCount_args _ = P.error "not a struct"
read_GetNotificationBadgeCount_args :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_args
read_GetNotificationBadgeCount_args iprot = to_GetNotificationBadgeCount_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args)
decode_GetNotificationBadgeCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_args
decode_GetNotificationBadgeCount_args iprot bs = to_GetNotificationBadgeCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_args) bs
typemap_GetNotificationBadgeCount_args :: T.TypeMap
typemap_GetNotificationBadgeCount_args = Map.fromList [(2,("localRev",T.T_I64))]
default_GetNotificationBadgeCount_args :: GetNotificationBadgeCount_args
default_GetNotificationBadgeCount_args = GetNotificationBadgeCount_args{
  getNotificationBadgeCount_args_localRev = 0}
data GetNotificationBadgeCount_result = GetNotificationBadgeCount_result  { getNotificationBadgeCount_result_success :: I.Int32
  , getNotificationBadgeCount_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationBadgeCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationBadgeCount_result_success record   `H.hashWithSalt` getNotificationBadgeCount_result_e record  
instance QC.Arbitrary GetNotificationBadgeCount_result where 
  arbitrary = M.liftM GetNotificationBadgeCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotificationBadgeCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = getNotificationBadgeCount_result_success obj}
    , if obj == default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj} then P.Nothing else P.Just $ default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = getNotificationBadgeCount_result_e obj}
    ]
from_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result -> T.ThriftVal
from_GetNotificationBadgeCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5312 -> (1, ("e",from_ChannelException _v5312))) <$> getNotificationBadgeCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5312 -> P.Just (0, ("success",T.TI32 _v5312))) $ getNotificationBadgeCount_result_success record
    , (\_v5312 -> (1, ("e",from_ChannelException _v5312))) <$> getNotificationBadgeCount_result_e record
    ]
    )
write_GetNotificationBadgeCount_result :: T.Protocol p => p -> GetNotificationBadgeCount_result -> P.IO ()
write_GetNotificationBadgeCount_result oprot record = T.writeVal oprot $ from_GetNotificationBadgeCount_result record
encode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> GetNotificationBadgeCount_result -> LBS.ByteString
encode_GetNotificationBadgeCount_result oprot record = T.serializeVal oprot $ from_GetNotificationBadgeCount_result record
to_GetNotificationBadgeCount_result :: T.ThriftVal -> GetNotificationBadgeCount_result
to_GetNotificationBadgeCount_result (T.TStruct fields) = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = P.maybe (getNotificationBadgeCount_result_success default_GetNotificationBadgeCount_result) (\(_,_val5314) -> (case _val5314 of {T.TI32 _val5315 -> _val5315; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotificationBadgeCount_result_e = P.maybe (P.Nothing) (\(_,_val5314) -> P.Just (case _val5314 of {T.TStruct _val5316 -> (to_ChannelException (T.TStruct _val5316)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNotificationBadgeCount_result _ = P.error "not a struct"
read_GetNotificationBadgeCount_result :: T.Protocol p => p -> P.IO GetNotificationBadgeCount_result
read_GetNotificationBadgeCount_result iprot = to_GetNotificationBadgeCount_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result)
decode_GetNotificationBadgeCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationBadgeCount_result
decode_GetNotificationBadgeCount_result iprot bs = to_GetNotificationBadgeCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationBadgeCount_result) bs
typemap_GetNotificationBadgeCount_result :: T.TypeMap
typemap_GetNotificationBadgeCount_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetNotificationBadgeCount_result :: GetNotificationBadgeCount_result
default_GetNotificationBadgeCount_result = GetNotificationBadgeCount_result{
  getNotificationBadgeCount_result_success = 0,
  getNotificationBadgeCount_result_e = P.Nothing}
data IssueChannelToken_args = IssueChannelToken_args  { issueChannelToken_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_args_channelId record  
instance QC.Arbitrary IssueChannelToken_args where 
  arbitrary = M.liftM IssueChannelToken_args (QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueChannelToken_args{issueChannelToken_args_channelId = issueChannelToken_args_channelId obj}
    ]
from_IssueChannelToken_args :: IssueChannelToken_args -> T.ThriftVal
from_IssueChannelToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5319 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5319))) $ issueChannelToken_args_channelId record
  ]
write_IssueChannelToken_args :: T.Protocol p => p -> IssueChannelToken_args -> P.IO ()
write_IssueChannelToken_args oprot record = T.writeVal oprot $ from_IssueChannelToken_args record
encode_IssueChannelToken_args :: T.StatelessProtocol p => p -> IssueChannelToken_args -> LBS.ByteString
encode_IssueChannelToken_args oprot record = T.serializeVal oprot $ from_IssueChannelToken_args record
to_IssueChannelToken_args :: T.ThriftVal -> IssueChannelToken_args
to_IssueChannelToken_args (T.TStruct fields) = IssueChannelToken_args{
  issueChannelToken_args_channelId = P.maybe (issueChannelToken_args_channelId default_IssueChannelToken_args) (\(_,_val5321) -> (case _val5321 of {T.TString _val5322 -> E.decodeUtf8 _val5322; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_args _ = P.error "not a struct"
read_IssueChannelToken_args :: T.Protocol p => p -> P.IO IssueChannelToken_args
read_IssueChannelToken_args iprot = to_IssueChannelToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_args)
decode_IssueChannelToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_args
decode_IssueChannelToken_args iprot bs = to_IssueChannelToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_args) bs
typemap_IssueChannelToken_args :: T.TypeMap
typemap_IssueChannelToken_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_IssueChannelToken_args :: IssueChannelToken_args
default_IssueChannelToken_args = IssueChannelToken_args{
  issueChannelToken_args_channelId = ""}
data IssueChannelToken_result = IssueChannelToken_result  { issueChannelToken_result_success :: ChannelToken
  , issueChannelToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueChannelToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueChannelToken_result_success record   `H.hashWithSalt` issueChannelToken_result_e record  
instance QC.Arbitrary IssueChannelToken_result where 
  arbitrary = M.liftM IssueChannelToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueChannelToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_success = issueChannelToken_result_success obj}
    , if obj == default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj} then P.Nothing else P.Just $ default_IssueChannelToken_result{issueChannelToken_result_e = issueChannelToken_result_e obj}
    ]
from_IssueChannelToken_result :: IssueChannelToken_result -> T.ThriftVal
from_IssueChannelToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5325 -> (1, ("e",from_ChannelException _v5325))) <$> issueChannelToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5325 -> P.Just (0, ("success",from_ChannelToken _v5325))) $ issueChannelToken_result_success record
    , (\_v5325 -> (1, ("e",from_ChannelException _v5325))) <$> issueChannelToken_result_e record
    ]
    )
write_IssueChannelToken_result :: T.Protocol p => p -> IssueChannelToken_result -> P.IO ()
write_IssueChannelToken_result oprot record = T.writeVal oprot $ from_IssueChannelToken_result record
encode_IssueChannelToken_result :: T.StatelessProtocol p => p -> IssueChannelToken_result -> LBS.ByteString
encode_IssueChannelToken_result oprot record = T.serializeVal oprot $ from_IssueChannelToken_result record
to_IssueChannelToken_result :: T.ThriftVal -> IssueChannelToken_result
to_IssueChannelToken_result (T.TStruct fields) = IssueChannelToken_result{
  issueChannelToken_result_success = P.maybe (issueChannelToken_result_success default_IssueChannelToken_result) (\(_,_val5327) -> (case _val5327 of {T.TStruct _val5328 -> (to_ChannelToken (T.TStruct _val5328)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueChannelToken_result_e = P.maybe (P.Nothing) (\(_,_val5327) -> P.Just (case _val5327 of {T.TStruct _val5329 -> (to_ChannelException (T.TStruct _val5329)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueChannelToken_result _ = P.error "not a struct"
read_IssueChannelToken_result :: T.Protocol p => p -> P.IO IssueChannelToken_result
read_IssueChannelToken_result iprot = to_IssueChannelToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueChannelToken_result)
decode_IssueChannelToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueChannelToken_result
decode_IssueChannelToken_result iprot bs = to_IssueChannelToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueChannelToken_result) bs
typemap_IssueChannelToken_result :: T.TypeMap
typemap_IssueChannelToken_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelToken))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueChannelToken_result :: IssueChannelToken_result
default_IssueChannelToken_result = IssueChannelToken_result{
  issueChannelToken_result_success = default_ChannelToken,
  issueChannelToken_result_e = P.Nothing}
data IssueRequestToken_args = IssueRequestToken_args  { issueRequestToken_args_channelId :: LT.Text
  , issueRequestToken_args_otpId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_args_channelId record   `H.hashWithSalt` issueRequestToken_args_otpId record  
instance QC.Arbitrary IssueRequestToken_args where 
  arbitrary = M.liftM IssueRequestToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_channelId = issueRequestToken_args_channelId obj}
    , if obj == default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestToken_args{issueRequestToken_args_otpId = issueRequestToken_args_otpId obj}
    ]
from_IssueRequestToken_args :: IssueRequestToken_args -> T.ThriftVal
from_IssueRequestToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5332 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5332))) $ issueRequestToken_args_channelId record
  , (\_v5332 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5332))) $ issueRequestToken_args_otpId record
  ]
write_IssueRequestToken_args :: T.Protocol p => p -> IssueRequestToken_args -> P.IO ()
write_IssueRequestToken_args oprot record = T.writeVal oprot $ from_IssueRequestToken_args record
encode_IssueRequestToken_args :: T.StatelessProtocol p => p -> IssueRequestToken_args -> LBS.ByteString
encode_IssueRequestToken_args oprot record = T.serializeVal oprot $ from_IssueRequestToken_args record
to_IssueRequestToken_args :: T.ThriftVal -> IssueRequestToken_args
to_IssueRequestToken_args (T.TStruct fields) = IssueRequestToken_args{
  issueRequestToken_args_channelId = P.maybe (issueRequestToken_args_channelId default_IssueRequestToken_args) (\(_,_val5334) -> (case _val5334 of {T.TString _val5335 -> E.decodeUtf8 _val5335; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestToken_args_otpId = P.maybe (issueRequestToken_args_otpId default_IssueRequestToken_args) (\(_,_val5334) -> (case _val5334 of {T.TString _val5336 -> E.decodeUtf8 _val5336; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueRequestToken_args _ = P.error "not a struct"
read_IssueRequestToken_args :: T.Protocol p => p -> P.IO IssueRequestToken_args
read_IssueRequestToken_args iprot = to_IssueRequestToken_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_args)
decode_IssueRequestToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_args
decode_IssueRequestToken_args iprot bs = to_IssueRequestToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_args) bs
typemap_IssueRequestToken_args :: T.TypeMap
typemap_IssueRequestToken_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING))]
default_IssueRequestToken_args :: IssueRequestToken_args
default_IssueRequestToken_args = IssueRequestToken_args{
  issueRequestToken_args_channelId = "",
  issueRequestToken_args_otpId = ""}
data IssueRequestToken_result = IssueRequestToken_result  { issueRequestToken_result_success :: LT.Text
  , issueRequestToken_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestToken_result_success record   `H.hashWithSalt` issueRequestToken_result_e record  
instance QC.Arbitrary IssueRequestToken_result where 
  arbitrary = M.liftM IssueRequestToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_success = issueRequestToken_result_success obj}
    , if obj == default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj} then P.Nothing else P.Just $ default_IssueRequestToken_result{issueRequestToken_result_e = issueRequestToken_result_e obj}
    ]
from_IssueRequestToken_result :: IssueRequestToken_result -> T.ThriftVal
from_IssueRequestToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5339 -> (1, ("e",from_ChannelException _v5339))) <$> issueRequestToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5339 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5339))) $ issueRequestToken_result_success record
    , (\_v5339 -> (1, ("e",from_ChannelException _v5339))) <$> issueRequestToken_result_e record
    ]
    )
write_IssueRequestToken_result :: T.Protocol p => p -> IssueRequestToken_result -> P.IO ()
write_IssueRequestToken_result oprot record = T.writeVal oprot $ from_IssueRequestToken_result record
encode_IssueRequestToken_result :: T.StatelessProtocol p => p -> IssueRequestToken_result -> LBS.ByteString
encode_IssueRequestToken_result oprot record = T.serializeVal oprot $ from_IssueRequestToken_result record
to_IssueRequestToken_result :: T.ThriftVal -> IssueRequestToken_result
to_IssueRequestToken_result (T.TStruct fields) = IssueRequestToken_result{
  issueRequestToken_result_success = P.maybe (issueRequestToken_result_success default_IssueRequestToken_result) (\(_,_val5341) -> (case _val5341 of {T.TString _val5342 -> E.decodeUtf8 _val5342; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestToken_result_e = P.maybe (P.Nothing) (\(_,_val5341) -> P.Just (case _val5341 of {T.TStruct _val5343 -> (to_ChannelException (T.TStruct _val5343)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestToken_result _ = P.error "not a struct"
read_IssueRequestToken_result :: T.Protocol p => p -> P.IO IssueRequestToken_result
read_IssueRequestToken_result iprot = to_IssueRequestToken_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestToken_result)
decode_IssueRequestToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestToken_result
decode_IssueRequestToken_result iprot bs = to_IssueRequestToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestToken_result) bs
typemap_IssueRequestToken_result :: T.TypeMap
typemap_IssueRequestToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestToken_result :: IssueRequestToken_result
default_IssueRequestToken_result = IssueRequestToken_result{
  issueRequestToken_result_success = "",
  issueRequestToken_result_e = P.Nothing}
data IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args  { issueRequestTokenWithAuthScheme_args_channelId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_otpId :: LT.Text
  , issueRequestTokenWithAuthScheme_args_authScheme :: (Vector.Vector LT.Text)
  , issueRequestTokenWithAuthScheme_args_returnUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_channelId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_otpId record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_authScheme record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_args_returnUrl record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_args where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_channelId = issueRequestTokenWithAuthScheme_args_channelId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_otpId = issueRequestTokenWithAuthScheme_args_otpId obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_authScheme = issueRequestTokenWithAuthScheme_args_authScheme obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_args{issueRequestTokenWithAuthScheme_args_returnUrl = issueRequestTokenWithAuthScheme_args_returnUrl obj}
    ]
from_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5346 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5346))) $ issueRequestTokenWithAuthScheme_args_channelId record
  , (\_v5346 -> P.Just (2, ("otpId",T.TString $ E.encodeUtf8 _v5346))) $ issueRequestTokenWithAuthScheme_args_otpId record
  , (\_v5346 -> P.Just (3, ("authScheme",T.TList T.T_STRING $ P.map (\_v5348 -> T.TString $ E.encodeUtf8 _v5348) $ Vector.toList _v5346))) $ issueRequestTokenWithAuthScheme_args_authScheme record
  , (\_v5346 -> P.Just (4, ("returnUrl",T.TString $ E.encodeUtf8 _v5346))) $ issueRequestTokenWithAuthScheme_args_returnUrl record
  ]
write_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_args -> P.IO ()
write_IssueRequestTokenWithAuthScheme_args oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
encode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_args -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_args oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_args record
to_IssueRequestTokenWithAuthScheme_args :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_args
to_IssueRequestTokenWithAuthScheme_args (T.TStruct fields) = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = P.maybe (issueRequestTokenWithAuthScheme_args_channelId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5350) -> (case _val5350 of {T.TString _val5351 -> E.decodeUtf8 _val5351; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  issueRequestTokenWithAuthScheme_args_otpId = P.maybe (issueRequestTokenWithAuthScheme_args_otpId default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5350) -> (case _val5350 of {T.TString _val5352 -> E.decodeUtf8 _val5352; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  issueRequestTokenWithAuthScheme_args_authScheme = P.maybe (issueRequestTokenWithAuthScheme_args_authScheme default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5350) -> (case _val5350 of {T.TList _ _val5353 -> (Vector.fromList $ P.map (\_v5354 -> (case _v5354 of {T.TString _val5355 -> E.decodeUtf8 _val5355; _ -> P.error "wrong type"})) _val5353); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  issueRequestTokenWithAuthScheme_args_returnUrl = P.maybe (issueRequestTokenWithAuthScheme_args_returnUrl default_IssueRequestTokenWithAuthScheme_args) (\(_,_val5350) -> (case _val5350 of {T.TString _val5356 -> E.decodeUtf8 _val5356; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IssueRequestTokenWithAuthScheme_args _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_args :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_args
read_IssueRequestTokenWithAuthScheme_args iprot = to_IssueRequestTokenWithAuthScheme_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args)
decode_IssueRequestTokenWithAuthScheme_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_args
decode_IssueRequestTokenWithAuthScheme_args iprot bs = to_IssueRequestTokenWithAuthScheme_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_args) bs
typemap_IssueRequestTokenWithAuthScheme_args :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_args = Map.fromList [(1,("channelId",T.T_STRING)),(2,("otpId",T.T_STRING)),(3,("authScheme",(T.T_LIST T.T_STRING))),(4,("returnUrl",T.T_STRING))]
default_IssueRequestTokenWithAuthScheme_args :: IssueRequestTokenWithAuthScheme_args
default_IssueRequestTokenWithAuthScheme_args = IssueRequestTokenWithAuthScheme_args{
  issueRequestTokenWithAuthScheme_args_channelId = "",
  issueRequestTokenWithAuthScheme_args_otpId = "",
  issueRequestTokenWithAuthScheme_args_authScheme = Vector.empty,
  issueRequestTokenWithAuthScheme_args_returnUrl = ""}
data IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result  { issueRequestTokenWithAuthScheme_result_success :: RequestTokenResponse
  , issueRequestTokenWithAuthScheme_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenWithAuthScheme_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_success record   `H.hashWithSalt` issueRequestTokenWithAuthScheme_result_e record  
instance QC.Arbitrary IssueRequestTokenWithAuthScheme_result where 
  arbitrary = M.liftM IssueRequestTokenWithAuthScheme_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenWithAuthScheme_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = issueRequestTokenWithAuthScheme_result_success obj}
    , if obj == default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj} then P.Nothing else P.Just $ default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = issueRequestTokenWithAuthScheme_result_e obj}
    ]
from_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result -> T.ThriftVal
from_IssueRequestTokenWithAuthScheme_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5359 -> (1, ("e",from_ChannelException _v5359))) <$> issueRequestTokenWithAuthScheme_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5359 -> P.Just (0, ("success",from_RequestTokenResponse _v5359))) $ issueRequestTokenWithAuthScheme_result_success record
    , (\_v5359 -> (1, ("e",from_ChannelException _v5359))) <$> issueRequestTokenWithAuthScheme_result_e record
    ]
    )
write_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> IssueRequestTokenWithAuthScheme_result -> P.IO ()
write_IssueRequestTokenWithAuthScheme_result oprot record = T.writeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
encode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> IssueRequestTokenWithAuthScheme_result -> LBS.ByteString
encode_IssueRequestTokenWithAuthScheme_result oprot record = T.serializeVal oprot $ from_IssueRequestTokenWithAuthScheme_result record
to_IssueRequestTokenWithAuthScheme_result :: T.ThriftVal -> IssueRequestTokenWithAuthScheme_result
to_IssueRequestTokenWithAuthScheme_result (T.TStruct fields) = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = P.maybe (issueRequestTokenWithAuthScheme_result_success default_IssueRequestTokenWithAuthScheme_result) (\(_,_val5361) -> (case _val5361 of {T.TStruct _val5362 -> (to_RequestTokenResponse (T.TStruct _val5362)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestTokenWithAuthScheme_result_e = P.maybe (P.Nothing) (\(_,_val5361) -> P.Just (case _val5361 of {T.TStruct _val5363 -> (to_ChannelException (T.TStruct _val5363)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestTokenWithAuthScheme_result _ = P.error "not a struct"
read_IssueRequestTokenWithAuthScheme_result :: T.Protocol p => p -> P.IO IssueRequestTokenWithAuthScheme_result
read_IssueRequestTokenWithAuthScheme_result iprot = to_IssueRequestTokenWithAuthScheme_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result)
decode_IssueRequestTokenWithAuthScheme_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenWithAuthScheme_result
decode_IssueRequestTokenWithAuthScheme_result iprot bs = to_IssueRequestTokenWithAuthScheme_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenWithAuthScheme_result) bs
typemap_IssueRequestTokenWithAuthScheme_result :: T.TypeMap
typemap_IssueRequestTokenWithAuthScheme_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RequestTokenResponse))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestTokenWithAuthScheme_result :: IssueRequestTokenWithAuthScheme_result
default_IssueRequestTokenWithAuthScheme_result = IssueRequestTokenWithAuthScheme_result{
  issueRequestTokenWithAuthScheme_result_success = default_RequestTokenResponse,
  issueRequestTokenWithAuthScheme_result_e = P.Nothing}
data IssueRequestTokenForAutoLogin_args = IssueRequestTokenForAutoLogin_args  { issueRequestTokenForAutoLogin_args_channelId :: LT.Text
  , issueRequestTokenForAutoLogin_args_otpId :: LT.Text
  , issueRequestTokenForAutoLogin_args_redirectUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenForAutoLogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_channelId record   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_otpId record   `H.hashWithSalt` issueRequestTokenForAutoLogin_args_redirectUrl record  
instance QC.Arbitrary IssueRequestTokenForAutoLogin_args where 
  arbitrary = M.liftM IssueRequestTokenForAutoLogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenForAutoLogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_channelId = issueRequestTokenForAutoLogin_args_channelId obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_channelId = issueRequestTokenForAutoLogin_args_channelId obj}
    , if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_otpId = issueRequestTokenForAutoLogin_args_otpId obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_otpId = issueRequestTokenForAutoLogin_args_otpId obj}
    , if obj == default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_redirectUrl = issueRequestTokenForAutoLogin_args_redirectUrl obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_args{issueRequestTokenForAutoLogin_args_redirectUrl = issueRequestTokenForAutoLogin_args_redirectUrl obj}
    ]
from_IssueRequestTokenForAutoLogin_args :: IssueRequestTokenForAutoLogin_args -> T.ThriftVal
from_IssueRequestTokenForAutoLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5366 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v5366))) $ issueRequestTokenForAutoLogin_args_channelId record
  , (\_v5366 -> P.Just (3, ("otpId",T.TString $ E.encodeUtf8 _v5366))) $ issueRequestTokenForAutoLogin_args_otpId record
  , (\_v5366 -> P.Just (4, ("redirectUrl",T.TString $ E.encodeUtf8 _v5366))) $ issueRequestTokenForAutoLogin_args_redirectUrl record
  ]
write_IssueRequestTokenForAutoLogin_args :: T.Protocol p => p -> IssueRequestTokenForAutoLogin_args -> P.IO ()
write_IssueRequestTokenForAutoLogin_args oprot record = T.writeVal oprot $ from_IssueRequestTokenForAutoLogin_args record
encode_IssueRequestTokenForAutoLogin_args :: T.StatelessProtocol p => p -> IssueRequestTokenForAutoLogin_args -> LBS.ByteString
encode_IssueRequestTokenForAutoLogin_args oprot record = T.serializeVal oprot $ from_IssueRequestTokenForAutoLogin_args record
to_IssueRequestTokenForAutoLogin_args :: T.ThriftVal -> IssueRequestTokenForAutoLogin_args
to_IssueRequestTokenForAutoLogin_args (T.TStruct fields) = IssueRequestTokenForAutoLogin_args{
  issueRequestTokenForAutoLogin_args_channelId = P.maybe (issueRequestTokenForAutoLogin_args_channelId default_IssueRequestTokenForAutoLogin_args) (\(_,_val5368) -> (case _val5368 of {T.TString _val5369 -> E.decodeUtf8 _val5369; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  issueRequestTokenForAutoLogin_args_otpId = P.maybe (issueRequestTokenForAutoLogin_args_otpId default_IssueRequestTokenForAutoLogin_args) (\(_,_val5368) -> (case _val5368 of {T.TString _val5370 -> E.decodeUtf8 _val5370; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  issueRequestTokenForAutoLogin_args_redirectUrl = P.maybe (issueRequestTokenForAutoLogin_args_redirectUrl default_IssueRequestTokenForAutoLogin_args) (\(_,_val5368) -> (case _val5368 of {T.TString _val5371 -> E.decodeUtf8 _val5371; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_IssueRequestTokenForAutoLogin_args _ = P.error "not a struct"
read_IssueRequestTokenForAutoLogin_args :: T.Protocol p => p -> P.IO IssueRequestTokenForAutoLogin_args
read_IssueRequestTokenForAutoLogin_args iprot = to_IssueRequestTokenForAutoLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_args)
decode_IssueRequestTokenForAutoLogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenForAutoLogin_args
decode_IssueRequestTokenForAutoLogin_args iprot bs = to_IssueRequestTokenForAutoLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_args) bs
typemap_IssueRequestTokenForAutoLogin_args :: T.TypeMap
typemap_IssueRequestTokenForAutoLogin_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("otpId",T.T_STRING)),(4,("redirectUrl",T.T_STRING))]
default_IssueRequestTokenForAutoLogin_args :: IssueRequestTokenForAutoLogin_args
default_IssueRequestTokenForAutoLogin_args = IssueRequestTokenForAutoLogin_args{
  issueRequestTokenForAutoLogin_args_channelId = "",
  issueRequestTokenForAutoLogin_args_otpId = "",
  issueRequestTokenForAutoLogin_args_redirectUrl = ""}
data IssueRequestTokenForAutoLogin_result = IssueRequestTokenForAutoLogin_result  { issueRequestTokenForAutoLogin_result_success :: LT.Text
  , issueRequestTokenForAutoLogin_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueRequestTokenForAutoLogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueRequestTokenForAutoLogin_result_success record   `H.hashWithSalt` issueRequestTokenForAutoLogin_result_e record  
instance QC.Arbitrary IssueRequestTokenForAutoLogin_result where 
  arbitrary = M.liftM IssueRequestTokenForAutoLogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueRequestTokenForAutoLogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = issueRequestTokenForAutoLogin_result_success obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = issueRequestTokenForAutoLogin_result_success obj}
    , if obj == default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = issueRequestTokenForAutoLogin_result_e obj} then P.Nothing else P.Just $ default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = issueRequestTokenForAutoLogin_result_e obj}
    ]
from_IssueRequestTokenForAutoLogin_result :: IssueRequestTokenForAutoLogin_result -> T.ThriftVal
from_IssueRequestTokenForAutoLogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5374 -> (1, ("e",from_ChannelException _v5374))) <$> issueRequestTokenForAutoLogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5374 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5374))) $ issueRequestTokenForAutoLogin_result_success record
    , (\_v5374 -> (1, ("e",from_ChannelException _v5374))) <$> issueRequestTokenForAutoLogin_result_e record
    ]
    )
write_IssueRequestTokenForAutoLogin_result :: T.Protocol p => p -> IssueRequestTokenForAutoLogin_result -> P.IO ()
write_IssueRequestTokenForAutoLogin_result oprot record = T.writeVal oprot $ from_IssueRequestTokenForAutoLogin_result record
encode_IssueRequestTokenForAutoLogin_result :: T.StatelessProtocol p => p -> IssueRequestTokenForAutoLogin_result -> LBS.ByteString
encode_IssueRequestTokenForAutoLogin_result oprot record = T.serializeVal oprot $ from_IssueRequestTokenForAutoLogin_result record
to_IssueRequestTokenForAutoLogin_result :: T.ThriftVal -> IssueRequestTokenForAutoLogin_result
to_IssueRequestTokenForAutoLogin_result (T.TStruct fields) = IssueRequestTokenForAutoLogin_result{
  issueRequestTokenForAutoLogin_result_success = P.maybe (issueRequestTokenForAutoLogin_result_success default_IssueRequestTokenForAutoLogin_result) (\(_,_val5376) -> (case _val5376 of {T.TString _val5377 -> E.decodeUtf8 _val5377; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueRequestTokenForAutoLogin_result_e = P.maybe (P.Nothing) (\(_,_val5376) -> P.Just (case _val5376 of {T.TStruct _val5378 -> (to_ChannelException (T.TStruct _val5378)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueRequestTokenForAutoLogin_result _ = P.error "not a struct"
read_IssueRequestTokenForAutoLogin_result :: T.Protocol p => p -> P.IO IssueRequestTokenForAutoLogin_result
read_IssueRequestTokenForAutoLogin_result iprot = to_IssueRequestTokenForAutoLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_result)
decode_IssueRequestTokenForAutoLogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueRequestTokenForAutoLogin_result
decode_IssueRequestTokenForAutoLogin_result iprot bs = to_IssueRequestTokenForAutoLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueRequestTokenForAutoLogin_result) bs
typemap_IssueRequestTokenForAutoLogin_result :: T.TypeMap
typemap_IssueRequestTokenForAutoLogin_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_IssueRequestTokenForAutoLogin_result :: IssueRequestTokenForAutoLogin_result
default_IssueRequestTokenForAutoLogin_result = IssueRequestTokenForAutoLogin_result{
  issueRequestTokenForAutoLogin_result_success = "",
  issueRequestTokenForAutoLogin_result_e = P.Nothing}
data GetUpdatedChannelIds_args = GetUpdatedChannelIds_args  { getUpdatedChannelIds_args_channelIds :: (Vector.Vector ChannelIdWithLastUpdated)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUpdatedChannelIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUpdatedChannelIds_args_channelIds record  
instance QC.Arbitrary GetUpdatedChannelIds_args where 
  arbitrary = M.liftM GetUpdatedChannelIds_args (QC.arbitrary)
  shrink obj | obj == default_GetUpdatedChannelIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUpdatedChannelIds_args{getUpdatedChannelIds_args_channelIds = getUpdatedChannelIds_args_channelIds obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_args{getUpdatedChannelIds_args_channelIds = getUpdatedChannelIds_args_channelIds obj}
    ]
from_GetUpdatedChannelIds_args :: GetUpdatedChannelIds_args -> T.ThriftVal
from_GetUpdatedChannelIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5381 -> P.Just (1, ("channelIds",T.TList (T.T_STRUCT typemap_ChannelIdWithLastUpdated) $ P.map (\_v5383 -> from_ChannelIdWithLastUpdated _v5383) $ Vector.toList _v5381))) $ getUpdatedChannelIds_args_channelIds record
  ]
write_GetUpdatedChannelIds_args :: T.Protocol p => p -> GetUpdatedChannelIds_args -> P.IO ()
write_GetUpdatedChannelIds_args oprot record = T.writeVal oprot $ from_GetUpdatedChannelIds_args record
encode_GetUpdatedChannelIds_args :: T.StatelessProtocol p => p -> GetUpdatedChannelIds_args -> LBS.ByteString
encode_GetUpdatedChannelIds_args oprot record = T.serializeVal oprot $ from_GetUpdatedChannelIds_args record
to_GetUpdatedChannelIds_args :: T.ThriftVal -> GetUpdatedChannelIds_args
to_GetUpdatedChannelIds_args (T.TStruct fields) = GetUpdatedChannelIds_args{
  getUpdatedChannelIds_args_channelIds = P.maybe (getUpdatedChannelIds_args_channelIds default_GetUpdatedChannelIds_args) (\(_,_val5385) -> (case _val5385 of {T.TList _ _val5386 -> (Vector.fromList $ P.map (\_v5387 -> (case _v5387 of {T.TStruct _val5388 -> (to_ChannelIdWithLastUpdated (T.TStruct _val5388)); _ -> P.error "wrong type"})) _val5386); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUpdatedChannelIds_args _ = P.error "not a struct"
read_GetUpdatedChannelIds_args :: T.Protocol p => p -> P.IO GetUpdatedChannelIds_args
read_GetUpdatedChannelIds_args iprot = to_GetUpdatedChannelIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_args)
decode_GetUpdatedChannelIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUpdatedChannelIds_args
decode_GetUpdatedChannelIds_args iprot bs = to_GetUpdatedChannelIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_args) bs
typemap_GetUpdatedChannelIds_args :: T.TypeMap
typemap_GetUpdatedChannelIds_args = Map.fromList [(1,("channelIds",(T.T_LIST (T.T_STRUCT typemap_ChannelIdWithLastUpdated))))]
default_GetUpdatedChannelIds_args :: GetUpdatedChannelIds_args
default_GetUpdatedChannelIds_args = GetUpdatedChannelIds_args{
  getUpdatedChannelIds_args_channelIds = Vector.empty}
data GetUpdatedChannelIds_result = GetUpdatedChannelIds_result  { getUpdatedChannelIds_result_success :: (Vector.Vector LT.Text)
  , getUpdatedChannelIds_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUpdatedChannelIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUpdatedChannelIds_result_success record   `H.hashWithSalt` getUpdatedChannelIds_result_e record  
instance QC.Arbitrary GetUpdatedChannelIds_result where 
  arbitrary = M.liftM GetUpdatedChannelIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUpdatedChannelIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = getUpdatedChannelIds_result_success obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = getUpdatedChannelIds_result_success obj}
    , if obj == default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = getUpdatedChannelIds_result_e obj} then P.Nothing else P.Just $ default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = getUpdatedChannelIds_result_e obj}
    ]
from_GetUpdatedChannelIds_result :: GetUpdatedChannelIds_result -> T.ThriftVal
from_GetUpdatedChannelIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5391 -> (1, ("e",from_ChannelException _v5391))) <$> getUpdatedChannelIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5391 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v5393 -> T.TString $ E.encodeUtf8 _v5393) $ Vector.toList _v5391))) $ getUpdatedChannelIds_result_success record
    , (\_v5391 -> (1, ("e",from_ChannelException _v5391))) <$> getUpdatedChannelIds_result_e record
    ]
    )
write_GetUpdatedChannelIds_result :: T.Protocol p => p -> GetUpdatedChannelIds_result -> P.IO ()
write_GetUpdatedChannelIds_result oprot record = T.writeVal oprot $ from_GetUpdatedChannelIds_result record
encode_GetUpdatedChannelIds_result :: T.StatelessProtocol p => p -> GetUpdatedChannelIds_result -> LBS.ByteString
encode_GetUpdatedChannelIds_result oprot record = T.serializeVal oprot $ from_GetUpdatedChannelIds_result record
to_GetUpdatedChannelIds_result :: T.ThriftVal -> GetUpdatedChannelIds_result
to_GetUpdatedChannelIds_result (T.TStruct fields) = GetUpdatedChannelIds_result{
  getUpdatedChannelIds_result_success = P.maybe (getUpdatedChannelIds_result_success default_GetUpdatedChannelIds_result) (\(_,_val5395) -> (case _val5395 of {T.TList _ _val5396 -> (Vector.fromList $ P.map (\_v5397 -> (case _v5397 of {T.TString _val5398 -> E.decodeUtf8 _val5398; _ -> P.error "wrong type"})) _val5396); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUpdatedChannelIds_result_e = P.maybe (P.Nothing) (\(_,_val5395) -> P.Just (case _val5395 of {T.TStruct _val5399 -> (to_ChannelException (T.TStruct _val5399)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUpdatedChannelIds_result _ = P.error "not a struct"
read_GetUpdatedChannelIds_result :: T.Protocol p => p -> P.IO GetUpdatedChannelIds_result
read_GetUpdatedChannelIds_result iprot = to_GetUpdatedChannelIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_result)
decode_GetUpdatedChannelIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUpdatedChannelIds_result
decode_GetUpdatedChannelIds_result iprot bs = to_GetUpdatedChannelIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUpdatedChannelIds_result) bs
typemap_GetUpdatedChannelIds_result :: T.TypeMap
typemap_GetUpdatedChannelIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_GetUpdatedChannelIds_result :: GetUpdatedChannelIds_result
default_GetUpdatedChannelIds_result = GetUpdatedChannelIds_result{
  getUpdatedChannelIds_result_success = Vector.empty,
  getUpdatedChannelIds_result_e = P.Nothing}
data ReserveCoinUse_args = ReserveCoinUse_args  { reserveCoinUse_args_request :: CoinUseReservation
  , reserveCoinUse_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_args_request record   `H.hashWithSalt` reserveCoinUse_args_locale record  
instance QC.Arbitrary ReserveCoinUse_args where 
  arbitrary = M.liftM ReserveCoinUse_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_request = reserveCoinUse_args_request obj}
    , if obj == default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj} then P.Nothing else P.Just $ default_ReserveCoinUse_args{reserveCoinUse_args_locale = reserveCoinUse_args_locale obj}
    ]
from_ReserveCoinUse_args :: ReserveCoinUse_args -> T.ThriftVal
from_ReserveCoinUse_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5402 -> P.Just (2, ("request",from_CoinUseReservation _v5402))) $ reserveCoinUse_args_request record
  , (\_v5402 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5402))) $ reserveCoinUse_args_locale record
  ]
write_ReserveCoinUse_args :: T.Protocol p => p -> ReserveCoinUse_args -> P.IO ()
write_ReserveCoinUse_args oprot record = T.writeVal oprot $ from_ReserveCoinUse_args record
encode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> ReserveCoinUse_args -> LBS.ByteString
encode_ReserveCoinUse_args oprot record = T.serializeVal oprot $ from_ReserveCoinUse_args record
to_ReserveCoinUse_args :: T.ThriftVal -> ReserveCoinUse_args
to_ReserveCoinUse_args (T.TStruct fields) = ReserveCoinUse_args{
  reserveCoinUse_args_request = P.maybe (reserveCoinUse_args_request default_ReserveCoinUse_args) (\(_,_val5404) -> (case _val5404 of {T.TStruct _val5405 -> (to_CoinUseReservation (T.TStruct _val5405)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reserveCoinUse_args_locale = P.maybe (reserveCoinUse_args_locale default_ReserveCoinUse_args) (\(_,_val5404) -> (case _val5404 of {T.TString _val5406 -> E.decodeUtf8 _val5406; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReserveCoinUse_args _ = P.error "not a struct"
read_ReserveCoinUse_args :: T.Protocol p => p -> P.IO ReserveCoinUse_args
read_ReserveCoinUse_args iprot = to_ReserveCoinUse_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args)
decode_ReserveCoinUse_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_args
decode_ReserveCoinUse_args iprot bs = to_ReserveCoinUse_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_args) bs
typemap_ReserveCoinUse_args :: T.TypeMap
typemap_ReserveCoinUse_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinUseReservation))),(3,("locale",T.T_STRING))]
default_ReserveCoinUse_args :: ReserveCoinUse_args
default_ReserveCoinUse_args = ReserveCoinUse_args{
  reserveCoinUse_args_request = default_CoinUseReservation,
  reserveCoinUse_args_locale = ""}
data ReserveCoinUse_result = ReserveCoinUse_result  { reserveCoinUse_result_success :: LT.Text
  , reserveCoinUse_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinUse_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinUse_result_success record   `H.hashWithSalt` reserveCoinUse_result_e record  
instance QC.Arbitrary ReserveCoinUse_result where 
  arbitrary = M.liftM ReserveCoinUse_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCoinUse_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_success = reserveCoinUse_result_success obj}
    , if obj == default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj} then P.Nothing else P.Just $ default_ReserveCoinUse_result{reserveCoinUse_result_e = reserveCoinUse_result_e obj}
    ]
from_ReserveCoinUse_result :: ReserveCoinUse_result -> T.ThriftVal
from_ReserveCoinUse_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5409 -> (1, ("e",from_ChannelException _v5409))) <$> reserveCoinUse_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5409 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5409))) $ reserveCoinUse_result_success record
    , (\_v5409 -> (1, ("e",from_ChannelException _v5409))) <$> reserveCoinUse_result_e record
    ]
    )
write_ReserveCoinUse_result :: T.Protocol p => p -> ReserveCoinUse_result -> P.IO ()
write_ReserveCoinUse_result oprot record = T.writeVal oprot $ from_ReserveCoinUse_result record
encode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> ReserveCoinUse_result -> LBS.ByteString
encode_ReserveCoinUse_result oprot record = T.serializeVal oprot $ from_ReserveCoinUse_result record
to_ReserveCoinUse_result :: T.ThriftVal -> ReserveCoinUse_result
to_ReserveCoinUse_result (T.TStruct fields) = ReserveCoinUse_result{
  reserveCoinUse_result_success = P.maybe (reserveCoinUse_result_success default_ReserveCoinUse_result) (\(_,_val5411) -> (case _val5411 of {T.TString _val5412 -> E.decodeUtf8 _val5412; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCoinUse_result_e = P.maybe (P.Nothing) (\(_,_val5411) -> P.Just (case _val5411 of {T.TStruct _val5413 -> (to_ChannelException (T.TStruct _val5413)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCoinUse_result _ = P.error "not a struct"
read_ReserveCoinUse_result :: T.Protocol p => p -> P.IO ReserveCoinUse_result
read_ReserveCoinUse_result iprot = to_ReserveCoinUse_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result)
decode_ReserveCoinUse_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinUse_result
decode_ReserveCoinUse_result iprot bs = to_ReserveCoinUse_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinUse_result) bs
typemap_ReserveCoinUse_result :: T.TypeMap
typemap_ReserveCoinUse_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_ReserveCoinUse_result :: ReserveCoinUse_result
default_ReserveCoinUse_result = ReserveCoinUse_result{
  reserveCoinUse_result_success = "",
  reserveCoinUse_result_e = P.Nothing}
data RevokeChannel_args = RevokeChannel_args  { revokeChannel_args_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_args_channelId record  
instance QC.Arbitrary RevokeChannel_args where 
  arbitrary = M.liftM RevokeChannel_args (QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj} then P.Nothing else P.Just $ default_RevokeChannel_args{revokeChannel_args_channelId = revokeChannel_args_channelId obj}
    ]
from_RevokeChannel_args :: RevokeChannel_args -> T.ThriftVal
from_RevokeChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5416 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v5416))) $ revokeChannel_args_channelId record
  ]
write_RevokeChannel_args :: T.Protocol p => p -> RevokeChannel_args -> P.IO ()
write_RevokeChannel_args oprot record = T.writeVal oprot $ from_RevokeChannel_args record
encode_RevokeChannel_args :: T.StatelessProtocol p => p -> RevokeChannel_args -> LBS.ByteString
encode_RevokeChannel_args oprot record = T.serializeVal oprot $ from_RevokeChannel_args record
to_RevokeChannel_args :: T.ThriftVal -> RevokeChannel_args
to_RevokeChannel_args (T.TStruct fields) = RevokeChannel_args{
  revokeChannel_args_channelId = P.maybe (revokeChannel_args_channelId default_RevokeChannel_args) (\(_,_val5418) -> (case _val5418 of {T.TString _val5419 -> E.decodeUtf8 _val5419; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_args _ = P.error "not a struct"
read_RevokeChannel_args :: T.Protocol p => p -> P.IO RevokeChannel_args
read_RevokeChannel_args iprot = to_RevokeChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_args)
decode_RevokeChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_args
decode_RevokeChannel_args iprot bs = to_RevokeChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_args) bs
typemap_RevokeChannel_args :: T.TypeMap
typemap_RevokeChannel_args = Map.fromList [(1,("channelId",T.T_STRING))]
default_RevokeChannel_args :: RevokeChannel_args
default_RevokeChannel_args = RevokeChannel_args{
  revokeChannel_args_channelId = ""}
data RevokeChannel_result = RevokeChannel_result  { revokeChannel_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeChannel_result_e record  
instance QC.Arbitrary RevokeChannel_result where 
  arbitrary = M.liftM RevokeChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RevokeChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj} then P.Nothing else P.Just $ default_RevokeChannel_result{revokeChannel_result_e = revokeChannel_result_e obj}
    ]
from_RevokeChannel_result :: RevokeChannel_result -> T.ThriftVal
from_RevokeChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5422 -> (1, ("e",from_ChannelException _v5422))) <$> revokeChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5422 -> (1, ("e",from_ChannelException _v5422))) <$> revokeChannel_result_e record
    ]
    )
write_RevokeChannel_result :: T.Protocol p => p -> RevokeChannel_result -> P.IO ()
write_RevokeChannel_result oprot record = T.writeVal oprot $ from_RevokeChannel_result record
encode_RevokeChannel_result :: T.StatelessProtocol p => p -> RevokeChannel_result -> LBS.ByteString
encode_RevokeChannel_result oprot record = T.serializeVal oprot $ from_RevokeChannel_result record
to_RevokeChannel_result :: T.ThriftVal -> RevokeChannel_result
to_RevokeChannel_result (T.TStruct fields) = RevokeChannel_result{
  revokeChannel_result_e = P.maybe (P.Nothing) (\(_,_val5424) -> P.Just (case _val5424 of {T.TStruct _val5425 -> (to_ChannelException (T.TStruct _val5425)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeChannel_result _ = P.error "not a struct"
read_RevokeChannel_result :: T.Protocol p => p -> P.IO RevokeChannel_result
read_RevokeChannel_result iprot = to_RevokeChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_RevokeChannel_result)
decode_RevokeChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeChannel_result
decode_RevokeChannel_result iprot bs = to_RevokeChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeChannel_result) bs
typemap_RevokeChannel_result :: T.TypeMap
typemap_RevokeChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_RevokeChannel_result :: RevokeChannel_result
default_RevokeChannel_result = RevokeChannel_result{
  revokeChannel_result_e = P.Nothing}
data SyncChannelData_args = SyncChannelData_args  { syncChannelData_args_lastSynced :: I.Int64
  , syncChannelData_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_args_lastSynced record   `H.hashWithSalt` syncChannelData_args_locale record  
instance QC.Arbitrary SyncChannelData_args where 
  arbitrary = M.liftM SyncChannelData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_lastSynced = syncChannelData_args_lastSynced obj}
    , if obj == default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj} then P.Nothing else P.Just $ default_SyncChannelData_args{syncChannelData_args_locale = syncChannelData_args_locale obj}
    ]
from_SyncChannelData_args :: SyncChannelData_args -> T.ThriftVal
from_SyncChannelData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5428 -> P.Just (2, ("lastSynced",T.TI64 _v5428))) $ syncChannelData_args_lastSynced record
  , (\_v5428 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v5428))) $ syncChannelData_args_locale record
  ]
write_SyncChannelData_args :: T.Protocol p => p -> SyncChannelData_args -> P.IO ()
write_SyncChannelData_args oprot record = T.writeVal oprot $ from_SyncChannelData_args record
encode_SyncChannelData_args :: T.StatelessProtocol p => p -> SyncChannelData_args -> LBS.ByteString
encode_SyncChannelData_args oprot record = T.serializeVal oprot $ from_SyncChannelData_args record
to_SyncChannelData_args :: T.ThriftVal -> SyncChannelData_args
to_SyncChannelData_args (T.TStruct fields) = SyncChannelData_args{
  syncChannelData_args_lastSynced = P.maybe (syncChannelData_args_lastSynced default_SyncChannelData_args) (\(_,_val5430) -> (case _val5430 of {T.TI64 _val5431 -> _val5431; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncChannelData_args_locale = P.maybe (syncChannelData_args_locale default_SyncChannelData_args) (\(_,_val5430) -> (case _val5430 of {T.TString _val5432 -> E.decodeUtf8 _val5432; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SyncChannelData_args _ = P.error "not a struct"
read_SyncChannelData_args :: T.Protocol p => p -> P.IO SyncChannelData_args
read_SyncChannelData_args iprot = to_SyncChannelData_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_args)
decode_SyncChannelData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_args
decode_SyncChannelData_args iprot bs = to_SyncChannelData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_args) bs
typemap_SyncChannelData_args :: T.TypeMap
typemap_SyncChannelData_args = Map.fromList [(2,("lastSynced",T.T_I64)),(3,("locale",T.T_STRING))]
default_SyncChannelData_args :: SyncChannelData_args
default_SyncChannelData_args = SyncChannelData_args{
  syncChannelData_args_lastSynced = 0,
  syncChannelData_args_locale = ""}
data SyncChannelData_result = SyncChannelData_result  { syncChannelData_result_success :: ChannelSyncDatas
  , syncChannelData_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChannelData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChannelData_result_success record   `H.hashWithSalt` syncChannelData_result_e record  
instance QC.Arbitrary SyncChannelData_result where 
  arbitrary = M.liftM SyncChannelData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncChannelData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_success = syncChannelData_result_success obj}
    , if obj == default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj} then P.Nothing else P.Just $ default_SyncChannelData_result{syncChannelData_result_e = syncChannelData_result_e obj}
    ]
from_SyncChannelData_result :: SyncChannelData_result -> T.ThriftVal
from_SyncChannelData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5435 -> (1, ("e",from_ChannelException _v5435))) <$> syncChannelData_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5435 -> P.Just (0, ("success",from_ChannelSyncDatas _v5435))) $ syncChannelData_result_success record
    , (\_v5435 -> (1, ("e",from_ChannelException _v5435))) <$> syncChannelData_result_e record
    ]
    )
write_SyncChannelData_result :: T.Protocol p => p -> SyncChannelData_result -> P.IO ()
write_SyncChannelData_result oprot record = T.writeVal oprot $ from_SyncChannelData_result record
encode_SyncChannelData_result :: T.StatelessProtocol p => p -> SyncChannelData_result -> LBS.ByteString
encode_SyncChannelData_result oprot record = T.serializeVal oprot $ from_SyncChannelData_result record
to_SyncChannelData_result :: T.ThriftVal -> SyncChannelData_result
to_SyncChannelData_result (T.TStruct fields) = SyncChannelData_result{
  syncChannelData_result_success = P.maybe (syncChannelData_result_success default_SyncChannelData_result) (\(_,_val5437) -> (case _val5437 of {T.TStruct _val5438 -> (to_ChannelSyncDatas (T.TStruct _val5438)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncChannelData_result_e = P.maybe (P.Nothing) (\(_,_val5437) -> P.Just (case _val5437 of {T.TStruct _val5439 -> (to_ChannelException (T.TStruct _val5439)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncChannelData_result _ = P.error "not a struct"
read_SyncChannelData_result :: T.Protocol p => p -> P.IO SyncChannelData_result
read_SyncChannelData_result iprot = to_SyncChannelData_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncChannelData_result)
decode_SyncChannelData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChannelData_result
decode_SyncChannelData_result iprot bs = to_SyncChannelData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChannelData_result) bs
typemap_SyncChannelData_result :: T.TypeMap
typemap_SyncChannelData_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChannelSyncDatas))),(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_SyncChannelData_result :: SyncChannelData_result
default_SyncChannelData_result = SyncChannelData_result{
  syncChannelData_result_success = default_ChannelSyncDatas,
  syncChannelData_result_e = P.Nothing}
data UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args  { updateChannelNotificationSetting_args_setting :: (Vector.Vector ChannelNotificationSetting)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_args_setting record  
instance QC.Arbitrary UpdateChannelNotificationSetting_args where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_args (QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_args{updateChannelNotificationSetting_args_setting = updateChannelNotificationSetting_args_setting obj}
    ]
from_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args -> T.ThriftVal
from_UpdateChannelNotificationSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5442 -> P.Just (1, ("setting",T.TList (T.T_STRUCT typemap_ChannelNotificationSetting) $ P.map (\_v5444 -> from_ChannelNotificationSetting _v5444) $ Vector.toList _v5442))) $ updateChannelNotificationSetting_args_setting record
  ]
write_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> UpdateChannelNotificationSetting_args -> P.IO ()
write_UpdateChannelNotificationSetting_args oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_args record
encode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_args -> LBS.ByteString
encode_UpdateChannelNotificationSetting_args oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_args record
to_UpdateChannelNotificationSetting_args :: T.ThriftVal -> UpdateChannelNotificationSetting_args
to_UpdateChannelNotificationSetting_args (T.TStruct fields) = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = P.maybe (updateChannelNotificationSetting_args_setting default_UpdateChannelNotificationSetting_args) (\(_,_val5446) -> (case _val5446 of {T.TList _ _val5447 -> (Vector.fromList $ P.map (\_v5448 -> (case _v5448 of {T.TStruct _val5449 -> (to_ChannelNotificationSetting (T.TStruct _val5449)); _ -> P.error "wrong type"})) _val5447); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_args _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_args :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_args
read_UpdateChannelNotificationSetting_args iprot = to_UpdateChannelNotificationSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args)
decode_UpdateChannelNotificationSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_args
decode_UpdateChannelNotificationSetting_args iprot bs = to_UpdateChannelNotificationSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_args) bs
typemap_UpdateChannelNotificationSetting_args :: T.TypeMap
typemap_UpdateChannelNotificationSetting_args = Map.fromList [(1,("setting",(T.T_LIST (T.T_STRUCT typemap_ChannelNotificationSetting))))]
default_UpdateChannelNotificationSetting_args :: UpdateChannelNotificationSetting_args
default_UpdateChannelNotificationSetting_args = UpdateChannelNotificationSetting_args{
  updateChannelNotificationSetting_args_setting = Vector.empty}
data UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result  { updateChannelNotificationSetting_result_e :: P.Maybe ChannelException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateChannelNotificationSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateChannelNotificationSetting_result_e record  
instance QC.Arbitrary UpdateChannelNotificationSetting_result where 
  arbitrary = M.liftM UpdateChannelNotificationSetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateChannelNotificationSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj} then P.Nothing else P.Just $ default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = updateChannelNotificationSetting_result_e obj}
    ]
from_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result -> T.ThriftVal
from_UpdateChannelNotificationSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5452 -> (1, ("e",from_ChannelException _v5452))) <$> updateChannelNotificationSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5452 -> (1, ("e",from_ChannelException _v5452))) <$> updateChannelNotificationSetting_result_e record
    ]
    )
write_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> UpdateChannelNotificationSetting_result -> P.IO ()
write_UpdateChannelNotificationSetting_result oprot record = T.writeVal oprot $ from_UpdateChannelNotificationSetting_result record
encode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> UpdateChannelNotificationSetting_result -> LBS.ByteString
encode_UpdateChannelNotificationSetting_result oprot record = T.serializeVal oprot $ from_UpdateChannelNotificationSetting_result record
to_UpdateChannelNotificationSetting_result :: T.ThriftVal -> UpdateChannelNotificationSetting_result
to_UpdateChannelNotificationSetting_result (T.TStruct fields) = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.maybe (P.Nothing) (\(_,_val5454) -> P.Just (case _val5454 of {T.TStruct _val5455 -> (to_ChannelException (T.TStruct _val5455)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateChannelNotificationSetting_result _ = P.error "not a struct"
read_UpdateChannelNotificationSetting_result :: T.Protocol p => p -> P.IO UpdateChannelNotificationSetting_result
read_UpdateChannelNotificationSetting_result iprot = to_UpdateChannelNotificationSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result)
decode_UpdateChannelNotificationSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateChannelNotificationSetting_result
decode_UpdateChannelNotificationSetting_result iprot bs = to_UpdateChannelNotificationSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateChannelNotificationSetting_result) bs
typemap_UpdateChannelNotificationSetting_result :: T.TypeMap
typemap_UpdateChannelNotificationSetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_ChannelException)))]
default_UpdateChannelNotificationSetting_result :: UpdateChannelNotificationSetting_result
default_UpdateChannelNotificationSetting_result = UpdateChannelNotificationSetting_result{
  updateChannelNotificationSetting_result_e = P.Nothing}
process_issueOTP (seqid, iprot, oprot, handler) = do
  args <- read_IssueOTP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueOTP handler (issueOTP_args_channelId args)
        let res = default_IssueOTP_result{issueOTP_result_success = val}
        T.writeMessage oprot ("issueOTP", T.M_REPLY, seqid) $
          write_IssueOTP_result oprot res)
      (\e  -> do
        let res = default_IssueOTP_result{issueOTP_result_e = P.Just e}
        T.writeMessage oprot ("issueOTP", T.M_REPLY, seqid) $
          write_IssueOTP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueOTP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveChannelAndIssueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueChannelToken handler (approveChannelAndIssueChannelToken_args_channelId args)
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueChannelToken_result{approveChannelAndIssueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveChannelAndIssueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_ApproveChannelAndIssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveChannelAndIssueRequestToken handler (approveChannelAndIssueRequestToken_args_channelId args) (approveChannelAndIssueRequestToken_args_otpId args)
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_success = val}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_ApproveChannelAndIssueRequestToken_result{approveChannelAndIssueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_REPLY, seqid) $
          write_ApproveChannelAndIssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveChannelAndIssueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchNotificationItems (seqid, iprot, oprot, handler) = do
  args <- read_FetchNotificationItems_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchNotificationItems handler (fetchNotificationItems_args_localRev args)
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_success = val}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res)
      (\e  -> do
        let res = default_FetchNotificationItems_result{fetchNotificationItems_result_e = P.Just e}
        T.writeMessage oprot ("fetchNotificationItems", T.M_REPLY, seqid) $
          write_FetchNotificationItems_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchNotificationItems", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getApprovedChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetApprovedChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getApprovedChannels handler (getApprovedChannels_args_lastSynced args) (getApprovedChannels_args_locale args)
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_success = val}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res)
      (\e  -> do
        let res = default_GetApprovedChannels_result{getApprovedChannels_result_e = P.Just e}
        T.writeMessage oprot ("getApprovedChannels", T.M_REPLY, seqid) $
          write_GetApprovedChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getApprovedChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelInfo handler (getChannelInfo_args_channelId args) (getChannelInfo_args_locale args)
        let res = default_GetChannelInfo_result{getChannelInfo_result_success = val}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res)
      (\e  -> do
        let res = default_GetChannelInfo_result{getChannelInfo_result_e = P.Just e}
        T.writeMessage oprot ("getChannelInfo", T.M_REPLY, seqid) $
          write_GetChannelInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSetting handler (getChannelNotificationSetting_args_channelId args) (getChannelNotificationSetting_args_locale args)
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSetting_result{getChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSetting", T.M_REPLY, seqid) $
          write_GetChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannelNotificationSettings (seqid, iprot, oprot, handler) = do
  args <- read_GetChannelNotificationSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannelNotificationSettings handler (getChannelNotificationSettings_args_locale args)
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_success = val}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res)
      (\e  -> do
        let res = default_GetChannelNotificationSettings_result{getChannelNotificationSettings_result_e = P.Just e}
        T.writeMessage oprot ("getChannelNotificationSettings", T.M_REPLY, seqid) $
          write_GetChannelNotificationSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannelNotificationSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChannels (seqid, iprot, oprot, handler) = do
  args <- read_GetChannels_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChannels handler (getChannels_args_lastSynced args) (getChannels_args_locale args)
        let res = default_GetChannels_result{getChannels_result_success = val}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res)
      (\e  -> do
        let res = default_GetChannels_result{getChannels_result_e = P.Just e}
        T.writeMessage oprot ("getChannels", T.M_REPLY, seqid) $
          write_GetChannels_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChannels", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDomains (seqid, iprot, oprot, handler) = do
  args <- read_GetDomains_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDomains handler (getDomains_args_lastSynced args)
        let res = default_GetDomains_result{getDomains_result_success = val}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res)
      (\e  -> do
        let res = default_GetDomains_result{getDomains_result_e = P.Just e}
        T.writeMessage oprot ("getDomains", T.M_REPLY, seqid) $
          write_GetDomains_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDomains", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendChannelMatrices (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendChannelMatrices_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendChannelMatrices handler (getFriendChannelMatrices_args_channelIds args)
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_success = val}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res)
      (\e  -> do
        let res = default_GetFriendChannelMatrices_result{getFriendChannelMatrices_result_e = P.Just e}
        T.writeMessage oprot ("getFriendChannelMatrices", T.M_REPLY, seqid) $
          write_GetFriendChannelMatrices_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendChannelMatrices", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateChannelSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateChannelSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateChannelSettings handler (updateChannelSettings_args_channelSettings args)
        let res = default_UpdateChannelSettings_result{updateChannelSettings_result_success = val}
        T.writeMessage oprot ("updateChannelSettings", T.M_REPLY, seqid) $
          write_UpdateChannelSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateChannelSettings_result{updateChannelSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateChannelSettings", T.M_REPLY, seqid) $
          write_UpdateChannelSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateChannelSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCommonDomains (seqid, iprot, oprot, handler) = do
  args <- read_GetCommonDomains_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCommonDomains handler (getCommonDomains_args_lastSynced args)
        let res = default_GetCommonDomains_result{getCommonDomains_result_success = val}
        T.writeMessage oprot ("getCommonDomains", T.M_REPLY, seqid) $
          write_GetCommonDomains_result oprot res)
      (\e  -> do
        let res = default_GetCommonDomains_result{getCommonDomains_result_e = P.Just e}
        T.writeMessage oprot ("getCommonDomains", T.M_REPLY, seqid) $
          write_GetCommonDomains_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCommonDomains", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotificationBadgeCount (seqid, iprot, oprot, handler) = do
  args <- read_GetNotificationBadgeCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNotificationBadgeCount handler (getNotificationBadgeCount_args_localRev args)
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_success = val}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res)
      (\e  -> do
        let res = default_GetNotificationBadgeCount_result{getNotificationBadgeCount_result_e = P.Just e}
        T.writeMessage oprot ("getNotificationBadgeCount", T.M_REPLY, seqid) $
          write_GetNotificationBadgeCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotificationBadgeCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueChannelToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueChannelToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueChannelToken handler (issueChannelToken_args_channelId args)
        let res = default_IssueChannelToken_result{issueChannelToken_result_success = val}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res)
      (\e  -> do
        let res = default_IssueChannelToken_result{issueChannelToken_result_e = P.Just e}
        T.writeMessage oprot ("issueChannelToken", T.M_REPLY, seqid) $
          write_IssueChannelToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueChannelToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestToken (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestToken handler (issueRequestToken_args_channelId args) (issueRequestToken_args_otpId args)
        let res = default_IssueRequestToken_result{issueRequestToken_result_success = val}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res)
      (\e  -> do
        let res = default_IssueRequestToken_result{issueRequestToken_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestToken", T.M_REPLY, seqid) $
          write_IssueRequestToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestTokenWithAuthScheme (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestTokenWithAuthScheme_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestTokenWithAuthScheme handler (issueRequestTokenWithAuthScheme_args_channelId args) (issueRequestTokenWithAuthScheme_args_otpId args) (issueRequestTokenWithAuthScheme_args_authScheme args) (issueRequestTokenWithAuthScheme_args_returnUrl args)
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_success = val}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res)
      (\e  -> do
        let res = default_IssueRequestTokenWithAuthScheme_result{issueRequestTokenWithAuthScheme_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_REPLY, seqid) $
          write_IssueRequestTokenWithAuthScheme_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestTokenWithAuthScheme", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueRequestTokenForAutoLogin (seqid, iprot, oprot, handler) = do
  args <- read_IssueRequestTokenForAutoLogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueRequestTokenForAutoLogin handler (issueRequestTokenForAutoLogin_args_channelId args) (issueRequestTokenForAutoLogin_args_otpId args) (issueRequestTokenForAutoLogin_args_redirectUrl args)
        let res = default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_success = val}
        T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_REPLY, seqid) $
          write_IssueRequestTokenForAutoLogin_result oprot res)
      (\e  -> do
        let res = default_IssueRequestTokenForAutoLogin_result{issueRequestTokenForAutoLogin_result_e = P.Just e}
        T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_REPLY, seqid) $
          write_IssueRequestTokenForAutoLogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueRequestTokenForAutoLogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUpdatedChannelIds (seqid, iprot, oprot, handler) = do
  args <- read_GetUpdatedChannelIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUpdatedChannelIds handler (getUpdatedChannelIds_args_channelIds args)
        let res = default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_success = val}
        T.writeMessage oprot ("getUpdatedChannelIds", T.M_REPLY, seqid) $
          write_GetUpdatedChannelIds_result oprot res)
      (\e  -> do
        let res = default_GetUpdatedChannelIds_result{getUpdatedChannelIds_result_e = P.Just e}
        T.writeMessage oprot ("getUpdatedChannelIds", T.M_REPLY, seqid) $
          write_GetUpdatedChannelIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUpdatedChannelIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCoinUse (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCoinUse_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCoinUse handler (reserveCoinUse_args_request args) (reserveCoinUse_args_locale args)
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_success = val}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res)
      (\e  -> do
        let res = default_ReserveCoinUse_result{reserveCoinUse_result_e = P.Just e}
        T.writeMessage oprot ("reserveCoinUse", T.M_REPLY, seqid) $
          write_ReserveCoinUse_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCoinUse", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_revokeChannel (seqid, iprot, oprot, handler) = do
  args <- read_RevokeChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.revokeChannel handler (revokeChannel_args_channelId args)
        let res = default_RevokeChannel_result
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res)
      (\e  -> do
        let res = default_RevokeChannel_result{revokeChannel_result_e = P.Just e}
        T.writeMessage oprot ("revokeChannel", T.M_REPLY, seqid) $
          write_RevokeChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("revokeChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncChannelData (seqid, iprot, oprot, handler) = do
  args <- read_SyncChannelData_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncChannelData handler (syncChannelData_args_lastSynced args) (syncChannelData_args_locale args)
        let res = default_SyncChannelData_result{syncChannelData_result_success = val}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res)
      (\e  -> do
        let res = default_SyncChannelData_result{syncChannelData_result_e = P.Just e}
        T.writeMessage oprot ("syncChannelData", T.M_REPLY, seqid) $
          write_SyncChannelData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncChannelData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateChannelNotificationSetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateChannelNotificationSetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateChannelNotificationSetting handler (updateChannelNotificationSetting_args_setting args)
        let res = default_UpdateChannelNotificationSetting_result
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res)
      (\e  -> do
        let res = default_UpdateChannelNotificationSetting_result{updateChannelNotificationSetting_result_e = P.Just e}
        T.writeMessage oprot ("updateChannelNotificationSetting", T.M_REPLY, seqid) $
          write_UpdateChannelNotificationSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateChannelNotificationSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "issueOTP" -> process_issueOTP (seqid,iprot,oprot,handler)
  "approveChannelAndIssueChannelToken" -> process_approveChannelAndIssueChannelToken (seqid,iprot,oprot,handler)
  "approveChannelAndIssueRequestToken" -> process_approveChannelAndIssueRequestToken (seqid,iprot,oprot,handler)
  "fetchNotificationItems" -> process_fetchNotificationItems (seqid,iprot,oprot,handler)
  "getApprovedChannels" -> process_getApprovedChannels (seqid,iprot,oprot,handler)
  "getChannelInfo" -> process_getChannelInfo (seqid,iprot,oprot,handler)
  "getChannelNotificationSetting" -> process_getChannelNotificationSetting (seqid,iprot,oprot,handler)
  "getChannelNotificationSettings" -> process_getChannelNotificationSettings (seqid,iprot,oprot,handler)
  "getChannels" -> process_getChannels (seqid,iprot,oprot,handler)
  "getDomains" -> process_getDomains (seqid,iprot,oprot,handler)
  "getFriendChannelMatrices" -> process_getFriendChannelMatrices (seqid,iprot,oprot,handler)
  "updateChannelSettings" -> process_updateChannelSettings (seqid,iprot,oprot,handler)
  "getCommonDomains" -> process_getCommonDomains (seqid,iprot,oprot,handler)
  "getNotificationBadgeCount" -> process_getNotificationBadgeCount (seqid,iprot,oprot,handler)
  "issueChannelToken" -> process_issueChannelToken (seqid,iprot,oprot,handler)
  "issueRequestToken" -> process_issueRequestToken (seqid,iprot,oprot,handler)
  "issueRequestTokenWithAuthScheme" -> process_issueRequestTokenWithAuthScheme (seqid,iprot,oprot,handler)
  "issueRequestTokenForAutoLogin" -> process_issueRequestTokenForAutoLogin (seqid,iprot,oprot,handler)
  "getUpdatedChannelIds" -> process_getUpdatedChannelIds (seqid,iprot,oprot,handler)
  "reserveCoinUse" -> process_reserveCoinUse (seqid,iprot,oprot,handler)
  "revokeChannel" -> process_revokeChannel (seqid,iprot,oprot,handler)
  "syncChannelData" -> process_syncChannelData (seqid,iprot,oprot,handler)
  "updateChannelNotificationSetting" -> process_updateChannelNotificationSetting (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
