{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuthService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified AuthService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data UpdatePassword_args = UpdatePassword_args  { updatePassword_args_authSessionId :: LT.Text
  , updatePassword_args_request :: IdentityCredentialRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdatePassword_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updatePassword_args_authSessionId record   `H.hashWithSalt` updatePassword_args_request record  
instance QC.Arbitrary UpdatePassword_args where 
  arbitrary = M.liftM UpdatePassword_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdatePassword_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdatePassword_args{updatePassword_args_authSessionId = updatePassword_args_authSessionId obj} then P.Nothing else P.Just $ default_UpdatePassword_args{updatePassword_args_authSessionId = updatePassword_args_authSessionId obj}
    , if obj == default_UpdatePassword_args{updatePassword_args_request = updatePassword_args_request obj} then P.Nothing else P.Just $ default_UpdatePassword_args{updatePassword_args_request = updatePassword_args_request obj}
    ]
from_UpdatePassword_args :: UpdatePassword_args -> T.ThriftVal
from_UpdatePassword_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11239 -> P.Just (2, ("authSessionId",T.TString $ E.encodeUtf8 _v11239))) $ updatePassword_args_authSessionId record
  , (\_v11239 -> P.Just (3, ("request",from_IdentityCredentialRequest _v11239))) $ updatePassword_args_request record
  ]
write_UpdatePassword_args :: T.Protocol p => p -> UpdatePassword_args -> P.IO ()
write_UpdatePassword_args oprot record = T.writeVal oprot $ from_UpdatePassword_args record
encode_UpdatePassword_args :: T.StatelessProtocol p => p -> UpdatePassword_args -> LBS.ByteString
encode_UpdatePassword_args oprot record = T.serializeVal oprot $ from_UpdatePassword_args record
to_UpdatePassword_args :: T.ThriftVal -> UpdatePassword_args
to_UpdatePassword_args (T.TStruct fields) = UpdatePassword_args{
  updatePassword_args_authSessionId = P.maybe (updatePassword_args_authSessionId default_UpdatePassword_args) (\(_,_val11241) -> (case _val11241 of {T.TString _val11242 -> E.decodeUtf8 _val11242; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updatePassword_args_request = P.maybe (updatePassword_args_request default_UpdatePassword_args) (\(_,_val11241) -> (case _val11241 of {T.TStruct _val11243 -> (to_IdentityCredentialRequest (T.TStruct _val11243)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdatePassword_args _ = P.error "not a struct"
read_UpdatePassword_args :: T.Protocol p => p -> P.IO UpdatePassword_args
read_UpdatePassword_args iprot = to_UpdatePassword_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdatePassword_args)
decode_UpdatePassword_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdatePassword_args
decode_UpdatePassword_args iprot bs = to_UpdatePassword_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdatePassword_args) bs
typemap_UpdatePassword_args :: T.TypeMap
typemap_UpdatePassword_args = Map.fromList [(2,("authSessionId",T.T_STRING)),(3,("request",(T.T_STRUCT typemap_IdentityCredentialRequest)))]
default_UpdatePassword_args :: UpdatePassword_args
default_UpdatePassword_args = UpdatePassword_args{
  updatePassword_args_authSessionId = "",
  updatePassword_args_request = default_IdentityCredentialRequest}
data UpdatePassword_result = UpdatePassword_result  { updatePassword_result_success :: IdentityCredentialResponse
  , updatePassword_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdatePassword_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updatePassword_result_success record   `H.hashWithSalt` updatePassword_result_e record  
instance QC.Arbitrary UpdatePassword_result where 
  arbitrary = M.liftM UpdatePassword_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdatePassword_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdatePassword_result{updatePassword_result_success = updatePassword_result_success obj} then P.Nothing else P.Just $ default_UpdatePassword_result{updatePassword_result_success = updatePassword_result_success obj}
    , if obj == default_UpdatePassword_result{updatePassword_result_e = updatePassword_result_e obj} then P.Nothing else P.Just $ default_UpdatePassword_result{updatePassword_result_e = updatePassword_result_e obj}
    ]
from_UpdatePassword_result :: UpdatePassword_result -> T.ThriftVal
from_UpdatePassword_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11246 -> (1, ("e",from_TalkException _v11246))) <$> updatePassword_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11246 -> P.Just (0, ("success",from_IdentityCredentialResponse _v11246))) $ updatePassword_result_success record
    , (\_v11246 -> (1, ("e",from_TalkException _v11246))) <$> updatePassword_result_e record
    ]
    )
write_UpdatePassword_result :: T.Protocol p => p -> UpdatePassword_result -> P.IO ()
write_UpdatePassword_result oprot record = T.writeVal oprot $ from_UpdatePassword_result record
encode_UpdatePassword_result :: T.StatelessProtocol p => p -> UpdatePassword_result -> LBS.ByteString
encode_UpdatePassword_result oprot record = T.serializeVal oprot $ from_UpdatePassword_result record
to_UpdatePassword_result :: T.ThriftVal -> UpdatePassword_result
to_UpdatePassword_result (T.TStruct fields) = UpdatePassword_result{
  updatePassword_result_success = P.maybe (updatePassword_result_success default_UpdatePassword_result) (\(_,_val11248) -> (case _val11248 of {T.TStruct _val11249 -> (to_IdentityCredentialResponse (T.TStruct _val11249)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updatePassword_result_e = P.maybe (P.Nothing) (\(_,_val11248) -> P.Just (case _val11248 of {T.TStruct _val11250 -> (to_TalkException (T.TStruct _val11250)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdatePassword_result _ = P.error "not a struct"
read_UpdatePassword_result :: T.Protocol p => p -> P.IO UpdatePassword_result
read_UpdatePassword_result iprot = to_UpdatePassword_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdatePassword_result)
decode_UpdatePassword_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdatePassword_result
decode_UpdatePassword_result iprot bs = to_UpdatePassword_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdatePassword_result) bs
typemap_UpdatePassword_result :: T.TypeMap
typemap_UpdatePassword_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_IdentityCredentialResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdatePassword_result :: UpdatePassword_result
default_UpdatePassword_result = UpdatePassword_result{
  updatePassword_result_success = default_IdentityCredentialResponse,
  updatePassword_result_e = P.Nothing}
data GetAuthRSAKey_args = GetAuthRSAKey_args  { getAuthRSAKey_args_authSessionId :: LT.Text
  , getAuthRSAKey_args_identityProvider :: IdentityProvider
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthRSAKey_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthRSAKey_args_authSessionId record   `H.hashWithSalt` getAuthRSAKey_args_identityProvider record  
instance QC.Arbitrary GetAuthRSAKey_args where 
  arbitrary = M.liftM GetAuthRSAKey_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetAuthRSAKey_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthRSAKey_args{getAuthRSAKey_args_authSessionId = getAuthRSAKey_args_authSessionId obj} then P.Nothing else P.Just $ default_GetAuthRSAKey_args{getAuthRSAKey_args_authSessionId = getAuthRSAKey_args_authSessionId obj}
    , if obj == default_GetAuthRSAKey_args{getAuthRSAKey_args_identityProvider = getAuthRSAKey_args_identityProvider obj} then P.Nothing else P.Just $ default_GetAuthRSAKey_args{getAuthRSAKey_args_identityProvider = getAuthRSAKey_args_identityProvider obj}
    ]
from_GetAuthRSAKey_args :: GetAuthRSAKey_args -> T.ThriftVal
from_GetAuthRSAKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11253 -> P.Just (2, ("authSessionId",T.TString $ E.encodeUtf8 _v11253))) $ getAuthRSAKey_args_authSessionId record
  , (\_v11253 -> P.Just (3, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v11253))) $ getAuthRSAKey_args_identityProvider record
  ]
write_GetAuthRSAKey_args :: T.Protocol p => p -> GetAuthRSAKey_args -> P.IO ()
write_GetAuthRSAKey_args oprot record = T.writeVal oprot $ from_GetAuthRSAKey_args record
encode_GetAuthRSAKey_args :: T.StatelessProtocol p => p -> GetAuthRSAKey_args -> LBS.ByteString
encode_GetAuthRSAKey_args oprot record = T.serializeVal oprot $ from_GetAuthRSAKey_args record
to_GetAuthRSAKey_args :: T.ThriftVal -> GetAuthRSAKey_args
to_GetAuthRSAKey_args (T.TStruct fields) = GetAuthRSAKey_args{
  getAuthRSAKey_args_authSessionId = P.maybe (getAuthRSAKey_args_authSessionId default_GetAuthRSAKey_args) (\(_,_val11255) -> (case _val11255 of {T.TString _val11256 -> E.decodeUtf8 _val11256; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getAuthRSAKey_args_identityProvider = P.maybe (getAuthRSAKey_args_identityProvider default_GetAuthRSAKey_args) (\(_,_val11255) -> (case _val11255 of {T.TI32 _val11257 -> P.toEnum $ P.fromIntegral _val11257; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetAuthRSAKey_args _ = P.error "not a struct"
read_GetAuthRSAKey_args :: T.Protocol p => p -> P.IO GetAuthRSAKey_args
read_GetAuthRSAKey_args iprot = to_GetAuthRSAKey_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthRSAKey_args)
decode_GetAuthRSAKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthRSAKey_args
decode_GetAuthRSAKey_args iprot bs = to_GetAuthRSAKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthRSAKey_args) bs
typemap_GetAuthRSAKey_args :: T.TypeMap
typemap_GetAuthRSAKey_args = Map.fromList [(2,("authSessionId",T.T_STRING)),(3,("identityProvider",T.T_I32))]
default_GetAuthRSAKey_args :: GetAuthRSAKey_args
default_GetAuthRSAKey_args = GetAuthRSAKey_args{
  getAuthRSAKey_args_authSessionId = "",
  getAuthRSAKey_args_identityProvider = (P.toEnum 0)}
data GetAuthRSAKey_result = GetAuthRSAKey_result  { getAuthRSAKey_result_success :: RSAKey
  , getAuthRSAKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthRSAKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthRSAKey_result_success record   `H.hashWithSalt` getAuthRSAKey_result_e record  
instance QC.Arbitrary GetAuthRSAKey_result where 
  arbitrary = M.liftM GetAuthRSAKey_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAuthRSAKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthRSAKey_result{getAuthRSAKey_result_success = getAuthRSAKey_result_success obj} then P.Nothing else P.Just $ default_GetAuthRSAKey_result{getAuthRSAKey_result_success = getAuthRSAKey_result_success obj}
    , if obj == default_GetAuthRSAKey_result{getAuthRSAKey_result_e = getAuthRSAKey_result_e obj} then P.Nothing else P.Just $ default_GetAuthRSAKey_result{getAuthRSAKey_result_e = getAuthRSAKey_result_e obj}
    ]
from_GetAuthRSAKey_result :: GetAuthRSAKey_result -> T.ThriftVal
from_GetAuthRSAKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11260 -> (1, ("e",from_TalkException _v11260))) <$> getAuthRSAKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11260 -> P.Just (0, ("success",from_RSAKey _v11260))) $ getAuthRSAKey_result_success record
    , (\_v11260 -> (1, ("e",from_TalkException _v11260))) <$> getAuthRSAKey_result_e record
    ]
    )
write_GetAuthRSAKey_result :: T.Protocol p => p -> GetAuthRSAKey_result -> P.IO ()
write_GetAuthRSAKey_result oprot record = T.writeVal oprot $ from_GetAuthRSAKey_result record
encode_GetAuthRSAKey_result :: T.StatelessProtocol p => p -> GetAuthRSAKey_result -> LBS.ByteString
encode_GetAuthRSAKey_result oprot record = T.serializeVal oprot $ from_GetAuthRSAKey_result record
to_GetAuthRSAKey_result :: T.ThriftVal -> GetAuthRSAKey_result
to_GetAuthRSAKey_result (T.TStruct fields) = GetAuthRSAKey_result{
  getAuthRSAKey_result_success = P.maybe (getAuthRSAKey_result_success default_GetAuthRSAKey_result) (\(_,_val11262) -> (case _val11262 of {T.TStruct _val11263 -> (to_RSAKey (T.TStruct _val11263)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAuthRSAKey_result_e = P.maybe (P.Nothing) (\(_,_val11262) -> P.Just (case _val11262 of {T.TStruct _val11264 -> (to_TalkException (T.TStruct _val11264)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAuthRSAKey_result _ = P.error "not a struct"
read_GetAuthRSAKey_result :: T.Protocol p => p -> P.IO GetAuthRSAKey_result
read_GetAuthRSAKey_result iprot = to_GetAuthRSAKey_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthRSAKey_result)
decode_GetAuthRSAKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthRSAKey_result
decode_GetAuthRSAKey_result iprot bs = to_GetAuthRSAKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthRSAKey_result) bs
typemap_GetAuthRSAKey_result :: T.TypeMap
typemap_GetAuthRSAKey_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RSAKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAuthRSAKey_result :: GetAuthRSAKey_result
default_GetAuthRSAKey_result = GetAuthRSAKey_result{
  getAuthRSAKey_result_success = default_RSAKey,
  getAuthRSAKey_result_e = P.Nothing}
data OpenAuthSession_args = OpenAuthSession_args  { openAuthSession_args_request :: AuthSessionRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenAuthSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` openAuthSession_args_request record  
instance QC.Arbitrary OpenAuthSession_args where 
  arbitrary = M.liftM OpenAuthSession_args (QC.arbitrary)
  shrink obj | obj == default_OpenAuthSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenAuthSession_args{openAuthSession_args_request = openAuthSession_args_request obj} then P.Nothing else P.Just $ default_OpenAuthSession_args{openAuthSession_args_request = openAuthSession_args_request obj}
    ]
from_OpenAuthSession_args :: OpenAuthSession_args -> T.ThriftVal
from_OpenAuthSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11267 -> P.Just (2, ("request",from_AuthSessionRequest _v11267))) $ openAuthSession_args_request record
  ]
write_OpenAuthSession_args :: T.Protocol p => p -> OpenAuthSession_args -> P.IO ()
write_OpenAuthSession_args oprot record = T.writeVal oprot $ from_OpenAuthSession_args record
encode_OpenAuthSession_args :: T.StatelessProtocol p => p -> OpenAuthSession_args -> LBS.ByteString
encode_OpenAuthSession_args oprot record = T.serializeVal oprot $ from_OpenAuthSession_args record
to_OpenAuthSession_args :: T.ThriftVal -> OpenAuthSession_args
to_OpenAuthSession_args (T.TStruct fields) = OpenAuthSession_args{
  openAuthSession_args_request = P.maybe (openAuthSession_args_request default_OpenAuthSession_args) (\(_,_val11269) -> (case _val11269 of {T.TStruct _val11270 -> (to_AuthSessionRequest (T.TStruct _val11270)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_OpenAuthSession_args _ = P.error "not a struct"
read_OpenAuthSession_args :: T.Protocol p => p -> P.IO OpenAuthSession_args
read_OpenAuthSession_args iprot = to_OpenAuthSession_args <$> T.readVal iprot (T.T_STRUCT typemap_OpenAuthSession_args)
decode_OpenAuthSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenAuthSession_args
decode_OpenAuthSession_args iprot bs = to_OpenAuthSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenAuthSession_args) bs
typemap_OpenAuthSession_args :: T.TypeMap
typemap_OpenAuthSession_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_AuthSessionRequest)))]
default_OpenAuthSession_args :: OpenAuthSession_args
default_OpenAuthSession_args = OpenAuthSession_args{
  openAuthSession_args_request = default_AuthSessionRequest}
data OpenAuthSession_result = OpenAuthSession_result  { openAuthSession_result_success :: LT.Text
  , openAuthSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenAuthSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` openAuthSession_result_success record   `H.hashWithSalt` openAuthSession_result_e record  
instance QC.Arbitrary OpenAuthSession_result where 
  arbitrary = M.liftM OpenAuthSession_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_OpenAuthSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenAuthSession_result{openAuthSession_result_success = openAuthSession_result_success obj} then P.Nothing else P.Just $ default_OpenAuthSession_result{openAuthSession_result_success = openAuthSession_result_success obj}
    , if obj == default_OpenAuthSession_result{openAuthSession_result_e = openAuthSession_result_e obj} then P.Nothing else P.Just $ default_OpenAuthSession_result{openAuthSession_result_e = openAuthSession_result_e obj}
    ]
from_OpenAuthSession_result :: OpenAuthSession_result -> T.ThriftVal
from_OpenAuthSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11273 -> (1, ("e",from_TalkException _v11273))) <$> openAuthSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11273 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v11273))) $ openAuthSession_result_success record
    , (\_v11273 -> (1, ("e",from_TalkException _v11273))) <$> openAuthSession_result_e record
    ]
    )
write_OpenAuthSession_result :: T.Protocol p => p -> OpenAuthSession_result -> P.IO ()
write_OpenAuthSession_result oprot record = T.writeVal oprot $ from_OpenAuthSession_result record
encode_OpenAuthSession_result :: T.StatelessProtocol p => p -> OpenAuthSession_result -> LBS.ByteString
encode_OpenAuthSession_result oprot record = T.serializeVal oprot $ from_OpenAuthSession_result record
to_OpenAuthSession_result :: T.ThriftVal -> OpenAuthSession_result
to_OpenAuthSession_result (T.TStruct fields) = OpenAuthSession_result{
  openAuthSession_result_success = P.maybe (openAuthSession_result_success default_OpenAuthSession_result) (\(_,_val11275) -> (case _val11275 of {T.TString _val11276 -> E.decodeUtf8 _val11276; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  openAuthSession_result_e = P.maybe (P.Nothing) (\(_,_val11275) -> P.Just (case _val11275 of {T.TStruct _val11277 -> (to_TalkException (T.TStruct _val11277)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_OpenAuthSession_result _ = P.error "not a struct"
read_OpenAuthSession_result :: T.Protocol p => p -> P.IO OpenAuthSession_result
read_OpenAuthSession_result iprot = to_OpenAuthSession_result <$> T.readVal iprot (T.T_STRUCT typemap_OpenAuthSession_result)
decode_OpenAuthSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenAuthSession_result
decode_OpenAuthSession_result iprot bs = to_OpenAuthSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenAuthSession_result) bs
typemap_OpenAuthSession_result :: T.TypeMap
typemap_OpenAuthSession_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_OpenAuthSession_result :: OpenAuthSession_result
default_OpenAuthSession_result = OpenAuthSession_result{
  openAuthSession_result_success = "",
  openAuthSession_result_e = P.Nothing}
data NormalizePhoneNumber_args = NormalizePhoneNumber_args  { normalizePhoneNumber_args_countryCode :: LT.Text
  , normalizePhoneNumber_args_phoneNumber :: LT.Text
  , normalizePhoneNumber_args_countryCodeHint :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NormalizePhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` normalizePhoneNumber_args_countryCode record   `H.hashWithSalt` normalizePhoneNumber_args_phoneNumber record   `H.hashWithSalt` normalizePhoneNumber_args_countryCodeHint record  
instance QC.Arbitrary NormalizePhoneNumber_args where 
  arbitrary = M.liftM NormalizePhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NormalizePhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCode = normalizePhoneNumber_args_countryCode obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCode = normalizePhoneNumber_args_countryCode obj}
    , if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_phoneNumber = normalizePhoneNumber_args_phoneNumber obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_phoneNumber = normalizePhoneNumber_args_phoneNumber obj}
    , if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCodeHint = normalizePhoneNumber_args_countryCodeHint obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCodeHint = normalizePhoneNumber_args_countryCodeHint obj}
    ]
from_NormalizePhoneNumber_args :: NormalizePhoneNumber_args -> T.ThriftVal
from_NormalizePhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11280 -> P.Just (2, ("countryCode",T.TString $ E.encodeUtf8 _v11280))) $ normalizePhoneNumber_args_countryCode record
  , (\_v11280 -> P.Just (3, ("phoneNumber",T.TString $ E.encodeUtf8 _v11280))) $ normalizePhoneNumber_args_phoneNumber record
  , (\_v11280 -> P.Just (4, ("countryCodeHint",T.TString $ E.encodeUtf8 _v11280))) $ normalizePhoneNumber_args_countryCodeHint record
  ]
write_NormalizePhoneNumber_args :: T.Protocol p => p -> NormalizePhoneNumber_args -> P.IO ()
write_NormalizePhoneNumber_args oprot record = T.writeVal oprot $ from_NormalizePhoneNumber_args record
encode_NormalizePhoneNumber_args :: T.StatelessProtocol p => p -> NormalizePhoneNumber_args -> LBS.ByteString
encode_NormalizePhoneNumber_args oprot record = T.serializeVal oprot $ from_NormalizePhoneNumber_args record
to_NormalizePhoneNumber_args :: T.ThriftVal -> NormalizePhoneNumber_args
to_NormalizePhoneNumber_args (T.TStruct fields) = NormalizePhoneNumber_args{
  normalizePhoneNumber_args_countryCode = P.maybe (normalizePhoneNumber_args_countryCode default_NormalizePhoneNumber_args) (\(_,_val11282) -> (case _val11282 of {T.TString _val11283 -> E.decodeUtf8 _val11283; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  normalizePhoneNumber_args_phoneNumber = P.maybe (normalizePhoneNumber_args_phoneNumber default_NormalizePhoneNumber_args) (\(_,_val11282) -> (case _val11282 of {T.TString _val11284 -> E.decodeUtf8 _val11284; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  normalizePhoneNumber_args_countryCodeHint = P.maybe (normalizePhoneNumber_args_countryCodeHint default_NormalizePhoneNumber_args) (\(_,_val11282) -> (case _val11282 of {T.TString _val11285 -> E.decodeUtf8 _val11285; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_NormalizePhoneNumber_args _ = P.error "not a struct"
read_NormalizePhoneNumber_args :: T.Protocol p => p -> P.IO NormalizePhoneNumber_args
read_NormalizePhoneNumber_args iprot = to_NormalizePhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_args)
decode_NormalizePhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NormalizePhoneNumber_args
decode_NormalizePhoneNumber_args iprot bs = to_NormalizePhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_args) bs
typemap_NormalizePhoneNumber_args :: T.TypeMap
typemap_NormalizePhoneNumber_args = Map.fromList [(2,("countryCode",T.T_STRING)),(3,("phoneNumber",T.T_STRING)),(4,("countryCodeHint",T.T_STRING))]
default_NormalizePhoneNumber_args :: NormalizePhoneNumber_args
default_NormalizePhoneNumber_args = NormalizePhoneNumber_args{
  normalizePhoneNumber_args_countryCode = "",
  normalizePhoneNumber_args_phoneNumber = "",
  normalizePhoneNumber_args_countryCodeHint = ""}
data NormalizePhoneNumber_result = NormalizePhoneNumber_result  { normalizePhoneNumber_result_success :: LT.Text
  , normalizePhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NormalizePhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` normalizePhoneNumber_result_success record   `H.hashWithSalt` normalizePhoneNumber_result_e record  
instance QC.Arbitrary NormalizePhoneNumber_result where 
  arbitrary = M.liftM NormalizePhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NormalizePhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = normalizePhoneNumber_result_success obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = normalizePhoneNumber_result_success obj}
    , if obj == default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = normalizePhoneNumber_result_e obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = normalizePhoneNumber_result_e obj}
    ]
from_NormalizePhoneNumber_result :: NormalizePhoneNumber_result -> T.ThriftVal
from_NormalizePhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11288 -> (1, ("e",from_TalkException _v11288))) <$> normalizePhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11288 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v11288))) $ normalizePhoneNumber_result_success record
    , (\_v11288 -> (1, ("e",from_TalkException _v11288))) <$> normalizePhoneNumber_result_e record
    ]
    )
write_NormalizePhoneNumber_result :: T.Protocol p => p -> NormalizePhoneNumber_result -> P.IO ()
write_NormalizePhoneNumber_result oprot record = T.writeVal oprot $ from_NormalizePhoneNumber_result record
encode_NormalizePhoneNumber_result :: T.StatelessProtocol p => p -> NormalizePhoneNumber_result -> LBS.ByteString
encode_NormalizePhoneNumber_result oprot record = T.serializeVal oprot $ from_NormalizePhoneNumber_result record
to_NormalizePhoneNumber_result :: T.ThriftVal -> NormalizePhoneNumber_result
to_NormalizePhoneNumber_result (T.TStruct fields) = NormalizePhoneNumber_result{
  normalizePhoneNumber_result_success = P.maybe (normalizePhoneNumber_result_success default_NormalizePhoneNumber_result) (\(_,_val11290) -> (case _val11290 of {T.TString _val11291 -> E.decodeUtf8 _val11291; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  normalizePhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val11290) -> P.Just (case _val11290 of {T.TStruct _val11292 -> (to_TalkException (T.TStruct _val11292)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NormalizePhoneNumber_result _ = P.error "not a struct"
read_NormalizePhoneNumber_result :: T.Protocol p => p -> P.IO NormalizePhoneNumber_result
read_NormalizePhoneNumber_result iprot = to_NormalizePhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_result)
decode_NormalizePhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NormalizePhoneNumber_result
decode_NormalizePhoneNumber_result iprot bs = to_NormalizePhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_result) bs
typemap_NormalizePhoneNumber_result :: T.TypeMap
typemap_NormalizePhoneNumber_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NormalizePhoneNumber_result :: NormalizePhoneNumber_result
default_NormalizePhoneNumber_result = NormalizePhoneNumber_result{
  normalizePhoneNumber_result_success = "",
  normalizePhoneNumber_result_e = P.Nothing}
data RespondE2EELoginRequest_args = RespondE2EELoginRequest_args  { respondE2EELoginRequest_args_verifier :: LT.Text
  , respondE2EELoginRequest_args_publicKey :: E2EEPublicKey
  , respondE2EELoginRequest_args_encryptedKeyChain :: LBS.ByteString
  , respondE2EELoginRequest_args_hashKeyChain :: LBS.ByteString
  , respondE2EELoginRequest_args_errorCode :: ErrorCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondE2EELoginRequest_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondE2EELoginRequest_args_verifier record   `H.hashWithSalt` respondE2EELoginRequest_args_publicKey record   `H.hashWithSalt` respondE2EELoginRequest_args_encryptedKeyChain record   `H.hashWithSalt` respondE2EELoginRequest_args_hashKeyChain record   `H.hashWithSalt` respondE2EELoginRequest_args_errorCode record  
instance QC.Arbitrary RespondE2EELoginRequest_args where 
  arbitrary = M.liftM RespondE2EELoginRequest_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RespondE2EELoginRequest_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_verifier = respondE2EELoginRequest_args_verifier obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_verifier = respondE2EELoginRequest_args_verifier obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_publicKey = respondE2EELoginRequest_args_publicKey obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_publicKey = respondE2EELoginRequest_args_publicKey obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_encryptedKeyChain = respondE2EELoginRequest_args_encryptedKeyChain obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_encryptedKeyChain = respondE2EELoginRequest_args_encryptedKeyChain obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_hashKeyChain = respondE2EELoginRequest_args_hashKeyChain obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_hashKeyChain = respondE2EELoginRequest_args_hashKeyChain obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_errorCode = respondE2EELoginRequest_args_errorCode obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_errorCode = respondE2EELoginRequest_args_errorCode obj}
    ]
from_RespondE2EELoginRequest_args :: RespondE2EELoginRequest_args -> T.ThriftVal
from_RespondE2EELoginRequest_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11295 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v11295))) $ respondE2EELoginRequest_args_verifier record
  , (\_v11295 -> P.Just (2, ("publicKey",from_E2EEPublicKey _v11295))) $ respondE2EELoginRequest_args_publicKey record
  , (\_v11295 -> P.Just (3, ("encryptedKeyChain",T.TBinary _v11295))) $ respondE2EELoginRequest_args_encryptedKeyChain record
  , (\_v11295 -> P.Just (4, ("hashKeyChain",T.TBinary _v11295))) $ respondE2EELoginRequest_args_hashKeyChain record
  , (\_v11295 -> P.Just (5, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v11295))) $ respondE2EELoginRequest_args_errorCode record
  ]
write_RespondE2EELoginRequest_args :: T.Protocol p => p -> RespondE2EELoginRequest_args -> P.IO ()
write_RespondE2EELoginRequest_args oprot record = T.writeVal oprot $ from_RespondE2EELoginRequest_args record
encode_RespondE2EELoginRequest_args :: T.StatelessProtocol p => p -> RespondE2EELoginRequest_args -> LBS.ByteString
encode_RespondE2EELoginRequest_args oprot record = T.serializeVal oprot $ from_RespondE2EELoginRequest_args record
to_RespondE2EELoginRequest_args :: T.ThriftVal -> RespondE2EELoginRequest_args
to_RespondE2EELoginRequest_args (T.TStruct fields) = RespondE2EELoginRequest_args{
  respondE2EELoginRequest_args_verifier = P.maybe (respondE2EELoginRequest_args_verifier default_RespondE2EELoginRequest_args) (\(_,_val11297) -> (case _val11297 of {T.TString _val11298 -> E.decodeUtf8 _val11298; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  respondE2EELoginRequest_args_publicKey = P.maybe (respondE2EELoginRequest_args_publicKey default_RespondE2EELoginRequest_args) (\(_,_val11297) -> (case _val11297 of {T.TStruct _val11299 -> (to_E2EEPublicKey (T.TStruct _val11299)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  respondE2EELoginRequest_args_encryptedKeyChain = P.maybe (respondE2EELoginRequest_args_encryptedKeyChain default_RespondE2EELoginRequest_args) (\(_,_val11297) -> (case _val11297 of {T.TBinary _val11300 -> _val11300; T.TString _val11300 -> _val11300; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  respondE2EELoginRequest_args_hashKeyChain = P.maybe (respondE2EELoginRequest_args_hashKeyChain default_RespondE2EELoginRequest_args) (\(_,_val11297) -> (case _val11297 of {T.TBinary _val11301 -> _val11301; T.TString _val11301 -> _val11301; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  respondE2EELoginRequest_args_errorCode = P.maybe (respondE2EELoginRequest_args_errorCode default_RespondE2EELoginRequest_args) (\(_,_val11297) -> (case _val11297 of {T.TI32 _val11302 -> P.toEnum $ P.fromIntegral _val11302; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RespondE2EELoginRequest_args _ = P.error "not a struct"
read_RespondE2EELoginRequest_args :: T.Protocol p => p -> P.IO RespondE2EELoginRequest_args
read_RespondE2EELoginRequest_args iprot = to_RespondE2EELoginRequest_args <$> T.readVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_args)
decode_RespondE2EELoginRequest_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondE2EELoginRequest_args
decode_RespondE2EELoginRequest_args iprot bs = to_RespondE2EELoginRequest_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_args) bs
typemap_RespondE2EELoginRequest_args :: T.TypeMap
typemap_RespondE2EELoginRequest_args = Map.fromList [(1,("verifier",T.T_STRING)),(2,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey))),(3,("encryptedKeyChain",T.T_BINARY)),(4,("hashKeyChain",T.T_BINARY)),(5,("errorCode",T.T_I32))]
default_RespondE2EELoginRequest_args :: RespondE2EELoginRequest_args
default_RespondE2EELoginRequest_args = RespondE2EELoginRequest_args{
  respondE2EELoginRequest_args_verifier = "",
  respondE2EELoginRequest_args_publicKey = default_E2EEPublicKey,
  respondE2EELoginRequest_args_encryptedKeyChain = "",
  respondE2EELoginRequest_args_hashKeyChain = "",
  respondE2EELoginRequest_args_errorCode = (P.toEnum 0)}
data RespondE2EELoginRequest_result = RespondE2EELoginRequest_result  { respondE2EELoginRequest_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondE2EELoginRequest_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondE2EELoginRequest_result_e record  
instance QC.Arbitrary RespondE2EELoginRequest_result where 
  arbitrary = M.liftM RespondE2EELoginRequest_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RespondE2EELoginRequest_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = respondE2EELoginRequest_result_e obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = respondE2EELoginRequest_result_e obj}
    ]
from_RespondE2EELoginRequest_result :: RespondE2EELoginRequest_result -> T.ThriftVal
from_RespondE2EELoginRequest_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11305 -> (1, ("e",from_TalkException _v11305))) <$> respondE2EELoginRequest_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11305 -> (1, ("e",from_TalkException _v11305))) <$> respondE2EELoginRequest_result_e record
    ]
    )
write_RespondE2EELoginRequest_result :: T.Protocol p => p -> RespondE2EELoginRequest_result -> P.IO ()
write_RespondE2EELoginRequest_result oprot record = T.writeVal oprot $ from_RespondE2EELoginRequest_result record
encode_RespondE2EELoginRequest_result :: T.StatelessProtocol p => p -> RespondE2EELoginRequest_result -> LBS.ByteString
encode_RespondE2EELoginRequest_result oprot record = T.serializeVal oprot $ from_RespondE2EELoginRequest_result record
to_RespondE2EELoginRequest_result :: T.ThriftVal -> RespondE2EELoginRequest_result
to_RespondE2EELoginRequest_result (T.TStruct fields) = RespondE2EELoginRequest_result{
  respondE2EELoginRequest_result_e = P.maybe (P.Nothing) (\(_,_val11307) -> P.Just (case _val11307 of {T.TStruct _val11308 -> (to_TalkException (T.TStruct _val11308)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RespondE2EELoginRequest_result _ = P.error "not a struct"
read_RespondE2EELoginRequest_result :: T.Protocol p => p -> P.IO RespondE2EELoginRequest_result
read_RespondE2EELoginRequest_result iprot = to_RespondE2EELoginRequest_result <$> T.readVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_result)
decode_RespondE2EELoginRequest_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondE2EELoginRequest_result
decode_RespondE2EELoginRequest_result iprot bs = to_RespondE2EELoginRequest_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_result) bs
typemap_RespondE2EELoginRequest_result :: T.TypeMap
typemap_RespondE2EELoginRequest_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RespondE2EELoginRequest_result :: RespondE2EELoginRequest_result
default_RespondE2EELoginRequest_result = RespondE2EELoginRequest_result{
  respondE2EELoginRequest_result_e = P.Nothing}
data ConfirmE2EELogin_args = ConfirmE2EELogin_args  { confirmE2EELogin_args_verifier :: LT.Text
  , confirmE2EELogin_args_deviceSecret :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmE2EELogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmE2EELogin_args_verifier record   `H.hashWithSalt` confirmE2EELogin_args_deviceSecret record  
instance QC.Arbitrary ConfirmE2EELogin_args where 
  arbitrary = M.liftM ConfirmE2EELogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfirmE2EELogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmE2EELogin_args{confirmE2EELogin_args_verifier = confirmE2EELogin_args_verifier obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_args{confirmE2EELogin_args_verifier = confirmE2EELogin_args_verifier obj}
    , if obj == default_ConfirmE2EELogin_args{confirmE2EELogin_args_deviceSecret = confirmE2EELogin_args_deviceSecret obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_args{confirmE2EELogin_args_deviceSecret = confirmE2EELogin_args_deviceSecret obj}
    ]
from_ConfirmE2EELogin_args :: ConfirmE2EELogin_args -> T.ThriftVal
from_ConfirmE2EELogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11311 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v11311))) $ confirmE2EELogin_args_verifier record
  , (\_v11311 -> P.Just (2, ("deviceSecret",T.TBinary _v11311))) $ confirmE2EELogin_args_deviceSecret record
  ]
write_ConfirmE2EELogin_args :: T.Protocol p => p -> ConfirmE2EELogin_args -> P.IO ()
write_ConfirmE2EELogin_args oprot record = T.writeVal oprot $ from_ConfirmE2EELogin_args record
encode_ConfirmE2EELogin_args :: T.StatelessProtocol p => p -> ConfirmE2EELogin_args -> LBS.ByteString
encode_ConfirmE2EELogin_args oprot record = T.serializeVal oprot $ from_ConfirmE2EELogin_args record
to_ConfirmE2EELogin_args :: T.ThriftVal -> ConfirmE2EELogin_args
to_ConfirmE2EELogin_args (T.TStruct fields) = ConfirmE2EELogin_args{
  confirmE2EELogin_args_verifier = P.maybe (confirmE2EELogin_args_verifier default_ConfirmE2EELogin_args) (\(_,_val11313) -> (case _val11313 of {T.TString _val11314 -> E.decodeUtf8 _val11314; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  confirmE2EELogin_args_deviceSecret = P.maybe (confirmE2EELogin_args_deviceSecret default_ConfirmE2EELogin_args) (\(_,_val11313) -> (case _val11313 of {T.TBinary _val11315 -> _val11315; T.TString _val11315 -> _val11315; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConfirmE2EELogin_args _ = P.error "not a struct"
read_ConfirmE2EELogin_args :: T.Protocol p => p -> P.IO ConfirmE2EELogin_args
read_ConfirmE2EELogin_args iprot = to_ConfirmE2EELogin_args <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_args)
decode_ConfirmE2EELogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmE2EELogin_args
decode_ConfirmE2EELogin_args iprot bs = to_ConfirmE2EELogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_args) bs
typemap_ConfirmE2EELogin_args :: T.TypeMap
typemap_ConfirmE2EELogin_args = Map.fromList [(1,("verifier",T.T_STRING)),(2,("deviceSecret",T.T_BINARY))]
default_ConfirmE2EELogin_args :: ConfirmE2EELogin_args
default_ConfirmE2EELogin_args = ConfirmE2EELogin_args{
  confirmE2EELogin_args_verifier = "",
  confirmE2EELogin_args_deviceSecret = ""}
data ConfirmE2EELogin_result = ConfirmE2EELogin_result  { confirmE2EELogin_result_success :: LT.Text
  , confirmE2EELogin_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmE2EELogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmE2EELogin_result_success record   `H.hashWithSalt` confirmE2EELogin_result_e record  
instance QC.Arbitrary ConfirmE2EELogin_result where 
  arbitrary = M.liftM ConfirmE2EELogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ConfirmE2EELogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = confirmE2EELogin_result_success obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = confirmE2EELogin_result_success obj}
    , if obj == default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = confirmE2EELogin_result_e obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = confirmE2EELogin_result_e obj}
    ]
from_ConfirmE2EELogin_result :: ConfirmE2EELogin_result -> T.ThriftVal
from_ConfirmE2EELogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11318 -> (1, ("e",from_TalkException _v11318))) <$> confirmE2EELogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11318 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v11318))) $ confirmE2EELogin_result_success record
    , (\_v11318 -> (1, ("e",from_TalkException _v11318))) <$> confirmE2EELogin_result_e record
    ]
    )
write_ConfirmE2EELogin_result :: T.Protocol p => p -> ConfirmE2EELogin_result -> P.IO ()
write_ConfirmE2EELogin_result oprot record = T.writeVal oprot $ from_ConfirmE2EELogin_result record
encode_ConfirmE2EELogin_result :: T.StatelessProtocol p => p -> ConfirmE2EELogin_result -> LBS.ByteString
encode_ConfirmE2EELogin_result oprot record = T.serializeVal oprot $ from_ConfirmE2EELogin_result record
to_ConfirmE2EELogin_result :: T.ThriftVal -> ConfirmE2EELogin_result
to_ConfirmE2EELogin_result (T.TStruct fields) = ConfirmE2EELogin_result{
  confirmE2EELogin_result_success = P.maybe (confirmE2EELogin_result_success default_ConfirmE2EELogin_result) (\(_,_val11320) -> (case _val11320 of {T.TString _val11321 -> E.decodeUtf8 _val11321; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  confirmE2EELogin_result_e = P.maybe (P.Nothing) (\(_,_val11320) -> P.Just (case _val11320 of {T.TStruct _val11322 -> (to_TalkException (T.TStruct _val11322)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ConfirmE2EELogin_result _ = P.error "not a struct"
read_ConfirmE2EELogin_result :: T.Protocol p => p -> P.IO ConfirmE2EELogin_result
read_ConfirmE2EELogin_result iprot = to_ConfirmE2EELogin_result <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_result)
decode_ConfirmE2EELogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmE2EELogin_result
decode_ConfirmE2EELogin_result iprot bs = to_ConfirmE2EELogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_result) bs
typemap_ConfirmE2EELogin_result :: T.TypeMap
typemap_ConfirmE2EELogin_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ConfirmE2EELogin_result :: ConfirmE2EELogin_result
default_ConfirmE2EELogin_result = ConfirmE2EELogin_result{
  confirmE2EELogin_result_success = "",
  confirmE2EELogin_result_e = P.Nothing}
data LogoutZ_args = LogoutZ_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutZ_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary LogoutZ_args where 
  arbitrary = QC.elements [LogoutZ_args]
from_LogoutZ_args :: LogoutZ_args -> T.ThriftVal
from_LogoutZ_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_LogoutZ_args :: T.Protocol p => p -> LogoutZ_args -> P.IO ()
write_LogoutZ_args oprot record = T.writeVal oprot $ from_LogoutZ_args record
encode_LogoutZ_args :: T.StatelessProtocol p => p -> LogoutZ_args -> LBS.ByteString
encode_LogoutZ_args oprot record = T.serializeVal oprot $ from_LogoutZ_args record
to_LogoutZ_args :: T.ThriftVal -> LogoutZ_args
to_LogoutZ_args (T.TStruct fields) = LogoutZ_args{

  }
to_LogoutZ_args _ = P.error "not a struct"
read_LogoutZ_args :: T.Protocol p => p -> P.IO LogoutZ_args
read_LogoutZ_args iprot = to_LogoutZ_args <$> T.readVal iprot (T.T_STRUCT typemap_LogoutZ_args)
decode_LogoutZ_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutZ_args
decode_LogoutZ_args iprot bs = to_LogoutZ_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutZ_args) bs
typemap_LogoutZ_args :: T.TypeMap
typemap_LogoutZ_args = Map.fromList []
default_LogoutZ_args :: LogoutZ_args
default_LogoutZ_args = LogoutZ_args{
}
data LogoutZ_result = LogoutZ_result  { logoutZ_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutZ_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutZ_result_e record  
instance QC.Arbitrary LogoutZ_result where 
  arbitrary = M.liftM LogoutZ_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LogoutZ_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutZ_result{logoutZ_result_e = logoutZ_result_e obj} then P.Nothing else P.Just $ default_LogoutZ_result{logoutZ_result_e = logoutZ_result_e obj}
    ]
from_LogoutZ_result :: LogoutZ_result -> T.ThriftVal
from_LogoutZ_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11330 -> (1, ("e",from_TalkException _v11330))) <$> logoutZ_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11330 -> (1, ("e",from_TalkException _v11330))) <$> logoutZ_result_e record
    ]
    )
write_LogoutZ_result :: T.Protocol p => p -> LogoutZ_result -> P.IO ()
write_LogoutZ_result oprot record = T.writeVal oprot $ from_LogoutZ_result record
encode_LogoutZ_result :: T.StatelessProtocol p => p -> LogoutZ_result -> LBS.ByteString
encode_LogoutZ_result oprot record = T.serializeVal oprot $ from_LogoutZ_result record
to_LogoutZ_result :: T.ThriftVal -> LogoutZ_result
to_LogoutZ_result (T.TStruct fields) = LogoutZ_result{
  logoutZ_result_e = P.maybe (P.Nothing) (\(_,_val11332) -> P.Just (case _val11332 of {T.TStruct _val11333 -> (to_TalkException (T.TStruct _val11333)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogoutZ_result _ = P.error "not a struct"
read_LogoutZ_result :: T.Protocol p => p -> P.IO LogoutZ_result
read_LogoutZ_result iprot = to_LogoutZ_result <$> T.readVal iprot (T.T_STRUCT typemap_LogoutZ_result)
decode_LogoutZ_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutZ_result
decode_LogoutZ_result iprot bs = to_LogoutZ_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutZ_result) bs
typemap_LogoutZ_result :: T.TypeMap
typemap_LogoutZ_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LogoutZ_result :: LogoutZ_result
default_LogoutZ_result = LogoutZ_result{
  logoutZ_result_e = P.Nothing}
data LoginZ_args = LoginZ_args  { loginZ_args_loginRequest :: LoginRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginZ_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginZ_args_loginRequest record  
instance QC.Arbitrary LoginZ_args where 
  arbitrary = M.liftM LoginZ_args (QC.arbitrary)
  shrink obj | obj == default_LoginZ_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginZ_args{loginZ_args_loginRequest = loginZ_args_loginRequest obj} then P.Nothing else P.Just $ default_LoginZ_args{loginZ_args_loginRequest = loginZ_args_loginRequest obj}
    ]
from_LoginZ_args :: LoginZ_args -> T.ThriftVal
from_LoginZ_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11336 -> P.Just (2, ("loginRequest",from_LoginRequest _v11336))) $ loginZ_args_loginRequest record
  ]
write_LoginZ_args :: T.Protocol p => p -> LoginZ_args -> P.IO ()
write_LoginZ_args oprot record = T.writeVal oprot $ from_LoginZ_args record
encode_LoginZ_args :: T.StatelessProtocol p => p -> LoginZ_args -> LBS.ByteString
encode_LoginZ_args oprot record = T.serializeVal oprot $ from_LoginZ_args record
to_LoginZ_args :: T.ThriftVal -> LoginZ_args
to_LoginZ_args (T.TStruct fields) = LoginZ_args{
  loginZ_args_loginRequest = P.maybe (loginZ_args_loginRequest default_LoginZ_args) (\(_,_val11338) -> (case _val11338 of {T.TStruct _val11339 -> (to_LoginRequest (T.TStruct _val11339)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LoginZ_args _ = P.error "not a struct"
read_LoginZ_args :: T.Protocol p => p -> P.IO LoginZ_args
read_LoginZ_args iprot = to_LoginZ_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginZ_args)
decode_LoginZ_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginZ_args
decode_LoginZ_args iprot bs = to_LoginZ_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginZ_args) bs
typemap_LoginZ_args :: T.TypeMap
typemap_LoginZ_args = Map.fromList [(2,("loginRequest",(T.T_STRUCT typemap_LoginRequest)))]
default_LoginZ_args :: LoginZ_args
default_LoginZ_args = LoginZ_args{
  loginZ_args_loginRequest = default_LoginRequest}
data LoginZ_result = LoginZ_result  { loginZ_result_success :: LoginResult
  , loginZ_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginZ_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginZ_result_success record   `H.hashWithSalt` loginZ_result_e record  
instance QC.Arbitrary LoginZ_result where 
  arbitrary = M.liftM LoginZ_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginZ_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginZ_result{loginZ_result_success = loginZ_result_success obj} then P.Nothing else P.Just $ default_LoginZ_result{loginZ_result_success = loginZ_result_success obj}
    , if obj == default_LoginZ_result{loginZ_result_e = loginZ_result_e obj} then P.Nothing else P.Just $ default_LoginZ_result{loginZ_result_e = loginZ_result_e obj}
    ]
from_LoginZ_result :: LoginZ_result -> T.ThriftVal
from_LoginZ_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11342 -> (1, ("e",from_TalkException _v11342))) <$> loginZ_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11342 -> P.Just (0, ("success",from_LoginResult _v11342))) $ loginZ_result_success record
    , (\_v11342 -> (1, ("e",from_TalkException _v11342))) <$> loginZ_result_e record
    ]
    )
write_LoginZ_result :: T.Protocol p => p -> LoginZ_result -> P.IO ()
write_LoginZ_result oprot record = T.writeVal oprot $ from_LoginZ_result record
encode_LoginZ_result :: T.StatelessProtocol p => p -> LoginZ_result -> LBS.ByteString
encode_LoginZ_result oprot record = T.serializeVal oprot $ from_LoginZ_result record
to_LoginZ_result :: T.ThriftVal -> LoginZ_result
to_LoginZ_result (T.TStruct fields) = LoginZ_result{
  loginZ_result_success = P.maybe (loginZ_result_success default_LoginZ_result) (\(_,_val11344) -> (case _val11344 of {T.TStruct _val11345 -> (to_LoginResult (T.TStruct _val11345)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginZ_result_e = P.maybe (P.Nothing) (\(_,_val11344) -> P.Just (case _val11344 of {T.TStruct _val11346 -> (to_TalkException (T.TStruct _val11346)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginZ_result _ = P.error "not a struct"
read_LoginZ_result :: T.Protocol p => p -> P.IO LoginZ_result
read_LoginZ_result iprot = to_LoginZ_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginZ_result)
decode_LoginZ_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginZ_result
decode_LoginZ_result iprot bs = to_LoginZ_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginZ_result) bs
typemap_LoginZ_result :: T.TypeMap
typemap_LoginZ_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginZ_result :: LoginZ_result
default_LoginZ_result = LoginZ_result{
  loginZ_result_success = default_LoginResult,
  loginZ_result_e = P.Nothing}
data IssueTokenForAccountMigrationSettings_args = IssueTokenForAccountMigrationSettings_args  { issueTokenForAccountMigrationSettings_args_enforce :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigrationSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigrationSettings_args_enforce record  
instance QC.Arbitrary IssueTokenForAccountMigrationSettings_args where 
  arbitrary = M.liftM IssueTokenForAccountMigrationSettings_args (QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigrationSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigrationSettings_args{issueTokenForAccountMigrationSettings_args_enforce = issueTokenForAccountMigrationSettings_args_enforce obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_args{issueTokenForAccountMigrationSettings_args_enforce = issueTokenForAccountMigrationSettings_args_enforce obj}
    ]
from_IssueTokenForAccountMigrationSettings_args :: IssueTokenForAccountMigrationSettings_args -> T.ThriftVal
from_IssueTokenForAccountMigrationSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11349 -> P.Just (2, ("enforce",T.TBool _v11349))) $ issueTokenForAccountMigrationSettings_args_enforce record
  ]
write_IssueTokenForAccountMigrationSettings_args :: T.Protocol p => p -> IssueTokenForAccountMigrationSettings_args -> P.IO ()
write_IssueTokenForAccountMigrationSettings_args oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigrationSettings_args record
encode_IssueTokenForAccountMigrationSettings_args :: T.StatelessProtocol p => p -> IssueTokenForAccountMigrationSettings_args -> LBS.ByteString
encode_IssueTokenForAccountMigrationSettings_args oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigrationSettings_args record
to_IssueTokenForAccountMigrationSettings_args :: T.ThriftVal -> IssueTokenForAccountMigrationSettings_args
to_IssueTokenForAccountMigrationSettings_args (T.TStruct fields) = IssueTokenForAccountMigrationSettings_args{
  issueTokenForAccountMigrationSettings_args_enforce = P.maybe (issueTokenForAccountMigrationSettings_args_enforce default_IssueTokenForAccountMigrationSettings_args) (\(_,_val11351) -> (case _val11351 of {T.TBool _val11352 -> _val11352; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueTokenForAccountMigrationSettings_args _ = P.error "not a struct"
read_IssueTokenForAccountMigrationSettings_args :: T.Protocol p => p -> P.IO IssueTokenForAccountMigrationSettings_args
read_IssueTokenForAccountMigrationSettings_args iprot = to_IssueTokenForAccountMigrationSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_args)
decode_IssueTokenForAccountMigrationSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigrationSettings_args
decode_IssueTokenForAccountMigrationSettings_args iprot bs = to_IssueTokenForAccountMigrationSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_args) bs
typemap_IssueTokenForAccountMigrationSettings_args :: T.TypeMap
typemap_IssueTokenForAccountMigrationSettings_args = Map.fromList [(2,("enforce",T.T_BOOL))]
default_IssueTokenForAccountMigrationSettings_args :: IssueTokenForAccountMigrationSettings_args
default_IssueTokenForAccountMigrationSettings_args = IssueTokenForAccountMigrationSettings_args{
  issueTokenForAccountMigrationSettings_args_enforce = P.False}
data IssueTokenForAccountMigrationSettings_result = IssueTokenForAccountMigrationSettings_result  { issueTokenForAccountMigrationSettings_result_success :: SecurityCenterResult
  , issueTokenForAccountMigrationSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigrationSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigrationSettings_result_success record   `H.hashWithSalt` issueTokenForAccountMigrationSettings_result_e record  
instance QC.Arbitrary IssueTokenForAccountMigrationSettings_result where 
  arbitrary = M.liftM IssueTokenForAccountMigrationSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigrationSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = issueTokenForAccountMigrationSettings_result_success obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = issueTokenForAccountMigrationSettings_result_success obj}
    , if obj == default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = issueTokenForAccountMigrationSettings_result_e obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = issueTokenForAccountMigrationSettings_result_e obj}
    ]
from_IssueTokenForAccountMigrationSettings_result :: IssueTokenForAccountMigrationSettings_result -> T.ThriftVal
from_IssueTokenForAccountMigrationSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11355 -> (1, ("e",from_TalkException _v11355))) <$> issueTokenForAccountMigrationSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11355 -> P.Just (0, ("success",from_SecurityCenterResult _v11355))) $ issueTokenForAccountMigrationSettings_result_success record
    , (\_v11355 -> (1, ("e",from_TalkException _v11355))) <$> issueTokenForAccountMigrationSettings_result_e record
    ]
    )
write_IssueTokenForAccountMigrationSettings_result :: T.Protocol p => p -> IssueTokenForAccountMigrationSettings_result -> P.IO ()
write_IssueTokenForAccountMigrationSettings_result oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigrationSettings_result record
encode_IssueTokenForAccountMigrationSettings_result :: T.StatelessProtocol p => p -> IssueTokenForAccountMigrationSettings_result -> LBS.ByteString
encode_IssueTokenForAccountMigrationSettings_result oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigrationSettings_result record
to_IssueTokenForAccountMigrationSettings_result :: T.ThriftVal -> IssueTokenForAccountMigrationSettings_result
to_IssueTokenForAccountMigrationSettings_result (T.TStruct fields) = IssueTokenForAccountMigrationSettings_result{
  issueTokenForAccountMigrationSettings_result_success = P.maybe (issueTokenForAccountMigrationSettings_result_success default_IssueTokenForAccountMigrationSettings_result) (\(_,_val11357) -> (case _val11357 of {T.TStruct _val11358 -> (to_SecurityCenterResult (T.TStruct _val11358)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueTokenForAccountMigrationSettings_result_e = P.maybe (P.Nothing) (\(_,_val11357) -> P.Just (case _val11357 of {T.TStruct _val11359 -> (to_TalkException (T.TStruct _val11359)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueTokenForAccountMigrationSettings_result _ = P.error "not a struct"
read_IssueTokenForAccountMigrationSettings_result :: T.Protocol p => p -> P.IO IssueTokenForAccountMigrationSettings_result
read_IssueTokenForAccountMigrationSettings_result iprot = to_IssueTokenForAccountMigrationSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_result)
decode_IssueTokenForAccountMigrationSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigrationSettings_result
decode_IssueTokenForAccountMigrationSettings_result iprot bs = to_IssueTokenForAccountMigrationSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_result) bs
typemap_IssueTokenForAccountMigrationSettings_result :: T.TypeMap
typemap_IssueTokenForAccountMigrationSettings_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SecurityCenterResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IssueTokenForAccountMigrationSettings_result :: IssueTokenForAccountMigrationSettings_result
default_IssueTokenForAccountMigrationSettings_result = IssueTokenForAccountMigrationSettings_result{
  issueTokenForAccountMigrationSettings_result_success = default_SecurityCenterResult,
  issueTokenForAccountMigrationSettings_result_e = P.Nothing}
data IssueTokenForAccountMigration_args = IssueTokenForAccountMigration_args  { issueTokenForAccountMigration_args_migrationSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigration_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigration_args_migrationSessionId record  
instance QC.Arbitrary IssueTokenForAccountMigration_args where 
  arbitrary = M.liftM IssueTokenForAccountMigration_args (QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigration_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigration_args{issueTokenForAccountMigration_args_migrationSessionId = issueTokenForAccountMigration_args_migrationSessionId obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_args{issueTokenForAccountMigration_args_migrationSessionId = issueTokenForAccountMigration_args_migrationSessionId obj}
    ]
from_IssueTokenForAccountMigration_args :: IssueTokenForAccountMigration_args -> T.ThriftVal
from_IssueTokenForAccountMigration_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11362 -> P.Just (2, ("migrationSessionId",T.TString $ E.encodeUtf8 _v11362))) $ issueTokenForAccountMigration_args_migrationSessionId record
  ]
write_IssueTokenForAccountMigration_args :: T.Protocol p => p -> IssueTokenForAccountMigration_args -> P.IO ()
write_IssueTokenForAccountMigration_args oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigration_args record
encode_IssueTokenForAccountMigration_args :: T.StatelessProtocol p => p -> IssueTokenForAccountMigration_args -> LBS.ByteString
encode_IssueTokenForAccountMigration_args oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigration_args record
to_IssueTokenForAccountMigration_args :: T.ThriftVal -> IssueTokenForAccountMigration_args
to_IssueTokenForAccountMigration_args (T.TStruct fields) = IssueTokenForAccountMigration_args{
  issueTokenForAccountMigration_args_migrationSessionId = P.maybe (issueTokenForAccountMigration_args_migrationSessionId default_IssueTokenForAccountMigration_args) (\(_,_val11364) -> (case _val11364 of {T.TString _val11365 -> E.decodeUtf8 _val11365; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueTokenForAccountMigration_args _ = P.error "not a struct"
read_IssueTokenForAccountMigration_args :: T.Protocol p => p -> P.IO IssueTokenForAccountMigration_args
read_IssueTokenForAccountMigration_args iprot = to_IssueTokenForAccountMigration_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_args)
decode_IssueTokenForAccountMigration_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigration_args
decode_IssueTokenForAccountMigration_args iprot bs = to_IssueTokenForAccountMigration_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_args) bs
typemap_IssueTokenForAccountMigration_args :: T.TypeMap
typemap_IssueTokenForAccountMigration_args = Map.fromList [(2,("migrationSessionId",T.T_STRING))]
default_IssueTokenForAccountMigration_args :: IssueTokenForAccountMigration_args
default_IssueTokenForAccountMigration_args = IssueTokenForAccountMigration_args{
  issueTokenForAccountMigration_args_migrationSessionId = ""}
data IssueTokenForAccountMigration_result = IssueTokenForAccountMigration_result  { issueTokenForAccountMigration_result_success :: SecurityCenterResult
  , issueTokenForAccountMigration_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigration_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigration_result_success record   `H.hashWithSalt` issueTokenForAccountMigration_result_e record  
instance QC.Arbitrary IssueTokenForAccountMigration_result where 
  arbitrary = M.liftM IssueTokenForAccountMigration_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigration_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = issueTokenForAccountMigration_result_success obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = issueTokenForAccountMigration_result_success obj}
    , if obj == default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = issueTokenForAccountMigration_result_e obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = issueTokenForAccountMigration_result_e obj}
    ]
from_IssueTokenForAccountMigration_result :: IssueTokenForAccountMigration_result -> T.ThriftVal
from_IssueTokenForAccountMigration_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11368 -> (1, ("e",from_TalkException _v11368))) <$> issueTokenForAccountMigration_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11368 -> P.Just (0, ("success",from_SecurityCenterResult _v11368))) $ issueTokenForAccountMigration_result_success record
    , (\_v11368 -> (1, ("e",from_TalkException _v11368))) <$> issueTokenForAccountMigration_result_e record
    ]
    )
write_IssueTokenForAccountMigration_result :: T.Protocol p => p -> IssueTokenForAccountMigration_result -> P.IO ()
write_IssueTokenForAccountMigration_result oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigration_result record
encode_IssueTokenForAccountMigration_result :: T.StatelessProtocol p => p -> IssueTokenForAccountMigration_result -> LBS.ByteString
encode_IssueTokenForAccountMigration_result oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigration_result record
to_IssueTokenForAccountMigration_result :: T.ThriftVal -> IssueTokenForAccountMigration_result
to_IssueTokenForAccountMigration_result (T.TStruct fields) = IssueTokenForAccountMigration_result{
  issueTokenForAccountMigration_result_success = P.maybe (issueTokenForAccountMigration_result_success default_IssueTokenForAccountMigration_result) (\(_,_val11370) -> (case _val11370 of {T.TStruct _val11371 -> (to_SecurityCenterResult (T.TStruct _val11371)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueTokenForAccountMigration_result_e = P.maybe (P.Nothing) (\(_,_val11370) -> P.Just (case _val11370 of {T.TStruct _val11372 -> (to_TalkException (T.TStruct _val11372)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueTokenForAccountMigration_result _ = P.error "not a struct"
read_IssueTokenForAccountMigration_result :: T.Protocol p => p -> P.IO IssueTokenForAccountMigration_result
read_IssueTokenForAccountMigration_result iprot = to_IssueTokenForAccountMigration_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_result)
decode_IssueTokenForAccountMigration_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigration_result
decode_IssueTokenForAccountMigration_result iprot bs = to_IssueTokenForAccountMigration_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_result) bs
typemap_IssueTokenForAccountMigration_result :: T.TypeMap
typemap_IssueTokenForAccountMigration_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SecurityCenterResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IssueTokenForAccountMigration_result :: IssueTokenForAccountMigration_result
default_IssueTokenForAccountMigration_result = IssueTokenForAccountMigration_result{
  issueTokenForAccountMigration_result_success = default_SecurityCenterResult,
  issueTokenForAccountMigration_result_e = P.Nothing}
data VerifyQrcodeWithE2EE_args = VerifyQrcodeWithE2EE_args  { verifyQrcodeWithE2EE_args_verifier :: LT.Text
  , verifyQrcodeWithE2EE_args_pinCode :: LT.Text
  , verifyQrcodeWithE2EE_args_errorCode :: ErrorCode
  , verifyQrcodeWithE2EE_args_publicKey :: E2EEPublicKey
  , verifyQrcodeWithE2EE_args_encryptedKeyChain :: LBS.ByteString
  , verifyQrcodeWithE2EE_args_hashKeyChain :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcodeWithE2EE_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcodeWithE2EE_args_verifier record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_pinCode record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_errorCode record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_publicKey record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_encryptedKeyChain record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_hashKeyChain record  
instance QC.Arbitrary VerifyQrcodeWithE2EE_args where 
  arbitrary = M.liftM VerifyQrcodeWithE2EE_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyQrcodeWithE2EE_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_verifier = verifyQrcodeWithE2EE_args_verifier obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_verifier = verifyQrcodeWithE2EE_args_verifier obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_pinCode = verifyQrcodeWithE2EE_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_pinCode = verifyQrcodeWithE2EE_args_pinCode obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_errorCode = verifyQrcodeWithE2EE_args_errorCode obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_errorCode = verifyQrcodeWithE2EE_args_errorCode obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_publicKey = verifyQrcodeWithE2EE_args_publicKey obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_publicKey = verifyQrcodeWithE2EE_args_publicKey obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_encryptedKeyChain = verifyQrcodeWithE2EE_args_encryptedKeyChain obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_encryptedKeyChain = verifyQrcodeWithE2EE_args_encryptedKeyChain obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_hashKeyChain = verifyQrcodeWithE2EE_args_hashKeyChain obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_hashKeyChain = verifyQrcodeWithE2EE_args_hashKeyChain obj}
    ]
from_VerifyQrcodeWithE2EE_args :: VerifyQrcodeWithE2EE_args -> T.ThriftVal
from_VerifyQrcodeWithE2EE_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11375 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v11375))) $ verifyQrcodeWithE2EE_args_verifier record
  , (\_v11375 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v11375))) $ verifyQrcodeWithE2EE_args_pinCode record
  , (\_v11375 -> P.Just (4, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v11375))) $ verifyQrcodeWithE2EE_args_errorCode record
  , (\_v11375 -> P.Just (5, ("publicKey",from_E2EEPublicKey _v11375))) $ verifyQrcodeWithE2EE_args_publicKey record
  , (\_v11375 -> P.Just (6, ("encryptedKeyChain",T.TBinary _v11375))) $ verifyQrcodeWithE2EE_args_encryptedKeyChain record
  , (\_v11375 -> P.Just (7, ("hashKeyChain",T.TBinary _v11375))) $ verifyQrcodeWithE2EE_args_hashKeyChain record
  ]
write_VerifyQrcodeWithE2EE_args :: T.Protocol p => p -> VerifyQrcodeWithE2EE_args -> P.IO ()
write_VerifyQrcodeWithE2EE_args oprot record = T.writeVal oprot $ from_VerifyQrcodeWithE2EE_args record
encode_VerifyQrcodeWithE2EE_args :: T.StatelessProtocol p => p -> VerifyQrcodeWithE2EE_args -> LBS.ByteString
encode_VerifyQrcodeWithE2EE_args oprot record = T.serializeVal oprot $ from_VerifyQrcodeWithE2EE_args record
to_VerifyQrcodeWithE2EE_args :: T.ThriftVal -> VerifyQrcodeWithE2EE_args
to_VerifyQrcodeWithE2EE_args (T.TStruct fields) = VerifyQrcodeWithE2EE_args{
  verifyQrcodeWithE2EE_args_verifier = P.maybe (verifyQrcodeWithE2EE_args_verifier default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TString _val11378 -> E.decodeUtf8 _val11378; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyQrcodeWithE2EE_args_pinCode = P.maybe (verifyQrcodeWithE2EE_args_pinCode default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TString _val11379 -> E.decodeUtf8 _val11379; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyQrcodeWithE2EE_args_errorCode = P.maybe (verifyQrcodeWithE2EE_args_errorCode default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TI32 _val11380 -> P.toEnum $ P.fromIntegral _val11380; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  verifyQrcodeWithE2EE_args_publicKey = P.maybe (verifyQrcodeWithE2EE_args_publicKey default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TStruct _val11381 -> (to_E2EEPublicKey (T.TStruct _val11381)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  verifyQrcodeWithE2EE_args_encryptedKeyChain = P.maybe (verifyQrcodeWithE2EE_args_encryptedKeyChain default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TBinary _val11382 -> _val11382; T.TString _val11382 -> _val11382; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  verifyQrcodeWithE2EE_args_hashKeyChain = P.maybe (verifyQrcodeWithE2EE_args_hashKeyChain default_VerifyQrcodeWithE2EE_args) (\(_,_val11377) -> (case _val11377 of {T.TBinary _val11383 -> _val11383; T.TString _val11383 -> _val11383; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_VerifyQrcodeWithE2EE_args _ = P.error "not a struct"
read_VerifyQrcodeWithE2EE_args :: T.Protocol p => p -> P.IO VerifyQrcodeWithE2EE_args
read_VerifyQrcodeWithE2EE_args iprot = to_VerifyQrcodeWithE2EE_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_args)
decode_VerifyQrcodeWithE2EE_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcodeWithE2EE_args
decode_VerifyQrcodeWithE2EE_args iprot bs = to_VerifyQrcodeWithE2EE_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_args) bs
typemap_VerifyQrcodeWithE2EE_args :: T.TypeMap
typemap_VerifyQrcodeWithE2EE_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING)),(4,("errorCode",T.T_I32)),(5,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey))),(6,("encryptedKeyChain",T.T_BINARY)),(7,("hashKeyChain",T.T_BINARY))]
default_VerifyQrcodeWithE2EE_args :: VerifyQrcodeWithE2EE_args
default_VerifyQrcodeWithE2EE_args = VerifyQrcodeWithE2EE_args{
  verifyQrcodeWithE2EE_args_verifier = "",
  verifyQrcodeWithE2EE_args_pinCode = "",
  verifyQrcodeWithE2EE_args_errorCode = (P.toEnum 0),
  verifyQrcodeWithE2EE_args_publicKey = default_E2EEPublicKey,
  verifyQrcodeWithE2EE_args_encryptedKeyChain = "",
  verifyQrcodeWithE2EE_args_hashKeyChain = ""}
data VerifyQrcodeWithE2EE_result = VerifyQrcodeWithE2EE_result  { verifyQrcodeWithE2EE_result_success :: LT.Text
  , verifyQrcodeWithE2EE_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcodeWithE2EE_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcodeWithE2EE_result_success record   `H.hashWithSalt` verifyQrcodeWithE2EE_result_e record  
instance QC.Arbitrary VerifyQrcodeWithE2EE_result where 
  arbitrary = M.liftM VerifyQrcodeWithE2EE_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyQrcodeWithE2EE_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = verifyQrcodeWithE2EE_result_success obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = verifyQrcodeWithE2EE_result_success obj}
    , if obj == default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = verifyQrcodeWithE2EE_result_e obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = verifyQrcodeWithE2EE_result_e obj}
    ]
from_VerifyQrcodeWithE2EE_result :: VerifyQrcodeWithE2EE_result -> T.ThriftVal
from_VerifyQrcodeWithE2EE_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11386 -> (1, ("e",from_TalkException _v11386))) <$> verifyQrcodeWithE2EE_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11386 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v11386))) $ verifyQrcodeWithE2EE_result_success record
    , (\_v11386 -> (1, ("e",from_TalkException _v11386))) <$> verifyQrcodeWithE2EE_result_e record
    ]
    )
write_VerifyQrcodeWithE2EE_result :: T.Protocol p => p -> VerifyQrcodeWithE2EE_result -> P.IO ()
write_VerifyQrcodeWithE2EE_result oprot record = T.writeVal oprot $ from_VerifyQrcodeWithE2EE_result record
encode_VerifyQrcodeWithE2EE_result :: T.StatelessProtocol p => p -> VerifyQrcodeWithE2EE_result -> LBS.ByteString
encode_VerifyQrcodeWithE2EE_result oprot record = T.serializeVal oprot $ from_VerifyQrcodeWithE2EE_result record
to_VerifyQrcodeWithE2EE_result :: T.ThriftVal -> VerifyQrcodeWithE2EE_result
to_VerifyQrcodeWithE2EE_result (T.TStruct fields) = VerifyQrcodeWithE2EE_result{
  verifyQrcodeWithE2EE_result_success = P.maybe (verifyQrcodeWithE2EE_result_success default_VerifyQrcodeWithE2EE_result) (\(_,_val11388) -> (case _val11388 of {T.TString _val11389 -> E.decodeUtf8 _val11389; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyQrcodeWithE2EE_result_e = P.maybe (P.Nothing) (\(_,_val11388) -> P.Just (case _val11388 of {T.TStruct _val11390 -> (to_TalkException (T.TStruct _val11390)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyQrcodeWithE2EE_result _ = P.error "not a struct"
read_VerifyQrcodeWithE2EE_result :: T.Protocol p => p -> P.IO VerifyQrcodeWithE2EE_result
read_VerifyQrcodeWithE2EE_result iprot = to_VerifyQrcodeWithE2EE_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_result)
decode_VerifyQrcodeWithE2EE_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcodeWithE2EE_result
decode_VerifyQrcodeWithE2EE_result iprot bs = to_VerifyQrcodeWithE2EE_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_result) bs
typemap_VerifyQrcodeWithE2EE_result :: T.TypeMap
typemap_VerifyQrcodeWithE2EE_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyQrcodeWithE2EE_result :: VerifyQrcodeWithE2EE_result
default_VerifyQrcodeWithE2EE_result = VerifyQrcodeWithE2EE_result{
  verifyQrcodeWithE2EE_result_success = "",
  verifyQrcodeWithE2EE_result_e = P.Nothing}
process_updatePassword (seqid, iprot, oprot, handler) = do
  args <- read_UpdatePassword_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updatePassword handler (updatePassword_args_authSessionId args) (updatePassword_args_request args)
        let res = default_UpdatePassword_result{updatePassword_result_success = val}
        T.writeMessage oprot ("updatePassword", T.M_REPLY, seqid) $
          write_UpdatePassword_result oprot res)
      (\e  -> do
        let res = default_UpdatePassword_result{updatePassword_result_e = P.Just e}
        T.writeMessage oprot ("updatePassword", T.M_REPLY, seqid) $
          write_UpdatePassword_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updatePassword", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAuthRSAKey (seqid, iprot, oprot, handler) = do
  args <- read_GetAuthRSAKey_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAuthRSAKey handler (getAuthRSAKey_args_authSessionId args) (getAuthRSAKey_args_identityProvider args)
        let res = default_GetAuthRSAKey_result{getAuthRSAKey_result_success = val}
        T.writeMessage oprot ("getAuthRSAKey", T.M_REPLY, seqid) $
          write_GetAuthRSAKey_result oprot res)
      (\e  -> do
        let res = default_GetAuthRSAKey_result{getAuthRSAKey_result_e = P.Just e}
        T.writeMessage oprot ("getAuthRSAKey", T.M_REPLY, seqid) $
          write_GetAuthRSAKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAuthRSAKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_openAuthSession (seqid, iprot, oprot, handler) = do
  args <- read_OpenAuthSession_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.openAuthSession handler (openAuthSession_args_request args)
        let res = default_OpenAuthSession_result{openAuthSession_result_success = val}
        T.writeMessage oprot ("openAuthSession", T.M_REPLY, seqid) $
          write_OpenAuthSession_result oprot res)
      (\e  -> do
        let res = default_OpenAuthSession_result{openAuthSession_result_e = P.Just e}
        T.writeMessage oprot ("openAuthSession", T.M_REPLY, seqid) $
          write_OpenAuthSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("openAuthSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_normalizePhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_NormalizePhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.normalizePhoneNumber handler (normalizePhoneNumber_args_countryCode args) (normalizePhoneNumber_args_phoneNumber args) (normalizePhoneNumber_args_countryCodeHint args)
        let res = default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = val}
        T.writeMessage oprot ("normalizePhoneNumber", T.M_REPLY, seqid) $
          write_NormalizePhoneNumber_result oprot res)
      (\e  -> do
        let res = default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("normalizePhoneNumber", T.M_REPLY, seqid) $
          write_NormalizePhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("normalizePhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_respondE2EELoginRequest (seqid, iprot, oprot, handler) = do
  args <- read_RespondE2EELoginRequest_args iprot
  (X.catch
    (X.catch
      (do
        Iface.respondE2EELoginRequest handler (respondE2EELoginRequest_args_verifier args) (respondE2EELoginRequest_args_publicKey args) (respondE2EELoginRequest_args_encryptedKeyChain args) (respondE2EELoginRequest_args_hashKeyChain args) (respondE2EELoginRequest_args_errorCode args)
        let res = default_RespondE2EELoginRequest_result
        T.writeMessage oprot ("respondE2EELoginRequest", T.M_REPLY, seqid) $
          write_RespondE2EELoginRequest_result oprot res)
      (\e  -> do
        let res = default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = P.Just e}
        T.writeMessage oprot ("respondE2EELoginRequest", T.M_REPLY, seqid) $
          write_RespondE2EELoginRequest_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("respondE2EELoginRequest", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_confirmE2EELogin (seqid, iprot, oprot, handler) = do
  args <- read_ConfirmE2EELogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.confirmE2EELogin handler (confirmE2EELogin_args_verifier args) (confirmE2EELogin_args_deviceSecret args)
        let res = default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = val}
        T.writeMessage oprot ("confirmE2EELogin", T.M_REPLY, seqid) $
          write_ConfirmE2EELogin_result oprot res)
      (\e  -> do
        let res = default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = P.Just e}
        T.writeMessage oprot ("confirmE2EELogin", T.M_REPLY, seqid) $
          write_ConfirmE2EELogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("confirmE2EELogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logoutZ (seqid, iprot, oprot, handler) = do
  args <- read_LogoutZ_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logoutZ handler
        let res = default_LogoutZ_result
        T.writeMessage oprot ("logoutZ", T.M_REPLY, seqid) $
          write_LogoutZ_result oprot res)
      (\e  -> do
        let res = default_LogoutZ_result{logoutZ_result_e = P.Just e}
        T.writeMessage oprot ("logoutZ", T.M_REPLY, seqid) $
          write_LogoutZ_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logoutZ", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginZ (seqid, iprot, oprot, handler) = do
  args <- read_LoginZ_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginZ handler (loginZ_args_loginRequest args)
        let res = default_LoginZ_result{loginZ_result_success = val}
        T.writeMessage oprot ("loginZ", T.M_REPLY, seqid) $
          write_LoginZ_result oprot res)
      (\e  -> do
        let res = default_LoginZ_result{loginZ_result_e = P.Just e}
        T.writeMessage oprot ("loginZ", T.M_REPLY, seqid) $
          write_LoginZ_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginZ", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueTokenForAccountMigrationSettings (seqid, iprot, oprot, handler) = do
  args <- read_IssueTokenForAccountMigrationSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueTokenForAccountMigrationSettings handler (issueTokenForAccountMigrationSettings_args_enforce args)
        let res = default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = val}
        T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigrationSettings_result oprot res)
      (\e  -> do
        let res = default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = P.Just e}
        T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigrationSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueTokenForAccountMigration (seqid, iprot, oprot, handler) = do
  args <- read_IssueTokenForAccountMigration_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueTokenForAccountMigration handler (issueTokenForAccountMigration_args_migrationSessionId args)
        let res = default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = val}
        T.writeMessage oprot ("issueTokenForAccountMigration", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigration_result oprot res)
      (\e  -> do
        let res = default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = P.Just e}
        T.writeMessage oprot ("issueTokenForAccountMigration", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigration_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueTokenForAccountMigration", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyQrcodeWithE2EE (seqid, iprot, oprot, handler) = do
  args <- read_VerifyQrcodeWithE2EE_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyQrcodeWithE2EE handler (verifyQrcodeWithE2EE_args_verifier args) (verifyQrcodeWithE2EE_args_pinCode args) (verifyQrcodeWithE2EE_args_errorCode args) (verifyQrcodeWithE2EE_args_publicKey args) (verifyQrcodeWithE2EE_args_encryptedKeyChain args) (verifyQrcodeWithE2EE_args_hashKeyChain args)
        let res = default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = val}
        T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_REPLY, seqid) $
          write_VerifyQrcodeWithE2EE_result oprot res)
      (\e  -> do
        let res = default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = P.Just e}
        T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_REPLY, seqid) $
          write_VerifyQrcodeWithE2EE_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "updatePassword" -> process_updatePassword (seqid,iprot,oprot,handler)
  "getAuthRSAKey" -> process_getAuthRSAKey (seqid,iprot,oprot,handler)
  "openAuthSession" -> process_openAuthSession (seqid,iprot,oprot,handler)
  "normalizePhoneNumber" -> process_normalizePhoneNumber (seqid,iprot,oprot,handler)
  "respondE2EELoginRequest" -> process_respondE2EELoginRequest (seqid,iprot,oprot,handler)
  "confirmE2EELogin" -> process_confirmE2EELogin (seqid,iprot,oprot,handler)
  "logoutZ" -> process_logoutZ (seqid,iprot,oprot,handler)
  "loginZ" -> process_loginZ (seqid,iprot,oprot,handler)
  "issueTokenForAccountMigrationSettings" -> process_issueTokenForAccountMigrationSettings (seqid,iprot,oprot,handler)
  "issueTokenForAccountMigration" -> process_issueTokenForAccountMigration (seqid,iprot,oprot,handler)
  "verifyQrcodeWithE2EE" -> process_verifyQrcodeWithE2EE (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
