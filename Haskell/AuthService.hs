{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.13.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AuthService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified AuthService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data NormalizePhoneNumber_args = NormalizePhoneNumber_args  { normalizePhoneNumber_args_countryCode :: LT.Text
  , normalizePhoneNumber_args_phoneNumber :: LT.Text
  , normalizePhoneNumber_args_countryCodeHint :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NormalizePhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` normalizePhoneNumber_args_countryCode record   `H.hashWithSalt` normalizePhoneNumber_args_phoneNumber record   `H.hashWithSalt` normalizePhoneNumber_args_countryCodeHint record  
instance QC.Arbitrary NormalizePhoneNumber_args where 
  arbitrary = M.liftM NormalizePhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NormalizePhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCode = normalizePhoneNumber_args_countryCode obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCode = normalizePhoneNumber_args_countryCode obj}
    , if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_phoneNumber = normalizePhoneNumber_args_phoneNumber obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_phoneNumber = normalizePhoneNumber_args_phoneNumber obj}
    , if obj == default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCodeHint = normalizePhoneNumber_args_countryCodeHint obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_args{normalizePhoneNumber_args_countryCodeHint = normalizePhoneNumber_args_countryCodeHint obj}
    ]
from_NormalizePhoneNumber_args :: NormalizePhoneNumber_args -> T.ThriftVal
from_NormalizePhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10690 -> P.Just (2, ("countryCode",T.TString $ E.encodeUtf8 _v10690))) $ normalizePhoneNumber_args_countryCode record
  , (\_v10690 -> P.Just (3, ("phoneNumber",T.TString $ E.encodeUtf8 _v10690))) $ normalizePhoneNumber_args_phoneNumber record
  , (\_v10690 -> P.Just (4, ("countryCodeHint",T.TString $ E.encodeUtf8 _v10690))) $ normalizePhoneNumber_args_countryCodeHint record
  ]
write_NormalizePhoneNumber_args :: T.Protocol p => p -> NormalizePhoneNumber_args -> P.IO ()
write_NormalizePhoneNumber_args oprot record = T.writeVal oprot $ from_NormalizePhoneNumber_args record
encode_NormalizePhoneNumber_args :: T.StatelessProtocol p => p -> NormalizePhoneNumber_args -> LBS.ByteString
encode_NormalizePhoneNumber_args oprot record = T.serializeVal oprot $ from_NormalizePhoneNumber_args record
to_NormalizePhoneNumber_args :: T.ThriftVal -> NormalizePhoneNumber_args
to_NormalizePhoneNumber_args (T.TStruct fields) = NormalizePhoneNumber_args{
  normalizePhoneNumber_args_countryCode = P.maybe (normalizePhoneNumber_args_countryCode default_NormalizePhoneNumber_args) (\(_,_val10692) -> (case _val10692 of {T.TString _val10693 -> E.decodeUtf8 _val10693; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  normalizePhoneNumber_args_phoneNumber = P.maybe (normalizePhoneNumber_args_phoneNumber default_NormalizePhoneNumber_args) (\(_,_val10692) -> (case _val10692 of {T.TString _val10694 -> E.decodeUtf8 _val10694; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  normalizePhoneNumber_args_countryCodeHint = P.maybe (normalizePhoneNumber_args_countryCodeHint default_NormalizePhoneNumber_args) (\(_,_val10692) -> (case _val10692 of {T.TString _val10695 -> E.decodeUtf8 _val10695; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_NormalizePhoneNumber_args _ = P.error "not a struct"
read_NormalizePhoneNumber_args :: T.Protocol p => p -> P.IO NormalizePhoneNumber_args
read_NormalizePhoneNumber_args iprot = to_NormalizePhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_args)
decode_NormalizePhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NormalizePhoneNumber_args
decode_NormalizePhoneNumber_args iprot bs = to_NormalizePhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_args) bs
typemap_NormalizePhoneNumber_args :: T.TypeMap
typemap_NormalizePhoneNumber_args = Map.fromList [(2,("countryCode",T.T_STRING)),(3,("phoneNumber",T.T_STRING)),(4,("countryCodeHint",T.T_STRING))]
default_NormalizePhoneNumber_args :: NormalizePhoneNumber_args
default_NormalizePhoneNumber_args = NormalizePhoneNumber_args{
  normalizePhoneNumber_args_countryCode = "",
  normalizePhoneNumber_args_phoneNumber = "",
  normalizePhoneNumber_args_countryCodeHint = ""}
data NormalizePhoneNumber_result = NormalizePhoneNumber_result  { normalizePhoneNumber_result_success :: LT.Text
  , normalizePhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NormalizePhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` normalizePhoneNumber_result_success record   `H.hashWithSalt` normalizePhoneNumber_result_e record  
instance QC.Arbitrary NormalizePhoneNumber_result where 
  arbitrary = M.liftM NormalizePhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NormalizePhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = normalizePhoneNumber_result_success obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = normalizePhoneNumber_result_success obj}
    , if obj == default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = normalizePhoneNumber_result_e obj} then P.Nothing else P.Just $ default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = normalizePhoneNumber_result_e obj}
    ]
from_NormalizePhoneNumber_result :: NormalizePhoneNumber_result -> T.ThriftVal
from_NormalizePhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10698 -> (1, ("e",from_TalkException _v10698))) <$> normalizePhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10698 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10698))) $ normalizePhoneNumber_result_success record
    , (\_v10698 -> (1, ("e",from_TalkException _v10698))) <$> normalizePhoneNumber_result_e record
    ]
    )
write_NormalizePhoneNumber_result :: T.Protocol p => p -> NormalizePhoneNumber_result -> P.IO ()
write_NormalizePhoneNumber_result oprot record = T.writeVal oprot $ from_NormalizePhoneNumber_result record
encode_NormalizePhoneNumber_result :: T.StatelessProtocol p => p -> NormalizePhoneNumber_result -> LBS.ByteString
encode_NormalizePhoneNumber_result oprot record = T.serializeVal oprot $ from_NormalizePhoneNumber_result record
to_NormalizePhoneNumber_result :: T.ThriftVal -> NormalizePhoneNumber_result
to_NormalizePhoneNumber_result (T.TStruct fields) = NormalizePhoneNumber_result{
  normalizePhoneNumber_result_success = P.maybe (normalizePhoneNumber_result_success default_NormalizePhoneNumber_result) (\(_,_val10700) -> (case _val10700 of {T.TString _val10701 -> E.decodeUtf8 _val10701; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  normalizePhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val10700) -> P.Just (case _val10700 of {T.TStruct _val10702 -> (to_TalkException (T.TStruct _val10702)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NormalizePhoneNumber_result _ = P.error "not a struct"
read_NormalizePhoneNumber_result :: T.Protocol p => p -> P.IO NormalizePhoneNumber_result
read_NormalizePhoneNumber_result iprot = to_NormalizePhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_result)
decode_NormalizePhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NormalizePhoneNumber_result
decode_NormalizePhoneNumber_result iprot bs = to_NormalizePhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NormalizePhoneNumber_result) bs
typemap_NormalizePhoneNumber_result :: T.TypeMap
typemap_NormalizePhoneNumber_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NormalizePhoneNumber_result :: NormalizePhoneNumber_result
default_NormalizePhoneNumber_result = NormalizePhoneNumber_result{
  normalizePhoneNumber_result_success = "",
  normalizePhoneNumber_result_e = P.Nothing}
data RespondE2EELoginRequest_args = RespondE2EELoginRequest_args  { respondE2EELoginRequest_args_verifier :: LT.Text
  , respondE2EELoginRequest_args_publicKey :: E2EEPublicKey
  , respondE2EELoginRequest_args_encryptedKeyChain :: LBS.ByteString
  , respondE2EELoginRequest_args_hashKeyChain :: LBS.ByteString
  , respondE2EELoginRequest_args_errorCode :: ErrorCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondE2EELoginRequest_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondE2EELoginRequest_args_verifier record   `H.hashWithSalt` respondE2EELoginRequest_args_publicKey record   `H.hashWithSalt` respondE2EELoginRequest_args_encryptedKeyChain record   `H.hashWithSalt` respondE2EELoginRequest_args_hashKeyChain record   `H.hashWithSalt` respondE2EELoginRequest_args_errorCode record  
instance QC.Arbitrary RespondE2EELoginRequest_args where 
  arbitrary = M.liftM RespondE2EELoginRequest_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RespondE2EELoginRequest_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_verifier = respondE2EELoginRequest_args_verifier obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_verifier = respondE2EELoginRequest_args_verifier obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_publicKey = respondE2EELoginRequest_args_publicKey obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_publicKey = respondE2EELoginRequest_args_publicKey obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_encryptedKeyChain = respondE2EELoginRequest_args_encryptedKeyChain obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_encryptedKeyChain = respondE2EELoginRequest_args_encryptedKeyChain obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_hashKeyChain = respondE2EELoginRequest_args_hashKeyChain obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_hashKeyChain = respondE2EELoginRequest_args_hashKeyChain obj}
    , if obj == default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_errorCode = respondE2EELoginRequest_args_errorCode obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_args{respondE2EELoginRequest_args_errorCode = respondE2EELoginRequest_args_errorCode obj}
    ]
from_RespondE2EELoginRequest_args :: RespondE2EELoginRequest_args -> T.ThriftVal
from_RespondE2EELoginRequest_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10705 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v10705))) $ respondE2EELoginRequest_args_verifier record
  , (\_v10705 -> P.Just (2, ("publicKey",from_E2EEPublicKey _v10705))) $ respondE2EELoginRequest_args_publicKey record
  , (\_v10705 -> P.Just (3, ("encryptedKeyChain",T.TBinary _v10705))) $ respondE2EELoginRequest_args_encryptedKeyChain record
  , (\_v10705 -> P.Just (4, ("hashKeyChain",T.TBinary _v10705))) $ respondE2EELoginRequest_args_hashKeyChain record
  , (\_v10705 -> P.Just (5, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v10705))) $ respondE2EELoginRequest_args_errorCode record
  ]
write_RespondE2EELoginRequest_args :: T.Protocol p => p -> RespondE2EELoginRequest_args -> P.IO ()
write_RespondE2EELoginRequest_args oprot record = T.writeVal oprot $ from_RespondE2EELoginRequest_args record
encode_RespondE2EELoginRequest_args :: T.StatelessProtocol p => p -> RespondE2EELoginRequest_args -> LBS.ByteString
encode_RespondE2EELoginRequest_args oprot record = T.serializeVal oprot $ from_RespondE2EELoginRequest_args record
to_RespondE2EELoginRequest_args :: T.ThriftVal -> RespondE2EELoginRequest_args
to_RespondE2EELoginRequest_args (T.TStruct fields) = RespondE2EELoginRequest_args{
  respondE2EELoginRequest_args_verifier = P.maybe (respondE2EELoginRequest_args_verifier default_RespondE2EELoginRequest_args) (\(_,_val10707) -> (case _val10707 of {T.TString _val10708 -> E.decodeUtf8 _val10708; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  respondE2EELoginRequest_args_publicKey = P.maybe (respondE2EELoginRequest_args_publicKey default_RespondE2EELoginRequest_args) (\(_,_val10707) -> (case _val10707 of {T.TStruct _val10709 -> (to_E2EEPublicKey (T.TStruct _val10709)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  respondE2EELoginRequest_args_encryptedKeyChain = P.maybe (respondE2EELoginRequest_args_encryptedKeyChain default_RespondE2EELoginRequest_args) (\(_,_val10707) -> (case _val10707 of {T.TBinary _val10710 -> _val10710; T.TString _val10710 -> _val10710; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  respondE2EELoginRequest_args_hashKeyChain = P.maybe (respondE2EELoginRequest_args_hashKeyChain default_RespondE2EELoginRequest_args) (\(_,_val10707) -> (case _val10707 of {T.TBinary _val10711 -> _val10711; T.TString _val10711 -> _val10711; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  respondE2EELoginRequest_args_errorCode = P.maybe (respondE2EELoginRequest_args_errorCode default_RespondE2EELoginRequest_args) (\(_,_val10707) -> (case _val10707 of {T.TI32 _val10712 -> P.toEnum $ P.fromIntegral _val10712; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RespondE2EELoginRequest_args _ = P.error "not a struct"
read_RespondE2EELoginRequest_args :: T.Protocol p => p -> P.IO RespondE2EELoginRequest_args
read_RespondE2EELoginRequest_args iprot = to_RespondE2EELoginRequest_args <$> T.readVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_args)
decode_RespondE2EELoginRequest_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondE2EELoginRequest_args
decode_RespondE2EELoginRequest_args iprot bs = to_RespondE2EELoginRequest_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_args) bs
typemap_RespondE2EELoginRequest_args :: T.TypeMap
typemap_RespondE2EELoginRequest_args = Map.fromList [(1,("verifier",T.T_STRING)),(2,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey))),(3,("encryptedKeyChain",T.T_BINARY)),(4,("hashKeyChain",T.T_BINARY)),(5,("errorCode",T.T_I32))]
default_RespondE2EELoginRequest_args :: RespondE2EELoginRequest_args
default_RespondE2EELoginRequest_args = RespondE2EELoginRequest_args{
  respondE2EELoginRequest_args_verifier = "",
  respondE2EELoginRequest_args_publicKey = default_E2EEPublicKey,
  respondE2EELoginRequest_args_encryptedKeyChain = "",
  respondE2EELoginRequest_args_hashKeyChain = "",
  respondE2EELoginRequest_args_errorCode = (P.toEnum 0)}
data RespondE2EELoginRequest_result = RespondE2EELoginRequest_result  { respondE2EELoginRequest_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondE2EELoginRequest_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondE2EELoginRequest_result_e record  
instance QC.Arbitrary RespondE2EELoginRequest_result where 
  arbitrary = M.liftM RespondE2EELoginRequest_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RespondE2EELoginRequest_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = respondE2EELoginRequest_result_e obj} then P.Nothing else P.Just $ default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = respondE2EELoginRequest_result_e obj}
    ]
from_RespondE2EELoginRequest_result :: RespondE2EELoginRequest_result -> T.ThriftVal
from_RespondE2EELoginRequest_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10715 -> (1, ("e",from_TalkException _v10715))) <$> respondE2EELoginRequest_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10715 -> (1, ("e",from_TalkException _v10715))) <$> respondE2EELoginRequest_result_e record
    ]
    )
write_RespondE2EELoginRequest_result :: T.Protocol p => p -> RespondE2EELoginRequest_result -> P.IO ()
write_RespondE2EELoginRequest_result oprot record = T.writeVal oprot $ from_RespondE2EELoginRequest_result record
encode_RespondE2EELoginRequest_result :: T.StatelessProtocol p => p -> RespondE2EELoginRequest_result -> LBS.ByteString
encode_RespondE2EELoginRequest_result oprot record = T.serializeVal oprot $ from_RespondE2EELoginRequest_result record
to_RespondE2EELoginRequest_result :: T.ThriftVal -> RespondE2EELoginRequest_result
to_RespondE2EELoginRequest_result (T.TStruct fields) = RespondE2EELoginRequest_result{
  respondE2EELoginRequest_result_e = P.maybe (P.Nothing) (\(_,_val10717) -> P.Just (case _val10717 of {T.TStruct _val10718 -> (to_TalkException (T.TStruct _val10718)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RespondE2EELoginRequest_result _ = P.error "not a struct"
read_RespondE2EELoginRequest_result :: T.Protocol p => p -> P.IO RespondE2EELoginRequest_result
read_RespondE2EELoginRequest_result iprot = to_RespondE2EELoginRequest_result <$> T.readVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_result)
decode_RespondE2EELoginRequest_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondE2EELoginRequest_result
decode_RespondE2EELoginRequest_result iprot bs = to_RespondE2EELoginRequest_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondE2EELoginRequest_result) bs
typemap_RespondE2EELoginRequest_result :: T.TypeMap
typemap_RespondE2EELoginRequest_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RespondE2EELoginRequest_result :: RespondE2EELoginRequest_result
default_RespondE2EELoginRequest_result = RespondE2EELoginRequest_result{
  respondE2EELoginRequest_result_e = P.Nothing}
data ConfirmE2EELogin_args = ConfirmE2EELogin_args  { confirmE2EELogin_args_verifier :: LT.Text
  , confirmE2EELogin_args_deviceSecret :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmE2EELogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmE2EELogin_args_verifier record   `H.hashWithSalt` confirmE2EELogin_args_deviceSecret record  
instance QC.Arbitrary ConfirmE2EELogin_args where 
  arbitrary = M.liftM ConfirmE2EELogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfirmE2EELogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmE2EELogin_args{confirmE2EELogin_args_verifier = confirmE2EELogin_args_verifier obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_args{confirmE2EELogin_args_verifier = confirmE2EELogin_args_verifier obj}
    , if obj == default_ConfirmE2EELogin_args{confirmE2EELogin_args_deviceSecret = confirmE2EELogin_args_deviceSecret obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_args{confirmE2EELogin_args_deviceSecret = confirmE2EELogin_args_deviceSecret obj}
    ]
from_ConfirmE2EELogin_args :: ConfirmE2EELogin_args -> T.ThriftVal
from_ConfirmE2EELogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10721 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v10721))) $ confirmE2EELogin_args_verifier record
  , (\_v10721 -> P.Just (2, ("deviceSecret",T.TBinary _v10721))) $ confirmE2EELogin_args_deviceSecret record
  ]
write_ConfirmE2EELogin_args :: T.Protocol p => p -> ConfirmE2EELogin_args -> P.IO ()
write_ConfirmE2EELogin_args oprot record = T.writeVal oprot $ from_ConfirmE2EELogin_args record
encode_ConfirmE2EELogin_args :: T.StatelessProtocol p => p -> ConfirmE2EELogin_args -> LBS.ByteString
encode_ConfirmE2EELogin_args oprot record = T.serializeVal oprot $ from_ConfirmE2EELogin_args record
to_ConfirmE2EELogin_args :: T.ThriftVal -> ConfirmE2EELogin_args
to_ConfirmE2EELogin_args (T.TStruct fields) = ConfirmE2EELogin_args{
  confirmE2EELogin_args_verifier = P.maybe (confirmE2EELogin_args_verifier default_ConfirmE2EELogin_args) (\(_,_val10723) -> (case _val10723 of {T.TString _val10724 -> E.decodeUtf8 _val10724; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  confirmE2EELogin_args_deviceSecret = P.maybe (confirmE2EELogin_args_deviceSecret default_ConfirmE2EELogin_args) (\(_,_val10723) -> (case _val10723 of {T.TBinary _val10725 -> _val10725; T.TString _val10725 -> _val10725; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ConfirmE2EELogin_args _ = P.error "not a struct"
read_ConfirmE2EELogin_args :: T.Protocol p => p -> P.IO ConfirmE2EELogin_args
read_ConfirmE2EELogin_args iprot = to_ConfirmE2EELogin_args <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_args)
decode_ConfirmE2EELogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmE2EELogin_args
decode_ConfirmE2EELogin_args iprot bs = to_ConfirmE2EELogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_args) bs
typemap_ConfirmE2EELogin_args :: T.TypeMap
typemap_ConfirmE2EELogin_args = Map.fromList [(1,("verifier",T.T_STRING)),(2,("deviceSecret",T.T_BINARY))]
default_ConfirmE2EELogin_args :: ConfirmE2EELogin_args
default_ConfirmE2EELogin_args = ConfirmE2EELogin_args{
  confirmE2EELogin_args_verifier = "",
  confirmE2EELogin_args_deviceSecret = ""}
data ConfirmE2EELogin_result = ConfirmE2EELogin_result  { confirmE2EELogin_result_success :: LT.Text
  , confirmE2EELogin_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmE2EELogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmE2EELogin_result_success record   `H.hashWithSalt` confirmE2EELogin_result_e record  
instance QC.Arbitrary ConfirmE2EELogin_result where 
  arbitrary = M.liftM ConfirmE2EELogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ConfirmE2EELogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = confirmE2EELogin_result_success obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = confirmE2EELogin_result_success obj}
    , if obj == default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = confirmE2EELogin_result_e obj} then P.Nothing else P.Just $ default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = confirmE2EELogin_result_e obj}
    ]
from_ConfirmE2EELogin_result :: ConfirmE2EELogin_result -> T.ThriftVal
from_ConfirmE2EELogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10728 -> (1, ("e",from_TalkException _v10728))) <$> confirmE2EELogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10728 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10728))) $ confirmE2EELogin_result_success record
    , (\_v10728 -> (1, ("e",from_TalkException _v10728))) <$> confirmE2EELogin_result_e record
    ]
    )
write_ConfirmE2EELogin_result :: T.Protocol p => p -> ConfirmE2EELogin_result -> P.IO ()
write_ConfirmE2EELogin_result oprot record = T.writeVal oprot $ from_ConfirmE2EELogin_result record
encode_ConfirmE2EELogin_result :: T.StatelessProtocol p => p -> ConfirmE2EELogin_result -> LBS.ByteString
encode_ConfirmE2EELogin_result oprot record = T.serializeVal oprot $ from_ConfirmE2EELogin_result record
to_ConfirmE2EELogin_result :: T.ThriftVal -> ConfirmE2EELogin_result
to_ConfirmE2EELogin_result (T.TStruct fields) = ConfirmE2EELogin_result{
  confirmE2EELogin_result_success = P.maybe (confirmE2EELogin_result_success default_ConfirmE2EELogin_result) (\(_,_val10730) -> (case _val10730 of {T.TString _val10731 -> E.decodeUtf8 _val10731; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  confirmE2EELogin_result_e = P.maybe (P.Nothing) (\(_,_val10730) -> P.Just (case _val10730 of {T.TStruct _val10732 -> (to_TalkException (T.TStruct _val10732)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ConfirmE2EELogin_result _ = P.error "not a struct"
read_ConfirmE2EELogin_result :: T.Protocol p => p -> P.IO ConfirmE2EELogin_result
read_ConfirmE2EELogin_result iprot = to_ConfirmE2EELogin_result <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_result)
decode_ConfirmE2EELogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmE2EELogin_result
decode_ConfirmE2EELogin_result iprot bs = to_ConfirmE2EELogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmE2EELogin_result) bs
typemap_ConfirmE2EELogin_result :: T.TypeMap
typemap_ConfirmE2EELogin_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ConfirmE2EELogin_result :: ConfirmE2EELogin_result
default_ConfirmE2EELogin_result = ConfirmE2EELogin_result{
  confirmE2EELogin_result_success = "",
  confirmE2EELogin_result_e = P.Nothing}
data LogoutZ_args = LogoutZ_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutZ_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary LogoutZ_args where 
  arbitrary = QC.elements [LogoutZ_args]
from_LogoutZ_args :: LogoutZ_args -> T.ThriftVal
from_LogoutZ_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_LogoutZ_args :: T.Protocol p => p -> LogoutZ_args -> P.IO ()
write_LogoutZ_args oprot record = T.writeVal oprot $ from_LogoutZ_args record
encode_LogoutZ_args :: T.StatelessProtocol p => p -> LogoutZ_args -> LBS.ByteString
encode_LogoutZ_args oprot record = T.serializeVal oprot $ from_LogoutZ_args record
to_LogoutZ_args :: T.ThriftVal -> LogoutZ_args
to_LogoutZ_args (T.TStruct fields) = LogoutZ_args{

  }
to_LogoutZ_args _ = P.error "not a struct"
read_LogoutZ_args :: T.Protocol p => p -> P.IO LogoutZ_args
read_LogoutZ_args iprot = to_LogoutZ_args <$> T.readVal iprot (T.T_STRUCT typemap_LogoutZ_args)
decode_LogoutZ_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutZ_args
decode_LogoutZ_args iprot bs = to_LogoutZ_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutZ_args) bs
typemap_LogoutZ_args :: T.TypeMap
typemap_LogoutZ_args = Map.fromList []
default_LogoutZ_args :: LogoutZ_args
default_LogoutZ_args = LogoutZ_args{
}
data LogoutZ_result = LogoutZ_result  { logoutZ_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutZ_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutZ_result_e record  
instance QC.Arbitrary LogoutZ_result where 
  arbitrary = M.liftM LogoutZ_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LogoutZ_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutZ_result{logoutZ_result_e = logoutZ_result_e obj} then P.Nothing else P.Just $ default_LogoutZ_result{logoutZ_result_e = logoutZ_result_e obj}
    ]
from_LogoutZ_result :: LogoutZ_result -> T.ThriftVal
from_LogoutZ_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10740 -> (1, ("e",from_TalkException _v10740))) <$> logoutZ_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10740 -> (1, ("e",from_TalkException _v10740))) <$> logoutZ_result_e record
    ]
    )
write_LogoutZ_result :: T.Protocol p => p -> LogoutZ_result -> P.IO ()
write_LogoutZ_result oprot record = T.writeVal oprot $ from_LogoutZ_result record
encode_LogoutZ_result :: T.StatelessProtocol p => p -> LogoutZ_result -> LBS.ByteString
encode_LogoutZ_result oprot record = T.serializeVal oprot $ from_LogoutZ_result record
to_LogoutZ_result :: T.ThriftVal -> LogoutZ_result
to_LogoutZ_result (T.TStruct fields) = LogoutZ_result{
  logoutZ_result_e = P.maybe (P.Nothing) (\(_,_val10742) -> P.Just (case _val10742 of {T.TStruct _val10743 -> (to_TalkException (T.TStruct _val10743)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogoutZ_result _ = P.error "not a struct"
read_LogoutZ_result :: T.Protocol p => p -> P.IO LogoutZ_result
read_LogoutZ_result iprot = to_LogoutZ_result <$> T.readVal iprot (T.T_STRUCT typemap_LogoutZ_result)
decode_LogoutZ_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutZ_result
decode_LogoutZ_result iprot bs = to_LogoutZ_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutZ_result) bs
typemap_LogoutZ_result :: T.TypeMap
typemap_LogoutZ_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LogoutZ_result :: LogoutZ_result
default_LogoutZ_result = LogoutZ_result{
  logoutZ_result_e = P.Nothing}
data LoginZ_args = LoginZ_args  { loginZ_args_loginRequest :: LoginRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginZ_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginZ_args_loginRequest record  
instance QC.Arbitrary LoginZ_args where 
  arbitrary = M.liftM LoginZ_args (QC.arbitrary)
  shrink obj | obj == default_LoginZ_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginZ_args{loginZ_args_loginRequest = loginZ_args_loginRequest obj} then P.Nothing else P.Just $ default_LoginZ_args{loginZ_args_loginRequest = loginZ_args_loginRequest obj}
    ]
from_LoginZ_args :: LoginZ_args -> T.ThriftVal
from_LoginZ_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10746 -> P.Just (2, ("loginRequest",from_LoginRequest _v10746))) $ loginZ_args_loginRequest record
  ]
write_LoginZ_args :: T.Protocol p => p -> LoginZ_args -> P.IO ()
write_LoginZ_args oprot record = T.writeVal oprot $ from_LoginZ_args record
encode_LoginZ_args :: T.StatelessProtocol p => p -> LoginZ_args -> LBS.ByteString
encode_LoginZ_args oprot record = T.serializeVal oprot $ from_LoginZ_args record
to_LoginZ_args :: T.ThriftVal -> LoginZ_args
to_LoginZ_args (T.TStruct fields) = LoginZ_args{
  loginZ_args_loginRequest = P.maybe (loginZ_args_loginRequest default_LoginZ_args) (\(_,_val10748) -> (case _val10748 of {T.TStruct _val10749 -> (to_LoginRequest (T.TStruct _val10749)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LoginZ_args _ = P.error "not a struct"
read_LoginZ_args :: T.Protocol p => p -> P.IO LoginZ_args
read_LoginZ_args iprot = to_LoginZ_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginZ_args)
decode_LoginZ_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginZ_args
decode_LoginZ_args iprot bs = to_LoginZ_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginZ_args) bs
typemap_LoginZ_args :: T.TypeMap
typemap_LoginZ_args = Map.fromList [(2,("loginRequest",(T.T_STRUCT typemap_LoginRequest)))]
default_LoginZ_args :: LoginZ_args
default_LoginZ_args = LoginZ_args{
  loginZ_args_loginRequest = default_LoginRequest}
data LoginZ_result = LoginZ_result  { loginZ_result_success :: LoginResult
  , loginZ_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginZ_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginZ_result_success record   `H.hashWithSalt` loginZ_result_e record  
instance QC.Arbitrary LoginZ_result where 
  arbitrary = M.liftM LoginZ_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginZ_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginZ_result{loginZ_result_success = loginZ_result_success obj} then P.Nothing else P.Just $ default_LoginZ_result{loginZ_result_success = loginZ_result_success obj}
    , if obj == default_LoginZ_result{loginZ_result_e = loginZ_result_e obj} then P.Nothing else P.Just $ default_LoginZ_result{loginZ_result_e = loginZ_result_e obj}
    ]
from_LoginZ_result :: LoginZ_result -> T.ThriftVal
from_LoginZ_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10752 -> (1, ("e",from_TalkException _v10752))) <$> loginZ_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10752 -> P.Just (0, ("success",from_LoginResult _v10752))) $ loginZ_result_success record
    , (\_v10752 -> (1, ("e",from_TalkException _v10752))) <$> loginZ_result_e record
    ]
    )
write_LoginZ_result :: T.Protocol p => p -> LoginZ_result -> P.IO ()
write_LoginZ_result oprot record = T.writeVal oprot $ from_LoginZ_result record
encode_LoginZ_result :: T.StatelessProtocol p => p -> LoginZ_result -> LBS.ByteString
encode_LoginZ_result oprot record = T.serializeVal oprot $ from_LoginZ_result record
to_LoginZ_result :: T.ThriftVal -> LoginZ_result
to_LoginZ_result (T.TStruct fields) = LoginZ_result{
  loginZ_result_success = P.maybe (loginZ_result_success default_LoginZ_result) (\(_,_val10754) -> (case _val10754 of {T.TStruct _val10755 -> (to_LoginResult (T.TStruct _val10755)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginZ_result_e = P.maybe (P.Nothing) (\(_,_val10754) -> P.Just (case _val10754 of {T.TStruct _val10756 -> (to_TalkException (T.TStruct _val10756)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginZ_result _ = P.error "not a struct"
read_LoginZ_result :: T.Protocol p => p -> P.IO LoginZ_result
read_LoginZ_result iprot = to_LoginZ_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginZ_result)
decode_LoginZ_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginZ_result
decode_LoginZ_result iprot bs = to_LoginZ_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginZ_result) bs
typemap_LoginZ_result :: T.TypeMap
typemap_LoginZ_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginZ_result :: LoginZ_result
default_LoginZ_result = LoginZ_result{
  loginZ_result_success = default_LoginResult,
  loginZ_result_e = P.Nothing}
data IssueTokenForAccountMigrationSettings_args = IssueTokenForAccountMigrationSettings_args  { issueTokenForAccountMigrationSettings_args_enforce :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigrationSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigrationSettings_args_enforce record  
instance QC.Arbitrary IssueTokenForAccountMigrationSettings_args where 
  arbitrary = M.liftM IssueTokenForAccountMigrationSettings_args (QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigrationSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigrationSettings_args{issueTokenForAccountMigrationSettings_args_enforce = issueTokenForAccountMigrationSettings_args_enforce obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_args{issueTokenForAccountMigrationSettings_args_enforce = issueTokenForAccountMigrationSettings_args_enforce obj}
    ]
from_IssueTokenForAccountMigrationSettings_args :: IssueTokenForAccountMigrationSettings_args -> T.ThriftVal
from_IssueTokenForAccountMigrationSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10759 -> P.Just (2, ("enforce",T.TBool _v10759))) $ issueTokenForAccountMigrationSettings_args_enforce record
  ]
write_IssueTokenForAccountMigrationSettings_args :: T.Protocol p => p -> IssueTokenForAccountMigrationSettings_args -> P.IO ()
write_IssueTokenForAccountMigrationSettings_args oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigrationSettings_args record
encode_IssueTokenForAccountMigrationSettings_args :: T.StatelessProtocol p => p -> IssueTokenForAccountMigrationSettings_args -> LBS.ByteString
encode_IssueTokenForAccountMigrationSettings_args oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigrationSettings_args record
to_IssueTokenForAccountMigrationSettings_args :: T.ThriftVal -> IssueTokenForAccountMigrationSettings_args
to_IssueTokenForAccountMigrationSettings_args (T.TStruct fields) = IssueTokenForAccountMigrationSettings_args{
  issueTokenForAccountMigrationSettings_args_enforce = P.maybe (issueTokenForAccountMigrationSettings_args_enforce default_IssueTokenForAccountMigrationSettings_args) (\(_,_val10761) -> (case _val10761 of {T.TBool _val10762 -> _val10762; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueTokenForAccountMigrationSettings_args _ = P.error "not a struct"
read_IssueTokenForAccountMigrationSettings_args :: T.Protocol p => p -> P.IO IssueTokenForAccountMigrationSettings_args
read_IssueTokenForAccountMigrationSettings_args iprot = to_IssueTokenForAccountMigrationSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_args)
decode_IssueTokenForAccountMigrationSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigrationSettings_args
decode_IssueTokenForAccountMigrationSettings_args iprot bs = to_IssueTokenForAccountMigrationSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_args) bs
typemap_IssueTokenForAccountMigrationSettings_args :: T.TypeMap
typemap_IssueTokenForAccountMigrationSettings_args = Map.fromList [(2,("enforce",T.T_BOOL))]
default_IssueTokenForAccountMigrationSettings_args :: IssueTokenForAccountMigrationSettings_args
default_IssueTokenForAccountMigrationSettings_args = IssueTokenForAccountMigrationSettings_args{
  issueTokenForAccountMigrationSettings_args_enforce = P.False}
data IssueTokenForAccountMigrationSettings_result = IssueTokenForAccountMigrationSettings_result  { issueTokenForAccountMigrationSettings_result_success :: SecurityCenterResult
  , issueTokenForAccountMigrationSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigrationSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigrationSettings_result_success record   `H.hashWithSalt` issueTokenForAccountMigrationSettings_result_e record  
instance QC.Arbitrary IssueTokenForAccountMigrationSettings_result where 
  arbitrary = M.liftM IssueTokenForAccountMigrationSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigrationSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = issueTokenForAccountMigrationSettings_result_success obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = issueTokenForAccountMigrationSettings_result_success obj}
    , if obj == default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = issueTokenForAccountMigrationSettings_result_e obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = issueTokenForAccountMigrationSettings_result_e obj}
    ]
from_IssueTokenForAccountMigrationSettings_result :: IssueTokenForAccountMigrationSettings_result -> T.ThriftVal
from_IssueTokenForAccountMigrationSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10765 -> (1, ("e",from_TalkException _v10765))) <$> issueTokenForAccountMigrationSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10765 -> P.Just (0, ("success",from_SecurityCenterResult _v10765))) $ issueTokenForAccountMigrationSettings_result_success record
    , (\_v10765 -> (1, ("e",from_TalkException _v10765))) <$> issueTokenForAccountMigrationSettings_result_e record
    ]
    )
write_IssueTokenForAccountMigrationSettings_result :: T.Protocol p => p -> IssueTokenForAccountMigrationSettings_result -> P.IO ()
write_IssueTokenForAccountMigrationSettings_result oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigrationSettings_result record
encode_IssueTokenForAccountMigrationSettings_result :: T.StatelessProtocol p => p -> IssueTokenForAccountMigrationSettings_result -> LBS.ByteString
encode_IssueTokenForAccountMigrationSettings_result oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigrationSettings_result record
to_IssueTokenForAccountMigrationSettings_result :: T.ThriftVal -> IssueTokenForAccountMigrationSettings_result
to_IssueTokenForAccountMigrationSettings_result (T.TStruct fields) = IssueTokenForAccountMigrationSettings_result{
  issueTokenForAccountMigrationSettings_result_success = P.maybe (issueTokenForAccountMigrationSettings_result_success default_IssueTokenForAccountMigrationSettings_result) (\(_,_val10767) -> (case _val10767 of {T.TStruct _val10768 -> (to_SecurityCenterResult (T.TStruct _val10768)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueTokenForAccountMigrationSettings_result_e = P.maybe (P.Nothing) (\(_,_val10767) -> P.Just (case _val10767 of {T.TStruct _val10769 -> (to_TalkException (T.TStruct _val10769)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueTokenForAccountMigrationSettings_result _ = P.error "not a struct"
read_IssueTokenForAccountMigrationSettings_result :: T.Protocol p => p -> P.IO IssueTokenForAccountMigrationSettings_result
read_IssueTokenForAccountMigrationSettings_result iprot = to_IssueTokenForAccountMigrationSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_result)
decode_IssueTokenForAccountMigrationSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigrationSettings_result
decode_IssueTokenForAccountMigrationSettings_result iprot bs = to_IssueTokenForAccountMigrationSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigrationSettings_result) bs
typemap_IssueTokenForAccountMigrationSettings_result :: T.TypeMap
typemap_IssueTokenForAccountMigrationSettings_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SecurityCenterResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IssueTokenForAccountMigrationSettings_result :: IssueTokenForAccountMigrationSettings_result
default_IssueTokenForAccountMigrationSettings_result = IssueTokenForAccountMigrationSettings_result{
  issueTokenForAccountMigrationSettings_result_success = default_SecurityCenterResult,
  issueTokenForAccountMigrationSettings_result_e = P.Nothing}
data IssueTokenForAccountMigration_args = IssueTokenForAccountMigration_args  { issueTokenForAccountMigration_args_migrationSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigration_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigration_args_migrationSessionId record  
instance QC.Arbitrary IssueTokenForAccountMigration_args where 
  arbitrary = M.liftM IssueTokenForAccountMigration_args (QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigration_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigration_args{issueTokenForAccountMigration_args_migrationSessionId = issueTokenForAccountMigration_args_migrationSessionId obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_args{issueTokenForAccountMigration_args_migrationSessionId = issueTokenForAccountMigration_args_migrationSessionId obj}
    ]
from_IssueTokenForAccountMigration_args :: IssueTokenForAccountMigration_args -> T.ThriftVal
from_IssueTokenForAccountMigration_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10772 -> P.Just (2, ("migrationSessionId",T.TString $ E.encodeUtf8 _v10772))) $ issueTokenForAccountMigration_args_migrationSessionId record
  ]
write_IssueTokenForAccountMigration_args :: T.Protocol p => p -> IssueTokenForAccountMigration_args -> P.IO ()
write_IssueTokenForAccountMigration_args oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigration_args record
encode_IssueTokenForAccountMigration_args :: T.StatelessProtocol p => p -> IssueTokenForAccountMigration_args -> LBS.ByteString
encode_IssueTokenForAccountMigration_args oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigration_args record
to_IssueTokenForAccountMigration_args :: T.ThriftVal -> IssueTokenForAccountMigration_args
to_IssueTokenForAccountMigration_args (T.TStruct fields) = IssueTokenForAccountMigration_args{
  issueTokenForAccountMigration_args_migrationSessionId = P.maybe (issueTokenForAccountMigration_args_migrationSessionId default_IssueTokenForAccountMigration_args) (\(_,_val10774) -> (case _val10774 of {T.TString _val10775 -> E.decodeUtf8 _val10775; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IssueTokenForAccountMigration_args _ = P.error "not a struct"
read_IssueTokenForAccountMigration_args :: T.Protocol p => p -> P.IO IssueTokenForAccountMigration_args
read_IssueTokenForAccountMigration_args iprot = to_IssueTokenForAccountMigration_args <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_args)
decode_IssueTokenForAccountMigration_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigration_args
decode_IssueTokenForAccountMigration_args iprot bs = to_IssueTokenForAccountMigration_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_args) bs
typemap_IssueTokenForAccountMigration_args :: T.TypeMap
typemap_IssueTokenForAccountMigration_args = Map.fromList [(2,("migrationSessionId",T.T_STRING))]
default_IssueTokenForAccountMigration_args :: IssueTokenForAccountMigration_args
default_IssueTokenForAccountMigration_args = IssueTokenForAccountMigration_args{
  issueTokenForAccountMigration_args_migrationSessionId = ""}
data IssueTokenForAccountMigration_result = IssueTokenForAccountMigration_result  { issueTokenForAccountMigration_result_success :: SecurityCenterResult
  , issueTokenForAccountMigration_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IssueTokenForAccountMigration_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` issueTokenForAccountMigration_result_success record   `H.hashWithSalt` issueTokenForAccountMigration_result_e record  
instance QC.Arbitrary IssueTokenForAccountMigration_result where 
  arbitrary = M.liftM IssueTokenForAccountMigration_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IssueTokenForAccountMigration_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = issueTokenForAccountMigration_result_success obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = issueTokenForAccountMigration_result_success obj}
    , if obj == default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = issueTokenForAccountMigration_result_e obj} then P.Nothing else P.Just $ default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = issueTokenForAccountMigration_result_e obj}
    ]
from_IssueTokenForAccountMigration_result :: IssueTokenForAccountMigration_result -> T.ThriftVal
from_IssueTokenForAccountMigration_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10778 -> (1, ("e",from_TalkException _v10778))) <$> issueTokenForAccountMigration_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10778 -> P.Just (0, ("success",from_SecurityCenterResult _v10778))) $ issueTokenForAccountMigration_result_success record
    , (\_v10778 -> (1, ("e",from_TalkException _v10778))) <$> issueTokenForAccountMigration_result_e record
    ]
    )
write_IssueTokenForAccountMigration_result :: T.Protocol p => p -> IssueTokenForAccountMigration_result -> P.IO ()
write_IssueTokenForAccountMigration_result oprot record = T.writeVal oprot $ from_IssueTokenForAccountMigration_result record
encode_IssueTokenForAccountMigration_result :: T.StatelessProtocol p => p -> IssueTokenForAccountMigration_result -> LBS.ByteString
encode_IssueTokenForAccountMigration_result oprot record = T.serializeVal oprot $ from_IssueTokenForAccountMigration_result record
to_IssueTokenForAccountMigration_result :: T.ThriftVal -> IssueTokenForAccountMigration_result
to_IssueTokenForAccountMigration_result (T.TStruct fields) = IssueTokenForAccountMigration_result{
  issueTokenForAccountMigration_result_success = P.maybe (issueTokenForAccountMigration_result_success default_IssueTokenForAccountMigration_result) (\(_,_val10780) -> (case _val10780 of {T.TStruct _val10781 -> (to_SecurityCenterResult (T.TStruct _val10781)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  issueTokenForAccountMigration_result_e = P.maybe (P.Nothing) (\(_,_val10780) -> P.Just (case _val10780 of {T.TStruct _val10782 -> (to_TalkException (T.TStruct _val10782)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IssueTokenForAccountMigration_result _ = P.error "not a struct"
read_IssueTokenForAccountMigration_result :: T.Protocol p => p -> P.IO IssueTokenForAccountMigration_result
read_IssueTokenForAccountMigration_result iprot = to_IssueTokenForAccountMigration_result <$> T.readVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_result)
decode_IssueTokenForAccountMigration_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IssueTokenForAccountMigration_result
decode_IssueTokenForAccountMigration_result iprot bs = to_IssueTokenForAccountMigration_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IssueTokenForAccountMigration_result) bs
typemap_IssueTokenForAccountMigration_result :: T.TypeMap
typemap_IssueTokenForAccountMigration_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SecurityCenterResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IssueTokenForAccountMigration_result :: IssueTokenForAccountMigration_result
default_IssueTokenForAccountMigration_result = IssueTokenForAccountMigration_result{
  issueTokenForAccountMigration_result_success = default_SecurityCenterResult,
  issueTokenForAccountMigration_result_e = P.Nothing}
data VerifyQrcodeWithE2EE_args = VerifyQrcodeWithE2EE_args  { verifyQrcodeWithE2EE_args_verifier :: LT.Text
  , verifyQrcodeWithE2EE_args_pinCode :: LT.Text
  , verifyQrcodeWithE2EE_args_errorCode :: ErrorCode
  , verifyQrcodeWithE2EE_args_publicKey :: E2EEPublicKey
  , verifyQrcodeWithE2EE_args_encryptedKeyChain :: LBS.ByteString
  , verifyQrcodeWithE2EE_args_hashKeyChain :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcodeWithE2EE_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcodeWithE2EE_args_verifier record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_pinCode record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_errorCode record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_publicKey record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_encryptedKeyChain record   `H.hashWithSalt` verifyQrcodeWithE2EE_args_hashKeyChain record  
instance QC.Arbitrary VerifyQrcodeWithE2EE_args where 
  arbitrary = M.liftM VerifyQrcodeWithE2EE_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyQrcodeWithE2EE_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_verifier = verifyQrcodeWithE2EE_args_verifier obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_verifier = verifyQrcodeWithE2EE_args_verifier obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_pinCode = verifyQrcodeWithE2EE_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_pinCode = verifyQrcodeWithE2EE_args_pinCode obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_errorCode = verifyQrcodeWithE2EE_args_errorCode obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_errorCode = verifyQrcodeWithE2EE_args_errorCode obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_publicKey = verifyQrcodeWithE2EE_args_publicKey obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_publicKey = verifyQrcodeWithE2EE_args_publicKey obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_encryptedKeyChain = verifyQrcodeWithE2EE_args_encryptedKeyChain obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_encryptedKeyChain = verifyQrcodeWithE2EE_args_encryptedKeyChain obj}
    , if obj == default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_hashKeyChain = verifyQrcodeWithE2EE_args_hashKeyChain obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_args{verifyQrcodeWithE2EE_args_hashKeyChain = verifyQrcodeWithE2EE_args_hashKeyChain obj}
    ]
from_VerifyQrcodeWithE2EE_args :: VerifyQrcodeWithE2EE_args -> T.ThriftVal
from_VerifyQrcodeWithE2EE_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10785 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v10785))) $ verifyQrcodeWithE2EE_args_verifier record
  , (\_v10785 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v10785))) $ verifyQrcodeWithE2EE_args_pinCode record
  , (\_v10785 -> P.Just (4, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v10785))) $ verifyQrcodeWithE2EE_args_errorCode record
  , (\_v10785 -> P.Just (5, ("publicKey",from_E2EEPublicKey _v10785))) $ verifyQrcodeWithE2EE_args_publicKey record
  , (\_v10785 -> P.Just (6, ("encryptedKeyChain",T.TBinary _v10785))) $ verifyQrcodeWithE2EE_args_encryptedKeyChain record
  , (\_v10785 -> P.Just (7, ("hashKeyChain",T.TBinary _v10785))) $ verifyQrcodeWithE2EE_args_hashKeyChain record
  ]
write_VerifyQrcodeWithE2EE_args :: T.Protocol p => p -> VerifyQrcodeWithE2EE_args -> P.IO ()
write_VerifyQrcodeWithE2EE_args oprot record = T.writeVal oprot $ from_VerifyQrcodeWithE2EE_args record
encode_VerifyQrcodeWithE2EE_args :: T.StatelessProtocol p => p -> VerifyQrcodeWithE2EE_args -> LBS.ByteString
encode_VerifyQrcodeWithE2EE_args oprot record = T.serializeVal oprot $ from_VerifyQrcodeWithE2EE_args record
to_VerifyQrcodeWithE2EE_args :: T.ThriftVal -> VerifyQrcodeWithE2EE_args
to_VerifyQrcodeWithE2EE_args (T.TStruct fields) = VerifyQrcodeWithE2EE_args{
  verifyQrcodeWithE2EE_args_verifier = P.maybe (verifyQrcodeWithE2EE_args_verifier default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TString _val10788 -> E.decodeUtf8 _val10788; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyQrcodeWithE2EE_args_pinCode = P.maybe (verifyQrcodeWithE2EE_args_pinCode default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TString _val10789 -> E.decodeUtf8 _val10789; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyQrcodeWithE2EE_args_errorCode = P.maybe (verifyQrcodeWithE2EE_args_errorCode default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TI32 _val10790 -> P.toEnum $ P.fromIntegral _val10790; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  verifyQrcodeWithE2EE_args_publicKey = P.maybe (verifyQrcodeWithE2EE_args_publicKey default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TStruct _val10791 -> (to_E2EEPublicKey (T.TStruct _val10791)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  verifyQrcodeWithE2EE_args_encryptedKeyChain = P.maybe (verifyQrcodeWithE2EE_args_encryptedKeyChain default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TBinary _val10792 -> _val10792; T.TString _val10792 -> _val10792; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  verifyQrcodeWithE2EE_args_hashKeyChain = P.maybe (verifyQrcodeWithE2EE_args_hashKeyChain default_VerifyQrcodeWithE2EE_args) (\(_,_val10787) -> (case _val10787 of {T.TBinary _val10793 -> _val10793; T.TString _val10793 -> _val10793; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_VerifyQrcodeWithE2EE_args _ = P.error "not a struct"
read_VerifyQrcodeWithE2EE_args :: T.Protocol p => p -> P.IO VerifyQrcodeWithE2EE_args
read_VerifyQrcodeWithE2EE_args iprot = to_VerifyQrcodeWithE2EE_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_args)
decode_VerifyQrcodeWithE2EE_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcodeWithE2EE_args
decode_VerifyQrcodeWithE2EE_args iprot bs = to_VerifyQrcodeWithE2EE_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_args) bs
typemap_VerifyQrcodeWithE2EE_args :: T.TypeMap
typemap_VerifyQrcodeWithE2EE_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING)),(4,("errorCode",T.T_I32)),(5,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey))),(6,("encryptedKeyChain",T.T_BINARY)),(7,("hashKeyChain",T.T_BINARY))]
default_VerifyQrcodeWithE2EE_args :: VerifyQrcodeWithE2EE_args
default_VerifyQrcodeWithE2EE_args = VerifyQrcodeWithE2EE_args{
  verifyQrcodeWithE2EE_args_verifier = "",
  verifyQrcodeWithE2EE_args_pinCode = "",
  verifyQrcodeWithE2EE_args_errorCode = (P.toEnum 0),
  verifyQrcodeWithE2EE_args_publicKey = default_E2EEPublicKey,
  verifyQrcodeWithE2EE_args_encryptedKeyChain = "",
  verifyQrcodeWithE2EE_args_hashKeyChain = ""}
data VerifyQrcodeWithE2EE_result = VerifyQrcodeWithE2EE_result  { verifyQrcodeWithE2EE_result_success :: LT.Text
  , verifyQrcodeWithE2EE_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcodeWithE2EE_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcodeWithE2EE_result_success record   `H.hashWithSalt` verifyQrcodeWithE2EE_result_e record  
instance QC.Arbitrary VerifyQrcodeWithE2EE_result where 
  arbitrary = M.liftM VerifyQrcodeWithE2EE_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyQrcodeWithE2EE_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = verifyQrcodeWithE2EE_result_success obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = verifyQrcodeWithE2EE_result_success obj}
    , if obj == default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = verifyQrcodeWithE2EE_result_e obj} then P.Nothing else P.Just $ default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = verifyQrcodeWithE2EE_result_e obj}
    ]
from_VerifyQrcodeWithE2EE_result :: VerifyQrcodeWithE2EE_result -> T.ThriftVal
from_VerifyQrcodeWithE2EE_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10796 -> (1, ("e",from_TalkException _v10796))) <$> verifyQrcodeWithE2EE_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10796 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10796))) $ verifyQrcodeWithE2EE_result_success record
    , (\_v10796 -> (1, ("e",from_TalkException _v10796))) <$> verifyQrcodeWithE2EE_result_e record
    ]
    )
write_VerifyQrcodeWithE2EE_result :: T.Protocol p => p -> VerifyQrcodeWithE2EE_result -> P.IO ()
write_VerifyQrcodeWithE2EE_result oprot record = T.writeVal oprot $ from_VerifyQrcodeWithE2EE_result record
encode_VerifyQrcodeWithE2EE_result :: T.StatelessProtocol p => p -> VerifyQrcodeWithE2EE_result -> LBS.ByteString
encode_VerifyQrcodeWithE2EE_result oprot record = T.serializeVal oprot $ from_VerifyQrcodeWithE2EE_result record
to_VerifyQrcodeWithE2EE_result :: T.ThriftVal -> VerifyQrcodeWithE2EE_result
to_VerifyQrcodeWithE2EE_result (T.TStruct fields) = VerifyQrcodeWithE2EE_result{
  verifyQrcodeWithE2EE_result_success = P.maybe (verifyQrcodeWithE2EE_result_success default_VerifyQrcodeWithE2EE_result) (\(_,_val10798) -> (case _val10798 of {T.TString _val10799 -> E.decodeUtf8 _val10799; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyQrcodeWithE2EE_result_e = P.maybe (P.Nothing) (\(_,_val10798) -> P.Just (case _val10798 of {T.TStruct _val10800 -> (to_TalkException (T.TStruct _val10800)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyQrcodeWithE2EE_result _ = P.error "not a struct"
read_VerifyQrcodeWithE2EE_result :: T.Protocol p => p -> P.IO VerifyQrcodeWithE2EE_result
read_VerifyQrcodeWithE2EE_result iprot = to_VerifyQrcodeWithE2EE_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_result)
decode_VerifyQrcodeWithE2EE_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcodeWithE2EE_result
decode_VerifyQrcodeWithE2EE_result iprot bs = to_VerifyQrcodeWithE2EE_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcodeWithE2EE_result) bs
typemap_VerifyQrcodeWithE2EE_result :: T.TypeMap
typemap_VerifyQrcodeWithE2EE_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyQrcodeWithE2EE_result :: VerifyQrcodeWithE2EE_result
default_VerifyQrcodeWithE2EE_result = VerifyQrcodeWithE2EE_result{
  verifyQrcodeWithE2EE_result_success = "",
  verifyQrcodeWithE2EE_result_e = P.Nothing}
process_normalizePhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_NormalizePhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.normalizePhoneNumber handler (normalizePhoneNumber_args_countryCode args) (normalizePhoneNumber_args_phoneNumber args) (normalizePhoneNumber_args_countryCodeHint args)
        let res = default_NormalizePhoneNumber_result{normalizePhoneNumber_result_success = val}
        T.writeMessage oprot ("normalizePhoneNumber", T.M_REPLY, seqid) $
          write_NormalizePhoneNumber_result oprot res)
      (\e  -> do
        let res = default_NormalizePhoneNumber_result{normalizePhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("normalizePhoneNumber", T.M_REPLY, seqid) $
          write_NormalizePhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("normalizePhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_respondE2EELoginRequest (seqid, iprot, oprot, handler) = do
  args <- read_RespondE2EELoginRequest_args iprot
  (X.catch
    (X.catch
      (do
        Iface.respondE2EELoginRequest handler (respondE2EELoginRequest_args_verifier args) (respondE2EELoginRequest_args_publicKey args) (respondE2EELoginRequest_args_encryptedKeyChain args) (respondE2EELoginRequest_args_hashKeyChain args) (respondE2EELoginRequest_args_errorCode args)
        let res = default_RespondE2EELoginRequest_result
        T.writeMessage oprot ("respondE2EELoginRequest", T.M_REPLY, seqid) $
          write_RespondE2EELoginRequest_result oprot res)
      (\e  -> do
        let res = default_RespondE2EELoginRequest_result{respondE2EELoginRequest_result_e = P.Just e}
        T.writeMessage oprot ("respondE2EELoginRequest", T.M_REPLY, seqid) $
          write_RespondE2EELoginRequest_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("respondE2EELoginRequest", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_confirmE2EELogin (seqid, iprot, oprot, handler) = do
  args <- read_ConfirmE2EELogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.confirmE2EELogin handler (confirmE2EELogin_args_verifier args) (confirmE2EELogin_args_deviceSecret args)
        let res = default_ConfirmE2EELogin_result{confirmE2EELogin_result_success = val}
        T.writeMessage oprot ("confirmE2EELogin", T.M_REPLY, seqid) $
          write_ConfirmE2EELogin_result oprot res)
      (\e  -> do
        let res = default_ConfirmE2EELogin_result{confirmE2EELogin_result_e = P.Just e}
        T.writeMessage oprot ("confirmE2EELogin", T.M_REPLY, seqid) $
          write_ConfirmE2EELogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("confirmE2EELogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logoutZ (seqid, iprot, oprot, handler) = do
  args <- read_LogoutZ_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logoutZ handler
        let res = default_LogoutZ_result
        T.writeMessage oprot ("logoutZ", T.M_REPLY, seqid) $
          write_LogoutZ_result oprot res)
      (\e  -> do
        let res = default_LogoutZ_result{logoutZ_result_e = P.Just e}
        T.writeMessage oprot ("logoutZ", T.M_REPLY, seqid) $
          write_LogoutZ_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logoutZ", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginZ (seqid, iprot, oprot, handler) = do
  args <- read_LoginZ_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginZ handler (loginZ_args_loginRequest args)
        let res = default_LoginZ_result{loginZ_result_success = val}
        T.writeMessage oprot ("loginZ", T.M_REPLY, seqid) $
          write_LoginZ_result oprot res)
      (\e  -> do
        let res = default_LoginZ_result{loginZ_result_e = P.Just e}
        T.writeMessage oprot ("loginZ", T.M_REPLY, seqid) $
          write_LoginZ_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginZ", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueTokenForAccountMigrationSettings (seqid, iprot, oprot, handler) = do
  args <- read_IssueTokenForAccountMigrationSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueTokenForAccountMigrationSettings handler (issueTokenForAccountMigrationSettings_args_enforce args)
        let res = default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_success = val}
        T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigrationSettings_result oprot res)
      (\e  -> do
        let res = default_IssueTokenForAccountMigrationSettings_result{issueTokenForAccountMigrationSettings_result_e = P.Just e}
        T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigrationSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueTokenForAccountMigrationSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_issueTokenForAccountMigration (seqid, iprot, oprot, handler) = do
  args <- read_IssueTokenForAccountMigration_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.issueTokenForAccountMigration handler (issueTokenForAccountMigration_args_migrationSessionId args)
        let res = default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_success = val}
        T.writeMessage oprot ("issueTokenForAccountMigration", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigration_result oprot res)
      (\e  -> do
        let res = default_IssueTokenForAccountMigration_result{issueTokenForAccountMigration_result_e = P.Just e}
        T.writeMessage oprot ("issueTokenForAccountMigration", T.M_REPLY, seqid) $
          write_IssueTokenForAccountMigration_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("issueTokenForAccountMigration", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyQrcodeWithE2EE (seqid, iprot, oprot, handler) = do
  args <- read_VerifyQrcodeWithE2EE_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyQrcodeWithE2EE handler (verifyQrcodeWithE2EE_args_verifier args) (verifyQrcodeWithE2EE_args_pinCode args) (verifyQrcodeWithE2EE_args_errorCode args) (verifyQrcodeWithE2EE_args_publicKey args) (verifyQrcodeWithE2EE_args_encryptedKeyChain args) (verifyQrcodeWithE2EE_args_hashKeyChain args)
        let res = default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_success = val}
        T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_REPLY, seqid) $
          write_VerifyQrcodeWithE2EE_result oprot res)
      (\e  -> do
        let res = default_VerifyQrcodeWithE2EE_result{verifyQrcodeWithE2EE_result_e = P.Just e}
        T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_REPLY, seqid) $
          write_VerifyQrcodeWithE2EE_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyQrcodeWithE2EE", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "normalizePhoneNumber" -> process_normalizePhoneNumber (seqid,iprot,oprot,handler)
  "respondE2EELoginRequest" -> process_respondE2EELoginRequest (seqid,iprot,oprot,handler)
  "confirmE2EELogin" -> process_confirmE2EELogin (seqid,iprot,oprot,handler)
  "logoutZ" -> process_logoutZ (seqid,iprot,oprot,handler)
  "loginZ" -> process_loginZ (seqid,iprot,oprot,handler)
  "issueTokenForAccountMigrationSettings" -> process_issueTokenForAccountMigrationSettings (seqid,iprot,oprot,handler)
  "issueTokenForAccountMigration" -> process_issueTokenForAccountMigration (seqid,iprot,oprot,handler)
  "verifyQrcodeWithE2EE" -> process_verifyQrcodeWithE2EE (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
