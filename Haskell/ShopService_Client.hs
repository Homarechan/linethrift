{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.13.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ShopService_Client(buyCoinProduct,buyFreeProduct,buyMustbuyProduct,checkCanReceivePresent,getActivePurchases,getActivePurchaseVersions,getCoinProducts,getCoinProductsByPgCode,getCoinPurchaseHistory,getCoinUseAndRefundHistory,getDownloads,getEventPackages,getNewlyReleasedPackages,getPopularPackages,getPresentsReceived,getPresentsSent,getProduct,getProductList,getProductListWithCarrier,getProductWithCarrier,getPurchaseHistory,getTotalBalance,notifyDownloaded,reserveCoinPurchase,reservePayment) where
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import ShopService
seqid = R.newIORef 0
buyCoinProduct (ip,op) arg_paymentReservation = do
  send_buyCoinProduct op arg_paymentReservation
  recv_buyCoinProduct ip
send_buyCoinProduct op arg_paymentReservation = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("buyCoinProduct", T.M_CALL, seqn) $
    write_BuyCoinProduct_args op (BuyCoinProduct_args{buyCoinProduct_args_paymentReservation=arg_paymentReservation})
recv_buyCoinProduct ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_BuyCoinProduct_result ip
    P.maybe (P.return ()) X.throw (buyCoinProduct_result_e res)
    P.return ()
buyFreeProduct (ip,op) arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId = do
  send_buyFreeProduct op arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId
  recv_buyFreeProduct ip
send_buyFreeProduct op arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("buyFreeProduct", T.M_CALL, seqn) $
    write_BuyFreeProduct_args op (BuyFreeProduct_args{buyFreeProduct_args_receiverMid=arg_receiverMid,buyFreeProduct_args_productId=arg_productId,buyFreeProduct_args_messageTemplate=arg_messageTemplate,buyFreeProduct_args_language=arg_language,buyFreeProduct_args_country=arg_country,buyFreeProduct_args_packageId=arg_packageId})
recv_buyFreeProduct ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_BuyFreeProduct_result ip
    P.maybe (P.return ()) X.throw (buyFreeProduct_result_e res)
    P.return ()
buyMustbuyProduct (ip,op) arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId arg_serialNumber = do
  send_buyMustbuyProduct op arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId arg_serialNumber
  recv_buyMustbuyProduct ip
send_buyMustbuyProduct op arg_receiverMid arg_productId arg_messageTemplate arg_language arg_country arg_packageId arg_serialNumber = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("buyMustbuyProduct", T.M_CALL, seqn) $
    write_BuyMustbuyProduct_args op (BuyMustbuyProduct_args{buyMustbuyProduct_args_receiverMid=arg_receiverMid,buyMustbuyProduct_args_productId=arg_productId,buyMustbuyProduct_args_messageTemplate=arg_messageTemplate,buyMustbuyProduct_args_language=arg_language,buyMustbuyProduct_args_country=arg_country,buyMustbuyProduct_args_packageId=arg_packageId,buyMustbuyProduct_args_serialNumber=arg_serialNumber})
recv_buyMustbuyProduct ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_BuyMustbuyProduct_result ip
    P.maybe (P.return ()) X.throw (buyMustbuyProduct_result_e res)
    P.return ()
checkCanReceivePresent (ip,op) arg_recipientMid arg_packageId arg_language arg_country = do
  send_checkCanReceivePresent op arg_recipientMid arg_packageId arg_language arg_country
  recv_checkCanReceivePresent ip
send_checkCanReceivePresent op arg_recipientMid arg_packageId arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("checkCanReceivePresent", T.M_CALL, seqn) $
    write_CheckCanReceivePresent_args op (CheckCanReceivePresent_args{checkCanReceivePresent_args_recipientMid=arg_recipientMid,checkCanReceivePresent_args_packageId=arg_packageId,checkCanReceivePresent_args_language=arg_language,checkCanReceivePresent_args_country=arg_country})
recv_checkCanReceivePresent ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CheckCanReceivePresent_result ip
    P.maybe (P.return ()) X.throw (checkCanReceivePresent_result_e res)
    P.return ()
getActivePurchases (ip,op) arg_start arg_size arg_language arg_country = do
  send_getActivePurchases op arg_start arg_size arg_language arg_country
  recv_getActivePurchases ip
send_getActivePurchases op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getActivePurchases", T.M_CALL, seqn) $
    write_GetActivePurchases_args op (GetActivePurchases_args{getActivePurchases_args_start=arg_start,getActivePurchases_args_size=arg_size,getActivePurchases_args_language=arg_language,getActivePurchases_args_country=arg_country})
recv_getActivePurchases ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetActivePurchases_result ip
    P.maybe (P.return ()) X.throw (getActivePurchases_result_e res)
    P.return $ getActivePurchases_result_success res
getActivePurchaseVersions (ip,op) arg_start arg_size arg_language arg_country = do
  send_getActivePurchaseVersions op arg_start arg_size arg_language arg_country
  recv_getActivePurchaseVersions ip
send_getActivePurchaseVersions op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getActivePurchaseVersions", T.M_CALL, seqn) $
    write_GetActivePurchaseVersions_args op (GetActivePurchaseVersions_args{getActivePurchaseVersions_args_start=arg_start,getActivePurchaseVersions_args_size=arg_size,getActivePurchaseVersions_args_language=arg_language,getActivePurchaseVersions_args_country=arg_country})
recv_getActivePurchaseVersions ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetActivePurchaseVersions_result ip
    P.maybe (P.return ()) X.throw (getActivePurchaseVersions_result_e res)
    P.return $ getActivePurchaseVersions_result_success res
getCoinProducts (ip,op) arg_appStoreCode arg_country arg_language = do
  send_getCoinProducts op arg_appStoreCode arg_country arg_language
  recv_getCoinProducts ip
send_getCoinProducts op arg_appStoreCode arg_country arg_language = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getCoinProducts", T.M_CALL, seqn) $
    write_GetCoinProducts_args op (GetCoinProducts_args{getCoinProducts_args_appStoreCode=arg_appStoreCode,getCoinProducts_args_country=arg_country,getCoinProducts_args_language=arg_language})
recv_getCoinProducts ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetCoinProducts_result ip
    P.maybe (P.return ()) X.throw (getCoinProducts_result_e res)
    P.return $ getCoinProducts_result_success res
getCoinProductsByPgCode (ip,op) arg_appStoreCode arg_pgCode arg_country arg_language = do
  send_getCoinProductsByPgCode op arg_appStoreCode arg_pgCode arg_country arg_language
  recv_getCoinProductsByPgCode ip
send_getCoinProductsByPgCode op arg_appStoreCode arg_pgCode arg_country arg_language = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getCoinProductsByPgCode", T.M_CALL, seqn) $
    write_GetCoinProductsByPgCode_args op (GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_appStoreCode=arg_appStoreCode,getCoinProductsByPgCode_args_pgCode=arg_pgCode,getCoinProductsByPgCode_args_country=arg_country,getCoinProductsByPgCode_args_language=arg_language})
recv_getCoinProductsByPgCode ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetCoinProductsByPgCode_result ip
    P.maybe (P.return ()) X.throw (getCoinProductsByPgCode_result_e res)
    P.return $ getCoinProductsByPgCode_result_success res
getCoinPurchaseHistory (ip,op) arg_request = do
  send_getCoinPurchaseHistory op arg_request
  recv_getCoinPurchaseHistory ip
send_getCoinPurchaseHistory op arg_request = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getCoinPurchaseHistory", T.M_CALL, seqn) $
    write_GetCoinPurchaseHistory_args op (GetCoinPurchaseHistory_args{getCoinPurchaseHistory_args_request=arg_request})
recv_getCoinPurchaseHistory ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetCoinPurchaseHistory_result ip
    P.maybe (P.return ()) X.throw (getCoinPurchaseHistory_result_e res)
    P.return $ getCoinPurchaseHistory_result_success res
getCoinUseAndRefundHistory (ip,op) arg_request = do
  send_getCoinUseAndRefundHistory op arg_request
  recv_getCoinUseAndRefundHistory ip
send_getCoinUseAndRefundHistory op arg_request = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getCoinUseAndRefundHistory", T.M_CALL, seqn) $
    write_GetCoinUseAndRefundHistory_args op (GetCoinUseAndRefundHistory_args{getCoinUseAndRefundHistory_args_request=arg_request})
recv_getCoinUseAndRefundHistory ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetCoinUseAndRefundHistory_result ip
    P.maybe (P.return ()) X.throw (getCoinUseAndRefundHistory_result_e res)
    P.return $ getCoinUseAndRefundHistory_result_success res
getDownloads (ip,op) arg_start arg_size arg_language arg_country = do
  send_getDownloads op arg_start arg_size arg_language arg_country
  recv_getDownloads ip
send_getDownloads op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getDownloads", T.M_CALL, seqn) $
    write_GetDownloads_args op (GetDownloads_args{getDownloads_args_start=arg_start,getDownloads_args_size=arg_size,getDownloads_args_language=arg_language,getDownloads_args_country=arg_country})
recv_getDownloads ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetDownloads_result ip
    P.maybe (P.return ()) X.throw (getDownloads_result_e res)
    P.return $ getDownloads_result_success res
getEventPackages (ip,op) arg_start arg_size arg_language arg_country = do
  send_getEventPackages op arg_start arg_size arg_language arg_country
  recv_getEventPackages ip
send_getEventPackages op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getEventPackages", T.M_CALL, seqn) $
    write_GetEventPackages_args op (GetEventPackages_args{getEventPackages_args_start=arg_start,getEventPackages_args_size=arg_size,getEventPackages_args_language=arg_language,getEventPackages_args_country=arg_country})
recv_getEventPackages ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetEventPackages_result ip
    P.maybe (P.return ()) X.throw (getEventPackages_result_e res)
    P.return $ getEventPackages_result_success res
getNewlyReleasedPackages (ip,op) arg_start arg_size arg_language arg_country = do
  send_getNewlyReleasedPackages op arg_start arg_size arg_language arg_country
  recv_getNewlyReleasedPackages ip
send_getNewlyReleasedPackages op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNewlyReleasedPackages", T.M_CALL, seqn) $
    write_GetNewlyReleasedPackages_args op (GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_start=arg_start,getNewlyReleasedPackages_args_size=arg_size,getNewlyReleasedPackages_args_language=arg_language,getNewlyReleasedPackages_args_country=arg_country})
recv_getNewlyReleasedPackages ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNewlyReleasedPackages_result ip
    P.maybe (P.return ()) X.throw (getNewlyReleasedPackages_result_e res)
    P.return $ getNewlyReleasedPackages_result_success res
getPopularPackages (ip,op) arg_start arg_size arg_language arg_country = do
  send_getPopularPackages op arg_start arg_size arg_language arg_country
  recv_getPopularPackages ip
send_getPopularPackages op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPopularPackages", T.M_CALL, seqn) $
    write_GetPopularPackages_args op (GetPopularPackages_args{getPopularPackages_args_start=arg_start,getPopularPackages_args_size=arg_size,getPopularPackages_args_language=arg_language,getPopularPackages_args_country=arg_country})
recv_getPopularPackages ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPopularPackages_result ip
    P.maybe (P.return ()) X.throw (getPopularPackages_result_e res)
    P.return $ getPopularPackages_result_success res
getPresentsReceived (ip,op) arg_start arg_size arg_language arg_country = do
  send_getPresentsReceived op arg_start arg_size arg_language arg_country
  recv_getPresentsReceived ip
send_getPresentsReceived op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPresentsReceived", T.M_CALL, seqn) $
    write_GetPresentsReceived_args op (GetPresentsReceived_args{getPresentsReceived_args_start=arg_start,getPresentsReceived_args_size=arg_size,getPresentsReceived_args_language=arg_language,getPresentsReceived_args_country=arg_country})
recv_getPresentsReceived ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPresentsReceived_result ip
    P.maybe (P.return ()) X.throw (getPresentsReceived_result_e res)
    P.return $ getPresentsReceived_result_success res
getPresentsSent (ip,op) arg_start arg_size arg_language arg_country = do
  send_getPresentsSent op arg_start arg_size arg_language arg_country
  recv_getPresentsSent ip
send_getPresentsSent op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPresentsSent", T.M_CALL, seqn) $
    write_GetPresentsSent_args op (GetPresentsSent_args{getPresentsSent_args_start=arg_start,getPresentsSent_args_size=arg_size,getPresentsSent_args_language=arg_language,getPresentsSent_args_country=arg_country})
recv_getPresentsSent ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPresentsSent_result ip
    P.maybe (P.return ()) X.throw (getPresentsSent_result_e res)
    P.return $ getPresentsSent_result_success res
getProduct (ip,op) arg_packageID arg_language arg_country = do
  send_getProduct op arg_packageID arg_language arg_country
  recv_getProduct ip
send_getProduct op arg_packageID arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getProduct", T.M_CALL, seqn) $
    write_GetProduct_args op (GetProduct_args{getProduct_args_packageID=arg_packageID,getProduct_args_language=arg_language,getProduct_args_country=arg_country})
recv_getProduct ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetProduct_result ip
    P.maybe (P.return ()) X.throw (getProduct_result_e res)
    P.return $ getProduct_result_success res
getProductList (ip,op) arg_productIdList arg_language arg_country = do
  send_getProductList op arg_productIdList arg_language arg_country
  recv_getProductList ip
send_getProductList op arg_productIdList arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getProductList", T.M_CALL, seqn) $
    write_GetProductList_args op (GetProductList_args{getProductList_args_productIdList=arg_productIdList,getProductList_args_language=arg_language,getProductList_args_country=arg_country})
recv_getProductList ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetProductList_result ip
    P.maybe (P.return ()) X.throw (getProductList_result_e res)
    P.return $ getProductList_result_success res
getProductListWithCarrier (ip,op) arg_productIdList arg_language arg_country arg_carrierCode = do
  send_getProductListWithCarrier op arg_productIdList arg_language arg_country arg_carrierCode
  recv_getProductListWithCarrier ip
send_getProductListWithCarrier op arg_productIdList arg_language arg_country arg_carrierCode = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getProductListWithCarrier", T.M_CALL, seqn) $
    write_GetProductListWithCarrier_args op (GetProductListWithCarrier_args{getProductListWithCarrier_args_productIdList=arg_productIdList,getProductListWithCarrier_args_language=arg_language,getProductListWithCarrier_args_country=arg_country,getProductListWithCarrier_args_carrierCode=arg_carrierCode})
recv_getProductListWithCarrier ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetProductListWithCarrier_result ip
    P.maybe (P.return ()) X.throw (getProductListWithCarrier_result_e res)
    P.return $ getProductListWithCarrier_result_success res
getProductWithCarrier (ip,op) arg_packageID arg_language arg_country arg_carrierCode = do
  send_getProductWithCarrier op arg_packageID arg_language arg_country arg_carrierCode
  recv_getProductWithCarrier ip
send_getProductWithCarrier op arg_packageID arg_language arg_country arg_carrierCode = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getProductWithCarrier", T.M_CALL, seqn) $
    write_GetProductWithCarrier_args op (GetProductWithCarrier_args{getProductWithCarrier_args_packageID=arg_packageID,getProductWithCarrier_args_language=arg_language,getProductWithCarrier_args_country=arg_country,getProductWithCarrier_args_carrierCode=arg_carrierCode})
recv_getProductWithCarrier ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetProductWithCarrier_result ip
    P.maybe (P.return ()) X.throw (getProductWithCarrier_result_e res)
    P.return $ getProductWithCarrier_result_success res
getPurchaseHistory (ip,op) arg_start arg_size arg_language arg_country = do
  send_getPurchaseHistory op arg_start arg_size arg_language arg_country
  recv_getPurchaseHistory ip
send_getPurchaseHistory op arg_start arg_size arg_language arg_country = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPurchaseHistory", T.M_CALL, seqn) $
    write_GetPurchaseHistory_args op (GetPurchaseHistory_args{getPurchaseHistory_args_start=arg_start,getPurchaseHistory_args_size=arg_size,getPurchaseHistory_args_language=arg_language,getPurchaseHistory_args_country=arg_country})
recv_getPurchaseHistory ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPurchaseHistory_result ip
    P.maybe (P.return ()) X.throw (getPurchaseHistory_result_e res)
    P.return $ getPurchaseHistory_result_success res
getTotalBalance (ip,op) arg_appStoreCode = do
  send_getTotalBalance op arg_appStoreCode
  recv_getTotalBalance ip
send_getTotalBalance op arg_appStoreCode = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getTotalBalance", T.M_CALL, seqn) $
    write_GetTotalBalance_args op (GetTotalBalance_args{getTotalBalance_args_appStoreCode=arg_appStoreCode})
recv_getTotalBalance ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetTotalBalance_result ip
    P.maybe (P.return ()) X.throw (getTotalBalance_result_e res)
    P.return $ getTotalBalance_result_success res
notifyDownloaded (ip,op) arg_packageId arg_language = do
  send_notifyDownloaded op arg_packageId arg_language
  recv_notifyDownloaded ip
send_notifyDownloaded op arg_packageId arg_language = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("notifyDownloaded", T.M_CALL, seqn) $
    write_NotifyDownloaded_args op (NotifyDownloaded_args{notifyDownloaded_args_packageId=arg_packageId,notifyDownloaded_args_language=arg_language})
recv_notifyDownloaded ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_NotifyDownloaded_result ip
    P.maybe (P.return ()) X.throw (notifyDownloaded_result_e res)
    P.return $ notifyDownloaded_result_success res
reserveCoinPurchase (ip,op) arg_request = do
  send_reserveCoinPurchase op arg_request
  recv_reserveCoinPurchase ip
send_reserveCoinPurchase op arg_request = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("reserveCoinPurchase", T.M_CALL, seqn) $
    write_ReserveCoinPurchase_args op (ReserveCoinPurchase_args{reserveCoinPurchase_args_request=arg_request})
recv_reserveCoinPurchase ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ReserveCoinPurchase_result ip
    P.maybe (P.return ()) X.throw (reserveCoinPurchase_result_e res)
    P.return $ reserveCoinPurchase_result_success res
reservePayment (ip,op) arg_paymentReservation = do
  send_reservePayment op arg_paymentReservation
  recv_reservePayment ip
send_reservePayment op arg_paymentReservation = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("reservePayment", T.M_CALL, seqn) $
    write_ReservePayment_args op (ReservePayment_args{reservePayment_args_paymentReservation=arg_paymentReservation})
recv_reservePayment ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ReservePayment_result ip
    P.maybe (P.return ()) X.throw (reservePayment_result_e res)
    P.return $ reservePayment_result_success res
