{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module MessageService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified MessageService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data FetchMessageOperations_args = FetchMessageOperations_args  { fetchMessageOperations_args_localRevision :: I.Int64
  , fetchMessageOperations_args_lastOpTimestamp :: I.Int64
  , fetchMessageOperations_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessageOperations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessageOperations_args_localRevision record   `H.hashWithSalt` fetchMessageOperations_args_lastOpTimestamp record   `H.hashWithSalt` fetchMessageOperations_args_count record  
instance QC.Arbitrary FetchMessageOperations_args where 
  arbitrary = M.liftM FetchMessageOperations_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchMessageOperations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessageOperations_args{fetchMessageOperations_args_localRevision = fetchMessageOperations_args_localRevision obj} then P.Nothing else P.Just $ default_FetchMessageOperations_args{fetchMessageOperations_args_localRevision = fetchMessageOperations_args_localRevision obj}
    , if obj == default_FetchMessageOperations_args{fetchMessageOperations_args_lastOpTimestamp = fetchMessageOperations_args_lastOpTimestamp obj} then P.Nothing else P.Just $ default_FetchMessageOperations_args{fetchMessageOperations_args_lastOpTimestamp = fetchMessageOperations_args_lastOpTimestamp obj}
    , if obj == default_FetchMessageOperations_args{fetchMessageOperations_args_count = fetchMessageOperations_args_count obj} then P.Nothing else P.Just $ default_FetchMessageOperations_args{fetchMessageOperations_args_count = fetchMessageOperations_args_count obj}
    ]
from_FetchMessageOperations_args :: FetchMessageOperations_args -> T.ThriftVal
from_FetchMessageOperations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5458 -> P.Just (2, ("localRevision",T.TI64 _v5458))) $ fetchMessageOperations_args_localRevision record
  , (\_v5458 -> P.Just (3, ("lastOpTimestamp",T.TI64 _v5458))) $ fetchMessageOperations_args_lastOpTimestamp record
  , (\_v5458 -> P.Just (4, ("count",T.TI32 _v5458))) $ fetchMessageOperations_args_count record
  ]
write_FetchMessageOperations_args :: T.Protocol p => p -> FetchMessageOperations_args -> P.IO ()
write_FetchMessageOperations_args oprot record = T.writeVal oprot $ from_FetchMessageOperations_args record
encode_FetchMessageOperations_args :: T.StatelessProtocol p => p -> FetchMessageOperations_args -> LBS.ByteString
encode_FetchMessageOperations_args oprot record = T.serializeVal oprot $ from_FetchMessageOperations_args record
to_FetchMessageOperations_args :: T.ThriftVal -> FetchMessageOperations_args
to_FetchMessageOperations_args (T.TStruct fields) = FetchMessageOperations_args{
  fetchMessageOperations_args_localRevision = P.maybe (fetchMessageOperations_args_localRevision default_FetchMessageOperations_args) (\(_,_val5460) -> (case _val5460 of {T.TI64 _val5461 -> _val5461; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchMessageOperations_args_lastOpTimestamp = P.maybe (fetchMessageOperations_args_lastOpTimestamp default_FetchMessageOperations_args) (\(_,_val5460) -> (case _val5460 of {T.TI64 _val5462 -> _val5462; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchMessageOperations_args_count = P.maybe (fetchMessageOperations_args_count default_FetchMessageOperations_args) (\(_,_val5460) -> (case _val5460 of {T.TI32 _val5463 -> _val5463; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FetchMessageOperations_args _ = P.error "not a struct"
read_FetchMessageOperations_args :: T.Protocol p => p -> P.IO FetchMessageOperations_args
read_FetchMessageOperations_args iprot = to_FetchMessageOperations_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessageOperations_args)
decode_FetchMessageOperations_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessageOperations_args
decode_FetchMessageOperations_args iprot bs = to_FetchMessageOperations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessageOperations_args) bs
typemap_FetchMessageOperations_args :: T.TypeMap
typemap_FetchMessageOperations_args = Map.fromList [(2,("localRevision",T.T_I64)),(3,("lastOpTimestamp",T.T_I64)),(4,("count",T.T_I32))]
default_FetchMessageOperations_args :: FetchMessageOperations_args
default_FetchMessageOperations_args = FetchMessageOperations_args{
  fetchMessageOperations_args_localRevision = 0,
  fetchMessageOperations_args_lastOpTimestamp = 0,
  fetchMessageOperations_args_count = 0}
data FetchMessageOperations_result = FetchMessageOperations_result  { fetchMessageOperations_result_success :: MessageOperations
  , fetchMessageOperations_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessageOperations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessageOperations_result_success record   `H.hashWithSalt` fetchMessageOperations_result_e record  
instance QC.Arbitrary FetchMessageOperations_result where 
  arbitrary = M.liftM FetchMessageOperations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchMessageOperations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessageOperations_result{fetchMessageOperations_result_success = fetchMessageOperations_result_success obj} then P.Nothing else P.Just $ default_FetchMessageOperations_result{fetchMessageOperations_result_success = fetchMessageOperations_result_success obj}
    , if obj == default_FetchMessageOperations_result{fetchMessageOperations_result_e = fetchMessageOperations_result_e obj} then P.Nothing else P.Just $ default_FetchMessageOperations_result{fetchMessageOperations_result_e = fetchMessageOperations_result_e obj}
    ]
from_FetchMessageOperations_result :: FetchMessageOperations_result -> T.ThriftVal
from_FetchMessageOperations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5466 -> (1, ("e",from_TalkException _v5466))) <$> fetchMessageOperations_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5466 -> P.Just (0, ("success",from_MessageOperations _v5466))) $ fetchMessageOperations_result_success record
    , (\_v5466 -> (1, ("e",from_TalkException _v5466))) <$> fetchMessageOperations_result_e record
    ]
    )
write_FetchMessageOperations_result :: T.Protocol p => p -> FetchMessageOperations_result -> P.IO ()
write_FetchMessageOperations_result oprot record = T.writeVal oprot $ from_FetchMessageOperations_result record
encode_FetchMessageOperations_result :: T.StatelessProtocol p => p -> FetchMessageOperations_result -> LBS.ByteString
encode_FetchMessageOperations_result oprot record = T.serializeVal oprot $ from_FetchMessageOperations_result record
to_FetchMessageOperations_result :: T.ThriftVal -> FetchMessageOperations_result
to_FetchMessageOperations_result (T.TStruct fields) = FetchMessageOperations_result{
  fetchMessageOperations_result_success = P.maybe (fetchMessageOperations_result_success default_FetchMessageOperations_result) (\(_,_val5468) -> (case _val5468 of {T.TStruct _val5469 -> (to_MessageOperations (T.TStruct _val5469)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchMessageOperations_result_e = P.maybe (P.Nothing) (\(_,_val5468) -> P.Just (case _val5468 of {T.TStruct _val5470 -> (to_TalkException (T.TStruct _val5470)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchMessageOperations_result _ = P.error "not a struct"
read_FetchMessageOperations_result :: T.Protocol p => p -> P.IO FetchMessageOperations_result
read_FetchMessageOperations_result iprot = to_FetchMessageOperations_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessageOperations_result)
decode_FetchMessageOperations_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessageOperations_result
decode_FetchMessageOperations_result iprot bs = to_FetchMessageOperations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessageOperations_result) bs
typemap_FetchMessageOperations_result :: T.TypeMap
typemap_FetchMessageOperations_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MessageOperations))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchMessageOperations_result :: FetchMessageOperations_result
default_FetchMessageOperations_result = FetchMessageOperations_result{
  fetchMessageOperations_result_success = default_MessageOperations,
  fetchMessageOperations_result_e = P.Nothing}
data GetLastReadMessageIds_args = GetLastReadMessageIds_args  { getLastReadMessageIds_args_chatId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastReadMessageIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastReadMessageIds_args_chatId record  
instance QC.Arbitrary GetLastReadMessageIds_args where 
  arbitrary = M.liftM GetLastReadMessageIds_args (QC.arbitrary)
  shrink obj | obj == default_GetLastReadMessageIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastReadMessageIds_args{getLastReadMessageIds_args_chatId = getLastReadMessageIds_args_chatId obj} then P.Nothing else P.Just $ default_GetLastReadMessageIds_args{getLastReadMessageIds_args_chatId = getLastReadMessageIds_args_chatId obj}
    ]
from_GetLastReadMessageIds_args :: GetLastReadMessageIds_args -> T.ThriftVal
from_GetLastReadMessageIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5473 -> P.Just (2, ("chatId",T.TString $ E.encodeUtf8 _v5473))) $ getLastReadMessageIds_args_chatId record
  ]
write_GetLastReadMessageIds_args :: T.Protocol p => p -> GetLastReadMessageIds_args -> P.IO ()
write_GetLastReadMessageIds_args oprot record = T.writeVal oprot $ from_GetLastReadMessageIds_args record
encode_GetLastReadMessageIds_args :: T.StatelessProtocol p => p -> GetLastReadMessageIds_args -> LBS.ByteString
encode_GetLastReadMessageIds_args oprot record = T.serializeVal oprot $ from_GetLastReadMessageIds_args record
to_GetLastReadMessageIds_args :: T.ThriftVal -> GetLastReadMessageIds_args
to_GetLastReadMessageIds_args (T.TStruct fields) = GetLastReadMessageIds_args{
  getLastReadMessageIds_args_chatId = P.maybe (getLastReadMessageIds_args_chatId default_GetLastReadMessageIds_args) (\(_,_val5475) -> (case _val5475 of {T.TString _val5476 -> E.decodeUtf8 _val5476; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetLastReadMessageIds_args _ = P.error "not a struct"
read_GetLastReadMessageIds_args :: T.Protocol p => p -> P.IO GetLastReadMessageIds_args
read_GetLastReadMessageIds_args iprot = to_GetLastReadMessageIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastReadMessageIds_args)
decode_GetLastReadMessageIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastReadMessageIds_args
decode_GetLastReadMessageIds_args iprot bs = to_GetLastReadMessageIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastReadMessageIds_args) bs
typemap_GetLastReadMessageIds_args :: T.TypeMap
typemap_GetLastReadMessageIds_args = Map.fromList [(2,("chatId",T.T_STRING))]
default_GetLastReadMessageIds_args :: GetLastReadMessageIds_args
default_GetLastReadMessageIds_args = GetLastReadMessageIds_args{
  getLastReadMessageIds_args_chatId = ""}
data GetLastReadMessageIds_result = GetLastReadMessageIds_result  { getLastReadMessageIds_result_success :: LastReadMessageIds
  , getLastReadMessageIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastReadMessageIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastReadMessageIds_result_success record   `H.hashWithSalt` getLastReadMessageIds_result_e record  
instance QC.Arbitrary GetLastReadMessageIds_result where 
  arbitrary = M.liftM GetLastReadMessageIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastReadMessageIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastReadMessageIds_result{getLastReadMessageIds_result_success = getLastReadMessageIds_result_success obj} then P.Nothing else P.Just $ default_GetLastReadMessageIds_result{getLastReadMessageIds_result_success = getLastReadMessageIds_result_success obj}
    , if obj == default_GetLastReadMessageIds_result{getLastReadMessageIds_result_e = getLastReadMessageIds_result_e obj} then P.Nothing else P.Just $ default_GetLastReadMessageIds_result{getLastReadMessageIds_result_e = getLastReadMessageIds_result_e obj}
    ]
from_GetLastReadMessageIds_result :: GetLastReadMessageIds_result -> T.ThriftVal
from_GetLastReadMessageIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5479 -> (1, ("e",from_TalkException _v5479))) <$> getLastReadMessageIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5479 -> P.Just (0, ("success",from_LastReadMessageIds _v5479))) $ getLastReadMessageIds_result_success record
    , (\_v5479 -> (1, ("e",from_TalkException _v5479))) <$> getLastReadMessageIds_result_e record
    ]
    )
write_GetLastReadMessageIds_result :: T.Protocol p => p -> GetLastReadMessageIds_result -> P.IO ()
write_GetLastReadMessageIds_result oprot record = T.writeVal oprot $ from_GetLastReadMessageIds_result record
encode_GetLastReadMessageIds_result :: T.StatelessProtocol p => p -> GetLastReadMessageIds_result -> LBS.ByteString
encode_GetLastReadMessageIds_result oprot record = T.serializeVal oprot $ from_GetLastReadMessageIds_result record
to_GetLastReadMessageIds_result :: T.ThriftVal -> GetLastReadMessageIds_result
to_GetLastReadMessageIds_result (T.TStruct fields) = GetLastReadMessageIds_result{
  getLastReadMessageIds_result_success = P.maybe (getLastReadMessageIds_result_success default_GetLastReadMessageIds_result) (\(_,_val5481) -> (case _val5481 of {T.TStruct _val5482 -> (to_LastReadMessageIds (T.TStruct _val5482)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastReadMessageIds_result_e = P.maybe (P.Nothing) (\(_,_val5481) -> P.Just (case _val5481 of {T.TStruct _val5483 -> (to_TalkException (T.TStruct _val5483)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastReadMessageIds_result _ = P.error "not a struct"
read_GetLastReadMessageIds_result :: T.Protocol p => p -> P.IO GetLastReadMessageIds_result
read_GetLastReadMessageIds_result iprot = to_GetLastReadMessageIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastReadMessageIds_result)
decode_GetLastReadMessageIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastReadMessageIds_result
decode_GetLastReadMessageIds_result iprot bs = to_GetLastReadMessageIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastReadMessageIds_result) bs
typemap_GetLastReadMessageIds_result :: T.TypeMap
typemap_GetLastReadMessageIds_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LastReadMessageIds))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastReadMessageIds_result :: GetLastReadMessageIds_result
default_GetLastReadMessageIds_result = GetLastReadMessageIds_result{
  getLastReadMessageIds_result_success = default_LastReadMessageIds,
  getLastReadMessageIds_result_e = P.Nothing}
data MultiGetLastReadMessageIds_args = MultiGetLastReadMessageIds_args  { multiGetLastReadMessageIds_args_chatIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MultiGetLastReadMessageIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` multiGetLastReadMessageIds_args_chatIds record  
instance QC.Arbitrary MultiGetLastReadMessageIds_args where 
  arbitrary = M.liftM MultiGetLastReadMessageIds_args (QC.arbitrary)
  shrink obj | obj == default_MultiGetLastReadMessageIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MultiGetLastReadMessageIds_args{multiGetLastReadMessageIds_args_chatIds = multiGetLastReadMessageIds_args_chatIds obj} then P.Nothing else P.Just $ default_MultiGetLastReadMessageIds_args{multiGetLastReadMessageIds_args_chatIds = multiGetLastReadMessageIds_args_chatIds obj}
    ]
from_MultiGetLastReadMessageIds_args :: MultiGetLastReadMessageIds_args -> T.ThriftVal
from_MultiGetLastReadMessageIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5486 -> P.Just (2, ("chatIds",T.TList T.T_STRING $ P.map (\_v5488 -> T.TString $ E.encodeUtf8 _v5488) $ Vector.toList _v5486))) $ multiGetLastReadMessageIds_args_chatIds record
  ]
write_MultiGetLastReadMessageIds_args :: T.Protocol p => p -> MultiGetLastReadMessageIds_args -> P.IO ()
write_MultiGetLastReadMessageIds_args oprot record = T.writeVal oprot $ from_MultiGetLastReadMessageIds_args record
encode_MultiGetLastReadMessageIds_args :: T.StatelessProtocol p => p -> MultiGetLastReadMessageIds_args -> LBS.ByteString
encode_MultiGetLastReadMessageIds_args oprot record = T.serializeVal oprot $ from_MultiGetLastReadMessageIds_args record
to_MultiGetLastReadMessageIds_args :: T.ThriftVal -> MultiGetLastReadMessageIds_args
to_MultiGetLastReadMessageIds_args (T.TStruct fields) = MultiGetLastReadMessageIds_args{
  multiGetLastReadMessageIds_args_chatIds = P.maybe (multiGetLastReadMessageIds_args_chatIds default_MultiGetLastReadMessageIds_args) (\(_,_val5490) -> (case _val5490 of {T.TList _ _val5491 -> (Vector.fromList $ P.map (\_v5492 -> (case _v5492 of {T.TString _val5493 -> E.decodeUtf8 _val5493; _ -> P.error "wrong type"})) _val5491); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MultiGetLastReadMessageIds_args _ = P.error "not a struct"
read_MultiGetLastReadMessageIds_args :: T.Protocol p => p -> P.IO MultiGetLastReadMessageIds_args
read_MultiGetLastReadMessageIds_args iprot = to_MultiGetLastReadMessageIds_args <$> T.readVal iprot (T.T_STRUCT typemap_MultiGetLastReadMessageIds_args)
decode_MultiGetLastReadMessageIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> MultiGetLastReadMessageIds_args
decode_MultiGetLastReadMessageIds_args iprot bs = to_MultiGetLastReadMessageIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MultiGetLastReadMessageIds_args) bs
typemap_MultiGetLastReadMessageIds_args :: T.TypeMap
typemap_MultiGetLastReadMessageIds_args = Map.fromList [(2,("chatIds",(T.T_LIST T.T_STRING)))]
default_MultiGetLastReadMessageIds_args :: MultiGetLastReadMessageIds_args
default_MultiGetLastReadMessageIds_args = MultiGetLastReadMessageIds_args{
  multiGetLastReadMessageIds_args_chatIds = Vector.empty}
data MultiGetLastReadMessageIds_result = MultiGetLastReadMessageIds_result  { multiGetLastReadMessageIds_result_success :: (Vector.Vector LastReadMessageIds)
  , multiGetLastReadMessageIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MultiGetLastReadMessageIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` multiGetLastReadMessageIds_result_success record   `H.hashWithSalt` multiGetLastReadMessageIds_result_e record  
instance QC.Arbitrary MultiGetLastReadMessageIds_result where 
  arbitrary = M.liftM MultiGetLastReadMessageIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MultiGetLastReadMessageIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_success = multiGetLastReadMessageIds_result_success obj} then P.Nothing else P.Just $ default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_success = multiGetLastReadMessageIds_result_success obj}
    , if obj == default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_e = multiGetLastReadMessageIds_result_e obj} then P.Nothing else P.Just $ default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_e = multiGetLastReadMessageIds_result_e obj}
    ]
from_MultiGetLastReadMessageIds_result :: MultiGetLastReadMessageIds_result -> T.ThriftVal
from_MultiGetLastReadMessageIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5496 -> (1, ("e",from_TalkException _v5496))) <$> multiGetLastReadMessageIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5496 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_LastReadMessageIds) $ P.map (\_v5498 -> from_LastReadMessageIds _v5498) $ Vector.toList _v5496))) $ multiGetLastReadMessageIds_result_success record
    , (\_v5496 -> (1, ("e",from_TalkException _v5496))) <$> multiGetLastReadMessageIds_result_e record
    ]
    )
write_MultiGetLastReadMessageIds_result :: T.Protocol p => p -> MultiGetLastReadMessageIds_result -> P.IO ()
write_MultiGetLastReadMessageIds_result oprot record = T.writeVal oprot $ from_MultiGetLastReadMessageIds_result record
encode_MultiGetLastReadMessageIds_result :: T.StatelessProtocol p => p -> MultiGetLastReadMessageIds_result -> LBS.ByteString
encode_MultiGetLastReadMessageIds_result oprot record = T.serializeVal oprot $ from_MultiGetLastReadMessageIds_result record
to_MultiGetLastReadMessageIds_result :: T.ThriftVal -> MultiGetLastReadMessageIds_result
to_MultiGetLastReadMessageIds_result (T.TStruct fields) = MultiGetLastReadMessageIds_result{
  multiGetLastReadMessageIds_result_success = P.maybe (multiGetLastReadMessageIds_result_success default_MultiGetLastReadMessageIds_result) (\(_,_val5500) -> (case _val5500 of {T.TList _ _val5501 -> (Vector.fromList $ P.map (\_v5502 -> (case _v5502 of {T.TStruct _val5503 -> (to_LastReadMessageIds (T.TStruct _val5503)); _ -> P.error "wrong type"})) _val5501); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  multiGetLastReadMessageIds_result_e = P.maybe (P.Nothing) (\(_,_val5500) -> P.Just (case _val5500 of {T.TStruct _val5504 -> (to_TalkException (T.TStruct _val5504)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MultiGetLastReadMessageIds_result _ = P.error "not a struct"
read_MultiGetLastReadMessageIds_result :: T.Protocol p => p -> P.IO MultiGetLastReadMessageIds_result
read_MultiGetLastReadMessageIds_result iprot = to_MultiGetLastReadMessageIds_result <$> T.readVal iprot (T.T_STRUCT typemap_MultiGetLastReadMessageIds_result)
decode_MultiGetLastReadMessageIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> MultiGetLastReadMessageIds_result
decode_MultiGetLastReadMessageIds_result iprot bs = to_MultiGetLastReadMessageIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MultiGetLastReadMessageIds_result) bs
typemap_MultiGetLastReadMessageIds_result :: T.TypeMap
typemap_MultiGetLastReadMessageIds_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_LastReadMessageIds)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_MultiGetLastReadMessageIds_result :: MultiGetLastReadMessageIds_result
default_MultiGetLastReadMessageIds_result = MultiGetLastReadMessageIds_result{
  multiGetLastReadMessageIds_result_success = Vector.empty,
  multiGetLastReadMessageIds_result_e = P.Nothing}
process_fetchMessageOperations (seqid, iprot, oprot, handler) = do
  args <- read_FetchMessageOperations_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchMessageOperations handler (fetchMessageOperations_args_localRevision args) (fetchMessageOperations_args_lastOpTimestamp args) (fetchMessageOperations_args_count args)
        let res = default_FetchMessageOperations_result{fetchMessageOperations_result_success = val}
        T.writeMessage oprot ("fetchMessageOperations", T.M_REPLY, seqid) $
          write_FetchMessageOperations_result oprot res)
      (\e  -> do
        let res = default_FetchMessageOperations_result{fetchMessageOperations_result_e = P.Just e}
        T.writeMessage oprot ("fetchMessageOperations", T.M_REPLY, seqid) $
          write_FetchMessageOperations_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchMessageOperations", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastReadMessageIds (seqid, iprot, oprot, handler) = do
  args <- read_GetLastReadMessageIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastReadMessageIds handler (getLastReadMessageIds_args_chatId args)
        let res = default_GetLastReadMessageIds_result{getLastReadMessageIds_result_success = val}
        T.writeMessage oprot ("getLastReadMessageIds", T.M_REPLY, seqid) $
          write_GetLastReadMessageIds_result oprot res)
      (\e  -> do
        let res = default_GetLastReadMessageIds_result{getLastReadMessageIds_result_e = P.Just e}
        T.writeMessage oprot ("getLastReadMessageIds", T.M_REPLY, seqid) $
          write_GetLastReadMessageIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastReadMessageIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_multiGetLastReadMessageIds (seqid, iprot, oprot, handler) = do
  args <- read_MultiGetLastReadMessageIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.multiGetLastReadMessageIds handler (multiGetLastReadMessageIds_args_chatIds args)
        let res = default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_success = val}
        T.writeMessage oprot ("multiGetLastReadMessageIds", T.M_REPLY, seqid) $
          write_MultiGetLastReadMessageIds_result oprot res)
      (\e  -> do
        let res = default_MultiGetLastReadMessageIds_result{multiGetLastReadMessageIds_result_e = P.Just e}
        T.writeMessage oprot ("multiGetLastReadMessageIds", T.M_REPLY, seqid) $
          write_MultiGetLastReadMessageIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("multiGetLastReadMessageIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "fetchMessageOperations" -> process_fetchMessageOperations (seqid,iprot,oprot,handler)
  "getLastReadMessageIds" -> process_getLastReadMessageIds (seqid,iprot,oprot,handler)
  "multiGetLastReadMessageIds" -> process_multiGetLastReadMessageIds (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
