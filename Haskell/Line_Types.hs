{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Line_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data ApplicationType = IOS|IOS_RC|IOS_BETA|IOS_ALPHA|ANDROID|ANDROID_RC|ANDROID_BETA|ANDROID_ALPHA|WAP|WAP_RC|WAP_BETA|WAP_ALPHA|BOT|BOT_RC|BOT_BETA|BOT_ALPHA|WEB|WEB_RC|WEB_BETA|WEB_ALPHA|DESKTOPWIN|DESKTOPWIN_RC|DESKTOPWIN_BETA|DESKTOPWIN_ALPHA|DESKTOPMAC|DESKTOPMAC_RC|DESKTOPMAC_BETA|DESKTOPMAC_ALPHA|CHANNELGW|CHANNELGW_RC|CHANNELGW_BETA|CHANNELGW_ALPHA|CHANNELCP|CHANNELCP_RC|CHANNELCP_BETA|CHANNELCP_ALPHA|WINPHONE|WINPHONE_RC|WINPHONE_BETA|WINPHONE_ALPHA|BLACKBERRY|BLACKBERRY_RC|BLACKBERRY_BETA|BLACKBERRY_ALPHA|WINMETRO|WINMETRO_RC|WINMETRO_BETA|WINMETRO_ALPHA|S40|S40_RC|S40_BETA|S40_ALPHA|CHRONO|CHRONO_RC|CHRONO_BETA|CHRONO_ALPHA|TIZEN|TIZEN_RC|TIZEN_BETA|TIZEN_ALPHA|VIRTUAL|FIREFOXOS|FIREFOXOS_RC|FIREFOXOS_BETA|FIREFOXOS_ALPHA|IOSIPAD|IOSIPAD_RC|IOSIPAD_BETA|IOSIPAD_ALPHA|BIZIOS|BIZIOS_RC|BIZIOS_BETA|BIZIOS_ALPHA|BIZANDROID|BIZANDROID_RC|BIZANDROID_BETA|BIZANDROID_ALPHA|BIZBOT|BIZBOT_RC|BIZBOT_BETA|BIZBOT_ALPHA|CHROMEOS|CHROMEOS_RC|CHROMEOS_BETA|CHROMEOS_ALPHA|ANDROIDLITE|ANDROIDLITE_RC|ANDROIDLITE_BETA|ANDROIDLITE_ALPHA|WIN10|WIN10_RC|WIN10_BETA|WIN10_ALPHA|BIZWEB|BIZWEB_RC|BIZWEB_BETA|BIZWEB_ALPHA|DUMMYPRIMARY|DUMMYPRIMARY_RC|DUMMYPRIMARY_BETA|DUMMYPRIMARY_ALPHA|SQUARE|SQUARE_RC|SQUARE_BETA|SQUARE_ALPHA|INTERNAL|INTERNAL_RC|INTERNAL_BETA|INTERNAL_ALPHA|CLOVAFRIENDS|CLOVAFRIENDS_RC|CLOVAFRIENDS_BETA|CLOVAFRIENDS_ALPHA  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ApplicationType where
  fromEnum t = case t of
    IOS -> 16
    IOS_RC -> 17
    IOS_BETA -> 18
    IOS_ALPHA -> 19
    ANDROID -> 32
    ANDROID_RC -> 33
    ANDROID_BETA -> 34
    ANDROID_ALPHA -> 35
    WAP -> 48
    WAP_RC -> 49
    WAP_BETA -> 50
    WAP_ALPHA -> 51
    BOT -> 64
    BOT_RC -> 65
    BOT_BETA -> 66
    BOT_ALPHA -> 67
    WEB -> 80
    WEB_RC -> 81
    WEB_BETA -> 82
    WEB_ALPHA -> 83
    DESKTOPWIN -> 96
    DESKTOPWIN_RC -> 97
    DESKTOPWIN_BETA -> 98
    DESKTOPWIN_ALPHA -> 99
    DESKTOPMAC -> 112
    DESKTOPMAC_RC -> 113
    DESKTOPMAC_BETA -> 114
    DESKTOPMAC_ALPHA -> 115
    CHANNELGW -> 128
    CHANNELGW_RC -> 129
    CHANNELGW_BETA -> 130
    CHANNELGW_ALPHA -> 131
    CHANNELCP -> 144
    CHANNELCP_RC -> 145
    CHANNELCP_BETA -> 146
    CHANNELCP_ALPHA -> 147
    WINPHONE -> 160
    WINPHONE_RC -> 161
    WINPHONE_BETA -> 162
    WINPHONE_ALPHA -> 163
    BLACKBERRY -> 176
    BLACKBERRY_RC -> 177
    BLACKBERRY_BETA -> 178
    BLACKBERRY_ALPHA -> 179
    WINMETRO -> 192
    WINMETRO_RC -> 193
    WINMETRO_BETA -> 194
    WINMETRO_ALPHA -> 195
    S40 -> 208
    S40_RC -> 209
    S40_BETA -> 210
    S40_ALPHA -> 211
    CHRONO -> 224
    CHRONO_RC -> 225
    CHRONO_BETA -> 226
    CHRONO_ALPHA -> 227
    TIZEN -> 256
    TIZEN_RC -> 257
    TIZEN_BETA -> 258
    TIZEN_ALPHA -> 259
    VIRTUAL -> 272
    FIREFOXOS -> 288
    FIREFOXOS_RC -> 289
    FIREFOXOS_BETA -> 290
    FIREFOXOS_ALPHA -> 291
    IOSIPAD -> 304
    IOSIPAD_RC -> 305
    IOSIPAD_BETA -> 306
    IOSIPAD_ALPHA -> 307
    BIZIOS -> 320
    BIZIOS_RC -> 321
    BIZIOS_BETA -> 322
    BIZIOS_ALPHA -> 323
    BIZANDROID -> 336
    BIZANDROID_RC -> 337
    BIZANDROID_BETA -> 338
    BIZANDROID_ALPHA -> 339
    BIZBOT -> 352
    BIZBOT_RC -> 353
    BIZBOT_BETA -> 354
    BIZBOT_ALPHA -> 355
    CHROMEOS -> 368
    CHROMEOS_RC -> 369
    CHROMEOS_BETA -> 370
    CHROMEOS_ALPHA -> 371
    ANDROIDLITE -> 384
    ANDROIDLITE_RC -> 385
    ANDROIDLITE_BETA -> 386
    ANDROIDLITE_ALPHA -> 387
    WIN10 -> 400
    WIN10_RC -> 401
    WIN10_BETA -> 402
    WIN10_ALPHA -> 403
    BIZWEB -> 416
    BIZWEB_RC -> 417
    BIZWEB_BETA -> 418
    BIZWEB_ALPHA -> 419
    DUMMYPRIMARY -> 432
    DUMMYPRIMARY_RC -> 433
    DUMMYPRIMARY_BETA -> 434
    DUMMYPRIMARY_ALPHA -> 435
    SQUARE -> 448
    SQUARE_RC -> 449
    SQUARE_BETA -> 450
    SQUARE_ALPHA -> 451
    INTERNAL -> 464
    INTERNAL_RC -> 465
    INTERNAL_BETA -> 466
    INTERNAL_ALPHA -> 467
    CLOVAFRIENDS -> 480
    CLOVAFRIENDS_RC -> 481
    CLOVAFRIENDS_BETA -> 482
    CLOVAFRIENDS_ALPHA -> 483
  toEnum t = case t of
    16 -> IOS
    17 -> IOS_RC
    18 -> IOS_BETA
    19 -> IOS_ALPHA
    32 -> ANDROID
    33 -> ANDROID_RC
    34 -> ANDROID_BETA
    35 -> ANDROID_ALPHA
    48 -> WAP
    49 -> WAP_RC
    50 -> WAP_BETA
    51 -> WAP_ALPHA
    64 -> BOT
    65 -> BOT_RC
    66 -> BOT_BETA
    67 -> BOT_ALPHA
    80 -> WEB
    81 -> WEB_RC
    82 -> WEB_BETA
    83 -> WEB_ALPHA
    96 -> DESKTOPWIN
    97 -> DESKTOPWIN_RC
    98 -> DESKTOPWIN_BETA
    99 -> DESKTOPWIN_ALPHA
    112 -> DESKTOPMAC
    113 -> DESKTOPMAC_RC
    114 -> DESKTOPMAC_BETA
    115 -> DESKTOPMAC_ALPHA
    128 -> CHANNELGW
    129 -> CHANNELGW_RC
    130 -> CHANNELGW_BETA
    131 -> CHANNELGW_ALPHA
    144 -> CHANNELCP
    145 -> CHANNELCP_RC
    146 -> CHANNELCP_BETA
    147 -> CHANNELCP_ALPHA
    160 -> WINPHONE
    161 -> WINPHONE_RC
    162 -> WINPHONE_BETA
    163 -> WINPHONE_ALPHA
    176 -> BLACKBERRY
    177 -> BLACKBERRY_RC
    178 -> BLACKBERRY_BETA
    179 -> BLACKBERRY_ALPHA
    192 -> WINMETRO
    193 -> WINMETRO_RC
    194 -> WINMETRO_BETA
    195 -> WINMETRO_ALPHA
    208 -> S40
    209 -> S40_RC
    210 -> S40_BETA
    211 -> S40_ALPHA
    224 -> CHRONO
    225 -> CHRONO_RC
    226 -> CHRONO_BETA
    227 -> CHRONO_ALPHA
    256 -> TIZEN
    257 -> TIZEN_RC
    258 -> TIZEN_BETA
    259 -> TIZEN_ALPHA
    272 -> VIRTUAL
    288 -> FIREFOXOS
    289 -> FIREFOXOS_RC
    290 -> FIREFOXOS_BETA
    291 -> FIREFOXOS_ALPHA
    304 -> IOSIPAD
    305 -> IOSIPAD_RC
    306 -> IOSIPAD_BETA
    307 -> IOSIPAD_ALPHA
    320 -> BIZIOS
    321 -> BIZIOS_RC
    322 -> BIZIOS_BETA
    323 -> BIZIOS_ALPHA
    336 -> BIZANDROID
    337 -> BIZANDROID_RC
    338 -> BIZANDROID_BETA
    339 -> BIZANDROID_ALPHA
    352 -> BIZBOT
    353 -> BIZBOT_RC
    354 -> BIZBOT_BETA
    355 -> BIZBOT_ALPHA
    368 -> CHROMEOS
    369 -> CHROMEOS_RC
    370 -> CHROMEOS_BETA
    371 -> CHROMEOS_ALPHA
    384 -> ANDROIDLITE
    385 -> ANDROIDLITE_RC
    386 -> ANDROIDLITE_BETA
    387 -> ANDROIDLITE_ALPHA
    400 -> WIN10
    401 -> WIN10_RC
    402 -> WIN10_BETA
    403 -> WIN10_ALPHA
    416 -> BIZWEB
    417 -> BIZWEB_RC
    418 -> BIZWEB_BETA
    419 -> BIZWEB_ALPHA
    432 -> DUMMYPRIMARY
    433 -> DUMMYPRIMARY_RC
    434 -> DUMMYPRIMARY_BETA
    435 -> DUMMYPRIMARY_ALPHA
    448 -> SQUARE
    449 -> SQUARE_RC
    450 -> SQUARE_BETA
    451 -> SQUARE_ALPHA
    464 -> INTERNAL
    465 -> INTERNAL_RC
    466 -> INTERNAL_BETA
    467 -> INTERNAL_ALPHA
    480 -> CLOVAFRIENDS
    481 -> CLOVAFRIENDS_RC
    482 -> CLOVAFRIENDS_BETA
    483 -> CLOVAFRIENDS_ALPHA
    _ -> X.throw T.ThriftException
instance H.Hashable ApplicationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ApplicationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ExtendedProfileAttribute =   deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ExtendedProfileAttribute where
  fromEnum t = case t of
  toEnum t = case t of
    _ -> X.throw T.ThriftException
instance H.Hashable ExtendedProfileAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ExtendedProfileAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PrivacyLevelType = PUBLIC|PRIVATE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PrivacyLevelType where
  fromEnum t = case t of
    PUBLIC -> 0
    PRIVATE -> 1
  toEnum t = case t of
    0 -> PUBLIC
    1 -> PRIVATE
    _ -> X.throw T.ThriftException
instance H.Hashable PrivacyLevelType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PrivacyLevelType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaidCallerIdStatus = NOT_SPECIFIED|VALID|VERIFICATION_REQUIRED|NOT_PERMITTED|LIMIT_EXCEEDED|LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaidCallerIdStatus where
  fromEnum t = case t of
    NOT_SPECIFIED -> 0
    VALID -> 1
    VERIFICATION_REQUIRED -> 2
    NOT_PERMITTED -> 3
    LIMIT_EXCEEDED -> 4
    LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED -> 5
  toEnum t = case t of
    0 -> NOT_SPECIFIED
    1 -> VALID
    2 -> VERIFICATION_REQUIRED
    3 -> NOT_PERMITTED
    4 -> LIMIT_EXCEEDED
    5 -> LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED
    _ -> X.throw T.ThriftException
instance H.Hashable PaidCallerIdStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaidCallerIdStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaidCallProductType = COIN|CREDIT|MONTHLY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaidCallProductType where
  fromEnum t = case t of
    COIN -> 0
    CREDIT -> 1
    MONTHLY -> 2
  toEnum t = case t of
    0 -> COIN
    1 -> CREDIT
    2 -> MONTHLY
    _ -> X.throw T.ThriftException
instance H.Hashable PaidCallProductType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaidCallProductType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaidCallType = OUT|IN|TOLLFREE|RECORD|AD|CS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaidCallType where
  fromEnum t = case t of
    OUT -> 0
    IN -> 1
    TOLLFREE -> 2
    RECORD -> 3
    AD -> 4
    CS -> 5
  toEnum t = case t of
    0 -> OUT
    1 -> IN
    2 -> TOLLFREE
    3 -> RECORD
    4 -> AD
    5 -> CS
    _ -> X.throw T.ThriftException
instance H.Hashable PaidCallType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaidCallType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BotType = RESERVED|OFFICIAL|LINE_AT_0|LINE_AT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BotType where
  fromEnum t = case t of
    RESERVED -> 0
    OFFICIAL -> 1
    LINE_AT_0 -> 2
    LINE_AT -> 3
  toEnum t = case t of
    0 -> RESERVED
    1 -> OFFICIAL
    2 -> LINE_AT_0
    3 -> LINE_AT
    _ -> X.throw T.ThriftException
instance H.Hashable BotType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BotType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyOnAirLabel = ON_AIR|LIVE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyOnAirLabel where
  fromEnum t = case t of
    ON_AIR -> 0
    LIVE -> 1
  toEnum t = case t of
    0 -> ON_AIR
    1 -> LIVE
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyOnAirLabel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyOnAirLabel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyBannerLinkType = BUDDY_BANNER_LINK_HIDDEN|BUDDY_BANNER_LINK_MID|BUDDY_BANNER_LINK_URL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyBannerLinkType where
  fromEnum t = case t of
    BUDDY_BANNER_LINK_HIDDEN -> 0
    BUDDY_BANNER_LINK_MID -> 1
    BUDDY_BANNER_LINK_URL -> 2
  toEnum t = case t of
    0 -> BUDDY_BANNER_LINK_HIDDEN
    1 -> BUDDY_BANNER_LINK_MID
    2 -> BUDDY_BANNER_LINK_URL
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyBannerLinkType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyBannerLinkType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyOnAirType = NORMAL|LIVE|VOIP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyOnAirType where
  fromEnum t = case t of
    NORMAL -> 0
    LIVE -> 1
    VOIP -> 2
  toEnum t = case t of
    0 -> NORMAL
    1 -> LIVE
    2 -> VOIP
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyOnAirType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyOnAirType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Diff = ADDED|UPDATED|REMOVED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum Diff where
  fromEnum t = case t of
    ADDED -> 0
    UPDATED -> 1
    REMOVED -> 2
  toEnum t = case t of
    0 -> ADDED
    1 -> UPDATED
    2 -> REMOVED
    _ -> X.throw T.ThriftException
instance H.Hashable Diff where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary Diff where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ReportType = ADVERTISING|GENDER_HARASSMENT|HARASSMENT|OTHER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ReportType where
  fromEnum t = case t of
    ADVERTISING -> 1
    GENDER_HARASSMENT -> 2
    HARASSMENT -> 3
    OTHER -> 4
  toEnum t = case t of
    1 -> ADVERTISING
    2 -> GENDER_HARASSMENT
    3 -> HARASSMENT
    4 -> OTHER
    _ -> X.throw T.ThriftException
instance H.Hashable ReportType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ReportType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncTriggerReason = OTHER|REVISION_GAP_TOO_LARGE|OPERATION_EXPIRED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SyncTriggerReason where
  fromEnum t = case t of
    OTHER -> 0
    REVISION_GAP_TOO_LARGE -> 1
    OPERATION_EXPIRED -> 2
  toEnum t = case t of
    0 -> OTHER
    1 -> REVISION_GAP_TOO_LARGE
    2 -> OPERATION_EXPIRED
    _ -> X.throw T.ThriftException
instance H.Hashable SyncTriggerReason where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SyncTriggerReason where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ReportCategory = PUSH_NORMAL_PLAIN|PUSH_NORMAL_E2EE|PUSH_VOIP_PLAIN|PUSH_VOIP_E2EE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ReportCategory where
  fromEnum t = case t of
    PUSH_NORMAL_PLAIN -> 0
    PUSH_NORMAL_E2EE -> 1
    PUSH_VOIP_PLAIN -> 2
    PUSH_VOIP_E2EE -> 3
  toEnum t = case t of
    0 -> PUSH_NORMAL_PLAIN
    1 -> PUSH_NORMAL_E2EE
    2 -> PUSH_VOIP_PLAIN
    3 -> PUSH_VOIP_E2EE
    _ -> X.throw T.ThriftException
instance H.Hashable ReportCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ReportCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddyResultState = ACCEPTED|SUCCEEDED|FAILED|CANCELLED|NOTIFY_FAILED|STORING|UPLOADING|NOTIFYING|REMOVING_SUBSCRIPTION|UNREGISTERING_ACCOUNT|NOTIFYING_LEAVE_CHAT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddyResultState where
  fromEnum t = case t of
    ACCEPTED -> 1
    SUCCEEDED -> 2
    FAILED -> 3
    CANCELLED -> 4
    NOTIFY_FAILED -> 5
    STORING -> 11
    UPLOADING -> 21
    NOTIFYING -> 31
    REMOVING_SUBSCRIPTION -> 41
    UNREGISTERING_ACCOUNT -> 42
    NOTIFYING_LEAVE_CHAT -> 43
  toEnum t = case t of
    1 -> ACCEPTED
    2 -> SUCCEEDED
    3 -> FAILED
    4 -> CANCELLED
    5 -> NOTIFY_FAILED
    11 -> STORING
    21 -> UPLOADING
    31 -> NOTIFYING
    41 -> REMOVING_SUBSCRIPTION
    42 -> UNREGISTERING_ACCOUNT
    43 -> NOTIFYING_LEAVE_CHAT
    _ -> X.throw T.ThriftException
instance H.Hashable BuddyResultState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddyResultState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BuddySearchRequestSource = NA|FRIEND_VIEW|OFFICIAL_ACCOUNT_VIEW  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BuddySearchRequestSource where
  fromEnum t = case t of
    NA -> 0
    FRIEND_VIEW -> 1
    OFFICIAL_ACCOUNT_VIEW -> 2
  toEnum t = case t of
    0 -> NA
    1 -> FRIEND_VIEW
    2 -> OFFICIAL_ACCOUNT_VIEW
    _ -> X.throw T.ThriftException
instance H.Hashable BuddySearchRequestSource where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BuddySearchRequestSource where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CarrierCode = NOT_SPECIFIED|JP_DOCOMO|JP_AU|JP_SOFTBANK|JP_DOCOMO_LINE|KR_SKT|KR_KT|KR_LGT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CarrierCode where
  fromEnum t = case t of
    NOT_SPECIFIED -> 0
    JP_DOCOMO -> 1
    JP_AU -> 2
    JP_SOFTBANK -> 3
    JP_DOCOMO_LINE -> 4
    KR_SKT -> 17
    KR_KT -> 18
    KR_LGT -> 19
  toEnum t = case t of
    0 -> NOT_SPECIFIED
    1 -> JP_DOCOMO
    2 -> JP_AU
    3 -> JP_SOFTBANK
    4 -> JP_DOCOMO_LINE
    17 -> KR_SKT
    18 -> KR_KT
    19 -> KR_LGT
    _ -> X.throw T.ThriftException
instance H.Hashable CarrierCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CarrierCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelConfiguration = MESSAGE|MESSAGE_NOTIFICATION|NOTIFICATION_CENTER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelConfiguration where
  fromEnum t = case t of
    MESSAGE -> 0
    MESSAGE_NOTIFICATION -> 1
    NOTIFICATION_CENTER -> 2
  toEnum t = case t of
    0 -> MESSAGE
    1 -> MESSAGE_NOTIFICATION
    2 -> NOTIFICATION_CENTER
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelConfiguration where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelConfiguration where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelPermission = PROFILE|FRIENDS|GROUP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelPermission where
  fromEnum t = case t of
    PROFILE -> 0
    FRIENDS -> 1
    GROUP -> 2
  toEnum t = case t of
    0 -> PROFILE
    1 -> FRIENDS
    2 -> GROUP
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelPermission where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelPermission where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelFeatureLicense = BLE_LCS_API_USABLE|PROHIBIT_MINIMIZE_CHANNEL_BROWSER|ALLOW_IOS_WEBKIT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelFeatureLicense where
  fromEnum t = case t of
    BLE_LCS_API_USABLE -> 26
    PROHIBIT_MINIMIZE_CHANNEL_BROWSER -> 27
    ALLOW_IOS_WEBKIT -> 28
  toEnum t = case t of
    26 -> BLE_LCS_API_USABLE
    27 -> PROHIBIT_MINIMIZE_CHANNEL_BROWSER
    28 -> ALLOW_IOS_WEBKIT
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelFeatureLicense where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelFeatureLicense where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelErrorCode = ILLEGAL_ARGUMENT|INTERNAL_ERROR|CONNECTION_ERROR|AUTHENTICATIONI_FAILED|NEED_PERMISSION_APPROVAL|COIN_NOT_USABLE|WEBVIEW_NOT_ALLOWED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelErrorCode where
  fromEnum t = case t of
    ILLEGAL_ARGUMENT -> 0
    INTERNAL_ERROR -> 1
    CONNECTION_ERROR -> 2
    AUTHENTICATIONI_FAILED -> 3
    NEED_PERMISSION_APPROVAL -> 4
    COIN_NOT_USABLE -> 5
    WEBVIEW_NOT_ALLOWED -> 6
  toEnum t = case t of
    0 -> ILLEGAL_ARGUMENT
    1 -> INTERNAL_ERROR
    2 -> CONNECTION_ERROR
    3 -> AUTHENTICATIONI_FAILED
    4 -> NEED_PERMISSION_APPROVAL
    5 -> COIN_NOT_USABLE
    6 -> WEBVIEW_NOT_ALLOWED
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChannelSyncType = SYNC|REMOVE|REMOVE_ALL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChannelSyncType where
  fromEnum t = case t of
    SYNC -> 0
    REMOVE -> 1
    REMOVE_ALL -> 2
  toEnum t = case t of
    0 -> SYNC
    1 -> REMOVE
    2 -> REMOVE_ALL
    _ -> X.throw T.ThriftException
instance H.Hashable ChannelSyncType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChannelSyncType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data LoginType = ID_CREDENTIAL|QRCODE|ID_CREDENTIAL_WITH_E2EE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum LoginType where
  fromEnum t = case t of
    ID_CREDENTIAL -> 0
    QRCODE -> 1
    ID_CREDENTIAL_WITH_E2EE -> 2
  toEnum t = case t of
    0 -> ID_CREDENTIAL
    1 -> QRCODE
    2 -> ID_CREDENTIAL_WITH_E2EE
    _ -> X.throw T.ThriftException
instance H.Hashable LoginType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary LoginType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactAttribute = CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL|CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL|CONTACT_ATTRIBUTE_CAPABLE_MY_HOME|CONTACT_ATTRIBUTE_CAPABLE_BUDDY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactAttribute where
  fromEnum t = case t of
    CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL -> 1
    CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL -> 2
    CONTACT_ATTRIBUTE_CAPABLE_MY_HOME -> 16
    CONTACT_ATTRIBUTE_CAPABLE_BUDDY -> 32
  toEnum t = case t of
    1 -> CONTACT_ATTRIBUTE_CAPABLE_VOICE_CALL
    2 -> CONTACT_ATTRIBUTE_CAPABLE_VIDEO_CALL
    16 -> CONTACT_ATTRIBUTE_CAPABLE_MY_HOME
    32 -> CONTACT_ATTRIBUTE_CAPABLE_BUDDY
    _ -> X.throw T.ThriftException
instance H.Hashable ContactAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactCategory = NORMAL|RECOMMEND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactCategory where
  fromEnum t = case t of
    NORMAL -> 0
    RECOMMEND -> 1
  toEnum t = case t of
    0 -> NORMAL
    1 -> RECOMMEND
    _ -> X.throw T.ThriftException
instance H.Hashable ContactCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactRelation = ONEWAY|BOTH|NOT_REGISTERED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactRelation where
  fromEnum t = case t of
    ONEWAY -> 0
    BOTH -> 1
    NOT_REGISTERED -> 2
  toEnum t = case t of
    0 -> ONEWAY
    1 -> BOTH
    2 -> NOT_REGISTERED
    _ -> X.throw T.ThriftException
instance H.Hashable ContactRelation where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactRelation where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data AsymmetricKeyAlgorithm = ASYMMETRIC_KEY_ALGORITHM_RSA|ASYMMETRIC_KEY_ALGORITHM_ECDH  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum AsymmetricKeyAlgorithm where
  fromEnum t = case t of
    ASYMMETRIC_KEY_ALGORITHM_RSA -> 1
    ASYMMETRIC_KEY_ALGORITHM_ECDH -> 2
  toEnum t = case t of
    1 -> ASYMMETRIC_KEY_ALGORITHM_RSA
    2 -> ASYMMETRIC_KEY_ALGORITHM_ECDH
    _ -> X.throw T.ThriftException
instance H.Hashable AsymmetricKeyAlgorithm where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary AsymmetricKeyAlgorithm where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactSetting = CONTACT_SETTING_NOTIFICATION_DISABLE|CONTACT_SETTING_DISPLAY_NAME_OVERRIDE|CONTACT_SETTING_CONTACT_HIDE|CONTACT_SETTING_FAVORITE|CONTACT_SETTING_DELETE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactSetting where
  fromEnum t = case t of
    CONTACT_SETTING_NOTIFICATION_DISABLE -> 1
    CONTACT_SETTING_DISPLAY_NAME_OVERRIDE -> 2
    CONTACT_SETTING_CONTACT_HIDE -> 4
    CONTACT_SETTING_FAVORITE -> 8
    CONTACT_SETTING_DELETE -> 16
  toEnum t = case t of
    1 -> CONTACT_SETTING_NOTIFICATION_DISABLE
    2 -> CONTACT_SETTING_DISPLAY_NAME_OVERRIDE
    4 -> CONTACT_SETTING_CONTACT_HIDE
    8 -> CONTACT_SETTING_FAVORITE
    16 -> CONTACT_SETTING_DELETE
    _ -> X.throw T.ThriftException
instance H.Hashable ContactSetting where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactSetting where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactStatus = UNSPECIFIED|FRIEND|FRIEND_BLOCKED|RECOMMEND|RECOMMEND_BLOCKED|DELETED|DELETED_BLOCKED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactStatus where
  fromEnum t = case t of
    UNSPECIFIED -> 0
    FRIEND -> 1
    FRIEND_BLOCKED -> 2
    RECOMMEND -> 3
    RECOMMEND_BLOCKED -> 4
    DELETED -> 5
    DELETED_BLOCKED -> 6
  toEnum t = case t of
    0 -> UNSPECIFIED
    1 -> FRIEND
    2 -> FRIEND_BLOCKED
    3 -> RECOMMEND
    4 -> RECOMMEND_BLOCKED
    5 -> DELETED
    6 -> DELETED_BLOCKED
    _ -> X.throw T.ThriftException
instance H.Hashable ContactStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactType = MID|PHONE|EMAIL|USERID|PROXIMITY|GROUP|USER|QRCODE|PROMOTION_BOT|CONTACT_MESSAGE|FRIEND_REQUEST|REPAIR|FACEBOOK|SINA|RENREN|FEIXIN|BBM|BEACON  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactType where
  fromEnum t = case t of
    MID -> 0
    PHONE -> 1
    EMAIL -> 2
    USERID -> 3
    PROXIMITY -> 4
    GROUP -> 5
    USER -> 6
    QRCODE -> 7
    PROMOTION_BOT -> 8
    CONTACT_MESSAGE -> 9
    FRIEND_REQUEST -> 10
    REPAIR -> 128
    FACEBOOK -> 2305
    SINA -> 2306
    RENREN -> 2307
    FEIXIN -> 2308
    BBM -> 2309
    BEACON -> 11
  toEnum t = case t of
    0 -> MID
    1 -> PHONE
    2 -> EMAIL
    3 -> USERID
    4 -> PROXIMITY
    5 -> GROUP
    6 -> USER
    7 -> QRCODE
    8 -> PROMOTION_BOT
    9 -> CONTACT_MESSAGE
    10 -> FRIEND_REQUEST
    128 -> REPAIR
    2305 -> FACEBOOK
    2306 -> SINA
    2307 -> RENREN
    2308 -> FEIXIN
    2309 -> BBM
    11 -> BEACON
    _ -> X.throw T.ThriftException
instance H.Hashable ContactType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data GroupPreferenceAttribute = INVITATION_TICKET|FAVORITE_TIMESTAMP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum GroupPreferenceAttribute where
  fromEnum t = case t of
    INVITATION_TICKET -> 1
    FAVORITE_TIMESTAMP -> 2
  toEnum t = case t of
    1 -> INVITATION_TICKET
    2 -> FAVORITE_TIMESTAMP
    _ -> X.throw T.ThriftException
instance H.Hashable GroupPreferenceAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary GroupPreferenceAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContentType = NONE|IMAGE|VIDEO|AUDIO|HTML|PDF|CALL|STICKER|PRESENCE|GIFT|GROUPBOARD|APPLINK|LINK|CONTACT|FILE|LOCATION|POSTNOTIFICATION|RICH|CHATEVENT|MUSIC|PAYMENT|EXTIMAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContentType where
  fromEnum t = case t of
    NONE -> 0
    IMAGE -> 1
    VIDEO -> 2
    AUDIO -> 3
    HTML -> 4
    PDF -> 5
    CALL -> 6
    STICKER -> 7
    PRESENCE -> 8
    GIFT -> 9
    GROUPBOARD -> 10
    APPLINK -> 11
    LINK -> 12
    CONTACT -> 13
    FILE -> 14
    LOCATION -> 15
    POSTNOTIFICATION -> 16
    RICH -> 17
    CHATEVENT -> 18
    MUSIC -> 19
    PAYMENT -> 20
    EXTIMAGE -> 21
  toEnum t = case t of
    0 -> NONE
    1 -> IMAGE
    2 -> VIDEO
    3 -> AUDIO
    4 -> HTML
    5 -> PDF
    6 -> CALL
    7 -> STICKER
    8 -> PRESENCE
    9 -> GIFT
    10 -> GROUPBOARD
    11 -> APPLINK
    12 -> LINK
    13 -> CONTACT
    14 -> FILE
    15 -> LOCATION
    16 -> POSTNOTIFICATION
    17 -> RICH
    18 -> CHATEVENT
    19 -> MUSIC
    20 -> PAYMENT
    21 -> EXTIMAGE
    _ -> X.throw T.ThriftException
instance H.Hashable ContentType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContentType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MessageRelationType = FORWARD|AUTO_REPLY|SUBORDINATE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MessageRelationType where
  fromEnum t = case t of
    FORWARD -> 0
    AUTO_REPLY -> 1
    SUBORDINATE -> 2
  toEnum t = case t of
    0 -> FORWARD
    1 -> AUTO_REPLY
    2 -> SUBORDINATE
    _ -> X.throw T.ThriftException
instance H.Hashable MessageRelationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MessageRelationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CustomMode = PROMOTION_FRIENDS_INVITE|CAPABILITY_SERVER_SIDE_SMS|LINE_CLIENT_ANALYTICS_CONFIGURATION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CustomMode where
  fromEnum t = case t of
    PROMOTION_FRIENDS_INVITE -> 1
    CAPABILITY_SERVER_SIDE_SMS -> 2
    LINE_CLIENT_ANALYTICS_CONFIGURATION -> 3
  toEnum t = case t of
    1 -> PROMOTION_FRIENDS_INVITE
    2 -> CAPABILITY_SERVER_SIDE_SMS
    3 -> LINE_CLIENT_ANALYTICS_CONFIGURATION
    _ -> X.throw T.ThriftException
instance H.Hashable CustomMode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CustomMode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RoomAttribute = ALL|NOTIFICATION_SETTING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RoomAttribute where
  fromEnum t = case t of
    ALL -> 255
    NOTIFICATION_SETTING -> 1
  toEnum t = case t of
    255 -> ALL
    1 -> NOTIFICATION_SETTING
    _ -> X.throw T.ThriftException
instance H.Hashable RoomAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RoomAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UserStatus = NORMAL|UNBOUND|UNREGISTERED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UserStatus where
  fromEnum t = case t of
    NORMAL -> 0
    UNBOUND -> 1
    UNREGISTERED -> 2
  toEnum t = case t of
    0 -> NORMAL
    1 -> UNBOUND
    2 -> UNREGISTERED
    _ -> X.throw T.ThriftException
instance H.Hashable UserStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UserStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data EmailConfirmationStatus = NOT_SPECIFIED|NOT_YET|DONE|NEED_ENFORCED_INPUT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum EmailConfirmationStatus where
  fromEnum t = case t of
    NOT_SPECIFIED -> 0
    NOT_YET -> 1
    DONE -> 3
    NEED_ENFORCED_INPUT -> 4
  toEnum t = case t of
    0 -> NOT_SPECIFIED
    1 -> NOT_YET
    3 -> DONE
    4 -> NEED_ENFORCED_INPUT
    _ -> X.throw T.ThriftException
instance H.Hashable EmailConfirmationStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary EmailConfirmationStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data AccountMigrationPincodeType = NOT_APPLICABLE|NOT_SET|SET|NEED_ENFORCED_INPUT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum AccountMigrationPincodeType where
  fromEnum t = case t of
    NOT_APPLICABLE -> 0
    NOT_SET -> 1
    SET -> 2
    NEED_ENFORCED_INPUT -> 3
  toEnum t = case t of
    0 -> NOT_APPLICABLE
    1 -> NOT_SET
    2 -> SET
    3 -> NEED_ENFORCED_INPUT
    _ -> X.throw T.ThriftException
instance H.Hashable AccountMigrationPincodeType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary AccountMigrationPincodeType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data AccountMigrationCheckType = SKIP|PINCODE|SECURITY_CENTER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum AccountMigrationCheckType where
  fromEnum t = case t of
    SKIP -> 0
    PINCODE -> 1
    SECURITY_CENTER -> 2
  toEnum t = case t of
    0 -> SKIP
    1 -> PINCODE
    2 -> SECURITY_CENTER
    _ -> X.throw T.ThriftException
instance H.Hashable AccountMigrationCheckType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary AccountMigrationCheckType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SecurityCenterSettingsType = NOT_APPLICABLE|NOT_SET|SET|NEED_ENFORCED_INPUT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SecurityCenterSettingsType where
  fromEnum t = case t of
    NOT_APPLICABLE -> 0
    NOT_SET -> 1
    SET -> 2
    NEED_ENFORCED_INPUT -> 3
  toEnum t = case t of
    0 -> NOT_APPLICABLE
    1 -> NOT_SET
    2 -> SET
    3 -> NEED_ENFORCED_INPUT
    _ -> X.throw T.ThriftException
instance H.Hashable SecurityCenterSettingsType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SecurityCenterSettingsType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data EmailConfirmationType = SERVER_SIDE_EMAIL|CLIENT_SIDE_EMAIL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum EmailConfirmationType where
  fromEnum t = case t of
    SERVER_SIDE_EMAIL -> 0
    CLIENT_SIDE_EMAIL -> 1
  toEnum t = case t of
    0 -> SERVER_SIDE_EMAIL
    1 -> CLIENT_SIDE_EMAIL
    _ -> X.throw T.ThriftException
instance H.Hashable EmailConfirmationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary EmailConfirmationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatAnnouncementType = TEXT_MESSAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatAnnouncementType where
  fromEnum t = case t of
    TEXT_MESSAGE -> 0
  toEnum t = case t of
    0 -> TEXT_MESSAGE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatAnnouncementType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatAnnouncementType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatAttribute = NAME|SQUARE_CHAT_IMAGE|STATE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatAttribute where
  fromEnum t = case t of
    NAME -> 2
    SQUARE_CHAT_IMAGE -> 3
    STATE -> 4
  toEnum t = case t of
    2 -> NAME
    3 -> SQUARE_CHAT_IMAGE
    4 -> STATE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareMemberAttribute = DISPLAY_NAME|PROFILE_IMAGE|ABLE_TO_RECEIVE_MESSAGE|MEMBERSHIP_STATE|ROLE|PREFERENCE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareMemberAttribute where
  fromEnum t = case t of
    DISPLAY_NAME -> 1
    PROFILE_IMAGE -> 2
    ABLE_TO_RECEIVE_MESSAGE -> 3
    MEMBERSHIP_STATE -> 5
    ROLE -> 6
    PREFERENCE -> 7
  toEnum t = case t of
    1 -> DISPLAY_NAME
    2 -> PROFILE_IMAGE
    3 -> ABLE_TO_RECEIVE_MESSAGE
    5 -> MEMBERSHIP_STATE
    6 -> ROLE
    7 -> PREFERENCE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareMemberAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareMemberAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareMemberRelationAttribute = BLOCKED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareMemberRelationAttribute where
  fromEnum t = case t of
    BLOCKED -> 1
  toEnum t = case t of
    1 -> BLOCKED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareMemberRelationAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareMemberRelationAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquarePreferenceAttribute = FAVORITE|NOTI_FOR_NEW_JOIN_REQUEST  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquarePreferenceAttribute where
  fromEnum t = case t of
    FAVORITE -> 1
    NOTI_FOR_NEW_JOIN_REQUEST -> 2
  toEnum t = case t of
    1 -> FAVORITE
    2 -> NOTI_FOR_NEW_JOIN_REQUEST
    _ -> X.throw T.ThriftException
instance H.Hashable SquarePreferenceAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquarePreferenceAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareState = ALIVE|DELETED|SUSPENDED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareState where
  fromEnum t = case t of
    ALIVE -> 0
    DELETED -> 1
    SUSPENDED -> 2
  toEnum t = case t of
    0 -> ALIVE
    1 -> DELETED
    2 -> SUSPENDED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data CommitMessageResultCode = DELIVERED|DELIVERY_SKIPPED|DELIVERY_RESTRICTED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum CommitMessageResultCode where
  fromEnum t = case t of
    DELIVERED -> 0
    DELIVERY_SKIPPED -> 1
    DELIVERY_RESTRICTED -> 2
  toEnum t = case t of
    0 -> DELIVERED
    1 -> DELIVERY_SKIPPED
    2 -> DELIVERY_RESTRICTED
    _ -> X.throw T.ThriftException
instance H.Hashable CommitMessageResultCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary CommitMessageResultCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ErrorCode = ILLEGAL_ARGUMENT|AUTHENTICATION_FAILED|DB_FAILED|INVALID_STATE|EXCESSIVE_ACCESS|NOT_FOUND|INVALID_MID|NOT_A_MEMBER|INVALID_LENGTH|NOT_AVAILABLE_USER|NOT_AUTHORIZED_DEVICE|NOT_AUTHORIZED_SESSION|INCOMPATIBLE_APP_VERSION|NOT_READY|NOT_AVAILABLE_SESSION|SYSTEM_ERROR|NO_AVAILABLE_VERIFICATION_METHOD|NOT_AUTHENTICATED|INVALID_IDENTITY_CREDENTIAL|NOT_AVAILABLE_IDENTITY_IDENTIFIER|INTERNAL_ERROR|NO_SUCH_IDENTITY_IDENFIER|DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY|ILLEGAL_IDENTITY_CREDENTIAL|UNKNOWN_CHANNEL|NO_SUCH_MESSAGE_BOX|NOT_AVAILABLE_MESSAGE_BOX|CHANNEL_DOES_NOT_MATCH|NOT_YOUR_MESSAGE|MESSAGE_DEFINED_ERROR|USER_CANNOT_ACCEPT_PRESENTS|USER_NOT_STICKER_OWNER|MAINTENANCE_ERROR|ACCOUNT_NOT_MATCHED|ABUSE_BLOCK|NOT_FRIEND|NOT_ALLOWED_CALL|BLOCK_FRIEND|INCOMPATIBLE_VOIP_VERSION|INVALID_SNS_ACCESS_TOKEN|EXTERNAL_SERVICE_NOT_AVAILABLE|NOT_ALLOWED_ADD_CONTACT|NOT_CERTIFICATED|NOT_ALLOWED_SECONDARY_DEVICE|INVALID_PIN_CODE|NOT_FOUND_IDENTITY_CREDENTIAL|EXCEED_FILE_MAX_SIZE|EXCEED_DAILY_QUOTA|NOT_SUPPORT_SEND_FILE|MUST_UPGRADE|NOT_AVAILABLE_PIN_CODE_SESSION|EXPIRED_REVISION|NOT_YET_PHONE_NUMBER|BAD_CALL_NUMBER|UNAVAILABLE_CALL_NUMBER|NOT_SUPPORT_CALL_SERVICE|CONGESTION_CONTROL|NO_BALANCE|NOT_PERMITTED_CALLER_ID|NO_CALLER_ID_LIMIT_EXCEEDED|CALLER_ID_VERIFICATION_REQUIRED|NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED|MESSAGE_NOT_FOUND|INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT|ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED|ACCOUNT_MIGRATION_PINCODE_BLOCKED|INVALID_PASSWORD_FORMAT|FEATURE_RESTRICTED|MESSAGE_NOT_DESTRUCTIBLE|PAID_CALL_REDEEM_FAILED|PREVENTED_JOIN_BY_TICKET|SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT|SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY|SECURITY_CENTER_NOT_VERIFIED|SECURITY_CENTER_BLOCKED_BY_SETTING|SECURITY_CENTER_BLOCKED|TALK_PROXY_EXCEPTION|E2EE_INVALID_PROTOCOL|E2EE_RETRY_ENCRYPT|E2EE_UPDATE_SENDER_KEY|E2EE_UPDATE_RECEIVER_KEY|E2EE_INVALID_ARGUMENT|E2EE_INVALID_VERSION|E2EE_SENDER_DISABLED|E2EE_RECEIVER_DISABLED|E2EE_SENDER_NOT_ALLOWED|E2EE_RECEIVER_NOT_ALLOWED|E2EE_RESEND_FAIL|E2EE_RESEND_OK|HITOKOTO_BACKUP_NO_AVAILABLE_DATA|E2EE_UPDATE_PRIMARY_DEVICE|SUCCESS|CANCEL|E2EE_PRIMARY_NOT_SUPPORT|E2EE_RETRY_PLAIN|E2EE_RECREATE_GROUP_KEY|E2EE_GROUP_TOO_MANY_MEMBERS|SERVER_BUSY|NOT_ALLOWED_ADD_FOLLOW|INCOMING_FRIEND_REQUEST_LIMIT|OUTGOING_FRIEND_REQUEST_LIMIT|OUTGOING_FRIEND_REQUEST_QUOTA|DUPLICATED|BANNED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ErrorCode where
  fromEnum t = case t of
    ILLEGAL_ARGUMENT -> 0
    AUTHENTICATION_FAILED -> 1
    DB_FAILED -> 2
    INVALID_STATE -> 3
    EXCESSIVE_ACCESS -> 4
    NOT_FOUND -> 5
    INVALID_MID -> 9
    NOT_A_MEMBER -> 10
    INVALID_LENGTH -> 6
    NOT_AVAILABLE_USER -> 7
    NOT_AUTHORIZED_DEVICE -> 8
    NOT_AUTHORIZED_SESSION -> 14
    INCOMPATIBLE_APP_VERSION -> 11
    NOT_READY -> 12
    NOT_AVAILABLE_SESSION -> 13
    SYSTEM_ERROR -> 15
    NO_AVAILABLE_VERIFICATION_METHOD -> 16
    NOT_AUTHENTICATED -> 17
    INVALID_IDENTITY_CREDENTIAL -> 18
    NOT_AVAILABLE_IDENTITY_IDENTIFIER -> 19
    INTERNAL_ERROR -> 20
    NO_SUCH_IDENTITY_IDENFIER -> 21
    DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY -> 22
    ILLEGAL_IDENTITY_CREDENTIAL -> 23
    UNKNOWN_CHANNEL -> 24
    NO_SUCH_MESSAGE_BOX -> 25
    NOT_AVAILABLE_MESSAGE_BOX -> 26
    CHANNEL_DOES_NOT_MATCH -> 27
    NOT_YOUR_MESSAGE -> 28
    MESSAGE_DEFINED_ERROR -> 29
    USER_CANNOT_ACCEPT_PRESENTS -> 30
    USER_NOT_STICKER_OWNER -> 32
    MAINTENANCE_ERROR -> 33
    ACCOUNT_NOT_MATCHED -> 34
    ABUSE_BLOCK -> 35
    NOT_FRIEND -> 36
    NOT_ALLOWED_CALL -> 37
    BLOCK_FRIEND -> 38
    INCOMPATIBLE_VOIP_VERSION -> 39
    INVALID_SNS_ACCESS_TOKEN -> 40
    EXTERNAL_SERVICE_NOT_AVAILABLE -> 41
    NOT_ALLOWED_ADD_CONTACT -> 42
    NOT_CERTIFICATED -> 43
    NOT_ALLOWED_SECONDARY_DEVICE -> 44
    INVALID_PIN_CODE -> 45
    NOT_FOUND_IDENTITY_CREDENTIAL -> 46
    EXCEED_FILE_MAX_SIZE -> 47
    EXCEED_DAILY_QUOTA -> 48
    NOT_SUPPORT_SEND_FILE -> 49
    MUST_UPGRADE -> 50
    NOT_AVAILABLE_PIN_CODE_SESSION -> 51
    EXPIRED_REVISION -> 52
    NOT_YET_PHONE_NUMBER -> 54
    BAD_CALL_NUMBER -> 55
    UNAVAILABLE_CALL_NUMBER -> 56
    NOT_SUPPORT_CALL_SERVICE -> 57
    CONGESTION_CONTROL -> 58
    NO_BALANCE -> 59
    NOT_PERMITTED_CALLER_ID -> 60
    NO_CALLER_ID_LIMIT_EXCEEDED -> 61
    CALLER_ID_VERIFICATION_REQUIRED -> 62
    NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED -> 63
    MESSAGE_NOT_FOUND -> 64
    INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT -> 65
    ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED -> 66
    ACCOUNT_MIGRATION_PINCODE_BLOCKED -> 67
    INVALID_PASSWORD_FORMAT -> 69
    FEATURE_RESTRICTED -> 70
    MESSAGE_NOT_DESTRUCTIBLE -> 71
    PAID_CALL_REDEEM_FAILED -> 72
    PREVENTED_JOIN_BY_TICKET -> 73
    SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT -> 75
    SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY -> 76
    SECURITY_CENTER_NOT_VERIFIED -> 77
    SECURITY_CENTER_BLOCKED_BY_SETTING -> 78
    SECURITY_CENTER_BLOCKED -> 79
    TALK_PROXY_EXCEPTION -> 80
    E2EE_INVALID_PROTOCOL -> 81
    E2EE_RETRY_ENCRYPT -> 82
    E2EE_UPDATE_SENDER_KEY -> 83
    E2EE_UPDATE_RECEIVER_KEY -> 84
    E2EE_INVALID_ARGUMENT -> 85
    E2EE_INVALID_VERSION -> 86
    E2EE_SENDER_DISABLED -> 87
    E2EE_RECEIVER_DISABLED -> 88
    E2EE_SENDER_NOT_ALLOWED -> 89
    E2EE_RECEIVER_NOT_ALLOWED -> 90
    E2EE_RESEND_FAIL -> 91
    E2EE_RESEND_OK -> 92
    HITOKOTO_BACKUP_NO_AVAILABLE_DATA -> 93
    E2EE_UPDATE_PRIMARY_DEVICE -> 94
    SUCCESS -> 95
    CANCEL -> 96
    E2EE_PRIMARY_NOT_SUPPORT -> 97
    E2EE_RETRY_PLAIN -> 98
    E2EE_RECREATE_GROUP_KEY -> 99
    E2EE_GROUP_TOO_MANY_MEMBERS -> 100
    SERVER_BUSY -> 101
    NOT_ALLOWED_ADD_FOLLOW -> 102
    INCOMING_FRIEND_REQUEST_LIMIT -> 103
    OUTGOING_FRIEND_REQUEST_LIMIT -> 104
    OUTGOING_FRIEND_REQUEST_QUOTA -> 105
    DUPLICATED -> 106
    BANNED -> 107
  toEnum t = case t of
    0 -> ILLEGAL_ARGUMENT
    1 -> AUTHENTICATION_FAILED
    2 -> DB_FAILED
    3 -> INVALID_STATE
    4 -> EXCESSIVE_ACCESS
    5 -> NOT_FOUND
    9 -> INVALID_MID
    10 -> NOT_A_MEMBER
    6 -> INVALID_LENGTH
    7 -> NOT_AVAILABLE_USER
    8 -> NOT_AUTHORIZED_DEVICE
    14 -> NOT_AUTHORIZED_SESSION
    11 -> INCOMPATIBLE_APP_VERSION
    12 -> NOT_READY
    13 -> NOT_AVAILABLE_SESSION
    15 -> SYSTEM_ERROR
    16 -> NO_AVAILABLE_VERIFICATION_METHOD
    17 -> NOT_AUTHENTICATED
    18 -> INVALID_IDENTITY_CREDENTIAL
    19 -> NOT_AVAILABLE_IDENTITY_IDENTIFIER
    20 -> INTERNAL_ERROR
    21 -> NO_SUCH_IDENTITY_IDENFIER
    22 -> DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY
    23 -> ILLEGAL_IDENTITY_CREDENTIAL
    24 -> UNKNOWN_CHANNEL
    25 -> NO_SUCH_MESSAGE_BOX
    26 -> NOT_AVAILABLE_MESSAGE_BOX
    27 -> CHANNEL_DOES_NOT_MATCH
    28 -> NOT_YOUR_MESSAGE
    29 -> MESSAGE_DEFINED_ERROR
    30 -> USER_CANNOT_ACCEPT_PRESENTS
    32 -> USER_NOT_STICKER_OWNER
    33 -> MAINTENANCE_ERROR
    34 -> ACCOUNT_NOT_MATCHED
    35 -> ABUSE_BLOCK
    36 -> NOT_FRIEND
    37 -> NOT_ALLOWED_CALL
    38 -> BLOCK_FRIEND
    39 -> INCOMPATIBLE_VOIP_VERSION
    40 -> INVALID_SNS_ACCESS_TOKEN
    41 -> EXTERNAL_SERVICE_NOT_AVAILABLE
    42 -> NOT_ALLOWED_ADD_CONTACT
    43 -> NOT_CERTIFICATED
    44 -> NOT_ALLOWED_SECONDARY_DEVICE
    45 -> INVALID_PIN_CODE
    46 -> NOT_FOUND_IDENTITY_CREDENTIAL
    47 -> EXCEED_FILE_MAX_SIZE
    48 -> EXCEED_DAILY_QUOTA
    49 -> NOT_SUPPORT_SEND_FILE
    50 -> MUST_UPGRADE
    51 -> NOT_AVAILABLE_PIN_CODE_SESSION
    52 -> EXPIRED_REVISION
    54 -> NOT_YET_PHONE_NUMBER
    55 -> BAD_CALL_NUMBER
    56 -> UNAVAILABLE_CALL_NUMBER
    57 -> NOT_SUPPORT_CALL_SERVICE
    58 -> CONGESTION_CONTROL
    59 -> NO_BALANCE
    60 -> NOT_PERMITTED_CALLER_ID
    61 -> NO_CALLER_ID_LIMIT_EXCEEDED
    62 -> CALLER_ID_VERIFICATION_REQUIRED
    63 -> NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED
    64 -> MESSAGE_NOT_FOUND
    65 -> INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT
    66 -> ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED
    67 -> ACCOUNT_MIGRATION_PINCODE_BLOCKED
    69 -> INVALID_PASSWORD_FORMAT
    70 -> FEATURE_RESTRICTED
    71 -> MESSAGE_NOT_DESTRUCTIBLE
    72 -> PAID_CALL_REDEEM_FAILED
    73 -> PREVENTED_JOIN_BY_TICKET
    75 -> SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT
    76 -> SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY
    77 -> SECURITY_CENTER_NOT_VERIFIED
    78 -> SECURITY_CENTER_BLOCKED_BY_SETTING
    79 -> SECURITY_CENTER_BLOCKED
    80 -> TALK_PROXY_EXCEPTION
    81 -> E2EE_INVALID_PROTOCOL
    82 -> E2EE_RETRY_ENCRYPT
    83 -> E2EE_UPDATE_SENDER_KEY
    84 -> E2EE_UPDATE_RECEIVER_KEY
    85 -> E2EE_INVALID_ARGUMENT
    86 -> E2EE_INVALID_VERSION
    87 -> E2EE_SENDER_DISABLED
    88 -> E2EE_RECEIVER_DISABLED
    89 -> E2EE_SENDER_NOT_ALLOWED
    90 -> E2EE_RECEIVER_NOT_ALLOWED
    91 -> E2EE_RESEND_FAIL
    92 -> E2EE_RESEND_OK
    93 -> HITOKOTO_BACKUP_NO_AVAILABLE_DATA
    94 -> E2EE_UPDATE_PRIMARY_DEVICE
    95 -> SUCCESS
    96 -> CANCEL
    97 -> E2EE_PRIMARY_NOT_SUPPORT
    98 -> E2EE_RETRY_PLAIN
    99 -> E2EE_RECREATE_GROUP_KEY
    100 -> E2EE_GROUP_TOO_MANY_MEMBERS
    101 -> SERVER_BUSY
    102 -> NOT_ALLOWED_ADD_FOLLOW
    103 -> INCOMING_FRIEND_REQUEST_LIMIT
    104 -> OUTGOING_FRIEND_REQUEST_LIMIT
    105 -> OUTGOING_FRIEND_REQUEST_QUOTA
    106 -> DUPLICATED
    107 -> BANNED
    _ -> X.throw T.ThriftException
instance H.Hashable ErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FeatureType = OBS_VIDEO|OBS_GENERAL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FeatureType where
  fromEnum t = case t of
    OBS_VIDEO -> 1
    OBS_GENERAL -> 2
  toEnum t = case t of
    1 -> OBS_VIDEO
    2 -> OBS_GENERAL
    _ -> X.throw T.ThriftException
instance H.Hashable FeatureType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FeatureType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data GroupAttribute = NAME|PICTURE_STATUS|ALL|PREVENTED_JOIN_BY_TICKET|NOTIFICATION_SETTING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum GroupAttribute where
  fromEnum t = case t of
    NAME -> 1
    PICTURE_STATUS -> 2
    ALL -> 255
    PREVENTED_JOIN_BY_TICKET -> 4
    NOTIFICATION_SETTING -> 8
  toEnum t = case t of
    1 -> NAME
    2 -> PICTURE_STATUS
    255 -> ALL
    4 -> PREVENTED_JOIN_BY_TICKET
    8 -> NOTIFICATION_SETTING
    _ -> X.throw T.ThriftException
instance H.Hashable GroupAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary GroupAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data IdentityProvider = UNKNOWN|LINE|NAVER_KR|LINE_PHONE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum IdentityProvider where
  fromEnum t = case t of
    UNKNOWN -> 0
    LINE -> 1
    NAVER_KR -> 2
    LINE_PHONE -> 3
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> LINE
    2 -> NAVER_KR
    3 -> LINE_PHONE
    _ -> X.throw T.ThriftException
instance H.Hashable IdentityProvider where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary IdentityProvider where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data LoginResultType = SUCCESS|REQUIRE_QRCODE|REQUIRE_DEVICE_CONFIRM|REQUIRE_SMS_CONFIRM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum LoginResultType where
  fromEnum t = case t of
    SUCCESS -> 1
    REQUIRE_QRCODE -> 2
    REQUIRE_DEVICE_CONFIRM -> 3
    REQUIRE_SMS_CONFIRM -> 4
  toEnum t = case t of
    1 -> SUCCESS
    2 -> REQUIRE_QRCODE
    3 -> REQUIRE_DEVICE_CONFIRM
    4 -> REQUIRE_SMS_CONFIRM
    _ -> X.throw T.ThriftException
instance H.Hashable LoginResultType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary LoginResultType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MessageOperationType = SEND_MESSAGE|RECEIVE_MESSAGE|READ_MESSAGE|NOTIFIED_READ_MESSAGE|NOTIFIED_JOIN_CHAT|FAILED_SEND_MESSAGE|SEND_CONTENT|SEND_CONTENT_RECEIPT|SEND_CHAT_REMOVED|REMOVE_ALL_MESSAGES  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MessageOperationType where
  fromEnum t = case t of
    SEND_MESSAGE -> 1
    RECEIVE_MESSAGE -> 2
    READ_MESSAGE -> 3
    NOTIFIED_READ_MESSAGE -> 4
    NOTIFIED_JOIN_CHAT -> 5
    FAILED_SEND_MESSAGE -> 6
    SEND_CONTENT -> 7
    SEND_CONTENT_RECEIPT -> 8
    SEND_CHAT_REMOVED -> 9
    REMOVE_ALL_MESSAGES -> 10
  toEnum t = case t of
    1 -> SEND_MESSAGE
    2 -> RECEIVE_MESSAGE
    3 -> READ_MESSAGE
    4 -> NOTIFIED_READ_MESSAGE
    5 -> NOTIFIED_JOIN_CHAT
    6 -> FAILED_SEND_MESSAGE
    7 -> SEND_CONTENT
    8 -> SEND_CONTENT_RECEIPT
    9 -> SEND_CHAT_REMOVED
    10 -> REMOVE_ALL_MESSAGES
    _ -> X.throw T.ThriftException
instance H.Hashable MessageOperationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MessageOperationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MIDType = USER|ROOM|GROUP|SQUARE|SQUARE_CHAT|SQUARE_MEMBER|BOT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MIDType where
  fromEnum t = case t of
    USER -> 0
    ROOM -> 1
    GROUP -> 2
    SQUARE -> 3
    SQUARE_CHAT -> 4
    SQUARE_MEMBER -> 5
    BOT -> 6
  toEnum t = case t of
    0 -> USER
    1 -> ROOM
    2 -> GROUP
    3 -> SQUARE
    4 -> SQUARE_CHAT
    5 -> SQUARE_MEMBER
    6 -> BOT
    _ -> X.throw T.ThriftException
instance H.Hashable MIDType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MIDType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ServiceCode = UNKNOWN|TALK|SQUARE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ServiceCode where
  fromEnum t = case t of
    UNKNOWN -> 0
    TALK -> 1
    SQUARE -> 2
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> TALK
    2 -> SQUARE
    _ -> X.throw T.ThriftException
instance H.Hashable ServiceCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ServiceCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FriendRequestDirection = INCOMING|OUTGOING  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FriendRequestDirection where
  fromEnum t = case t of
    INCOMING -> 1
    OUTGOING -> 2
  toEnum t = case t of
    1 -> INCOMING
    2 -> OUTGOING
    _ -> X.throw T.ThriftException
instance H.Hashable FriendRequestDirection where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FriendRequestDirection where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FriendRequestMethod = TIMELINE|NEARBY|SQUARE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FriendRequestMethod where
  fromEnum t = case t of
    TIMELINE -> 1
    NEARBY -> 2
    SQUARE -> 3
  toEnum t = case t of
    1 -> TIMELINE
    2 -> NEARBY
    3 -> SQUARE
    _ -> X.throw T.ThriftException
instance H.Hashable FriendRequestMethod where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FriendRequestMethod where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FriendRequestStatus = NONE|AVAILABLE|ALREADY_REQUESTED|UNAVAILABLE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FriendRequestStatus where
  fromEnum t = case t of
    NONE -> 0
    AVAILABLE -> 1
    ALREADY_REQUESTED -> 2
    UNAVAILABLE -> 3
  toEnum t = case t of
    0 -> NONE
    1 -> AVAILABLE
    2 -> ALREADY_REQUESTED
    3 -> UNAVAILABLE
    _ -> X.throw T.ThriftException
instance H.Hashable FriendRequestStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FriendRequestStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ModificationType = ADD|REMOVE|MODIFY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ModificationType where
  fromEnum t = case t of
    ADD -> 0
    REMOVE -> 1
    MODIFY -> 2
  toEnum t = case t of
    0 -> ADD
    1 -> REMOVE
    2 -> MODIFY
    _ -> X.throw T.ThriftException
instance H.Hashable ModificationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ModificationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationItemFetchMode = ALL|APPEND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationItemFetchMode where
  fromEnum t = case t of
    ALL -> 0
    APPEND -> 1
  toEnum t = case t of
    0 -> ALL
    1 -> APPEND
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationItemFetchMode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationItemFetchMode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationQueueType = GLOBAL|MESSAGE|PRIMARY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationQueueType where
  fromEnum t = case t of
    GLOBAL -> 1
    MESSAGE -> 2
    PRIMARY -> 3
  toEnum t = case t of
    1 -> GLOBAL
    2 -> MESSAGE
    3 -> PRIMARY
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationQueueType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationQueueType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data GroupCallMediaType = AUDIO|VIDEO  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum GroupCallMediaType where
  fromEnum t = case t of
    AUDIO -> 1
    VIDEO -> 2
  toEnum t = case t of
    1 -> AUDIO
    2 -> VIDEO
    _ -> X.throw T.ThriftException
instance H.Hashable GroupCallMediaType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary GroupCallMediaType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PersonalInfo = EMAIL|PHONE|BIRTHDAY|RAW_BIRTHDAY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PersonalInfo where
  fromEnum t = case t of
    EMAIL -> 0
    PHONE -> 1
    BIRTHDAY -> 2
    RAW_BIRTHDAY -> 3
  toEnum t = case t of
    0 -> EMAIL
    1 -> PHONE
    2 -> BIRTHDAY
    3 -> RAW_BIRTHDAY
    _ -> X.throw T.ThriftException
instance H.Hashable PersonalInfo where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PersonalInfo where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationStatus = NOTIFICATION_ITEM_EXIST|TIMELINE_ITEM_EXIST|NOTE_GROUP_NEW_ITEM_EXIST|TIMELINE_BUDDYGROUP_CHANGED|NOTE_ONE_TO_ONE_NEW_ITEM_EXIST|ALBUM_ITEM_EXIST|TIMELINE_ITEM_DELETED|OTOGROUP_ITEM_EXIST|GROUPHOME_NEW_ITEM_EXIST|GROUPHOME_HIDDEN_ITEM_CHANGED|NOTIFICATION_ITEM_CHANGED|BEAD_ITEM_HIDE|BEAD_ITEM_SHOW  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationStatus where
  fromEnum t = case t of
    NOTIFICATION_ITEM_EXIST -> 1
    TIMELINE_ITEM_EXIST -> 2
    NOTE_GROUP_NEW_ITEM_EXIST -> 4
    TIMELINE_BUDDYGROUP_CHANGED -> 8
    NOTE_ONE_TO_ONE_NEW_ITEM_EXIST -> 16
    ALBUM_ITEM_EXIST -> 32
    TIMELINE_ITEM_DELETED -> 64
    OTOGROUP_ITEM_EXIST -> 128
    GROUPHOME_NEW_ITEM_EXIST -> 256
    GROUPHOME_HIDDEN_ITEM_CHANGED -> 512
    NOTIFICATION_ITEM_CHANGED -> 1024
    BEAD_ITEM_HIDE -> 2048
    BEAD_ITEM_SHOW -> 4096
  toEnum t = case t of
    1 -> NOTIFICATION_ITEM_EXIST
    2 -> TIMELINE_ITEM_EXIST
    4 -> NOTE_GROUP_NEW_ITEM_EXIST
    8 -> TIMELINE_BUDDYGROUP_CHANGED
    16 -> NOTE_ONE_TO_ONE_NEW_ITEM_EXIST
    32 -> ALBUM_ITEM_EXIST
    64 -> TIMELINE_ITEM_DELETED
    128 -> OTOGROUP_ITEM_EXIST
    256 -> GROUPHOME_NEW_ITEM_EXIST
    512 -> GROUPHOME_HIDDEN_ITEM_CHANGED
    1024 -> NOTIFICATION_ITEM_CHANGED
    2048 -> BEAD_ITEM_HIDE
    4096 -> BEAD_ITEM_SHOW
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NotificationType = APPLE_APNS|GOOGLE_C2DM|NHN_NNI|SKT_AOM|MS_MPNS|RIM_BIS|GOOGLE_GCM|NOKIA_NNAPI|TIZEN|LINE_BOT|LINE_WAP|APPLE_APNS_VOIP|MS_WNS|GOOGLE_FCM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NotificationType where
  fromEnum t = case t of
    APPLE_APNS -> 1
    GOOGLE_C2DM -> 2
    NHN_NNI -> 3
    SKT_AOM -> 4
    MS_MPNS -> 5
    RIM_BIS -> 6
    GOOGLE_GCM -> 7
    NOKIA_NNAPI -> 8
    TIZEN -> 9
    LINE_BOT -> 17
    LINE_WAP -> 18
    APPLE_APNS_VOIP -> 19
    MS_WNS -> 20
    GOOGLE_FCM -> 21
  toEnum t = case t of
    1 -> APPLE_APNS
    2 -> GOOGLE_C2DM
    3 -> NHN_NNI
    4 -> SKT_AOM
    5 -> MS_MPNS
    6 -> RIM_BIS
    7 -> GOOGLE_GCM
    8 -> NOKIA_NNAPI
    9 -> TIZEN
    17 -> LINE_BOT
    18 -> LINE_WAP
    19 -> APPLE_APNS_VOIP
    20 -> MS_WNS
    21 -> GOOGLE_FCM
    _ -> X.throw T.ThriftException
instance H.Hashable NotificationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NotificationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data OpStatus = NORMAL|ALERT_DISABLED|ALWAYS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum OpStatus where
  fromEnum t = case t of
    NORMAL -> 0
    ALERT_DISABLED -> 1
    ALWAYS -> 2
  toEnum t = case t of
    0 -> NORMAL
    1 -> ALERT_DISABLED
    2 -> ALWAYS
    _ -> X.throw T.ThriftException
instance H.Hashable OpStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary OpStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data OpType = END_OF_OPERATION|UPDATE_PROFILE|UPDATE_SETTINGS|NOTIFIED_UPDATE_PROFILE|REGISTER_USERID|ADD_CONTACT|NOTIFIED_ADD_CONTACT|BLOCK_CONTACT|UNBLOCK_CONTACT|NOTIFIED_RECOMMEND_CONTACT|CREATE_GROUP|UPDATE_GROUP|NOTIFIED_UPDATE_GROUP|INVITE_INTO_GROUP|NOTIFIED_INVITE_INTO_GROUP|CANCEL_INVITATION_GROUP|NOTIFIED_CANCEL_INVITATION_GROUP|LEAVE_GROUP|NOTIFIED_LEAVE_GROUP|ACCEPT_GROUP_INVITATION|NOTIFIED_ACCEPT_GROUP_INVITATION|REJECT_GROUP_INVITATION|NOTIFIED_REJECT_GROUP_INVITATION|KICKOUT_FROM_GROUP|NOTIFIED_KICKOUT_FROM_GROUP|CREATE_ROOM|INVITE_INTO_ROOM|NOTIFIED_INVITE_INTO_ROOM|LEAVE_ROOM|NOTIFIED_LEAVE_ROOM|SEND_MESSAGE|RECEIVE_MESSAGE|SEND_MESSAGE_RECEIPT|RECEIVE_MESSAGE_RECEIPT|SEND_CONTENT_RECEIPT|RECEIVE_ANNOUNCEMENT|NOTIFIED_UNREGISTER_USER|INVITE_VIA_EMAIL|NOTIFIED_REGISTER_USER|NOTIFIED_REQUEST_RECOVERY|SEND_CHAT_CHECKED|SEND_CHAT_REMOVED|NOTIFIED_FORCE_SYNC|SEND_CONTENT|SEND_MESSAGE_MYHOME|NOTIFIED_UPDATE_CONTENT_PREVIEW|REMOVE_ALL_MESSAGES|NOTIFIED_UPDATE_PURCHASES|DUMMY|UPDATE_CONTACT|NOTIFIED_RECEIVED_CALL|CANCEL_CALL|NOTIFIED_REDIRECT|NOTIFIED_CHANNEL_SYNC|FAILED_SEND_MESSAGE|NOTIFIED_READ_MESSAGE|FAILED_EMAIL_CONFIRMATION|NOTIFIED_CHAT_CONTENT|NOTIFIED_PUSH_NOTICENTER_ITEM|NOTIFIED_JOIN_CHAT|NOTIFIED_LEAVE_CHAT|NOTIFIED_TYPING|FRIEND_REQUEST_ACCEPTED|DESTROY_MESSAGE|NOTIFIED_DESTROY_MESSAGE|UPDATE_PUBLICKEYCHAIN|NOTIFIED_UPDATE_PUBLICKEYCHAIN|NOTIFIED_BLOCK_CONTACT|NOTIFIED_UNBLOCK_CONTACT|UPDATE_GROUPPREFERENCE|NOTIFIED_PAYMENT_EVENT|REGISTER_E2EE_PUBLICKEY|NOTIFIED_E2EE_KEY_EXCHANGE_REQ|NOTIFIED_E2EE_KEY_EXCHANGE_RESP|NOTIFIED_E2EE_MESSAGE_RESEND_REQ|NOTIFIED_E2EE_MESSAGE_RESEND_RESP|NOTIFIED_E2EE_KEY_UPDATE|NOTIFIED_BUDDY_UPDATE_PROFILE|NOTIFIED_UPDATE_LINEAT_TABS|UPDATE_ROOM|NOTIFIED_BEACON_DETECTED|UPDATE_EXTENDED_PROFILE|ADD_FOLLOW|NOTIFIED_ADD_FOLLOW|DELETE_FOLLOW|NOTIFIED_DELETE_FOLLOW|UPDATE_TIMELINE_SETTINGS|NOTIFIED_FRIEND_REQUEST|UPDATE_RINGBACK_TONE|NOTIFIED_POSTBACK|RECEIVE_READ_WATERMARK|NOTIFIED_MESSAGE_DELIVERED|NOTIFIED_UPDATE_CHAT_BAR|NOTIFIED_CHATAPP_INSTALLED|NOTIFIED_CHATAPP_UPDATED|NOTIFIED_CHATAPP_NEW_MARK|NOTIFIED_CHATAPP_DELETED|NOTIFIED_CHATAPP_SYNC|NOTIFIED_UPDATE_MESSAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum OpType where
  fromEnum t = case t of
    END_OF_OPERATION -> 0
    UPDATE_PROFILE -> 1
    UPDATE_SETTINGS -> 36
    NOTIFIED_UPDATE_PROFILE -> 2
    REGISTER_USERID -> 3
    ADD_CONTACT -> 4
    NOTIFIED_ADD_CONTACT -> 5
    BLOCK_CONTACT -> 6
    UNBLOCK_CONTACT -> 7
    NOTIFIED_RECOMMEND_CONTACT -> 8
    CREATE_GROUP -> 9
    UPDATE_GROUP -> 10
    NOTIFIED_UPDATE_GROUP -> 11
    INVITE_INTO_GROUP -> 12
    NOTIFIED_INVITE_INTO_GROUP -> 13
    CANCEL_INVITATION_GROUP -> 31
    NOTIFIED_CANCEL_INVITATION_GROUP -> 32
    LEAVE_GROUP -> 14
    NOTIFIED_LEAVE_GROUP -> 15
    ACCEPT_GROUP_INVITATION -> 16
    NOTIFIED_ACCEPT_GROUP_INVITATION -> 17
    REJECT_GROUP_INVITATION -> 34
    NOTIFIED_REJECT_GROUP_INVITATION -> 35
    KICKOUT_FROM_GROUP -> 18
    NOTIFIED_KICKOUT_FROM_GROUP -> 19
    CREATE_ROOM -> 20
    INVITE_INTO_ROOM -> 21
    NOTIFIED_INVITE_INTO_ROOM -> 22
    LEAVE_ROOM -> 23
    NOTIFIED_LEAVE_ROOM -> 24
    SEND_MESSAGE -> 25
    RECEIVE_MESSAGE -> 26
    SEND_MESSAGE_RECEIPT -> 27
    RECEIVE_MESSAGE_RECEIPT -> 28
    SEND_CONTENT_RECEIPT -> 29
    RECEIVE_ANNOUNCEMENT -> 30
    NOTIFIED_UNREGISTER_USER -> 33
    INVITE_VIA_EMAIL -> 38
    NOTIFIED_REGISTER_USER -> 37
    NOTIFIED_REQUEST_RECOVERY -> 39
    SEND_CHAT_CHECKED -> 40
    SEND_CHAT_REMOVED -> 41
    NOTIFIED_FORCE_SYNC -> 42
    SEND_CONTENT -> 43
    SEND_MESSAGE_MYHOME -> 44
    NOTIFIED_UPDATE_CONTENT_PREVIEW -> 45
    REMOVE_ALL_MESSAGES -> 46
    NOTIFIED_UPDATE_PURCHASES -> 47
    DUMMY -> 48
    UPDATE_CONTACT -> 49
    NOTIFIED_RECEIVED_CALL -> 50
    CANCEL_CALL -> 51
    NOTIFIED_REDIRECT -> 52
    NOTIFIED_CHANNEL_SYNC -> 53
    FAILED_SEND_MESSAGE -> 54
    NOTIFIED_READ_MESSAGE -> 55
    FAILED_EMAIL_CONFIRMATION -> 56
    NOTIFIED_CHAT_CONTENT -> 58
    NOTIFIED_PUSH_NOTICENTER_ITEM -> 59
    NOTIFIED_JOIN_CHAT -> 60
    NOTIFIED_LEAVE_CHAT -> 61
    NOTIFIED_TYPING -> 62
    FRIEND_REQUEST_ACCEPTED -> 63
    DESTROY_MESSAGE -> 64
    NOTIFIED_DESTROY_MESSAGE -> 65
    UPDATE_PUBLICKEYCHAIN -> 66
    NOTIFIED_UPDATE_PUBLICKEYCHAIN -> 67
    NOTIFIED_BLOCK_CONTACT -> 68
    NOTIFIED_UNBLOCK_CONTACT -> 69
    UPDATE_GROUPPREFERENCE -> 70
    NOTIFIED_PAYMENT_EVENT -> 71
    REGISTER_E2EE_PUBLICKEY -> 72
    NOTIFIED_E2EE_KEY_EXCHANGE_REQ -> 73
    NOTIFIED_E2EE_KEY_EXCHANGE_RESP -> 74
    NOTIFIED_E2EE_MESSAGE_RESEND_REQ -> 75
    NOTIFIED_E2EE_MESSAGE_RESEND_RESP -> 76
    NOTIFIED_E2EE_KEY_UPDATE -> 77
    NOTIFIED_BUDDY_UPDATE_PROFILE -> 78
    NOTIFIED_UPDATE_LINEAT_TABS -> 79
    UPDATE_ROOM -> 80
    NOTIFIED_BEACON_DETECTED -> 81
    UPDATE_EXTENDED_PROFILE -> 82
    ADD_FOLLOW -> 83
    NOTIFIED_ADD_FOLLOW -> 84
    DELETE_FOLLOW -> 85
    NOTIFIED_DELETE_FOLLOW -> 86
    UPDATE_TIMELINE_SETTINGS -> 87
    NOTIFIED_FRIEND_REQUEST -> 88
    UPDATE_RINGBACK_TONE -> 89
    NOTIFIED_POSTBACK -> 90
    RECEIVE_READ_WATERMARK -> 91
    NOTIFIED_MESSAGE_DELIVERED -> 92
    NOTIFIED_UPDATE_CHAT_BAR -> 93
    NOTIFIED_CHATAPP_INSTALLED -> 94
    NOTIFIED_CHATAPP_UPDATED -> 95
    NOTIFIED_CHATAPP_NEW_MARK -> 96
    NOTIFIED_CHATAPP_DELETED -> 97
    NOTIFIED_CHATAPP_SYNC -> 98
    NOTIFIED_UPDATE_MESSAGE -> 99
  toEnum t = case t of
    0 -> END_OF_OPERATION
    1 -> UPDATE_PROFILE
    36 -> UPDATE_SETTINGS
    2 -> NOTIFIED_UPDATE_PROFILE
    3 -> REGISTER_USERID
    4 -> ADD_CONTACT
    5 -> NOTIFIED_ADD_CONTACT
    6 -> BLOCK_CONTACT
    7 -> UNBLOCK_CONTACT
    8 -> NOTIFIED_RECOMMEND_CONTACT
    9 -> CREATE_GROUP
    10 -> UPDATE_GROUP
    11 -> NOTIFIED_UPDATE_GROUP
    12 -> INVITE_INTO_GROUP
    13 -> NOTIFIED_INVITE_INTO_GROUP
    31 -> CANCEL_INVITATION_GROUP
    32 -> NOTIFIED_CANCEL_INVITATION_GROUP
    14 -> LEAVE_GROUP
    15 -> NOTIFIED_LEAVE_GROUP
    16 -> ACCEPT_GROUP_INVITATION
    17 -> NOTIFIED_ACCEPT_GROUP_INVITATION
    34 -> REJECT_GROUP_INVITATION
    35 -> NOTIFIED_REJECT_GROUP_INVITATION
    18 -> KICKOUT_FROM_GROUP
    19 -> NOTIFIED_KICKOUT_FROM_GROUP
    20 -> CREATE_ROOM
    21 -> INVITE_INTO_ROOM
    22 -> NOTIFIED_INVITE_INTO_ROOM
    23 -> LEAVE_ROOM
    24 -> NOTIFIED_LEAVE_ROOM
    25 -> SEND_MESSAGE
    26 -> RECEIVE_MESSAGE
    27 -> SEND_MESSAGE_RECEIPT
    28 -> RECEIVE_MESSAGE_RECEIPT
    29 -> SEND_CONTENT_RECEIPT
    30 -> RECEIVE_ANNOUNCEMENT
    33 -> NOTIFIED_UNREGISTER_USER
    38 -> INVITE_VIA_EMAIL
    37 -> NOTIFIED_REGISTER_USER
    39 -> NOTIFIED_REQUEST_RECOVERY
    40 -> SEND_CHAT_CHECKED
    41 -> SEND_CHAT_REMOVED
    42 -> NOTIFIED_FORCE_SYNC
    43 -> SEND_CONTENT
    44 -> SEND_MESSAGE_MYHOME
    45 -> NOTIFIED_UPDATE_CONTENT_PREVIEW
    46 -> REMOVE_ALL_MESSAGES
    47 -> NOTIFIED_UPDATE_PURCHASES
    48 -> DUMMY
    49 -> UPDATE_CONTACT
    50 -> NOTIFIED_RECEIVED_CALL
    51 -> CANCEL_CALL
    52 -> NOTIFIED_REDIRECT
    53 -> NOTIFIED_CHANNEL_SYNC
    54 -> FAILED_SEND_MESSAGE
    55 -> NOTIFIED_READ_MESSAGE
    56 -> FAILED_EMAIL_CONFIRMATION
    58 -> NOTIFIED_CHAT_CONTENT
    59 -> NOTIFIED_PUSH_NOTICENTER_ITEM
    60 -> NOTIFIED_JOIN_CHAT
    61 -> NOTIFIED_LEAVE_CHAT
    62 -> NOTIFIED_TYPING
    63 -> FRIEND_REQUEST_ACCEPTED
    64 -> DESTROY_MESSAGE
    65 -> NOTIFIED_DESTROY_MESSAGE
    66 -> UPDATE_PUBLICKEYCHAIN
    67 -> NOTIFIED_UPDATE_PUBLICKEYCHAIN
    68 -> NOTIFIED_BLOCK_CONTACT
    69 -> NOTIFIED_UNBLOCK_CONTACT
    70 -> UPDATE_GROUPPREFERENCE
    71 -> NOTIFIED_PAYMENT_EVENT
    72 -> REGISTER_E2EE_PUBLICKEY
    73 -> NOTIFIED_E2EE_KEY_EXCHANGE_REQ
    74 -> NOTIFIED_E2EE_KEY_EXCHANGE_RESP
    75 -> NOTIFIED_E2EE_MESSAGE_RESEND_REQ
    76 -> NOTIFIED_E2EE_MESSAGE_RESEND_RESP
    77 -> NOTIFIED_E2EE_KEY_UPDATE
    78 -> NOTIFIED_BUDDY_UPDATE_PROFILE
    79 -> NOTIFIED_UPDATE_LINEAT_TABS
    80 -> UPDATE_ROOM
    81 -> NOTIFIED_BEACON_DETECTED
    82 -> UPDATE_EXTENDED_PROFILE
    83 -> ADD_FOLLOW
    84 -> NOTIFIED_ADD_FOLLOW
    85 -> DELETE_FOLLOW
    86 -> NOTIFIED_DELETE_FOLLOW
    87 -> UPDATE_TIMELINE_SETTINGS
    88 -> NOTIFIED_FRIEND_REQUEST
    89 -> UPDATE_RINGBACK_TONE
    90 -> NOTIFIED_POSTBACK
    91 -> RECEIVE_READ_WATERMARK
    92 -> NOTIFIED_MESSAGE_DELIVERED
    93 -> NOTIFIED_UPDATE_CHAT_BAR
    94 -> NOTIFIED_CHATAPP_INSTALLED
    95 -> NOTIFIED_CHATAPP_UPDATED
    96 -> NOTIFIED_CHATAPP_NEW_MARK
    97 -> NOTIFIED_CHATAPP_DELETED
    98 -> NOTIFIED_CHATAPP_SYNC
    99 -> NOTIFIED_UPDATE_MESSAGE
    _ -> X.throw T.ThriftException
instance H.Hashable OpType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary OpType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PayloadType = PAYLOAD_BUY|PAYLOAD_CS|PAYLOAD_BONUS|PAYLOAD_EVENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PayloadType where
  fromEnum t = case t of
    PAYLOAD_BUY -> 101
    PAYLOAD_CS -> 111
    PAYLOAD_BONUS -> 121
    PAYLOAD_EVENT -> 131
  toEnum t = case t of
    101 -> PAYLOAD_BUY
    111 -> PAYLOAD_CS
    121 -> PAYLOAD_BONUS
    131 -> PAYLOAD_EVENT
    _ -> X.throw T.ThriftException
instance H.Hashable PayloadType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PayloadType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaymentPgType = PAYMENT_PG_NONE|PAYMENT_PG_AU|PAYMENT_PG_AL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaymentPgType where
  fromEnum t = case t of
    PAYMENT_PG_NONE -> 0
    PAYMENT_PG_AU -> 1
    PAYMENT_PG_AL -> 2
  toEnum t = case t of
    0 -> PAYMENT_PG_NONE
    1 -> PAYMENT_PG_AU
    2 -> PAYMENT_PG_AL
    _ -> X.throw T.ThriftException
instance H.Hashable PaymentPgType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaymentPgType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PaymentType = PAYMENT_APPLE|PAYMENT_GOOGLE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PaymentType where
  fromEnum t = case t of
    PAYMENT_APPLE -> 1
    PAYMENT_GOOGLE -> 2
  toEnum t = case t of
    1 -> PAYMENT_APPLE
    2 -> PAYMENT_GOOGLE
    _ -> X.throw T.ThriftException
instance H.Hashable PaymentType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PaymentType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProductBannerLinkType = BANNER_LINK_NONE|BANNER_LINK_ITEM|BANNER_LINK_URL|BANNER_LINK_CATEGORY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProductBannerLinkType where
  fromEnum t = case t of
    BANNER_LINK_NONE -> 0
    BANNER_LINK_ITEM -> 1
    BANNER_LINK_URL -> 2
    BANNER_LINK_CATEGORY -> 3
  toEnum t = case t of
    0 -> BANNER_LINK_NONE
    1 -> BANNER_LINK_ITEM
    2 -> BANNER_LINK_URL
    3 -> BANNER_LINK_CATEGORY
    _ -> X.throw T.ThriftException
instance H.Hashable ProductBannerLinkType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProductBannerLinkType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProductEventType = NO_EVENT|CARRIER_ANY|BUDDY_ANY|INSTALL_IOS|INSTALL_ANDROID|MISSION_ANY|MUSTBUY_ANY  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProductEventType where
  fromEnum t = case t of
    NO_EVENT -> 0
    CARRIER_ANY -> 65537
    BUDDY_ANY -> 131073
    INSTALL_IOS -> 196609
    INSTALL_ANDROID -> 196610
    MISSION_ANY -> 262145
    MUSTBUY_ANY -> 327681
  toEnum t = case t of
    0 -> NO_EVENT
    65537 -> CARRIER_ANY
    131073 -> BUDDY_ANY
    196609 -> INSTALL_IOS
    196610 -> INSTALL_ANDROID
    262145 -> MISSION_ANY
    327681 -> MUSTBUY_ANY
    _ -> X.throw T.ThriftException
instance H.Hashable ProductEventType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProductEventType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data StickerResourceType = STATIC|ANIMATION|SOUND|ANIMATION_SOUND|POPUP|POPUP_SOUND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum StickerResourceType where
  fromEnum t = case t of
    STATIC -> 1
    ANIMATION -> 2
    SOUND -> 3
    ANIMATION_SOUND -> 4
    POPUP -> 5
    POPUP_SOUND -> 6
  toEnum t = case t of
    1 -> STATIC
    2 -> ANIMATION
    3 -> SOUND
    4 -> ANIMATION_SOUND
    5 -> POPUP
    6 -> POPUP_SOUND
    _ -> X.throw T.ThriftException
instance H.Hashable StickerResourceType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary StickerResourceType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PlaceSearchProvider = GOOGLE|BAIDU  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PlaceSearchProvider where
  fromEnum t = case t of
    GOOGLE -> 0
    BAIDU -> 1
  toEnum t = case t of
    0 -> GOOGLE
    1 -> BAIDU
    _ -> X.throw T.ThriftException
instance H.Hashable PlaceSearchProvider where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PlaceSearchProvider where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PointErrorCode = REQUEST_DUPLICATION|INVALID_PARAMETER|NOT_ENOUGH_BALANCE|AUTHENTICATION_FAIL|API_ACCESS_FORBIDDEN|MEMBER_ACCOUNT_NOT_FOUND|SERVICE_ACCOUNT_NOT_FOUND|TRANSACTION_NOT_FOUND|ALREADY_REVERSED_TRANSACTION|MESSAGE_NOT_READABLE|HTTP_REQUEST_METHOD_NOT_SUPPORTED|HTTP_MEDIA_TYPE_NOT_SUPPORTED|NOT_ALLOWED_TO_DEPOSIT|NOT_ALLOWED_TO_PAY|TRANSACTION_ACCESS_FORBIDDEN|INVALID_SERVICE_CONFIGURATION|DCS_COMMUNICATION_FAIL|UPDATE_BALANCE_FAIL|SYSTEM_ERROR|SYSTEM_MAINTENANCE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PointErrorCode where
  fromEnum t = case t of
    REQUEST_DUPLICATION -> 3001
    INVALID_PARAMETER -> 3002
    NOT_ENOUGH_BALANCE -> 3003
    AUTHENTICATION_FAIL -> 3004
    API_ACCESS_FORBIDDEN -> 3005
    MEMBER_ACCOUNT_NOT_FOUND -> 3006
    SERVICE_ACCOUNT_NOT_FOUND -> 3007
    TRANSACTION_NOT_FOUND -> 3008
    ALREADY_REVERSED_TRANSACTION -> 3009
    MESSAGE_NOT_READABLE -> 3010
    HTTP_REQUEST_METHOD_NOT_SUPPORTED -> 3011
    HTTP_MEDIA_TYPE_NOT_SUPPORTED -> 3012
    NOT_ALLOWED_TO_DEPOSIT -> 3013
    NOT_ALLOWED_TO_PAY -> 3014
    TRANSACTION_ACCESS_FORBIDDEN -> 3015
    INVALID_SERVICE_CONFIGURATION -> 4001
    DCS_COMMUNICATION_FAIL -> 5004
    UPDATE_BALANCE_FAIL -> 5007
    SYSTEM_ERROR -> 5999
    SYSTEM_MAINTENANCE -> 5888
  toEnum t = case t of
    3001 -> REQUEST_DUPLICATION
    3002 -> INVALID_PARAMETER
    3003 -> NOT_ENOUGH_BALANCE
    3004 -> AUTHENTICATION_FAIL
    3005 -> API_ACCESS_FORBIDDEN
    3006 -> MEMBER_ACCOUNT_NOT_FOUND
    3007 -> SERVICE_ACCOUNT_NOT_FOUND
    3008 -> TRANSACTION_NOT_FOUND
    3009 -> ALREADY_REVERSED_TRANSACTION
    3010 -> MESSAGE_NOT_READABLE
    3011 -> HTTP_REQUEST_METHOD_NOT_SUPPORTED
    3012 -> HTTP_MEDIA_TYPE_NOT_SUPPORTED
    3013 -> NOT_ALLOWED_TO_DEPOSIT
    3014 -> NOT_ALLOWED_TO_PAY
    3015 -> TRANSACTION_ACCESS_FORBIDDEN
    4001 -> INVALID_SERVICE_CONFIGURATION
    5004 -> DCS_COMMUNICATION_FAIL
    5007 -> UPDATE_BALANCE_FAIL
    5999 -> SYSTEM_ERROR
    5888 -> SYSTEM_MAINTENANCE
    _ -> X.throw T.ThriftException
instance H.Hashable PointErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PointErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ProfileAttribute = ALL|EMAIL|DISPLAY_NAME|PHONETIC_NAME|PICTURE|STATUS_MESSAGE|ALLOW_SEARCH_BY_USERID|ALLOW_SEARCH_BY_EMAIL|BUDDY_STATUS|MUSIC_PROFILE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ProfileAttribute where
  fromEnum t = case t of
    ALL -> 511
    EMAIL -> 1
    DISPLAY_NAME -> 2
    PHONETIC_NAME -> 4
    PICTURE -> 8
    STATUS_MESSAGE -> 16
    ALLOW_SEARCH_BY_USERID -> 32
    ALLOW_SEARCH_BY_EMAIL -> 64
    BUDDY_STATUS -> 128
    MUSIC_PROFILE -> 256
  toEnum t = case t of
    511 -> ALL
    1 -> EMAIL
    2 -> DISPLAY_NAME
    4 -> PHONETIC_NAME
    8 -> PICTURE
    16 -> STATUS_MESSAGE
    32 -> ALLOW_SEARCH_BY_USERID
    64 -> ALLOW_SEARCH_BY_EMAIL
    128 -> BUDDY_STATUS
    256 -> MUSIC_PROFILE
    _ -> X.throw T.ThriftException
instance H.Hashable ProfileAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ProfileAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PublicType = HIDDEN|PUBLIC  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PublicType where
  fromEnum t = case t of
    HIDDEN -> 0
    PUBLIC -> 1000
  toEnum t = case t of
    0 -> HIDDEN
    1000 -> PUBLIC
    _ -> X.throw T.ThriftException
instance H.Hashable PublicType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PublicType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RedirectType = NONE|EXPIRE_SECOND  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RedirectType where
  fromEnum t = case t of
    NONE -> 0
    EXPIRE_SECOND -> 1
  toEnum t = case t of
    0 -> NONE
    1 -> EXPIRE_SECOND
    _ -> X.throw T.ThriftException
instance H.Hashable RedirectType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RedirectType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RegistrationType = PHONE|EMAIL_WAP|FACEBOOK|SINA|RENREN|FEIXIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RegistrationType where
  fromEnum t = case t of
    PHONE -> 0
    EMAIL_WAP -> 1
    FACEBOOK -> 2305
    SINA -> 2306
    RENREN -> 2307
    FEIXIN -> 2308
  toEnum t = case t of
    0 -> PHONE
    1 -> EMAIL_WAP
    2305 -> FACEBOOK
    2306 -> SINA
    2307 -> RENREN
    2308 -> FEIXIN
    _ -> X.throw T.ThriftException
instance H.Hashable RegistrationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RegistrationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ChatRoomAnnouncementType = MESSAGE|NOTE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ChatRoomAnnouncementType where
  fromEnum t = case t of
    MESSAGE -> 0
    NOTE -> 1
  toEnum t = case t of
    0 -> MESSAGE
    1 -> NOTE
    _ -> X.throw T.ThriftException
instance H.Hashable ChatRoomAnnouncementType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ChatRoomAnnouncementType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SettingsAttribute = ALL|NOTIFICATION_ENABLE|NOTIFICATION_MUTE_EXPIRATION|NOTIFICATION_NEW_MESSAGE|NOTIFICATION_GROUP_INVITATION|NOTIFICATION_SHOW_MESSAGE|NOTIFICATION_INCOMING_CALL|NOTIFICATION_SOUND_MESSAGE|NOTIFICATION_SOUND_GROUP|NOTIFICATION_DISABLED_WITH_SUB|NOTIFICATION_PAYMENT|PRIVACY_SYNC_CONTACTS|PRIVACY_SEARCH_BY_PHONE_NUMBER|PRIVACY_SEARCH_BY_USERID|PRIVACY_SEARCH_BY_EMAIL|PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN|PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME|PRIVACY_ALLOW_FRIEND_REQUEST|PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND|PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL|PRIVACY_AGREE_USE_PAIDCALL|CONTACT_MY_TICKET|IDENTITY_PROVIDER|IDENTITY_IDENTIFIER|SNS_ACCOUNT|PHONE_REGISTRATION|PREFERENCE_LOCALE|CUSTOM_MODE|EMAIL_CONFIRMATION_STATUS|ACCOUNT_MIGRATION_PINCODE|ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE|SECURITY_CENTER_SETTINGS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SettingsAttribute where
  fromEnum t = case t of
    ALL -> 2147483647
    NOTIFICATION_ENABLE -> 1
    NOTIFICATION_MUTE_EXPIRATION -> 2
    NOTIFICATION_NEW_MESSAGE -> 4
    NOTIFICATION_GROUP_INVITATION -> 8
    NOTIFICATION_SHOW_MESSAGE -> 16
    NOTIFICATION_INCOMING_CALL -> 32
    NOTIFICATION_SOUND_MESSAGE -> 256
    NOTIFICATION_SOUND_GROUP -> 512
    NOTIFICATION_DISABLED_WITH_SUB -> 65536
    NOTIFICATION_PAYMENT -> 131072
    PRIVACY_SYNC_CONTACTS -> 64
    PRIVACY_SEARCH_BY_PHONE_NUMBER -> 128
    PRIVACY_SEARCH_BY_USERID -> 8192
    PRIVACY_SEARCH_BY_EMAIL -> 16384
    PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN -> 2097152
    PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME -> 8388608
    PRIVACY_ALLOW_FRIEND_REQUEST -> 1073741824
    PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND -> 33554432
    PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL -> 67108864
    PRIVACY_AGREE_USE_PAIDCALL -> 134217728
    CONTACT_MY_TICKET -> 1024
    IDENTITY_PROVIDER -> 2048
    IDENTITY_IDENTIFIER -> 4096
    SNS_ACCOUNT -> 524288
    PHONE_REGISTRATION -> 1048576
    PREFERENCE_LOCALE -> 32768
    CUSTOM_MODE -> 4194304
    EMAIL_CONFIRMATION_STATUS -> 16777216
    ACCOUNT_MIGRATION_PINCODE -> 268435456
    ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE -> 536870912
    SECURITY_CENTER_SETTINGS -> 262144
  toEnum t = case t of
    2147483647 -> ALL
    1 -> NOTIFICATION_ENABLE
    2 -> NOTIFICATION_MUTE_EXPIRATION
    4 -> NOTIFICATION_NEW_MESSAGE
    8 -> NOTIFICATION_GROUP_INVITATION
    16 -> NOTIFICATION_SHOW_MESSAGE
    32 -> NOTIFICATION_INCOMING_CALL
    256 -> NOTIFICATION_SOUND_MESSAGE
    512 -> NOTIFICATION_SOUND_GROUP
    65536 -> NOTIFICATION_DISABLED_WITH_SUB
    131072 -> NOTIFICATION_PAYMENT
    64 -> PRIVACY_SYNC_CONTACTS
    128 -> PRIVACY_SEARCH_BY_PHONE_NUMBER
    8192 -> PRIVACY_SEARCH_BY_USERID
    16384 -> PRIVACY_SEARCH_BY_EMAIL
    2097152 -> PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN
    8388608 -> PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME
    1073741824 -> PRIVACY_ALLOW_FRIEND_REQUEST
    33554432 -> PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND
    67108864 -> PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL
    134217728 -> PRIVACY_AGREE_USE_PAIDCALL
    1024 -> CONTACT_MY_TICKET
    2048 -> IDENTITY_PROVIDER
    4096 -> IDENTITY_IDENTIFIER
    524288 -> SNS_ACCOUNT
    1048576 -> PHONE_REGISTRATION
    32768 -> PREFERENCE_LOCALE
    4194304 -> CUSTOM_MODE
    16777216 -> EMAIL_CONFIRMATION_STATUS
    268435456 -> ACCOUNT_MIGRATION_PINCODE
    536870912 -> ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE
    262144 -> SECURITY_CENTER_SETTINGS
    _ -> X.throw T.ThriftException
instance H.Hashable SettingsAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SettingsAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SettingsAttributeEx = NOTIFICATION_ENABLE|NOTIFICATION_MUTE_EXPIRATION|NOTIFICATION_NEW_MESSAGE|NOTIFICATION_GROUP_INVITATION|NOTIFICATION_SHOW_MESSAGE|NOTIFICATION_INCOMING_CALL|NOTIFICATION_SOUND_MESSAGE|NOTIFICATION_SOUND_GROUP|NOTIFICATION_DISABLED_WITH_SUB|NOTIFICATION_PAYMENT|NOTIFICATION_MENTION|NOTIFICATION_THUMBNAIL|PRIVACY_SYNC_CONTACTS|PRIVACY_SEARCH_BY_PHONE_NUMBER|PRIVACY_SEARCH_BY_USERID|PRIVACY_SEARCH_BY_EMAIL|PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN|PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME|PRIVACY_PROFILE_MUSIC_POST_TO_MYHOME|PRIVACY_ALLOW_FRIEND_REQUEST|PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND|PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL|PRIVACY_AGREE_USE_PAIDCALL|CONTACT_MY_TICKET|IDENTITY_PROVIDER|IDENTITY_IDENTIFIER|SNS_ACCOUNT|PHONE_REGISTRATION|PREFERENCE_LOCALE|CUSTOM_MODE|EMAIL_CONFIRMATION_STATUS|ACCOUNT_MIGRATION_PINCODE|ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE|SECURITY_CENTER_SETTINGS|E2EE_ENABLE|ENABLE_SOUND_TO_TEXT|HITOKOTO_BACKUP_REQUESTED|CONTACT_ALLOW_FOLLOWING|PRIVACY_ALLOW_NEARBY|AGREEMENT_NEARBY|AGREEMENT_SQUARE|ALLOW_UNREGISTRATION_SECONDARY_DEVICE|AGREEMENT_BOT_USE|AGREEMENT_SHAKE_FUNCTION|AGREEMENT_MOBILE_CONTACT_NAME|AGREEMENT_SOUND_TO_TEXT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SettingsAttributeEx where
  fromEnum t = case t of
    NOTIFICATION_ENABLE -> 0
    NOTIFICATION_MUTE_EXPIRATION -> 1
    NOTIFICATION_NEW_MESSAGE -> 2
    NOTIFICATION_GROUP_INVITATION -> 3
    NOTIFICATION_SHOW_MESSAGE -> 4
    NOTIFICATION_INCOMING_CALL -> 5
    NOTIFICATION_SOUND_MESSAGE -> 8
    NOTIFICATION_SOUND_GROUP -> 9
    NOTIFICATION_DISABLED_WITH_SUB -> 16
    NOTIFICATION_PAYMENT -> 17
    NOTIFICATION_MENTION -> 40
    NOTIFICATION_THUMBNAIL -> 45
    PRIVACY_SYNC_CONTACTS -> 6
    PRIVACY_SEARCH_BY_PHONE_NUMBER -> 7
    PRIVACY_SEARCH_BY_USERID -> 13
    PRIVACY_SEARCH_BY_EMAIL -> 14
    PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN -> 21
    PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME -> 23
    PRIVACY_PROFILE_MUSIC_POST_TO_MYHOME -> 35
    PRIVACY_ALLOW_FRIEND_REQUEST -> 30
    PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND -> 25
    PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL -> 26
    PRIVACY_AGREE_USE_PAIDCALL -> 27
    CONTACT_MY_TICKET -> 10
    IDENTITY_PROVIDER -> 11
    IDENTITY_IDENTIFIER -> 12
    SNS_ACCOUNT -> 19
    PHONE_REGISTRATION -> 20
    PREFERENCE_LOCALE -> 15
    CUSTOM_MODE -> 22
    EMAIL_CONFIRMATION_STATUS -> 24
    ACCOUNT_MIGRATION_PINCODE -> 28
    ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE -> 29
    SECURITY_CENTER_SETTINGS -> 18
    E2EE_ENABLE -> 33
    ENABLE_SOUND_TO_TEXT -> 47
    HITOKOTO_BACKUP_REQUESTED -> 34
    CONTACT_ALLOW_FOLLOWING -> 36
    PRIVACY_ALLOW_NEARBY -> 37
    AGREEMENT_NEARBY -> 38
    AGREEMENT_SQUARE -> 39
    ALLOW_UNREGISTRATION_SECONDARY_DEVICE -> 41
    AGREEMENT_BOT_USE -> 42
    AGREEMENT_SHAKE_FUNCTION -> 43
    AGREEMENT_MOBILE_CONTACT_NAME -> 44
    AGREEMENT_SOUND_TO_TEXT -> 46
  toEnum t = case t of
    0 -> NOTIFICATION_ENABLE
    1 -> NOTIFICATION_MUTE_EXPIRATION
    2 -> NOTIFICATION_NEW_MESSAGE
    3 -> NOTIFICATION_GROUP_INVITATION
    4 -> NOTIFICATION_SHOW_MESSAGE
    5 -> NOTIFICATION_INCOMING_CALL
    8 -> NOTIFICATION_SOUND_MESSAGE
    9 -> NOTIFICATION_SOUND_GROUP
    16 -> NOTIFICATION_DISABLED_WITH_SUB
    17 -> NOTIFICATION_PAYMENT
    40 -> NOTIFICATION_MENTION
    45 -> NOTIFICATION_THUMBNAIL
    6 -> PRIVACY_SYNC_CONTACTS
    7 -> PRIVACY_SEARCH_BY_PHONE_NUMBER
    13 -> PRIVACY_SEARCH_BY_USERID
    14 -> PRIVACY_SEARCH_BY_EMAIL
    21 -> PRIVACY_ALLOW_SECONDARY_DEVICE_LOGIN
    23 -> PRIVACY_PROFILE_IMAGE_POST_TO_MYHOME
    35 -> PRIVACY_PROFILE_MUSIC_POST_TO_MYHOME
    30 -> PRIVACY_ALLOW_FRIEND_REQUEST
    25 -> PRIVACY_RECV_MESSAGES_FROM_NOT_FRIEND
    26 -> PRIVACY_AGREE_USE_LINECOIN_TO_PAIDCALL
    27 -> PRIVACY_AGREE_USE_PAIDCALL
    10 -> CONTACT_MY_TICKET
    11 -> IDENTITY_PROVIDER
    12 -> IDENTITY_IDENTIFIER
    19 -> SNS_ACCOUNT
    20 -> PHONE_REGISTRATION
    15 -> PREFERENCE_LOCALE
    22 -> CUSTOM_MODE
    24 -> EMAIL_CONFIRMATION_STATUS
    28 -> ACCOUNT_MIGRATION_PINCODE
    29 -> ENFORCED_INPUT_ACCOUNT_MIGRATION_PINCODE
    18 -> SECURITY_CENTER_SETTINGS
    33 -> E2EE_ENABLE
    47 -> ENABLE_SOUND_TO_TEXT
    34 -> HITOKOTO_BACKUP_REQUESTED
    36 -> CONTACT_ALLOW_FOLLOWING
    37 -> PRIVACY_ALLOW_NEARBY
    38 -> AGREEMENT_NEARBY
    39 -> AGREEMENT_SQUARE
    41 -> ALLOW_UNREGISTRATION_SECONDARY_DEVICE
    42 -> AGREEMENT_BOT_USE
    43 -> AGREEMENT_SHAKE_FUNCTION
    44 -> AGREEMENT_MOBILE_CONTACT_NAME
    46 -> AGREEMENT_SOUND_TO_TEXT
    _ -> X.throw T.ThriftException
instance H.Hashable SettingsAttributeEx where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SettingsAttributeEx where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SnsIdType = FACEBOOK|SINA|RENREN|FEIXIN|BBM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SnsIdType where
  fromEnum t = case t of
    FACEBOOK -> 1
    SINA -> 2
    RENREN -> 3
    FEIXIN -> 4
    BBM -> 5
  toEnum t = case t of
    1 -> FACEBOOK
    2 -> SINA
    3 -> RENREN
    4 -> FEIXIN
    5 -> BBM
    _ -> X.throw T.ThriftException
instance H.Hashable SnsIdType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SnsIdType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SpammerReason = OTHER|ADVERTISING|GENDER_HARASSMENT|HARASSMENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SpammerReason where
  fromEnum t = case t of
    OTHER -> 0
    ADVERTISING -> 1
    GENDER_HARASSMENT -> 2
    HARASSMENT -> 3
  toEnum t = case t of
    0 -> OTHER
    1 -> ADVERTISING
    2 -> GENDER_HARASSMENT
    3 -> HARASSMENT
    _ -> X.throw T.ThriftException
instance H.Hashable SpammerReason where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SpammerReason where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncActionType = SYNC|REPORT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SyncActionType where
  fromEnum t = case t of
    SYNC -> 0
    REPORT -> 1
  toEnum t = case t of
    0 -> SYNC
    1 -> REPORT
    _ -> X.throw T.ThriftException
instance H.Hashable SyncActionType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SyncActionType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SpotCategory = UNKNOWN|GOURMET|BEAUTY|TRAVEL|SHOPPING|ENTERTAINMENT|SPORTS|TRANSPORT|LIFE|HOSPITAL|FINANCE|EDUCATION|OTHER|ALL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SpotCategory where
  fromEnum t = case t of
    UNKNOWN -> 0
    GOURMET -> 1
    BEAUTY -> 2
    TRAVEL -> 3
    SHOPPING -> 4
    ENTERTAINMENT -> 5
    SPORTS -> 6
    TRANSPORT -> 7
    LIFE -> 8
    HOSPITAL -> 9
    FINANCE -> 10
    EDUCATION -> 11
    OTHER -> 12
    ALL -> 10000
  toEnum t = case t of
    0 -> UNKNOWN
    1 -> GOURMET
    2 -> BEAUTY
    3 -> TRAVEL
    4 -> SHOPPING
    5 -> ENTERTAINMENT
    6 -> SPORTS
    7 -> TRANSPORT
    8 -> LIFE
    9 -> HOSPITAL
    10 -> FINANCE
    11 -> EDUCATION
    12 -> OTHER
    10000 -> ALL
    _ -> X.throw T.ThriftException
instance H.Hashable SpotCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SpotCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncCategory = PROFILE|SETTINGS|OPS|CONTACT|RECOMMEND|BLOCK|GROUP|ROOM|NOTIFICATION|ADDRESS_BOOK  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SyncCategory where
  fromEnum t = case t of
    PROFILE -> 0
    SETTINGS -> 1
    OPS -> 2
    CONTACT -> 3
    RECOMMEND -> 4
    BLOCK -> 5
    GROUP -> 6
    ROOM -> 7
    NOTIFICATION -> 8
    ADDRESS_BOOK -> 9
  toEnum t = case t of
    0 -> PROFILE
    1 -> SETTINGS
    2 -> OPS
    3 -> CONTACT
    4 -> RECOMMEND
    5 -> BLOCK
    6 -> GROUP
    7 -> ROOM
    8 -> NOTIFICATION
    9 -> ADDRESS_BOOK
    _ -> X.throw T.ThriftException
instance H.Hashable SyncCategory where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SyncCategory where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data TMessageBoxStatus = ACTIVATED|UNREAD  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum TMessageBoxStatus where
  fromEnum t = case t of
    ACTIVATED -> 1
    UNREAD -> 2
  toEnum t = case t of
    1 -> ACTIVATED
    2 -> UNREAD
    _ -> X.throw T.ThriftException
instance H.Hashable TMessageBoxStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary TMessageBoxStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UniversalNotificationServiceErrorCode = INTERNAL_ERROR|INVALID_KEY|ILLEGAL_ARGUMENT|TOO_MANY_REQUEST|AUTHENTICATION_FAILED|NO_WRITE_PERMISSION  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UniversalNotificationServiceErrorCode where
  fromEnum t = case t of
    INTERNAL_ERROR -> 0
    INVALID_KEY -> 1
    ILLEGAL_ARGUMENT -> 2
    TOO_MANY_REQUEST -> 3
    AUTHENTICATION_FAILED -> 4
    NO_WRITE_PERMISSION -> 5
  toEnum t = case t of
    0 -> INTERNAL_ERROR
    1 -> INVALID_KEY
    2 -> ILLEGAL_ARGUMENT
    3 -> TOO_MANY_REQUEST
    4 -> AUTHENTICATION_FAILED
    5 -> NO_WRITE_PERMISSION
    _ -> X.throw T.ThriftException
instance H.Hashable UniversalNotificationServiceErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UniversalNotificationServiceErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UnregistrationReason = UNREGISTRATION_REASON_UNREGISTER_USER|UNREGISTRATION_REASON_UNBIND_DEVICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UnregistrationReason where
  fromEnum t = case t of
    UNREGISTRATION_REASON_UNREGISTER_USER -> 1
    UNREGISTRATION_REASON_UNBIND_DEVICE -> 2
  toEnum t = case t of
    1 -> UNREGISTRATION_REASON_UNREGISTER_USER
    2 -> UNREGISTRATION_REASON_UNBIND_DEVICE
    _ -> X.throw T.ThriftException
instance H.Hashable UnregistrationReason where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UnregistrationReason where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UserAgeType = OVER|UNDER|UNDEFINED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UserAgeType where
  fromEnum t = case t of
    OVER -> 1
    UNDER -> 2
    UNDEFINED -> 3
  toEnum t = case t of
    1 -> OVER
    2 -> UNDER
    3 -> UNDEFINED
    _ -> X.throw T.ThriftException
instance H.Hashable UserAgeType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UserAgeType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data VerificationMethod = NO_AVAILABLE|PIN_VIA_SMS|CALLERID_INDIGO|PIN_VIA_TTS|SKIP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum VerificationMethod where
  fromEnum t = case t of
    NO_AVAILABLE -> 0
    PIN_VIA_SMS -> 1
    CALLERID_INDIGO -> 2
    PIN_VIA_TTS -> 4
    SKIP -> 10
  toEnum t = case t of
    0 -> NO_AVAILABLE
    1 -> PIN_VIA_SMS
    2 -> CALLERID_INDIGO
    4 -> PIN_VIA_TTS
    10 -> SKIP
    _ -> X.throw T.ThriftException
instance H.Hashable VerificationMethod where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary VerificationMethod where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data VerificationResult = FAILED|OK_NOT_REGISTERED_YET|OK_REGISTERED_WITH_SAME_DEVICE|OK_REGISTERED_WITH_ANOTHER_DEVICE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum VerificationResult where
  fromEnum t = case t of
    FAILED -> 0
    OK_NOT_REGISTERED_YET -> 1
    OK_REGISTERED_WITH_SAME_DEVICE -> 2
    OK_REGISTERED_WITH_ANOTHER_DEVICE -> 3
  toEnum t = case t of
    0 -> FAILED
    1 -> OK_NOT_REGISTERED_YET
    2 -> OK_REGISTERED_WITH_SAME_DEVICE
    3 -> OK_REGISTERED_WITH_ANOTHER_DEVICE
    _ -> X.throw T.ThriftException
instance H.Hashable VerificationResult where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary VerificationResult where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data WapInvitationType = REGISTRATION|CHAT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum WapInvitationType where
  fromEnum t = case t of
    REGISTRATION -> 1
    CHAT -> 2
  toEnum t = case t of
    1 -> REGISTRATION
    2 -> CHAT
    _ -> X.throw T.ThriftException
instance H.Hashable WapInvitationType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary WapInvitationType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data MediaType = AUDIO|VIDEO  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum MediaType where
  fromEnum t = case t of
    AUDIO -> 1
    VIDEO -> 2
  toEnum t = case t of
    1 -> AUDIO
    2 -> VIDEO
    _ -> X.throw T.ThriftException
instance H.Hashable MediaType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary MediaType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SQErrorCode = UNKNOWN|ILLEGAL_ARGUMENT|AUTHENTICATION_FAILURE|FORBIDDEN|NOT_FOUND|REVISION_MISMATCH|PRECONDITION_FAILED|INTERNAL_ERROR|NOT_IMPLEMENTED|TRY_AGAIN_LATER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SQErrorCode where
  fromEnum t = case t of
    UNKNOWN -> 0
    ILLEGAL_ARGUMENT -> 400
    AUTHENTICATION_FAILURE -> 401
    FORBIDDEN -> 403
    NOT_FOUND -> 404
    REVISION_MISMATCH -> 409
    PRECONDITION_FAILED -> 410
    INTERNAL_ERROR -> 500
    NOT_IMPLEMENTED -> 501
    TRY_AGAIN_LATER -> 505
  toEnum t = case t of
    0 -> UNKNOWN
    400 -> ILLEGAL_ARGUMENT
    401 -> AUTHENTICATION_FAILURE
    403 -> FORBIDDEN
    404 -> NOT_FOUND
    409 -> REVISION_MISMATCH
    410 -> PRECONDITION_FAILED
    500 -> INTERNAL_ERROR
    501 -> NOT_IMPLEMENTED
    505 -> TRY_AGAIN_LATER
    _ -> X.throw T.ThriftException
instance H.Hashable SQErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SQErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareEventType = RECEIVE_MESSAGE|SEND_MESSAGE|NOTIFIED_JOIN_SQUARE_CHAT|NOTIFIED_INVITE_INTO_SQUARE_CHAT|NOTIFIED_LEAVE_SQUARE_CHAT|NOTIFIED_DESTROY_MESSAGE|NOTIFIED_MARK_AS_READ|NOTIFIED_UPDATE_SQUARE_MEMBER_PROFILE|NOTIFIED_KICKOUT_FROM_SQUARE|NOTIFIED_SHUTDOWN_SQUARE|NOTIFIED_DELETE_SQUARE_CHAT|NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_NAME|NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_IMAGE|NOTIFIED_UPDATE_SQUARE_CHAT_ANNOUNCEMENT|NOTIFIED_ADD_BOT|NOTIFIED_REMOVE_BOT|NOTIFIED_UPDATE_SQUARE|NOTIFIED_UPDATE_SQUARE_STATUS|NOTIFIED_UPDATE_SQUARE_AUTHORITY|NOTIFIED_UPDATE_SQUARE_MEMBER|NOTIFIED_UPDATE_SQUARE_CHAT|NOTIFIED_UPDATE_SQUARE_CHAT_STATUS|NOTIFIED_UPDATE_SQUARE_CHAT_MEMBER|NOTIFIED_CREATE_SQUARE_MEMBER|NOTIFIED_CREATE_SQUARE_CHAT_MEMBER|NOTIFIED_UPDATE_SQUARE_MEMBER_RELATION|NOTIFIED_UPDATE_SQUARE_FEATURE_SET|NOTIFIED_UPDATE_SQUARE_NOTE_STATUS|NOTIFICATION_JOIN_REQUEST|NOTIFICATION_JOINED|NOTIFICATION_PROMOTED_COADMIN|NOTIFICATION_PROMOTED_ADMIN|NOTIFICATION_DEMOTED_MEMBER|NOTIFICATION_KICKED_OUT|NOTIFICATION_SQUARE_DELETE|NOTIFICATION_SQUARE_CHAT_DELETE|NOTIFICATION_MESSAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareEventType where
  fromEnum t = case t of
    RECEIVE_MESSAGE -> 0
    SEND_MESSAGE -> 1
    NOTIFIED_JOIN_SQUARE_CHAT -> 2
    NOTIFIED_INVITE_INTO_SQUARE_CHAT -> 3
    NOTIFIED_LEAVE_SQUARE_CHAT -> 4
    NOTIFIED_DESTROY_MESSAGE -> 5
    NOTIFIED_MARK_AS_READ -> 6
    NOTIFIED_UPDATE_SQUARE_MEMBER_PROFILE -> 7
    NOTIFIED_KICKOUT_FROM_SQUARE -> 19
    NOTIFIED_SHUTDOWN_SQUARE -> 18
    NOTIFIED_DELETE_SQUARE_CHAT -> 20
    NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_NAME -> 30
    NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_IMAGE -> 31
    NOTIFIED_UPDATE_SQUARE_CHAT_ANNOUNCEMENT -> 37
    NOTIFIED_ADD_BOT -> 33
    NOTIFIED_REMOVE_BOT -> 34
    NOTIFIED_UPDATE_SQUARE -> 8
    NOTIFIED_UPDATE_SQUARE_STATUS -> 9
    NOTIFIED_UPDATE_SQUARE_AUTHORITY -> 10
    NOTIFIED_UPDATE_SQUARE_MEMBER -> 11
    NOTIFIED_UPDATE_SQUARE_CHAT -> 12
    NOTIFIED_UPDATE_SQUARE_CHAT_STATUS -> 13
    NOTIFIED_UPDATE_SQUARE_CHAT_MEMBER -> 14
    NOTIFIED_CREATE_SQUARE_MEMBER -> 15
    NOTIFIED_CREATE_SQUARE_CHAT_MEMBER -> 16
    NOTIFIED_UPDATE_SQUARE_MEMBER_RELATION -> 17
    NOTIFIED_UPDATE_SQUARE_FEATURE_SET -> 32
    NOTIFIED_UPDATE_SQUARE_NOTE_STATUS -> 36
    NOTIFICATION_JOIN_REQUEST -> 21
    NOTIFICATION_JOINED -> 22
    NOTIFICATION_PROMOTED_COADMIN -> 23
    NOTIFICATION_PROMOTED_ADMIN -> 24
    NOTIFICATION_DEMOTED_MEMBER -> 25
    NOTIFICATION_KICKED_OUT -> 26
    NOTIFICATION_SQUARE_DELETE -> 27
    NOTIFICATION_SQUARE_CHAT_DELETE -> 28
    NOTIFICATION_MESSAGE -> 29
  toEnum t = case t of
    0 -> RECEIVE_MESSAGE
    1 -> SEND_MESSAGE
    2 -> NOTIFIED_JOIN_SQUARE_CHAT
    3 -> NOTIFIED_INVITE_INTO_SQUARE_CHAT
    4 -> NOTIFIED_LEAVE_SQUARE_CHAT
    5 -> NOTIFIED_DESTROY_MESSAGE
    6 -> NOTIFIED_MARK_AS_READ
    7 -> NOTIFIED_UPDATE_SQUARE_MEMBER_PROFILE
    19 -> NOTIFIED_KICKOUT_FROM_SQUARE
    18 -> NOTIFIED_SHUTDOWN_SQUARE
    20 -> NOTIFIED_DELETE_SQUARE_CHAT
    30 -> NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_NAME
    31 -> NOTIFIED_UPDATE_SQUARE_CHAT_PROFILE_IMAGE
    37 -> NOTIFIED_UPDATE_SQUARE_CHAT_ANNOUNCEMENT
    33 -> NOTIFIED_ADD_BOT
    34 -> NOTIFIED_REMOVE_BOT
    8 -> NOTIFIED_UPDATE_SQUARE
    9 -> NOTIFIED_UPDATE_SQUARE_STATUS
    10 -> NOTIFIED_UPDATE_SQUARE_AUTHORITY
    11 -> NOTIFIED_UPDATE_SQUARE_MEMBER
    12 -> NOTIFIED_UPDATE_SQUARE_CHAT
    13 -> NOTIFIED_UPDATE_SQUARE_CHAT_STATUS
    14 -> NOTIFIED_UPDATE_SQUARE_CHAT_MEMBER
    15 -> NOTIFIED_CREATE_SQUARE_MEMBER
    16 -> NOTIFIED_CREATE_SQUARE_CHAT_MEMBER
    17 -> NOTIFIED_UPDATE_SQUARE_MEMBER_RELATION
    32 -> NOTIFIED_UPDATE_SQUARE_FEATURE_SET
    36 -> NOTIFIED_UPDATE_SQUARE_NOTE_STATUS
    21 -> NOTIFICATION_JOIN_REQUEST
    22 -> NOTIFICATION_JOINED
    23 -> NOTIFICATION_PROMOTED_COADMIN
    24 -> NOTIFICATION_PROMOTED_ADMIN
    25 -> NOTIFICATION_DEMOTED_MEMBER
    26 -> NOTIFICATION_KICKED_OUT
    27 -> NOTIFICATION_SQUARE_DELETE
    28 -> NOTIFICATION_SQUARE_CHAT_DELETE
    29 -> NOTIFICATION_MESSAGE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareEventType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareEventType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareMemberRelationState = NONE|BLOCKED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareMemberRelationState where
  fromEnum t = case t of
    NONE -> 1
    BLOCKED -> 2
  toEnum t = case t of
    1 -> NONE
    2 -> BLOCKED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareMemberRelationState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareMemberRelationState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareFeatureControlState = DISABLED|ENABLED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareFeatureControlState where
  fromEnum t = case t of
    DISABLED -> 1
    ENABLED -> 2
  toEnum t = case t of
    1 -> DISABLED
    2 -> ENABLED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareFeatureControlState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareFeatureControlState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BooleanState = NONE|OFF|ON  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BooleanState where
  fromEnum t = case t of
    NONE -> 0
    OFF -> 1
    ON -> 2
  toEnum t = case t of
    0 -> NONE
    1 -> OFF
    2 -> ON
    _ -> X.throw T.ThriftException
instance H.Hashable BooleanState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BooleanState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareType = CLOSED|OPEN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareType where
  fromEnum t = case t of
    CLOSED -> 0
    OPEN -> 1
  toEnum t = case t of
    0 -> CLOSED
    1 -> OPEN
    _ -> X.throw T.ThriftException
instance H.Hashable SquareType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatType = OPEN|SECRET|ONE_ON_ONE|SQUARE_DEFAULT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatType where
  fromEnum t = case t of
    OPEN -> 1
    SECRET -> 2
    ONE_ON_ONE -> 3
    SQUARE_DEFAULT -> 4
  toEnum t = case t of
    1 -> OPEN
    2 -> SECRET
    3 -> ONE_ON_ONE
    4 -> SQUARE_DEFAULT
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareErrorCode = UNKNOWN|INTERNAL_ERROR|NOT_IMPLEMENTED|TRY_AGAIN_LATER|MAINTENANCE|ILLEGAL_ARGUMENT|AUTHENTICATION_FAILURE|FORBIDDEN|NOT_FOUND|REVISION_MISMATCH|PRECONDITION_FAILED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareErrorCode where
  fromEnum t = case t of
    UNKNOWN -> 0
    INTERNAL_ERROR -> 500
    NOT_IMPLEMENTED -> 501
    TRY_AGAIN_LATER -> 503
    MAINTENANCE -> 505
    ILLEGAL_ARGUMENT -> 400
    AUTHENTICATION_FAILURE -> 401
    FORBIDDEN -> 403
    NOT_FOUND -> 404
    REVISION_MISMATCH -> 409
    PRECONDITION_FAILED -> 410
  toEnum t = case t of
    0 -> UNKNOWN
    500 -> INTERNAL_ERROR
    501 -> NOT_IMPLEMENTED
    503 -> TRY_AGAIN_LATER
    505 -> MAINTENANCE
    400 -> ILLEGAL_ARGUMENT
    401 -> AUTHENTICATION_FAILURE
    403 -> FORBIDDEN
    404 -> NOT_FOUND
    409 -> REVISION_MISMATCH
    410 -> PRECONDITION_FAILED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareErrorCode where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareErrorCode where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatState = ALIVE|DELETED|SUSPENDED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatState where
  fromEnum t = case t of
    ALIVE -> 0
    DELETED -> 1
    SUSPENDED -> 2
  toEnum t = case t of
    0 -> ALIVE
    1 -> DELETED
    2 -> SUSPENDED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareFeatureSetAttribute = CREATING_SECRET_SQUARE_CHAT|INVITING_INTO_OPEN_SQUARE_CHAT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareFeatureSetAttribute where
  fromEnum t = case t of
    CREATING_SECRET_SQUARE_CHAT -> 1
    INVITING_INTO_OPEN_SQUARE_CHAT -> 2
  toEnum t = case t of
    1 -> CREATING_SECRET_SQUARE_CHAT
    2 -> INVITING_INTO_OPEN_SQUARE_CHAT
    _ -> X.throw T.ThriftException
instance H.Hashable SquareFeatureSetAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareFeatureSetAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareMembershipState = JOIN_REQUESTED|JOINED|REJECTED|LEFT|KICK_OUT|BANNED|DELETED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareMembershipState where
  fromEnum t = case t of
    JOIN_REQUESTED -> 1
    JOINED -> 2
    REJECTED -> 3
    LEFT -> 4
    KICK_OUT -> 5
    BANNED -> 6
    DELETED -> 7
  toEnum t = case t of
    1 -> JOIN_REQUESTED
    2 -> JOINED
    3 -> REJECTED
    4 -> LEFT
    5 -> KICK_OUT
    6 -> BANNED
    7 -> DELETED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareMembershipState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareMembershipState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatMemberAttribute = MEMBERSHIP_STATE|NOTIFICATION_MESSAGE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatMemberAttribute where
  fromEnum t = case t of
    MEMBERSHIP_STATE -> 4
    NOTIFICATION_MESSAGE -> 6
  toEnum t = case t of
    4 -> MEMBERSHIP_STATE
    6 -> NOTIFICATION_MESSAGE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatMemberAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatMemberAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareMemberRole = ADMIN|CO_ADMIN|MEMBER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareMemberRole where
  fromEnum t = case t of
    ADMIN -> 1
    CO_ADMIN -> 2
    MEMBER -> 10
  toEnum t = case t of
    1 -> ADMIN
    2 -> CO_ADMIN
    10 -> MEMBER
    _ -> X.throw T.ThriftException
instance H.Hashable SquareMemberRole where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareMemberRole where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PreconditionFailedExtraInfo = DUPLICATED_DISPLAY_NAME  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PreconditionFailedExtraInfo where
  fromEnum t = case t of
    DUPLICATED_DISPLAY_NAME -> 0
  toEnum t = case t of
    0 -> DUPLICATED_DISPLAY_NAME
    _ -> X.throw T.ThriftException
instance H.Hashable PreconditionFailedExtraInfo where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PreconditionFailedExtraInfo where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareChatMembershipState = JOINED|LEFT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareChatMembershipState where
  fromEnum t = case t of
    JOINED -> 1
    LEFT -> 2
  toEnum t = case t of
    1 -> JOINED
    2 -> LEFT
    _ -> X.throw T.ThriftException
instance H.Hashable SquareChatMembershipState where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareChatMembershipState where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data FetchDirection = FORWARD|BACKWARD  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum FetchDirection where
  fromEnum t = case t of
    FORWARD -> 1
    BACKWARD -> 2
  toEnum t = case t of
    1 -> FORWARD
    2 -> BACKWARD
    _ -> X.throw T.ThriftException
instance H.Hashable FetchDirection where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary FetchDirection where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareAttribute = NAME|WELCOME_MESSAGE|PROFILE_IMAGE|DESCRIPTION|SEARCHABLE|CATEGORY|INVITATION_URL|ABLE_TO_USE_INVITATION_URL|STATE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareAttribute where
  fromEnum t = case t of
    NAME -> 1
    WELCOME_MESSAGE -> 2
    PROFILE_IMAGE -> 3
    DESCRIPTION -> 4
    SEARCHABLE -> 6
    CATEGORY -> 7
    INVITATION_URL -> 8
    ABLE_TO_USE_INVITATION_URL -> 9
    STATE -> 10
  toEnum t = case t of
    1 -> NAME
    2 -> WELCOME_MESSAGE
    3 -> PROFILE_IMAGE
    4 -> DESCRIPTION
    6 -> SEARCHABLE
    7 -> CATEGORY
    8 -> INVITATION_URL
    9 -> ABLE_TO_USE_INVITATION_URL
    10 -> STATE
    _ -> X.throw T.ThriftException
instance H.Hashable SquareAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareAuthorityAttribute = UPDATE_SQUARE_PROFILE|INVITE_NEW_MEMBER|APPROVE_JOIN_REQUEST|CREATE_POST|CREATE_OPEN_SQUARE_CHAT|DELETE_SQUARE_CHAT_OR_POST|REMOVE_SQUARE_MEMBER|GRANT_ROLE|ENABLE_INVITATION_TICKET|CREATE_CHAT_ANNOUNCEMENT  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareAuthorityAttribute where
  fromEnum t = case t of
    UPDATE_SQUARE_PROFILE -> 1
    INVITE_NEW_MEMBER -> 2
    APPROVE_JOIN_REQUEST -> 3
    CREATE_POST -> 4
    CREATE_OPEN_SQUARE_CHAT -> 5
    DELETE_SQUARE_CHAT_OR_POST -> 6
    REMOVE_SQUARE_MEMBER -> 7
    GRANT_ROLE -> 8
    ENABLE_INVITATION_TICKET -> 9
    CREATE_CHAT_ANNOUNCEMENT -> 10
  toEnum t = case t of
    1 -> UPDATE_SQUARE_PROFILE
    2 -> INVITE_NEW_MEMBER
    3 -> APPROVE_JOIN_REQUEST
    4 -> CREATE_POST
    5 -> CREATE_OPEN_SQUARE_CHAT
    6 -> DELETE_SQUARE_CHAT_OR_POST
    7 -> REMOVE_SQUARE_MEMBER
    8 -> GRANT_ROLE
    9 -> ENABLE_INVITATION_TICKET
    10 -> CREATE_CHAT_ANNOUNCEMENT
    _ -> X.throw T.ThriftException
instance H.Hashable SquareAuthorityAttribute where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareAuthorityAttribute where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SquareEventStatus = NORMAL|ALERT_DISABLED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SquareEventStatus where
  fromEnum t = case t of
    NORMAL -> 1
    ALERT_DISABLED -> 2
  toEnum t = case t of
    1 -> NORMAL
    2 -> ALERT_DISABLED
    _ -> X.throw T.ThriftException
instance H.Hashable SquareEventStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SquareEventStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SuggestDictionaryIncrementStatus = SUCCESS|INVALID_REVISION|TOO_LARGE_DATA|SCHEME_CHANGED|RETRY|FAIL|TOO_OLD_DATA  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SuggestDictionaryIncrementStatus where
  fromEnum t = case t of
    SUCCESS -> 0
    INVALID_REVISION -> 1
    TOO_LARGE_DATA -> 2
    SCHEME_CHANGED -> 3
    RETRY -> 4
    FAIL -> 5
    TOO_OLD_DATA -> 6
  toEnum t = case t of
    0 -> SUCCESS
    1 -> INVALID_REVISION
    2 -> TOO_LARGE_DATA
    3 -> SCHEME_CHANGED
    4 -> RETRY
    5 -> FAIL
    6 -> TOO_OLD_DATA
    _ -> X.throw T.ThriftException
instance H.Hashable SuggestDictionaryIncrementStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SuggestDictionaryIncrementStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data Location = Location  { location_title :: LT.Text
  , location_address :: LT.Text
  , location_latitude :: P.Double
  , location_longitude :: P.Double
  , location_phone :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Location where
  hashWithSalt salt record = salt   `H.hashWithSalt` location_title record   `H.hashWithSalt` location_address record   `H.hashWithSalt` location_latitude record   `H.hashWithSalt` location_longitude record   `H.hashWithSalt` location_phone record  
instance QC.Arbitrary Location where 
  arbitrary = M.liftM Location (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Location = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Location{location_title = location_title obj} then P.Nothing else P.Just $ default_Location{location_title = location_title obj}
    , if obj == default_Location{location_address = location_address obj} then P.Nothing else P.Just $ default_Location{location_address = location_address obj}
    , if obj == default_Location{location_latitude = location_latitude obj} then P.Nothing else P.Just $ default_Location{location_latitude = location_latitude obj}
    , if obj == default_Location{location_longitude = location_longitude obj} then P.Nothing else P.Just $ default_Location{location_longitude = location_longitude obj}
    , if obj == default_Location{location_phone = location_phone obj} then P.Nothing else P.Just $ default_Location{location_phone = location_phone obj}
    ]
from_Location :: Location -> T.ThriftVal
from_Location record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("title",T.TString $ E.encodeUtf8 _v2))) $ location_title record
  , (\_v2 -> P.Just (2, ("address",T.TString $ E.encodeUtf8 _v2))) $ location_address record
  , (\_v2 -> P.Just (3, ("latitude",T.TDouble _v2))) $ location_latitude record
  , (\_v2 -> P.Just (4, ("longitude",T.TDouble _v2))) $ location_longitude record
  , (\_v2 -> P.Just (5, ("phone",T.TString $ E.encodeUtf8 _v2))) $ location_phone record
  ]
write_Location :: T.Protocol p => p -> Location -> P.IO ()
write_Location oprot record = T.writeVal oprot $ from_Location record
encode_Location :: T.StatelessProtocol p => p -> Location -> LBS.ByteString
encode_Location oprot record = T.serializeVal oprot $ from_Location record
to_Location :: T.ThriftVal -> Location
to_Location (T.TStruct fields) = Location{
  location_title = P.maybe (location_title default_Location) (\(_,_val4) -> (case _val4 of {T.TString _val5 -> E.decodeUtf8 _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  location_address = P.maybe (location_address default_Location) (\(_,_val4) -> (case _val4 of {T.TString _val6 -> E.decodeUtf8 _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  location_latitude = P.maybe (location_latitude default_Location) (\(_,_val4) -> (case _val4 of {T.TDouble _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  location_longitude = P.maybe (location_longitude default_Location) (\(_,_val4) -> (case _val4 of {T.TDouble _val8 -> _val8; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  location_phone = P.maybe (location_phone default_Location) (\(_,_val4) -> (case _val4 of {T.TString _val9 -> E.decodeUtf8 _val9; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_Location _ = P.error "not a struct"
read_Location :: T.Protocol p => p -> P.IO Location
read_Location iprot = to_Location <$> T.readVal iprot (T.T_STRUCT typemap_Location)
decode_Location :: T.StatelessProtocol p => p -> LBS.ByteString -> Location
decode_Location iprot bs = to_Location $ T.deserializeVal iprot (T.T_STRUCT typemap_Location) bs
typemap_Location :: T.TypeMap
typemap_Location = Map.fromList [(1,("title",T.T_STRING)),(2,("address",T.T_STRING)),(3,("latitude",T.T_DOUBLE)),(4,("longitude",T.T_DOUBLE)),(5,("phone",T.T_STRING))]
default_Location :: Location
default_Location = Location{
  location_title = "",
  location_address = "",
  location_latitude = 0,
  location_longitude = 0,
  location_phone = ""}
data MessageBoxV2MessageId = MessageBoxV2MessageId  { messageBoxV2MessageId_deliveredTime :: I.Int64
  , messageBoxV2MessageId_messageId :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageBoxV2MessageId where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageBoxV2MessageId_deliveredTime record   `H.hashWithSalt` messageBoxV2MessageId_messageId record  
instance QC.Arbitrary MessageBoxV2MessageId where 
  arbitrary = M.liftM MessageBoxV2MessageId (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageBoxV2MessageId = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageBoxV2MessageId{messageBoxV2MessageId_deliveredTime = messageBoxV2MessageId_deliveredTime obj} then P.Nothing else P.Just $ default_MessageBoxV2MessageId{messageBoxV2MessageId_deliveredTime = messageBoxV2MessageId_deliveredTime obj}
    , if obj == default_MessageBoxV2MessageId{messageBoxV2MessageId_messageId = messageBoxV2MessageId_messageId obj} then P.Nothing else P.Just $ default_MessageBoxV2MessageId{messageBoxV2MessageId_messageId = messageBoxV2MessageId_messageId obj}
    ]
from_MessageBoxV2MessageId :: MessageBoxV2MessageId -> T.ThriftVal
from_MessageBoxV2MessageId record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v12 -> P.Just (1, ("deliveredTime",T.TI64 _v12))) $ messageBoxV2MessageId_deliveredTime record
  , (\_v12 -> P.Just (2, ("messageId",T.TI64 _v12))) $ messageBoxV2MessageId_messageId record
  ]
write_MessageBoxV2MessageId :: T.Protocol p => p -> MessageBoxV2MessageId -> P.IO ()
write_MessageBoxV2MessageId oprot record = T.writeVal oprot $ from_MessageBoxV2MessageId record
encode_MessageBoxV2MessageId :: T.StatelessProtocol p => p -> MessageBoxV2MessageId -> LBS.ByteString
encode_MessageBoxV2MessageId oprot record = T.serializeVal oprot $ from_MessageBoxV2MessageId record
to_MessageBoxV2MessageId :: T.ThriftVal -> MessageBoxV2MessageId
to_MessageBoxV2MessageId (T.TStruct fields) = MessageBoxV2MessageId{
  messageBoxV2MessageId_deliveredTime = P.maybe (messageBoxV2MessageId_deliveredTime default_MessageBoxV2MessageId) (\(_,_val14) -> (case _val14 of {T.TI64 _val15 -> _val15; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageBoxV2MessageId_messageId = P.maybe (messageBoxV2MessageId_messageId default_MessageBoxV2MessageId) (\(_,_val14) -> (case _val14 of {T.TI64 _val16 -> _val16; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MessageBoxV2MessageId _ = P.error "not a struct"
read_MessageBoxV2MessageId :: T.Protocol p => p -> P.IO MessageBoxV2MessageId
read_MessageBoxV2MessageId iprot = to_MessageBoxV2MessageId <$> T.readVal iprot (T.T_STRUCT typemap_MessageBoxV2MessageId)
decode_MessageBoxV2MessageId :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageBoxV2MessageId
decode_MessageBoxV2MessageId iprot bs = to_MessageBoxV2MessageId $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageBoxV2MessageId) bs
typemap_MessageBoxV2MessageId :: T.TypeMap
typemap_MessageBoxV2MessageId = Map.fromList [(1,("deliveredTime",T.T_I64)),(2,("messageId",T.T_I64))]
default_MessageBoxV2MessageId :: MessageBoxV2MessageId
default_MessageBoxV2MessageId = MessageBoxV2MessageId{
  messageBoxV2MessageId_deliveredTime = 0,
  messageBoxV2MessageId_messageId = 0}
data MessageCommitResult = MessageCommitResult  { messageCommitResult_requestId :: LT.Text
  , messageCommitResult_state :: BuddyResultState
  , messageCommitResult_messageStoreRequestId :: LT.Text
  , messageCommitResult_messageIds :: (Vector.Vector LT.Text)
  , messageCommitResult_receiverCount :: I.Int64
  , messageCommitResult_successCount :: I.Int64
  , messageCommitResult_failCount :: I.Int64
  , messageCommitResult_blockCount :: I.Int64
  , messageCommitResult_unregisteredCount :: I.Int64
  , messageCommitResult_unrelatedCount :: I.Int64
  , messageCommitResult_errorDescription :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageCommitResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageCommitResult_requestId record   `H.hashWithSalt` messageCommitResult_state record   `H.hashWithSalt` messageCommitResult_messageStoreRequestId record   `H.hashWithSalt` messageCommitResult_messageIds record   `H.hashWithSalt` messageCommitResult_receiverCount record   `H.hashWithSalt` messageCommitResult_successCount record   `H.hashWithSalt` messageCommitResult_failCount record   `H.hashWithSalt` messageCommitResult_blockCount record   `H.hashWithSalt` messageCommitResult_unregisteredCount record   `H.hashWithSalt` messageCommitResult_unrelatedCount record   `H.hashWithSalt` messageCommitResult_errorDescription record  
instance QC.Arbitrary MessageCommitResult where 
  arbitrary = M.liftM MessageCommitResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageCommitResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageCommitResult{messageCommitResult_requestId = messageCommitResult_requestId obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_requestId = messageCommitResult_requestId obj}
    , if obj == default_MessageCommitResult{messageCommitResult_state = messageCommitResult_state obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_state = messageCommitResult_state obj}
    , if obj == default_MessageCommitResult{messageCommitResult_messageStoreRequestId = messageCommitResult_messageStoreRequestId obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_messageStoreRequestId = messageCommitResult_messageStoreRequestId obj}
    , if obj == default_MessageCommitResult{messageCommitResult_messageIds = messageCommitResult_messageIds obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_messageIds = messageCommitResult_messageIds obj}
    , if obj == default_MessageCommitResult{messageCommitResult_receiverCount = messageCommitResult_receiverCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_receiverCount = messageCommitResult_receiverCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_successCount = messageCommitResult_successCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_successCount = messageCommitResult_successCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_failCount = messageCommitResult_failCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_failCount = messageCommitResult_failCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_blockCount = messageCommitResult_blockCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_blockCount = messageCommitResult_blockCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_unregisteredCount = messageCommitResult_unregisteredCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_unregisteredCount = messageCommitResult_unregisteredCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_unrelatedCount = messageCommitResult_unrelatedCount obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_unrelatedCount = messageCommitResult_unrelatedCount obj}
    , if obj == default_MessageCommitResult{messageCommitResult_errorDescription = messageCommitResult_errorDescription obj} then P.Nothing else P.Just $ default_MessageCommitResult{messageCommitResult_errorDescription = messageCommitResult_errorDescription obj}
    ]
from_MessageCommitResult :: MessageCommitResult -> T.ThriftVal
from_MessageCommitResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v19 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v19))) $ messageCommitResult_requestId record
  , (\_v19 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v19))) $ messageCommitResult_state record
  , (\_v19 -> P.Just (3, ("messageStoreRequestId",T.TString $ E.encodeUtf8 _v19))) $ messageCommitResult_messageStoreRequestId record
  , (\_v19 -> P.Just (4, ("messageIds",T.TList T.T_STRING $ P.map (\_v21 -> T.TString $ E.encodeUtf8 _v21) $ Vector.toList _v19))) $ messageCommitResult_messageIds record
  , (\_v19 -> P.Just (11, ("receiverCount",T.TI64 _v19))) $ messageCommitResult_receiverCount record
  , (\_v19 -> P.Just (12, ("successCount",T.TI64 _v19))) $ messageCommitResult_successCount record
  , (\_v19 -> P.Just (13, ("failCount",T.TI64 _v19))) $ messageCommitResult_failCount record
  , (\_v19 -> P.Just (14, ("blockCount",T.TI64 _v19))) $ messageCommitResult_blockCount record
  , (\_v19 -> P.Just (15, ("unregisteredCount",T.TI64 _v19))) $ messageCommitResult_unregisteredCount record
  , (\_v19 -> P.Just (16, ("unrelatedCount",T.TI64 _v19))) $ messageCommitResult_unrelatedCount record
  , (\_v19 -> P.Just (21, ("errorDescription",T.TString $ E.encodeUtf8 _v19))) $ messageCommitResult_errorDescription record
  ]
write_MessageCommitResult :: T.Protocol p => p -> MessageCommitResult -> P.IO ()
write_MessageCommitResult oprot record = T.writeVal oprot $ from_MessageCommitResult record
encode_MessageCommitResult :: T.StatelessProtocol p => p -> MessageCommitResult -> LBS.ByteString
encode_MessageCommitResult oprot record = T.serializeVal oprot $ from_MessageCommitResult record
to_MessageCommitResult :: T.ThriftVal -> MessageCommitResult
to_MessageCommitResult (T.TStruct fields) = MessageCommitResult{
  messageCommitResult_requestId = P.maybe (messageCommitResult_requestId default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TString _val24 -> E.decodeUtf8 _val24; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageCommitResult_state = P.maybe (messageCommitResult_state default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI32 _val25 -> P.toEnum $ P.fromIntegral _val25; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  messageCommitResult_messageStoreRequestId = P.maybe (messageCommitResult_messageStoreRequestId default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TString _val26 -> E.decodeUtf8 _val26; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  messageCommitResult_messageIds = P.maybe (messageCommitResult_messageIds default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TList _ _val27 -> (Vector.fromList $ P.map (\_v28 -> (case _v28 of {T.TString _val29 -> E.decodeUtf8 _val29; _ -> P.error "wrong type"})) _val27); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  messageCommitResult_receiverCount = P.maybe (messageCommitResult_receiverCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val30 -> _val30; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  messageCommitResult_successCount = P.maybe (messageCommitResult_successCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val31 -> _val31; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  messageCommitResult_failCount = P.maybe (messageCommitResult_failCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val32 -> _val32; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  messageCommitResult_blockCount = P.maybe (messageCommitResult_blockCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val33 -> _val33; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  messageCommitResult_unregisteredCount = P.maybe (messageCommitResult_unregisteredCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val34 -> _val34; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  messageCommitResult_unrelatedCount = P.maybe (messageCommitResult_unrelatedCount default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TI64 _val35 -> _val35; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  messageCommitResult_errorDescription = P.maybe (messageCommitResult_errorDescription default_MessageCommitResult) (\(_,_val23) -> (case _val23 of {T.TString _val36 -> E.decodeUtf8 _val36; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_MessageCommitResult _ = P.error "not a struct"
read_MessageCommitResult :: T.Protocol p => p -> P.IO MessageCommitResult
read_MessageCommitResult iprot = to_MessageCommitResult <$> T.readVal iprot (T.T_STRUCT typemap_MessageCommitResult)
decode_MessageCommitResult :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageCommitResult
decode_MessageCommitResult iprot bs = to_MessageCommitResult $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageCommitResult) bs
typemap_MessageCommitResult :: T.TypeMap
typemap_MessageCommitResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("messageStoreRequestId",T.T_STRING)),(4,("messageIds",(T.T_LIST T.T_STRING))),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("blockCount",T.T_I64)),(15,("unregisteredCount",T.T_I64)),(16,("unrelatedCount",T.T_I64)),(21,("errorDescription",T.T_STRING))]
default_MessageCommitResult :: MessageCommitResult
default_MessageCommitResult = MessageCommitResult{
  messageCommitResult_requestId = "",
  messageCommitResult_state = (P.toEnum 0),
  messageCommitResult_messageStoreRequestId = "",
  messageCommitResult_messageIds = Vector.empty,
  messageCommitResult_receiverCount = 0,
  messageCommitResult_successCount = 0,
  messageCommitResult_failCount = 0,
  messageCommitResult_blockCount = 0,
  messageCommitResult_unregisteredCount = 0,
  messageCommitResult_unrelatedCount = 0,
  messageCommitResult_errorDescription = ""}
data CallHost = CallHost  { callHost_host :: LT.Text
  , callHost_port :: I.Int32
  , callHost_zone :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CallHost where
  hashWithSalt salt record = salt   `H.hashWithSalt` callHost_host record   `H.hashWithSalt` callHost_port record   `H.hashWithSalt` callHost_zone record  
instance QC.Arbitrary CallHost where 
  arbitrary = M.liftM CallHost (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CallHost = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CallHost{callHost_host = callHost_host obj} then P.Nothing else P.Just $ default_CallHost{callHost_host = callHost_host obj}
    , if obj == default_CallHost{callHost_port = callHost_port obj} then P.Nothing else P.Just $ default_CallHost{callHost_port = callHost_port obj}
    , if obj == default_CallHost{callHost_zone = callHost_zone obj} then P.Nothing else P.Just $ default_CallHost{callHost_zone = callHost_zone obj}
    ]
from_CallHost :: CallHost -> T.ThriftVal
from_CallHost record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v39 -> P.Just (1, ("host",T.TString $ E.encodeUtf8 _v39))) $ callHost_host record
  , (\_v39 -> P.Just (2, ("port",T.TI32 _v39))) $ callHost_port record
  , (\_v39 -> P.Just (3, ("zone",T.TString $ E.encodeUtf8 _v39))) $ callHost_zone record
  ]
write_CallHost :: T.Protocol p => p -> CallHost -> P.IO ()
write_CallHost oprot record = T.writeVal oprot $ from_CallHost record
encode_CallHost :: T.StatelessProtocol p => p -> CallHost -> LBS.ByteString
encode_CallHost oprot record = T.serializeVal oprot $ from_CallHost record
to_CallHost :: T.ThriftVal -> CallHost
to_CallHost (T.TStruct fields) = CallHost{
  callHost_host = P.maybe (callHost_host default_CallHost) (\(_,_val41) -> (case _val41 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  callHost_port = P.maybe (callHost_port default_CallHost) (\(_,_val41) -> (case _val41 of {T.TI32 _val43 -> _val43; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  callHost_zone = P.maybe (callHost_zone default_CallHost) (\(_,_val41) -> (case _val41 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CallHost _ = P.error "not a struct"
read_CallHost :: T.Protocol p => p -> P.IO CallHost
read_CallHost iprot = to_CallHost <$> T.readVal iprot (T.T_STRUCT typemap_CallHost)
decode_CallHost :: T.StatelessProtocol p => p -> LBS.ByteString -> CallHost
decode_CallHost iprot bs = to_CallHost $ T.deserializeVal iprot (T.T_STRUCT typemap_CallHost) bs
typemap_CallHost :: T.TypeMap
typemap_CallHost = Map.fromList [(1,("host",T.T_STRING)),(2,("port",T.T_I32)),(3,("zone",T.T_STRING))]
default_CallHost :: CallHost
default_CallHost = CallHost{
  callHost_host = "",
  callHost_port = 0,
  callHost_zone = ""}
data AgeCheckDocomoResult = AgeCheckDocomoResult  { ageCheckDocomoResult_authUrl :: LT.Text
  , ageCheckDocomoResult_userAgeType :: UserAgeType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AgeCheckDocomoResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` ageCheckDocomoResult_authUrl record   `H.hashWithSalt` ageCheckDocomoResult_userAgeType record  
instance QC.Arbitrary AgeCheckDocomoResult where 
  arbitrary = M.liftM AgeCheckDocomoResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AgeCheckDocomoResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AgeCheckDocomoResult{ageCheckDocomoResult_authUrl = ageCheckDocomoResult_authUrl obj} then P.Nothing else P.Just $ default_AgeCheckDocomoResult{ageCheckDocomoResult_authUrl = ageCheckDocomoResult_authUrl obj}
    , if obj == default_AgeCheckDocomoResult{ageCheckDocomoResult_userAgeType = ageCheckDocomoResult_userAgeType obj} then P.Nothing else P.Just $ default_AgeCheckDocomoResult{ageCheckDocomoResult_userAgeType = ageCheckDocomoResult_userAgeType obj}
    ]
from_AgeCheckDocomoResult :: AgeCheckDocomoResult -> T.ThriftVal
from_AgeCheckDocomoResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v47 -> P.Just (1, ("authUrl",T.TString $ E.encodeUtf8 _v47))) $ ageCheckDocomoResult_authUrl record
  , (\_v47 -> P.Just (2, ("userAgeType",T.TI32 $ P.fromIntegral $ P.fromEnum _v47))) $ ageCheckDocomoResult_userAgeType record
  ]
write_AgeCheckDocomoResult :: T.Protocol p => p -> AgeCheckDocomoResult -> P.IO ()
write_AgeCheckDocomoResult oprot record = T.writeVal oprot $ from_AgeCheckDocomoResult record
encode_AgeCheckDocomoResult :: T.StatelessProtocol p => p -> AgeCheckDocomoResult -> LBS.ByteString
encode_AgeCheckDocomoResult oprot record = T.serializeVal oprot $ from_AgeCheckDocomoResult record
to_AgeCheckDocomoResult :: T.ThriftVal -> AgeCheckDocomoResult
to_AgeCheckDocomoResult (T.TStruct fields) = AgeCheckDocomoResult{
  ageCheckDocomoResult_authUrl = P.maybe (ageCheckDocomoResult_authUrl default_AgeCheckDocomoResult) (\(_,_val49) -> (case _val49 of {T.TString _val50 -> E.decodeUtf8 _val50; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ageCheckDocomoResult_userAgeType = P.maybe (ageCheckDocomoResult_userAgeType default_AgeCheckDocomoResult) (\(_,_val49) -> (case _val49 of {T.TI32 _val51 -> P.toEnum $ P.fromIntegral _val51; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AgeCheckDocomoResult _ = P.error "not a struct"
read_AgeCheckDocomoResult :: T.Protocol p => p -> P.IO AgeCheckDocomoResult
read_AgeCheckDocomoResult iprot = to_AgeCheckDocomoResult <$> T.readVal iprot (T.T_STRUCT typemap_AgeCheckDocomoResult)
decode_AgeCheckDocomoResult :: T.StatelessProtocol p => p -> LBS.ByteString -> AgeCheckDocomoResult
decode_AgeCheckDocomoResult iprot bs = to_AgeCheckDocomoResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AgeCheckDocomoResult) bs
typemap_AgeCheckDocomoResult :: T.TypeMap
typemap_AgeCheckDocomoResult = Map.fromList [(1,("authUrl",T.T_STRING)),(2,("userAgeType",T.T_I32))]
default_AgeCheckDocomoResult :: AgeCheckDocomoResult
default_AgeCheckDocomoResult = AgeCheckDocomoResult{
  ageCheckDocomoResult_authUrl = "",
  ageCheckDocomoResult_userAgeType = (P.toEnum 0)}
data AgeCheckRequestResult = AgeCheckRequestResult  { ageCheckRequestResult_authUrl :: LT.Text
  , ageCheckRequestResult_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AgeCheckRequestResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` ageCheckRequestResult_authUrl record   `H.hashWithSalt` ageCheckRequestResult_sessionId record  
instance QC.Arbitrary AgeCheckRequestResult where 
  arbitrary = M.liftM AgeCheckRequestResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AgeCheckRequestResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AgeCheckRequestResult{ageCheckRequestResult_authUrl = ageCheckRequestResult_authUrl obj} then P.Nothing else P.Just $ default_AgeCheckRequestResult{ageCheckRequestResult_authUrl = ageCheckRequestResult_authUrl obj}
    , if obj == default_AgeCheckRequestResult{ageCheckRequestResult_sessionId = ageCheckRequestResult_sessionId obj} then P.Nothing else P.Just $ default_AgeCheckRequestResult{ageCheckRequestResult_sessionId = ageCheckRequestResult_sessionId obj}
    ]
from_AgeCheckRequestResult :: AgeCheckRequestResult -> T.ThriftVal
from_AgeCheckRequestResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v54 -> P.Just (1, ("authUrl",T.TString $ E.encodeUtf8 _v54))) $ ageCheckRequestResult_authUrl record
  , (\_v54 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v54))) $ ageCheckRequestResult_sessionId record
  ]
write_AgeCheckRequestResult :: T.Protocol p => p -> AgeCheckRequestResult -> P.IO ()
write_AgeCheckRequestResult oprot record = T.writeVal oprot $ from_AgeCheckRequestResult record
encode_AgeCheckRequestResult :: T.StatelessProtocol p => p -> AgeCheckRequestResult -> LBS.ByteString
encode_AgeCheckRequestResult oprot record = T.serializeVal oprot $ from_AgeCheckRequestResult record
to_AgeCheckRequestResult :: T.ThriftVal -> AgeCheckRequestResult
to_AgeCheckRequestResult (T.TStruct fields) = AgeCheckRequestResult{
  ageCheckRequestResult_authUrl = P.maybe (ageCheckRequestResult_authUrl default_AgeCheckRequestResult) (\(_,_val56) -> (case _val56 of {T.TString _val57 -> E.decodeUtf8 _val57; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ageCheckRequestResult_sessionId = P.maybe (ageCheckRequestResult_sessionId default_AgeCheckRequestResult) (\(_,_val56) -> (case _val56 of {T.TString _val58 -> E.decodeUtf8 _val58; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AgeCheckRequestResult _ = P.error "not a struct"
read_AgeCheckRequestResult :: T.Protocol p => p -> P.IO AgeCheckRequestResult
read_AgeCheckRequestResult iprot = to_AgeCheckRequestResult <$> T.readVal iprot (T.T_STRUCT typemap_AgeCheckRequestResult)
decode_AgeCheckRequestResult :: T.StatelessProtocol p => p -> LBS.ByteString -> AgeCheckRequestResult
decode_AgeCheckRequestResult iprot bs = to_AgeCheckRequestResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AgeCheckRequestResult) bs
typemap_AgeCheckRequestResult :: T.TypeMap
typemap_AgeCheckRequestResult = Map.fromList [(1,("authUrl",T.T_STRING)),(2,("sessionId",T.T_STRING))]
default_AgeCheckRequestResult :: AgeCheckRequestResult
default_AgeCheckRequestResult = AgeCheckRequestResult{
  ageCheckRequestResult_authUrl = "",
  ageCheckRequestResult_sessionId = ""}
data TextMessageAnnouncementContents = TextMessageAnnouncementContents  { textMessageAnnouncementContents_messageId :: LT.Text
  , textMessageAnnouncementContents_text :: LT.Text
  , textMessageAnnouncementContents_senderSquareMemberMid :: LT.Text
  , textMessageAnnouncementContents_createdAt :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TextMessageAnnouncementContents where
  hashWithSalt salt record = salt   `H.hashWithSalt` textMessageAnnouncementContents_messageId record   `H.hashWithSalt` textMessageAnnouncementContents_text record   `H.hashWithSalt` textMessageAnnouncementContents_senderSquareMemberMid record   `H.hashWithSalt` textMessageAnnouncementContents_createdAt record  
instance QC.Arbitrary TextMessageAnnouncementContents where 
  arbitrary = M.liftM TextMessageAnnouncementContents (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TextMessageAnnouncementContents = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TextMessageAnnouncementContents{textMessageAnnouncementContents_messageId = textMessageAnnouncementContents_messageId obj} then P.Nothing else P.Just $ default_TextMessageAnnouncementContents{textMessageAnnouncementContents_messageId = textMessageAnnouncementContents_messageId obj}
    , if obj == default_TextMessageAnnouncementContents{textMessageAnnouncementContents_text = textMessageAnnouncementContents_text obj} then P.Nothing else P.Just $ default_TextMessageAnnouncementContents{textMessageAnnouncementContents_text = textMessageAnnouncementContents_text obj}
    , if obj == default_TextMessageAnnouncementContents{textMessageAnnouncementContents_senderSquareMemberMid = textMessageAnnouncementContents_senderSquareMemberMid obj} then P.Nothing else P.Just $ default_TextMessageAnnouncementContents{textMessageAnnouncementContents_senderSquareMemberMid = textMessageAnnouncementContents_senderSquareMemberMid obj}
    , if obj == default_TextMessageAnnouncementContents{textMessageAnnouncementContents_createdAt = textMessageAnnouncementContents_createdAt obj} then P.Nothing else P.Just $ default_TextMessageAnnouncementContents{textMessageAnnouncementContents_createdAt = textMessageAnnouncementContents_createdAt obj}
    ]
from_TextMessageAnnouncementContents :: TextMessageAnnouncementContents -> T.ThriftVal
from_TextMessageAnnouncementContents record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v61 -> P.Just (1, ("messageId",T.TString $ E.encodeUtf8 _v61))) $ textMessageAnnouncementContents_messageId record
  , (\_v61 -> P.Just (2, ("text",T.TString $ E.encodeUtf8 _v61))) $ textMessageAnnouncementContents_text record
  , (\_v61 -> P.Just (3, ("senderSquareMemberMid",T.TString $ E.encodeUtf8 _v61))) $ textMessageAnnouncementContents_senderSquareMemberMid record
  , (\_v61 -> P.Just (4, ("createdAt",T.TI64 _v61))) $ textMessageAnnouncementContents_createdAt record
  ]
write_TextMessageAnnouncementContents :: T.Protocol p => p -> TextMessageAnnouncementContents -> P.IO ()
write_TextMessageAnnouncementContents oprot record = T.writeVal oprot $ from_TextMessageAnnouncementContents record
encode_TextMessageAnnouncementContents :: T.StatelessProtocol p => p -> TextMessageAnnouncementContents -> LBS.ByteString
encode_TextMessageAnnouncementContents oprot record = T.serializeVal oprot $ from_TextMessageAnnouncementContents record
to_TextMessageAnnouncementContents :: T.ThriftVal -> TextMessageAnnouncementContents
to_TextMessageAnnouncementContents (T.TStruct fields) = TextMessageAnnouncementContents{
  textMessageAnnouncementContents_messageId = P.maybe (textMessageAnnouncementContents_messageId default_TextMessageAnnouncementContents) (\(_,_val63) -> (case _val63 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  textMessageAnnouncementContents_text = P.maybe (textMessageAnnouncementContents_text default_TextMessageAnnouncementContents) (\(_,_val63) -> (case _val63 of {T.TString _val65 -> E.decodeUtf8 _val65; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  textMessageAnnouncementContents_senderSquareMemberMid = P.maybe (textMessageAnnouncementContents_senderSquareMemberMid default_TextMessageAnnouncementContents) (\(_,_val63) -> (case _val63 of {T.TString _val66 -> E.decodeUtf8 _val66; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  textMessageAnnouncementContents_createdAt = P.maybe (textMessageAnnouncementContents_createdAt default_TextMessageAnnouncementContents) (\(_,_val63) -> (case _val63 of {T.TI64 _val67 -> _val67; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TextMessageAnnouncementContents _ = P.error "not a struct"
read_TextMessageAnnouncementContents :: T.Protocol p => p -> P.IO TextMessageAnnouncementContents
read_TextMessageAnnouncementContents iprot = to_TextMessageAnnouncementContents <$> T.readVal iprot (T.T_STRUCT typemap_TextMessageAnnouncementContents)
decode_TextMessageAnnouncementContents :: T.StatelessProtocol p => p -> LBS.ByteString -> TextMessageAnnouncementContents
decode_TextMessageAnnouncementContents iprot bs = to_TextMessageAnnouncementContents $ T.deserializeVal iprot (T.T_STRUCT typemap_TextMessageAnnouncementContents) bs
typemap_TextMessageAnnouncementContents :: T.TypeMap
typemap_TextMessageAnnouncementContents = Map.fromList [(1,("messageId",T.T_STRING)),(2,("text",T.T_STRING)),(3,("senderSquareMemberMid",T.T_STRING)),(4,("createdAt",T.T_I64))]
default_TextMessageAnnouncementContents :: TextMessageAnnouncementContents
default_TextMessageAnnouncementContents = TextMessageAnnouncementContents{
  textMessageAnnouncementContents_messageId = "",
  textMessageAnnouncementContents_text = "",
  textMessageAnnouncementContents_senderSquareMemberMid = "",
  textMessageAnnouncementContents_createdAt = 0}
data SquareChatAnnouncementContents = SquareChatAnnouncementContents  { squareChatAnnouncementContents_textMessageAnnouncementContents :: TextMessageAnnouncementContents
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChatAnnouncementContents where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChatAnnouncementContents_textMessageAnnouncementContents record  
instance QC.Arbitrary SquareChatAnnouncementContents where 
  arbitrary = M.liftM SquareChatAnnouncementContents (QC.arbitrary)
  shrink obj | obj == default_SquareChatAnnouncementContents = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChatAnnouncementContents{squareChatAnnouncementContents_textMessageAnnouncementContents = squareChatAnnouncementContents_textMessageAnnouncementContents obj} then P.Nothing else P.Just $ default_SquareChatAnnouncementContents{squareChatAnnouncementContents_textMessageAnnouncementContents = squareChatAnnouncementContents_textMessageAnnouncementContents obj}
    ]
from_SquareChatAnnouncementContents :: SquareChatAnnouncementContents -> T.ThriftVal
from_SquareChatAnnouncementContents record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v70 -> P.Just (1, ("textMessageAnnouncementContents",from_TextMessageAnnouncementContents _v70))) $ squareChatAnnouncementContents_textMessageAnnouncementContents record
  ]
write_SquareChatAnnouncementContents :: T.Protocol p => p -> SquareChatAnnouncementContents -> P.IO ()
write_SquareChatAnnouncementContents oprot record = T.writeVal oprot $ from_SquareChatAnnouncementContents record
encode_SquareChatAnnouncementContents :: T.StatelessProtocol p => p -> SquareChatAnnouncementContents -> LBS.ByteString
encode_SquareChatAnnouncementContents oprot record = T.serializeVal oprot $ from_SquareChatAnnouncementContents record
to_SquareChatAnnouncementContents :: T.ThriftVal -> SquareChatAnnouncementContents
to_SquareChatAnnouncementContents (T.TStruct fields) = SquareChatAnnouncementContents{
  squareChatAnnouncementContents_textMessageAnnouncementContents = P.maybe (squareChatAnnouncementContents_textMessageAnnouncementContents default_SquareChatAnnouncementContents) (\(_,_val72) -> (case _val72 of {T.TStruct _val73 -> (to_TextMessageAnnouncementContents (T.TStruct _val73)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SquareChatAnnouncementContents _ = P.error "not a struct"
read_SquareChatAnnouncementContents :: T.Protocol p => p -> P.IO SquareChatAnnouncementContents
read_SquareChatAnnouncementContents iprot = to_SquareChatAnnouncementContents <$> T.readVal iprot (T.T_STRUCT typemap_SquareChatAnnouncementContents)
decode_SquareChatAnnouncementContents :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChatAnnouncementContents
decode_SquareChatAnnouncementContents iprot bs = to_SquareChatAnnouncementContents $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChatAnnouncementContents) bs
typemap_SquareChatAnnouncementContents :: T.TypeMap
typemap_SquareChatAnnouncementContents = Map.fromList [(1,("textMessageAnnouncementContents",(T.T_STRUCT typemap_TextMessageAnnouncementContents)))]
default_SquareChatAnnouncementContents :: SquareChatAnnouncementContents
default_SquareChatAnnouncementContents = SquareChatAnnouncementContents{
  squareChatAnnouncementContents_textMessageAnnouncementContents = default_TextMessageAnnouncementContents}
data SquareChatAnnouncement = SquareChatAnnouncement  { squareChatAnnouncement_announcementSeq :: I.Int64
  , squareChatAnnouncement_type :: SquareChatAnnouncementType
  , squareChatAnnouncement_contents :: SquareChatAnnouncementContents
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChatAnnouncement where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChatAnnouncement_announcementSeq record   `H.hashWithSalt` squareChatAnnouncement_type record   `H.hashWithSalt` squareChatAnnouncement_contents record  
instance QC.Arbitrary SquareChatAnnouncement where 
  arbitrary = M.liftM SquareChatAnnouncement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareChatAnnouncement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChatAnnouncement{squareChatAnnouncement_announcementSeq = squareChatAnnouncement_announcementSeq obj} then P.Nothing else P.Just $ default_SquareChatAnnouncement{squareChatAnnouncement_announcementSeq = squareChatAnnouncement_announcementSeq obj}
    , if obj == default_SquareChatAnnouncement{squareChatAnnouncement_type = squareChatAnnouncement_type obj} then P.Nothing else P.Just $ default_SquareChatAnnouncement{squareChatAnnouncement_type = squareChatAnnouncement_type obj}
    , if obj == default_SquareChatAnnouncement{squareChatAnnouncement_contents = squareChatAnnouncement_contents obj} then P.Nothing else P.Just $ default_SquareChatAnnouncement{squareChatAnnouncement_contents = squareChatAnnouncement_contents obj}
    ]
from_SquareChatAnnouncement :: SquareChatAnnouncement -> T.ThriftVal
from_SquareChatAnnouncement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v76 -> P.Just (1, ("announcementSeq",T.TI64 _v76))) $ squareChatAnnouncement_announcementSeq record
  , (\_v76 -> P.Just (2, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v76))) $ squareChatAnnouncement_type record
  , (\_v76 -> P.Just (3, ("contents",from_SquareChatAnnouncementContents _v76))) $ squareChatAnnouncement_contents record
  ]
write_SquareChatAnnouncement :: T.Protocol p => p -> SquareChatAnnouncement -> P.IO ()
write_SquareChatAnnouncement oprot record = T.writeVal oprot $ from_SquareChatAnnouncement record
encode_SquareChatAnnouncement :: T.StatelessProtocol p => p -> SquareChatAnnouncement -> LBS.ByteString
encode_SquareChatAnnouncement oprot record = T.serializeVal oprot $ from_SquareChatAnnouncement record
to_SquareChatAnnouncement :: T.ThriftVal -> SquareChatAnnouncement
to_SquareChatAnnouncement (T.TStruct fields) = SquareChatAnnouncement{
  squareChatAnnouncement_announcementSeq = P.maybe (squareChatAnnouncement_announcementSeq default_SquareChatAnnouncement) (\(_,_val78) -> (case _val78 of {T.TI64 _val79 -> _val79; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareChatAnnouncement_type = P.maybe (squareChatAnnouncement_type default_SquareChatAnnouncement) (\(_,_val78) -> (case _val78 of {T.TI32 _val80 -> P.toEnum $ P.fromIntegral _val80; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareChatAnnouncement_contents = P.maybe (squareChatAnnouncement_contents default_SquareChatAnnouncement) (\(_,_val78) -> (case _val78 of {T.TStruct _val81 -> (to_SquareChatAnnouncementContents (T.TStruct _val81)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareChatAnnouncement _ = P.error "not a struct"
read_SquareChatAnnouncement :: T.Protocol p => p -> P.IO SquareChatAnnouncement
read_SquareChatAnnouncement iprot = to_SquareChatAnnouncement <$> T.readVal iprot (T.T_STRUCT typemap_SquareChatAnnouncement)
decode_SquareChatAnnouncement :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChatAnnouncement
decode_SquareChatAnnouncement iprot bs = to_SquareChatAnnouncement $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChatAnnouncement) bs
typemap_SquareChatAnnouncement :: T.TypeMap
typemap_SquareChatAnnouncement = Map.fromList [(1,("announcementSeq",T.T_I64)),(2,("type",T.T_I32)),(3,("contents",(T.T_STRUCT typemap_SquareChatAnnouncementContents)))]
default_SquareChatAnnouncement :: SquareChatAnnouncement
default_SquareChatAnnouncement = SquareChatAnnouncement{
  squareChatAnnouncement_announcementSeq = 0,
  squareChatAnnouncement_type = (P.toEnum 0),
  squareChatAnnouncement_contents = default_SquareChatAnnouncementContents}
data Announcement = Announcement  { announcement_index :: I.Int32
  , announcement_forceUpdate :: P.Bool
  , announcement_title :: LT.Text
  , announcement_text :: LT.Text
  , announcement_createdTime :: I.Int64
  , announcement_pictureUrl :: LT.Text
  , announcement_thumbnailUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Announcement where
  hashWithSalt salt record = salt   `H.hashWithSalt` announcement_index record   `H.hashWithSalt` announcement_forceUpdate record   `H.hashWithSalt` announcement_title record   `H.hashWithSalt` announcement_text record   `H.hashWithSalt` announcement_createdTime record   `H.hashWithSalt` announcement_pictureUrl record   `H.hashWithSalt` announcement_thumbnailUrl record  
instance QC.Arbitrary Announcement where 
  arbitrary = M.liftM Announcement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Announcement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Announcement{announcement_index = announcement_index obj} then P.Nothing else P.Just $ default_Announcement{announcement_index = announcement_index obj}
    , if obj == default_Announcement{announcement_forceUpdate = announcement_forceUpdate obj} then P.Nothing else P.Just $ default_Announcement{announcement_forceUpdate = announcement_forceUpdate obj}
    , if obj == default_Announcement{announcement_title = announcement_title obj} then P.Nothing else P.Just $ default_Announcement{announcement_title = announcement_title obj}
    , if obj == default_Announcement{announcement_text = announcement_text obj} then P.Nothing else P.Just $ default_Announcement{announcement_text = announcement_text obj}
    , if obj == default_Announcement{announcement_createdTime = announcement_createdTime obj} then P.Nothing else P.Just $ default_Announcement{announcement_createdTime = announcement_createdTime obj}
    , if obj == default_Announcement{announcement_pictureUrl = announcement_pictureUrl obj} then P.Nothing else P.Just $ default_Announcement{announcement_pictureUrl = announcement_pictureUrl obj}
    , if obj == default_Announcement{announcement_thumbnailUrl = announcement_thumbnailUrl obj} then P.Nothing else P.Just $ default_Announcement{announcement_thumbnailUrl = announcement_thumbnailUrl obj}
    ]
from_Announcement :: Announcement -> T.ThriftVal
from_Announcement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v84 -> P.Just (1, ("index",T.TI32 _v84))) $ announcement_index record
  , (\_v84 -> P.Just (10, ("forceUpdate",T.TBool _v84))) $ announcement_forceUpdate record
  , (\_v84 -> P.Just (11, ("title",T.TString $ E.encodeUtf8 _v84))) $ announcement_title record
  , (\_v84 -> P.Just (12, ("text",T.TString $ E.encodeUtf8 _v84))) $ announcement_text record
  , (\_v84 -> P.Just (13, ("createdTime",T.TI64 _v84))) $ announcement_createdTime record
  , (\_v84 -> P.Just (14, ("pictureUrl",T.TString $ E.encodeUtf8 _v84))) $ announcement_pictureUrl record
  , (\_v84 -> P.Just (15, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v84))) $ announcement_thumbnailUrl record
  ]
write_Announcement :: T.Protocol p => p -> Announcement -> P.IO ()
write_Announcement oprot record = T.writeVal oprot $ from_Announcement record
encode_Announcement :: T.StatelessProtocol p => p -> Announcement -> LBS.ByteString
encode_Announcement oprot record = T.serializeVal oprot $ from_Announcement record
to_Announcement :: T.ThriftVal -> Announcement
to_Announcement (T.TStruct fields) = Announcement{
  announcement_index = P.maybe (announcement_index default_Announcement) (\(_,_val86) -> (case _val86 of {T.TI32 _val87 -> _val87; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  announcement_forceUpdate = P.maybe (announcement_forceUpdate default_Announcement) (\(_,_val86) -> (case _val86 of {T.TBool _val88 -> _val88; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  announcement_title = P.maybe (announcement_title default_Announcement) (\(_,_val86) -> (case _val86 of {T.TString _val89 -> E.decodeUtf8 _val89; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  announcement_text = P.maybe (announcement_text default_Announcement) (\(_,_val86) -> (case _val86 of {T.TString _val90 -> E.decodeUtf8 _val90; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  announcement_createdTime = P.maybe (announcement_createdTime default_Announcement) (\(_,_val86) -> (case _val86 of {T.TI64 _val91 -> _val91; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  announcement_pictureUrl = P.maybe (announcement_pictureUrl default_Announcement) (\(_,_val86) -> (case _val86 of {T.TString _val92 -> E.decodeUtf8 _val92; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  announcement_thumbnailUrl = P.maybe (announcement_thumbnailUrl default_Announcement) (\(_,_val86) -> (case _val86 of {T.TString _val93 -> E.decodeUtf8 _val93; _ -> P.error "wrong type"})) (Map.lookup (15) fields)
  }
to_Announcement _ = P.error "not a struct"
read_Announcement :: T.Protocol p => p -> P.IO Announcement
read_Announcement iprot = to_Announcement <$> T.readVal iprot (T.T_STRUCT typemap_Announcement)
decode_Announcement :: T.StatelessProtocol p => p -> LBS.ByteString -> Announcement
decode_Announcement iprot bs = to_Announcement $ T.deserializeVal iprot (T.T_STRUCT typemap_Announcement) bs
typemap_Announcement :: T.TypeMap
typemap_Announcement = Map.fromList [(1,("index",T.T_I32)),(10,("forceUpdate",T.T_BOOL)),(11,("title",T.T_STRING)),(12,("text",T.T_STRING)),(13,("createdTime",T.T_I64)),(14,("pictureUrl",T.T_STRING)),(15,("thumbnailUrl",T.T_STRING))]
default_Announcement :: Announcement
default_Announcement = Announcement{
  announcement_index = 0,
  announcement_forceUpdate = P.False,
  announcement_title = "",
  announcement_text = "",
  announcement_createdTime = 0,
  announcement_pictureUrl = "",
  announcement_thumbnailUrl = ""}
data ChannelProvider = ChannelProvider  { channelProvider_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelProvider where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelProvider_name record  
instance QC.Arbitrary ChannelProvider where 
  arbitrary = M.liftM ChannelProvider (QC.arbitrary)
  shrink obj | obj == default_ChannelProvider = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelProvider{channelProvider_name = channelProvider_name obj} then P.Nothing else P.Just $ default_ChannelProvider{channelProvider_name = channelProvider_name obj}
    ]
from_ChannelProvider :: ChannelProvider -> T.ThriftVal
from_ChannelProvider record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v96 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v96))) $ channelProvider_name record
  ]
write_ChannelProvider :: T.Protocol p => p -> ChannelProvider -> P.IO ()
write_ChannelProvider oprot record = T.writeVal oprot $ from_ChannelProvider record
encode_ChannelProvider :: T.StatelessProtocol p => p -> ChannelProvider -> LBS.ByteString
encode_ChannelProvider oprot record = T.serializeVal oprot $ from_ChannelProvider record
to_ChannelProvider :: T.ThriftVal -> ChannelProvider
to_ChannelProvider (T.TStruct fields) = ChannelProvider{
  channelProvider_name = P.maybe (channelProvider_name default_ChannelProvider) (\(_,_val98) -> (case _val98 of {T.TString _val99 -> E.decodeUtf8 _val99; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ChannelProvider _ = P.error "not a struct"
read_ChannelProvider :: T.Protocol p => p -> P.IO ChannelProvider
read_ChannelProvider iprot = to_ChannelProvider <$> T.readVal iprot (T.T_STRUCT typemap_ChannelProvider)
decode_ChannelProvider :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelProvider
decode_ChannelProvider iprot bs = to_ChannelProvider $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelProvider) bs
typemap_ChannelProvider :: T.TypeMap
typemap_ChannelProvider = Map.fromList [(1,("name",T.T_STRING))]
default_ChannelProvider :: ChannelProvider
default_ChannelProvider = ChannelProvider{
  channelProvider_name = ""}
data E2EEPublicKey = E2EEPublicKey  { e2EEPublicKey_version :: I.Int32
  , e2EEPublicKey_keyId :: I.Int32
  , e2EEPublicKey_keyData :: LBS.ByteString
  , e2EEPublicKey_createdTime :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable E2EEPublicKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` e2EEPublicKey_version record   `H.hashWithSalt` e2EEPublicKey_keyId record   `H.hashWithSalt` e2EEPublicKey_keyData record   `H.hashWithSalt` e2EEPublicKey_createdTime record  
instance QC.Arbitrary E2EEPublicKey where 
  arbitrary = M.liftM E2EEPublicKey (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_E2EEPublicKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_E2EEPublicKey{e2EEPublicKey_version = e2EEPublicKey_version obj} then P.Nothing else P.Just $ default_E2EEPublicKey{e2EEPublicKey_version = e2EEPublicKey_version obj}
    , if obj == default_E2EEPublicKey{e2EEPublicKey_keyId = e2EEPublicKey_keyId obj} then P.Nothing else P.Just $ default_E2EEPublicKey{e2EEPublicKey_keyId = e2EEPublicKey_keyId obj}
    , if obj == default_E2EEPublicKey{e2EEPublicKey_keyData = e2EEPublicKey_keyData obj} then P.Nothing else P.Just $ default_E2EEPublicKey{e2EEPublicKey_keyData = e2EEPublicKey_keyData obj}
    , if obj == default_E2EEPublicKey{e2EEPublicKey_createdTime = e2EEPublicKey_createdTime obj} then P.Nothing else P.Just $ default_E2EEPublicKey{e2EEPublicKey_createdTime = e2EEPublicKey_createdTime obj}
    ]
from_E2EEPublicKey :: E2EEPublicKey -> T.ThriftVal
from_E2EEPublicKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v102 -> P.Just (1, ("version",T.TI32 _v102))) $ e2EEPublicKey_version record
  , (\_v102 -> P.Just (2, ("keyId",T.TI32 _v102))) $ e2EEPublicKey_keyId record
  , (\_v102 -> P.Just (4, ("keyData",T.TBinary _v102))) $ e2EEPublicKey_keyData record
  , (\_v102 -> P.Just (5, ("createdTime",T.TI64 _v102))) $ e2EEPublicKey_createdTime record
  ]
write_E2EEPublicKey :: T.Protocol p => p -> E2EEPublicKey -> P.IO ()
write_E2EEPublicKey oprot record = T.writeVal oprot $ from_E2EEPublicKey record
encode_E2EEPublicKey :: T.StatelessProtocol p => p -> E2EEPublicKey -> LBS.ByteString
encode_E2EEPublicKey oprot record = T.serializeVal oprot $ from_E2EEPublicKey record
to_E2EEPublicKey :: T.ThriftVal -> E2EEPublicKey
to_E2EEPublicKey (T.TStruct fields) = E2EEPublicKey{
  e2EEPublicKey_version = P.maybe (e2EEPublicKey_version default_E2EEPublicKey) (\(_,_val104) -> (case _val104 of {T.TI32 _val105 -> _val105; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  e2EEPublicKey_keyId = P.maybe (e2EEPublicKey_keyId default_E2EEPublicKey) (\(_,_val104) -> (case _val104 of {T.TI32 _val106 -> _val106; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  e2EEPublicKey_keyData = P.maybe (e2EEPublicKey_keyData default_E2EEPublicKey) (\(_,_val104) -> (case _val104 of {T.TBinary _val107 -> _val107; T.TString _val107 -> _val107; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  e2EEPublicKey_createdTime = P.maybe (e2EEPublicKey_createdTime default_E2EEPublicKey) (\(_,_val104) -> (case _val104 of {T.TI64 _val108 -> _val108; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_E2EEPublicKey _ = P.error "not a struct"
read_E2EEPublicKey :: T.Protocol p => p -> P.IO E2EEPublicKey
read_E2EEPublicKey iprot = to_E2EEPublicKey <$> T.readVal iprot (T.T_STRUCT typemap_E2EEPublicKey)
decode_E2EEPublicKey :: T.StatelessProtocol p => p -> LBS.ByteString -> E2EEPublicKey
decode_E2EEPublicKey iprot bs = to_E2EEPublicKey $ T.deserializeVal iprot (T.T_STRUCT typemap_E2EEPublicKey) bs
typemap_E2EEPublicKey :: T.TypeMap
typemap_E2EEPublicKey = Map.fromList [(1,("version",T.T_I32)),(2,("keyId",T.T_I32)),(4,("keyData",T.T_BINARY)),(5,("createdTime",T.T_I64))]
default_E2EEPublicKey :: E2EEPublicKey
default_E2EEPublicKey = E2EEPublicKey{
  e2EEPublicKey_version = 0,
  e2EEPublicKey_keyId = 0,
  e2EEPublicKey_keyData = "",
  e2EEPublicKey_createdTime = 0}
data ChannelDomain = ChannelDomain  { channelDomain_host :: LT.Text
  , channelDomain_removed :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelDomain where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelDomain_host record   `H.hashWithSalt` channelDomain_removed record  
instance QC.Arbitrary ChannelDomain where 
  arbitrary = M.liftM ChannelDomain (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelDomain = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelDomain{channelDomain_host = channelDomain_host obj} then P.Nothing else P.Just $ default_ChannelDomain{channelDomain_host = channelDomain_host obj}
    , if obj == default_ChannelDomain{channelDomain_removed = channelDomain_removed obj} then P.Nothing else P.Just $ default_ChannelDomain{channelDomain_removed = channelDomain_removed obj}
    ]
from_ChannelDomain :: ChannelDomain -> T.ThriftVal
from_ChannelDomain record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v111 -> P.Just (1, ("host",T.TString $ E.encodeUtf8 _v111))) $ channelDomain_host record
  , (\_v111 -> P.Just (2, ("removed",T.TBool _v111))) $ channelDomain_removed record
  ]
write_ChannelDomain :: T.Protocol p => p -> ChannelDomain -> P.IO ()
write_ChannelDomain oprot record = T.writeVal oprot $ from_ChannelDomain record
encode_ChannelDomain :: T.StatelessProtocol p => p -> ChannelDomain -> LBS.ByteString
encode_ChannelDomain oprot record = T.serializeVal oprot $ from_ChannelDomain record
to_ChannelDomain :: T.ThriftVal -> ChannelDomain
to_ChannelDomain (T.TStruct fields) = ChannelDomain{
  channelDomain_host = P.maybe (channelDomain_host default_ChannelDomain) (\(_,_val113) -> (case _val113 of {T.TString _val114 -> E.decodeUtf8 _val114; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelDomain_removed = P.maybe (channelDomain_removed default_ChannelDomain) (\(_,_val113) -> (case _val113 of {T.TBool _val115 -> _val115; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelDomain _ = P.error "not a struct"
read_ChannelDomain :: T.Protocol p => p -> P.IO ChannelDomain
read_ChannelDomain iprot = to_ChannelDomain <$> T.readVal iprot (T.T_STRUCT typemap_ChannelDomain)
decode_ChannelDomain :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelDomain
decode_ChannelDomain iprot bs = to_ChannelDomain $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelDomain) bs
typemap_ChannelDomain :: T.TypeMap
typemap_ChannelDomain = Map.fromList [(1,("host",T.T_STRING)),(2,("removed",T.T_BOOL))]
default_ChannelDomain :: ChannelDomain
default_ChannelDomain = ChannelDomain{
  channelDomain_host = "",
  channelDomain_removed = P.False}
data E2EENegotiationResult = E2EENegotiationResult  { e2EENegotiationResult_allowedTypes :: (Set.HashSet ContentType)
  , e2EENegotiationResult_publicKey :: E2EEPublicKey
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable E2EENegotiationResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` e2EENegotiationResult_allowedTypes record   `H.hashWithSalt` e2EENegotiationResult_publicKey record  
instance QC.Arbitrary E2EENegotiationResult where 
  arbitrary = M.liftM E2EENegotiationResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_E2EENegotiationResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_E2EENegotiationResult{e2EENegotiationResult_allowedTypes = e2EENegotiationResult_allowedTypes obj} then P.Nothing else P.Just $ default_E2EENegotiationResult{e2EENegotiationResult_allowedTypes = e2EENegotiationResult_allowedTypes obj}
    , if obj == default_E2EENegotiationResult{e2EENegotiationResult_publicKey = e2EENegotiationResult_publicKey obj} then P.Nothing else P.Just $ default_E2EENegotiationResult{e2EENegotiationResult_publicKey = e2EENegotiationResult_publicKey obj}
    ]
from_E2EENegotiationResult :: E2EENegotiationResult -> T.ThriftVal
from_E2EENegotiationResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v118 -> P.Just (1, ("allowedTypes",T.TSet T.T_I32 $ P.map (\_v120 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v120) $ Set.toList _v118))) $ e2EENegotiationResult_allowedTypes record
  , (\_v118 -> P.Just (2, ("publicKey",from_E2EEPublicKey _v118))) $ e2EENegotiationResult_publicKey record
  ]
write_E2EENegotiationResult :: T.Protocol p => p -> E2EENegotiationResult -> P.IO ()
write_E2EENegotiationResult oprot record = T.writeVal oprot $ from_E2EENegotiationResult record
encode_E2EENegotiationResult :: T.StatelessProtocol p => p -> E2EENegotiationResult -> LBS.ByteString
encode_E2EENegotiationResult oprot record = T.serializeVal oprot $ from_E2EENegotiationResult record
to_E2EENegotiationResult :: T.ThriftVal -> E2EENegotiationResult
to_E2EENegotiationResult (T.TStruct fields) = E2EENegotiationResult{
  e2EENegotiationResult_allowedTypes = P.maybe (e2EENegotiationResult_allowedTypes default_E2EENegotiationResult) (\(_,_val122) -> (case _val122 of {T.TSet _ _val123 -> (Set.fromList $ P.map (\_v124 -> (case _v124 of {T.TI32 _val125 -> P.toEnum $ P.fromIntegral _val125; _ -> P.error "wrong type"})) _val123); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  e2EENegotiationResult_publicKey = P.maybe (e2EENegotiationResult_publicKey default_E2EENegotiationResult) (\(_,_val122) -> (case _val122 of {T.TStruct _val126 -> (to_E2EEPublicKey (T.TStruct _val126)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_E2EENegotiationResult _ = P.error "not a struct"
read_E2EENegotiationResult :: T.Protocol p => p -> P.IO E2EENegotiationResult
read_E2EENegotiationResult iprot = to_E2EENegotiationResult <$> T.readVal iprot (T.T_STRUCT typemap_E2EENegotiationResult)
decode_E2EENegotiationResult :: T.StatelessProtocol p => p -> LBS.ByteString -> E2EENegotiationResult
decode_E2EENegotiationResult iprot bs = to_E2EENegotiationResult $ T.deserializeVal iprot (T.T_STRUCT typemap_E2EENegotiationResult) bs
typemap_E2EENegotiationResult :: T.TypeMap
typemap_E2EENegotiationResult = Map.fromList [(1,("allowedTypes",(T.T_SET T.T_I32))),(2,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey)))]
default_E2EENegotiationResult :: E2EENegotiationResult
default_E2EENegotiationResult = E2EENegotiationResult{
  e2EENegotiationResult_allowedTypes = Set.empty,
  e2EENegotiationResult_publicKey = default_E2EEPublicKey}
data OTPResult = OTPResult  { oTPResult_otpId :: LT.Text
  , oTPResult_otp :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OTPResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` oTPResult_otpId record   `H.hashWithSalt` oTPResult_otp record  
instance QC.Arbitrary OTPResult where 
  arbitrary = M.liftM OTPResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_OTPResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OTPResult{oTPResult_otpId = oTPResult_otpId obj} then P.Nothing else P.Just $ default_OTPResult{oTPResult_otpId = oTPResult_otpId obj}
    , if obj == default_OTPResult{oTPResult_otp = oTPResult_otp obj} then P.Nothing else P.Just $ default_OTPResult{oTPResult_otp = oTPResult_otp obj}
    ]
from_OTPResult :: OTPResult -> T.ThriftVal
from_OTPResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v129 -> P.Just (1, ("otpId",T.TString $ E.encodeUtf8 _v129))) $ oTPResult_otpId record
  , (\_v129 -> P.Just (2, ("otp",T.TString $ E.encodeUtf8 _v129))) $ oTPResult_otp record
  ]
write_OTPResult :: T.Protocol p => p -> OTPResult -> P.IO ()
write_OTPResult oprot record = T.writeVal oprot $ from_OTPResult record
encode_OTPResult :: T.StatelessProtocol p => p -> OTPResult -> LBS.ByteString
encode_OTPResult oprot record = T.serializeVal oprot $ from_OTPResult record
to_OTPResult :: T.ThriftVal -> OTPResult
to_OTPResult (T.TStruct fields) = OTPResult{
  oTPResult_otpId = P.maybe (oTPResult_otpId default_OTPResult) (\(_,_val131) -> (case _val131 of {T.TString _val132 -> E.decodeUtf8 _val132; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  oTPResult_otp = P.maybe (oTPResult_otp default_OTPResult) (\(_,_val131) -> (case _val131 of {T.TString _val133 -> E.decodeUtf8 _val133; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_OTPResult _ = P.error "not a struct"
read_OTPResult :: T.Protocol p => p -> P.IO OTPResult
read_OTPResult iprot = to_OTPResult <$> T.readVal iprot (T.T_STRUCT typemap_OTPResult)
decode_OTPResult :: T.StatelessProtocol p => p -> LBS.ByteString -> OTPResult
decode_OTPResult iprot bs = to_OTPResult $ T.deserializeVal iprot (T.T_STRUCT typemap_OTPResult) bs
typemap_OTPResult :: T.TypeMap
typemap_OTPResult = Map.fromList [(1,("otpId",T.T_STRING)),(2,("otp",T.T_STRING))]
default_OTPResult :: OTPResult
default_OTPResult = OTPResult{
  oTPResult_otpId = "",
  oTPResult_otp = ""}
data Square = Square  { square_mid :: LT.Text
  , square_name :: LT.Text
  , square_welcomeMessage :: LT.Text
  , square_profileImageObsHash :: LT.Text
  , square_desc :: LT.Text
  , square_searchable :: P.Bool
  , square_type :: SquareType
  , square_categoryID :: I.Int32
  , square_invitationURL :: LT.Text
  , square_revision :: I.Int64
  , square_ableToUseInvitationTicket :: P.Bool
  , square_state :: SquareState
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Square where
  hashWithSalt salt record = salt   `H.hashWithSalt` square_mid record   `H.hashWithSalt` square_name record   `H.hashWithSalt` square_welcomeMessage record   `H.hashWithSalt` square_profileImageObsHash record   `H.hashWithSalt` square_desc record   `H.hashWithSalt` square_searchable record   `H.hashWithSalt` square_type record   `H.hashWithSalt` square_categoryID record   `H.hashWithSalt` square_invitationURL record   `H.hashWithSalt` square_revision record   `H.hashWithSalt` square_ableToUseInvitationTicket record   `H.hashWithSalt` square_state record  
instance QC.Arbitrary Square where 
  arbitrary = M.liftM Square (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Square = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Square{square_mid = square_mid obj} then P.Nothing else P.Just $ default_Square{square_mid = square_mid obj}
    , if obj == default_Square{square_name = square_name obj} then P.Nothing else P.Just $ default_Square{square_name = square_name obj}
    , if obj == default_Square{square_welcomeMessage = square_welcomeMessage obj} then P.Nothing else P.Just $ default_Square{square_welcomeMessage = square_welcomeMessage obj}
    , if obj == default_Square{square_profileImageObsHash = square_profileImageObsHash obj} then P.Nothing else P.Just $ default_Square{square_profileImageObsHash = square_profileImageObsHash obj}
    , if obj == default_Square{square_desc = square_desc obj} then P.Nothing else P.Just $ default_Square{square_desc = square_desc obj}
    , if obj == default_Square{square_searchable = square_searchable obj} then P.Nothing else P.Just $ default_Square{square_searchable = square_searchable obj}
    , if obj == default_Square{square_type = square_type obj} then P.Nothing else P.Just $ default_Square{square_type = square_type obj}
    , if obj == default_Square{square_categoryID = square_categoryID obj} then P.Nothing else P.Just $ default_Square{square_categoryID = square_categoryID obj}
    , if obj == default_Square{square_invitationURL = square_invitationURL obj} then P.Nothing else P.Just $ default_Square{square_invitationURL = square_invitationURL obj}
    , if obj == default_Square{square_revision = square_revision obj} then P.Nothing else P.Just $ default_Square{square_revision = square_revision obj}
    , if obj == default_Square{square_ableToUseInvitationTicket = square_ableToUseInvitationTicket obj} then P.Nothing else P.Just $ default_Square{square_ableToUseInvitationTicket = square_ableToUseInvitationTicket obj}
    , if obj == default_Square{square_state = square_state obj} then P.Nothing else P.Just $ default_Square{square_state = square_state obj}
    ]
from_Square :: Square -> T.ThriftVal
from_Square record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v136 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v136))) $ square_mid record
  , (\_v136 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v136))) $ square_name record
  , (\_v136 -> P.Just (3, ("welcomeMessage",T.TString $ E.encodeUtf8 _v136))) $ square_welcomeMessage record
  , (\_v136 -> P.Just (4, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v136))) $ square_profileImageObsHash record
  , (\_v136 -> P.Just (5, ("desc",T.TString $ E.encodeUtf8 _v136))) $ square_desc record
  , (\_v136 -> P.Just (6, ("searchable",T.TBool _v136))) $ square_searchable record
  , (\_v136 -> P.Just (7, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v136))) $ square_type record
  , (\_v136 -> P.Just (8, ("categoryID",T.TI32 _v136))) $ square_categoryID record
  , (\_v136 -> P.Just (9, ("invitationURL",T.TString $ E.encodeUtf8 _v136))) $ square_invitationURL record
  , (\_v136 -> P.Just (10, ("revision",T.TI64 _v136))) $ square_revision record
  , (\_v136 -> P.Just (11, ("ableToUseInvitationTicket",T.TBool _v136))) $ square_ableToUseInvitationTicket record
  , (\_v136 -> P.Just (12, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v136))) $ square_state record
  ]
write_Square :: T.Protocol p => p -> Square -> P.IO ()
write_Square oprot record = T.writeVal oprot $ from_Square record
encode_Square :: T.StatelessProtocol p => p -> Square -> LBS.ByteString
encode_Square oprot record = T.serializeVal oprot $ from_Square record
to_Square :: T.ThriftVal -> Square
to_Square (T.TStruct fields) = Square{
  square_mid = P.maybe (square_mid default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val139 -> E.decodeUtf8 _val139; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  square_name = P.maybe (square_name default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val140 -> E.decodeUtf8 _val140; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  square_welcomeMessage = P.maybe (square_welcomeMessage default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val141 -> E.decodeUtf8 _val141; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  square_profileImageObsHash = P.maybe (square_profileImageObsHash default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val142 -> E.decodeUtf8 _val142; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  square_desc = P.maybe (square_desc default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val143 -> E.decodeUtf8 _val143; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  square_searchable = P.maybe (square_searchable default_Square) (\(_,_val138) -> (case _val138 of {T.TBool _val144 -> _val144; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  square_type = P.maybe (square_type default_Square) (\(_,_val138) -> (case _val138 of {T.TI32 _val145 -> P.toEnum $ P.fromIntegral _val145; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  square_categoryID = P.maybe (square_categoryID default_Square) (\(_,_val138) -> (case _val138 of {T.TI32 _val146 -> _val146; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  square_invitationURL = P.maybe (square_invitationURL default_Square) (\(_,_val138) -> (case _val138 of {T.TString _val147 -> E.decodeUtf8 _val147; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  square_revision = P.maybe (square_revision default_Square) (\(_,_val138) -> (case _val138 of {T.TI64 _val148 -> _val148; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  square_ableToUseInvitationTicket = P.maybe (square_ableToUseInvitationTicket default_Square) (\(_,_val138) -> (case _val138 of {T.TBool _val149 -> _val149; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  square_state = P.maybe (square_state default_Square) (\(_,_val138) -> (case _val138 of {T.TI32 _val150 -> P.toEnum $ P.fromIntegral _val150; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_Square _ = P.error "not a struct"
read_Square :: T.Protocol p => p -> P.IO Square
read_Square iprot = to_Square <$> T.readVal iprot (T.T_STRUCT typemap_Square)
decode_Square :: T.StatelessProtocol p => p -> LBS.ByteString -> Square
decode_Square iprot bs = to_Square $ T.deserializeVal iprot (T.T_STRUCT typemap_Square) bs
typemap_Square :: T.TypeMap
typemap_Square = Map.fromList [(1,("mid",T.T_STRING)),(2,("name",T.T_STRING)),(3,("welcomeMessage",T.T_STRING)),(4,("profileImageObsHash",T.T_STRING)),(5,("desc",T.T_STRING)),(6,("searchable",T.T_BOOL)),(7,("type",T.T_I32)),(8,("categoryID",T.T_I32)),(9,("invitationURL",T.T_STRING)),(10,("revision",T.T_I64)),(11,("ableToUseInvitationTicket",T.T_BOOL)),(12,("state",T.T_I32))]
default_Square :: Square
default_Square = Square{
  square_mid = "",
  square_name = "",
  square_welcomeMessage = "",
  square_profileImageObsHash = "",
  square_desc = "",
  square_searchable = P.False,
  square_type = (P.toEnum 0),
  square_categoryID = 0,
  square_invitationURL = "",
  square_revision = 0,
  square_ableToUseInvitationTicket = P.False,
  square_state = (P.toEnum 0)}
data SquareAuthority = SquareAuthority  { squareAuthority_squareMid :: LT.Text
  , squareAuthority_updateSquareProfile :: SquareMemberRole
  , squareAuthority_inviteNewMember :: SquareMemberRole
  , squareAuthority_approveJoinRequest :: SquareMemberRole
  , squareAuthority_createPost :: SquareMemberRole
  , squareAuthority_createOpenSquareChat :: SquareMemberRole
  , squareAuthority_deleteSquareChatOrPost :: SquareMemberRole
  , squareAuthority_removeSquareMember :: SquareMemberRole
  , squareAuthority_grantRole :: SquareMemberRole
  , squareAuthority_enableInvitationTicket :: SquareMemberRole
  , squareAuthority_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareAuthority where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareAuthority_squareMid record   `H.hashWithSalt` squareAuthority_updateSquareProfile record   `H.hashWithSalt` squareAuthority_inviteNewMember record   `H.hashWithSalt` squareAuthority_approveJoinRequest record   `H.hashWithSalt` squareAuthority_createPost record   `H.hashWithSalt` squareAuthority_createOpenSquareChat record   `H.hashWithSalt` squareAuthority_deleteSquareChatOrPost record   `H.hashWithSalt` squareAuthority_removeSquareMember record   `H.hashWithSalt` squareAuthority_grantRole record   `H.hashWithSalt` squareAuthority_enableInvitationTicket record   `H.hashWithSalt` squareAuthority_revision record  
instance QC.Arbitrary SquareAuthority where 
  arbitrary = M.liftM SquareAuthority (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareAuthority = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareAuthority{squareAuthority_squareMid = squareAuthority_squareMid obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_squareMid = squareAuthority_squareMid obj}
    , if obj == default_SquareAuthority{squareAuthority_updateSquareProfile = squareAuthority_updateSquareProfile obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_updateSquareProfile = squareAuthority_updateSquareProfile obj}
    , if obj == default_SquareAuthority{squareAuthority_inviteNewMember = squareAuthority_inviteNewMember obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_inviteNewMember = squareAuthority_inviteNewMember obj}
    , if obj == default_SquareAuthority{squareAuthority_approveJoinRequest = squareAuthority_approveJoinRequest obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_approveJoinRequest = squareAuthority_approveJoinRequest obj}
    , if obj == default_SquareAuthority{squareAuthority_createPost = squareAuthority_createPost obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_createPost = squareAuthority_createPost obj}
    , if obj == default_SquareAuthority{squareAuthority_createOpenSquareChat = squareAuthority_createOpenSquareChat obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_createOpenSquareChat = squareAuthority_createOpenSquareChat obj}
    , if obj == default_SquareAuthority{squareAuthority_deleteSquareChatOrPost = squareAuthority_deleteSquareChatOrPost obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_deleteSquareChatOrPost = squareAuthority_deleteSquareChatOrPost obj}
    , if obj == default_SquareAuthority{squareAuthority_removeSquareMember = squareAuthority_removeSquareMember obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_removeSquareMember = squareAuthority_removeSquareMember obj}
    , if obj == default_SquareAuthority{squareAuthority_grantRole = squareAuthority_grantRole obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_grantRole = squareAuthority_grantRole obj}
    , if obj == default_SquareAuthority{squareAuthority_enableInvitationTicket = squareAuthority_enableInvitationTicket obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_enableInvitationTicket = squareAuthority_enableInvitationTicket obj}
    , if obj == default_SquareAuthority{squareAuthority_revision = squareAuthority_revision obj} then P.Nothing else P.Just $ default_SquareAuthority{squareAuthority_revision = squareAuthority_revision obj}
    ]
from_SquareAuthority :: SquareAuthority -> T.ThriftVal
from_SquareAuthority record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v153 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v153))) $ squareAuthority_squareMid record
  , (\_v153 -> P.Just (2, ("updateSquareProfile",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_updateSquareProfile record
  , (\_v153 -> P.Just (3, ("inviteNewMember",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_inviteNewMember record
  , (\_v153 -> P.Just (4, ("approveJoinRequest",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_approveJoinRequest record
  , (\_v153 -> P.Just (5, ("createPost",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_createPost record
  , (\_v153 -> P.Just (6, ("createOpenSquareChat",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_createOpenSquareChat record
  , (\_v153 -> P.Just (7, ("deleteSquareChatOrPost",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_deleteSquareChatOrPost record
  , (\_v153 -> P.Just (8, ("removeSquareMember",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_removeSquareMember record
  , (\_v153 -> P.Just (9, ("grantRole",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_grantRole record
  , (\_v153 -> P.Just (10, ("enableInvitationTicket",T.TI32 $ P.fromIntegral $ P.fromEnum _v153))) $ squareAuthority_enableInvitationTicket record
  , (\_v153 -> P.Just (11, ("revision",T.TI64 _v153))) $ squareAuthority_revision record
  ]
write_SquareAuthority :: T.Protocol p => p -> SquareAuthority -> P.IO ()
write_SquareAuthority oprot record = T.writeVal oprot $ from_SquareAuthority record
encode_SquareAuthority :: T.StatelessProtocol p => p -> SquareAuthority -> LBS.ByteString
encode_SquareAuthority oprot record = T.serializeVal oprot $ from_SquareAuthority record
to_SquareAuthority :: T.ThriftVal -> SquareAuthority
to_SquareAuthority (T.TStruct fields) = SquareAuthority{
  squareAuthority_squareMid = P.maybe (squareAuthority_squareMid default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TString _val156 -> E.decodeUtf8 _val156; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareAuthority_updateSquareProfile = P.maybe (squareAuthority_updateSquareProfile default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val157 -> P.toEnum $ P.fromIntegral _val157; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareAuthority_inviteNewMember = P.maybe (squareAuthority_inviteNewMember default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val158 -> P.toEnum $ P.fromIntegral _val158; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareAuthority_approveJoinRequest = P.maybe (squareAuthority_approveJoinRequest default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val159 -> P.toEnum $ P.fromIntegral _val159; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareAuthority_createPost = P.maybe (squareAuthority_createPost default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val160 -> P.toEnum $ P.fromIntegral _val160; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareAuthority_createOpenSquareChat = P.maybe (squareAuthority_createOpenSquareChat default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val161 -> P.toEnum $ P.fromIntegral _val161; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  squareAuthority_deleteSquareChatOrPost = P.maybe (squareAuthority_deleteSquareChatOrPost default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val162 -> P.toEnum $ P.fromIntegral _val162; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  squareAuthority_removeSquareMember = P.maybe (squareAuthority_removeSquareMember default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val163 -> P.toEnum $ P.fromIntegral _val163; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  squareAuthority_grantRole = P.maybe (squareAuthority_grantRole default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val164 -> P.toEnum $ P.fromIntegral _val164; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  squareAuthority_enableInvitationTicket = P.maybe (squareAuthority_enableInvitationTicket default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI32 _val165 -> P.toEnum $ P.fromIntegral _val165; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  squareAuthority_revision = P.maybe (squareAuthority_revision default_SquareAuthority) (\(_,_val155) -> (case _val155 of {T.TI64 _val166 -> _val166; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_SquareAuthority _ = P.error "not a struct"
read_SquareAuthority :: T.Protocol p => p -> P.IO SquareAuthority
read_SquareAuthority iprot = to_SquareAuthority <$> T.readVal iprot (T.T_STRUCT typemap_SquareAuthority)
decode_SquareAuthority :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareAuthority
decode_SquareAuthority iprot bs = to_SquareAuthority $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareAuthority) bs
typemap_SquareAuthority :: T.TypeMap
typemap_SquareAuthority = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("updateSquareProfile",T.T_I32)),(3,("inviteNewMember",T.T_I32)),(4,("approveJoinRequest",T.T_I32)),(5,("createPost",T.T_I32)),(6,("createOpenSquareChat",T.T_I32)),(7,("deleteSquareChatOrPost",T.T_I32)),(8,("removeSquareMember",T.T_I32)),(9,("grantRole",T.T_I32)),(10,("enableInvitationTicket",T.T_I32)),(11,("revision",T.T_I64))]
default_SquareAuthority :: SquareAuthority
default_SquareAuthority = SquareAuthority{
  squareAuthority_squareMid = "",
  squareAuthority_updateSquareProfile = (P.toEnum 0),
  squareAuthority_inviteNewMember = (P.toEnum 0),
  squareAuthority_approveJoinRequest = (P.toEnum 0),
  squareAuthority_createPost = (P.toEnum 0),
  squareAuthority_createOpenSquareChat = (P.toEnum 0),
  squareAuthority_deleteSquareChatOrPost = (P.toEnum 0),
  squareAuthority_removeSquareMember = (P.toEnum 0),
  squareAuthority_grantRole = (P.toEnum 0),
  squareAuthority_enableInvitationTicket = (P.toEnum 0),
  squareAuthority_revision = 0}
data SquarePreference = SquarePreference  { squarePreference_favoriteTimestamp :: I.Int64
  , squarePreference_notiForNewJoinRequest :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquarePreference where
  hashWithSalt salt record = salt   `H.hashWithSalt` squarePreference_favoriteTimestamp record   `H.hashWithSalt` squarePreference_notiForNewJoinRequest record  
instance QC.Arbitrary SquarePreference where 
  arbitrary = M.liftM SquarePreference (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquarePreference = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquarePreference{squarePreference_favoriteTimestamp = squarePreference_favoriteTimestamp obj} then P.Nothing else P.Just $ default_SquarePreference{squarePreference_favoriteTimestamp = squarePreference_favoriteTimestamp obj}
    , if obj == default_SquarePreference{squarePreference_notiForNewJoinRequest = squarePreference_notiForNewJoinRequest obj} then P.Nothing else P.Just $ default_SquarePreference{squarePreference_notiForNewJoinRequest = squarePreference_notiForNewJoinRequest obj}
    ]
from_SquarePreference :: SquarePreference -> T.ThriftVal
from_SquarePreference record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v169 -> P.Just (1, ("favoriteTimestamp",T.TI64 _v169))) $ squarePreference_favoriteTimestamp record
  , (\_v169 -> P.Just (2, ("notiForNewJoinRequest",T.TBool _v169))) $ squarePreference_notiForNewJoinRequest record
  ]
write_SquarePreference :: T.Protocol p => p -> SquarePreference -> P.IO ()
write_SquarePreference oprot record = T.writeVal oprot $ from_SquarePreference record
encode_SquarePreference :: T.StatelessProtocol p => p -> SquarePreference -> LBS.ByteString
encode_SquarePreference oprot record = T.serializeVal oprot $ from_SquarePreference record
to_SquarePreference :: T.ThriftVal -> SquarePreference
to_SquarePreference (T.TStruct fields) = SquarePreference{
  squarePreference_favoriteTimestamp = P.maybe (squarePreference_favoriteTimestamp default_SquarePreference) (\(_,_val171) -> (case _val171 of {T.TI64 _val172 -> _val172; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squarePreference_notiForNewJoinRequest = P.maybe (squarePreference_notiForNewJoinRequest default_SquarePreference) (\(_,_val171) -> (case _val171 of {T.TBool _val173 -> _val173; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquarePreference _ = P.error "not a struct"
read_SquarePreference :: T.Protocol p => p -> P.IO SquarePreference
read_SquarePreference iprot = to_SquarePreference <$> T.readVal iprot (T.T_STRUCT typemap_SquarePreference)
decode_SquarePreference :: T.StatelessProtocol p => p -> LBS.ByteString -> SquarePreference
decode_SquarePreference iprot bs = to_SquarePreference $ T.deserializeVal iprot (T.T_STRUCT typemap_SquarePreference) bs
typemap_SquarePreference :: T.TypeMap
typemap_SquarePreference = Map.fromList [(1,("favoriteTimestamp",T.T_I64)),(2,("notiForNewJoinRequest",T.T_BOOL))]
default_SquarePreference :: SquarePreference
default_SquarePreference = SquarePreference{
  squarePreference_favoriteTimestamp = 0,
  squarePreference_notiForNewJoinRequest = P.False}
data SquareMember = SquareMember  { squareMember_squareMemberMid :: LT.Text
  , squareMember_squareMid :: LT.Text
  , squareMember_displayName :: LT.Text
  , squareMember_profileImageObsHash :: LT.Text
  , squareMember_ableToReceiveMessage :: P.Bool
  , squareMember_membershipState :: SquareMembershipState
  , squareMember_role :: SquareMemberRole
  , squareMember_revision :: I.Int64
  , squareMember_preference :: SquarePreference
  , squareMember_joinMessage :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareMember_squareMemberMid record   `H.hashWithSalt` squareMember_squareMid record   `H.hashWithSalt` squareMember_displayName record   `H.hashWithSalt` squareMember_profileImageObsHash record   `H.hashWithSalt` squareMember_ableToReceiveMessage record   `H.hashWithSalt` squareMember_membershipState record   `H.hashWithSalt` squareMember_role record   `H.hashWithSalt` squareMember_revision record   `H.hashWithSalt` squareMember_preference record   `H.hashWithSalt` squareMember_joinMessage record  
instance QC.Arbitrary SquareMember where 
  arbitrary = M.liftM SquareMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareMember{squareMember_squareMemberMid = squareMember_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_squareMemberMid = squareMember_squareMemberMid obj}
    , if obj == default_SquareMember{squareMember_squareMid = squareMember_squareMid obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_squareMid = squareMember_squareMid obj}
    , if obj == default_SquareMember{squareMember_displayName = squareMember_displayName obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_displayName = squareMember_displayName obj}
    , if obj == default_SquareMember{squareMember_profileImageObsHash = squareMember_profileImageObsHash obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_profileImageObsHash = squareMember_profileImageObsHash obj}
    , if obj == default_SquareMember{squareMember_ableToReceiveMessage = squareMember_ableToReceiveMessage obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_ableToReceiveMessage = squareMember_ableToReceiveMessage obj}
    , if obj == default_SquareMember{squareMember_membershipState = squareMember_membershipState obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_membershipState = squareMember_membershipState obj}
    , if obj == default_SquareMember{squareMember_role = squareMember_role obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_role = squareMember_role obj}
    , if obj == default_SquareMember{squareMember_revision = squareMember_revision obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_revision = squareMember_revision obj}
    , if obj == default_SquareMember{squareMember_preference = squareMember_preference obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_preference = squareMember_preference obj}
    , if obj == default_SquareMember{squareMember_joinMessage = squareMember_joinMessage obj} then P.Nothing else P.Just $ default_SquareMember{squareMember_joinMessage = squareMember_joinMessage obj}
    ]
from_SquareMember :: SquareMember -> T.ThriftVal
from_SquareMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v176 -> P.Just (1, ("squareMemberMid",T.TString $ E.encodeUtf8 _v176))) $ squareMember_squareMemberMid record
  , (\_v176 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v176))) $ squareMember_squareMid record
  , (\_v176 -> P.Just (3, ("displayName",T.TString $ E.encodeUtf8 _v176))) $ squareMember_displayName record
  , (\_v176 -> P.Just (4, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v176))) $ squareMember_profileImageObsHash record
  , (\_v176 -> P.Just (5, ("ableToReceiveMessage",T.TBool _v176))) $ squareMember_ableToReceiveMessage record
  , (\_v176 -> P.Just (7, ("membershipState",T.TI32 $ P.fromIntegral $ P.fromEnum _v176))) $ squareMember_membershipState record
  , (\_v176 -> P.Just (8, ("role",T.TI32 $ P.fromIntegral $ P.fromEnum _v176))) $ squareMember_role record
  , (\_v176 -> P.Just (9, ("revision",T.TI64 _v176))) $ squareMember_revision record
  , (\_v176 -> P.Just (10, ("preference",from_SquarePreference _v176))) $ squareMember_preference record
  , (\_v176 -> P.Just (11, ("joinMessage",T.TString $ E.encodeUtf8 _v176))) $ squareMember_joinMessage record
  ]
write_SquareMember :: T.Protocol p => p -> SquareMember -> P.IO ()
write_SquareMember oprot record = T.writeVal oprot $ from_SquareMember record
encode_SquareMember :: T.StatelessProtocol p => p -> SquareMember -> LBS.ByteString
encode_SquareMember oprot record = T.serializeVal oprot $ from_SquareMember record
to_SquareMember :: T.ThriftVal -> SquareMember
to_SquareMember (T.TStruct fields) = SquareMember{
  squareMember_squareMemberMid = P.maybe (squareMember_squareMemberMid default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TString _val179 -> E.decodeUtf8 _val179; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareMember_squareMid = P.maybe (squareMember_squareMid default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TString _val180 -> E.decodeUtf8 _val180; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareMember_displayName = P.maybe (squareMember_displayName default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TString _val181 -> E.decodeUtf8 _val181; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareMember_profileImageObsHash = P.maybe (squareMember_profileImageObsHash default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TString _val182 -> E.decodeUtf8 _val182; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareMember_ableToReceiveMessage = P.maybe (squareMember_ableToReceiveMessage default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TBool _val183 -> _val183; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareMember_membershipState = P.maybe (squareMember_membershipState default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TI32 _val184 -> P.toEnum $ P.fromIntegral _val184; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  squareMember_role = P.maybe (squareMember_role default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TI32 _val185 -> P.toEnum $ P.fromIntegral _val185; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  squareMember_revision = P.maybe (squareMember_revision default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TI64 _val186 -> _val186; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  squareMember_preference = P.maybe (squareMember_preference default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TStruct _val187 -> (to_SquarePreference (T.TStruct _val187)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  squareMember_joinMessage = P.maybe (squareMember_joinMessage default_SquareMember) (\(_,_val178) -> (case _val178 of {T.TString _val188 -> E.decodeUtf8 _val188; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_SquareMember _ = P.error "not a struct"
read_SquareMember :: T.Protocol p => p -> P.IO SquareMember
read_SquareMember iprot = to_SquareMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareMember)
decode_SquareMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareMember
decode_SquareMember iprot bs = to_SquareMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareMember) bs
typemap_SquareMember :: T.TypeMap
typemap_SquareMember = Map.fromList [(1,("squareMemberMid",T.T_STRING)),(2,("squareMid",T.T_STRING)),(3,("displayName",T.T_STRING)),(4,("profileImageObsHash",T.T_STRING)),(5,("ableToReceiveMessage",T.T_BOOL)),(7,("membershipState",T.T_I32)),(8,("role",T.T_I32)),(9,("revision",T.T_I64)),(10,("preference",(T.T_STRUCT typemap_SquarePreference))),(11,("joinMessage",T.T_STRING))]
default_SquareMember :: SquareMember
default_SquareMember = SquareMember{
  squareMember_squareMemberMid = "",
  squareMember_squareMid = "",
  squareMember_displayName = "",
  squareMember_profileImageObsHash = "",
  squareMember_ableToReceiveMessage = P.False,
  squareMember_membershipState = (P.toEnum 0),
  squareMember_role = (P.toEnum 0),
  squareMember_revision = 0,
  squareMember_preference = default_SquarePreference,
  squareMember_joinMessage = ""}
data SquareMemberRelation = SquareMemberRelation  { squareMemberRelation_state :: SquareMemberRelationState
  , squareMemberRelation_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareMemberRelation where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareMemberRelation_state record   `H.hashWithSalt` squareMemberRelation_revision record  
instance QC.Arbitrary SquareMemberRelation where 
  arbitrary = M.liftM SquareMemberRelation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareMemberRelation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareMemberRelation{squareMemberRelation_state = squareMemberRelation_state obj} then P.Nothing else P.Just $ default_SquareMemberRelation{squareMemberRelation_state = squareMemberRelation_state obj}
    , if obj == default_SquareMemberRelation{squareMemberRelation_revision = squareMemberRelation_revision obj} then P.Nothing else P.Just $ default_SquareMemberRelation{squareMemberRelation_revision = squareMemberRelation_revision obj}
    ]
from_SquareMemberRelation :: SquareMemberRelation -> T.ThriftVal
from_SquareMemberRelation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v191 -> P.Just (1, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v191))) $ squareMemberRelation_state record
  , (\_v191 -> P.Just (2, ("revision",T.TI64 _v191))) $ squareMemberRelation_revision record
  ]
write_SquareMemberRelation :: T.Protocol p => p -> SquareMemberRelation -> P.IO ()
write_SquareMemberRelation oprot record = T.writeVal oprot $ from_SquareMemberRelation record
encode_SquareMemberRelation :: T.StatelessProtocol p => p -> SquareMemberRelation -> LBS.ByteString
encode_SquareMemberRelation oprot record = T.serializeVal oprot $ from_SquareMemberRelation record
to_SquareMemberRelation :: T.ThriftVal -> SquareMemberRelation
to_SquareMemberRelation (T.TStruct fields) = SquareMemberRelation{
  squareMemberRelation_state = P.maybe (squareMemberRelation_state default_SquareMemberRelation) (\(_,_val193) -> (case _val193 of {T.TI32 _val194 -> P.toEnum $ P.fromIntegral _val194; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareMemberRelation_revision = P.maybe (squareMemberRelation_revision default_SquareMemberRelation) (\(_,_val193) -> (case _val193 of {T.TI64 _val195 -> _val195; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareMemberRelation _ = P.error "not a struct"
read_SquareMemberRelation :: T.Protocol p => p -> P.IO SquareMemberRelation
read_SquareMemberRelation iprot = to_SquareMemberRelation <$> T.readVal iprot (T.T_STRUCT typemap_SquareMemberRelation)
decode_SquareMemberRelation :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareMemberRelation
decode_SquareMemberRelation iprot bs = to_SquareMemberRelation $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareMemberRelation) bs
typemap_SquareMemberRelation :: T.TypeMap
typemap_SquareMemberRelation = Map.fromList [(1,("state",T.T_I32)),(2,("revision",T.T_I64))]
default_SquareMemberRelation :: SquareMemberRelation
default_SquareMemberRelation = SquareMemberRelation{
  squareMemberRelation_state = (P.toEnum 0),
  squareMemberRelation_revision = 0}
data SquareFeature = SquareFeature  { squareFeature_controlState :: SquareFeatureControlState
  , squareFeature_booleanValue :: BooleanState
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareFeature where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareFeature_controlState record   `H.hashWithSalt` squareFeature_booleanValue record  
instance QC.Arbitrary SquareFeature where 
  arbitrary = M.liftM SquareFeature (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareFeature = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareFeature{squareFeature_controlState = squareFeature_controlState obj} then P.Nothing else P.Just $ default_SquareFeature{squareFeature_controlState = squareFeature_controlState obj}
    , if obj == default_SquareFeature{squareFeature_booleanValue = squareFeature_booleanValue obj} then P.Nothing else P.Just $ default_SquareFeature{squareFeature_booleanValue = squareFeature_booleanValue obj}
    ]
from_SquareFeature :: SquareFeature -> T.ThriftVal
from_SquareFeature record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v198 -> P.Just (1, ("controlState",T.TI32 $ P.fromIntegral $ P.fromEnum _v198))) $ squareFeature_controlState record
  , (\_v198 -> P.Just (2, ("booleanValue",T.TI32 $ P.fromIntegral $ P.fromEnum _v198))) $ squareFeature_booleanValue record
  ]
write_SquareFeature :: T.Protocol p => p -> SquareFeature -> P.IO ()
write_SquareFeature oprot record = T.writeVal oprot $ from_SquareFeature record
encode_SquareFeature :: T.StatelessProtocol p => p -> SquareFeature -> LBS.ByteString
encode_SquareFeature oprot record = T.serializeVal oprot $ from_SquareFeature record
to_SquareFeature :: T.ThriftVal -> SquareFeature
to_SquareFeature (T.TStruct fields) = SquareFeature{
  squareFeature_controlState = P.maybe (squareFeature_controlState default_SquareFeature) (\(_,_val200) -> (case _val200 of {T.TI32 _val201 -> P.toEnum $ P.fromIntegral _val201; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareFeature_booleanValue = P.maybe (squareFeature_booleanValue default_SquareFeature) (\(_,_val200) -> (case _val200 of {T.TI32 _val202 -> P.toEnum $ P.fromIntegral _val202; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareFeature _ = P.error "not a struct"
read_SquareFeature :: T.Protocol p => p -> P.IO SquareFeature
read_SquareFeature iprot = to_SquareFeature <$> T.readVal iprot (T.T_STRUCT typemap_SquareFeature)
decode_SquareFeature :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareFeature
decode_SquareFeature iprot bs = to_SquareFeature $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareFeature) bs
typemap_SquareFeature :: T.TypeMap
typemap_SquareFeature = Map.fromList [(1,("controlState",T.T_I32)),(2,("booleanValue",T.T_I32))]
default_SquareFeature :: SquareFeature
default_SquareFeature = SquareFeature{
  squareFeature_controlState = (P.toEnum 0),
  squareFeature_booleanValue = (P.toEnum 0)}
data SquareFeatureSet = SquareFeatureSet  { squareFeatureSet_squareMid :: LT.Text
  , squareFeatureSet_revision :: I.Int64
  , squareFeatureSet_creatingSecretSquareChat :: SquareFeature
  , squareFeatureSet_invitingIntoOpenSquareChat :: SquareFeature
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareFeatureSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareFeatureSet_squareMid record   `H.hashWithSalt` squareFeatureSet_revision record   `H.hashWithSalt` squareFeatureSet_creatingSecretSquareChat record   `H.hashWithSalt` squareFeatureSet_invitingIntoOpenSquareChat record  
instance QC.Arbitrary SquareFeatureSet where 
  arbitrary = M.liftM SquareFeatureSet (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareFeatureSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareFeatureSet{squareFeatureSet_squareMid = squareFeatureSet_squareMid obj} then P.Nothing else P.Just $ default_SquareFeatureSet{squareFeatureSet_squareMid = squareFeatureSet_squareMid obj}
    , if obj == default_SquareFeatureSet{squareFeatureSet_revision = squareFeatureSet_revision obj} then P.Nothing else P.Just $ default_SquareFeatureSet{squareFeatureSet_revision = squareFeatureSet_revision obj}
    , if obj == default_SquareFeatureSet{squareFeatureSet_creatingSecretSquareChat = squareFeatureSet_creatingSecretSquareChat obj} then P.Nothing else P.Just $ default_SquareFeatureSet{squareFeatureSet_creatingSecretSquareChat = squareFeatureSet_creatingSecretSquareChat obj}
    , if obj == default_SquareFeatureSet{squareFeatureSet_invitingIntoOpenSquareChat = squareFeatureSet_invitingIntoOpenSquareChat obj} then P.Nothing else P.Just $ default_SquareFeatureSet{squareFeatureSet_invitingIntoOpenSquareChat = squareFeatureSet_invitingIntoOpenSquareChat obj}
    ]
from_SquareFeatureSet :: SquareFeatureSet -> T.ThriftVal
from_SquareFeatureSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v205 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v205))) $ squareFeatureSet_squareMid record
  , (\_v205 -> P.Just (2, ("revision",T.TI64 _v205))) $ squareFeatureSet_revision record
  , (\_v205 -> P.Just (11, ("creatingSecretSquareChat",from_SquareFeature _v205))) $ squareFeatureSet_creatingSecretSquareChat record
  , (\_v205 -> P.Just (12, ("invitingIntoOpenSquareChat",from_SquareFeature _v205))) $ squareFeatureSet_invitingIntoOpenSquareChat record
  ]
write_SquareFeatureSet :: T.Protocol p => p -> SquareFeatureSet -> P.IO ()
write_SquareFeatureSet oprot record = T.writeVal oprot $ from_SquareFeatureSet record
encode_SquareFeatureSet :: T.StatelessProtocol p => p -> SquareFeatureSet -> LBS.ByteString
encode_SquareFeatureSet oprot record = T.serializeVal oprot $ from_SquareFeatureSet record
to_SquareFeatureSet :: T.ThriftVal -> SquareFeatureSet
to_SquareFeatureSet (T.TStruct fields) = SquareFeatureSet{
  squareFeatureSet_squareMid = P.maybe (squareFeatureSet_squareMid default_SquareFeatureSet) (\(_,_val207) -> (case _val207 of {T.TString _val208 -> E.decodeUtf8 _val208; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareFeatureSet_revision = P.maybe (squareFeatureSet_revision default_SquareFeatureSet) (\(_,_val207) -> (case _val207 of {T.TI64 _val209 -> _val209; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareFeatureSet_creatingSecretSquareChat = P.maybe (squareFeatureSet_creatingSecretSquareChat default_SquareFeatureSet) (\(_,_val207) -> (case _val207 of {T.TStruct _val210 -> (to_SquareFeature (T.TStruct _val210)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  squareFeatureSet_invitingIntoOpenSquareChat = P.maybe (squareFeatureSet_invitingIntoOpenSquareChat default_SquareFeatureSet) (\(_,_val207) -> (case _val207 of {T.TStruct _val211 -> (to_SquareFeature (T.TStruct _val211)); _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_SquareFeatureSet _ = P.error "not a struct"
read_SquareFeatureSet :: T.Protocol p => p -> P.IO SquareFeatureSet
read_SquareFeatureSet iprot = to_SquareFeatureSet <$> T.readVal iprot (T.T_STRUCT typemap_SquareFeatureSet)
decode_SquareFeatureSet :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareFeatureSet
decode_SquareFeatureSet iprot bs = to_SquareFeatureSet $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareFeatureSet) bs
typemap_SquareFeatureSet :: T.TypeMap
typemap_SquareFeatureSet = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("revision",T.T_I64)),(11,("creatingSecretSquareChat",(T.T_STRUCT typemap_SquareFeature))),(12,("invitingIntoOpenSquareChat",(T.T_STRUCT typemap_SquareFeature)))]
default_SquareFeatureSet :: SquareFeatureSet
default_SquareFeatureSet = SquareFeatureSet{
  squareFeatureSet_squareMid = "",
  squareFeatureSet_revision = 0,
  squareFeatureSet_creatingSecretSquareChat = default_SquareFeature,
  squareFeatureSet_invitingIntoOpenSquareChat = default_SquareFeature}
data SquareStatus = SquareStatus  { squareStatus_memberCount :: I.Int32
  , squareStatus_joinRequestCount :: I.Int32
  , squareStatus_lastJoinRequestAt :: I.Int64
  , squareStatus_openChatCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareStatus_memberCount record   `H.hashWithSalt` squareStatus_joinRequestCount record   `H.hashWithSalt` squareStatus_lastJoinRequestAt record   `H.hashWithSalt` squareStatus_openChatCount record  
instance QC.Arbitrary SquareStatus where 
  arbitrary = M.liftM SquareStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareStatus{squareStatus_memberCount = squareStatus_memberCount obj} then P.Nothing else P.Just $ default_SquareStatus{squareStatus_memberCount = squareStatus_memberCount obj}
    , if obj == default_SquareStatus{squareStatus_joinRequestCount = squareStatus_joinRequestCount obj} then P.Nothing else P.Just $ default_SquareStatus{squareStatus_joinRequestCount = squareStatus_joinRequestCount obj}
    , if obj == default_SquareStatus{squareStatus_lastJoinRequestAt = squareStatus_lastJoinRequestAt obj} then P.Nothing else P.Just $ default_SquareStatus{squareStatus_lastJoinRequestAt = squareStatus_lastJoinRequestAt obj}
    , if obj == default_SquareStatus{squareStatus_openChatCount = squareStatus_openChatCount obj} then P.Nothing else P.Just $ default_SquareStatus{squareStatus_openChatCount = squareStatus_openChatCount obj}
    ]
from_SquareStatus :: SquareStatus -> T.ThriftVal
from_SquareStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v214 -> P.Just (1, ("memberCount",T.TI32 _v214))) $ squareStatus_memberCount record
  , (\_v214 -> P.Just (2, ("joinRequestCount",T.TI32 _v214))) $ squareStatus_joinRequestCount record
  , (\_v214 -> P.Just (3, ("lastJoinRequestAt",T.TI64 _v214))) $ squareStatus_lastJoinRequestAt record
  , (\_v214 -> P.Just (4, ("openChatCount",T.TI32 _v214))) $ squareStatus_openChatCount record
  ]
write_SquareStatus :: T.Protocol p => p -> SquareStatus -> P.IO ()
write_SquareStatus oprot record = T.writeVal oprot $ from_SquareStatus record
encode_SquareStatus :: T.StatelessProtocol p => p -> SquareStatus -> LBS.ByteString
encode_SquareStatus oprot record = T.serializeVal oprot $ from_SquareStatus record
to_SquareStatus :: T.ThriftVal -> SquareStatus
to_SquareStatus (T.TStruct fields) = SquareStatus{
  squareStatus_memberCount = P.maybe (squareStatus_memberCount default_SquareStatus) (\(_,_val216) -> (case _val216 of {T.TI32 _val217 -> _val217; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareStatus_joinRequestCount = P.maybe (squareStatus_joinRequestCount default_SquareStatus) (\(_,_val216) -> (case _val216 of {T.TI32 _val218 -> _val218; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareStatus_lastJoinRequestAt = P.maybe (squareStatus_lastJoinRequestAt default_SquareStatus) (\(_,_val216) -> (case _val216 of {T.TI64 _val219 -> _val219; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareStatus_openChatCount = P.maybe (squareStatus_openChatCount default_SquareStatus) (\(_,_val216) -> (case _val216 of {T.TI32 _val220 -> _val220; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareStatus _ = P.error "not a struct"
read_SquareStatus :: T.Protocol p => p -> P.IO SquareStatus
read_SquareStatus iprot = to_SquareStatus <$> T.readVal iprot (T.T_STRUCT typemap_SquareStatus)
decode_SquareStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareStatus
decode_SquareStatus iprot bs = to_SquareStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareStatus) bs
typemap_SquareStatus :: T.TypeMap
typemap_SquareStatus = Map.fromList [(1,("memberCount",T.T_I32)),(2,("joinRequestCount",T.T_I32)),(3,("lastJoinRequestAt",T.T_I64)),(4,("openChatCount",T.T_I32))]
default_SquareStatus :: SquareStatus
default_SquareStatus = SquareStatus{
  squareStatus_memberCount = 0,
  squareStatus_joinRequestCount = 0,
  squareStatus_lastJoinRequestAt = 0,
  squareStatus_openChatCount = 0}
data SquareChat = SquareChat  { squareChat_squareChatMid :: LT.Text
  , squareChat_squareMid :: LT.Text
  , squareChat_type :: SquareChatType
  , squareChat_name :: LT.Text
  , squareChat_chatImageObsHash :: LT.Text
  , squareChat_squareChatRevision :: I.Int64
  , squareChat_maxMemberCount :: I.Int32
  , squareChat_state :: SquareChatState
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChat_squareChatMid record   `H.hashWithSalt` squareChat_squareMid record   `H.hashWithSalt` squareChat_type record   `H.hashWithSalt` squareChat_name record   `H.hashWithSalt` squareChat_chatImageObsHash record   `H.hashWithSalt` squareChat_squareChatRevision record   `H.hashWithSalt` squareChat_maxMemberCount record   `H.hashWithSalt` squareChat_state record  
instance QC.Arbitrary SquareChat where 
  arbitrary = M.liftM SquareChat (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChat{squareChat_squareChatMid = squareChat_squareChatMid obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_squareChatMid = squareChat_squareChatMid obj}
    , if obj == default_SquareChat{squareChat_squareMid = squareChat_squareMid obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_squareMid = squareChat_squareMid obj}
    , if obj == default_SquareChat{squareChat_type = squareChat_type obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_type = squareChat_type obj}
    , if obj == default_SquareChat{squareChat_name = squareChat_name obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_name = squareChat_name obj}
    , if obj == default_SquareChat{squareChat_chatImageObsHash = squareChat_chatImageObsHash obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_chatImageObsHash = squareChat_chatImageObsHash obj}
    , if obj == default_SquareChat{squareChat_squareChatRevision = squareChat_squareChatRevision obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_squareChatRevision = squareChat_squareChatRevision obj}
    , if obj == default_SquareChat{squareChat_maxMemberCount = squareChat_maxMemberCount obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_maxMemberCount = squareChat_maxMemberCount obj}
    , if obj == default_SquareChat{squareChat_state = squareChat_state obj} then P.Nothing else P.Just $ default_SquareChat{squareChat_state = squareChat_state obj}
    ]
from_SquareChat :: SquareChat -> T.ThriftVal
from_SquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v223 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v223))) $ squareChat_squareChatMid record
  , (\_v223 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v223))) $ squareChat_squareMid record
  , (\_v223 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v223))) $ squareChat_type record
  , (\_v223 -> P.Just (4, ("name",T.TString $ E.encodeUtf8 _v223))) $ squareChat_name record
  , (\_v223 -> P.Just (5, ("chatImageObsHash",T.TString $ E.encodeUtf8 _v223))) $ squareChat_chatImageObsHash record
  , (\_v223 -> P.Just (6, ("squareChatRevision",T.TI64 _v223))) $ squareChat_squareChatRevision record
  , (\_v223 -> P.Just (7, ("maxMemberCount",T.TI32 _v223))) $ squareChat_maxMemberCount record
  , (\_v223 -> P.Just (8, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v223))) $ squareChat_state record
  ]
write_SquareChat :: T.Protocol p => p -> SquareChat -> P.IO ()
write_SquareChat oprot record = T.writeVal oprot $ from_SquareChat record
encode_SquareChat :: T.StatelessProtocol p => p -> SquareChat -> LBS.ByteString
encode_SquareChat oprot record = T.serializeVal oprot $ from_SquareChat record
to_SquareChat :: T.ThriftVal -> SquareChat
to_SquareChat (T.TStruct fields) = SquareChat{
  squareChat_squareChatMid = P.maybe (squareChat_squareChatMid default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TString _val226 -> E.decodeUtf8 _val226; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareChat_squareMid = P.maybe (squareChat_squareMid default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TString _val227 -> E.decodeUtf8 _val227; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareChat_type = P.maybe (squareChat_type default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TI32 _val228 -> P.toEnum $ P.fromIntegral _val228; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareChat_name = P.maybe (squareChat_name default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TString _val229 -> E.decodeUtf8 _val229; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareChat_chatImageObsHash = P.maybe (squareChat_chatImageObsHash default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TString _val230 -> E.decodeUtf8 _val230; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareChat_squareChatRevision = P.maybe (squareChat_squareChatRevision default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TI64 _val231 -> _val231; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  squareChat_maxMemberCount = P.maybe (squareChat_maxMemberCount default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TI32 _val232 -> _val232; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  squareChat_state = P.maybe (squareChat_state default_SquareChat) (\(_,_val225) -> (case _val225 of {T.TI32 _val233 -> P.toEnum $ P.fromIntegral _val233; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_SquareChat _ = P.error "not a struct"
read_SquareChat :: T.Protocol p => p -> P.IO SquareChat
read_SquareChat iprot = to_SquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareChat)
decode_SquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChat
decode_SquareChat iprot bs = to_SquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChat) bs
typemap_SquareChat :: T.TypeMap
typemap_SquareChat = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMid",T.T_STRING)),(3,("type",T.T_I32)),(4,("name",T.T_STRING)),(5,("chatImageObsHash",T.T_STRING)),(6,("squareChatRevision",T.T_I64)),(7,("maxMemberCount",T.T_I32)),(8,("state",T.T_I32))]
default_SquareChat :: SquareChat
default_SquareChat = SquareChat{
  squareChat_squareChatMid = "",
  squareChat_squareMid = "",
  squareChat_type = (P.toEnum 0),
  squareChat_name = "",
  squareChat_chatImageObsHash = "",
  squareChat_squareChatRevision = 0,
  squareChat_maxMemberCount = 0,
  squareChat_state = (P.toEnum 0)}
data NoteStatus = NoteStatus  { noteStatus_noteCount :: I.Int32
  , noteStatus_latestCreatedAt :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteStatus_noteCount record   `H.hashWithSalt` noteStatus_latestCreatedAt record  
instance QC.Arbitrary NoteStatus where 
  arbitrary = M.liftM NoteStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NoteStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteStatus{noteStatus_noteCount = noteStatus_noteCount obj} then P.Nothing else P.Just $ default_NoteStatus{noteStatus_noteCount = noteStatus_noteCount obj}
    , if obj == default_NoteStatus{noteStatus_latestCreatedAt = noteStatus_latestCreatedAt obj} then P.Nothing else P.Just $ default_NoteStatus{noteStatus_latestCreatedAt = noteStatus_latestCreatedAt obj}
    ]
from_NoteStatus :: NoteStatus -> T.ThriftVal
from_NoteStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v236 -> P.Just (1, ("noteCount",T.TI32 _v236))) $ noteStatus_noteCount record
  , (\_v236 -> P.Just (2, ("latestCreatedAt",T.TI64 _v236))) $ noteStatus_latestCreatedAt record
  ]
write_NoteStatus :: T.Protocol p => p -> NoteStatus -> P.IO ()
write_NoteStatus oprot record = T.writeVal oprot $ from_NoteStatus record
encode_NoteStatus :: T.StatelessProtocol p => p -> NoteStatus -> LBS.ByteString
encode_NoteStatus oprot record = T.serializeVal oprot $ from_NoteStatus record
to_NoteStatus :: T.ThriftVal -> NoteStatus
to_NoteStatus (T.TStruct fields) = NoteStatus{
  noteStatus_noteCount = P.maybe (noteStatus_noteCount default_NoteStatus) (\(_,_val238) -> (case _val238 of {T.TI32 _val239 -> _val239; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteStatus_latestCreatedAt = P.maybe (noteStatus_latestCreatedAt default_NoteStatus) (\(_,_val238) -> (case _val238 of {T.TI64 _val240 -> _val240; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NoteStatus _ = P.error "not a struct"
read_NoteStatus :: T.Protocol p => p -> P.IO NoteStatus
read_NoteStatus iprot = to_NoteStatus <$> T.readVal iprot (T.T_STRUCT typemap_NoteStatus)
decode_NoteStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteStatus
decode_NoteStatus iprot bs = to_NoteStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteStatus) bs
typemap_NoteStatus :: T.TypeMap
typemap_NoteStatus = Map.fromList [(1,("noteCount",T.T_I32)),(2,("latestCreatedAt",T.T_I64))]
default_NoteStatus :: NoteStatus
default_NoteStatus = NoteStatus{
  noteStatus_noteCount = 0,
  noteStatus_latestCreatedAt = 0}
data SquareInfo = SquareInfo  { squareInfo_square :: Square
  , squareInfo_squareStatus :: SquareStatus
  , squareInfo_squareNoteStatus :: NoteStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareInfo_square record   `H.hashWithSalt` squareInfo_squareStatus record   `H.hashWithSalt` squareInfo_squareNoteStatus record  
instance QC.Arbitrary SquareInfo where 
  arbitrary = M.liftM SquareInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareInfo{squareInfo_square = squareInfo_square obj} then P.Nothing else P.Just $ default_SquareInfo{squareInfo_square = squareInfo_square obj}
    , if obj == default_SquareInfo{squareInfo_squareStatus = squareInfo_squareStatus obj} then P.Nothing else P.Just $ default_SquareInfo{squareInfo_squareStatus = squareInfo_squareStatus obj}
    , if obj == default_SquareInfo{squareInfo_squareNoteStatus = squareInfo_squareNoteStatus obj} then P.Nothing else P.Just $ default_SquareInfo{squareInfo_squareNoteStatus = squareInfo_squareNoteStatus obj}
    ]
from_SquareInfo :: SquareInfo -> T.ThriftVal
from_SquareInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v243 -> P.Just (1, ("square",from_Square _v243))) $ squareInfo_square record
  , (\_v243 -> P.Just (2, ("squareStatus",from_SquareStatus _v243))) $ squareInfo_squareStatus record
  , (\_v243 -> P.Just (3, ("squareNoteStatus",from_NoteStatus _v243))) $ squareInfo_squareNoteStatus record
  ]
write_SquareInfo :: T.Protocol p => p -> SquareInfo -> P.IO ()
write_SquareInfo oprot record = T.writeVal oprot $ from_SquareInfo record
encode_SquareInfo :: T.StatelessProtocol p => p -> SquareInfo -> LBS.ByteString
encode_SquareInfo oprot record = T.serializeVal oprot $ from_SquareInfo record
to_SquareInfo :: T.ThriftVal -> SquareInfo
to_SquareInfo (T.TStruct fields) = SquareInfo{
  squareInfo_square = P.maybe (squareInfo_square default_SquareInfo) (\(_,_val245) -> (case _val245 of {T.TStruct _val246 -> (to_Square (T.TStruct _val246)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareInfo_squareStatus = P.maybe (squareInfo_squareStatus default_SquareInfo) (\(_,_val245) -> (case _val245 of {T.TStruct _val247 -> (to_SquareStatus (T.TStruct _val247)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareInfo_squareNoteStatus = P.maybe (squareInfo_squareNoteStatus default_SquareInfo) (\(_,_val245) -> (case _val245 of {T.TStruct _val248 -> (to_NoteStatus (T.TStruct _val248)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareInfo _ = P.error "not a struct"
read_SquareInfo :: T.Protocol p => p -> P.IO SquareInfo
read_SquareInfo iprot = to_SquareInfo <$> T.readVal iprot (T.T_STRUCT typemap_SquareInfo)
decode_SquareInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareInfo
decode_SquareInfo iprot bs = to_SquareInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareInfo) bs
typemap_SquareInfo :: T.TypeMap
typemap_SquareInfo = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("squareStatus",(T.T_STRUCT typemap_SquareStatus))),(3,("squareNoteStatus",(T.T_STRUCT typemap_NoteStatus)))]
default_SquareInfo :: SquareInfo
default_SquareInfo = SquareInfo{
  squareInfo_square = default_Square,
  squareInfo_squareStatus = default_SquareStatus,
  squareInfo_squareNoteStatus = default_NoteStatus}
data BotUseInfo = BotUseInfo  { botUseInfo_botUseAgreementAccepted :: P.Bool
  , botUseInfo_botInFriends :: P.Bool
  , botUseInfo_primaryApplication :: LT.Text
  , botUseInfo_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BotUseInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` botUseInfo_botUseAgreementAccepted record   `H.hashWithSalt` botUseInfo_botInFriends record   `H.hashWithSalt` botUseInfo_primaryApplication record   `H.hashWithSalt` botUseInfo_locale record  
instance QC.Arbitrary BotUseInfo where 
  arbitrary = M.liftM BotUseInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BotUseInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BotUseInfo{botUseInfo_botUseAgreementAccepted = botUseInfo_botUseAgreementAccepted obj} then P.Nothing else P.Just $ default_BotUseInfo{botUseInfo_botUseAgreementAccepted = botUseInfo_botUseAgreementAccepted obj}
    , if obj == default_BotUseInfo{botUseInfo_botInFriends = botUseInfo_botInFriends obj} then P.Nothing else P.Just $ default_BotUseInfo{botUseInfo_botInFriends = botUseInfo_botInFriends obj}
    , if obj == default_BotUseInfo{botUseInfo_primaryApplication = botUseInfo_primaryApplication obj} then P.Nothing else P.Just $ default_BotUseInfo{botUseInfo_primaryApplication = botUseInfo_primaryApplication obj}
    , if obj == default_BotUseInfo{botUseInfo_locale = botUseInfo_locale obj} then P.Nothing else P.Just $ default_BotUseInfo{botUseInfo_locale = botUseInfo_locale obj}
    ]
from_BotUseInfo :: BotUseInfo -> T.ThriftVal
from_BotUseInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v251 -> P.Just (1, ("botUseAgreementAccepted",T.TBool _v251))) $ botUseInfo_botUseAgreementAccepted record
  , (\_v251 -> P.Just (2, ("botInFriends",T.TBool _v251))) $ botUseInfo_botInFriends record
  , (\_v251 -> P.Just (3, ("primaryApplication",T.TString $ E.encodeUtf8 _v251))) $ botUseInfo_primaryApplication record
  , (\_v251 -> P.Just (4, ("locale",T.TString $ E.encodeUtf8 _v251))) $ botUseInfo_locale record
  ]
write_BotUseInfo :: T.Protocol p => p -> BotUseInfo -> P.IO ()
write_BotUseInfo oprot record = T.writeVal oprot $ from_BotUseInfo record
encode_BotUseInfo :: T.StatelessProtocol p => p -> BotUseInfo -> LBS.ByteString
encode_BotUseInfo oprot record = T.serializeVal oprot $ from_BotUseInfo record
to_BotUseInfo :: T.ThriftVal -> BotUseInfo
to_BotUseInfo (T.TStruct fields) = BotUseInfo{
  botUseInfo_botUseAgreementAccepted = P.maybe (botUseInfo_botUseAgreementAccepted default_BotUseInfo) (\(_,_val253) -> (case _val253 of {T.TBool _val254 -> _val254; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  botUseInfo_botInFriends = P.maybe (botUseInfo_botInFriends default_BotUseInfo) (\(_,_val253) -> (case _val253 of {T.TBool _val255 -> _val255; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  botUseInfo_primaryApplication = P.maybe (botUseInfo_primaryApplication default_BotUseInfo) (\(_,_val253) -> (case _val253 of {T.TString _val256 -> E.decodeUtf8 _val256; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  botUseInfo_locale = P.maybe (botUseInfo_locale default_BotUseInfo) (\(_,_val253) -> (case _val253 of {T.TString _val257 -> E.decodeUtf8 _val257; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_BotUseInfo _ = P.error "not a struct"
read_BotUseInfo :: T.Protocol p => p -> P.IO BotUseInfo
read_BotUseInfo iprot = to_BotUseInfo <$> T.readVal iprot (T.T_STRUCT typemap_BotUseInfo)
decode_BotUseInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> BotUseInfo
decode_BotUseInfo iprot bs = to_BotUseInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_BotUseInfo) bs
typemap_BotUseInfo :: T.TypeMap
typemap_BotUseInfo = Map.fromList [(1,("botUseAgreementAccepted",T.T_BOOL)),(2,("botInFriends",T.T_BOOL)),(3,("primaryApplication",T.T_STRING)),(4,("locale",T.T_STRING))]
default_BotUseInfo :: BotUseInfo
default_BotUseInfo = BotUseInfo{
  botUseInfo_botUseAgreementAccepted = P.False,
  botUseInfo_botInFriends = P.False,
  botUseInfo_primaryApplication = "",
  botUseInfo_locale = ""}
data PaidCallAdCountry = PaidCallAdCountry  { paidCallAdCountry_countryCode :: LT.Text
  , paidCallAdCountry_rateDivision :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallAdCountry where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallAdCountry_countryCode record   `H.hashWithSalt` paidCallAdCountry_rateDivision record  
instance QC.Arbitrary PaidCallAdCountry where 
  arbitrary = M.liftM PaidCallAdCountry (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallAdCountry = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallAdCountry{paidCallAdCountry_countryCode = paidCallAdCountry_countryCode obj} then P.Nothing else P.Just $ default_PaidCallAdCountry{paidCallAdCountry_countryCode = paidCallAdCountry_countryCode obj}
    , if obj == default_PaidCallAdCountry{paidCallAdCountry_rateDivision = paidCallAdCountry_rateDivision obj} then P.Nothing else P.Just $ default_PaidCallAdCountry{paidCallAdCountry_rateDivision = paidCallAdCountry_rateDivision obj}
    ]
from_PaidCallAdCountry :: PaidCallAdCountry -> T.ThriftVal
from_PaidCallAdCountry record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v260 -> P.Just (1, ("countryCode",T.TString $ E.encodeUtf8 _v260))) $ paidCallAdCountry_countryCode record
  , (\_v260 -> P.Just (2, ("rateDivision",T.TString $ E.encodeUtf8 _v260))) $ paidCallAdCountry_rateDivision record
  ]
write_PaidCallAdCountry :: T.Protocol p => p -> PaidCallAdCountry -> P.IO ()
write_PaidCallAdCountry oprot record = T.writeVal oprot $ from_PaidCallAdCountry record
encode_PaidCallAdCountry :: T.StatelessProtocol p => p -> PaidCallAdCountry -> LBS.ByteString
encode_PaidCallAdCountry oprot record = T.serializeVal oprot $ from_PaidCallAdCountry record
to_PaidCallAdCountry :: T.ThriftVal -> PaidCallAdCountry
to_PaidCallAdCountry (T.TStruct fields) = PaidCallAdCountry{
  paidCallAdCountry_countryCode = P.maybe (paidCallAdCountry_countryCode default_PaidCallAdCountry) (\(_,_val262) -> (case _val262 of {T.TString _val263 -> E.decodeUtf8 _val263; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallAdCountry_rateDivision = P.maybe (paidCallAdCountry_rateDivision default_PaidCallAdCountry) (\(_,_val262) -> (case _val262 of {T.TString _val264 -> E.decodeUtf8 _val264; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PaidCallAdCountry _ = P.error "not a struct"
read_PaidCallAdCountry :: T.Protocol p => p -> P.IO PaidCallAdCountry
read_PaidCallAdCountry iprot = to_PaidCallAdCountry <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallAdCountry)
decode_PaidCallAdCountry :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallAdCountry
decode_PaidCallAdCountry iprot bs = to_PaidCallAdCountry $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallAdCountry) bs
typemap_PaidCallAdCountry :: T.TypeMap
typemap_PaidCallAdCountry = Map.fromList [(1,("countryCode",T.T_STRING)),(2,("rateDivision",T.T_STRING))]
default_PaidCallAdCountry :: PaidCallAdCountry
default_PaidCallAdCountry = PaidCallAdCountry{
  paidCallAdCountry_countryCode = "",
  paidCallAdCountry_rateDivision = ""}
data PaidCallAdResult = PaidCallAdResult  { paidCallAdResult_adRemains :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallAdResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallAdResult_adRemains record  
instance QC.Arbitrary PaidCallAdResult where 
  arbitrary = M.liftM PaidCallAdResult (QC.arbitrary)
  shrink obj | obj == default_PaidCallAdResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallAdResult{paidCallAdResult_adRemains = paidCallAdResult_adRemains obj} then P.Nothing else P.Just $ default_PaidCallAdResult{paidCallAdResult_adRemains = paidCallAdResult_adRemains obj}
    ]
from_PaidCallAdResult :: PaidCallAdResult -> T.ThriftVal
from_PaidCallAdResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v267 -> P.Just (1, ("adRemains",T.TI32 _v267))) $ paidCallAdResult_adRemains record
  ]
write_PaidCallAdResult :: T.Protocol p => p -> PaidCallAdResult -> P.IO ()
write_PaidCallAdResult oprot record = T.writeVal oprot $ from_PaidCallAdResult record
encode_PaidCallAdResult :: T.StatelessProtocol p => p -> PaidCallAdResult -> LBS.ByteString
encode_PaidCallAdResult oprot record = T.serializeVal oprot $ from_PaidCallAdResult record
to_PaidCallAdResult :: T.ThriftVal -> PaidCallAdResult
to_PaidCallAdResult (T.TStruct fields) = PaidCallAdResult{
  paidCallAdResult_adRemains = P.maybe (paidCallAdResult_adRemains default_PaidCallAdResult) (\(_,_val269) -> (case _val269 of {T.TI32 _val270 -> _val270; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_PaidCallAdResult _ = P.error "not a struct"
read_PaidCallAdResult :: T.Protocol p => p -> P.IO PaidCallAdResult
read_PaidCallAdResult iprot = to_PaidCallAdResult <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallAdResult)
decode_PaidCallAdResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallAdResult
decode_PaidCallAdResult iprot bs = to_PaidCallAdResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallAdResult) bs
typemap_PaidCallAdResult :: T.TypeMap
typemap_PaidCallAdResult = Map.fromList [(1,("adRemains",T.T_I32))]
default_PaidCallAdResult :: PaidCallAdResult
default_PaidCallAdResult = PaidCallAdResult{
  paidCallAdResult_adRemains = 0}
data PaidCallBalance = PaidCallBalance  { paidCallBalance_productType :: PaidCallProductType
  , paidCallBalance_productName :: LT.Text
  , paidCallBalance_unit :: LT.Text
  , paidCallBalance_limitedPaidBalance :: I.Int32
  , paidCallBalance_limitedFreeBalance :: I.Int32
  , paidCallBalance_unlimitedPaidBalance :: I.Int32
  , paidCallBalance_unlimitedFreeBalance :: I.Int32
  , paidCallBalance_startTime :: I.Int64
  , paidCallBalance_endTime :: I.Int64
  , paidCallBalance_autopayEnabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallBalance where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallBalance_productType record   `H.hashWithSalt` paidCallBalance_productName record   `H.hashWithSalt` paidCallBalance_unit record   `H.hashWithSalt` paidCallBalance_limitedPaidBalance record   `H.hashWithSalt` paidCallBalance_limitedFreeBalance record   `H.hashWithSalt` paidCallBalance_unlimitedPaidBalance record   `H.hashWithSalt` paidCallBalance_unlimitedFreeBalance record   `H.hashWithSalt` paidCallBalance_startTime record   `H.hashWithSalt` paidCallBalance_endTime record   `H.hashWithSalt` paidCallBalance_autopayEnabled record  
instance QC.Arbitrary PaidCallBalance where 
  arbitrary = M.liftM PaidCallBalance (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallBalance = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallBalance{paidCallBalance_productType = paidCallBalance_productType obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_productType = paidCallBalance_productType obj}
    , if obj == default_PaidCallBalance{paidCallBalance_productName = paidCallBalance_productName obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_productName = paidCallBalance_productName obj}
    , if obj == default_PaidCallBalance{paidCallBalance_unit = paidCallBalance_unit obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_unit = paidCallBalance_unit obj}
    , if obj == default_PaidCallBalance{paidCallBalance_limitedPaidBalance = paidCallBalance_limitedPaidBalance obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_limitedPaidBalance = paidCallBalance_limitedPaidBalance obj}
    , if obj == default_PaidCallBalance{paidCallBalance_limitedFreeBalance = paidCallBalance_limitedFreeBalance obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_limitedFreeBalance = paidCallBalance_limitedFreeBalance obj}
    , if obj == default_PaidCallBalance{paidCallBalance_unlimitedPaidBalance = paidCallBalance_unlimitedPaidBalance obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_unlimitedPaidBalance = paidCallBalance_unlimitedPaidBalance obj}
    , if obj == default_PaidCallBalance{paidCallBalance_unlimitedFreeBalance = paidCallBalance_unlimitedFreeBalance obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_unlimitedFreeBalance = paidCallBalance_unlimitedFreeBalance obj}
    , if obj == default_PaidCallBalance{paidCallBalance_startTime = paidCallBalance_startTime obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_startTime = paidCallBalance_startTime obj}
    , if obj == default_PaidCallBalance{paidCallBalance_endTime = paidCallBalance_endTime obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_endTime = paidCallBalance_endTime obj}
    , if obj == default_PaidCallBalance{paidCallBalance_autopayEnabled = paidCallBalance_autopayEnabled obj} then P.Nothing else P.Just $ default_PaidCallBalance{paidCallBalance_autopayEnabled = paidCallBalance_autopayEnabled obj}
    ]
from_PaidCallBalance :: PaidCallBalance -> T.ThriftVal
from_PaidCallBalance record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v273 -> P.Just (1, ("productType",T.TI32 $ P.fromIntegral $ P.fromEnum _v273))) $ paidCallBalance_productType record
  , (\_v273 -> P.Just (2, ("productName",T.TString $ E.encodeUtf8 _v273))) $ paidCallBalance_productName record
  , (\_v273 -> P.Just (3, ("unit",T.TString $ E.encodeUtf8 _v273))) $ paidCallBalance_unit record
  , (\_v273 -> P.Just (4, ("limitedPaidBalance",T.TI32 _v273))) $ paidCallBalance_limitedPaidBalance record
  , (\_v273 -> P.Just (5, ("limitedFreeBalance",T.TI32 _v273))) $ paidCallBalance_limitedFreeBalance record
  , (\_v273 -> P.Just (6, ("unlimitedPaidBalance",T.TI32 _v273))) $ paidCallBalance_unlimitedPaidBalance record
  , (\_v273 -> P.Just (7, ("unlimitedFreeBalance",T.TI32 _v273))) $ paidCallBalance_unlimitedFreeBalance record
  , (\_v273 -> P.Just (8, ("startTime",T.TI64 _v273))) $ paidCallBalance_startTime record
  , (\_v273 -> P.Just (9, ("endTime",T.TI64 _v273))) $ paidCallBalance_endTime record
  , (\_v273 -> P.Just (10, ("autopayEnabled",T.TBool _v273))) $ paidCallBalance_autopayEnabled record
  ]
write_PaidCallBalance :: T.Protocol p => p -> PaidCallBalance -> P.IO ()
write_PaidCallBalance oprot record = T.writeVal oprot $ from_PaidCallBalance record
encode_PaidCallBalance :: T.StatelessProtocol p => p -> PaidCallBalance -> LBS.ByteString
encode_PaidCallBalance oprot record = T.serializeVal oprot $ from_PaidCallBalance record
to_PaidCallBalance :: T.ThriftVal -> PaidCallBalance
to_PaidCallBalance (T.TStruct fields) = PaidCallBalance{
  paidCallBalance_productType = P.maybe (paidCallBalance_productType default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI32 _val276 -> P.toEnum $ P.fromIntegral _val276; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallBalance_productName = P.maybe (paidCallBalance_productName default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TString _val277 -> E.decodeUtf8 _val277; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallBalance_unit = P.maybe (paidCallBalance_unit default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TString _val278 -> E.decodeUtf8 _val278; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallBalance_limitedPaidBalance = P.maybe (paidCallBalance_limitedPaidBalance default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI32 _val279 -> _val279; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paidCallBalance_limitedFreeBalance = P.maybe (paidCallBalance_limitedFreeBalance default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI32 _val280 -> _val280; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paidCallBalance_unlimitedPaidBalance = P.maybe (paidCallBalance_unlimitedPaidBalance default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI32 _val281 -> _val281; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  paidCallBalance_unlimitedFreeBalance = P.maybe (paidCallBalance_unlimitedFreeBalance default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI32 _val282 -> _val282; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  paidCallBalance_startTime = P.maybe (paidCallBalance_startTime default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI64 _val283 -> _val283; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  paidCallBalance_endTime = P.maybe (paidCallBalance_endTime default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TI64 _val284 -> _val284; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  paidCallBalance_autopayEnabled = P.maybe (paidCallBalance_autopayEnabled default_PaidCallBalance) (\(_,_val275) -> (case _val275 of {T.TBool _val285 -> _val285; _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_PaidCallBalance _ = P.error "not a struct"
read_PaidCallBalance :: T.Protocol p => p -> P.IO PaidCallBalance
read_PaidCallBalance iprot = to_PaidCallBalance <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallBalance)
decode_PaidCallBalance :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallBalance
decode_PaidCallBalance iprot bs = to_PaidCallBalance $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallBalance) bs
typemap_PaidCallBalance :: T.TypeMap
typemap_PaidCallBalance = Map.fromList [(1,("productType",T.T_I32)),(2,("productName",T.T_STRING)),(3,("unit",T.T_STRING)),(4,("limitedPaidBalance",T.T_I32)),(5,("limitedFreeBalance",T.T_I32)),(6,("unlimitedPaidBalance",T.T_I32)),(7,("unlimitedFreeBalance",T.T_I32)),(8,("startTime",T.T_I64)),(9,("endTime",T.T_I64)),(10,("autopayEnabled",T.T_BOOL))]
default_PaidCallBalance :: PaidCallBalance
default_PaidCallBalance = PaidCallBalance{
  paidCallBalance_productType = (P.toEnum 0),
  paidCallBalance_productName = "",
  paidCallBalance_unit = "",
  paidCallBalance_limitedPaidBalance = 0,
  paidCallBalance_limitedFreeBalance = 0,
  paidCallBalance_unlimitedPaidBalance = 0,
  paidCallBalance_unlimitedFreeBalance = 0,
  paidCallBalance_startTime = 0,
  paidCallBalance_endTime = 0,
  paidCallBalance_autopayEnabled = P.False}
data PaidCallCurrencyExchangeRate = PaidCallCurrencyExchangeRate  { paidCallCurrencyExchangeRate_currencyCode :: LT.Text
  , paidCallCurrencyExchangeRate_currencyName :: LT.Text
  , paidCallCurrencyExchangeRate_currencySign :: LT.Text
  , paidCallCurrencyExchangeRate_preferred :: P.Bool
  , paidCallCurrencyExchangeRate_coinRate :: LT.Text
  , paidCallCurrencyExchangeRate_creditRate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallCurrencyExchangeRate where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallCurrencyExchangeRate_currencyCode record   `H.hashWithSalt` paidCallCurrencyExchangeRate_currencyName record   `H.hashWithSalt` paidCallCurrencyExchangeRate_currencySign record   `H.hashWithSalt` paidCallCurrencyExchangeRate_preferred record   `H.hashWithSalt` paidCallCurrencyExchangeRate_coinRate record   `H.hashWithSalt` paidCallCurrencyExchangeRate_creditRate record  
instance QC.Arbitrary PaidCallCurrencyExchangeRate where 
  arbitrary = M.liftM PaidCallCurrencyExchangeRate (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallCurrencyExchangeRate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencyCode = paidCallCurrencyExchangeRate_currencyCode obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencyCode = paidCallCurrencyExchangeRate_currencyCode obj}
    , if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencyName = paidCallCurrencyExchangeRate_currencyName obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencyName = paidCallCurrencyExchangeRate_currencyName obj}
    , if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencySign = paidCallCurrencyExchangeRate_currencySign obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_currencySign = paidCallCurrencyExchangeRate_currencySign obj}
    , if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_preferred = paidCallCurrencyExchangeRate_preferred obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_preferred = paidCallCurrencyExchangeRate_preferred obj}
    , if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_coinRate = paidCallCurrencyExchangeRate_coinRate obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_coinRate = paidCallCurrencyExchangeRate_coinRate obj}
    , if obj == default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_creditRate = paidCallCurrencyExchangeRate_creditRate obj} then P.Nothing else P.Just $ default_PaidCallCurrencyExchangeRate{paidCallCurrencyExchangeRate_creditRate = paidCallCurrencyExchangeRate_creditRate obj}
    ]
from_PaidCallCurrencyExchangeRate :: PaidCallCurrencyExchangeRate -> T.ThriftVal
from_PaidCallCurrencyExchangeRate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v288 -> P.Just (1, ("currencyCode",T.TString $ E.encodeUtf8 _v288))) $ paidCallCurrencyExchangeRate_currencyCode record
  , (\_v288 -> P.Just (2, ("currencyName",T.TString $ E.encodeUtf8 _v288))) $ paidCallCurrencyExchangeRate_currencyName record
  , (\_v288 -> P.Just (3, ("currencySign",T.TString $ E.encodeUtf8 _v288))) $ paidCallCurrencyExchangeRate_currencySign record
  , (\_v288 -> P.Just (4, ("preferred",T.TBool _v288))) $ paidCallCurrencyExchangeRate_preferred record
  , (\_v288 -> P.Just (5, ("coinRate",T.TString $ E.encodeUtf8 _v288))) $ paidCallCurrencyExchangeRate_coinRate record
  , (\_v288 -> P.Just (6, ("creditRate",T.TString $ E.encodeUtf8 _v288))) $ paidCallCurrencyExchangeRate_creditRate record
  ]
write_PaidCallCurrencyExchangeRate :: T.Protocol p => p -> PaidCallCurrencyExchangeRate -> P.IO ()
write_PaidCallCurrencyExchangeRate oprot record = T.writeVal oprot $ from_PaidCallCurrencyExchangeRate record
encode_PaidCallCurrencyExchangeRate :: T.StatelessProtocol p => p -> PaidCallCurrencyExchangeRate -> LBS.ByteString
encode_PaidCallCurrencyExchangeRate oprot record = T.serializeVal oprot $ from_PaidCallCurrencyExchangeRate record
to_PaidCallCurrencyExchangeRate :: T.ThriftVal -> PaidCallCurrencyExchangeRate
to_PaidCallCurrencyExchangeRate (T.TStruct fields) = PaidCallCurrencyExchangeRate{
  paidCallCurrencyExchangeRate_currencyCode = P.maybe (paidCallCurrencyExchangeRate_currencyCode default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TString _val291 -> E.decodeUtf8 _val291; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallCurrencyExchangeRate_currencyName = P.maybe (paidCallCurrencyExchangeRate_currencyName default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TString _val292 -> E.decodeUtf8 _val292; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallCurrencyExchangeRate_currencySign = P.maybe (paidCallCurrencyExchangeRate_currencySign default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TString _val293 -> E.decodeUtf8 _val293; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallCurrencyExchangeRate_preferred = P.maybe (paidCallCurrencyExchangeRate_preferred default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TBool _val294 -> _val294; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paidCallCurrencyExchangeRate_coinRate = P.maybe (paidCallCurrencyExchangeRate_coinRate default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TString _val295 -> E.decodeUtf8 _val295; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paidCallCurrencyExchangeRate_creditRate = P.maybe (paidCallCurrencyExchangeRate_creditRate default_PaidCallCurrencyExchangeRate) (\(_,_val290) -> (case _val290 of {T.TString _val296 -> E.decodeUtf8 _val296; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_PaidCallCurrencyExchangeRate _ = P.error "not a struct"
read_PaidCallCurrencyExchangeRate :: T.Protocol p => p -> P.IO PaidCallCurrencyExchangeRate
read_PaidCallCurrencyExchangeRate iprot = to_PaidCallCurrencyExchangeRate <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate)
decode_PaidCallCurrencyExchangeRate :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallCurrencyExchangeRate
decode_PaidCallCurrencyExchangeRate iprot bs = to_PaidCallCurrencyExchangeRate $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate) bs
typemap_PaidCallCurrencyExchangeRate :: T.TypeMap
typemap_PaidCallCurrencyExchangeRate = Map.fromList [(1,("currencyCode",T.T_STRING)),(2,("currencyName",T.T_STRING)),(3,("currencySign",T.T_STRING)),(4,("preferred",T.T_BOOL)),(5,("coinRate",T.T_STRING)),(6,("creditRate",T.T_STRING))]
default_PaidCallCurrencyExchangeRate :: PaidCallCurrencyExchangeRate
default_PaidCallCurrencyExchangeRate = PaidCallCurrencyExchangeRate{
  paidCallCurrencyExchangeRate_currencyCode = "",
  paidCallCurrencyExchangeRate_currencyName = "",
  paidCallCurrencyExchangeRate_currencySign = "",
  paidCallCurrencyExchangeRate_preferred = P.False,
  paidCallCurrencyExchangeRate_coinRate = "",
  paidCallCurrencyExchangeRate_creditRate = ""}
data ExtendedProfileBirthday = ExtendedProfileBirthday  { extendedProfileBirthday_year :: LT.Text
  , extendedProfileBirthday_yearPrivacyLevelType :: PrivacyLevelType
  , extendedProfileBirthday_yearEnabled :: P.Bool
  , extendedProfileBirthday_day :: LT.Text
  , extendedProfileBirthday_dayPrivacyLevelType :: PrivacyLevelType
  , extendedProfileBirthday_dayEnabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExtendedProfileBirthday where
  hashWithSalt salt record = salt   `H.hashWithSalt` extendedProfileBirthday_year record   `H.hashWithSalt` extendedProfileBirthday_yearPrivacyLevelType record   `H.hashWithSalt` extendedProfileBirthday_yearEnabled record   `H.hashWithSalt` extendedProfileBirthday_day record   `H.hashWithSalt` extendedProfileBirthday_dayPrivacyLevelType record   `H.hashWithSalt` extendedProfileBirthday_dayEnabled record  
instance QC.Arbitrary ExtendedProfileBirthday where 
  arbitrary = M.liftM ExtendedProfileBirthday (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExtendedProfileBirthday = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_year = extendedProfileBirthday_year obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_year = extendedProfileBirthday_year obj}
    , if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_yearPrivacyLevelType = extendedProfileBirthday_yearPrivacyLevelType obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_yearPrivacyLevelType = extendedProfileBirthday_yearPrivacyLevelType obj}
    , if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_yearEnabled = extendedProfileBirthday_yearEnabled obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_yearEnabled = extendedProfileBirthday_yearEnabled obj}
    , if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_day = extendedProfileBirthday_day obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_day = extendedProfileBirthday_day obj}
    , if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_dayPrivacyLevelType = extendedProfileBirthday_dayPrivacyLevelType obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_dayPrivacyLevelType = extendedProfileBirthday_dayPrivacyLevelType obj}
    , if obj == default_ExtendedProfileBirthday{extendedProfileBirthday_dayEnabled = extendedProfileBirthday_dayEnabled obj} then P.Nothing else P.Just $ default_ExtendedProfileBirthday{extendedProfileBirthday_dayEnabled = extendedProfileBirthday_dayEnabled obj}
    ]
from_ExtendedProfileBirthday :: ExtendedProfileBirthday -> T.ThriftVal
from_ExtendedProfileBirthday record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v299 -> P.Just (1, ("year",T.TString $ E.encodeUtf8 _v299))) $ extendedProfileBirthday_year record
  , (\_v299 -> P.Just (2, ("yearPrivacyLevelType",T.TI32 $ P.fromIntegral $ P.fromEnum _v299))) $ extendedProfileBirthday_yearPrivacyLevelType record
  , (\_v299 -> P.Just (3, ("yearEnabled",T.TBool _v299))) $ extendedProfileBirthday_yearEnabled record
  , (\_v299 -> P.Just (5, ("day",T.TString $ E.encodeUtf8 _v299))) $ extendedProfileBirthday_day record
  , (\_v299 -> P.Just (6, ("dayPrivacyLevelType",T.TI32 $ P.fromIntegral $ P.fromEnum _v299))) $ extendedProfileBirthday_dayPrivacyLevelType record
  , (\_v299 -> P.Just (7, ("dayEnabled",T.TBool _v299))) $ extendedProfileBirthday_dayEnabled record
  ]
write_ExtendedProfileBirthday :: T.Protocol p => p -> ExtendedProfileBirthday -> P.IO ()
write_ExtendedProfileBirthday oprot record = T.writeVal oprot $ from_ExtendedProfileBirthday record
encode_ExtendedProfileBirthday :: T.StatelessProtocol p => p -> ExtendedProfileBirthday -> LBS.ByteString
encode_ExtendedProfileBirthday oprot record = T.serializeVal oprot $ from_ExtendedProfileBirthday record
to_ExtendedProfileBirthday :: T.ThriftVal -> ExtendedProfileBirthday
to_ExtendedProfileBirthday (T.TStruct fields) = ExtendedProfileBirthday{
  extendedProfileBirthday_year = P.maybe (extendedProfileBirthday_year default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TString _val302 -> E.decodeUtf8 _val302; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  extendedProfileBirthday_yearPrivacyLevelType = P.maybe (extendedProfileBirthday_yearPrivacyLevelType default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TI32 _val303 -> P.toEnum $ P.fromIntegral _val303; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  extendedProfileBirthday_yearEnabled = P.maybe (extendedProfileBirthday_yearEnabled default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TBool _val304 -> _val304; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  extendedProfileBirthday_day = P.maybe (extendedProfileBirthday_day default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TString _val305 -> E.decodeUtf8 _val305; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  extendedProfileBirthday_dayPrivacyLevelType = P.maybe (extendedProfileBirthday_dayPrivacyLevelType default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TI32 _val306 -> P.toEnum $ P.fromIntegral _val306; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  extendedProfileBirthday_dayEnabled = P.maybe (extendedProfileBirthday_dayEnabled default_ExtendedProfileBirthday) (\(_,_val301) -> (case _val301 of {T.TBool _val307 -> _val307; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_ExtendedProfileBirthday _ = P.error "not a struct"
read_ExtendedProfileBirthday :: T.Protocol p => p -> P.IO ExtendedProfileBirthday
read_ExtendedProfileBirthday iprot = to_ExtendedProfileBirthday <$> T.readVal iprot (T.T_STRUCT typemap_ExtendedProfileBirthday)
decode_ExtendedProfileBirthday :: T.StatelessProtocol p => p -> LBS.ByteString -> ExtendedProfileBirthday
decode_ExtendedProfileBirthday iprot bs = to_ExtendedProfileBirthday $ T.deserializeVal iprot (T.T_STRUCT typemap_ExtendedProfileBirthday) bs
typemap_ExtendedProfileBirthday :: T.TypeMap
typemap_ExtendedProfileBirthday = Map.fromList [(1,("year",T.T_STRING)),(2,("yearPrivacyLevelType",T.T_I32)),(3,("yearEnabled",T.T_BOOL)),(5,("day",T.T_STRING)),(6,("dayPrivacyLevelType",T.T_I32)),(7,("dayEnabled",T.T_BOOL))]
default_ExtendedProfileBirthday :: ExtendedProfileBirthday
default_ExtendedProfileBirthday = ExtendedProfileBirthday{
  extendedProfileBirthday_year = "",
  extendedProfileBirthday_yearPrivacyLevelType = (P.toEnum 0),
  extendedProfileBirthday_yearEnabled = P.False,
  extendedProfileBirthday_day = "",
  extendedProfileBirthday_dayPrivacyLevelType = (P.toEnum 0),
  extendedProfileBirthday_dayEnabled = P.False}
data ExtendedProfile = ExtendedProfile  { extendedProfile_birthday :: ExtendedProfileBirthday
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExtendedProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` extendedProfile_birthday record  
instance QC.Arbitrary ExtendedProfile where 
  arbitrary = M.liftM ExtendedProfile (QC.arbitrary)
  shrink obj | obj == default_ExtendedProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExtendedProfile{extendedProfile_birthday = extendedProfile_birthday obj} then P.Nothing else P.Just $ default_ExtendedProfile{extendedProfile_birthday = extendedProfile_birthday obj}
    ]
from_ExtendedProfile :: ExtendedProfile -> T.ThriftVal
from_ExtendedProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v310 -> P.Just (1, ("birthday",from_ExtendedProfileBirthday _v310))) $ extendedProfile_birthday record
  ]
write_ExtendedProfile :: T.Protocol p => p -> ExtendedProfile -> P.IO ()
write_ExtendedProfile oprot record = T.writeVal oprot $ from_ExtendedProfile record
encode_ExtendedProfile :: T.StatelessProtocol p => p -> ExtendedProfile -> LBS.ByteString
encode_ExtendedProfile oprot record = T.serializeVal oprot $ from_ExtendedProfile record
to_ExtendedProfile :: T.ThriftVal -> ExtendedProfile
to_ExtendedProfile (T.TStruct fields) = ExtendedProfile{
  extendedProfile_birthday = P.maybe (extendedProfile_birthday default_ExtendedProfile) (\(_,_val312) -> (case _val312 of {T.TStruct _val313 -> (to_ExtendedProfileBirthday (T.TStruct _val313)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ExtendedProfile _ = P.error "not a struct"
read_ExtendedProfile :: T.Protocol p => p -> P.IO ExtendedProfile
read_ExtendedProfile iprot = to_ExtendedProfile <$> T.readVal iprot (T.T_STRUCT typemap_ExtendedProfile)
decode_ExtendedProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> ExtendedProfile
decode_ExtendedProfile iprot bs = to_ExtendedProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_ExtendedProfile) bs
typemap_ExtendedProfile :: T.TypeMap
typemap_ExtendedProfile = Map.fromList [(1,("birthday",(T.T_STRUCT typemap_ExtendedProfileBirthday)))]
default_ExtendedProfile :: ExtendedProfile
default_ExtendedProfile = ExtendedProfile{
  extendedProfile_birthday = default_ExtendedProfileBirthday}
data PaidCallDialing = PaidCallDialing  { paidCallDialing_type :: PaidCallType
  , paidCallDialing_dialedNumber :: LT.Text
  , paidCallDialing_serviceDomain :: LT.Text
  , paidCallDialing_productType :: PaidCallProductType
  , paidCallDialing_productName :: LT.Text
  , paidCallDialing_multipleProduct :: P.Bool
  , paidCallDialing_callerIdStatus :: PaidCallerIdStatus
  , paidCallDialing_balance :: I.Int32
  , paidCallDialing_unit :: LT.Text
  , paidCallDialing_rate :: I.Int32
  , paidCallDialing_displayCode :: LT.Text
  , paidCallDialing_calledNumber :: LT.Text
  , paidCallDialing_calleeNationalNumber :: LT.Text
  , paidCallDialing_calleeCallingCode :: LT.Text
  , paidCallDialing_rateDivision :: LT.Text
  , paidCallDialing_adMaxMin :: I.Int32
  , paidCallDialing_adRemains :: I.Int32
  , paidCallDialing_adSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallDialing where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallDialing_type record   `H.hashWithSalt` paidCallDialing_dialedNumber record   `H.hashWithSalt` paidCallDialing_serviceDomain record   `H.hashWithSalt` paidCallDialing_productType record   `H.hashWithSalt` paidCallDialing_productName record   `H.hashWithSalt` paidCallDialing_multipleProduct record   `H.hashWithSalt` paidCallDialing_callerIdStatus record   `H.hashWithSalt` paidCallDialing_balance record   `H.hashWithSalt` paidCallDialing_unit record   `H.hashWithSalt` paidCallDialing_rate record   `H.hashWithSalt` paidCallDialing_displayCode record   `H.hashWithSalt` paidCallDialing_calledNumber record   `H.hashWithSalt` paidCallDialing_calleeNationalNumber record   `H.hashWithSalt` paidCallDialing_calleeCallingCode record   `H.hashWithSalt` paidCallDialing_rateDivision record   `H.hashWithSalt` paidCallDialing_adMaxMin record   `H.hashWithSalt` paidCallDialing_adRemains record   `H.hashWithSalt` paidCallDialing_adSessionId record  
instance QC.Arbitrary PaidCallDialing where 
  arbitrary = M.liftM PaidCallDialing (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallDialing = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallDialing{paidCallDialing_type = paidCallDialing_type obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_type = paidCallDialing_type obj}
    , if obj == default_PaidCallDialing{paidCallDialing_dialedNumber = paidCallDialing_dialedNumber obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_dialedNumber = paidCallDialing_dialedNumber obj}
    , if obj == default_PaidCallDialing{paidCallDialing_serviceDomain = paidCallDialing_serviceDomain obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_serviceDomain = paidCallDialing_serviceDomain obj}
    , if obj == default_PaidCallDialing{paidCallDialing_productType = paidCallDialing_productType obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_productType = paidCallDialing_productType obj}
    , if obj == default_PaidCallDialing{paidCallDialing_productName = paidCallDialing_productName obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_productName = paidCallDialing_productName obj}
    , if obj == default_PaidCallDialing{paidCallDialing_multipleProduct = paidCallDialing_multipleProduct obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_multipleProduct = paidCallDialing_multipleProduct obj}
    , if obj == default_PaidCallDialing{paidCallDialing_callerIdStatus = paidCallDialing_callerIdStatus obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_callerIdStatus = paidCallDialing_callerIdStatus obj}
    , if obj == default_PaidCallDialing{paidCallDialing_balance = paidCallDialing_balance obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_balance = paidCallDialing_balance obj}
    , if obj == default_PaidCallDialing{paidCallDialing_unit = paidCallDialing_unit obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_unit = paidCallDialing_unit obj}
    , if obj == default_PaidCallDialing{paidCallDialing_rate = paidCallDialing_rate obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_rate = paidCallDialing_rate obj}
    , if obj == default_PaidCallDialing{paidCallDialing_displayCode = paidCallDialing_displayCode obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_displayCode = paidCallDialing_displayCode obj}
    , if obj == default_PaidCallDialing{paidCallDialing_calledNumber = paidCallDialing_calledNumber obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_calledNumber = paidCallDialing_calledNumber obj}
    , if obj == default_PaidCallDialing{paidCallDialing_calleeNationalNumber = paidCallDialing_calleeNationalNumber obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_calleeNationalNumber = paidCallDialing_calleeNationalNumber obj}
    , if obj == default_PaidCallDialing{paidCallDialing_calleeCallingCode = paidCallDialing_calleeCallingCode obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_calleeCallingCode = paidCallDialing_calleeCallingCode obj}
    , if obj == default_PaidCallDialing{paidCallDialing_rateDivision = paidCallDialing_rateDivision obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_rateDivision = paidCallDialing_rateDivision obj}
    , if obj == default_PaidCallDialing{paidCallDialing_adMaxMin = paidCallDialing_adMaxMin obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_adMaxMin = paidCallDialing_adMaxMin obj}
    , if obj == default_PaidCallDialing{paidCallDialing_adRemains = paidCallDialing_adRemains obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_adRemains = paidCallDialing_adRemains obj}
    , if obj == default_PaidCallDialing{paidCallDialing_adSessionId = paidCallDialing_adSessionId obj} then P.Nothing else P.Just $ default_PaidCallDialing{paidCallDialing_adSessionId = paidCallDialing_adSessionId obj}
    ]
from_PaidCallDialing :: PaidCallDialing -> T.ThriftVal
from_PaidCallDialing record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v316 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v316))) $ paidCallDialing_type record
  , (\_v316 -> P.Just (2, ("dialedNumber",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_dialedNumber record
  , (\_v316 -> P.Just (3, ("serviceDomain",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_serviceDomain record
  , (\_v316 -> P.Just (4, ("productType",T.TI32 $ P.fromIntegral $ P.fromEnum _v316))) $ paidCallDialing_productType record
  , (\_v316 -> P.Just (5, ("productName",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_productName record
  , (\_v316 -> P.Just (6, ("multipleProduct",T.TBool _v316))) $ paidCallDialing_multipleProduct record
  , (\_v316 -> P.Just (7, ("callerIdStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v316))) $ paidCallDialing_callerIdStatus record
  , (\_v316 -> P.Just (10, ("balance",T.TI32 _v316))) $ paidCallDialing_balance record
  , (\_v316 -> P.Just (11, ("unit",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_unit record
  , (\_v316 -> P.Just (12, ("rate",T.TI32 _v316))) $ paidCallDialing_rate record
  , (\_v316 -> P.Just (13, ("displayCode",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_displayCode record
  , (\_v316 -> P.Just (14, ("calledNumber",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_calledNumber record
  , (\_v316 -> P.Just (15, ("calleeNationalNumber",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_calleeNationalNumber record
  , (\_v316 -> P.Just (16, ("calleeCallingCode",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_calleeCallingCode record
  , (\_v316 -> P.Just (17, ("rateDivision",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_rateDivision record
  , (\_v316 -> P.Just (20, ("adMaxMin",T.TI32 _v316))) $ paidCallDialing_adMaxMin record
  , (\_v316 -> P.Just (21, ("adRemains",T.TI32 _v316))) $ paidCallDialing_adRemains record
  , (\_v316 -> P.Just (22, ("adSessionId",T.TString $ E.encodeUtf8 _v316))) $ paidCallDialing_adSessionId record
  ]
write_PaidCallDialing :: T.Protocol p => p -> PaidCallDialing -> P.IO ()
write_PaidCallDialing oprot record = T.writeVal oprot $ from_PaidCallDialing record
encode_PaidCallDialing :: T.StatelessProtocol p => p -> PaidCallDialing -> LBS.ByteString
encode_PaidCallDialing oprot record = T.serializeVal oprot $ from_PaidCallDialing record
to_PaidCallDialing :: T.ThriftVal -> PaidCallDialing
to_PaidCallDialing (T.TStruct fields) = PaidCallDialing{
  paidCallDialing_type = P.maybe (paidCallDialing_type default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val319 -> P.toEnum $ P.fromIntegral _val319; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallDialing_dialedNumber = P.maybe (paidCallDialing_dialedNumber default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val320 -> E.decodeUtf8 _val320; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallDialing_serviceDomain = P.maybe (paidCallDialing_serviceDomain default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val321 -> E.decodeUtf8 _val321; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallDialing_productType = P.maybe (paidCallDialing_productType default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val322 -> P.toEnum $ P.fromIntegral _val322; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paidCallDialing_productName = P.maybe (paidCallDialing_productName default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val323 -> E.decodeUtf8 _val323; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paidCallDialing_multipleProduct = P.maybe (paidCallDialing_multipleProduct default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TBool _val324 -> _val324; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  paidCallDialing_callerIdStatus = P.maybe (paidCallDialing_callerIdStatus default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val325 -> P.toEnum $ P.fromIntegral _val325; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  paidCallDialing_balance = P.maybe (paidCallDialing_balance default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val326 -> _val326; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  paidCallDialing_unit = P.maybe (paidCallDialing_unit default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val327 -> E.decodeUtf8 _val327; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  paidCallDialing_rate = P.maybe (paidCallDialing_rate default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val328 -> _val328; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  paidCallDialing_displayCode = P.maybe (paidCallDialing_displayCode default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val329 -> E.decodeUtf8 _val329; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  paidCallDialing_calledNumber = P.maybe (paidCallDialing_calledNumber default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val330 -> E.decodeUtf8 _val330; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  paidCallDialing_calleeNationalNumber = P.maybe (paidCallDialing_calleeNationalNumber default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val331 -> E.decodeUtf8 _val331; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  paidCallDialing_calleeCallingCode = P.maybe (paidCallDialing_calleeCallingCode default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val332 -> E.decodeUtf8 _val332; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  paidCallDialing_rateDivision = P.maybe (paidCallDialing_rateDivision default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val333 -> E.decodeUtf8 _val333; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  paidCallDialing_adMaxMin = P.maybe (paidCallDialing_adMaxMin default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val334 -> _val334; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  paidCallDialing_adRemains = P.maybe (paidCallDialing_adRemains default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TI32 _val335 -> _val335; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  paidCallDialing_adSessionId = P.maybe (paidCallDialing_adSessionId default_PaidCallDialing) (\(_,_val318) -> (case _val318 of {T.TString _val336 -> E.decodeUtf8 _val336; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_PaidCallDialing _ = P.error "not a struct"
read_PaidCallDialing :: T.Protocol p => p -> P.IO PaidCallDialing
read_PaidCallDialing iprot = to_PaidCallDialing <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallDialing)
decode_PaidCallDialing :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallDialing
decode_PaidCallDialing iprot bs = to_PaidCallDialing $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallDialing) bs
typemap_PaidCallDialing :: T.TypeMap
typemap_PaidCallDialing = Map.fromList [(1,("type",T.T_I32)),(2,("dialedNumber",T.T_STRING)),(3,("serviceDomain",T.T_STRING)),(4,("productType",T.T_I32)),(5,("productName",T.T_STRING)),(6,("multipleProduct",T.T_BOOL)),(7,("callerIdStatus",T.T_I32)),(10,("balance",T.T_I32)),(11,("unit",T.T_STRING)),(12,("rate",T.T_I32)),(13,("displayCode",T.T_STRING)),(14,("calledNumber",T.T_STRING)),(15,("calleeNationalNumber",T.T_STRING)),(16,("calleeCallingCode",T.T_STRING)),(17,("rateDivision",T.T_STRING)),(20,("adMaxMin",T.T_I32)),(21,("adRemains",T.T_I32)),(22,("adSessionId",T.T_STRING))]
default_PaidCallDialing :: PaidCallDialing
default_PaidCallDialing = PaidCallDialing{
  paidCallDialing_type = (P.toEnum 0),
  paidCallDialing_dialedNumber = "",
  paidCallDialing_serviceDomain = "",
  paidCallDialing_productType = (P.toEnum 0),
  paidCallDialing_productName = "",
  paidCallDialing_multipleProduct = P.False,
  paidCallDialing_callerIdStatus = (P.toEnum 0),
  paidCallDialing_balance = 0,
  paidCallDialing_unit = "",
  paidCallDialing_rate = 0,
  paidCallDialing_displayCode = "",
  paidCallDialing_calledNumber = "",
  paidCallDialing_calleeNationalNumber = "",
  paidCallDialing_calleeCallingCode = "",
  paidCallDialing_rateDivision = "",
  paidCallDialing_adMaxMin = 0,
  paidCallDialing_adRemains = 0,
  paidCallDialing_adSessionId = ""}
data SpotItem = SpotItem  { spotItem_name :: LT.Text
  , spotItem_phone :: LT.Text
  , spotItem_category :: SpotCategory
  , spotItem_mid :: LT.Text
  , spotItem_countryAreaCode :: LT.Text
  , spotItem_freePhoneCallable :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpotItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` spotItem_name record   `H.hashWithSalt` spotItem_phone record   `H.hashWithSalt` spotItem_category record   `H.hashWithSalt` spotItem_mid record   `H.hashWithSalt` spotItem_countryAreaCode record   `H.hashWithSalt` spotItem_freePhoneCallable record  
instance QC.Arbitrary SpotItem where 
  arbitrary = M.liftM SpotItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SpotItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpotItem{spotItem_name = spotItem_name obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_name = spotItem_name obj}
    , if obj == default_SpotItem{spotItem_phone = spotItem_phone obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_phone = spotItem_phone obj}
    , if obj == default_SpotItem{spotItem_category = spotItem_category obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_category = spotItem_category obj}
    , if obj == default_SpotItem{spotItem_mid = spotItem_mid obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_mid = spotItem_mid obj}
    , if obj == default_SpotItem{spotItem_countryAreaCode = spotItem_countryAreaCode obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_countryAreaCode = spotItem_countryAreaCode obj}
    , if obj == default_SpotItem{spotItem_freePhoneCallable = spotItem_freePhoneCallable obj} then P.Nothing else P.Just $ default_SpotItem{spotItem_freePhoneCallable = spotItem_freePhoneCallable obj}
    ]
from_SpotItem :: SpotItem -> T.ThriftVal
from_SpotItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v339 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v339))) $ spotItem_name record
  , (\_v339 -> P.Just (3, ("phone",T.TString $ E.encodeUtf8 _v339))) $ spotItem_phone record
  , (\_v339 -> P.Just (4, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v339))) $ spotItem_category record
  , (\_v339 -> P.Just (5, ("mid",T.TString $ E.encodeUtf8 _v339))) $ spotItem_mid record
  , (\_v339 -> P.Just (6, ("countryAreaCode",T.TString $ E.encodeUtf8 _v339))) $ spotItem_countryAreaCode record
  , (\_v339 -> P.Just (10, ("freePhoneCallable",T.TBool _v339))) $ spotItem_freePhoneCallable record
  ]
write_SpotItem :: T.Protocol p => p -> SpotItem -> P.IO ()
write_SpotItem oprot record = T.writeVal oprot $ from_SpotItem record
encode_SpotItem :: T.StatelessProtocol p => p -> SpotItem -> LBS.ByteString
encode_SpotItem oprot record = T.serializeVal oprot $ from_SpotItem record
to_SpotItem :: T.ThriftVal -> SpotItem
to_SpotItem (T.TStruct fields) = SpotItem{
  spotItem_name = P.maybe (spotItem_name default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TString _val342 -> E.decodeUtf8 _val342; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  spotItem_phone = P.maybe (spotItem_phone default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TString _val343 -> E.decodeUtf8 _val343; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  spotItem_category = P.maybe (spotItem_category default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TI32 _val344 -> P.toEnum $ P.fromIntegral _val344; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  spotItem_mid = P.maybe (spotItem_mid default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TString _val345 -> E.decodeUtf8 _val345; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  spotItem_countryAreaCode = P.maybe (spotItem_countryAreaCode default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TString _val346 -> E.decodeUtf8 _val346; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  spotItem_freePhoneCallable = P.maybe (spotItem_freePhoneCallable default_SpotItem) (\(_,_val341) -> (case _val341 of {T.TBool _val347 -> _val347; _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_SpotItem _ = P.error "not a struct"
read_SpotItem :: T.Protocol p => p -> P.IO SpotItem
read_SpotItem iprot = to_SpotItem <$> T.readVal iprot (T.T_STRUCT typemap_SpotItem)
decode_SpotItem :: T.StatelessProtocol p => p -> LBS.ByteString -> SpotItem
decode_SpotItem iprot bs = to_SpotItem $ T.deserializeVal iprot (T.T_STRUCT typemap_SpotItem) bs
typemap_SpotItem :: T.TypeMap
typemap_SpotItem = Map.fromList [(2,("name",T.T_STRING)),(3,("phone",T.T_STRING)),(4,("category",T.T_I32)),(5,("mid",T.T_STRING)),(6,("countryAreaCode",T.T_STRING)),(10,("freePhoneCallable",T.T_BOOL))]
default_SpotItem :: SpotItem
default_SpotItem = SpotItem{
  spotItem_name = "",
  spotItem_phone = "",
  spotItem_category = (P.toEnum 0),
  spotItem_mid = "",
  spotItem_countryAreaCode = "",
  spotItem_freePhoneCallable = P.False}
data SpotNearbyItem = SpotNearbyItem  { spotNearbyItem_spotItem :: SpotItem
  , spotNearbyItem_location :: Location
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpotNearbyItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` spotNearbyItem_spotItem record   `H.hashWithSalt` spotNearbyItem_location record  
instance QC.Arbitrary SpotNearbyItem where 
  arbitrary = M.liftM SpotNearbyItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SpotNearbyItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpotNearbyItem{spotNearbyItem_spotItem = spotNearbyItem_spotItem obj} then P.Nothing else P.Just $ default_SpotNearbyItem{spotNearbyItem_spotItem = spotNearbyItem_spotItem obj}
    , if obj == default_SpotNearbyItem{spotNearbyItem_location = spotNearbyItem_location obj} then P.Nothing else P.Just $ default_SpotNearbyItem{spotNearbyItem_location = spotNearbyItem_location obj}
    ]
from_SpotNearbyItem :: SpotNearbyItem -> T.ThriftVal
from_SpotNearbyItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v350 -> P.Just (2, ("spotItem",from_SpotItem _v350))) $ spotNearbyItem_spotItem record
  , (\_v350 -> P.Just (11, ("location",from_Location _v350))) $ spotNearbyItem_location record
  ]
write_SpotNearbyItem :: T.Protocol p => p -> SpotNearbyItem -> P.IO ()
write_SpotNearbyItem oprot record = T.writeVal oprot $ from_SpotNearbyItem record
encode_SpotNearbyItem :: T.StatelessProtocol p => p -> SpotNearbyItem -> LBS.ByteString
encode_SpotNearbyItem oprot record = T.serializeVal oprot $ from_SpotNearbyItem record
to_SpotNearbyItem :: T.ThriftVal -> SpotNearbyItem
to_SpotNearbyItem (T.TStruct fields) = SpotNearbyItem{
  spotNearbyItem_spotItem = P.maybe (spotNearbyItem_spotItem default_SpotNearbyItem) (\(_,_val352) -> (case _val352 of {T.TStruct _val353 -> (to_SpotItem (T.TStruct _val353)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  spotNearbyItem_location = P.maybe (spotNearbyItem_location default_SpotNearbyItem) (\(_,_val352) -> (case _val352 of {T.TStruct _val354 -> (to_Location (T.TStruct _val354)); _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_SpotNearbyItem _ = P.error "not a struct"
read_SpotNearbyItem :: T.Protocol p => p -> P.IO SpotNearbyItem
read_SpotNearbyItem iprot = to_SpotNearbyItem <$> T.readVal iprot (T.T_STRUCT typemap_SpotNearbyItem)
decode_SpotNearbyItem :: T.StatelessProtocol p => p -> LBS.ByteString -> SpotNearbyItem
decode_SpotNearbyItem iprot bs = to_SpotNearbyItem $ T.deserializeVal iprot (T.T_STRUCT typemap_SpotNearbyItem) bs
typemap_SpotNearbyItem :: T.TypeMap
typemap_SpotNearbyItem = Map.fromList [(2,("spotItem",(T.T_STRUCT typemap_SpotItem))),(11,("location",(T.T_STRUCT typemap_Location)))]
default_SpotNearbyItem :: SpotNearbyItem
default_SpotNearbyItem = SpotNearbyItem{
  spotNearbyItem_spotItem = default_SpotItem,
  spotNearbyItem_location = default_Location}
data SpotNearbyResponse = SpotNearbyResponse  { spotNearbyResponse_spotNearbyItems :: (Vector.Vector SpotNearbyItem)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpotNearbyResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` spotNearbyResponse_spotNearbyItems record  
instance QC.Arbitrary SpotNearbyResponse where 
  arbitrary = M.liftM SpotNearbyResponse (QC.arbitrary)
  shrink obj | obj == default_SpotNearbyResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpotNearbyResponse{spotNearbyResponse_spotNearbyItems = spotNearbyResponse_spotNearbyItems obj} then P.Nothing else P.Just $ default_SpotNearbyResponse{spotNearbyResponse_spotNearbyItems = spotNearbyResponse_spotNearbyItems obj}
    ]
from_SpotNearbyResponse :: SpotNearbyResponse -> T.ThriftVal
from_SpotNearbyResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v357 -> P.Just (1, ("spotNearbyItems",T.TList (T.T_STRUCT typemap_SpotNearbyItem) $ P.map (\_v359 -> from_SpotNearbyItem _v359) $ Vector.toList _v357))) $ spotNearbyResponse_spotNearbyItems record
  ]
write_SpotNearbyResponse :: T.Protocol p => p -> SpotNearbyResponse -> P.IO ()
write_SpotNearbyResponse oprot record = T.writeVal oprot $ from_SpotNearbyResponse record
encode_SpotNearbyResponse :: T.StatelessProtocol p => p -> SpotNearbyResponse -> LBS.ByteString
encode_SpotNearbyResponse oprot record = T.serializeVal oprot $ from_SpotNearbyResponse record
to_SpotNearbyResponse :: T.ThriftVal -> SpotNearbyResponse
to_SpotNearbyResponse (T.TStruct fields) = SpotNearbyResponse{
  spotNearbyResponse_spotNearbyItems = P.maybe (spotNearbyResponse_spotNearbyItems default_SpotNearbyResponse) (\(_,_val361) -> (case _val361 of {T.TList _ _val362 -> (Vector.fromList $ P.map (\_v363 -> (case _v363 of {T.TStruct _val364 -> (to_SpotNearbyItem (T.TStruct _val364)); _ -> P.error "wrong type"})) _val362); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SpotNearbyResponse _ = P.error "not a struct"
read_SpotNearbyResponse :: T.Protocol p => p -> P.IO SpotNearbyResponse
read_SpotNearbyResponse iprot = to_SpotNearbyResponse <$> T.readVal iprot (T.T_STRUCT typemap_SpotNearbyResponse)
decode_SpotNearbyResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SpotNearbyResponse
decode_SpotNearbyResponse iprot bs = to_SpotNearbyResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SpotNearbyResponse) bs
typemap_SpotNearbyResponse :: T.TypeMap
typemap_SpotNearbyResponse = Map.fromList [(1,("spotNearbyItems",(T.T_LIST (T.T_STRUCT typemap_SpotNearbyItem))))]
default_SpotNearbyResponse :: SpotNearbyResponse
default_SpotNearbyResponse = SpotNearbyResponse{
  spotNearbyResponse_spotNearbyItems = Vector.empty}
data SpotPhoneNumberResponse = SpotPhoneNumberResponse  { spotPhoneNumberResponse_spotItems :: (Vector.Vector SpotItem)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SpotPhoneNumberResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` spotPhoneNumberResponse_spotItems record  
instance QC.Arbitrary SpotPhoneNumberResponse where 
  arbitrary = M.liftM SpotPhoneNumberResponse (QC.arbitrary)
  shrink obj | obj == default_SpotPhoneNumberResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SpotPhoneNumberResponse{spotPhoneNumberResponse_spotItems = spotPhoneNumberResponse_spotItems obj} then P.Nothing else P.Just $ default_SpotPhoneNumberResponse{spotPhoneNumberResponse_spotItems = spotPhoneNumberResponse_spotItems obj}
    ]
from_SpotPhoneNumberResponse :: SpotPhoneNumberResponse -> T.ThriftVal
from_SpotPhoneNumberResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v367 -> P.Just (1, ("spotItems",T.TList (T.T_STRUCT typemap_SpotItem) $ P.map (\_v369 -> from_SpotItem _v369) $ Vector.toList _v367))) $ spotPhoneNumberResponse_spotItems record
  ]
write_SpotPhoneNumberResponse :: T.Protocol p => p -> SpotPhoneNumberResponse -> P.IO ()
write_SpotPhoneNumberResponse oprot record = T.writeVal oprot $ from_SpotPhoneNumberResponse record
encode_SpotPhoneNumberResponse :: T.StatelessProtocol p => p -> SpotPhoneNumberResponse -> LBS.ByteString
encode_SpotPhoneNumberResponse oprot record = T.serializeVal oprot $ from_SpotPhoneNumberResponse record
to_SpotPhoneNumberResponse :: T.ThriftVal -> SpotPhoneNumberResponse
to_SpotPhoneNumberResponse (T.TStruct fields) = SpotPhoneNumberResponse{
  spotPhoneNumberResponse_spotItems = P.maybe (spotPhoneNumberResponse_spotItems default_SpotPhoneNumberResponse) (\(_,_val371) -> (case _val371 of {T.TList _ _val372 -> (Vector.fromList $ P.map (\_v373 -> (case _v373 of {T.TStruct _val374 -> (to_SpotItem (T.TStruct _val374)); _ -> P.error "wrong type"})) _val372); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SpotPhoneNumberResponse _ = P.error "not a struct"
read_SpotPhoneNumberResponse :: T.Protocol p => p -> P.IO SpotPhoneNumberResponse
read_SpotPhoneNumberResponse iprot = to_SpotPhoneNumberResponse <$> T.readVal iprot (T.T_STRUCT typemap_SpotPhoneNumberResponse)
decode_SpotPhoneNumberResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SpotPhoneNumberResponse
decode_SpotPhoneNumberResponse iprot bs = to_SpotPhoneNumberResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SpotPhoneNumberResponse) bs
typemap_SpotPhoneNumberResponse :: T.TypeMap
typemap_SpotPhoneNumberResponse = Map.fromList [(1,("spotItems",(T.T_LIST (T.T_STRUCT typemap_SpotItem))))]
default_SpotPhoneNumberResponse :: SpotPhoneNumberResponse
default_SpotPhoneNumberResponse = SpotPhoneNumberResponse{
  spotPhoneNumberResponse_spotItems = Vector.empty}
data PaidCallHistory = PaidCallHistory  { paidCallHistory_seq :: I.Int64
  , paidCallHistory_type :: PaidCallType
  , paidCallHistory_dialedNumber :: LT.Text
  , paidCallHistory_calledNumber :: LT.Text
  , paidCallHistory_toMid :: LT.Text
  , paidCallHistory_toName :: LT.Text
  , paidCallHistory_setupTime :: I.Int64
  , paidCallHistory_startTime :: I.Int64
  , paidCallHistory_endTime :: I.Int64
  , paidCallHistory_duration :: I.Int64
  , paidCallHistory_terminate :: I.Int32
  , paidCallHistory_productType :: PaidCallProductType
  , paidCallHistory_charge :: I.Int32
  , paidCallHistory_unit :: LT.Text
  , paidCallHistory_result :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallHistory where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallHistory_seq record   `H.hashWithSalt` paidCallHistory_type record   `H.hashWithSalt` paidCallHistory_dialedNumber record   `H.hashWithSalt` paidCallHistory_calledNumber record   `H.hashWithSalt` paidCallHistory_toMid record   `H.hashWithSalt` paidCallHistory_toName record   `H.hashWithSalt` paidCallHistory_setupTime record   `H.hashWithSalt` paidCallHistory_startTime record   `H.hashWithSalt` paidCallHistory_endTime record   `H.hashWithSalt` paidCallHistory_duration record   `H.hashWithSalt` paidCallHistory_terminate record   `H.hashWithSalt` paidCallHistory_productType record   `H.hashWithSalt` paidCallHistory_charge record   `H.hashWithSalt` paidCallHistory_unit record   `H.hashWithSalt` paidCallHistory_result record  
instance QC.Arbitrary PaidCallHistory where 
  arbitrary = M.liftM PaidCallHistory (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallHistory = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallHistory{paidCallHistory_seq = paidCallHistory_seq obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_seq = paidCallHistory_seq obj}
    , if obj == default_PaidCallHistory{paidCallHistory_type = paidCallHistory_type obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_type = paidCallHistory_type obj}
    , if obj == default_PaidCallHistory{paidCallHistory_dialedNumber = paidCallHistory_dialedNumber obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_dialedNumber = paidCallHistory_dialedNumber obj}
    , if obj == default_PaidCallHistory{paidCallHistory_calledNumber = paidCallHistory_calledNumber obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_calledNumber = paidCallHistory_calledNumber obj}
    , if obj == default_PaidCallHistory{paidCallHistory_toMid = paidCallHistory_toMid obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_toMid = paidCallHistory_toMid obj}
    , if obj == default_PaidCallHistory{paidCallHistory_toName = paidCallHistory_toName obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_toName = paidCallHistory_toName obj}
    , if obj == default_PaidCallHistory{paidCallHistory_setupTime = paidCallHistory_setupTime obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_setupTime = paidCallHistory_setupTime obj}
    , if obj == default_PaidCallHistory{paidCallHistory_startTime = paidCallHistory_startTime obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_startTime = paidCallHistory_startTime obj}
    , if obj == default_PaidCallHistory{paidCallHistory_endTime = paidCallHistory_endTime obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_endTime = paidCallHistory_endTime obj}
    , if obj == default_PaidCallHistory{paidCallHistory_duration = paidCallHistory_duration obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_duration = paidCallHistory_duration obj}
    , if obj == default_PaidCallHistory{paidCallHistory_terminate = paidCallHistory_terminate obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_terminate = paidCallHistory_terminate obj}
    , if obj == default_PaidCallHistory{paidCallHistory_productType = paidCallHistory_productType obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_productType = paidCallHistory_productType obj}
    , if obj == default_PaidCallHistory{paidCallHistory_charge = paidCallHistory_charge obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_charge = paidCallHistory_charge obj}
    , if obj == default_PaidCallHistory{paidCallHistory_unit = paidCallHistory_unit obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_unit = paidCallHistory_unit obj}
    , if obj == default_PaidCallHistory{paidCallHistory_result = paidCallHistory_result obj} then P.Nothing else P.Just $ default_PaidCallHistory{paidCallHistory_result = paidCallHistory_result obj}
    ]
from_PaidCallHistory :: PaidCallHistory -> T.ThriftVal
from_PaidCallHistory record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v377 -> P.Just (1, ("seq",T.TI64 _v377))) $ paidCallHistory_seq record
  , (\_v377 -> P.Just (2, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v377))) $ paidCallHistory_type record
  , (\_v377 -> P.Just (3, ("dialedNumber",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_dialedNumber record
  , (\_v377 -> P.Just (4, ("calledNumber",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_calledNumber record
  , (\_v377 -> P.Just (5, ("toMid",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_toMid record
  , (\_v377 -> P.Just (6, ("toName",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_toName record
  , (\_v377 -> P.Just (7, ("setupTime",T.TI64 _v377))) $ paidCallHistory_setupTime record
  , (\_v377 -> P.Just (8, ("startTime",T.TI64 _v377))) $ paidCallHistory_startTime record
  , (\_v377 -> P.Just (9, ("endTime",T.TI64 _v377))) $ paidCallHistory_endTime record
  , (\_v377 -> P.Just (10, ("duration",T.TI64 _v377))) $ paidCallHistory_duration record
  , (\_v377 -> P.Just (11, ("terminate",T.TI32 _v377))) $ paidCallHistory_terminate record
  , (\_v377 -> P.Just (12, ("productType",T.TI32 $ P.fromIntegral $ P.fromEnum _v377))) $ paidCallHistory_productType record
  , (\_v377 -> P.Just (13, ("charge",T.TI32 _v377))) $ paidCallHistory_charge record
  , (\_v377 -> P.Just (14, ("unit",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_unit record
  , (\_v377 -> P.Just (15, ("result",T.TString $ E.encodeUtf8 _v377))) $ paidCallHistory_result record
  ]
write_PaidCallHistory :: T.Protocol p => p -> PaidCallHistory -> P.IO ()
write_PaidCallHistory oprot record = T.writeVal oprot $ from_PaidCallHistory record
encode_PaidCallHistory :: T.StatelessProtocol p => p -> PaidCallHistory -> LBS.ByteString
encode_PaidCallHistory oprot record = T.serializeVal oprot $ from_PaidCallHistory record
to_PaidCallHistory :: T.ThriftVal -> PaidCallHistory
to_PaidCallHistory (T.TStruct fields) = PaidCallHistory{
  paidCallHistory_seq = P.maybe (paidCallHistory_seq default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI64 _val380 -> _val380; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallHistory_type = P.maybe (paidCallHistory_type default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI32 _val381 -> P.toEnum $ P.fromIntegral _val381; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallHistory_dialedNumber = P.maybe (paidCallHistory_dialedNumber default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val382 -> E.decodeUtf8 _val382; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallHistory_calledNumber = P.maybe (paidCallHistory_calledNumber default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val383 -> E.decodeUtf8 _val383; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paidCallHistory_toMid = P.maybe (paidCallHistory_toMid default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val384 -> E.decodeUtf8 _val384; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paidCallHistory_toName = P.maybe (paidCallHistory_toName default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val385 -> E.decodeUtf8 _val385; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  paidCallHistory_setupTime = P.maybe (paidCallHistory_setupTime default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI64 _val386 -> _val386; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  paidCallHistory_startTime = P.maybe (paidCallHistory_startTime default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI64 _val387 -> _val387; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  paidCallHistory_endTime = P.maybe (paidCallHistory_endTime default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI64 _val388 -> _val388; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  paidCallHistory_duration = P.maybe (paidCallHistory_duration default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI64 _val389 -> _val389; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  paidCallHistory_terminate = P.maybe (paidCallHistory_terminate default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI32 _val390 -> _val390; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  paidCallHistory_productType = P.maybe (paidCallHistory_productType default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI32 _val391 -> P.toEnum $ P.fromIntegral _val391; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  paidCallHistory_charge = P.maybe (paidCallHistory_charge default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TI32 _val392 -> _val392; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  paidCallHistory_unit = P.maybe (paidCallHistory_unit default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val393 -> E.decodeUtf8 _val393; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  paidCallHistory_result = P.maybe (paidCallHistory_result default_PaidCallHistory) (\(_,_val379) -> (case _val379 of {T.TString _val394 -> E.decodeUtf8 _val394; _ -> P.error "wrong type"})) (Map.lookup (15) fields)
  }
to_PaidCallHistory _ = P.error "not a struct"
read_PaidCallHistory :: T.Protocol p => p -> P.IO PaidCallHistory
read_PaidCallHistory iprot = to_PaidCallHistory <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallHistory)
decode_PaidCallHistory :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallHistory
decode_PaidCallHistory iprot bs = to_PaidCallHistory $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallHistory) bs
typemap_PaidCallHistory :: T.TypeMap
typemap_PaidCallHistory = Map.fromList [(1,("seq",T.T_I64)),(2,("type",T.T_I32)),(3,("dialedNumber",T.T_STRING)),(4,("calledNumber",T.T_STRING)),(5,("toMid",T.T_STRING)),(6,("toName",T.T_STRING)),(7,("setupTime",T.T_I64)),(8,("startTime",T.T_I64)),(9,("endTime",T.T_I64)),(10,("duration",T.T_I64)),(11,("terminate",T.T_I32)),(12,("productType",T.T_I32)),(13,("charge",T.T_I32)),(14,("unit",T.T_STRING)),(15,("result",T.T_STRING))]
default_PaidCallHistory :: PaidCallHistory
default_PaidCallHistory = PaidCallHistory{
  paidCallHistory_seq = 0,
  paidCallHistory_type = (P.toEnum 0),
  paidCallHistory_dialedNumber = "",
  paidCallHistory_calledNumber = "",
  paidCallHistory_toMid = "",
  paidCallHistory_toName = "",
  paidCallHistory_setupTime = 0,
  paidCallHistory_startTime = 0,
  paidCallHistory_endTime = 0,
  paidCallHistory_duration = 0,
  paidCallHistory_terminate = 0,
  paidCallHistory_productType = (P.toEnum 0),
  paidCallHistory_charge = 0,
  paidCallHistory_unit = "",
  paidCallHistory_result = ""}
data PaidCallHistoryResult = PaidCallHistoryResult  { paidCallHistoryResult_historys :: (Vector.Vector PaidCallHistory)
  , paidCallHistoryResult_hasNext :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallHistoryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallHistoryResult_historys record   `H.hashWithSalt` paidCallHistoryResult_hasNext record  
instance QC.Arbitrary PaidCallHistoryResult where 
  arbitrary = M.liftM PaidCallHistoryResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallHistoryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallHistoryResult{paidCallHistoryResult_historys = paidCallHistoryResult_historys obj} then P.Nothing else P.Just $ default_PaidCallHistoryResult{paidCallHistoryResult_historys = paidCallHistoryResult_historys obj}
    , if obj == default_PaidCallHistoryResult{paidCallHistoryResult_hasNext = paidCallHistoryResult_hasNext obj} then P.Nothing else P.Just $ default_PaidCallHistoryResult{paidCallHistoryResult_hasNext = paidCallHistoryResult_hasNext obj}
    ]
from_PaidCallHistoryResult :: PaidCallHistoryResult -> T.ThriftVal
from_PaidCallHistoryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v397 -> P.Just (1, ("historys",T.TList (T.T_STRUCT typemap_PaidCallHistory) $ P.map (\_v399 -> from_PaidCallHistory _v399) $ Vector.toList _v397))) $ paidCallHistoryResult_historys record
  , (\_v397 -> P.Just (2, ("hasNext",T.TBool _v397))) $ paidCallHistoryResult_hasNext record
  ]
write_PaidCallHistoryResult :: T.Protocol p => p -> PaidCallHistoryResult -> P.IO ()
write_PaidCallHistoryResult oprot record = T.writeVal oprot $ from_PaidCallHistoryResult record
encode_PaidCallHistoryResult :: T.StatelessProtocol p => p -> PaidCallHistoryResult -> LBS.ByteString
encode_PaidCallHistoryResult oprot record = T.serializeVal oprot $ from_PaidCallHistoryResult record
to_PaidCallHistoryResult :: T.ThriftVal -> PaidCallHistoryResult
to_PaidCallHistoryResult (T.TStruct fields) = PaidCallHistoryResult{
  paidCallHistoryResult_historys = P.maybe (paidCallHistoryResult_historys default_PaidCallHistoryResult) (\(_,_val401) -> (case _val401 of {T.TList _ _val402 -> (Vector.fromList $ P.map (\_v403 -> (case _v403 of {T.TStruct _val404 -> (to_PaidCallHistory (T.TStruct _val404)); _ -> P.error "wrong type"})) _val402); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallHistoryResult_hasNext = P.maybe (paidCallHistoryResult_hasNext default_PaidCallHistoryResult) (\(_,_val401) -> (case _val401 of {T.TBool _val405 -> _val405; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PaidCallHistoryResult _ = P.error "not a struct"
read_PaidCallHistoryResult :: T.Protocol p => p -> P.IO PaidCallHistoryResult
read_PaidCallHistoryResult iprot = to_PaidCallHistoryResult <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallHistoryResult)
decode_PaidCallHistoryResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallHistoryResult
decode_PaidCallHistoryResult iprot bs = to_PaidCallHistoryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallHistoryResult) bs
typemap_PaidCallHistoryResult :: T.TypeMap
typemap_PaidCallHistoryResult = Map.fromList [(1,("historys",(T.T_LIST (T.T_STRUCT typemap_PaidCallHistory)))),(2,("hasNext",T.T_BOOL))]
default_PaidCallHistoryResult :: PaidCallHistoryResult
default_PaidCallHistoryResult = PaidCallHistoryResult{
  paidCallHistoryResult_historys = Vector.empty,
  paidCallHistoryResult_hasNext = P.False}
data PaidCallMetadataResult = PaidCallMetadataResult  { paidCallMetadataResult_currencyExchangeRates :: (Vector.Vector PaidCallCurrencyExchangeRate)
  , paidCallMetadataResult_recommendedCountryCodes :: (Vector.Vector LT.Text)
  , paidCallMetadataResult_adCountries :: (Vector.Vector PaidCallAdCountry)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallMetadataResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallMetadataResult_currencyExchangeRates record   `H.hashWithSalt` paidCallMetadataResult_recommendedCountryCodes record   `H.hashWithSalt` paidCallMetadataResult_adCountries record  
instance QC.Arbitrary PaidCallMetadataResult where 
  arbitrary = M.liftM PaidCallMetadataResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallMetadataResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallMetadataResult{paidCallMetadataResult_currencyExchangeRates = paidCallMetadataResult_currencyExchangeRates obj} then P.Nothing else P.Just $ default_PaidCallMetadataResult{paidCallMetadataResult_currencyExchangeRates = paidCallMetadataResult_currencyExchangeRates obj}
    , if obj == default_PaidCallMetadataResult{paidCallMetadataResult_recommendedCountryCodes = paidCallMetadataResult_recommendedCountryCodes obj} then P.Nothing else P.Just $ default_PaidCallMetadataResult{paidCallMetadataResult_recommendedCountryCodes = paidCallMetadataResult_recommendedCountryCodes obj}
    , if obj == default_PaidCallMetadataResult{paidCallMetadataResult_adCountries = paidCallMetadataResult_adCountries obj} then P.Nothing else P.Just $ default_PaidCallMetadataResult{paidCallMetadataResult_adCountries = paidCallMetadataResult_adCountries obj}
    ]
from_PaidCallMetadataResult :: PaidCallMetadataResult -> T.ThriftVal
from_PaidCallMetadataResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v408 -> P.Just (1, ("currencyExchangeRates",T.TList (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate) $ P.map (\_v410 -> from_PaidCallCurrencyExchangeRate _v410) $ Vector.toList _v408))) $ paidCallMetadataResult_currencyExchangeRates record
  , (\_v408 -> P.Just (2, ("recommendedCountryCodes",T.TList T.T_STRING $ P.map (\_v412 -> T.TString $ E.encodeUtf8 _v412) $ Vector.toList _v408))) $ paidCallMetadataResult_recommendedCountryCodes record
  , (\_v408 -> P.Just (3, ("adCountries",T.TList (T.T_STRUCT typemap_PaidCallAdCountry) $ P.map (\_v414 -> from_PaidCallAdCountry _v414) $ Vector.toList _v408))) $ paidCallMetadataResult_adCountries record
  ]
write_PaidCallMetadataResult :: T.Protocol p => p -> PaidCallMetadataResult -> P.IO ()
write_PaidCallMetadataResult oprot record = T.writeVal oprot $ from_PaidCallMetadataResult record
encode_PaidCallMetadataResult :: T.StatelessProtocol p => p -> PaidCallMetadataResult -> LBS.ByteString
encode_PaidCallMetadataResult oprot record = T.serializeVal oprot $ from_PaidCallMetadataResult record
to_PaidCallMetadataResult :: T.ThriftVal -> PaidCallMetadataResult
to_PaidCallMetadataResult (T.TStruct fields) = PaidCallMetadataResult{
  paidCallMetadataResult_currencyExchangeRates = P.maybe (paidCallMetadataResult_currencyExchangeRates default_PaidCallMetadataResult) (\(_,_val416) -> (case _val416 of {T.TList _ _val417 -> (Vector.fromList $ P.map (\_v418 -> (case _v418 of {T.TStruct _val419 -> (to_PaidCallCurrencyExchangeRate (T.TStruct _val419)); _ -> P.error "wrong type"})) _val417); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallMetadataResult_recommendedCountryCodes = P.maybe (paidCallMetadataResult_recommendedCountryCodes default_PaidCallMetadataResult) (\(_,_val416) -> (case _val416 of {T.TList _ _val420 -> (Vector.fromList $ P.map (\_v421 -> (case _v421 of {T.TString _val422 -> E.decodeUtf8 _val422; _ -> P.error "wrong type"})) _val420); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallMetadataResult_adCountries = P.maybe (paidCallMetadataResult_adCountries default_PaidCallMetadataResult) (\(_,_val416) -> (case _val416 of {T.TList _ _val423 -> (Vector.fromList $ P.map (\_v424 -> (case _v424 of {T.TStruct _val425 -> (to_PaidCallAdCountry (T.TStruct _val425)); _ -> P.error "wrong type"})) _val423); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PaidCallMetadataResult _ = P.error "not a struct"
read_PaidCallMetadataResult :: T.Protocol p => p -> P.IO PaidCallMetadataResult
read_PaidCallMetadataResult iprot = to_PaidCallMetadataResult <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallMetadataResult)
decode_PaidCallMetadataResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallMetadataResult
decode_PaidCallMetadataResult iprot bs = to_PaidCallMetadataResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallMetadataResult) bs
typemap_PaidCallMetadataResult :: T.TypeMap
typemap_PaidCallMetadataResult = Map.fromList [(1,("currencyExchangeRates",(T.T_LIST (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate)))),(2,("recommendedCountryCodes",(T.T_LIST T.T_STRING))),(3,("adCountries",(T.T_LIST (T.T_STRUCT typemap_PaidCallAdCountry))))]
default_PaidCallMetadataResult :: PaidCallMetadataResult
default_PaidCallMetadataResult = PaidCallMetadataResult{
  paidCallMetadataResult_currencyExchangeRates = Vector.empty,
  paidCallMetadataResult_recommendedCountryCodes = Vector.empty,
  paidCallMetadataResult_adCountries = Vector.empty}
data PaidCallRedeemResult = PaidCallRedeemResult  { paidCallRedeemResult_eventName :: LT.Text
  , paidCallRedeemResult_eventAmount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallRedeemResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallRedeemResult_eventName record   `H.hashWithSalt` paidCallRedeemResult_eventAmount record  
instance QC.Arbitrary PaidCallRedeemResult where 
  arbitrary = M.liftM PaidCallRedeemResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallRedeemResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallRedeemResult{paidCallRedeemResult_eventName = paidCallRedeemResult_eventName obj} then P.Nothing else P.Just $ default_PaidCallRedeemResult{paidCallRedeemResult_eventName = paidCallRedeemResult_eventName obj}
    , if obj == default_PaidCallRedeemResult{paidCallRedeemResult_eventAmount = paidCallRedeemResult_eventAmount obj} then P.Nothing else P.Just $ default_PaidCallRedeemResult{paidCallRedeemResult_eventAmount = paidCallRedeemResult_eventAmount obj}
    ]
from_PaidCallRedeemResult :: PaidCallRedeemResult -> T.ThriftVal
from_PaidCallRedeemResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v428 -> P.Just (1, ("eventName",T.TString $ E.encodeUtf8 _v428))) $ paidCallRedeemResult_eventName record
  , (\_v428 -> P.Just (2, ("eventAmount",T.TI32 _v428))) $ paidCallRedeemResult_eventAmount record
  ]
write_PaidCallRedeemResult :: T.Protocol p => p -> PaidCallRedeemResult -> P.IO ()
write_PaidCallRedeemResult oprot record = T.writeVal oprot $ from_PaidCallRedeemResult record
encode_PaidCallRedeemResult :: T.StatelessProtocol p => p -> PaidCallRedeemResult -> LBS.ByteString
encode_PaidCallRedeemResult oprot record = T.serializeVal oprot $ from_PaidCallRedeemResult record
to_PaidCallRedeemResult :: T.ThriftVal -> PaidCallRedeemResult
to_PaidCallRedeemResult (T.TStruct fields) = PaidCallRedeemResult{
  paidCallRedeemResult_eventName = P.maybe (paidCallRedeemResult_eventName default_PaidCallRedeemResult) (\(_,_val430) -> (case _val430 of {T.TString _val431 -> E.decodeUtf8 _val431; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallRedeemResult_eventAmount = P.maybe (paidCallRedeemResult_eventAmount default_PaidCallRedeemResult) (\(_,_val430) -> (case _val430 of {T.TI32 _val432 -> _val432; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_PaidCallRedeemResult _ = P.error "not a struct"
read_PaidCallRedeemResult :: T.Protocol p => p -> P.IO PaidCallRedeemResult
read_PaidCallRedeemResult iprot = to_PaidCallRedeemResult <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallRedeemResult)
decode_PaidCallRedeemResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallRedeemResult
decode_PaidCallRedeemResult iprot bs = to_PaidCallRedeemResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallRedeemResult) bs
typemap_PaidCallRedeemResult :: T.TypeMap
typemap_PaidCallRedeemResult = Map.fromList [(1,("eventName",T.T_STRING)),(2,("eventAmount",T.T_I32))]
default_PaidCallRedeemResult :: PaidCallRedeemResult
default_PaidCallRedeemResult = PaidCallRedeemResult{
  paidCallRedeemResult_eventName = "",
  paidCallRedeemResult_eventAmount = 0}
data PaidCallResponse = PaidCallResponse  { paidCallResponse_host :: CallHost
  , paidCallResponse_dialing :: PaidCallDialing
  , paidCallResponse_token :: LT.Text
  , paidCallResponse_spotItems :: (Vector.Vector SpotItem)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallResponse_host record   `H.hashWithSalt` paidCallResponse_dialing record   `H.hashWithSalt` paidCallResponse_token record   `H.hashWithSalt` paidCallResponse_spotItems record  
instance QC.Arbitrary PaidCallResponse where 
  arbitrary = M.liftM PaidCallResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallResponse{paidCallResponse_host = paidCallResponse_host obj} then P.Nothing else P.Just $ default_PaidCallResponse{paidCallResponse_host = paidCallResponse_host obj}
    , if obj == default_PaidCallResponse{paidCallResponse_dialing = paidCallResponse_dialing obj} then P.Nothing else P.Just $ default_PaidCallResponse{paidCallResponse_dialing = paidCallResponse_dialing obj}
    , if obj == default_PaidCallResponse{paidCallResponse_token = paidCallResponse_token obj} then P.Nothing else P.Just $ default_PaidCallResponse{paidCallResponse_token = paidCallResponse_token obj}
    , if obj == default_PaidCallResponse{paidCallResponse_spotItems = paidCallResponse_spotItems obj} then P.Nothing else P.Just $ default_PaidCallResponse{paidCallResponse_spotItems = paidCallResponse_spotItems obj}
    ]
from_PaidCallResponse :: PaidCallResponse -> T.ThriftVal
from_PaidCallResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v435 -> P.Just (1, ("host",from_CallHost _v435))) $ paidCallResponse_host record
  , (\_v435 -> P.Just (2, ("dialing",from_PaidCallDialing _v435))) $ paidCallResponse_dialing record
  , (\_v435 -> P.Just (3, ("token",T.TString $ E.encodeUtf8 _v435))) $ paidCallResponse_token record
  , (\_v435 -> P.Just (4, ("spotItems",T.TList (T.T_STRUCT typemap_SpotItem) $ P.map (\_v437 -> from_SpotItem _v437) $ Vector.toList _v435))) $ paidCallResponse_spotItems record
  ]
write_PaidCallResponse :: T.Protocol p => p -> PaidCallResponse -> P.IO ()
write_PaidCallResponse oprot record = T.writeVal oprot $ from_PaidCallResponse record
encode_PaidCallResponse :: T.StatelessProtocol p => p -> PaidCallResponse -> LBS.ByteString
encode_PaidCallResponse oprot record = T.serializeVal oprot $ from_PaidCallResponse record
to_PaidCallResponse :: T.ThriftVal -> PaidCallResponse
to_PaidCallResponse (T.TStruct fields) = PaidCallResponse{
  paidCallResponse_host = P.maybe (paidCallResponse_host default_PaidCallResponse) (\(_,_val439) -> (case _val439 of {T.TStruct _val440 -> (to_CallHost (T.TStruct _val440)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallResponse_dialing = P.maybe (paidCallResponse_dialing default_PaidCallResponse) (\(_,_val439) -> (case _val439 of {T.TStruct _val441 -> (to_PaidCallDialing (T.TStruct _val441)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallResponse_token = P.maybe (paidCallResponse_token default_PaidCallResponse) (\(_,_val439) -> (case _val439 of {T.TString _val442 -> E.decodeUtf8 _val442; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallResponse_spotItems = P.maybe (paidCallResponse_spotItems default_PaidCallResponse) (\(_,_val439) -> (case _val439 of {T.TList _ _val443 -> (Vector.fromList $ P.map (\_v444 -> (case _v444 of {T.TStruct _val445 -> (to_SpotItem (T.TStruct _val445)); _ -> P.error "wrong type"})) _val443); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_PaidCallResponse _ = P.error "not a struct"
read_PaidCallResponse :: T.Protocol p => p -> P.IO PaidCallResponse
read_PaidCallResponse iprot = to_PaidCallResponse <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallResponse)
decode_PaidCallResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallResponse
decode_PaidCallResponse iprot bs = to_PaidCallResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallResponse) bs
typemap_PaidCallResponse :: T.TypeMap
typemap_PaidCallResponse = Map.fromList [(1,("host",(T.T_STRUCT typemap_CallHost))),(2,("dialing",(T.T_STRUCT typemap_PaidCallDialing))),(3,("token",T.T_STRING)),(4,("spotItems",(T.T_LIST (T.T_STRUCT typemap_SpotItem))))]
default_PaidCallResponse :: PaidCallResponse
default_PaidCallResponse = PaidCallResponse{
  paidCallResponse_host = default_CallHost,
  paidCallResponse_dialing = default_PaidCallDialing,
  paidCallResponse_token = "",
  paidCallResponse_spotItems = Vector.empty}
data PaidCallUserRate = PaidCallUserRate  { paidCallUserRate_countryCode :: LT.Text
  , paidCallUserRate_rate :: I.Int32
  , paidCallUserRate_rateDivision :: LT.Text
  , paidCallUserRate_rateName :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaidCallUserRate where
  hashWithSalt salt record = salt   `H.hashWithSalt` paidCallUserRate_countryCode record   `H.hashWithSalt` paidCallUserRate_rate record   `H.hashWithSalt` paidCallUserRate_rateDivision record   `H.hashWithSalt` paidCallUserRate_rateName record  
instance QC.Arbitrary PaidCallUserRate where 
  arbitrary = M.liftM PaidCallUserRate (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaidCallUserRate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaidCallUserRate{paidCallUserRate_countryCode = paidCallUserRate_countryCode obj} then P.Nothing else P.Just $ default_PaidCallUserRate{paidCallUserRate_countryCode = paidCallUserRate_countryCode obj}
    , if obj == default_PaidCallUserRate{paidCallUserRate_rate = paidCallUserRate_rate obj} then P.Nothing else P.Just $ default_PaidCallUserRate{paidCallUserRate_rate = paidCallUserRate_rate obj}
    , if obj == default_PaidCallUserRate{paidCallUserRate_rateDivision = paidCallUserRate_rateDivision obj} then P.Nothing else P.Just $ default_PaidCallUserRate{paidCallUserRate_rateDivision = paidCallUserRate_rateDivision obj}
    , if obj == default_PaidCallUserRate{paidCallUserRate_rateName = paidCallUserRate_rateName obj} then P.Nothing else P.Just $ default_PaidCallUserRate{paidCallUserRate_rateName = paidCallUserRate_rateName obj}
    ]
from_PaidCallUserRate :: PaidCallUserRate -> T.ThriftVal
from_PaidCallUserRate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v448 -> P.Just (1, ("countryCode",T.TString $ E.encodeUtf8 _v448))) $ paidCallUserRate_countryCode record
  , (\_v448 -> P.Just (2, ("rate",T.TI32 _v448))) $ paidCallUserRate_rate record
  , (\_v448 -> P.Just (3, ("rateDivision",T.TString $ E.encodeUtf8 _v448))) $ paidCallUserRate_rateDivision record
  , (\_v448 -> P.Just (4, ("rateName",T.TString $ E.encodeUtf8 _v448))) $ paidCallUserRate_rateName record
  ]
write_PaidCallUserRate :: T.Protocol p => p -> PaidCallUserRate -> P.IO ()
write_PaidCallUserRate oprot record = T.writeVal oprot $ from_PaidCallUserRate record
encode_PaidCallUserRate :: T.StatelessProtocol p => p -> PaidCallUserRate -> LBS.ByteString
encode_PaidCallUserRate oprot record = T.serializeVal oprot $ from_PaidCallUserRate record
to_PaidCallUserRate :: T.ThriftVal -> PaidCallUserRate
to_PaidCallUserRate (T.TStruct fields) = PaidCallUserRate{
  paidCallUserRate_countryCode = P.maybe (paidCallUserRate_countryCode default_PaidCallUserRate) (\(_,_val450) -> (case _val450 of {T.TString _val451 -> E.decodeUtf8 _val451; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paidCallUserRate_rate = P.maybe (paidCallUserRate_rate default_PaidCallUserRate) (\(_,_val450) -> (case _val450 of {T.TI32 _val452 -> _val452; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paidCallUserRate_rateDivision = P.maybe (paidCallUserRate_rateDivision default_PaidCallUserRate) (\(_,_val450) -> (case _val450 of {T.TString _val453 -> E.decodeUtf8 _val453; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paidCallUserRate_rateName = P.maybe (paidCallUserRate_rateName default_PaidCallUserRate) (\(_,_val450) -> (case _val450 of {T.TString _val454 -> E.decodeUtf8 _val454; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_PaidCallUserRate _ = P.error "not a struct"
read_PaidCallUserRate :: T.Protocol p => p -> P.IO PaidCallUserRate
read_PaidCallUserRate iprot = to_PaidCallUserRate <$> T.readVal iprot (T.T_STRUCT typemap_PaidCallUserRate)
decode_PaidCallUserRate :: T.StatelessProtocol p => p -> LBS.ByteString -> PaidCallUserRate
decode_PaidCallUserRate iprot bs = to_PaidCallUserRate $ T.deserializeVal iprot (T.T_STRUCT typemap_PaidCallUserRate) bs
typemap_PaidCallUserRate :: T.TypeMap
typemap_PaidCallUserRate = Map.fromList [(1,("countryCode",T.T_STRING)),(2,("rate",T.T_I32)),(3,("rateDivision",T.T_STRING)),(4,("rateName",T.T_STRING))]
default_PaidCallUserRate :: PaidCallUserRate
default_PaidCallUserRate = PaidCallUserRate{
  paidCallUserRate_countryCode = "",
  paidCallUserRate_rate = 0,
  paidCallUserRate_rateDivision = "",
  paidCallUserRate_rateName = ""}
data ChannelInfo = ChannelInfo  { channelInfo_channelId :: LT.Text
  , channelInfo_name :: LT.Text
  , channelInfo_entryPageUrl :: LT.Text
  , channelInfo_descriptionText :: LT.Text
  , channelInfo_provider :: ChannelProvider
  , channelInfo_publicType :: PublicType
  , channelInfo_iconImage :: LT.Text
  , channelInfo_permissions :: (Vector.Vector LT.Text)
  , channelInfo_iconThumbnailImage :: LT.Text
  , channelInfo_channelConfigurations :: (Vector.Vector ChannelConfiguration)
  , channelInfo_lcsAllApiUsable :: P.Bool
  , channelInfo_allowedPermissions :: (Set.HashSet ChannelPermission)
  , channelInfo_channelDomains :: (Vector.Vector ChannelDomain)
  , channelInfo_updatedTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelInfo_channelId record   `H.hashWithSalt` channelInfo_name record   `H.hashWithSalt` channelInfo_entryPageUrl record   `H.hashWithSalt` channelInfo_descriptionText record   `H.hashWithSalt` channelInfo_provider record   `H.hashWithSalt` channelInfo_publicType record   `H.hashWithSalt` channelInfo_iconImage record   `H.hashWithSalt` channelInfo_permissions record   `H.hashWithSalt` channelInfo_iconThumbnailImage record   `H.hashWithSalt` channelInfo_channelConfigurations record   `H.hashWithSalt` channelInfo_lcsAllApiUsable record   `H.hashWithSalt` channelInfo_allowedPermissions record   `H.hashWithSalt` channelInfo_channelDomains record   `H.hashWithSalt` channelInfo_updatedTimestamp record  
instance QC.Arbitrary ChannelInfo where 
  arbitrary = M.liftM ChannelInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelInfo{channelInfo_channelId = channelInfo_channelId obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_channelId = channelInfo_channelId obj}
    , if obj == default_ChannelInfo{channelInfo_name = channelInfo_name obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_name = channelInfo_name obj}
    , if obj == default_ChannelInfo{channelInfo_entryPageUrl = channelInfo_entryPageUrl obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_entryPageUrl = channelInfo_entryPageUrl obj}
    , if obj == default_ChannelInfo{channelInfo_descriptionText = channelInfo_descriptionText obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_descriptionText = channelInfo_descriptionText obj}
    , if obj == default_ChannelInfo{channelInfo_provider = channelInfo_provider obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_provider = channelInfo_provider obj}
    , if obj == default_ChannelInfo{channelInfo_publicType = channelInfo_publicType obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_publicType = channelInfo_publicType obj}
    , if obj == default_ChannelInfo{channelInfo_iconImage = channelInfo_iconImage obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_iconImage = channelInfo_iconImage obj}
    , if obj == default_ChannelInfo{channelInfo_permissions = channelInfo_permissions obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_permissions = channelInfo_permissions obj}
    , if obj == default_ChannelInfo{channelInfo_iconThumbnailImage = channelInfo_iconThumbnailImage obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_iconThumbnailImage = channelInfo_iconThumbnailImage obj}
    , if obj == default_ChannelInfo{channelInfo_channelConfigurations = channelInfo_channelConfigurations obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_channelConfigurations = channelInfo_channelConfigurations obj}
    , if obj == default_ChannelInfo{channelInfo_lcsAllApiUsable = channelInfo_lcsAllApiUsable obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_lcsAllApiUsable = channelInfo_lcsAllApiUsable obj}
    , if obj == default_ChannelInfo{channelInfo_allowedPermissions = channelInfo_allowedPermissions obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_allowedPermissions = channelInfo_allowedPermissions obj}
    , if obj == default_ChannelInfo{channelInfo_channelDomains = channelInfo_channelDomains obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_channelDomains = channelInfo_channelDomains obj}
    , if obj == default_ChannelInfo{channelInfo_updatedTimestamp = channelInfo_updatedTimestamp obj} then P.Nothing else P.Just $ default_ChannelInfo{channelInfo_updatedTimestamp = channelInfo_updatedTimestamp obj}
    ]
from_ChannelInfo :: ChannelInfo -> T.ThriftVal
from_ChannelInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v457 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_channelId record
  , (\_v457 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_name record
  , (\_v457 -> P.Just (4, ("entryPageUrl",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_entryPageUrl record
  , (\_v457 -> P.Just (5, ("descriptionText",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_descriptionText record
  , (\_v457 -> P.Just (6, ("provider",from_ChannelProvider _v457))) $ channelInfo_provider record
  , (\_v457 -> P.Just (7, ("publicType",T.TI32 $ P.fromIntegral $ P.fromEnum _v457))) $ channelInfo_publicType record
  , (\_v457 -> P.Just (8, ("iconImage",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_iconImage record
  , (\_v457 -> P.Just (9, ("permissions",T.TList T.T_STRING $ P.map (\_v459 -> T.TString $ E.encodeUtf8 _v459) $ Vector.toList _v457))) $ channelInfo_permissions record
  , (\_v457 -> P.Just (11, ("iconThumbnailImage",T.TString $ E.encodeUtf8 _v457))) $ channelInfo_iconThumbnailImage record
  , (\_v457 -> P.Just (12, ("channelConfigurations",T.TList T.T_I32 $ P.map (\_v461 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v461) $ Vector.toList _v457))) $ channelInfo_channelConfigurations record
  , (\_v457 -> P.Just (13, ("lcsAllApiUsable",T.TBool _v457))) $ channelInfo_lcsAllApiUsable record
  , (\_v457 -> P.Just (14, ("allowedPermissions",T.TSet T.T_I32 $ P.map (\_v463 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v463) $ Set.toList _v457))) $ channelInfo_allowedPermissions record
  , (\_v457 -> P.Just (15, ("channelDomains",T.TList (T.T_STRUCT typemap_ChannelDomain) $ P.map (\_v465 -> from_ChannelDomain _v465) $ Vector.toList _v457))) $ channelInfo_channelDomains record
  , (\_v457 -> P.Just (16, ("updatedTimestamp",T.TI64 _v457))) $ channelInfo_updatedTimestamp record
  ]
write_ChannelInfo :: T.Protocol p => p -> ChannelInfo -> P.IO ()
write_ChannelInfo oprot record = T.writeVal oprot $ from_ChannelInfo record
encode_ChannelInfo :: T.StatelessProtocol p => p -> ChannelInfo -> LBS.ByteString
encode_ChannelInfo oprot record = T.serializeVal oprot $ from_ChannelInfo record
to_ChannelInfo :: T.ThriftVal -> ChannelInfo
to_ChannelInfo (T.TStruct fields) = ChannelInfo{
  channelInfo_channelId = P.maybe (channelInfo_channelId default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val468 -> E.decodeUtf8 _val468; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelInfo_name = P.maybe (channelInfo_name default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val469 -> E.decodeUtf8 _val469; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelInfo_entryPageUrl = P.maybe (channelInfo_entryPageUrl default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val470 -> E.decodeUtf8 _val470; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelInfo_descriptionText = P.maybe (channelInfo_descriptionText default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val471 -> E.decodeUtf8 _val471; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  channelInfo_provider = P.maybe (channelInfo_provider default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TStruct _val472 -> (to_ChannelProvider (T.TStruct _val472)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  channelInfo_publicType = P.maybe (channelInfo_publicType default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TI32 _val473 -> P.toEnum $ P.fromIntegral _val473; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  channelInfo_iconImage = P.maybe (channelInfo_iconImage default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val474 -> E.decodeUtf8 _val474; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  channelInfo_permissions = P.maybe (channelInfo_permissions default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TList _ _val475 -> (Vector.fromList $ P.map (\_v476 -> (case _v476 of {T.TString _val477 -> E.decodeUtf8 _val477; _ -> P.error "wrong type"})) _val475); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  channelInfo_iconThumbnailImage = P.maybe (channelInfo_iconThumbnailImage default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TString _val478 -> E.decodeUtf8 _val478; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  channelInfo_channelConfigurations = P.maybe (channelInfo_channelConfigurations default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TList _ _val479 -> (Vector.fromList $ P.map (\_v480 -> (case _v480 of {T.TI32 _val481 -> P.toEnum $ P.fromIntegral _val481; _ -> P.error "wrong type"})) _val479); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  channelInfo_lcsAllApiUsable = P.maybe (channelInfo_lcsAllApiUsable default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TBool _val482 -> _val482; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  channelInfo_allowedPermissions = P.maybe (channelInfo_allowedPermissions default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TSet _ _val483 -> (Set.fromList $ P.map (\_v484 -> (case _v484 of {T.TI32 _val485 -> P.toEnum $ P.fromIntegral _val485; _ -> P.error "wrong type"})) _val483); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  channelInfo_channelDomains = P.maybe (channelInfo_channelDomains default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TList _ _val486 -> (Vector.fromList $ P.map (\_v487 -> (case _v487 of {T.TStruct _val488 -> (to_ChannelDomain (T.TStruct _val488)); _ -> P.error "wrong type"})) _val486); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  channelInfo_updatedTimestamp = P.maybe (channelInfo_updatedTimestamp default_ChannelInfo) (\(_,_val467) -> (case _val467 of {T.TI64 _val489 -> _val489; _ -> P.error "wrong type"})) (Map.lookup (16) fields)
  }
to_ChannelInfo _ = P.error "not a struct"
read_ChannelInfo :: T.Protocol p => p -> P.IO ChannelInfo
read_ChannelInfo iprot = to_ChannelInfo <$> T.readVal iprot (T.T_STRUCT typemap_ChannelInfo)
decode_ChannelInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelInfo
decode_ChannelInfo iprot bs = to_ChannelInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelInfo) bs
typemap_ChannelInfo :: T.TypeMap
typemap_ChannelInfo = Map.fromList [(1,("channelId",T.T_STRING)),(3,("name",T.T_STRING)),(4,("entryPageUrl",T.T_STRING)),(5,("descriptionText",T.T_STRING)),(6,("provider",(T.T_STRUCT typemap_ChannelProvider))),(7,("publicType",T.T_I32)),(8,("iconImage",T.T_STRING)),(9,("permissions",(T.T_LIST T.T_STRING))),(11,("iconThumbnailImage",T.T_STRING)),(12,("channelConfigurations",(T.T_LIST T.T_I32))),(13,("lcsAllApiUsable",T.T_BOOL)),(14,("allowedPermissions",(T.T_SET T.T_I32))),(15,("channelDomains",(T.T_LIST (T.T_STRUCT typemap_ChannelDomain)))),(16,("updatedTimestamp",T.T_I64))]
default_ChannelInfo :: ChannelInfo
default_ChannelInfo = ChannelInfo{
  channelInfo_channelId = "",
  channelInfo_name = "",
  channelInfo_entryPageUrl = "",
  channelInfo_descriptionText = "",
  channelInfo_provider = default_ChannelProvider,
  channelInfo_publicType = (P.toEnum 0),
  channelInfo_iconImage = "",
  channelInfo_permissions = Vector.empty,
  channelInfo_iconThumbnailImage = "",
  channelInfo_channelConfigurations = Vector.empty,
  channelInfo_lcsAllApiUsable = P.False,
  channelInfo_allowedPermissions = Set.empty,
  channelInfo_channelDomains = Vector.empty,
  channelInfo_updatedTimestamp = 0}
data ApprovedChannelInfo = ApprovedChannelInfo  { approvedChannelInfo_channelInfo :: ChannelInfo
  , approvedChannelInfo_approvedAt :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApprovedChannelInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` approvedChannelInfo_channelInfo record   `H.hashWithSalt` approvedChannelInfo_approvedAt record  
instance QC.Arbitrary ApprovedChannelInfo where 
  arbitrary = M.liftM ApprovedChannelInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApprovedChannelInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApprovedChannelInfo{approvedChannelInfo_channelInfo = approvedChannelInfo_channelInfo obj} then P.Nothing else P.Just $ default_ApprovedChannelInfo{approvedChannelInfo_channelInfo = approvedChannelInfo_channelInfo obj}
    , if obj == default_ApprovedChannelInfo{approvedChannelInfo_approvedAt = approvedChannelInfo_approvedAt obj} then P.Nothing else P.Just $ default_ApprovedChannelInfo{approvedChannelInfo_approvedAt = approvedChannelInfo_approvedAt obj}
    ]
from_ApprovedChannelInfo :: ApprovedChannelInfo -> T.ThriftVal
from_ApprovedChannelInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v492 -> P.Just (1, ("channelInfo",from_ChannelInfo _v492))) $ approvedChannelInfo_channelInfo record
  , (\_v492 -> P.Just (2, ("approvedAt",T.TI64 _v492))) $ approvedChannelInfo_approvedAt record
  ]
write_ApprovedChannelInfo :: T.Protocol p => p -> ApprovedChannelInfo -> P.IO ()
write_ApprovedChannelInfo oprot record = T.writeVal oprot $ from_ApprovedChannelInfo record
encode_ApprovedChannelInfo :: T.StatelessProtocol p => p -> ApprovedChannelInfo -> LBS.ByteString
encode_ApprovedChannelInfo oprot record = T.serializeVal oprot $ from_ApprovedChannelInfo record
to_ApprovedChannelInfo :: T.ThriftVal -> ApprovedChannelInfo
to_ApprovedChannelInfo (T.TStruct fields) = ApprovedChannelInfo{
  approvedChannelInfo_channelInfo = P.maybe (approvedChannelInfo_channelInfo default_ApprovedChannelInfo) (\(_,_val494) -> (case _val494 of {T.TStruct _val495 -> (to_ChannelInfo (T.TStruct _val495)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approvedChannelInfo_approvedAt = P.maybe (approvedChannelInfo_approvedAt default_ApprovedChannelInfo) (\(_,_val494) -> (case _val494 of {T.TI64 _val496 -> _val496; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApprovedChannelInfo _ = P.error "not a struct"
read_ApprovedChannelInfo :: T.Protocol p => p -> P.IO ApprovedChannelInfo
read_ApprovedChannelInfo iprot = to_ApprovedChannelInfo <$> T.readVal iprot (T.T_STRUCT typemap_ApprovedChannelInfo)
decode_ApprovedChannelInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> ApprovedChannelInfo
decode_ApprovedChannelInfo iprot bs = to_ApprovedChannelInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ApprovedChannelInfo) bs
typemap_ApprovedChannelInfo :: T.TypeMap
typemap_ApprovedChannelInfo = Map.fromList [(1,("channelInfo",(T.T_STRUCT typemap_ChannelInfo))),(2,("approvedAt",T.T_I64))]
default_ApprovedChannelInfo :: ApprovedChannelInfo
default_ApprovedChannelInfo = ApprovedChannelInfo{
  approvedChannelInfo_channelInfo = default_ChannelInfo,
  approvedChannelInfo_approvedAt = 0}
data ApprovedChannelInfos = ApprovedChannelInfos  { approvedChannelInfos_approvedChannelInfos :: (Vector.Vector ApprovedChannelInfo)
  , approvedChannelInfos_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApprovedChannelInfos where
  hashWithSalt salt record = salt   `H.hashWithSalt` approvedChannelInfos_approvedChannelInfos record   `H.hashWithSalt` approvedChannelInfos_revision record  
instance QC.Arbitrary ApprovedChannelInfos where 
  arbitrary = M.liftM ApprovedChannelInfos (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApprovedChannelInfos = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApprovedChannelInfos{approvedChannelInfos_approvedChannelInfos = approvedChannelInfos_approvedChannelInfos obj} then P.Nothing else P.Just $ default_ApprovedChannelInfos{approvedChannelInfos_approvedChannelInfos = approvedChannelInfos_approvedChannelInfos obj}
    , if obj == default_ApprovedChannelInfos{approvedChannelInfos_revision = approvedChannelInfos_revision obj} then P.Nothing else P.Just $ default_ApprovedChannelInfos{approvedChannelInfos_revision = approvedChannelInfos_revision obj}
    ]
from_ApprovedChannelInfos :: ApprovedChannelInfos -> T.ThriftVal
from_ApprovedChannelInfos record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v499 -> P.Just (1, ("approvedChannelInfos",T.TList (T.T_STRUCT typemap_ApprovedChannelInfo) $ P.map (\_v501 -> from_ApprovedChannelInfo _v501) $ Vector.toList _v499))) $ approvedChannelInfos_approvedChannelInfos record
  , (\_v499 -> P.Just (2, ("revision",T.TI64 _v499))) $ approvedChannelInfos_revision record
  ]
write_ApprovedChannelInfos :: T.Protocol p => p -> ApprovedChannelInfos -> P.IO ()
write_ApprovedChannelInfos oprot record = T.writeVal oprot $ from_ApprovedChannelInfos record
encode_ApprovedChannelInfos :: T.StatelessProtocol p => p -> ApprovedChannelInfos -> LBS.ByteString
encode_ApprovedChannelInfos oprot record = T.serializeVal oprot $ from_ApprovedChannelInfos record
to_ApprovedChannelInfos :: T.ThriftVal -> ApprovedChannelInfos
to_ApprovedChannelInfos (T.TStruct fields) = ApprovedChannelInfos{
  approvedChannelInfos_approvedChannelInfos = P.maybe (approvedChannelInfos_approvedChannelInfos default_ApprovedChannelInfos) (\(_,_val503) -> (case _val503 of {T.TList _ _val504 -> (Vector.fromList $ P.map (\_v505 -> (case _v505 of {T.TStruct _val506 -> (to_ApprovedChannelInfo (T.TStruct _val506)); _ -> P.error "wrong type"})) _val504); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approvedChannelInfos_revision = P.maybe (approvedChannelInfos_revision default_ApprovedChannelInfos) (\(_,_val503) -> (case _val503 of {T.TI64 _val507 -> _val507; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApprovedChannelInfos _ = P.error "not a struct"
read_ApprovedChannelInfos :: T.Protocol p => p -> P.IO ApprovedChannelInfos
read_ApprovedChannelInfos iprot = to_ApprovedChannelInfos <$> T.readVal iprot (T.T_STRUCT typemap_ApprovedChannelInfos)
decode_ApprovedChannelInfos :: T.StatelessProtocol p => p -> LBS.ByteString -> ApprovedChannelInfos
decode_ApprovedChannelInfos iprot bs = to_ApprovedChannelInfos $ T.deserializeVal iprot (T.T_STRUCT typemap_ApprovedChannelInfos) bs
typemap_ApprovedChannelInfos :: T.TypeMap
typemap_ApprovedChannelInfos = Map.fromList [(1,("approvedChannelInfos",(T.T_LIST (T.T_STRUCT typemap_ApprovedChannelInfo)))),(2,("revision",T.T_I64))]
default_ApprovedChannelInfos :: ApprovedChannelInfos
default_ApprovedChannelInfos = ApprovedChannelInfos{
  approvedChannelInfos_approvedChannelInfos = Vector.empty,
  approvedChannelInfos_revision = 0}
data AuthQrcode = AuthQrcode  { authQrcode_qrcode :: LT.Text
  , authQrcode_verifier :: LT.Text
  , authQrcode_callbackUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthQrcode where
  hashWithSalt salt record = salt   `H.hashWithSalt` authQrcode_qrcode record   `H.hashWithSalt` authQrcode_verifier record   `H.hashWithSalt` authQrcode_callbackUrl record  
instance QC.Arbitrary AuthQrcode where 
  arbitrary = M.liftM AuthQrcode (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AuthQrcode = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthQrcode{authQrcode_qrcode = authQrcode_qrcode obj} then P.Nothing else P.Just $ default_AuthQrcode{authQrcode_qrcode = authQrcode_qrcode obj}
    , if obj == default_AuthQrcode{authQrcode_verifier = authQrcode_verifier obj} then P.Nothing else P.Just $ default_AuthQrcode{authQrcode_verifier = authQrcode_verifier obj}
    , if obj == default_AuthQrcode{authQrcode_callbackUrl = authQrcode_callbackUrl obj} then P.Nothing else P.Just $ default_AuthQrcode{authQrcode_callbackUrl = authQrcode_callbackUrl obj}
    ]
from_AuthQrcode :: AuthQrcode -> T.ThriftVal
from_AuthQrcode record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v510 -> P.Just (1, ("qrcode",T.TString $ E.encodeUtf8 _v510))) $ authQrcode_qrcode record
  , (\_v510 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v510))) $ authQrcode_verifier record
  , (\_v510 -> P.Just (3, ("callbackUrl",T.TString $ E.encodeUtf8 _v510))) $ authQrcode_callbackUrl record
  ]
write_AuthQrcode :: T.Protocol p => p -> AuthQrcode -> P.IO ()
write_AuthQrcode oprot record = T.writeVal oprot $ from_AuthQrcode record
encode_AuthQrcode :: T.StatelessProtocol p => p -> AuthQrcode -> LBS.ByteString
encode_AuthQrcode oprot record = T.serializeVal oprot $ from_AuthQrcode record
to_AuthQrcode :: T.ThriftVal -> AuthQrcode
to_AuthQrcode (T.TStruct fields) = AuthQrcode{
  authQrcode_qrcode = P.maybe (authQrcode_qrcode default_AuthQrcode) (\(_,_val512) -> (case _val512 of {T.TString _val513 -> E.decodeUtf8 _val513; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authQrcode_verifier = P.maybe (authQrcode_verifier default_AuthQrcode) (\(_,_val512) -> (case _val512 of {T.TString _val514 -> E.decodeUtf8 _val514; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authQrcode_callbackUrl = P.maybe (authQrcode_callbackUrl default_AuthQrcode) (\(_,_val512) -> (case _val512 of {T.TString _val515 -> E.decodeUtf8 _val515; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AuthQrcode _ = P.error "not a struct"
read_AuthQrcode :: T.Protocol p => p -> P.IO AuthQrcode
read_AuthQrcode iprot = to_AuthQrcode <$> T.readVal iprot (T.T_STRUCT typemap_AuthQrcode)
decode_AuthQrcode :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthQrcode
decode_AuthQrcode iprot bs = to_AuthQrcode $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthQrcode) bs
typemap_AuthQrcode :: T.TypeMap
typemap_AuthQrcode = Map.fromList [(1,("qrcode",T.T_STRING)),(2,("verifier",T.T_STRING)),(3,("callbackUrl",T.T_STRING))]
default_AuthQrcode :: AuthQrcode
default_AuthQrcode = AuthQrcode{
  authQrcode_qrcode = "",
  authQrcode_verifier = "",
  authQrcode_callbackUrl = ""}
data AnalyticsInfo = AnalyticsInfo  { analyticsInfo_gaSamplingRate :: P.Double
  , analyticsInfo_tmid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AnalyticsInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` analyticsInfo_gaSamplingRate record   `H.hashWithSalt` analyticsInfo_tmid record  
instance QC.Arbitrary AnalyticsInfo where 
  arbitrary = M.liftM AnalyticsInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AnalyticsInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AnalyticsInfo{analyticsInfo_gaSamplingRate = analyticsInfo_gaSamplingRate obj} then P.Nothing else P.Just $ default_AnalyticsInfo{analyticsInfo_gaSamplingRate = analyticsInfo_gaSamplingRate obj}
    , if obj == default_AnalyticsInfo{analyticsInfo_tmid = analyticsInfo_tmid obj} then P.Nothing else P.Just $ default_AnalyticsInfo{analyticsInfo_tmid = analyticsInfo_tmid obj}
    ]
from_AnalyticsInfo :: AnalyticsInfo -> T.ThriftVal
from_AnalyticsInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v518 -> P.Just (1, ("gaSamplingRate",T.TDouble _v518))) $ analyticsInfo_gaSamplingRate record
  , (\_v518 -> P.Just (2, ("tmid",T.TString $ E.encodeUtf8 _v518))) $ analyticsInfo_tmid record
  ]
write_AnalyticsInfo :: T.Protocol p => p -> AnalyticsInfo -> P.IO ()
write_AnalyticsInfo oprot record = T.writeVal oprot $ from_AnalyticsInfo record
encode_AnalyticsInfo :: T.StatelessProtocol p => p -> AnalyticsInfo -> LBS.ByteString
encode_AnalyticsInfo oprot record = T.serializeVal oprot $ from_AnalyticsInfo record
to_AnalyticsInfo :: T.ThriftVal -> AnalyticsInfo
to_AnalyticsInfo (T.TStruct fields) = AnalyticsInfo{
  analyticsInfo_gaSamplingRate = P.maybe (analyticsInfo_gaSamplingRate default_AnalyticsInfo) (\(_,_val520) -> (case _val520 of {T.TDouble _val521 -> _val521; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  analyticsInfo_tmid = P.maybe (analyticsInfo_tmid default_AnalyticsInfo) (\(_,_val520) -> (case _val520 of {T.TString _val522 -> E.decodeUtf8 _val522; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AnalyticsInfo _ = P.error "not a struct"
read_AnalyticsInfo :: T.Protocol p => p -> P.IO AnalyticsInfo
read_AnalyticsInfo iprot = to_AnalyticsInfo <$> T.readVal iprot (T.T_STRUCT typemap_AnalyticsInfo)
decode_AnalyticsInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> AnalyticsInfo
decode_AnalyticsInfo iprot bs = to_AnalyticsInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_AnalyticsInfo) bs
typemap_AnalyticsInfo :: T.TypeMap
typemap_AnalyticsInfo = Map.fromList [(1,("gaSamplingRate",T.T_DOUBLE)),(2,("tmid",T.T_STRING))]
default_AnalyticsInfo :: AnalyticsInfo
default_AnalyticsInfo = AnalyticsInfo{
  analyticsInfo_gaSamplingRate = 0,
  analyticsInfo_tmid = ""}
data ContactTransition = ContactTransition  { contactTransition_ownerMid :: LT.Text
  , contactTransition_targetMid :: LT.Text
  , contactTransition_previousStatus :: ContactStatus
  , contactTransition_resultStatus :: ContactStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactTransition where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactTransition_ownerMid record   `H.hashWithSalt` contactTransition_targetMid record   `H.hashWithSalt` contactTransition_previousStatus record   `H.hashWithSalt` contactTransition_resultStatus record  
instance QC.Arbitrary ContactTransition where 
  arbitrary = M.liftM ContactTransition (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactTransition = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactTransition{contactTransition_ownerMid = contactTransition_ownerMid obj} then P.Nothing else P.Just $ default_ContactTransition{contactTransition_ownerMid = contactTransition_ownerMid obj}
    , if obj == default_ContactTransition{contactTransition_targetMid = contactTransition_targetMid obj} then P.Nothing else P.Just $ default_ContactTransition{contactTransition_targetMid = contactTransition_targetMid obj}
    , if obj == default_ContactTransition{contactTransition_previousStatus = contactTransition_previousStatus obj} then P.Nothing else P.Just $ default_ContactTransition{contactTransition_previousStatus = contactTransition_previousStatus obj}
    , if obj == default_ContactTransition{contactTransition_resultStatus = contactTransition_resultStatus obj} then P.Nothing else P.Just $ default_ContactTransition{contactTransition_resultStatus = contactTransition_resultStatus obj}
    ]
from_ContactTransition :: ContactTransition -> T.ThriftVal
from_ContactTransition record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v525 -> P.Just (1, ("ownerMid",T.TString $ E.encodeUtf8 _v525))) $ contactTransition_ownerMid record
  , (\_v525 -> P.Just (2, ("targetMid",T.TString $ E.encodeUtf8 _v525))) $ contactTransition_targetMid record
  , (\_v525 -> P.Just (3, ("previousStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v525))) $ contactTransition_previousStatus record
  , (\_v525 -> P.Just (4, ("resultStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v525))) $ contactTransition_resultStatus record
  ]
write_ContactTransition :: T.Protocol p => p -> ContactTransition -> P.IO ()
write_ContactTransition oprot record = T.writeVal oprot $ from_ContactTransition record
encode_ContactTransition :: T.StatelessProtocol p => p -> ContactTransition -> LBS.ByteString
encode_ContactTransition oprot record = T.serializeVal oprot $ from_ContactTransition record
to_ContactTransition :: T.ThriftVal -> ContactTransition
to_ContactTransition (T.TStruct fields) = ContactTransition{
  contactTransition_ownerMid = P.maybe (contactTransition_ownerMid default_ContactTransition) (\(_,_val527) -> (case _val527 of {T.TString _val528 -> E.decodeUtf8 _val528; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactTransition_targetMid = P.maybe (contactTransition_targetMid default_ContactTransition) (\(_,_val527) -> (case _val527 of {T.TString _val529 -> E.decodeUtf8 _val529; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contactTransition_previousStatus = P.maybe (contactTransition_previousStatus default_ContactTransition) (\(_,_val527) -> (case _val527 of {T.TI32 _val530 -> P.toEnum $ P.fromIntegral _val530; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  contactTransition_resultStatus = P.maybe (contactTransition_resultStatus default_ContactTransition) (\(_,_val527) -> (case _val527 of {T.TI32 _val531 -> P.toEnum $ P.fromIntegral _val531; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ContactTransition _ = P.error "not a struct"
read_ContactTransition :: T.Protocol p => p -> P.IO ContactTransition
read_ContactTransition iprot = to_ContactTransition <$> T.readVal iprot (T.T_STRUCT typemap_ContactTransition)
decode_ContactTransition :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactTransition
decode_ContactTransition iprot bs = to_ContactTransition $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactTransition) bs
typemap_ContactTransition :: T.TypeMap
typemap_ContactTransition = Map.fromList [(1,("ownerMid",T.T_STRING)),(2,("targetMid",T.T_STRING)),(3,("previousStatus",T.T_I32)),(4,("resultStatus",T.T_I32))]
default_ContactTransition :: ContactTransition
default_ContactTransition = ContactTransition{
  contactTransition_ownerMid = "",
  contactTransition_targetMid = "",
  contactTransition_previousStatus = (P.toEnum 0),
  contactTransition_resultStatus = (P.toEnum 0)}
data UserTicketResponse = UserTicketResponse  { userTicketResponse_mid :: LT.Text
  , userTicketResponse_userTicket :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserTicketResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` userTicketResponse_mid record   `H.hashWithSalt` userTicketResponse_userTicket record  
instance QC.Arbitrary UserTicketResponse where 
  arbitrary = M.liftM UserTicketResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UserTicketResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserTicketResponse{userTicketResponse_mid = userTicketResponse_mid obj} then P.Nothing else P.Just $ default_UserTicketResponse{userTicketResponse_mid = userTicketResponse_mid obj}
    , if obj == default_UserTicketResponse{userTicketResponse_userTicket = userTicketResponse_userTicket obj} then P.Nothing else P.Just $ default_UserTicketResponse{userTicketResponse_userTicket = userTicketResponse_userTicket obj}
    ]
from_UserTicketResponse :: UserTicketResponse -> T.ThriftVal
from_UserTicketResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v534 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v534))) $ userTicketResponse_mid record
  , (\_v534 -> P.Just (2, ("userTicket",T.TString $ E.encodeUtf8 _v534))) $ userTicketResponse_userTicket record
  ]
write_UserTicketResponse :: T.Protocol p => p -> UserTicketResponse -> P.IO ()
write_UserTicketResponse oprot record = T.writeVal oprot $ from_UserTicketResponse record
encode_UserTicketResponse :: T.StatelessProtocol p => p -> UserTicketResponse -> LBS.ByteString
encode_UserTicketResponse oprot record = T.serializeVal oprot $ from_UserTicketResponse record
to_UserTicketResponse :: T.ThriftVal -> UserTicketResponse
to_UserTicketResponse (T.TStruct fields) = UserTicketResponse{
  userTicketResponse_mid = P.maybe (userTicketResponse_mid default_UserTicketResponse) (\(_,_val536) -> (case _val536 of {T.TString _val537 -> E.decodeUtf8 _val537; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userTicketResponse_userTicket = P.maybe (userTicketResponse_userTicket default_UserTicketResponse) (\(_,_val536) -> (case _val536 of {T.TString _val538 -> E.decodeUtf8 _val538; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UserTicketResponse _ = P.error "not a struct"
read_UserTicketResponse :: T.Protocol p => p -> P.IO UserTicketResponse
read_UserTicketResponse iprot = to_UserTicketResponse <$> T.readVal iprot (T.T_STRUCT typemap_UserTicketResponse)
decode_UserTicketResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UserTicketResponse
decode_UserTicketResponse iprot bs = to_UserTicketResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UserTicketResponse) bs
typemap_UserTicketResponse :: T.TypeMap
typemap_UserTicketResponse = Map.fromList [(1,("mid",T.T_STRING)),(2,("userTicket",T.T_STRING))]
default_UserTicketResponse :: UserTicketResponse
default_UserTicketResponse = UserTicketResponse{
  userTicketResponse_mid = "",
  userTicketResponse_userTicket = ""}
data BuddyBanner = BuddyBanner  { buddyBanner_buddyBannerLinkType :: BuddyBannerLinkType
  , buddyBanner_buddyBannerLink :: LT.Text
  , buddyBanner_buddyBannerImageUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyBanner where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyBanner_buddyBannerLinkType record   `H.hashWithSalt` buddyBanner_buddyBannerLink record   `H.hashWithSalt` buddyBanner_buddyBannerImageUrl record  
instance QC.Arbitrary BuddyBanner where 
  arbitrary = M.liftM BuddyBanner (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyBanner = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyBanner{buddyBanner_buddyBannerLinkType = buddyBanner_buddyBannerLinkType obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerLinkType = buddyBanner_buddyBannerLinkType obj}
    , if obj == default_BuddyBanner{buddyBanner_buddyBannerLink = buddyBanner_buddyBannerLink obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerLink = buddyBanner_buddyBannerLink obj}
    , if obj == default_BuddyBanner{buddyBanner_buddyBannerImageUrl = buddyBanner_buddyBannerImageUrl obj} then P.Nothing else P.Just $ default_BuddyBanner{buddyBanner_buddyBannerImageUrl = buddyBanner_buddyBannerImageUrl obj}
    ]
from_BuddyBanner :: BuddyBanner -> T.ThriftVal
from_BuddyBanner record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v541 -> P.Just (1, ("buddyBannerLinkType",T.TI32 $ P.fromIntegral $ P.fromEnum _v541))) $ buddyBanner_buddyBannerLinkType record
  , (\_v541 -> P.Just (2, ("buddyBannerLink",T.TString $ E.encodeUtf8 _v541))) $ buddyBanner_buddyBannerLink record
  , (\_v541 -> P.Just (3, ("buddyBannerImageUrl",T.TString $ E.encodeUtf8 _v541))) $ buddyBanner_buddyBannerImageUrl record
  ]
write_BuddyBanner :: T.Protocol p => p -> BuddyBanner -> P.IO ()
write_BuddyBanner oprot record = T.writeVal oprot $ from_BuddyBanner record
encode_BuddyBanner :: T.StatelessProtocol p => p -> BuddyBanner -> LBS.ByteString
encode_BuddyBanner oprot record = T.serializeVal oprot $ from_BuddyBanner record
to_BuddyBanner :: T.ThriftVal -> BuddyBanner
to_BuddyBanner (T.TStruct fields) = BuddyBanner{
  buddyBanner_buddyBannerLinkType = P.maybe (buddyBanner_buddyBannerLinkType default_BuddyBanner) (\(_,_val543) -> (case _val543 of {T.TI32 _val544 -> P.toEnum $ P.fromIntegral _val544; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyBanner_buddyBannerLink = P.maybe (buddyBanner_buddyBannerLink default_BuddyBanner) (\(_,_val543) -> (case _val543 of {T.TString _val545 -> E.decodeUtf8 _val545; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyBanner_buddyBannerImageUrl = P.maybe (buddyBanner_buddyBannerImageUrl default_BuddyBanner) (\(_,_val543) -> (case _val543 of {T.TString _val546 -> E.decodeUtf8 _val546; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_BuddyBanner _ = P.error "not a struct"
read_BuddyBanner :: T.Protocol p => p -> P.IO BuddyBanner
read_BuddyBanner iprot = to_BuddyBanner <$> T.readVal iprot (T.T_STRUCT typemap_BuddyBanner)
decode_BuddyBanner :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyBanner
decode_BuddyBanner iprot bs = to_BuddyBanner $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyBanner) bs
typemap_BuddyBanner :: T.TypeMap
typemap_BuddyBanner = Map.fromList [(1,("buddyBannerLinkType",T.T_I32)),(2,("buddyBannerLink",T.T_STRING)),(3,("buddyBannerImageUrl",T.T_STRING))]
default_BuddyBanner :: BuddyBanner
default_BuddyBanner = BuddyBanner{
  buddyBanner_buddyBannerLinkType = (P.toEnum 0),
  buddyBanner_buddyBannerLink = "",
  buddyBanner_buddyBannerImageUrl = ""}
data BuddyDetail = BuddyDetail  { buddyDetail_mid :: LT.Text
  , buddyDetail_memberCount :: I.Int64
  , buddyDetail_onAir :: P.Bool
  , buddyDetail_businessAccount :: P.Bool
  , buddyDetail_addable :: P.Bool
  , buddyDetail_acceptableContentTypes :: (Set.HashSet ContentType)
  , buddyDetail_capableMyhome :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyDetail where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyDetail_mid record   `H.hashWithSalt` buddyDetail_memberCount record   `H.hashWithSalt` buddyDetail_onAir record   `H.hashWithSalt` buddyDetail_businessAccount record   `H.hashWithSalt` buddyDetail_addable record   `H.hashWithSalt` buddyDetail_acceptableContentTypes record   `H.hashWithSalt` buddyDetail_capableMyhome record  
instance QC.Arbitrary BuddyDetail where 
  arbitrary = M.liftM BuddyDetail (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyDetail = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyDetail{buddyDetail_mid = buddyDetail_mid obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_mid = buddyDetail_mid obj}
    , if obj == default_BuddyDetail{buddyDetail_memberCount = buddyDetail_memberCount obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_memberCount = buddyDetail_memberCount obj}
    , if obj == default_BuddyDetail{buddyDetail_onAir = buddyDetail_onAir obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_onAir = buddyDetail_onAir obj}
    , if obj == default_BuddyDetail{buddyDetail_businessAccount = buddyDetail_businessAccount obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_businessAccount = buddyDetail_businessAccount obj}
    , if obj == default_BuddyDetail{buddyDetail_addable = buddyDetail_addable obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_addable = buddyDetail_addable obj}
    , if obj == default_BuddyDetail{buddyDetail_acceptableContentTypes = buddyDetail_acceptableContentTypes obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_acceptableContentTypes = buddyDetail_acceptableContentTypes obj}
    , if obj == default_BuddyDetail{buddyDetail_capableMyhome = buddyDetail_capableMyhome obj} then P.Nothing else P.Just $ default_BuddyDetail{buddyDetail_capableMyhome = buddyDetail_capableMyhome obj}
    ]
from_BuddyDetail :: BuddyDetail -> T.ThriftVal
from_BuddyDetail record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v549 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v549))) $ buddyDetail_mid record
  , (\_v549 -> P.Just (2, ("memberCount",T.TI64 _v549))) $ buddyDetail_memberCount record
  , (\_v549 -> P.Just (3, ("onAir",T.TBool _v549))) $ buddyDetail_onAir record
  , (\_v549 -> P.Just (4, ("businessAccount",T.TBool _v549))) $ buddyDetail_businessAccount record
  , (\_v549 -> P.Just (5, ("addable",T.TBool _v549))) $ buddyDetail_addable record
  , (\_v549 -> P.Just (6, ("acceptableContentTypes",T.TSet T.T_I32 $ P.map (\_v551 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v551) $ Set.toList _v549))) $ buddyDetail_acceptableContentTypes record
  , (\_v549 -> P.Just (7, ("capableMyhome",T.TBool _v549))) $ buddyDetail_capableMyhome record
  ]
write_BuddyDetail :: T.Protocol p => p -> BuddyDetail -> P.IO ()
write_BuddyDetail oprot record = T.writeVal oprot $ from_BuddyDetail record
encode_BuddyDetail :: T.StatelessProtocol p => p -> BuddyDetail -> LBS.ByteString
encode_BuddyDetail oprot record = T.serializeVal oprot $ from_BuddyDetail record
to_BuddyDetail :: T.ThriftVal -> BuddyDetail
to_BuddyDetail (T.TStruct fields) = BuddyDetail{
  buddyDetail_mid = P.maybe (buddyDetail_mid default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TString _val554 -> E.decodeUtf8 _val554; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyDetail_memberCount = P.maybe (buddyDetail_memberCount default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TI64 _val555 -> _val555; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyDetail_onAir = P.maybe (buddyDetail_onAir default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TBool _val556 -> _val556; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyDetail_businessAccount = P.maybe (buddyDetail_businessAccount default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TBool _val557 -> _val557; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyDetail_addable = P.maybe (buddyDetail_addable default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TBool _val558 -> _val558; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyDetail_acceptableContentTypes = P.maybe (buddyDetail_acceptableContentTypes default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TSet _ _val559 -> (Set.fromList $ P.map (\_v560 -> (case _v560 of {T.TI32 _val561 -> P.toEnum $ P.fromIntegral _val561; _ -> P.error "wrong type"})) _val559); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  buddyDetail_capableMyhome = P.maybe (buddyDetail_capableMyhome default_BuddyDetail) (\(_,_val553) -> (case _val553 of {T.TBool _val562 -> _val562; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_BuddyDetail _ = P.error "not a struct"
read_BuddyDetail :: T.Protocol p => p -> P.IO BuddyDetail
read_BuddyDetail iprot = to_BuddyDetail <$> T.readVal iprot (T.T_STRUCT typemap_BuddyDetail)
decode_BuddyDetail :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyDetail
decode_BuddyDetail iprot bs = to_BuddyDetail $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyDetail) bs
typemap_BuddyDetail :: T.TypeMap
typemap_BuddyDetail = Map.fromList [(1,("mid",T.T_STRING)),(2,("memberCount",T.T_I64)),(3,("onAir",T.T_BOOL)),(4,("businessAccount",T.T_BOOL)),(5,("addable",T.T_BOOL)),(6,("acceptableContentTypes",(T.T_SET T.T_I32))),(7,("capableMyhome",T.T_BOOL))]
default_BuddyDetail :: BuddyDetail
default_BuddyDetail = BuddyDetail{
  buddyDetail_mid = "",
  buddyDetail_memberCount = 0,
  buddyDetail_onAir = P.False,
  buddyDetail_businessAccount = P.False,
  buddyDetail_addable = P.False,
  buddyDetail_acceptableContentTypes = Set.empty,
  buddyDetail_capableMyhome = P.False}
data Contact = Contact  { contact_mid :: LT.Text
  , contact_createdTime :: I.Int64
  , contact_type :: ContactType
  , contact_status :: ContactStatus
  , contact_relation :: ContactRelation
  , contact_displayName :: LT.Text
  , contact_phoneticName :: LT.Text
  , contact_pictureStatus :: LT.Text
  , contact_thumbnailUrl :: LT.Text
  , contact_statusMessage :: LT.Text
  , contact_displayNameOverridden :: LT.Text
  , contact_favoriteTime :: I.Int64
  , contact_capableVoiceCall :: P.Bool
  , contact_capableVideoCall :: P.Bool
  , contact_capableMyhome :: P.Bool
  , contact_capableBuddy :: P.Bool
  , contact_attributes :: I.Int32
  , contact_settings :: I.Int64
  , contact_picturePath :: LT.Text
  , contact_recommendParams :: LT.Text
  , contact_friendRequestStatus :: FriendRequestStatus
  , contact_musicProfile :: LT.Text
  , contact_videoProfile :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Contact where
  hashWithSalt salt record = salt   `H.hashWithSalt` contact_mid record   `H.hashWithSalt` contact_createdTime record   `H.hashWithSalt` contact_type record   `H.hashWithSalt` contact_status record   `H.hashWithSalt` contact_relation record   `H.hashWithSalt` contact_displayName record   `H.hashWithSalt` contact_phoneticName record   `H.hashWithSalt` contact_pictureStatus record   `H.hashWithSalt` contact_thumbnailUrl record   `H.hashWithSalt` contact_statusMessage record   `H.hashWithSalt` contact_displayNameOverridden record   `H.hashWithSalt` contact_favoriteTime record   `H.hashWithSalt` contact_capableVoiceCall record   `H.hashWithSalt` contact_capableVideoCall record   `H.hashWithSalt` contact_capableMyhome record   `H.hashWithSalt` contact_capableBuddy record   `H.hashWithSalt` contact_attributes record   `H.hashWithSalt` contact_settings record   `H.hashWithSalt` contact_picturePath record   `H.hashWithSalt` contact_recommendParams record   `H.hashWithSalt` contact_friendRequestStatus record   `H.hashWithSalt` contact_musicProfile record   `H.hashWithSalt` contact_videoProfile record  
instance QC.Arbitrary Contact where 
  arbitrary = M.liftM Contact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Contact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Contact{contact_mid = contact_mid obj} then P.Nothing else P.Just $ default_Contact{contact_mid = contact_mid obj}
    , if obj == default_Contact{contact_createdTime = contact_createdTime obj} then P.Nothing else P.Just $ default_Contact{contact_createdTime = contact_createdTime obj}
    , if obj == default_Contact{contact_type = contact_type obj} then P.Nothing else P.Just $ default_Contact{contact_type = contact_type obj}
    , if obj == default_Contact{contact_status = contact_status obj} then P.Nothing else P.Just $ default_Contact{contact_status = contact_status obj}
    , if obj == default_Contact{contact_relation = contact_relation obj} then P.Nothing else P.Just $ default_Contact{contact_relation = contact_relation obj}
    , if obj == default_Contact{contact_displayName = contact_displayName obj} then P.Nothing else P.Just $ default_Contact{contact_displayName = contact_displayName obj}
    , if obj == default_Contact{contact_phoneticName = contact_phoneticName obj} then P.Nothing else P.Just $ default_Contact{contact_phoneticName = contact_phoneticName obj}
    , if obj == default_Contact{contact_pictureStatus = contact_pictureStatus obj} then P.Nothing else P.Just $ default_Contact{contact_pictureStatus = contact_pictureStatus obj}
    , if obj == default_Contact{contact_thumbnailUrl = contact_thumbnailUrl obj} then P.Nothing else P.Just $ default_Contact{contact_thumbnailUrl = contact_thumbnailUrl obj}
    , if obj == default_Contact{contact_statusMessage = contact_statusMessage obj} then P.Nothing else P.Just $ default_Contact{contact_statusMessage = contact_statusMessage obj}
    , if obj == default_Contact{contact_displayNameOverridden = contact_displayNameOverridden obj} then P.Nothing else P.Just $ default_Contact{contact_displayNameOverridden = contact_displayNameOverridden obj}
    , if obj == default_Contact{contact_favoriteTime = contact_favoriteTime obj} then P.Nothing else P.Just $ default_Contact{contact_favoriteTime = contact_favoriteTime obj}
    , if obj == default_Contact{contact_capableVoiceCall = contact_capableVoiceCall obj} then P.Nothing else P.Just $ default_Contact{contact_capableVoiceCall = contact_capableVoiceCall obj}
    , if obj == default_Contact{contact_capableVideoCall = contact_capableVideoCall obj} then P.Nothing else P.Just $ default_Contact{contact_capableVideoCall = contact_capableVideoCall obj}
    , if obj == default_Contact{contact_capableMyhome = contact_capableMyhome obj} then P.Nothing else P.Just $ default_Contact{contact_capableMyhome = contact_capableMyhome obj}
    , if obj == default_Contact{contact_capableBuddy = contact_capableBuddy obj} then P.Nothing else P.Just $ default_Contact{contact_capableBuddy = contact_capableBuddy obj}
    , if obj == default_Contact{contact_attributes = contact_attributes obj} then P.Nothing else P.Just $ default_Contact{contact_attributes = contact_attributes obj}
    , if obj == default_Contact{contact_settings = contact_settings obj} then P.Nothing else P.Just $ default_Contact{contact_settings = contact_settings obj}
    , if obj == default_Contact{contact_picturePath = contact_picturePath obj} then P.Nothing else P.Just $ default_Contact{contact_picturePath = contact_picturePath obj}
    , if obj == default_Contact{contact_recommendParams = contact_recommendParams obj} then P.Nothing else P.Just $ default_Contact{contact_recommendParams = contact_recommendParams obj}
    , if obj == default_Contact{contact_friendRequestStatus = contact_friendRequestStatus obj} then P.Nothing else P.Just $ default_Contact{contact_friendRequestStatus = contact_friendRequestStatus obj}
    , if obj == default_Contact{contact_musicProfile = contact_musicProfile obj} then P.Nothing else P.Just $ default_Contact{contact_musicProfile = contact_musicProfile obj}
    , if obj == default_Contact{contact_videoProfile = contact_videoProfile obj} then P.Nothing else P.Just $ default_Contact{contact_videoProfile = contact_videoProfile obj}
    ]
from_Contact :: Contact -> T.ThriftVal
from_Contact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v565 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v565))) $ contact_mid record
  , (\_v565 -> P.Just (2, ("createdTime",T.TI64 _v565))) $ contact_createdTime record
  , (\_v565 -> P.Just (10, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v565))) $ contact_type record
  , (\_v565 -> P.Just (11, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v565))) $ contact_status record
  , (\_v565 -> P.Just (21, ("relation",T.TI32 $ P.fromIntegral $ P.fromEnum _v565))) $ contact_relation record
  , (\_v565 -> P.Just (22, ("displayName",T.TString $ E.encodeUtf8 _v565))) $ contact_displayName record
  , (\_v565 -> P.Just (23, ("phoneticName",T.TString $ E.encodeUtf8 _v565))) $ contact_phoneticName record
  , (\_v565 -> P.Just (24, ("pictureStatus",T.TString $ E.encodeUtf8 _v565))) $ contact_pictureStatus record
  , (\_v565 -> P.Just (25, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v565))) $ contact_thumbnailUrl record
  , (\_v565 -> P.Just (26, ("statusMessage",T.TString $ E.encodeUtf8 _v565))) $ contact_statusMessage record
  , (\_v565 -> P.Just (27, ("displayNameOverridden",T.TString $ E.encodeUtf8 _v565))) $ contact_displayNameOverridden record
  , (\_v565 -> P.Just (28, ("favoriteTime",T.TI64 _v565))) $ contact_favoriteTime record
  , (\_v565 -> P.Just (31, ("capableVoiceCall",T.TBool _v565))) $ contact_capableVoiceCall record
  , (\_v565 -> P.Just (32, ("capableVideoCall",T.TBool _v565))) $ contact_capableVideoCall record
  , (\_v565 -> P.Just (33, ("capableMyhome",T.TBool _v565))) $ contact_capableMyhome record
  , (\_v565 -> P.Just (34, ("capableBuddy",T.TBool _v565))) $ contact_capableBuddy record
  , (\_v565 -> P.Just (35, ("attributes",T.TI32 _v565))) $ contact_attributes record
  , (\_v565 -> P.Just (36, ("settings",T.TI64 _v565))) $ contact_settings record
  , (\_v565 -> P.Just (37, ("picturePath",T.TString $ E.encodeUtf8 _v565))) $ contact_picturePath record
  , (\_v565 -> P.Just (38, ("recommendParams",T.TString $ E.encodeUtf8 _v565))) $ contact_recommendParams record
  , (\_v565 -> P.Just (39, ("friendRequestStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v565))) $ contact_friendRequestStatus record
  , (\_v565 -> P.Just (40, ("musicProfile",T.TString $ E.encodeUtf8 _v565))) $ contact_musicProfile record
  , (\_v565 -> P.Just (42, ("videoProfile",T.TString $ E.encodeUtf8 _v565))) $ contact_videoProfile record
  ]
write_Contact :: T.Protocol p => p -> Contact -> P.IO ()
write_Contact oprot record = T.writeVal oprot $ from_Contact record
encode_Contact :: T.StatelessProtocol p => p -> Contact -> LBS.ByteString
encode_Contact oprot record = T.serializeVal oprot $ from_Contact record
to_Contact :: T.ThriftVal -> Contact
to_Contact (T.TStruct fields) = Contact{
  contact_mid = P.maybe (contact_mid default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val568 -> E.decodeUtf8 _val568; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contact_createdTime = P.maybe (contact_createdTime default_Contact) (\(_,_val567) -> (case _val567 of {T.TI64 _val569 -> _val569; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contact_type = P.maybe (contact_type default_Contact) (\(_,_val567) -> (case _val567 of {T.TI32 _val570 -> P.toEnum $ P.fromIntegral _val570; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  contact_status = P.maybe (contact_status default_Contact) (\(_,_val567) -> (case _val567 of {T.TI32 _val571 -> P.toEnum $ P.fromIntegral _val571; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contact_relation = P.maybe (contact_relation default_Contact) (\(_,_val567) -> (case _val567 of {T.TI32 _val572 -> P.toEnum $ P.fromIntegral _val572; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  contact_displayName = P.maybe (contact_displayName default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val573 -> E.decodeUtf8 _val573; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  contact_phoneticName = P.maybe (contact_phoneticName default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val574 -> E.decodeUtf8 _val574; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  contact_pictureStatus = P.maybe (contact_pictureStatus default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val575 -> E.decodeUtf8 _val575; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  contact_thumbnailUrl = P.maybe (contact_thumbnailUrl default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val576 -> E.decodeUtf8 _val576; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  contact_statusMessage = P.maybe (contact_statusMessage default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val577 -> E.decodeUtf8 _val577; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  contact_displayNameOverridden = P.maybe (contact_displayNameOverridden default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val578 -> E.decodeUtf8 _val578; _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  contact_favoriteTime = P.maybe (contact_favoriteTime default_Contact) (\(_,_val567) -> (case _val567 of {T.TI64 _val579 -> _val579; _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  contact_capableVoiceCall = P.maybe (contact_capableVoiceCall default_Contact) (\(_,_val567) -> (case _val567 of {T.TBool _val580 -> _val580; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  contact_capableVideoCall = P.maybe (contact_capableVideoCall default_Contact) (\(_,_val567) -> (case _val567 of {T.TBool _val581 -> _val581; _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  contact_capableMyhome = P.maybe (contact_capableMyhome default_Contact) (\(_,_val567) -> (case _val567 of {T.TBool _val582 -> _val582; _ -> P.error "wrong type"})) (Map.lookup (33) fields),
  contact_capableBuddy = P.maybe (contact_capableBuddy default_Contact) (\(_,_val567) -> (case _val567 of {T.TBool _val583 -> _val583; _ -> P.error "wrong type"})) (Map.lookup (34) fields),
  contact_attributes = P.maybe (contact_attributes default_Contact) (\(_,_val567) -> (case _val567 of {T.TI32 _val584 -> _val584; _ -> P.error "wrong type"})) (Map.lookup (35) fields),
  contact_settings = P.maybe (contact_settings default_Contact) (\(_,_val567) -> (case _val567 of {T.TI64 _val585 -> _val585; _ -> P.error "wrong type"})) (Map.lookup (36) fields),
  contact_picturePath = P.maybe (contact_picturePath default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val586 -> E.decodeUtf8 _val586; _ -> P.error "wrong type"})) (Map.lookup (37) fields),
  contact_recommendParams = P.maybe (contact_recommendParams default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val587 -> E.decodeUtf8 _val587; _ -> P.error "wrong type"})) (Map.lookup (38) fields),
  contact_friendRequestStatus = P.maybe (contact_friendRequestStatus default_Contact) (\(_,_val567) -> (case _val567 of {T.TI32 _val588 -> P.toEnum $ P.fromIntegral _val588; _ -> P.error "wrong type"})) (Map.lookup (39) fields),
  contact_musicProfile = P.maybe (contact_musicProfile default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val589 -> E.decodeUtf8 _val589; _ -> P.error "wrong type"})) (Map.lookup (40) fields),
  contact_videoProfile = P.maybe (contact_videoProfile default_Contact) (\(_,_val567) -> (case _val567 of {T.TString _val590 -> E.decodeUtf8 _val590; _ -> P.error "wrong type"})) (Map.lookup (42) fields)
  }
to_Contact _ = P.error "not a struct"
read_Contact :: T.Protocol p => p -> P.IO Contact
read_Contact iprot = to_Contact <$> T.readVal iprot (T.T_STRUCT typemap_Contact)
decode_Contact :: T.StatelessProtocol p => p -> LBS.ByteString -> Contact
decode_Contact iprot bs = to_Contact $ T.deserializeVal iprot (T.T_STRUCT typemap_Contact) bs
typemap_Contact :: T.TypeMap
typemap_Contact = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("type",T.T_I32)),(11,("status",T.T_I32)),(21,("relation",T.T_I32)),(22,("displayName",T.T_STRING)),(23,("phoneticName",T.T_STRING)),(24,("pictureStatus",T.T_STRING)),(25,("thumbnailUrl",T.T_STRING)),(26,("statusMessage",T.T_STRING)),(27,("displayNameOverridden",T.T_STRING)),(28,("favoriteTime",T.T_I64)),(31,("capableVoiceCall",T.T_BOOL)),(32,("capableVideoCall",T.T_BOOL)),(33,("capableMyhome",T.T_BOOL)),(34,("capableBuddy",T.T_BOOL)),(35,("attributes",T.T_I32)),(36,("settings",T.T_I64)),(37,("picturePath",T.T_STRING)),(38,("recommendParams",T.T_STRING)),(39,("friendRequestStatus",T.T_I32)),(40,("musicProfile",T.T_STRING)),(42,("videoProfile",T.T_STRING))]
default_Contact :: Contact
default_Contact = Contact{
  contact_mid = "",
  contact_createdTime = 0,
  contact_type = (P.toEnum 0),
  contact_status = (P.toEnum 0),
  contact_relation = (P.toEnum 0),
  contact_displayName = "",
  contact_phoneticName = "",
  contact_pictureStatus = "",
  contact_thumbnailUrl = "",
  contact_statusMessage = "",
  contact_displayNameOverridden = "",
  contact_favoriteTime = 0,
  contact_capableVoiceCall = P.False,
  contact_capableVideoCall = P.False,
  contact_capableMyhome = P.False,
  contact_capableBuddy = P.False,
  contact_attributes = 0,
  contact_settings = 0,
  contact_picturePath = "",
  contact_recommendParams = "",
  contact_friendRequestStatus = (P.toEnum 0),
  contact_musicProfile = "",
  contact_videoProfile = ""}
data BuddyList = BuddyList  { buddyList_classification :: LT.Text
  , buddyList_displayName :: LT.Text
  , buddyList_totalBuddyCount :: I.Int32
  , buddyList_popularContacts :: (Vector.Vector Contact)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyList where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyList_classification record   `H.hashWithSalt` buddyList_displayName record   `H.hashWithSalt` buddyList_totalBuddyCount record   `H.hashWithSalt` buddyList_popularContacts record  
instance QC.Arbitrary BuddyList where 
  arbitrary = M.liftM BuddyList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyList{buddyList_classification = buddyList_classification obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_classification = buddyList_classification obj}
    , if obj == default_BuddyList{buddyList_displayName = buddyList_displayName obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_displayName = buddyList_displayName obj}
    , if obj == default_BuddyList{buddyList_totalBuddyCount = buddyList_totalBuddyCount obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_totalBuddyCount = buddyList_totalBuddyCount obj}
    , if obj == default_BuddyList{buddyList_popularContacts = buddyList_popularContacts obj} then P.Nothing else P.Just $ default_BuddyList{buddyList_popularContacts = buddyList_popularContacts obj}
    ]
from_BuddyList :: BuddyList -> T.ThriftVal
from_BuddyList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v593 -> P.Just (1, ("classification",T.TString $ E.encodeUtf8 _v593))) $ buddyList_classification record
  , (\_v593 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v593))) $ buddyList_displayName record
  , (\_v593 -> P.Just (3, ("totalBuddyCount",T.TI32 _v593))) $ buddyList_totalBuddyCount record
  , (\_v593 -> P.Just (4, ("popularContacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v595 -> from_Contact _v595) $ Vector.toList _v593))) $ buddyList_popularContacts record
  ]
write_BuddyList :: T.Protocol p => p -> BuddyList -> P.IO ()
write_BuddyList oprot record = T.writeVal oprot $ from_BuddyList record
encode_BuddyList :: T.StatelessProtocol p => p -> BuddyList -> LBS.ByteString
encode_BuddyList oprot record = T.serializeVal oprot $ from_BuddyList record
to_BuddyList :: T.ThriftVal -> BuddyList
to_BuddyList (T.TStruct fields) = BuddyList{
  buddyList_classification = P.maybe (buddyList_classification default_BuddyList) (\(_,_val597) -> (case _val597 of {T.TString _val598 -> E.decodeUtf8 _val598; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyList_displayName = P.maybe (buddyList_displayName default_BuddyList) (\(_,_val597) -> (case _val597 of {T.TString _val599 -> E.decodeUtf8 _val599; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyList_totalBuddyCount = P.maybe (buddyList_totalBuddyCount default_BuddyList) (\(_,_val597) -> (case _val597 of {T.TI32 _val600 -> _val600; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyList_popularContacts = P.maybe (buddyList_popularContacts default_BuddyList) (\(_,_val597) -> (case _val597 of {T.TList _ _val601 -> (Vector.fromList $ P.map (\_v602 -> (case _v602 of {T.TStruct _val603 -> (to_Contact (T.TStruct _val603)); _ -> P.error "wrong type"})) _val601); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_BuddyList _ = P.error "not a struct"
read_BuddyList :: T.Protocol p => p -> P.IO BuddyList
read_BuddyList iprot = to_BuddyList <$> T.readVal iprot (T.T_STRUCT typemap_BuddyList)
decode_BuddyList :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyList
decode_BuddyList iprot bs = to_BuddyList $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyList) bs
typemap_BuddyList :: T.TypeMap
typemap_BuddyList = Map.fromList [(1,("classification",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("totalBuddyCount",T.T_I32)),(4,("popularContacts",(T.T_LIST (T.T_STRUCT typemap_Contact))))]
default_BuddyList :: BuddyList
default_BuddyList = BuddyList{
  buddyList_classification = "",
  buddyList_displayName = "",
  buddyList_totalBuddyCount = 0,
  buddyList_popularContacts = Vector.empty}
data RegisterWithPhoneNumberResult = RegisterWithPhoneNumberResult  { registerWithPhoneNumberResult_authToken :: LT.Text
  , registerWithPhoneNumberResult_recommendEmailRegistration :: P.Bool
  , registerWithPhoneNumberResult_certificate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithPhoneNumberResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithPhoneNumberResult_authToken record   `H.hashWithSalt` registerWithPhoneNumberResult_recommendEmailRegistration record   `H.hashWithSalt` registerWithPhoneNumberResult_certificate record  
instance QC.Arbitrary RegisterWithPhoneNumberResult where 
  arbitrary = M.liftM RegisterWithPhoneNumberResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithPhoneNumberResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_authToken = registerWithPhoneNumberResult_authToken obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_authToken = registerWithPhoneNumberResult_authToken obj}
    , if obj == default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_recommendEmailRegistration = registerWithPhoneNumberResult_recommendEmailRegistration obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_recommendEmailRegistration = registerWithPhoneNumberResult_recommendEmailRegistration obj}
    , if obj == default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_certificate = registerWithPhoneNumberResult_certificate obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberResult{registerWithPhoneNumberResult_certificate = registerWithPhoneNumberResult_certificate obj}
    ]
from_RegisterWithPhoneNumberResult :: RegisterWithPhoneNumberResult -> T.ThriftVal
from_RegisterWithPhoneNumberResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v606 -> P.Just (1, ("authToken",T.TString $ E.encodeUtf8 _v606))) $ registerWithPhoneNumberResult_authToken record
  , (\_v606 -> P.Just (2, ("recommendEmailRegistration",T.TBool _v606))) $ registerWithPhoneNumberResult_recommendEmailRegistration record
  , (\_v606 -> P.Just (3, ("certificate",T.TString $ E.encodeUtf8 _v606))) $ registerWithPhoneNumberResult_certificate record
  ]
write_RegisterWithPhoneNumberResult :: T.Protocol p => p -> RegisterWithPhoneNumberResult -> P.IO ()
write_RegisterWithPhoneNumberResult oprot record = T.writeVal oprot $ from_RegisterWithPhoneNumberResult record
encode_RegisterWithPhoneNumberResult :: T.StatelessProtocol p => p -> RegisterWithPhoneNumberResult -> LBS.ByteString
encode_RegisterWithPhoneNumberResult oprot record = T.serializeVal oprot $ from_RegisterWithPhoneNumberResult record
to_RegisterWithPhoneNumberResult :: T.ThriftVal -> RegisterWithPhoneNumberResult
to_RegisterWithPhoneNumberResult (T.TStruct fields) = RegisterWithPhoneNumberResult{
  registerWithPhoneNumberResult_authToken = P.maybe (registerWithPhoneNumberResult_authToken default_RegisterWithPhoneNumberResult) (\(_,_val608) -> (case _val608 of {T.TString _val609 -> E.decodeUtf8 _val609; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerWithPhoneNumberResult_recommendEmailRegistration = P.maybe (registerWithPhoneNumberResult_recommendEmailRegistration default_RegisterWithPhoneNumberResult) (\(_,_val608) -> (case _val608 of {T.TBool _val610 -> _val610; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithPhoneNumberResult_certificate = P.maybe (registerWithPhoneNumberResult_certificate default_RegisterWithPhoneNumberResult) (\(_,_val608) -> (case _val608 of {T.TString _val611 -> E.decodeUtf8 _val611; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterWithPhoneNumberResult _ = P.error "not a struct"
read_RegisterWithPhoneNumberResult :: T.Protocol p => p -> P.IO RegisterWithPhoneNumberResult
read_RegisterWithPhoneNumberResult iprot = to_RegisterWithPhoneNumberResult <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberResult)
decode_RegisterWithPhoneNumberResult :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithPhoneNumberResult
decode_RegisterWithPhoneNumberResult iprot bs = to_RegisterWithPhoneNumberResult $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberResult) bs
typemap_RegisterWithPhoneNumberResult :: T.TypeMap
typemap_RegisterWithPhoneNumberResult = Map.fromList [(1,("authToken",T.T_STRING)),(2,("recommendEmailRegistration",T.T_BOOL)),(3,("certificate",T.T_STRING))]
default_RegisterWithPhoneNumberResult :: RegisterWithPhoneNumberResult
default_RegisterWithPhoneNumberResult = RegisterWithPhoneNumberResult{
  registerWithPhoneNumberResult_authToken = "",
  registerWithPhoneNumberResult_recommendEmailRegistration = P.False,
  registerWithPhoneNumberResult_certificate = ""}
data BuddyMessageRequest = BuddyMessageRequest  { buddyMessageRequest_contentType :: ContentType
  , buddyMessageRequest_text :: LT.Text
  , buddyMessageRequest_location :: Location
  , buddyMessageRequest_content :: LBS.ByteString
  , buddyMessageRequest_contentMetadata :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyMessageRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyMessageRequest_contentType record   `H.hashWithSalt` buddyMessageRequest_text record   `H.hashWithSalt` buddyMessageRequest_location record   `H.hashWithSalt` buddyMessageRequest_content record   `H.hashWithSalt` buddyMessageRequest_contentMetadata record  
instance QC.Arbitrary BuddyMessageRequest where 
  arbitrary = M.liftM BuddyMessageRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyMessageRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyMessageRequest{buddyMessageRequest_contentType = buddyMessageRequest_contentType obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_contentType = buddyMessageRequest_contentType obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_text = buddyMessageRequest_text obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_text = buddyMessageRequest_text obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_location = buddyMessageRequest_location obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_location = buddyMessageRequest_location obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_content = buddyMessageRequest_content obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_content = buddyMessageRequest_content obj}
    , if obj == default_BuddyMessageRequest{buddyMessageRequest_contentMetadata = buddyMessageRequest_contentMetadata obj} then P.Nothing else P.Just $ default_BuddyMessageRequest{buddyMessageRequest_contentMetadata = buddyMessageRequest_contentMetadata obj}
    ]
from_BuddyMessageRequest :: BuddyMessageRequest -> T.ThriftVal
from_BuddyMessageRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v614 -> P.Just (1, ("contentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v614))) $ buddyMessageRequest_contentType record
  , (\_v614 -> P.Just (2, ("text",T.TString $ E.encodeUtf8 _v614))) $ buddyMessageRequest_text record
  , (\_v614 -> P.Just (3, ("location",from_Location _v614))) $ buddyMessageRequest_location record
  , (\_v614 -> P.Just (4, ("content",T.TBinary _v614))) $ buddyMessageRequest_content record
  , (\_v614 -> P.Just (5, ("contentMetadata",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k615,_v616) -> (T.TString $ E.encodeUtf8 _k615, T.TString $ E.encodeUtf8 _v616)) $ Map.toList _v614))) $ buddyMessageRequest_contentMetadata record
  ]
write_BuddyMessageRequest :: T.Protocol p => p -> BuddyMessageRequest -> P.IO ()
write_BuddyMessageRequest oprot record = T.writeVal oprot $ from_BuddyMessageRequest record
encode_BuddyMessageRequest :: T.StatelessProtocol p => p -> BuddyMessageRequest -> LBS.ByteString
encode_BuddyMessageRequest oprot record = T.serializeVal oprot $ from_BuddyMessageRequest record
to_BuddyMessageRequest :: T.ThriftVal -> BuddyMessageRequest
to_BuddyMessageRequest (T.TStruct fields) = BuddyMessageRequest{
  buddyMessageRequest_contentType = P.maybe (buddyMessageRequest_contentType default_BuddyMessageRequest) (\(_,_val618) -> (case _val618 of {T.TI32 _val619 -> P.toEnum $ P.fromIntegral _val619; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyMessageRequest_text = P.maybe (buddyMessageRequest_text default_BuddyMessageRequest) (\(_,_val618) -> (case _val618 of {T.TString _val620 -> E.decodeUtf8 _val620; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyMessageRequest_location = P.maybe (buddyMessageRequest_location default_BuddyMessageRequest) (\(_,_val618) -> (case _val618 of {T.TStruct _val621 -> (to_Location (T.TStruct _val621)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyMessageRequest_content = P.maybe (buddyMessageRequest_content default_BuddyMessageRequest) (\(_,_val618) -> (case _val618 of {T.TBinary _val622 -> _val622; T.TString _val622 -> _val622; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyMessageRequest_contentMetadata = P.maybe (buddyMessageRequest_contentMetadata default_BuddyMessageRequest) (\(_,_val618) -> (case _val618 of {T.TMap _ _ _val623 -> (Map.fromList $ P.map (\(_k625,_v624) -> ((case _k625 of {T.TString _val626 -> E.decodeUtf8 _val626; _ -> P.error "wrong type"}),(case _v624 of {T.TString _val627 -> E.decodeUtf8 _val627; _ -> P.error "wrong type"}))) _val623); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_BuddyMessageRequest _ = P.error "not a struct"
read_BuddyMessageRequest :: T.Protocol p => p -> P.IO BuddyMessageRequest
read_BuddyMessageRequest iprot = to_BuddyMessageRequest <$> T.readVal iprot (T.T_STRUCT typemap_BuddyMessageRequest)
decode_BuddyMessageRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyMessageRequest
decode_BuddyMessageRequest iprot bs = to_BuddyMessageRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyMessageRequest) bs
typemap_BuddyMessageRequest :: T.TypeMap
typemap_BuddyMessageRequest = Map.fromList [(1,("contentType",T.T_I32)),(2,("text",T.T_STRING)),(3,("location",(T.T_STRUCT typemap_Location))),(4,("content",T.T_BINARY)),(5,("contentMetadata",(T.T_MAP T.T_STRING T.T_STRING)))]
default_BuddyMessageRequest :: BuddyMessageRequest
default_BuddyMessageRequest = BuddyMessageRequest{
  buddyMessageRequest_contentType = (P.toEnum 0),
  buddyMessageRequest_text = "",
  buddyMessageRequest_location = default_Location,
  buddyMessageRequest_content = "",
  buddyMessageRequest_contentMetadata = Map.empty}
data BuddyOnAirUrls = BuddyOnAirUrls  { buddyOnAirUrls_hls :: (Map.HashMap LT.Text LT.Text)
  , buddyOnAirUrls_smoothStreaming :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyOnAirUrls where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyOnAirUrls_hls record   `H.hashWithSalt` buddyOnAirUrls_smoothStreaming record  
instance QC.Arbitrary BuddyOnAirUrls where 
  arbitrary = M.liftM BuddyOnAirUrls (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyOnAirUrls = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyOnAirUrls{buddyOnAirUrls_hls = buddyOnAirUrls_hls obj} then P.Nothing else P.Just $ default_BuddyOnAirUrls{buddyOnAirUrls_hls = buddyOnAirUrls_hls obj}
    , if obj == default_BuddyOnAirUrls{buddyOnAirUrls_smoothStreaming = buddyOnAirUrls_smoothStreaming obj} then P.Nothing else P.Just $ default_BuddyOnAirUrls{buddyOnAirUrls_smoothStreaming = buddyOnAirUrls_smoothStreaming obj}
    ]
from_BuddyOnAirUrls :: BuddyOnAirUrls -> T.ThriftVal
from_BuddyOnAirUrls record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v630 -> P.Just (1, ("hls",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k631,_v632) -> (T.TString $ E.encodeUtf8 _k631, T.TString $ E.encodeUtf8 _v632)) $ Map.toList _v630))) $ buddyOnAirUrls_hls record
  , (\_v630 -> P.Just (2, ("smoothStreaming",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k633,_v634) -> (T.TString $ E.encodeUtf8 _k633, T.TString $ E.encodeUtf8 _v634)) $ Map.toList _v630))) $ buddyOnAirUrls_smoothStreaming record
  ]
write_BuddyOnAirUrls :: T.Protocol p => p -> BuddyOnAirUrls -> P.IO ()
write_BuddyOnAirUrls oprot record = T.writeVal oprot $ from_BuddyOnAirUrls record
encode_BuddyOnAirUrls :: T.StatelessProtocol p => p -> BuddyOnAirUrls -> LBS.ByteString
encode_BuddyOnAirUrls oprot record = T.serializeVal oprot $ from_BuddyOnAirUrls record
to_BuddyOnAirUrls :: T.ThriftVal -> BuddyOnAirUrls
to_BuddyOnAirUrls (T.TStruct fields) = BuddyOnAirUrls{
  buddyOnAirUrls_hls = P.maybe (buddyOnAirUrls_hls default_BuddyOnAirUrls) (\(_,_val636) -> (case _val636 of {T.TMap _ _ _val637 -> (Map.fromList $ P.map (\(_k639,_v638) -> ((case _k639 of {T.TString _val640 -> E.decodeUtf8 _val640; _ -> P.error "wrong type"}),(case _v638 of {T.TString _val641 -> E.decodeUtf8 _val641; _ -> P.error "wrong type"}))) _val637); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyOnAirUrls_smoothStreaming = P.maybe (buddyOnAirUrls_smoothStreaming default_BuddyOnAirUrls) (\(_,_val636) -> (case _val636 of {T.TMap _ _ _val642 -> (Map.fromList $ P.map (\(_k644,_v643) -> ((case _k644 of {T.TString _val645 -> E.decodeUtf8 _val645; _ -> P.error "wrong type"}),(case _v643 of {T.TString _val646 -> E.decodeUtf8 _val646; _ -> P.error "wrong type"}))) _val642); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BuddyOnAirUrls _ = P.error "not a struct"
read_BuddyOnAirUrls :: T.Protocol p => p -> P.IO BuddyOnAirUrls
read_BuddyOnAirUrls iprot = to_BuddyOnAirUrls <$> T.readVal iprot (T.T_STRUCT typemap_BuddyOnAirUrls)
decode_BuddyOnAirUrls :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyOnAirUrls
decode_BuddyOnAirUrls iprot bs = to_BuddyOnAirUrls $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyOnAirUrls) bs
typemap_BuddyOnAirUrls :: T.TypeMap
typemap_BuddyOnAirUrls = Map.fromList [(1,("hls",(T.T_MAP T.T_STRING T.T_STRING))),(2,("smoothStreaming",(T.T_MAP T.T_STRING T.T_STRING)))]
default_BuddyOnAirUrls :: BuddyOnAirUrls
default_BuddyOnAirUrls = BuddyOnAirUrls{
  buddyOnAirUrls_hls = Map.empty,
  buddyOnAirUrls_smoothStreaming = Map.empty}
data BuddyOnAir = BuddyOnAir  { buddyOnAir_mid :: LT.Text
  , buddyOnAir_freshnessLifetime :: I.Int64
  , buddyOnAir_onAirId :: LT.Text
  , buddyOnAir_onAir :: P.Bool
  , buddyOnAir_text :: LT.Text
  , buddyOnAir_viewerCount :: I.Int64
  , buddyOnAir_targetCount :: I.Int64
  , buddyOnAir_onAirType :: BuddyOnAirType
  , buddyOnAir_onAirUrls :: BuddyOnAirUrls
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyOnAir where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyOnAir_mid record   `H.hashWithSalt` buddyOnAir_freshnessLifetime record   `H.hashWithSalt` buddyOnAir_onAirId record   `H.hashWithSalt` buddyOnAir_onAir record   `H.hashWithSalt` buddyOnAir_text record   `H.hashWithSalt` buddyOnAir_viewerCount record   `H.hashWithSalt` buddyOnAir_targetCount record   `H.hashWithSalt` buddyOnAir_onAirType record   `H.hashWithSalt` buddyOnAir_onAirUrls record  
instance QC.Arbitrary BuddyOnAir where 
  arbitrary = M.liftM BuddyOnAir (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyOnAir = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyOnAir{buddyOnAir_mid = buddyOnAir_mid obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_mid = buddyOnAir_mid obj}
    , if obj == default_BuddyOnAir{buddyOnAir_freshnessLifetime = buddyOnAir_freshnessLifetime obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_freshnessLifetime = buddyOnAir_freshnessLifetime obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirId = buddyOnAir_onAirId obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirId = buddyOnAir_onAirId obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAir = buddyOnAir_onAir obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAir = buddyOnAir_onAir obj}
    , if obj == default_BuddyOnAir{buddyOnAir_text = buddyOnAir_text obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_text = buddyOnAir_text obj}
    , if obj == default_BuddyOnAir{buddyOnAir_viewerCount = buddyOnAir_viewerCount obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_viewerCount = buddyOnAir_viewerCount obj}
    , if obj == default_BuddyOnAir{buddyOnAir_targetCount = buddyOnAir_targetCount obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_targetCount = buddyOnAir_targetCount obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirType = buddyOnAir_onAirType obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirType = buddyOnAir_onAirType obj}
    , if obj == default_BuddyOnAir{buddyOnAir_onAirUrls = buddyOnAir_onAirUrls obj} then P.Nothing else P.Just $ default_BuddyOnAir{buddyOnAir_onAirUrls = buddyOnAir_onAirUrls obj}
    ]
from_BuddyOnAir :: BuddyOnAir -> T.ThriftVal
from_BuddyOnAir record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v649 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v649))) $ buddyOnAir_mid record
  , (\_v649 -> P.Just (3, ("freshnessLifetime",T.TI64 _v649))) $ buddyOnAir_freshnessLifetime record
  , (\_v649 -> P.Just (4, ("onAirId",T.TString $ E.encodeUtf8 _v649))) $ buddyOnAir_onAirId record
  , (\_v649 -> P.Just (5, ("onAir",T.TBool _v649))) $ buddyOnAir_onAir record
  , (\_v649 -> P.Just (11, ("text",T.TString $ E.encodeUtf8 _v649))) $ buddyOnAir_text record
  , (\_v649 -> P.Just (12, ("viewerCount",T.TI64 _v649))) $ buddyOnAir_viewerCount record
  , (\_v649 -> P.Just (13, ("targetCount",T.TI64 _v649))) $ buddyOnAir_targetCount record
  , (\_v649 -> P.Just (31, ("onAirType",T.TI32 $ P.fromIntegral $ P.fromEnum _v649))) $ buddyOnAir_onAirType record
  , (\_v649 -> P.Just (32, ("onAirUrls",from_BuddyOnAirUrls _v649))) $ buddyOnAir_onAirUrls record
  ]
write_BuddyOnAir :: T.Protocol p => p -> BuddyOnAir -> P.IO ()
write_BuddyOnAir oprot record = T.writeVal oprot $ from_BuddyOnAir record
encode_BuddyOnAir :: T.StatelessProtocol p => p -> BuddyOnAir -> LBS.ByteString
encode_BuddyOnAir oprot record = T.serializeVal oprot $ from_BuddyOnAir record
to_BuddyOnAir :: T.ThriftVal -> BuddyOnAir
to_BuddyOnAir (T.TStruct fields) = BuddyOnAir{
  buddyOnAir_mid = P.maybe (buddyOnAir_mid default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TString _val652 -> E.decodeUtf8 _val652; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyOnAir_freshnessLifetime = P.maybe (buddyOnAir_freshnessLifetime default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TI64 _val653 -> _val653; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyOnAir_onAirId = P.maybe (buddyOnAir_onAirId default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TString _val654 -> E.decodeUtf8 _val654; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyOnAir_onAir = P.maybe (buddyOnAir_onAir default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TBool _val655 -> _val655; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyOnAir_text = P.maybe (buddyOnAir_text default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TString _val656 -> E.decodeUtf8 _val656; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  buddyOnAir_viewerCount = P.maybe (buddyOnAir_viewerCount default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TI64 _val657 -> _val657; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  buddyOnAir_targetCount = P.maybe (buddyOnAir_targetCount default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TI64 _val658 -> _val658; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  buddyOnAir_onAirType = P.maybe (buddyOnAir_onAirType default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TI32 _val659 -> P.toEnum $ P.fromIntegral _val659; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  buddyOnAir_onAirUrls = P.maybe (buddyOnAir_onAirUrls default_BuddyOnAir) (\(_,_val651) -> (case _val651 of {T.TStruct _val660 -> (to_BuddyOnAirUrls (T.TStruct _val660)); _ -> P.error "wrong type"})) (Map.lookup (32) fields)
  }
to_BuddyOnAir _ = P.error "not a struct"
read_BuddyOnAir :: T.Protocol p => p -> P.IO BuddyOnAir
read_BuddyOnAir iprot = to_BuddyOnAir <$> T.readVal iprot (T.T_STRUCT typemap_BuddyOnAir)
decode_BuddyOnAir :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyOnAir
decode_BuddyOnAir iprot bs = to_BuddyOnAir $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyOnAir) bs
typemap_BuddyOnAir :: T.TypeMap
typemap_BuddyOnAir = Map.fromList [(1,("mid",T.T_STRING)),(3,("freshnessLifetime",T.T_I64)),(4,("onAirId",T.T_STRING)),(5,("onAir",T.T_BOOL)),(11,("text",T.T_STRING)),(12,("viewerCount",T.T_I64)),(13,("targetCount",T.T_I64)),(31,("onAirType",T.T_I32)),(32,("onAirUrls",(T.T_STRUCT typemap_BuddyOnAirUrls)))]
default_BuddyOnAir :: BuddyOnAir
default_BuddyOnAir = BuddyOnAir{
  buddyOnAir_mid = "",
  buddyOnAir_freshnessLifetime = 0,
  buddyOnAir_onAirId = "",
  buddyOnAir_onAir = P.False,
  buddyOnAir_text = "",
  buddyOnAir_viewerCount = 0,
  buddyOnAir_targetCount = 0,
  buddyOnAir_onAirType = (P.toEnum 0),
  buddyOnAir_onAirUrls = default_BuddyOnAirUrls}
data BuddyProfile = BuddyProfile  { buddyProfile_buddyId :: LT.Text
  , buddyProfile_mid :: LT.Text
  , buddyProfile_searchId :: LT.Text
  , buddyProfile_displayName :: LT.Text
  , buddyProfile_statusMessage :: LT.Text
  , buddyProfile_contactCount :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddyProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddyProfile_buddyId record   `H.hashWithSalt` buddyProfile_mid record   `H.hashWithSalt` buddyProfile_searchId record   `H.hashWithSalt` buddyProfile_displayName record   `H.hashWithSalt` buddyProfile_statusMessage record   `H.hashWithSalt` buddyProfile_contactCount record  
instance QC.Arbitrary BuddyProfile where 
  arbitrary = M.liftM BuddyProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddyProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddyProfile{buddyProfile_buddyId = buddyProfile_buddyId obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_buddyId = buddyProfile_buddyId obj}
    , if obj == default_BuddyProfile{buddyProfile_mid = buddyProfile_mid obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_mid = buddyProfile_mid obj}
    , if obj == default_BuddyProfile{buddyProfile_searchId = buddyProfile_searchId obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_searchId = buddyProfile_searchId obj}
    , if obj == default_BuddyProfile{buddyProfile_displayName = buddyProfile_displayName obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_displayName = buddyProfile_displayName obj}
    , if obj == default_BuddyProfile{buddyProfile_statusMessage = buddyProfile_statusMessage obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_statusMessage = buddyProfile_statusMessage obj}
    , if obj == default_BuddyProfile{buddyProfile_contactCount = buddyProfile_contactCount obj} then P.Nothing else P.Just $ default_BuddyProfile{buddyProfile_contactCount = buddyProfile_contactCount obj}
    ]
from_BuddyProfile :: BuddyProfile -> T.ThriftVal
from_BuddyProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v663 -> P.Just (1, ("buddyId",T.TString $ E.encodeUtf8 _v663))) $ buddyProfile_buddyId record
  , (\_v663 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v663))) $ buddyProfile_mid record
  , (\_v663 -> P.Just (3, ("searchId",T.TString $ E.encodeUtf8 _v663))) $ buddyProfile_searchId record
  , (\_v663 -> P.Just (4, ("displayName",T.TString $ E.encodeUtf8 _v663))) $ buddyProfile_displayName record
  , (\_v663 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v663))) $ buddyProfile_statusMessage record
  , (\_v663 -> P.Just (11, ("contactCount",T.TI64 _v663))) $ buddyProfile_contactCount record
  ]
write_BuddyProfile :: T.Protocol p => p -> BuddyProfile -> P.IO ()
write_BuddyProfile oprot record = T.writeVal oprot $ from_BuddyProfile record
encode_BuddyProfile :: T.StatelessProtocol p => p -> BuddyProfile -> LBS.ByteString
encode_BuddyProfile oprot record = T.serializeVal oprot $ from_BuddyProfile record
to_BuddyProfile :: T.ThriftVal -> BuddyProfile
to_BuddyProfile (T.TStruct fields) = BuddyProfile{
  buddyProfile_buddyId = P.maybe (buddyProfile_buddyId default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TString _val666 -> E.decodeUtf8 _val666; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddyProfile_mid = P.maybe (buddyProfile_mid default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TString _val667 -> E.decodeUtf8 _val667; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddyProfile_searchId = P.maybe (buddyProfile_searchId default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TString _val668 -> E.decodeUtf8 _val668; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddyProfile_displayName = P.maybe (buddyProfile_displayName default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TString _val669 -> E.decodeUtf8 _val669; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddyProfile_statusMessage = P.maybe (buddyProfile_statusMessage default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TString _val670 -> E.decodeUtf8 _val670; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddyProfile_contactCount = P.maybe (buddyProfile_contactCount default_BuddyProfile) (\(_,_val665) -> (case _val665 of {T.TI64 _val671 -> _val671; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_BuddyProfile _ = P.error "not a struct"
read_BuddyProfile :: T.Protocol p => p -> P.IO BuddyProfile
read_BuddyProfile iprot = to_BuddyProfile <$> T.readVal iprot (T.T_STRUCT typemap_BuddyProfile)
decode_BuddyProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddyProfile
decode_BuddyProfile iprot bs = to_BuddyProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddyProfile) bs
typemap_BuddyProfile :: T.TypeMap
typemap_BuddyProfile = Map.fromList [(1,("buddyId",T.T_STRING)),(2,("mid",T.T_STRING)),(3,("searchId",T.T_STRING)),(4,("displayName",T.T_STRING)),(5,("statusMessage",T.T_STRING)),(11,("contactCount",T.T_I64))]
default_BuddyProfile :: BuddyProfile
default_BuddyProfile = BuddyProfile{
  buddyProfile_buddyId = "",
  buddyProfile_mid = "",
  buddyProfile_searchId = "",
  buddyProfile_displayName = "",
  buddyProfile_statusMessage = "",
  buddyProfile_contactCount = 0}
data CommitMessageResult = CommitMessageResult  { commitMessageResult_message :: Message
  , commitMessageResult_code :: CommitMessageResultCode
  , commitMessageResult_reason :: LT.Text
  , commitMessageResult_successCount :: I.Int64
  , commitMessageResult_failCount :: I.Int64
  , commitMessageResult_unregisterCount :: I.Int64
  , commitMessageResult_blockCount :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitMessageResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitMessageResult_message record   `H.hashWithSalt` commitMessageResult_code record   `H.hashWithSalt` commitMessageResult_reason record   `H.hashWithSalt` commitMessageResult_successCount record   `H.hashWithSalt` commitMessageResult_failCount record   `H.hashWithSalt` commitMessageResult_unregisterCount record   `H.hashWithSalt` commitMessageResult_blockCount record  
instance QC.Arbitrary CommitMessageResult where 
  arbitrary = M.liftM CommitMessageResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitMessageResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitMessageResult{commitMessageResult_message = commitMessageResult_message obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_message = commitMessageResult_message obj}
    , if obj == default_CommitMessageResult{commitMessageResult_code = commitMessageResult_code obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_code = commitMessageResult_code obj}
    , if obj == default_CommitMessageResult{commitMessageResult_reason = commitMessageResult_reason obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_reason = commitMessageResult_reason obj}
    , if obj == default_CommitMessageResult{commitMessageResult_successCount = commitMessageResult_successCount obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_successCount = commitMessageResult_successCount obj}
    , if obj == default_CommitMessageResult{commitMessageResult_failCount = commitMessageResult_failCount obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_failCount = commitMessageResult_failCount obj}
    , if obj == default_CommitMessageResult{commitMessageResult_unregisterCount = commitMessageResult_unregisterCount obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_unregisterCount = commitMessageResult_unregisterCount obj}
    , if obj == default_CommitMessageResult{commitMessageResult_blockCount = commitMessageResult_blockCount obj} then P.Nothing else P.Just $ default_CommitMessageResult{commitMessageResult_blockCount = commitMessageResult_blockCount obj}
    ]
from_CommitMessageResult :: CommitMessageResult -> T.ThriftVal
from_CommitMessageResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v674 -> P.Just (1, ("message",from_Message _v674))) $ commitMessageResult_message record
  , (\_v674 -> P.Just (2, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v674))) $ commitMessageResult_code record
  , (\_v674 -> P.Just (3, ("reason",T.TString $ E.encodeUtf8 _v674))) $ commitMessageResult_reason record
  , (\_v674 -> P.Just (4, ("successCount",T.TI64 _v674))) $ commitMessageResult_successCount record
  , (\_v674 -> P.Just (5, ("failCount",T.TI64 _v674))) $ commitMessageResult_failCount record
  , (\_v674 -> P.Just (6, ("unregisterCount",T.TI64 _v674))) $ commitMessageResult_unregisterCount record
  , (\_v674 -> P.Just (7, ("blockCount",T.TI64 _v674))) $ commitMessageResult_blockCount record
  ]
write_CommitMessageResult :: T.Protocol p => p -> CommitMessageResult -> P.IO ()
write_CommitMessageResult oprot record = T.writeVal oprot $ from_CommitMessageResult record
encode_CommitMessageResult :: T.StatelessProtocol p => p -> CommitMessageResult -> LBS.ByteString
encode_CommitMessageResult oprot record = T.serializeVal oprot $ from_CommitMessageResult record
to_CommitMessageResult :: T.ThriftVal -> CommitMessageResult
to_CommitMessageResult (T.TStruct fields) = CommitMessageResult{
  commitMessageResult_message = P.maybe (commitMessageResult_message default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TStruct _val677 -> (to_Message (T.TStruct _val677)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitMessageResult_code = P.maybe (commitMessageResult_code default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TI32 _val678 -> P.toEnum $ P.fromIntegral _val678; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitMessageResult_reason = P.maybe (commitMessageResult_reason default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TString _val679 -> E.decodeUtf8 _val679; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  commitMessageResult_successCount = P.maybe (commitMessageResult_successCount default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TI64 _val680 -> _val680; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  commitMessageResult_failCount = P.maybe (commitMessageResult_failCount default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TI64 _val681 -> _val681; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  commitMessageResult_unregisterCount = P.maybe (commitMessageResult_unregisterCount default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TI64 _val682 -> _val682; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  commitMessageResult_blockCount = P.maybe (commitMessageResult_blockCount default_CommitMessageResult) (\(_,_val676) -> (case _val676 of {T.TI64 _val683 -> _val683; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_CommitMessageResult _ = P.error "not a struct"
read_CommitMessageResult :: T.Protocol p => p -> P.IO CommitMessageResult
read_CommitMessageResult iprot = to_CommitMessageResult <$> T.readVal iprot (T.T_STRUCT typemap_CommitMessageResult)
decode_CommitMessageResult :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitMessageResult
decode_CommitMessageResult iprot bs = to_CommitMessageResult $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitMessageResult) bs
typemap_CommitMessageResult :: T.TypeMap
typemap_CommitMessageResult = Map.fromList [(1,("message",(T.T_STRUCT typemap_Message))),(2,("code",T.T_I32)),(3,("reason",T.T_STRING)),(4,("successCount",T.T_I64)),(5,("failCount",T.T_I64)),(6,("unregisterCount",T.T_I64)),(7,("blockCount",T.T_I64))]
default_CommitMessageResult :: CommitMessageResult
default_CommitMessageResult = CommitMessageResult{
  commitMessageResult_message = default_Message,
  commitMessageResult_code = (P.toEnum 0),
  commitMessageResult_reason = "",
  commitMessageResult_successCount = 0,
  commitMessageResult_failCount = 0,
  commitMessageResult_unregisterCount = 0,
  commitMessageResult_blockCount = 0}
data BuddySearchResult = BuddySearchResult  { buddySearchResult_mid :: LT.Text
  , buddySearchResult_displayName :: LT.Text
  , buddySearchResult_pictureStatus :: LT.Text
  , buddySearchResult_picturePath :: LT.Text
  , buddySearchResult_statusMessage :: LT.Text
  , buddySearchResult_businessAccount :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuddySearchResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` buddySearchResult_mid record   `H.hashWithSalt` buddySearchResult_displayName record   `H.hashWithSalt` buddySearchResult_pictureStatus record   `H.hashWithSalt` buddySearchResult_picturePath record   `H.hashWithSalt` buddySearchResult_statusMessage record   `H.hashWithSalt` buddySearchResult_businessAccount record  
instance QC.Arbitrary BuddySearchResult where 
  arbitrary = M.liftM BuddySearchResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuddySearchResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuddySearchResult{buddySearchResult_mid = buddySearchResult_mid obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_mid = buddySearchResult_mid obj}
    , if obj == default_BuddySearchResult{buddySearchResult_displayName = buddySearchResult_displayName obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_displayName = buddySearchResult_displayName obj}
    , if obj == default_BuddySearchResult{buddySearchResult_pictureStatus = buddySearchResult_pictureStatus obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_pictureStatus = buddySearchResult_pictureStatus obj}
    , if obj == default_BuddySearchResult{buddySearchResult_picturePath = buddySearchResult_picturePath obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_picturePath = buddySearchResult_picturePath obj}
    , if obj == default_BuddySearchResult{buddySearchResult_statusMessage = buddySearchResult_statusMessage obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_statusMessage = buddySearchResult_statusMessage obj}
    , if obj == default_BuddySearchResult{buddySearchResult_businessAccount = buddySearchResult_businessAccount obj} then P.Nothing else P.Just $ default_BuddySearchResult{buddySearchResult_businessAccount = buddySearchResult_businessAccount obj}
    ]
from_BuddySearchResult :: BuddySearchResult -> T.ThriftVal
from_BuddySearchResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v686 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v686))) $ buddySearchResult_mid record
  , (\_v686 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v686))) $ buddySearchResult_displayName record
  , (\_v686 -> P.Just (3, ("pictureStatus",T.TString $ E.encodeUtf8 _v686))) $ buddySearchResult_pictureStatus record
  , (\_v686 -> P.Just (4, ("picturePath",T.TString $ E.encodeUtf8 _v686))) $ buddySearchResult_picturePath record
  , (\_v686 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v686))) $ buddySearchResult_statusMessage record
  , (\_v686 -> P.Just (6, ("businessAccount",T.TBool _v686))) $ buddySearchResult_businessAccount record
  ]
write_BuddySearchResult :: T.Protocol p => p -> BuddySearchResult -> P.IO ()
write_BuddySearchResult oprot record = T.writeVal oprot $ from_BuddySearchResult record
encode_BuddySearchResult :: T.StatelessProtocol p => p -> BuddySearchResult -> LBS.ByteString
encode_BuddySearchResult oprot record = T.serializeVal oprot $ from_BuddySearchResult record
to_BuddySearchResult :: T.ThriftVal -> BuddySearchResult
to_BuddySearchResult (T.TStruct fields) = BuddySearchResult{
  buddySearchResult_mid = P.maybe (buddySearchResult_mid default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TString _val689 -> E.decodeUtf8 _val689; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  buddySearchResult_displayName = P.maybe (buddySearchResult_displayName default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TString _val690 -> E.decodeUtf8 _val690; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buddySearchResult_pictureStatus = P.maybe (buddySearchResult_pictureStatus default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TString _val691 -> E.decodeUtf8 _val691; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buddySearchResult_picturePath = P.maybe (buddySearchResult_picturePath default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TString _val692 -> E.decodeUtf8 _val692; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buddySearchResult_statusMessage = P.maybe (buddySearchResult_statusMessage default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TString _val693 -> E.decodeUtf8 _val693; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buddySearchResult_businessAccount = P.maybe (buddySearchResult_businessAccount default_BuddySearchResult) (\(_,_val688) -> (case _val688 of {T.TBool _val694 -> _val694; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_BuddySearchResult _ = P.error "not a struct"
read_BuddySearchResult :: T.Protocol p => p -> P.IO BuddySearchResult
read_BuddySearchResult iprot = to_BuddySearchResult <$> T.readVal iprot (T.T_STRUCT typemap_BuddySearchResult)
decode_BuddySearchResult :: T.StatelessProtocol p => p -> LBS.ByteString -> BuddySearchResult
decode_BuddySearchResult iprot bs = to_BuddySearchResult $ T.deserializeVal iprot (T.T_STRUCT typemap_BuddySearchResult) bs
typemap_BuddySearchResult :: T.TypeMap
typemap_BuddySearchResult = Map.fromList [(1,("mid",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("pictureStatus",T.T_STRING)),(4,("picturePath",T.T_STRING)),(5,("statusMessage",T.T_STRING)),(6,("businessAccount",T.T_BOOL))]
default_BuddySearchResult :: BuddySearchResult
default_BuddySearchResult = BuddySearchResult{
  buddySearchResult_mid = "",
  buddySearchResult_displayName = "",
  buddySearchResult_pictureStatus = "",
  buddySearchResult_picturePath = "",
  buddySearchResult_statusMessage = "",
  buddySearchResult_businessAccount = P.False}
data SyncParamMid = SyncParamMid  { syncParamMid_mid :: LT.Text
  , syncParamMid_diff :: Diff
  , syncParamMid_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncParamMid where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncParamMid_mid record   `H.hashWithSalt` syncParamMid_diff record   `H.hashWithSalt` syncParamMid_revision record  
instance QC.Arbitrary SyncParamMid where 
  arbitrary = M.liftM SyncParamMid (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncParamMid = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncParamMid{syncParamMid_mid = syncParamMid_mid obj} then P.Nothing else P.Just $ default_SyncParamMid{syncParamMid_mid = syncParamMid_mid obj}
    , if obj == default_SyncParamMid{syncParamMid_diff = syncParamMid_diff obj} then P.Nothing else P.Just $ default_SyncParamMid{syncParamMid_diff = syncParamMid_diff obj}
    , if obj == default_SyncParamMid{syncParamMid_revision = syncParamMid_revision obj} then P.Nothing else P.Just $ default_SyncParamMid{syncParamMid_revision = syncParamMid_revision obj}
    ]
from_SyncParamMid :: SyncParamMid -> T.ThriftVal
from_SyncParamMid record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v697 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v697))) $ syncParamMid_mid record
  , (\_v697 -> P.Just (2, ("diff",T.TI32 $ P.fromIntegral $ P.fromEnum _v697))) $ syncParamMid_diff record
  , (\_v697 -> P.Just (3, ("revision",T.TI64 _v697))) $ syncParamMid_revision record
  ]
write_SyncParamMid :: T.Protocol p => p -> SyncParamMid -> P.IO ()
write_SyncParamMid oprot record = T.writeVal oprot $ from_SyncParamMid record
encode_SyncParamMid :: T.StatelessProtocol p => p -> SyncParamMid -> LBS.ByteString
encode_SyncParamMid oprot record = T.serializeVal oprot $ from_SyncParamMid record
to_SyncParamMid :: T.ThriftVal -> SyncParamMid
to_SyncParamMid (T.TStruct fields) = SyncParamMid{
  syncParamMid_mid = P.maybe (syncParamMid_mid default_SyncParamMid) (\(_,_val699) -> (case _val699 of {T.TString _val700 -> E.decodeUtf8 _val700; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncParamMid_diff = P.maybe (syncParamMid_diff default_SyncParamMid) (\(_,_val699) -> (case _val699 of {T.TI32 _val701 -> P.toEnum $ P.fromIntegral _val701; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncParamMid_revision = P.maybe (syncParamMid_revision default_SyncParamMid) (\(_,_val699) -> (case _val699 of {T.TI64 _val702 -> _val702; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SyncParamMid _ = P.error "not a struct"
read_SyncParamMid :: T.Protocol p => p -> P.IO SyncParamMid
read_SyncParamMid iprot = to_SyncParamMid <$> T.readVal iprot (T.T_STRUCT typemap_SyncParamMid)
decode_SyncParamMid :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncParamMid
decode_SyncParamMid iprot bs = to_SyncParamMid $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncParamMid) bs
typemap_SyncParamMid :: T.TypeMap
typemap_SyncParamMid = Map.fromList [(1,("mid",T.T_STRING)),(2,("diff",T.T_I32)),(3,("revision",T.T_I64))]
default_SyncParamMid :: SyncParamMid
default_SyncParamMid = SyncParamMid{
  syncParamMid_mid = "",
  syncParamMid_diff = (P.toEnum 0),
  syncParamMid_revision = 0}
data SIMInfo = SIMInfo  { sIMInfo_phoneNumber :: LT.Text
  , sIMInfo_countryCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SIMInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` sIMInfo_phoneNumber record   `H.hashWithSalt` sIMInfo_countryCode record  
instance QC.Arbitrary SIMInfo where 
  arbitrary = M.liftM SIMInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SIMInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SIMInfo{sIMInfo_phoneNumber = sIMInfo_phoneNumber obj} then P.Nothing else P.Just $ default_SIMInfo{sIMInfo_phoneNumber = sIMInfo_phoneNumber obj}
    , if obj == default_SIMInfo{sIMInfo_countryCode = sIMInfo_countryCode obj} then P.Nothing else P.Just $ default_SIMInfo{sIMInfo_countryCode = sIMInfo_countryCode obj}
    ]
from_SIMInfo :: SIMInfo -> T.ThriftVal
from_SIMInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v705 -> P.Just (1, ("phoneNumber",T.TString $ E.encodeUtf8 _v705))) $ sIMInfo_phoneNumber record
  , (\_v705 -> P.Just (2, ("countryCode",T.TString $ E.encodeUtf8 _v705))) $ sIMInfo_countryCode record
  ]
write_SIMInfo :: T.Protocol p => p -> SIMInfo -> P.IO ()
write_SIMInfo oprot record = T.writeVal oprot $ from_SIMInfo record
encode_SIMInfo :: T.StatelessProtocol p => p -> SIMInfo -> LBS.ByteString
encode_SIMInfo oprot record = T.serializeVal oprot $ from_SIMInfo record
to_SIMInfo :: T.ThriftVal -> SIMInfo
to_SIMInfo (T.TStruct fields) = SIMInfo{
  sIMInfo_phoneNumber = P.maybe (sIMInfo_phoneNumber default_SIMInfo) (\(_,_val707) -> (case _val707 of {T.TString _val708 -> E.decodeUtf8 _val708; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sIMInfo_countryCode = P.maybe (sIMInfo_countryCode default_SIMInfo) (\(_,_val707) -> (case _val707 of {T.TString _val709 -> E.decodeUtf8 _val709; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SIMInfo _ = P.error "not a struct"
read_SIMInfo :: T.Protocol p => p -> P.IO SIMInfo
read_SIMInfo iprot = to_SIMInfo <$> T.readVal iprot (T.T_STRUCT typemap_SIMInfo)
decode_SIMInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> SIMInfo
decode_SIMInfo iprot bs = to_SIMInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_SIMInfo) bs
typemap_SIMInfo :: T.TypeMap
typemap_SIMInfo = Map.fromList [(1,("phoneNumber",T.T_STRING)),(2,("countryCode",T.T_STRING))]
default_SIMInfo :: SIMInfo
default_SIMInfo = SIMInfo{
  sIMInfo_phoneNumber = "",
  sIMInfo_countryCode = ""}
data SyncParamContact = SyncParamContact  { syncParamContact_syncParamMid :: SyncParamMid
  , syncParamContact_contactStatus :: ContactStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncParamContact where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncParamContact_syncParamMid record   `H.hashWithSalt` syncParamContact_contactStatus record  
instance QC.Arbitrary SyncParamContact where 
  arbitrary = M.liftM SyncParamContact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncParamContact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncParamContact{syncParamContact_syncParamMid = syncParamContact_syncParamMid obj} then P.Nothing else P.Just $ default_SyncParamContact{syncParamContact_syncParamMid = syncParamContact_syncParamMid obj}
    , if obj == default_SyncParamContact{syncParamContact_contactStatus = syncParamContact_contactStatus obj} then P.Nothing else P.Just $ default_SyncParamContact{syncParamContact_contactStatus = syncParamContact_contactStatus obj}
    ]
from_SyncParamContact :: SyncParamContact -> T.ThriftVal
from_SyncParamContact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v712 -> P.Just (1, ("syncParamMid",from_SyncParamMid _v712))) $ syncParamContact_syncParamMid record
  , (\_v712 -> P.Just (2, ("contactStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v712))) $ syncParamContact_contactStatus record
  ]
write_SyncParamContact :: T.Protocol p => p -> SyncParamContact -> P.IO ()
write_SyncParamContact oprot record = T.writeVal oprot $ from_SyncParamContact record
encode_SyncParamContact :: T.StatelessProtocol p => p -> SyncParamContact -> LBS.ByteString
encode_SyncParamContact oprot record = T.serializeVal oprot $ from_SyncParamContact record
to_SyncParamContact :: T.ThriftVal -> SyncParamContact
to_SyncParamContact (T.TStruct fields) = SyncParamContact{
  syncParamContact_syncParamMid = P.maybe (syncParamContact_syncParamMid default_SyncParamContact) (\(_,_val714) -> (case _val714 of {T.TStruct _val715 -> (to_SyncParamMid (T.TStruct _val715)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncParamContact_contactStatus = P.maybe (syncParamContact_contactStatus default_SyncParamContact) (\(_,_val714) -> (case _val714 of {T.TI32 _val716 -> P.toEnum $ P.fromIntegral _val716; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SyncParamContact _ = P.error "not a struct"
read_SyncParamContact :: T.Protocol p => p -> P.IO SyncParamContact
read_SyncParamContact iprot = to_SyncParamContact <$> T.readVal iprot (T.T_STRUCT typemap_SyncParamContact)
decode_SyncParamContact :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncParamContact
decode_SyncParamContact iprot bs = to_SyncParamContact $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncParamContact) bs
typemap_SyncParamContact :: T.TypeMap
typemap_SyncParamContact = Map.fromList [(1,("syncParamMid",(T.T_STRUCT typemap_SyncParamMid))),(2,("contactStatus",T.T_I32))]
default_SyncParamContact :: SyncParamContact
default_SyncParamContact = SyncParamContact{
  syncParamContact_syncParamMid = default_SyncParamMid,
  syncParamContact_contactStatus = (P.toEnum 0)}
data ChannelDomains = ChannelDomains  { channelDomains_channelDomains :: (Vector.Vector ChannelDomain)
  , channelDomains_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelDomains where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelDomains_channelDomains record   `H.hashWithSalt` channelDomains_revision record  
instance QC.Arbitrary ChannelDomains where 
  arbitrary = M.liftM ChannelDomains (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelDomains = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelDomains{channelDomains_channelDomains = channelDomains_channelDomains obj} then P.Nothing else P.Just $ default_ChannelDomains{channelDomains_channelDomains = channelDomains_channelDomains obj}
    , if obj == default_ChannelDomains{channelDomains_revision = channelDomains_revision obj} then P.Nothing else P.Just $ default_ChannelDomains{channelDomains_revision = channelDomains_revision obj}
    ]
from_ChannelDomains :: ChannelDomains -> T.ThriftVal
from_ChannelDomains record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v719 -> P.Just (1, ("channelDomains",T.TList (T.T_STRUCT typemap_ChannelDomain) $ P.map (\_v721 -> from_ChannelDomain _v721) $ Vector.toList _v719))) $ channelDomains_channelDomains record
  , (\_v719 -> P.Just (2, ("revision",T.TI64 _v719))) $ channelDomains_revision record
  ]
write_ChannelDomains :: T.Protocol p => p -> ChannelDomains -> P.IO ()
write_ChannelDomains oprot record = T.writeVal oprot $ from_ChannelDomains record
encode_ChannelDomains :: T.StatelessProtocol p => p -> ChannelDomains -> LBS.ByteString
encode_ChannelDomains oprot record = T.serializeVal oprot $ from_ChannelDomains record
to_ChannelDomains :: T.ThriftVal -> ChannelDomains
to_ChannelDomains (T.TStruct fields) = ChannelDomains{
  channelDomains_channelDomains = P.maybe (channelDomains_channelDomains default_ChannelDomains) (\(_,_val723) -> (case _val723 of {T.TList _ _val724 -> (Vector.fromList $ P.map (\_v725 -> (case _v725 of {T.TStruct _val726 -> (to_ChannelDomain (T.TStruct _val726)); _ -> P.error "wrong type"})) _val724); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelDomains_revision = P.maybe (channelDomains_revision default_ChannelDomains) (\(_,_val723) -> (case _val723 of {T.TI64 _val727 -> _val727; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelDomains _ = P.error "not a struct"
read_ChannelDomains :: T.Protocol p => p -> P.IO ChannelDomains
read_ChannelDomains iprot = to_ChannelDomains <$> T.readVal iprot (T.T_STRUCT typemap_ChannelDomains)
decode_ChannelDomains :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelDomains
decode_ChannelDomains iprot bs = to_ChannelDomains $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelDomains) bs
typemap_ChannelDomains :: T.TypeMap
typemap_ChannelDomains = Map.fromList [(1,("channelDomains",(T.T_LIST (T.T_STRUCT typemap_ChannelDomain)))),(2,("revision",T.T_I64))]
default_ChannelDomains :: ChannelDomains
default_ChannelDomains = ChannelDomains{
  channelDomains_channelDomains = Vector.empty,
  channelDomains_revision = 0}
data ProductCategory = ProductCategory  { productCategory_productCategoryId :: I.Int64
  , productCategory_title :: LT.Text
  , productCategory_productCount :: I.Int32
  , productCategory_newFlag :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductCategory where
  hashWithSalt salt record = salt   `H.hashWithSalt` productCategory_productCategoryId record   `H.hashWithSalt` productCategory_title record   `H.hashWithSalt` productCategory_productCount record   `H.hashWithSalt` productCategory_newFlag record  
instance QC.Arbitrary ProductCategory where 
  arbitrary = M.liftM ProductCategory (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductCategory = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductCategory{productCategory_productCategoryId = productCategory_productCategoryId obj} then P.Nothing else P.Just $ default_ProductCategory{productCategory_productCategoryId = productCategory_productCategoryId obj}
    , if obj == default_ProductCategory{productCategory_title = productCategory_title obj} then P.Nothing else P.Just $ default_ProductCategory{productCategory_title = productCategory_title obj}
    , if obj == default_ProductCategory{productCategory_productCount = productCategory_productCount obj} then P.Nothing else P.Just $ default_ProductCategory{productCategory_productCount = productCategory_productCount obj}
    , if obj == default_ProductCategory{productCategory_newFlag = productCategory_newFlag obj} then P.Nothing else P.Just $ default_ProductCategory{productCategory_newFlag = productCategory_newFlag obj}
    ]
from_ProductCategory :: ProductCategory -> T.ThriftVal
from_ProductCategory record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v730 -> P.Just (1, ("productCategoryId",T.TI64 _v730))) $ productCategory_productCategoryId record
  , (\_v730 -> P.Just (2, ("title",T.TString $ E.encodeUtf8 _v730))) $ productCategory_title record
  , (\_v730 -> P.Just (3, ("productCount",T.TI32 _v730))) $ productCategory_productCount record
  , (\_v730 -> P.Just (4, ("newFlag",T.TBool _v730))) $ productCategory_newFlag record
  ]
write_ProductCategory :: T.Protocol p => p -> ProductCategory -> P.IO ()
write_ProductCategory oprot record = T.writeVal oprot $ from_ProductCategory record
encode_ProductCategory :: T.StatelessProtocol p => p -> ProductCategory -> LBS.ByteString
encode_ProductCategory oprot record = T.serializeVal oprot $ from_ProductCategory record
to_ProductCategory :: T.ThriftVal -> ProductCategory
to_ProductCategory (T.TStruct fields) = ProductCategory{
  productCategory_productCategoryId = P.maybe (productCategory_productCategoryId default_ProductCategory) (\(_,_val732) -> (case _val732 of {T.TI64 _val733 -> _val733; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productCategory_title = P.maybe (productCategory_title default_ProductCategory) (\(_,_val732) -> (case _val732 of {T.TString _val734 -> E.decodeUtf8 _val734; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  productCategory_productCount = P.maybe (productCategory_productCount default_ProductCategory) (\(_,_val732) -> (case _val732 of {T.TI32 _val735 -> _val735; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  productCategory_newFlag = P.maybe (productCategory_newFlag default_ProductCategory) (\(_,_val732) -> (case _val732 of {T.TBool _val736 -> _val736; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ProductCategory _ = P.error "not a struct"
read_ProductCategory :: T.Protocol p => p -> P.IO ProductCategory
read_ProductCategory iprot = to_ProductCategory <$> T.readVal iprot (T.T_STRUCT typemap_ProductCategory)
decode_ProductCategory :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductCategory
decode_ProductCategory iprot bs = to_ProductCategory $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductCategory) bs
typemap_ProductCategory :: T.TypeMap
typemap_ProductCategory = Map.fromList [(1,("productCategoryId",T.T_I64)),(2,("title",T.T_STRING)),(3,("productCount",T.T_I32)),(4,("newFlag",T.T_BOOL))]
default_ProductCategory :: ProductCategory
default_ProductCategory = ProductCategory{
  productCategory_productCategoryId = 0,
  productCategory_title = "",
  productCategory_productCount = 0,
  productCategory_newFlag = P.False}
data ChannelInfos = ChannelInfos  { channelInfos_channelInfos :: (Vector.Vector ChannelInfo)
  , channelInfos_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelInfos where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelInfos_channelInfos record   `H.hashWithSalt` channelInfos_revision record  
instance QC.Arbitrary ChannelInfos where 
  arbitrary = M.liftM ChannelInfos (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelInfos = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelInfos{channelInfos_channelInfos = channelInfos_channelInfos obj} then P.Nothing else P.Just $ default_ChannelInfos{channelInfos_channelInfos = channelInfos_channelInfos obj}
    , if obj == default_ChannelInfos{channelInfos_revision = channelInfos_revision obj} then P.Nothing else P.Just $ default_ChannelInfos{channelInfos_revision = channelInfos_revision obj}
    ]
from_ChannelInfos :: ChannelInfos -> T.ThriftVal
from_ChannelInfos record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v739 -> P.Just (1, ("channelInfos",T.TList (T.T_STRUCT typemap_ChannelInfo) $ P.map (\_v741 -> from_ChannelInfo _v741) $ Vector.toList _v739))) $ channelInfos_channelInfos record
  , (\_v739 -> P.Just (2, ("revision",T.TI64 _v739))) $ channelInfos_revision record
  ]
write_ChannelInfos :: T.Protocol p => p -> ChannelInfos -> P.IO ()
write_ChannelInfos oprot record = T.writeVal oprot $ from_ChannelInfos record
encode_ChannelInfos :: T.StatelessProtocol p => p -> ChannelInfos -> LBS.ByteString
encode_ChannelInfos oprot record = T.serializeVal oprot $ from_ChannelInfos record
to_ChannelInfos :: T.ThriftVal -> ChannelInfos
to_ChannelInfos (T.TStruct fields) = ChannelInfos{
  channelInfos_channelInfos = P.maybe (channelInfos_channelInfos default_ChannelInfos) (\(_,_val743) -> (case _val743 of {T.TList _ _val744 -> (Vector.fromList $ P.map (\_v745 -> (case _v745 of {T.TStruct _val746 -> (to_ChannelInfo (T.TStruct _val746)); _ -> P.error "wrong type"})) _val744); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelInfos_revision = P.maybe (channelInfos_revision default_ChannelInfos) (\(_,_val743) -> (case _val743 of {T.TI64 _val747 -> _val747; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelInfos _ = P.error "not a struct"
read_ChannelInfos :: T.Protocol p => p -> P.IO ChannelInfos
read_ChannelInfos iprot = to_ChannelInfos <$> T.readVal iprot (T.T_STRUCT typemap_ChannelInfos)
decode_ChannelInfos :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelInfos
decode_ChannelInfos iprot bs = to_ChannelInfos $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelInfos) bs
typemap_ChannelInfos :: T.TypeMap
typemap_ChannelInfos = Map.fromList [(1,("channelInfos",(T.T_LIST (T.T_STRUCT typemap_ChannelInfo)))),(2,("revision",T.T_I64))]
default_ChannelInfos :: ChannelInfos
default_ChannelInfos = ChannelInfos{
  channelInfos_channelInfos = Vector.empty,
  channelInfos_revision = 0}
data ChannelNotificationSetting = ChannelNotificationSetting  { channelNotificationSetting_channelId :: LT.Text
  , channelNotificationSetting_name :: LT.Text
  , channelNotificationSetting_notificationReceivable :: P.Bool
  , channelNotificationSetting_messageReceivable :: P.Bool
  , channelNotificationSetting_showDefault :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelNotificationSetting where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelNotificationSetting_channelId record   `H.hashWithSalt` channelNotificationSetting_name record   `H.hashWithSalt` channelNotificationSetting_notificationReceivable record   `H.hashWithSalt` channelNotificationSetting_messageReceivable record   `H.hashWithSalt` channelNotificationSetting_showDefault record  
instance QC.Arbitrary ChannelNotificationSetting where 
  arbitrary = M.liftM ChannelNotificationSetting (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelNotificationSetting = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelNotificationSetting{channelNotificationSetting_channelId = channelNotificationSetting_channelId obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_channelId = channelNotificationSetting_channelId obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_name = channelNotificationSetting_name obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_name = channelNotificationSetting_name obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_notificationReceivable = channelNotificationSetting_notificationReceivable obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_notificationReceivable = channelNotificationSetting_notificationReceivable obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_messageReceivable = channelNotificationSetting_messageReceivable obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_messageReceivable = channelNotificationSetting_messageReceivable obj}
    , if obj == default_ChannelNotificationSetting{channelNotificationSetting_showDefault = channelNotificationSetting_showDefault obj} then P.Nothing else P.Just $ default_ChannelNotificationSetting{channelNotificationSetting_showDefault = channelNotificationSetting_showDefault obj}
    ]
from_ChannelNotificationSetting :: ChannelNotificationSetting -> T.ThriftVal
from_ChannelNotificationSetting record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v750 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v750))) $ channelNotificationSetting_channelId record
  , (\_v750 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v750))) $ channelNotificationSetting_name record
  , (\_v750 -> P.Just (3, ("notificationReceivable",T.TBool _v750))) $ channelNotificationSetting_notificationReceivable record
  , (\_v750 -> P.Just (4, ("messageReceivable",T.TBool _v750))) $ channelNotificationSetting_messageReceivable record
  , (\_v750 -> P.Just (5, ("showDefault",T.TBool _v750))) $ channelNotificationSetting_showDefault record
  ]
write_ChannelNotificationSetting :: T.Protocol p => p -> ChannelNotificationSetting -> P.IO ()
write_ChannelNotificationSetting oprot record = T.writeVal oprot $ from_ChannelNotificationSetting record
encode_ChannelNotificationSetting :: T.StatelessProtocol p => p -> ChannelNotificationSetting -> LBS.ByteString
encode_ChannelNotificationSetting oprot record = T.serializeVal oprot $ from_ChannelNotificationSetting record
to_ChannelNotificationSetting :: T.ThriftVal -> ChannelNotificationSetting
to_ChannelNotificationSetting (T.TStruct fields) = ChannelNotificationSetting{
  channelNotificationSetting_channelId = P.maybe (channelNotificationSetting_channelId default_ChannelNotificationSetting) (\(_,_val752) -> (case _val752 of {T.TString _val753 -> E.decodeUtf8 _val753; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelNotificationSetting_name = P.maybe (channelNotificationSetting_name default_ChannelNotificationSetting) (\(_,_val752) -> (case _val752 of {T.TString _val754 -> E.decodeUtf8 _val754; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelNotificationSetting_notificationReceivable = P.maybe (channelNotificationSetting_notificationReceivable default_ChannelNotificationSetting) (\(_,_val752) -> (case _val752 of {T.TBool _val755 -> _val755; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelNotificationSetting_messageReceivable = P.maybe (channelNotificationSetting_messageReceivable default_ChannelNotificationSetting) (\(_,_val752) -> (case _val752 of {T.TBool _val756 -> _val756; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelNotificationSetting_showDefault = P.maybe (channelNotificationSetting_showDefault default_ChannelNotificationSetting) (\(_,_val752) -> (case _val752 of {T.TBool _val757 -> _val757; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ChannelNotificationSetting _ = P.error "not a struct"
read_ChannelNotificationSetting :: T.Protocol p => p -> P.IO ChannelNotificationSetting
read_ChannelNotificationSetting iprot = to_ChannelNotificationSetting <$> T.readVal iprot (T.T_STRUCT typemap_ChannelNotificationSetting)
decode_ChannelNotificationSetting :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelNotificationSetting
decode_ChannelNotificationSetting iprot bs = to_ChannelNotificationSetting $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelNotificationSetting) bs
typemap_ChannelNotificationSetting :: T.TypeMap
typemap_ChannelNotificationSetting = Map.fromList [(1,("channelId",T.T_STRING)),(2,("name",T.T_STRING)),(3,("notificationReceivable",T.T_BOOL)),(4,("messageReceivable",T.T_BOOL)),(5,("showDefault",T.T_BOOL))]
default_ChannelNotificationSetting :: ChannelNotificationSetting
default_ChannelNotificationSetting = ChannelNotificationSetting{
  channelNotificationSetting_channelId = "",
  channelNotificationSetting_name = "",
  channelNotificationSetting_notificationReceivable = P.False,
  channelNotificationSetting_messageReceivable = P.False,
  channelNotificationSetting_showDefault = P.False}
data ChannelSyncDatas = ChannelSyncDatas  { channelSyncDatas_channelInfos :: (Vector.Vector ChannelInfo)
  , channelSyncDatas_channelDomains :: (Vector.Vector ChannelDomain)
  , channelSyncDatas_revision :: I.Int64
  , channelSyncDatas_expires :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelSyncDatas where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelSyncDatas_channelInfos record   `H.hashWithSalt` channelSyncDatas_channelDomains record   `H.hashWithSalt` channelSyncDatas_revision record   `H.hashWithSalt` channelSyncDatas_expires record  
instance QC.Arbitrary ChannelSyncDatas where 
  arbitrary = M.liftM ChannelSyncDatas (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelSyncDatas = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelSyncDatas{channelSyncDatas_channelInfos = channelSyncDatas_channelInfos obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_channelInfos = channelSyncDatas_channelInfos obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_channelDomains = channelSyncDatas_channelDomains obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_channelDomains = channelSyncDatas_channelDomains obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_revision = channelSyncDatas_revision obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_revision = channelSyncDatas_revision obj}
    , if obj == default_ChannelSyncDatas{channelSyncDatas_expires = channelSyncDatas_expires obj} then P.Nothing else P.Just $ default_ChannelSyncDatas{channelSyncDatas_expires = channelSyncDatas_expires obj}
    ]
from_ChannelSyncDatas :: ChannelSyncDatas -> T.ThriftVal
from_ChannelSyncDatas record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v760 -> P.Just (1, ("channelInfos",T.TList (T.T_STRUCT typemap_ChannelInfo) $ P.map (\_v762 -> from_ChannelInfo _v762) $ Vector.toList _v760))) $ channelSyncDatas_channelInfos record
  , (\_v760 -> P.Just (2, ("channelDomains",T.TList (T.T_STRUCT typemap_ChannelDomain) $ P.map (\_v764 -> from_ChannelDomain _v764) $ Vector.toList _v760))) $ channelSyncDatas_channelDomains record
  , (\_v760 -> P.Just (3, ("revision",T.TI64 _v760))) $ channelSyncDatas_revision record
  , (\_v760 -> P.Just (4, ("expires",T.TI64 _v760))) $ channelSyncDatas_expires record
  ]
write_ChannelSyncDatas :: T.Protocol p => p -> ChannelSyncDatas -> P.IO ()
write_ChannelSyncDatas oprot record = T.writeVal oprot $ from_ChannelSyncDatas record
encode_ChannelSyncDatas :: T.StatelessProtocol p => p -> ChannelSyncDatas -> LBS.ByteString
encode_ChannelSyncDatas oprot record = T.serializeVal oprot $ from_ChannelSyncDatas record
to_ChannelSyncDatas :: T.ThriftVal -> ChannelSyncDatas
to_ChannelSyncDatas (T.TStruct fields) = ChannelSyncDatas{
  channelSyncDatas_channelInfos = P.maybe (channelSyncDatas_channelInfos default_ChannelSyncDatas) (\(_,_val766) -> (case _val766 of {T.TList _ _val767 -> (Vector.fromList $ P.map (\_v768 -> (case _v768 of {T.TStruct _val769 -> (to_ChannelInfo (T.TStruct _val769)); _ -> P.error "wrong type"})) _val767); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelSyncDatas_channelDomains = P.maybe (channelSyncDatas_channelDomains default_ChannelSyncDatas) (\(_,_val766) -> (case _val766 of {T.TList _ _val770 -> (Vector.fromList $ P.map (\_v771 -> (case _v771 of {T.TStruct _val772 -> (to_ChannelDomain (T.TStruct _val772)); _ -> P.error "wrong type"})) _val770); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelSyncDatas_revision = P.maybe (channelSyncDatas_revision default_ChannelSyncDatas) (\(_,_val766) -> (case _val766 of {T.TI64 _val773 -> _val773; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelSyncDatas_expires = P.maybe (channelSyncDatas_expires default_ChannelSyncDatas) (\(_,_val766) -> (case _val766 of {T.TI64 _val774 -> _val774; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ChannelSyncDatas _ = P.error "not a struct"
read_ChannelSyncDatas :: T.Protocol p => p -> P.IO ChannelSyncDatas
read_ChannelSyncDatas iprot = to_ChannelSyncDatas <$> T.readVal iprot (T.T_STRUCT typemap_ChannelSyncDatas)
decode_ChannelSyncDatas :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelSyncDatas
decode_ChannelSyncDatas iprot bs = to_ChannelSyncDatas $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelSyncDatas) bs
typemap_ChannelSyncDatas :: T.TypeMap
typemap_ChannelSyncDatas = Map.fromList [(1,("channelInfos",(T.T_LIST (T.T_STRUCT typemap_ChannelInfo)))),(2,("channelDomains",(T.T_LIST (T.T_STRUCT typemap_ChannelDomain)))),(3,("revision",T.T_I64)),(4,("expires",T.T_I64))]
default_ChannelSyncDatas :: ChannelSyncDatas
default_ChannelSyncDatas = ChannelSyncDatas{
  channelSyncDatas_channelInfos = Vector.empty,
  channelSyncDatas_channelDomains = Vector.empty,
  channelSyncDatas_revision = 0,
  channelSyncDatas_expires = 0}
data NotiCenterEventData = NotiCenterEventData  { notiCenterEventData_id :: LT.Text
  , notiCenterEventData_to :: LT.Text
  , notiCenterEventData_from_ :: LT.Text
  , notiCenterEventData_toChannel :: LT.Text
  , notiCenterEventData_fromChannel :: LT.Text
  , notiCenterEventData_eventType :: LT.Text
  , notiCenterEventData_createdTime :: I.Int64
  , notiCenterEventData_operationRevision :: I.Int64
  , notiCenterEventData_content :: (Map.HashMap LT.Text LT.Text)
  , notiCenterEventData_push :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotiCenterEventData where
  hashWithSalt salt record = salt   `H.hashWithSalt` notiCenterEventData_id record   `H.hashWithSalt` notiCenterEventData_to record   `H.hashWithSalt` notiCenterEventData_from_ record   `H.hashWithSalt` notiCenterEventData_toChannel record   `H.hashWithSalt` notiCenterEventData_fromChannel record   `H.hashWithSalt` notiCenterEventData_eventType record   `H.hashWithSalt` notiCenterEventData_createdTime record   `H.hashWithSalt` notiCenterEventData_operationRevision record   `H.hashWithSalt` notiCenterEventData_content record   `H.hashWithSalt` notiCenterEventData_push record  
instance QC.Arbitrary NotiCenterEventData where 
  arbitrary = M.liftM NotiCenterEventData (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotiCenterEventData = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotiCenterEventData{notiCenterEventData_id = notiCenterEventData_id obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_id = notiCenterEventData_id obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_to = notiCenterEventData_to obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_to = notiCenterEventData_to obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_from_ = notiCenterEventData_from_ obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_from_ = notiCenterEventData_from_ obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_toChannel = notiCenterEventData_toChannel obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_toChannel = notiCenterEventData_toChannel obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_fromChannel = notiCenterEventData_fromChannel obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_fromChannel = notiCenterEventData_fromChannel obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_eventType = notiCenterEventData_eventType obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_eventType = notiCenterEventData_eventType obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_createdTime = notiCenterEventData_createdTime obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_createdTime = notiCenterEventData_createdTime obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_operationRevision = notiCenterEventData_operationRevision obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_operationRevision = notiCenterEventData_operationRevision obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_content = notiCenterEventData_content obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_content = notiCenterEventData_content obj}
    , if obj == default_NotiCenterEventData{notiCenterEventData_push = notiCenterEventData_push obj} then P.Nothing else P.Just $ default_NotiCenterEventData{notiCenterEventData_push = notiCenterEventData_push obj}
    ]
from_NotiCenterEventData :: NotiCenterEventData -> T.ThriftVal
from_NotiCenterEventData record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v777 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_id record
  , (\_v777 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_to record
  , (\_v777 -> P.Just (3, ("from_",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_from_ record
  , (\_v777 -> P.Just (4, ("toChannel",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_toChannel record
  , (\_v777 -> P.Just (5, ("fromChannel",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_fromChannel record
  , (\_v777 -> P.Just (6, ("eventType",T.TString $ E.encodeUtf8 _v777))) $ notiCenterEventData_eventType record
  , (\_v777 -> P.Just (7, ("createdTime",T.TI64 _v777))) $ notiCenterEventData_createdTime record
  , (\_v777 -> P.Just (8, ("operationRevision",T.TI64 _v777))) $ notiCenterEventData_operationRevision record
  , (\_v777 -> P.Just (9, ("content",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k778,_v779) -> (T.TString $ E.encodeUtf8 _k778, T.TString $ E.encodeUtf8 _v779)) $ Map.toList _v777))) $ notiCenterEventData_content record
  , (\_v777 -> P.Just (10, ("push",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k780,_v781) -> (T.TString $ E.encodeUtf8 _k780, T.TString $ E.encodeUtf8 _v781)) $ Map.toList _v777))) $ notiCenterEventData_push record
  ]
write_NotiCenterEventData :: T.Protocol p => p -> NotiCenterEventData -> P.IO ()
write_NotiCenterEventData oprot record = T.writeVal oprot $ from_NotiCenterEventData record
encode_NotiCenterEventData :: T.StatelessProtocol p => p -> NotiCenterEventData -> LBS.ByteString
encode_NotiCenterEventData oprot record = T.serializeVal oprot $ from_NotiCenterEventData record
to_NotiCenterEventData :: T.ThriftVal -> NotiCenterEventData
to_NotiCenterEventData (T.TStruct fields) = NotiCenterEventData{
  notiCenterEventData_id = P.maybe (notiCenterEventData_id default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val784 -> E.decodeUtf8 _val784; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notiCenterEventData_to = P.maybe (notiCenterEventData_to default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val785 -> E.decodeUtf8 _val785; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notiCenterEventData_from_ = P.maybe (notiCenterEventData_from_ default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val786 -> E.decodeUtf8 _val786; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notiCenterEventData_toChannel = P.maybe (notiCenterEventData_toChannel default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val787 -> E.decodeUtf8 _val787; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notiCenterEventData_fromChannel = P.maybe (notiCenterEventData_fromChannel default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val788 -> E.decodeUtf8 _val788; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notiCenterEventData_eventType = P.maybe (notiCenterEventData_eventType default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TString _val789 -> E.decodeUtf8 _val789; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  notiCenterEventData_createdTime = P.maybe (notiCenterEventData_createdTime default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TI64 _val790 -> _val790; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notiCenterEventData_operationRevision = P.maybe (notiCenterEventData_operationRevision default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TI64 _val791 -> _val791; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notiCenterEventData_content = P.maybe (notiCenterEventData_content default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TMap _ _ _val792 -> (Map.fromList $ P.map (\(_k794,_v793) -> ((case _k794 of {T.TString _val795 -> E.decodeUtf8 _val795; _ -> P.error "wrong type"}),(case _v793 of {T.TString _val796 -> E.decodeUtf8 _val796; _ -> P.error "wrong type"}))) _val792); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  notiCenterEventData_push = P.maybe (notiCenterEventData_push default_NotiCenterEventData) (\(_,_val783) -> (case _val783 of {T.TMap _ _ _val797 -> (Map.fromList $ P.map (\(_k799,_v798) -> ((case _k799 of {T.TString _val800 -> E.decodeUtf8 _val800; _ -> P.error "wrong type"}),(case _v798 of {T.TString _val801 -> E.decodeUtf8 _val801; _ -> P.error "wrong type"}))) _val797); _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_NotiCenterEventData _ = P.error "not a struct"
read_NotiCenterEventData :: T.Protocol p => p -> P.IO NotiCenterEventData
read_NotiCenterEventData iprot = to_NotiCenterEventData <$> T.readVal iprot (T.T_STRUCT typemap_NotiCenterEventData)
decode_NotiCenterEventData :: T.StatelessProtocol p => p -> LBS.ByteString -> NotiCenterEventData
decode_NotiCenterEventData iprot bs = to_NotiCenterEventData $ T.deserializeVal iprot (T.T_STRUCT typemap_NotiCenterEventData) bs
typemap_NotiCenterEventData :: T.TypeMap
typemap_NotiCenterEventData = Map.fromList [(1,("id",T.T_STRING)),(2,("to",T.T_STRING)),(3,("from_",T.T_STRING)),(4,("toChannel",T.T_STRING)),(5,("fromChannel",T.T_STRING)),(6,("eventType",T.T_STRING)),(7,("createdTime",T.T_I64)),(8,("operationRevision",T.T_I64)),(9,("content",(T.T_MAP T.T_STRING T.T_STRING))),(10,("push",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotiCenterEventData :: NotiCenterEventData
default_NotiCenterEventData = NotiCenterEventData{
  notiCenterEventData_id = "",
  notiCenterEventData_to = "",
  notiCenterEventData_from_ = "",
  notiCenterEventData_toChannel = "",
  notiCenterEventData_fromChannel = "",
  notiCenterEventData_eventType = "",
  notiCenterEventData_createdTime = 0,
  notiCenterEventData_operationRevision = 0,
  notiCenterEventData_content = Map.empty,
  notiCenterEventData_push = Map.empty}
data ChannelToken = ChannelToken  { channelToken_token :: LT.Text
  , channelToken_obsToken :: LT.Text
  , channelToken_expiration :: I.Int64
  , channelToken_refreshToken :: LT.Text
  , channelToken_channelAccessToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelToken where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelToken_token record   `H.hashWithSalt` channelToken_obsToken record   `H.hashWithSalt` channelToken_expiration record   `H.hashWithSalt` channelToken_refreshToken record   `H.hashWithSalt` channelToken_channelAccessToken record  
instance QC.Arbitrary ChannelToken where 
  arbitrary = M.liftM ChannelToken (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelToken = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelToken{channelToken_token = channelToken_token obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_token = channelToken_token obj}
    , if obj == default_ChannelToken{channelToken_obsToken = channelToken_obsToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_obsToken = channelToken_obsToken obj}
    , if obj == default_ChannelToken{channelToken_expiration = channelToken_expiration obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_expiration = channelToken_expiration obj}
    , if obj == default_ChannelToken{channelToken_refreshToken = channelToken_refreshToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_refreshToken = channelToken_refreshToken obj}
    , if obj == default_ChannelToken{channelToken_channelAccessToken = channelToken_channelAccessToken obj} then P.Nothing else P.Just $ default_ChannelToken{channelToken_channelAccessToken = channelToken_channelAccessToken obj}
    ]
from_ChannelToken :: ChannelToken -> T.ThriftVal
from_ChannelToken record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v804 -> P.Just (1, ("token",T.TString $ E.encodeUtf8 _v804))) $ channelToken_token record
  , (\_v804 -> P.Just (2, ("obsToken",T.TString $ E.encodeUtf8 _v804))) $ channelToken_obsToken record
  , (\_v804 -> P.Just (3, ("expiration",T.TI64 _v804))) $ channelToken_expiration record
  , (\_v804 -> P.Just (4, ("refreshToken",T.TString $ E.encodeUtf8 _v804))) $ channelToken_refreshToken record
  , (\_v804 -> P.Just (5, ("channelAccessToken",T.TString $ E.encodeUtf8 _v804))) $ channelToken_channelAccessToken record
  ]
write_ChannelToken :: T.Protocol p => p -> ChannelToken -> P.IO ()
write_ChannelToken oprot record = T.writeVal oprot $ from_ChannelToken record
encode_ChannelToken :: T.StatelessProtocol p => p -> ChannelToken -> LBS.ByteString
encode_ChannelToken oprot record = T.serializeVal oprot $ from_ChannelToken record
to_ChannelToken :: T.ThriftVal -> ChannelToken
to_ChannelToken (T.TStruct fields) = ChannelToken{
  channelToken_token = P.maybe (channelToken_token default_ChannelToken) (\(_,_val806) -> (case _val806 of {T.TString _val807 -> E.decodeUtf8 _val807; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelToken_obsToken = P.maybe (channelToken_obsToken default_ChannelToken) (\(_,_val806) -> (case _val806 of {T.TString _val808 -> E.decodeUtf8 _val808; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelToken_expiration = P.maybe (channelToken_expiration default_ChannelToken) (\(_,_val806) -> (case _val806 of {T.TI64 _val809 -> _val809; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  channelToken_refreshToken = P.maybe (channelToken_refreshToken default_ChannelToken) (\(_,_val806) -> (case _val806 of {T.TString _val810 -> E.decodeUtf8 _val810; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  channelToken_channelAccessToken = P.maybe (channelToken_channelAccessToken default_ChannelToken) (\(_,_val806) -> (case _val806 of {T.TString _val811 -> E.decodeUtf8 _val811; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ChannelToken _ = P.error "not a struct"
read_ChannelToken :: T.Protocol p => p -> P.IO ChannelToken
read_ChannelToken iprot = to_ChannelToken <$> T.readVal iprot (T.T_STRUCT typemap_ChannelToken)
decode_ChannelToken :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelToken
decode_ChannelToken iprot bs = to_ChannelToken $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelToken) bs
typemap_ChannelToken :: T.TypeMap
typemap_ChannelToken = Map.fromList [(1,("token",T.T_STRING)),(2,("obsToken",T.T_STRING)),(3,("expiration",T.T_I64)),(4,("refreshToken",T.T_STRING)),(5,("channelAccessToken",T.T_STRING))]
default_ChannelToken :: ChannelToken
default_ChannelToken = ChannelToken{
  channelToken_token = "",
  channelToken_obsToken = "",
  channelToken_expiration = 0,
  channelToken_refreshToken = "",
  channelToken_channelAccessToken = ""}
data ChannelSettings = ChannelSettings  { channelSettings_unapprovedMessageReceivable :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelSettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelSettings_unapprovedMessageReceivable record  
instance QC.Arbitrary ChannelSettings where 
  arbitrary = M.liftM ChannelSettings (QC.arbitrary)
  shrink obj | obj == default_ChannelSettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelSettings{channelSettings_unapprovedMessageReceivable = channelSettings_unapprovedMessageReceivable obj} then P.Nothing else P.Just $ default_ChannelSettings{channelSettings_unapprovedMessageReceivable = channelSettings_unapprovedMessageReceivable obj}
    ]
from_ChannelSettings :: ChannelSettings -> T.ThriftVal
from_ChannelSettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v814 -> P.Just (1, ("unapprovedMessageReceivable",T.TBool _v814))) $ channelSettings_unapprovedMessageReceivable record
  ]
write_ChannelSettings :: T.Protocol p => p -> ChannelSettings -> P.IO ()
write_ChannelSettings oprot record = T.writeVal oprot $ from_ChannelSettings record
encode_ChannelSettings :: T.StatelessProtocol p => p -> ChannelSettings -> LBS.ByteString
encode_ChannelSettings oprot record = T.serializeVal oprot $ from_ChannelSettings record
to_ChannelSettings :: T.ThriftVal -> ChannelSettings
to_ChannelSettings (T.TStruct fields) = ChannelSettings{
  channelSettings_unapprovedMessageReceivable = P.maybe (channelSettings_unapprovedMessageReceivable default_ChannelSettings) (\(_,_val816) -> (case _val816 of {T.TBool _val817 -> _val817; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ChannelSettings _ = P.error "not a struct"
read_ChannelSettings :: T.Protocol p => p -> P.IO ChannelSettings
read_ChannelSettings iprot = to_ChannelSettings <$> T.readVal iprot (T.T_STRUCT typemap_ChannelSettings)
decode_ChannelSettings :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelSettings
decode_ChannelSettings iprot bs = to_ChannelSettings $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelSettings) bs
typemap_ChannelSettings :: T.TypeMap
typemap_ChannelSettings = Map.fromList [(1,("unapprovedMessageReceivable",T.T_BOOL))]
default_ChannelSettings :: ChannelSettings
default_ChannelSettings = ChannelSettings{
  channelSettings_unapprovedMessageReceivable = P.False}
data ChannelIdWithLastUpdated = ChannelIdWithLastUpdated  { channelIdWithLastUpdated_channelId :: LT.Text
  , channelIdWithLastUpdated_lastUpdated :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChannelIdWithLastUpdated where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelIdWithLastUpdated_channelId record   `H.hashWithSalt` channelIdWithLastUpdated_lastUpdated record  
instance QC.Arbitrary ChannelIdWithLastUpdated where 
  arbitrary = M.liftM ChannelIdWithLastUpdated (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelIdWithLastUpdated = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelIdWithLastUpdated{channelIdWithLastUpdated_channelId = channelIdWithLastUpdated_channelId obj} then P.Nothing else P.Just $ default_ChannelIdWithLastUpdated{channelIdWithLastUpdated_channelId = channelIdWithLastUpdated_channelId obj}
    , if obj == default_ChannelIdWithLastUpdated{channelIdWithLastUpdated_lastUpdated = channelIdWithLastUpdated_lastUpdated obj} then P.Nothing else P.Just $ default_ChannelIdWithLastUpdated{channelIdWithLastUpdated_lastUpdated = channelIdWithLastUpdated_lastUpdated obj}
    ]
from_ChannelIdWithLastUpdated :: ChannelIdWithLastUpdated -> T.ThriftVal
from_ChannelIdWithLastUpdated record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v820 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v820))) $ channelIdWithLastUpdated_channelId record
  , (\_v820 -> P.Just (2, ("lastUpdated",T.TI64 _v820))) $ channelIdWithLastUpdated_lastUpdated record
  ]
write_ChannelIdWithLastUpdated :: T.Protocol p => p -> ChannelIdWithLastUpdated -> P.IO ()
write_ChannelIdWithLastUpdated oprot record = T.writeVal oprot $ from_ChannelIdWithLastUpdated record
encode_ChannelIdWithLastUpdated :: T.StatelessProtocol p => p -> ChannelIdWithLastUpdated -> LBS.ByteString
encode_ChannelIdWithLastUpdated oprot record = T.serializeVal oprot $ from_ChannelIdWithLastUpdated record
to_ChannelIdWithLastUpdated :: T.ThriftVal -> ChannelIdWithLastUpdated
to_ChannelIdWithLastUpdated (T.TStruct fields) = ChannelIdWithLastUpdated{
  channelIdWithLastUpdated_channelId = P.maybe (channelIdWithLastUpdated_channelId default_ChannelIdWithLastUpdated) (\(_,_val822) -> (case _val822 of {T.TString _val823 -> E.decodeUtf8 _val823; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelIdWithLastUpdated_lastUpdated = P.maybe (channelIdWithLastUpdated_lastUpdated default_ChannelIdWithLastUpdated) (\(_,_val822) -> (case _val822 of {T.TI64 _val824 -> _val824; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ChannelIdWithLastUpdated _ = P.error "not a struct"
read_ChannelIdWithLastUpdated :: T.Protocol p => p -> P.IO ChannelIdWithLastUpdated
read_ChannelIdWithLastUpdated iprot = to_ChannelIdWithLastUpdated <$> T.readVal iprot (T.T_STRUCT typemap_ChannelIdWithLastUpdated)
decode_ChannelIdWithLastUpdated :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelIdWithLastUpdated
decode_ChannelIdWithLastUpdated iprot bs = to_ChannelIdWithLastUpdated $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelIdWithLastUpdated) bs
typemap_ChannelIdWithLastUpdated :: T.TypeMap
typemap_ChannelIdWithLastUpdated = Map.fromList [(1,("channelId",T.T_STRING)),(2,("lastUpdated",T.T_I64))]
default_ChannelIdWithLastUpdated :: ChannelIdWithLastUpdated
default_ChannelIdWithLastUpdated = ChannelIdWithLastUpdated{
  channelIdWithLastUpdated_channelId = "",
  channelIdWithLastUpdated_lastUpdated = 0}
data Coin = Coin  { coin_freeCoinBalance :: I.Int32
  , coin_payedCoinBalance :: I.Int32
  , coin_totalCoinBalance :: I.Int32
  , coin_rewardCoinBalance :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Coin where
  hashWithSalt salt record = salt   `H.hashWithSalt` coin_freeCoinBalance record   `H.hashWithSalt` coin_payedCoinBalance record   `H.hashWithSalt` coin_totalCoinBalance record   `H.hashWithSalt` coin_rewardCoinBalance record  
instance QC.Arbitrary Coin where 
  arbitrary = M.liftM Coin (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Coin = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Coin{coin_freeCoinBalance = coin_freeCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_freeCoinBalance = coin_freeCoinBalance obj}
    , if obj == default_Coin{coin_payedCoinBalance = coin_payedCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_payedCoinBalance = coin_payedCoinBalance obj}
    , if obj == default_Coin{coin_totalCoinBalance = coin_totalCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_totalCoinBalance = coin_totalCoinBalance obj}
    , if obj == default_Coin{coin_rewardCoinBalance = coin_rewardCoinBalance obj} then P.Nothing else P.Just $ default_Coin{coin_rewardCoinBalance = coin_rewardCoinBalance obj}
    ]
from_Coin :: Coin -> T.ThriftVal
from_Coin record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v827 -> P.Just (1, ("freeCoinBalance",T.TI32 _v827))) $ coin_freeCoinBalance record
  , (\_v827 -> P.Just (2, ("payedCoinBalance",T.TI32 _v827))) $ coin_payedCoinBalance record
  , (\_v827 -> P.Just (3, ("totalCoinBalance",T.TI32 _v827))) $ coin_totalCoinBalance record
  , (\_v827 -> P.Just (4, ("rewardCoinBalance",T.TI32 _v827))) $ coin_rewardCoinBalance record
  ]
write_Coin :: T.Protocol p => p -> Coin -> P.IO ()
write_Coin oprot record = T.writeVal oprot $ from_Coin record
encode_Coin :: T.StatelessProtocol p => p -> Coin -> LBS.ByteString
encode_Coin oprot record = T.serializeVal oprot $ from_Coin record
to_Coin :: T.ThriftVal -> Coin
to_Coin (T.TStruct fields) = Coin{
  coin_freeCoinBalance = P.maybe (coin_freeCoinBalance default_Coin) (\(_,_val829) -> (case _val829 of {T.TI32 _val830 -> _val830; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coin_payedCoinBalance = P.maybe (coin_payedCoinBalance default_Coin) (\(_,_val829) -> (case _val829 of {T.TI32 _val831 -> _val831; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coin_totalCoinBalance = P.maybe (coin_totalCoinBalance default_Coin) (\(_,_val829) -> (case _val829 of {T.TI32 _val832 -> _val832; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coin_rewardCoinBalance = P.maybe (coin_rewardCoinBalance default_Coin) (\(_,_val829) -> (case _val829 of {T.TI32 _val833 -> _val833; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Coin _ = P.error "not a struct"
read_Coin :: T.Protocol p => p -> P.IO Coin
read_Coin iprot = to_Coin <$> T.readVal iprot (T.T_STRUCT typemap_Coin)
decode_Coin :: T.StatelessProtocol p => p -> LBS.ByteString -> Coin
decode_Coin iprot bs = to_Coin $ T.deserializeVal iprot (T.T_STRUCT typemap_Coin) bs
typemap_Coin :: T.TypeMap
typemap_Coin = Map.fromList [(1,("freeCoinBalance",T.T_I32)),(2,("payedCoinBalance",T.T_I32)),(3,("totalCoinBalance",T.T_I32)),(4,("rewardCoinBalance",T.T_I32))]
default_Coin :: Coin
default_Coin = Coin{
  coin_freeCoinBalance = 0,
  coin_payedCoinBalance = 0,
  coin_totalCoinBalance = 0,
  coin_rewardCoinBalance = 0}
data CoinPayLoad = CoinPayLoad  { coinPayLoad_payCoin :: I.Int32
  , coinPayLoad_freeCoin :: I.Int32
  , coinPayLoad_type :: PayloadType
  , coinPayLoad_rewardCoin :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPayLoad where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPayLoad_payCoin record   `H.hashWithSalt` coinPayLoad_freeCoin record   `H.hashWithSalt` coinPayLoad_type record   `H.hashWithSalt` coinPayLoad_rewardCoin record  
instance QC.Arbitrary CoinPayLoad where 
  arbitrary = M.liftM CoinPayLoad (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPayLoad = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPayLoad{coinPayLoad_payCoin = coinPayLoad_payCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_payCoin = coinPayLoad_payCoin obj}
    , if obj == default_CoinPayLoad{coinPayLoad_freeCoin = coinPayLoad_freeCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_freeCoin = coinPayLoad_freeCoin obj}
    , if obj == default_CoinPayLoad{coinPayLoad_type = coinPayLoad_type obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_type = coinPayLoad_type obj}
    , if obj == default_CoinPayLoad{coinPayLoad_rewardCoin = coinPayLoad_rewardCoin obj} then P.Nothing else P.Just $ default_CoinPayLoad{coinPayLoad_rewardCoin = coinPayLoad_rewardCoin obj}
    ]
from_CoinPayLoad :: CoinPayLoad -> T.ThriftVal
from_CoinPayLoad record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v836 -> P.Just (1, ("payCoin",T.TI32 _v836))) $ coinPayLoad_payCoin record
  , (\_v836 -> P.Just (2, ("freeCoin",T.TI32 _v836))) $ coinPayLoad_freeCoin record
  , (\_v836 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v836))) $ coinPayLoad_type record
  , (\_v836 -> P.Just (4, ("rewardCoin",T.TI32 _v836))) $ coinPayLoad_rewardCoin record
  ]
write_CoinPayLoad :: T.Protocol p => p -> CoinPayLoad -> P.IO ()
write_CoinPayLoad oprot record = T.writeVal oprot $ from_CoinPayLoad record
encode_CoinPayLoad :: T.StatelessProtocol p => p -> CoinPayLoad -> LBS.ByteString
encode_CoinPayLoad oprot record = T.serializeVal oprot $ from_CoinPayLoad record
to_CoinPayLoad :: T.ThriftVal -> CoinPayLoad
to_CoinPayLoad (T.TStruct fields) = CoinPayLoad{
  coinPayLoad_payCoin = P.maybe (coinPayLoad_payCoin default_CoinPayLoad) (\(_,_val838) -> (case _val838 of {T.TI32 _val839 -> _val839; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPayLoad_freeCoin = P.maybe (coinPayLoad_freeCoin default_CoinPayLoad) (\(_,_val838) -> (case _val838 of {T.TI32 _val840 -> _val840; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPayLoad_type = P.maybe (coinPayLoad_type default_CoinPayLoad) (\(_,_val838) -> (case _val838 of {T.TI32 _val841 -> P.toEnum $ P.fromIntegral _val841; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPayLoad_rewardCoin = P.maybe (coinPayLoad_rewardCoin default_CoinPayLoad) (\(_,_val838) -> (case _val838 of {T.TI32 _val842 -> _val842; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CoinPayLoad _ = P.error "not a struct"
read_CoinPayLoad :: T.Protocol p => p -> P.IO CoinPayLoad
read_CoinPayLoad iprot = to_CoinPayLoad <$> T.readVal iprot (T.T_STRUCT typemap_CoinPayLoad)
decode_CoinPayLoad :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPayLoad
decode_CoinPayLoad iprot bs = to_CoinPayLoad $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPayLoad) bs
typemap_CoinPayLoad :: T.TypeMap
typemap_CoinPayLoad = Map.fromList [(1,("payCoin",T.T_I32)),(2,("freeCoin",T.T_I32)),(3,("type",T.T_I32)),(4,("rewardCoin",T.T_I32))]
default_CoinPayLoad :: CoinPayLoad
default_CoinPayLoad = CoinPayLoad{
  coinPayLoad_payCoin = 0,
  coinPayLoad_freeCoin = 0,
  coinPayLoad_type = (P.toEnum 0),
  coinPayLoad_rewardCoin = 0}
data CoinHistory = CoinHistory  { coinHistory_payDate :: I.Int64
  , coinHistory_coinBalance :: I.Int32
  , coinHistory_coin :: I.Int32
  , coinHistory_price :: LT.Text
  , coinHistory_title :: LT.Text
  , coinHistory_refund :: P.Bool
  , coinHistory_paySeq :: LT.Text
  , coinHistory_currency :: LT.Text
  , coinHistory_currencySign :: LT.Text
  , coinHistory_displayPrice :: LT.Text
  , coinHistory_payload :: CoinPayLoad
  , coinHistory_channelId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistory where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistory_payDate record   `H.hashWithSalt` coinHistory_coinBalance record   `H.hashWithSalt` coinHistory_coin record   `H.hashWithSalt` coinHistory_price record   `H.hashWithSalt` coinHistory_title record   `H.hashWithSalt` coinHistory_refund record   `H.hashWithSalt` coinHistory_paySeq record   `H.hashWithSalt` coinHistory_currency record   `H.hashWithSalt` coinHistory_currencySign record   `H.hashWithSalt` coinHistory_displayPrice record   `H.hashWithSalt` coinHistory_payload record   `H.hashWithSalt` coinHistory_channelId record  
instance QC.Arbitrary CoinHistory where 
  arbitrary = M.liftM CoinHistory (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistory = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistory{coinHistory_payDate = coinHistory_payDate obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_payDate = coinHistory_payDate obj}
    , if obj == default_CoinHistory{coinHistory_coinBalance = coinHistory_coinBalance obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_coinBalance = coinHistory_coinBalance obj}
    , if obj == default_CoinHistory{coinHistory_coin = coinHistory_coin obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_coin = coinHistory_coin obj}
    , if obj == default_CoinHistory{coinHistory_price = coinHistory_price obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_price = coinHistory_price obj}
    , if obj == default_CoinHistory{coinHistory_title = coinHistory_title obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_title = coinHistory_title obj}
    , if obj == default_CoinHistory{coinHistory_refund = coinHistory_refund obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_refund = coinHistory_refund obj}
    , if obj == default_CoinHistory{coinHistory_paySeq = coinHistory_paySeq obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_paySeq = coinHistory_paySeq obj}
    , if obj == default_CoinHistory{coinHistory_currency = coinHistory_currency obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_currency = coinHistory_currency obj}
    , if obj == default_CoinHistory{coinHistory_currencySign = coinHistory_currencySign obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_currencySign = coinHistory_currencySign obj}
    , if obj == default_CoinHistory{coinHistory_displayPrice = coinHistory_displayPrice obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_displayPrice = coinHistory_displayPrice obj}
    , if obj == default_CoinHistory{coinHistory_payload = coinHistory_payload obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_payload = coinHistory_payload obj}
    , if obj == default_CoinHistory{coinHistory_channelId = coinHistory_channelId obj} then P.Nothing else P.Just $ default_CoinHistory{coinHistory_channelId = coinHistory_channelId obj}
    ]
from_CoinHistory :: CoinHistory -> T.ThriftVal
from_CoinHistory record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v845 -> P.Just (1, ("payDate",T.TI64 _v845))) $ coinHistory_payDate record
  , (\_v845 -> P.Just (2, ("coinBalance",T.TI32 _v845))) $ coinHistory_coinBalance record
  , (\_v845 -> P.Just (3, ("coin",T.TI32 _v845))) $ coinHistory_coin record
  , (\_v845 -> P.Just (4, ("price",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_price record
  , (\_v845 -> P.Just (5, ("title",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_title record
  , (\_v845 -> P.Just (6, ("refund",T.TBool _v845))) $ coinHistory_refund record
  , (\_v845 -> P.Just (7, ("paySeq",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_paySeq record
  , (\_v845 -> P.Just (8, ("currency",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_currency record
  , (\_v845 -> P.Just (9, ("currencySign",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_currencySign record
  , (\_v845 -> P.Just (10, ("displayPrice",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_displayPrice record
  , (\_v845 -> P.Just (11, ("payload",from_CoinPayLoad _v845))) $ coinHistory_payload record
  , (\_v845 -> P.Just (12, ("channelId",T.TString $ E.encodeUtf8 _v845))) $ coinHistory_channelId record
  ]
write_CoinHistory :: T.Protocol p => p -> CoinHistory -> P.IO ()
write_CoinHistory oprot record = T.writeVal oprot $ from_CoinHistory record
encode_CoinHistory :: T.StatelessProtocol p => p -> CoinHistory -> LBS.ByteString
encode_CoinHistory oprot record = T.serializeVal oprot $ from_CoinHistory record
to_CoinHistory :: T.ThriftVal -> CoinHistory
to_CoinHistory (T.TStruct fields) = CoinHistory{
  coinHistory_payDate = P.maybe (coinHistory_payDate default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TI64 _val848 -> _val848; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistory_coinBalance = P.maybe (coinHistory_coinBalance default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TI32 _val849 -> _val849; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistory_coin = P.maybe (coinHistory_coin default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TI32 _val850 -> _val850; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinHistory_price = P.maybe (coinHistory_price default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val851 -> E.decodeUtf8 _val851; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinHistory_title = P.maybe (coinHistory_title default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val852 -> E.decodeUtf8 _val852; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinHistory_refund = P.maybe (coinHistory_refund default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TBool _val853 -> _val853; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinHistory_paySeq = P.maybe (coinHistory_paySeq default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val854 -> E.decodeUtf8 _val854; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinHistory_currency = P.maybe (coinHistory_currency default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val855 -> E.decodeUtf8 _val855; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  coinHistory_currencySign = P.maybe (coinHistory_currencySign default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val856 -> E.decodeUtf8 _val856; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  coinHistory_displayPrice = P.maybe (coinHistory_displayPrice default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val857 -> E.decodeUtf8 _val857; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  coinHistory_payload = P.maybe (coinHistory_payload default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TStruct _val858 -> (to_CoinPayLoad (T.TStruct _val858)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  coinHistory_channelId = P.maybe (coinHistory_channelId default_CoinHistory) (\(_,_val847) -> (case _val847 of {T.TString _val859 -> E.decodeUtf8 _val859; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_CoinHistory _ = P.error "not a struct"
read_CoinHistory :: T.Protocol p => p -> P.IO CoinHistory
read_CoinHistory iprot = to_CoinHistory <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistory)
decode_CoinHistory :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistory
decode_CoinHistory iprot bs = to_CoinHistory $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistory) bs
typemap_CoinHistory :: T.TypeMap
typemap_CoinHistory = Map.fromList [(1,("payDate",T.T_I64)),(2,("coinBalance",T.T_I32)),(3,("coin",T.T_I32)),(4,("price",T.T_STRING)),(5,("title",T.T_STRING)),(6,("refund",T.T_BOOL)),(7,("paySeq",T.T_STRING)),(8,("currency",T.T_STRING)),(9,("currencySign",T.T_STRING)),(10,("displayPrice",T.T_STRING)),(11,("payload",(T.T_STRUCT typemap_CoinPayLoad))),(12,("channelId",T.T_STRING))]
default_CoinHistory :: CoinHistory
default_CoinHistory = CoinHistory{
  coinHistory_payDate = 0,
  coinHistory_coinBalance = 0,
  coinHistory_coin = 0,
  coinHistory_price = "",
  coinHistory_title = "",
  coinHistory_refund = P.False,
  coinHistory_paySeq = "",
  coinHistory_currency = "",
  coinHistory_currencySign = "",
  coinHistory_displayPrice = "",
  coinHistory_payload = default_CoinPayLoad,
  coinHistory_channelId = ""}
data CoinHistoryCondition = CoinHistoryCondition  { coinHistoryCondition_start :: I.Int64
  , coinHistoryCondition_size :: I.Int32
  , coinHistoryCondition_language :: LT.Text
  , coinHistoryCondition_eddt :: LT.Text
  , coinHistoryCondition_appStoreCode :: PaymentType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistoryCondition where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistoryCondition_start record   `H.hashWithSalt` coinHistoryCondition_size record   `H.hashWithSalt` coinHistoryCondition_language record   `H.hashWithSalt` coinHistoryCondition_eddt record   `H.hashWithSalt` coinHistoryCondition_appStoreCode record  
instance QC.Arbitrary CoinHistoryCondition where 
  arbitrary = M.liftM CoinHistoryCondition (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistoryCondition = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistoryCondition{coinHistoryCondition_start = coinHistoryCondition_start obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_start = coinHistoryCondition_start obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_size = coinHistoryCondition_size obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_size = coinHistoryCondition_size obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_language = coinHistoryCondition_language obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_language = coinHistoryCondition_language obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_eddt = coinHistoryCondition_eddt obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_eddt = coinHistoryCondition_eddt obj}
    , if obj == default_CoinHistoryCondition{coinHistoryCondition_appStoreCode = coinHistoryCondition_appStoreCode obj} then P.Nothing else P.Just $ default_CoinHistoryCondition{coinHistoryCondition_appStoreCode = coinHistoryCondition_appStoreCode obj}
    ]
from_CoinHistoryCondition :: CoinHistoryCondition -> T.ThriftVal
from_CoinHistoryCondition record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v862 -> P.Just (1, ("start",T.TI64 _v862))) $ coinHistoryCondition_start record
  , (\_v862 -> P.Just (2, ("size",T.TI32 _v862))) $ coinHistoryCondition_size record
  , (\_v862 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v862))) $ coinHistoryCondition_language record
  , (\_v862 -> P.Just (4, ("eddt",T.TString $ E.encodeUtf8 _v862))) $ coinHistoryCondition_eddt record
  , (\_v862 -> P.Just (5, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v862))) $ coinHistoryCondition_appStoreCode record
  ]
write_CoinHistoryCondition :: T.Protocol p => p -> CoinHistoryCondition -> P.IO ()
write_CoinHistoryCondition oprot record = T.writeVal oprot $ from_CoinHistoryCondition record
encode_CoinHistoryCondition :: T.StatelessProtocol p => p -> CoinHistoryCondition -> LBS.ByteString
encode_CoinHistoryCondition oprot record = T.serializeVal oprot $ from_CoinHistoryCondition record
to_CoinHistoryCondition :: T.ThriftVal -> CoinHistoryCondition
to_CoinHistoryCondition (T.TStruct fields) = CoinHistoryCondition{
  coinHistoryCondition_start = P.maybe (coinHistoryCondition_start default_CoinHistoryCondition) (\(_,_val864) -> (case _val864 of {T.TI64 _val865 -> _val865; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistoryCondition_size = P.maybe (coinHistoryCondition_size default_CoinHistoryCondition) (\(_,_val864) -> (case _val864 of {T.TI32 _val866 -> _val866; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistoryCondition_language = P.maybe (coinHistoryCondition_language default_CoinHistoryCondition) (\(_,_val864) -> (case _val864 of {T.TString _val867 -> E.decodeUtf8 _val867; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinHistoryCondition_eddt = P.maybe (coinHistoryCondition_eddt default_CoinHistoryCondition) (\(_,_val864) -> (case _val864 of {T.TString _val868 -> E.decodeUtf8 _val868; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinHistoryCondition_appStoreCode = P.maybe (coinHistoryCondition_appStoreCode default_CoinHistoryCondition) (\(_,_val864) -> (case _val864 of {T.TI32 _val869 -> P.toEnum $ P.fromIntegral _val869; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CoinHistoryCondition _ = P.error "not a struct"
read_CoinHistoryCondition :: T.Protocol p => p -> P.IO CoinHistoryCondition
read_CoinHistoryCondition iprot = to_CoinHistoryCondition <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistoryCondition)
decode_CoinHistoryCondition :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistoryCondition
decode_CoinHistoryCondition iprot bs = to_CoinHistoryCondition $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistoryCondition) bs
typemap_CoinHistoryCondition :: T.TypeMap
typemap_CoinHistoryCondition = Map.fromList [(1,("start",T.T_I64)),(2,("size",T.T_I32)),(3,("language",T.T_STRING)),(4,("eddt",T.T_STRING)),(5,("appStoreCode",T.T_I32))]
default_CoinHistoryCondition :: CoinHistoryCondition
default_CoinHistoryCondition = CoinHistoryCondition{
  coinHistoryCondition_start = 0,
  coinHistoryCondition_size = 0,
  coinHistoryCondition_language = "",
  coinHistoryCondition_eddt = "",
  coinHistoryCondition_appStoreCode = (P.toEnum 0)}
data CoinHistoryResult = CoinHistoryResult  { coinHistoryResult_historys :: (Vector.Vector CoinHistory)
  , coinHistoryResult_balance :: Coin
  , coinHistoryResult_hasNext :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinHistoryResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinHistoryResult_historys record   `H.hashWithSalt` coinHistoryResult_balance record   `H.hashWithSalt` coinHistoryResult_hasNext record  
instance QC.Arbitrary CoinHistoryResult where 
  arbitrary = M.liftM CoinHistoryResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinHistoryResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinHistoryResult{coinHistoryResult_historys = coinHistoryResult_historys obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_historys = coinHistoryResult_historys obj}
    , if obj == default_CoinHistoryResult{coinHistoryResult_balance = coinHistoryResult_balance obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_balance = coinHistoryResult_balance obj}
    , if obj == default_CoinHistoryResult{coinHistoryResult_hasNext = coinHistoryResult_hasNext obj} then P.Nothing else P.Just $ default_CoinHistoryResult{coinHistoryResult_hasNext = coinHistoryResult_hasNext obj}
    ]
from_CoinHistoryResult :: CoinHistoryResult -> T.ThriftVal
from_CoinHistoryResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v872 -> P.Just (1, ("historys",T.TList (T.T_STRUCT typemap_CoinHistory) $ P.map (\_v874 -> from_CoinHistory _v874) $ Vector.toList _v872))) $ coinHistoryResult_historys record
  , (\_v872 -> P.Just (2, ("balance",from_Coin _v872))) $ coinHistoryResult_balance record
  , (\_v872 -> P.Just (3, ("hasNext",T.TBool _v872))) $ coinHistoryResult_hasNext record
  ]
write_CoinHistoryResult :: T.Protocol p => p -> CoinHistoryResult -> P.IO ()
write_CoinHistoryResult oprot record = T.writeVal oprot $ from_CoinHistoryResult record
encode_CoinHistoryResult :: T.StatelessProtocol p => p -> CoinHistoryResult -> LBS.ByteString
encode_CoinHistoryResult oprot record = T.serializeVal oprot $ from_CoinHistoryResult record
to_CoinHistoryResult :: T.ThriftVal -> CoinHistoryResult
to_CoinHistoryResult (T.TStruct fields) = CoinHistoryResult{
  coinHistoryResult_historys = P.maybe (coinHistoryResult_historys default_CoinHistoryResult) (\(_,_val876) -> (case _val876 of {T.TList _ _val877 -> (Vector.fromList $ P.map (\_v878 -> (case _v878 of {T.TStruct _val879 -> (to_CoinHistory (T.TStruct _val879)); _ -> P.error "wrong type"})) _val877); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinHistoryResult_balance = P.maybe (coinHistoryResult_balance default_CoinHistoryResult) (\(_,_val876) -> (case _val876 of {T.TStruct _val880 -> (to_Coin (T.TStruct _val880)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinHistoryResult_hasNext = P.maybe (coinHistoryResult_hasNext default_CoinHistoryResult) (\(_,_val876) -> (case _val876 of {T.TBool _val881 -> _val881; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CoinHistoryResult _ = P.error "not a struct"
read_CoinHistoryResult :: T.Protocol p => p -> P.IO CoinHistoryResult
read_CoinHistoryResult iprot = to_CoinHistoryResult <$> T.readVal iprot (T.T_STRUCT typemap_CoinHistoryResult)
decode_CoinHistoryResult :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinHistoryResult
decode_CoinHistoryResult iprot bs = to_CoinHistoryResult $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinHistoryResult) bs
typemap_CoinHistoryResult :: T.TypeMap
typemap_CoinHistoryResult = Map.fromList [(1,("historys",(T.T_LIST (T.T_STRUCT typemap_CoinHistory)))),(2,("balance",(T.T_STRUCT typemap_Coin))),(3,("hasNext",T.T_BOOL))]
default_CoinHistoryResult :: CoinHistoryResult
default_CoinHistoryResult = CoinHistoryResult{
  coinHistoryResult_historys = Vector.empty,
  coinHistoryResult_balance = default_Coin,
  coinHistoryResult_hasNext = P.False}
data CoinProductItem = CoinProductItem  { coinProductItem_itemId :: LT.Text
  , coinProductItem_coin :: I.Int32
  , coinProductItem_freeCoin :: I.Int32
  , coinProductItem_currency :: LT.Text
  , coinProductItem_price :: LT.Text
  , coinProductItem_displayPrice :: LT.Text
  , coinProductItem_name :: LT.Text
  , coinProductItem_desc :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinProductItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinProductItem_itemId record   `H.hashWithSalt` coinProductItem_coin record   `H.hashWithSalt` coinProductItem_freeCoin record   `H.hashWithSalt` coinProductItem_currency record   `H.hashWithSalt` coinProductItem_price record   `H.hashWithSalt` coinProductItem_displayPrice record   `H.hashWithSalt` coinProductItem_name record   `H.hashWithSalt` coinProductItem_desc record  
instance QC.Arbitrary CoinProductItem where 
  arbitrary = M.liftM CoinProductItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinProductItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinProductItem{coinProductItem_itemId = coinProductItem_itemId obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_itemId = coinProductItem_itemId obj}
    , if obj == default_CoinProductItem{coinProductItem_coin = coinProductItem_coin obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_coin = coinProductItem_coin obj}
    , if obj == default_CoinProductItem{coinProductItem_freeCoin = coinProductItem_freeCoin obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_freeCoin = coinProductItem_freeCoin obj}
    , if obj == default_CoinProductItem{coinProductItem_currency = coinProductItem_currency obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_currency = coinProductItem_currency obj}
    , if obj == default_CoinProductItem{coinProductItem_price = coinProductItem_price obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_price = coinProductItem_price obj}
    , if obj == default_CoinProductItem{coinProductItem_displayPrice = coinProductItem_displayPrice obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_displayPrice = coinProductItem_displayPrice obj}
    , if obj == default_CoinProductItem{coinProductItem_name = coinProductItem_name obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_name = coinProductItem_name obj}
    , if obj == default_CoinProductItem{coinProductItem_desc = coinProductItem_desc obj} then P.Nothing else P.Just $ default_CoinProductItem{coinProductItem_desc = coinProductItem_desc obj}
    ]
from_CoinProductItem :: CoinProductItem -> T.ThriftVal
from_CoinProductItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v884 -> P.Just (1, ("itemId",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_itemId record
  , (\_v884 -> P.Just (2, ("coin",T.TI32 _v884))) $ coinProductItem_coin record
  , (\_v884 -> P.Just (3, ("freeCoin",T.TI32 _v884))) $ coinProductItem_freeCoin record
  , (\_v884 -> P.Just (5, ("currency",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_currency record
  , (\_v884 -> P.Just (6, ("price",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_price record
  , (\_v884 -> P.Just (7, ("displayPrice",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_displayPrice record
  , (\_v884 -> P.Just (8, ("name",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_name record
  , (\_v884 -> P.Just (9, ("desc",T.TString $ E.encodeUtf8 _v884))) $ coinProductItem_desc record
  ]
write_CoinProductItem :: T.Protocol p => p -> CoinProductItem -> P.IO ()
write_CoinProductItem oprot record = T.writeVal oprot $ from_CoinProductItem record
encode_CoinProductItem :: T.StatelessProtocol p => p -> CoinProductItem -> LBS.ByteString
encode_CoinProductItem oprot record = T.serializeVal oprot $ from_CoinProductItem record
to_CoinProductItem :: T.ThriftVal -> CoinProductItem
to_CoinProductItem (T.TStruct fields) = CoinProductItem{
  coinProductItem_itemId = P.maybe (coinProductItem_itemId default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val887 -> E.decodeUtf8 _val887; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinProductItem_coin = P.maybe (coinProductItem_coin default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TI32 _val888 -> _val888; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinProductItem_freeCoin = P.maybe (coinProductItem_freeCoin default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TI32 _val889 -> _val889; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinProductItem_currency = P.maybe (coinProductItem_currency default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val890 -> E.decodeUtf8 _val890; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinProductItem_price = P.maybe (coinProductItem_price default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val891 -> E.decodeUtf8 _val891; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinProductItem_displayPrice = P.maybe (coinProductItem_displayPrice default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val892 -> E.decodeUtf8 _val892; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinProductItem_name = P.maybe (coinProductItem_name default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val893 -> E.decodeUtf8 _val893; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  coinProductItem_desc = P.maybe (coinProductItem_desc default_CoinProductItem) (\(_,_val886) -> (case _val886 of {T.TString _val894 -> E.decodeUtf8 _val894; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_CoinProductItem _ = P.error "not a struct"
read_CoinProductItem :: T.Protocol p => p -> P.IO CoinProductItem
read_CoinProductItem iprot = to_CoinProductItem <$> T.readVal iprot (T.T_STRUCT typemap_CoinProductItem)
decode_CoinProductItem :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinProductItem
decode_CoinProductItem iprot bs = to_CoinProductItem $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinProductItem) bs
typemap_CoinProductItem :: T.TypeMap
typemap_CoinProductItem = Map.fromList [(1,("itemId",T.T_STRING)),(2,("coin",T.T_I32)),(3,("freeCoin",T.T_I32)),(5,("currency",T.T_STRING)),(6,("price",T.T_STRING)),(7,("displayPrice",T.T_STRING)),(8,("name",T.T_STRING)),(9,("desc",T.T_STRING))]
default_CoinProductItem :: CoinProductItem
default_CoinProductItem = CoinProductItem{
  coinProductItem_itemId = "",
  coinProductItem_coin = 0,
  coinProductItem_freeCoin = 0,
  coinProductItem_currency = "",
  coinProductItem_price = "",
  coinProductItem_displayPrice = "",
  coinProductItem_name = "",
  coinProductItem_desc = ""}
data CoinPurchaseConfirm = CoinPurchaseConfirm  { coinPurchaseConfirm_orderId :: LT.Text
  , coinPurchaseConfirm_appStoreCode :: PaymentType
  , coinPurchaseConfirm_receipt :: LT.Text
  , coinPurchaseConfirm_signature :: LT.Text
  , coinPurchaseConfirm_seller :: LT.Text
  , coinPurchaseConfirm_requestType :: LT.Text
  , coinPurchaseConfirm_ignoreReceipt :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPurchaseConfirm where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPurchaseConfirm_orderId record   `H.hashWithSalt` coinPurchaseConfirm_appStoreCode record   `H.hashWithSalt` coinPurchaseConfirm_receipt record   `H.hashWithSalt` coinPurchaseConfirm_signature record   `H.hashWithSalt` coinPurchaseConfirm_seller record   `H.hashWithSalt` coinPurchaseConfirm_requestType record   `H.hashWithSalt` coinPurchaseConfirm_ignoreReceipt record  
instance QC.Arbitrary CoinPurchaseConfirm where 
  arbitrary = M.liftM CoinPurchaseConfirm (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPurchaseConfirm = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_orderId = coinPurchaseConfirm_orderId obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_orderId = coinPurchaseConfirm_orderId obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_appStoreCode = coinPurchaseConfirm_appStoreCode obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_appStoreCode = coinPurchaseConfirm_appStoreCode obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_receipt = coinPurchaseConfirm_receipt obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_receipt = coinPurchaseConfirm_receipt obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_signature = coinPurchaseConfirm_signature obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_signature = coinPurchaseConfirm_signature obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_seller = coinPurchaseConfirm_seller obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_seller = coinPurchaseConfirm_seller obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_requestType = coinPurchaseConfirm_requestType obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_requestType = coinPurchaseConfirm_requestType obj}
    , if obj == default_CoinPurchaseConfirm{coinPurchaseConfirm_ignoreReceipt = coinPurchaseConfirm_ignoreReceipt obj} then P.Nothing else P.Just $ default_CoinPurchaseConfirm{coinPurchaseConfirm_ignoreReceipt = coinPurchaseConfirm_ignoreReceipt obj}
    ]
from_CoinPurchaseConfirm :: CoinPurchaseConfirm -> T.ThriftVal
from_CoinPurchaseConfirm record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v897 -> P.Just (1, ("orderId",T.TString $ E.encodeUtf8 _v897))) $ coinPurchaseConfirm_orderId record
  , (\_v897 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v897))) $ coinPurchaseConfirm_appStoreCode record
  , (\_v897 -> P.Just (3, ("receipt",T.TString $ E.encodeUtf8 _v897))) $ coinPurchaseConfirm_receipt record
  , (\_v897 -> P.Just (4, ("signature",T.TString $ E.encodeUtf8 _v897))) $ coinPurchaseConfirm_signature record
  , (\_v897 -> P.Just (5, ("seller",T.TString $ E.encodeUtf8 _v897))) $ coinPurchaseConfirm_seller record
  , (\_v897 -> P.Just (6, ("requestType",T.TString $ E.encodeUtf8 _v897))) $ coinPurchaseConfirm_requestType record
  , (\_v897 -> P.Just (7, ("ignoreReceipt",T.TBool _v897))) $ coinPurchaseConfirm_ignoreReceipt record
  ]
write_CoinPurchaseConfirm :: T.Protocol p => p -> CoinPurchaseConfirm -> P.IO ()
write_CoinPurchaseConfirm oprot record = T.writeVal oprot $ from_CoinPurchaseConfirm record
encode_CoinPurchaseConfirm :: T.StatelessProtocol p => p -> CoinPurchaseConfirm -> LBS.ByteString
encode_CoinPurchaseConfirm oprot record = T.serializeVal oprot $ from_CoinPurchaseConfirm record
to_CoinPurchaseConfirm :: T.ThriftVal -> CoinPurchaseConfirm
to_CoinPurchaseConfirm (T.TStruct fields) = CoinPurchaseConfirm{
  coinPurchaseConfirm_orderId = P.maybe (coinPurchaseConfirm_orderId default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TString _val900 -> E.decodeUtf8 _val900; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPurchaseConfirm_appStoreCode = P.maybe (coinPurchaseConfirm_appStoreCode default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TI32 _val901 -> P.toEnum $ P.fromIntegral _val901; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPurchaseConfirm_receipt = P.maybe (coinPurchaseConfirm_receipt default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TString _val902 -> E.decodeUtf8 _val902; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPurchaseConfirm_signature = P.maybe (coinPurchaseConfirm_signature default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TString _val903 -> E.decodeUtf8 _val903; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinPurchaseConfirm_seller = P.maybe (coinPurchaseConfirm_seller default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TString _val904 -> E.decodeUtf8 _val904; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinPurchaseConfirm_requestType = P.maybe (coinPurchaseConfirm_requestType default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TString _val905 -> E.decodeUtf8 _val905; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinPurchaseConfirm_ignoreReceipt = P.maybe (coinPurchaseConfirm_ignoreReceipt default_CoinPurchaseConfirm) (\(_,_val899) -> (case _val899 of {T.TBool _val906 -> _val906; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_CoinPurchaseConfirm _ = P.error "not a struct"
read_CoinPurchaseConfirm :: T.Protocol p => p -> P.IO CoinPurchaseConfirm
read_CoinPurchaseConfirm iprot = to_CoinPurchaseConfirm <$> T.readVal iprot (T.T_STRUCT typemap_CoinPurchaseConfirm)
decode_CoinPurchaseConfirm :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPurchaseConfirm
decode_CoinPurchaseConfirm iprot bs = to_CoinPurchaseConfirm $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPurchaseConfirm) bs
typemap_CoinPurchaseConfirm :: T.TypeMap
typemap_CoinPurchaseConfirm = Map.fromList [(1,("orderId",T.T_STRING)),(2,("appStoreCode",T.T_I32)),(3,("receipt",T.T_STRING)),(4,("signature",T.T_STRING)),(5,("seller",T.T_STRING)),(6,("requestType",T.T_STRING)),(7,("ignoreReceipt",T.T_BOOL))]
default_CoinPurchaseConfirm :: CoinPurchaseConfirm
default_CoinPurchaseConfirm = CoinPurchaseConfirm{
  coinPurchaseConfirm_orderId = "",
  coinPurchaseConfirm_appStoreCode = (P.toEnum 0),
  coinPurchaseConfirm_receipt = "",
  coinPurchaseConfirm_signature = "",
  coinPurchaseConfirm_seller = "",
  coinPurchaseConfirm_requestType = "",
  coinPurchaseConfirm_ignoreReceipt = P.False}
data CoinPurchaseReservation = CoinPurchaseReservation  { coinPurchaseReservation_productId :: LT.Text
  , coinPurchaseReservation_country :: LT.Text
  , coinPurchaseReservation_currency :: LT.Text
  , coinPurchaseReservation_price :: LT.Text
  , coinPurchaseReservation_appStoreCode :: PaymentType
  , coinPurchaseReservation_language :: LT.Text
  , coinPurchaseReservation_pgCode :: PaymentPgType
  , coinPurchaseReservation_redirectUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinPurchaseReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinPurchaseReservation_productId record   `H.hashWithSalt` coinPurchaseReservation_country record   `H.hashWithSalt` coinPurchaseReservation_currency record   `H.hashWithSalt` coinPurchaseReservation_price record   `H.hashWithSalt` coinPurchaseReservation_appStoreCode record   `H.hashWithSalt` coinPurchaseReservation_language record   `H.hashWithSalt` coinPurchaseReservation_pgCode record   `H.hashWithSalt` coinPurchaseReservation_redirectUrl record  
instance QC.Arbitrary CoinPurchaseReservation where 
  arbitrary = M.liftM CoinPurchaseReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinPurchaseReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinPurchaseReservation{coinPurchaseReservation_productId = coinPurchaseReservation_productId obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_productId = coinPurchaseReservation_productId obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_country = coinPurchaseReservation_country obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_country = coinPurchaseReservation_country obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_currency = coinPurchaseReservation_currency obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_currency = coinPurchaseReservation_currency obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_price = coinPurchaseReservation_price obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_price = coinPurchaseReservation_price obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_appStoreCode = coinPurchaseReservation_appStoreCode obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_appStoreCode = coinPurchaseReservation_appStoreCode obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_language = coinPurchaseReservation_language obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_language = coinPurchaseReservation_language obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_pgCode = coinPurchaseReservation_pgCode obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_pgCode = coinPurchaseReservation_pgCode obj}
    , if obj == default_CoinPurchaseReservation{coinPurchaseReservation_redirectUrl = coinPurchaseReservation_redirectUrl obj} then P.Nothing else P.Just $ default_CoinPurchaseReservation{coinPurchaseReservation_redirectUrl = coinPurchaseReservation_redirectUrl obj}
    ]
from_CoinPurchaseReservation :: CoinPurchaseReservation -> T.ThriftVal
from_CoinPurchaseReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v909 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_productId record
  , (\_v909 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_country record
  , (\_v909 -> P.Just (3, ("currency",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_currency record
  , (\_v909 -> P.Just (4, ("price",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_price record
  , (\_v909 -> P.Just (5, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v909))) $ coinPurchaseReservation_appStoreCode record
  , (\_v909 -> P.Just (6, ("language",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_language record
  , (\_v909 -> P.Just (7, ("pgCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v909))) $ coinPurchaseReservation_pgCode record
  , (\_v909 -> P.Just (8, ("redirectUrl",T.TString $ E.encodeUtf8 _v909))) $ coinPurchaseReservation_redirectUrl record
  ]
write_CoinPurchaseReservation :: T.Protocol p => p -> CoinPurchaseReservation -> P.IO ()
write_CoinPurchaseReservation oprot record = T.writeVal oprot $ from_CoinPurchaseReservation record
encode_CoinPurchaseReservation :: T.StatelessProtocol p => p -> CoinPurchaseReservation -> LBS.ByteString
encode_CoinPurchaseReservation oprot record = T.serializeVal oprot $ from_CoinPurchaseReservation record
to_CoinPurchaseReservation :: T.ThriftVal -> CoinPurchaseReservation
to_CoinPurchaseReservation (T.TStruct fields) = CoinPurchaseReservation{
  coinPurchaseReservation_productId = P.maybe (coinPurchaseReservation_productId default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val912 -> E.decodeUtf8 _val912; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinPurchaseReservation_country = P.maybe (coinPurchaseReservation_country default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val913 -> E.decodeUtf8 _val913; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinPurchaseReservation_currency = P.maybe (coinPurchaseReservation_currency default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val914 -> E.decodeUtf8 _val914; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinPurchaseReservation_price = P.maybe (coinPurchaseReservation_price default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val915 -> E.decodeUtf8 _val915; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinPurchaseReservation_appStoreCode = P.maybe (coinPurchaseReservation_appStoreCode default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TI32 _val916 -> P.toEnum $ P.fromIntegral _val916; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  coinPurchaseReservation_language = P.maybe (coinPurchaseReservation_language default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val917 -> E.decodeUtf8 _val917; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  coinPurchaseReservation_pgCode = P.maybe (coinPurchaseReservation_pgCode default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TI32 _val918 -> P.toEnum $ P.fromIntegral _val918; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  coinPurchaseReservation_redirectUrl = P.maybe (coinPurchaseReservation_redirectUrl default_CoinPurchaseReservation) (\(_,_val911) -> (case _val911 of {T.TString _val919 -> E.decodeUtf8 _val919; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_CoinPurchaseReservation _ = P.error "not a struct"
read_CoinPurchaseReservation :: T.Protocol p => p -> P.IO CoinPurchaseReservation
read_CoinPurchaseReservation iprot = to_CoinPurchaseReservation <$> T.readVal iprot (T.T_STRUCT typemap_CoinPurchaseReservation)
decode_CoinPurchaseReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinPurchaseReservation
decode_CoinPurchaseReservation iprot bs = to_CoinPurchaseReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinPurchaseReservation) bs
typemap_CoinPurchaseReservation :: T.TypeMap
typemap_CoinPurchaseReservation = Map.fromList [(1,("productId",T.T_STRING)),(2,("country",T.T_STRING)),(3,("currency",T.T_STRING)),(4,("price",T.T_STRING)),(5,("appStoreCode",T.T_I32)),(6,("language",T.T_STRING)),(7,("pgCode",T.T_I32)),(8,("redirectUrl",T.T_STRING))]
default_CoinPurchaseReservation :: CoinPurchaseReservation
default_CoinPurchaseReservation = CoinPurchaseReservation{
  coinPurchaseReservation_productId = "",
  coinPurchaseReservation_country = "",
  coinPurchaseReservation_currency = "",
  coinPurchaseReservation_price = "",
  coinPurchaseReservation_appStoreCode = (P.toEnum 0),
  coinPurchaseReservation_language = "",
  coinPurchaseReservation_pgCode = (P.toEnum 0),
  coinPurchaseReservation_redirectUrl = ""}
data CoinUseReservationItem = CoinUseReservationItem  { coinUseReservationItem_itemId :: LT.Text
  , coinUseReservationItem_itemName :: LT.Text
  , coinUseReservationItem_amount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinUseReservationItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinUseReservationItem_itemId record   `H.hashWithSalt` coinUseReservationItem_itemName record   `H.hashWithSalt` coinUseReservationItem_amount record  
instance QC.Arbitrary CoinUseReservationItem where 
  arbitrary = M.liftM CoinUseReservationItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinUseReservationItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinUseReservationItem{coinUseReservationItem_itemId = coinUseReservationItem_itemId obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_itemId = coinUseReservationItem_itemId obj}
    , if obj == default_CoinUseReservationItem{coinUseReservationItem_itemName = coinUseReservationItem_itemName obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_itemName = coinUseReservationItem_itemName obj}
    , if obj == default_CoinUseReservationItem{coinUseReservationItem_amount = coinUseReservationItem_amount obj} then P.Nothing else P.Just $ default_CoinUseReservationItem{coinUseReservationItem_amount = coinUseReservationItem_amount obj}
    ]
from_CoinUseReservationItem :: CoinUseReservationItem -> T.ThriftVal
from_CoinUseReservationItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v922 -> P.Just (1, ("itemId",T.TString $ E.encodeUtf8 _v922))) $ coinUseReservationItem_itemId record
  , (\_v922 -> P.Just (2, ("itemName",T.TString $ E.encodeUtf8 _v922))) $ coinUseReservationItem_itemName record
  , (\_v922 -> P.Just (3, ("amount",T.TI32 _v922))) $ coinUseReservationItem_amount record
  ]
write_CoinUseReservationItem :: T.Protocol p => p -> CoinUseReservationItem -> P.IO ()
write_CoinUseReservationItem oprot record = T.writeVal oprot $ from_CoinUseReservationItem record
encode_CoinUseReservationItem :: T.StatelessProtocol p => p -> CoinUseReservationItem -> LBS.ByteString
encode_CoinUseReservationItem oprot record = T.serializeVal oprot $ from_CoinUseReservationItem record
to_CoinUseReservationItem :: T.ThriftVal -> CoinUseReservationItem
to_CoinUseReservationItem (T.TStruct fields) = CoinUseReservationItem{
  coinUseReservationItem_itemId = P.maybe (coinUseReservationItem_itemId default_CoinUseReservationItem) (\(_,_val924) -> (case _val924 of {T.TString _val925 -> E.decodeUtf8 _val925; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinUseReservationItem_itemName = P.maybe (coinUseReservationItem_itemName default_CoinUseReservationItem) (\(_,_val924) -> (case _val924 of {T.TString _val926 -> E.decodeUtf8 _val926; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinUseReservationItem_amount = P.maybe (coinUseReservationItem_amount default_CoinUseReservationItem) (\(_,_val924) -> (case _val924 of {T.TI32 _val927 -> _val927; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CoinUseReservationItem _ = P.error "not a struct"
read_CoinUseReservationItem :: T.Protocol p => p -> P.IO CoinUseReservationItem
read_CoinUseReservationItem iprot = to_CoinUseReservationItem <$> T.readVal iprot (T.T_STRUCT typemap_CoinUseReservationItem)
decode_CoinUseReservationItem :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinUseReservationItem
decode_CoinUseReservationItem iprot bs = to_CoinUseReservationItem $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinUseReservationItem) bs
typemap_CoinUseReservationItem :: T.TypeMap
typemap_CoinUseReservationItem = Map.fromList [(1,("itemId",T.T_STRING)),(2,("itemName",T.T_STRING)),(3,("amount",T.T_I32))]
default_CoinUseReservationItem :: CoinUseReservationItem
default_CoinUseReservationItem = CoinUseReservationItem{
  coinUseReservationItem_itemId = "",
  coinUseReservationItem_itemName = "",
  coinUseReservationItem_amount = 0}
data CoinUseReservation = CoinUseReservation  { coinUseReservation_channelId :: LT.Text
  , coinUseReservation_shopOrderId :: LT.Text
  , coinUseReservation_appStoreCode :: PaymentType
  , coinUseReservation_items :: (Vector.Vector CoinUseReservationItem)
  , coinUseReservation_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CoinUseReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` coinUseReservation_channelId record   `H.hashWithSalt` coinUseReservation_shopOrderId record   `H.hashWithSalt` coinUseReservation_appStoreCode record   `H.hashWithSalt` coinUseReservation_items record   `H.hashWithSalt` coinUseReservation_country record  
instance QC.Arbitrary CoinUseReservation where 
  arbitrary = M.liftM CoinUseReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CoinUseReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CoinUseReservation{coinUseReservation_channelId = coinUseReservation_channelId obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_channelId = coinUseReservation_channelId obj}
    , if obj == default_CoinUseReservation{coinUseReservation_shopOrderId = coinUseReservation_shopOrderId obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_shopOrderId = coinUseReservation_shopOrderId obj}
    , if obj == default_CoinUseReservation{coinUseReservation_appStoreCode = coinUseReservation_appStoreCode obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_appStoreCode = coinUseReservation_appStoreCode obj}
    , if obj == default_CoinUseReservation{coinUseReservation_items = coinUseReservation_items obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_items = coinUseReservation_items obj}
    , if obj == default_CoinUseReservation{coinUseReservation_country = coinUseReservation_country obj} then P.Nothing else P.Just $ default_CoinUseReservation{coinUseReservation_country = coinUseReservation_country obj}
    ]
from_CoinUseReservation :: CoinUseReservation -> T.ThriftVal
from_CoinUseReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v930 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v930))) $ coinUseReservation_channelId record
  , (\_v930 -> P.Just (2, ("shopOrderId",T.TString $ E.encodeUtf8 _v930))) $ coinUseReservation_shopOrderId record
  , (\_v930 -> P.Just (3, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v930))) $ coinUseReservation_appStoreCode record
  , (\_v930 -> P.Just (4, ("items",T.TList (T.T_STRUCT typemap_CoinUseReservationItem) $ P.map (\_v932 -> from_CoinUseReservationItem _v932) $ Vector.toList _v930))) $ coinUseReservation_items record
  , (\_v930 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v930))) $ coinUseReservation_country record
  ]
write_CoinUseReservation :: T.Protocol p => p -> CoinUseReservation -> P.IO ()
write_CoinUseReservation oprot record = T.writeVal oprot $ from_CoinUseReservation record
encode_CoinUseReservation :: T.StatelessProtocol p => p -> CoinUseReservation -> LBS.ByteString
encode_CoinUseReservation oprot record = T.serializeVal oprot $ from_CoinUseReservation record
to_CoinUseReservation :: T.ThriftVal -> CoinUseReservation
to_CoinUseReservation (T.TStruct fields) = CoinUseReservation{
  coinUseReservation_channelId = P.maybe (coinUseReservation_channelId default_CoinUseReservation) (\(_,_val934) -> (case _val934 of {T.TString _val935 -> E.decodeUtf8 _val935; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  coinUseReservation_shopOrderId = P.maybe (coinUseReservation_shopOrderId default_CoinUseReservation) (\(_,_val934) -> (case _val934 of {T.TString _val936 -> E.decodeUtf8 _val936; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  coinUseReservation_appStoreCode = P.maybe (coinUseReservation_appStoreCode default_CoinUseReservation) (\(_,_val934) -> (case _val934 of {T.TI32 _val937 -> P.toEnum $ P.fromIntegral _val937; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  coinUseReservation_items = P.maybe (coinUseReservation_items default_CoinUseReservation) (\(_,_val934) -> (case _val934 of {T.TList _ _val938 -> (Vector.fromList $ P.map (\_v939 -> (case _v939 of {T.TStruct _val940 -> (to_CoinUseReservationItem (T.TStruct _val940)); _ -> P.error "wrong type"})) _val938); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  coinUseReservation_country = P.maybe (coinUseReservation_country default_CoinUseReservation) (\(_,_val934) -> (case _val934 of {T.TString _val941 -> E.decodeUtf8 _val941; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CoinUseReservation _ = P.error "not a struct"
read_CoinUseReservation :: T.Protocol p => p -> P.IO CoinUseReservation
read_CoinUseReservation iprot = to_CoinUseReservation <$> T.readVal iprot (T.T_STRUCT typemap_CoinUseReservation)
decode_CoinUseReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> CoinUseReservation
decode_CoinUseReservation iprot bs = to_CoinUseReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_CoinUseReservation) bs
typemap_CoinUseReservation :: T.TypeMap
typemap_CoinUseReservation = Map.fromList [(1,("channelId",T.T_STRING)),(2,("shopOrderId",T.T_STRING)),(3,("appStoreCode",T.T_I32)),(4,("items",(T.T_LIST (T.T_STRUCT typemap_CoinUseReservationItem)))),(5,("country",T.T_STRING))]
default_CoinUseReservation :: CoinUseReservation
default_CoinUseReservation = CoinUseReservation{
  coinUseReservation_channelId = "",
  coinUseReservation_shopOrderId = "",
  coinUseReservation_appStoreCode = (P.toEnum 0),
  coinUseReservation_items = Vector.empty,
  coinUseReservation_country = ""}
data CompactContact = CompactContact  { compactContact_mid :: LT.Text
  , compactContact_createdTime :: I.Int64
  , compactContact_modifiedTime :: I.Int64
  , compactContact_status :: ContactStatus
  , compactContact_settings :: I.Int64
  , compactContact_displayNameOverridden :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CompactContact where
  hashWithSalt salt record = salt   `H.hashWithSalt` compactContact_mid record   `H.hashWithSalt` compactContact_createdTime record   `H.hashWithSalt` compactContact_modifiedTime record   `H.hashWithSalt` compactContact_status record   `H.hashWithSalt` compactContact_settings record   `H.hashWithSalt` compactContact_displayNameOverridden record  
instance QC.Arbitrary CompactContact where 
  arbitrary = M.liftM CompactContact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CompactContact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CompactContact{compactContact_mid = compactContact_mid obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_mid = compactContact_mid obj}
    , if obj == default_CompactContact{compactContact_createdTime = compactContact_createdTime obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_createdTime = compactContact_createdTime obj}
    , if obj == default_CompactContact{compactContact_modifiedTime = compactContact_modifiedTime obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_modifiedTime = compactContact_modifiedTime obj}
    , if obj == default_CompactContact{compactContact_status = compactContact_status obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_status = compactContact_status obj}
    , if obj == default_CompactContact{compactContact_settings = compactContact_settings obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_settings = compactContact_settings obj}
    , if obj == default_CompactContact{compactContact_displayNameOverridden = compactContact_displayNameOverridden obj} then P.Nothing else P.Just $ default_CompactContact{compactContact_displayNameOverridden = compactContact_displayNameOverridden obj}
    ]
from_CompactContact :: CompactContact -> T.ThriftVal
from_CompactContact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v944 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v944))) $ compactContact_mid record
  , (\_v944 -> P.Just (2, ("createdTime",T.TI64 _v944))) $ compactContact_createdTime record
  , (\_v944 -> P.Just (3, ("modifiedTime",T.TI64 _v944))) $ compactContact_modifiedTime record
  , (\_v944 -> P.Just (4, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v944))) $ compactContact_status record
  , (\_v944 -> P.Just (5, ("settings",T.TI64 _v944))) $ compactContact_settings record
  , (\_v944 -> P.Just (6, ("displayNameOverridden",T.TString $ E.encodeUtf8 _v944))) $ compactContact_displayNameOverridden record
  ]
write_CompactContact :: T.Protocol p => p -> CompactContact -> P.IO ()
write_CompactContact oprot record = T.writeVal oprot $ from_CompactContact record
encode_CompactContact :: T.StatelessProtocol p => p -> CompactContact -> LBS.ByteString
encode_CompactContact oprot record = T.serializeVal oprot $ from_CompactContact record
to_CompactContact :: T.ThriftVal -> CompactContact
to_CompactContact (T.TStruct fields) = CompactContact{
  compactContact_mid = P.maybe (compactContact_mid default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TString _val947 -> E.decodeUtf8 _val947; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  compactContact_createdTime = P.maybe (compactContact_createdTime default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TI64 _val948 -> _val948; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  compactContact_modifiedTime = P.maybe (compactContact_modifiedTime default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TI64 _val949 -> _val949; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  compactContact_status = P.maybe (compactContact_status default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TI32 _val950 -> P.toEnum $ P.fromIntegral _val950; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  compactContact_settings = P.maybe (compactContact_settings default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TI64 _val951 -> _val951; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  compactContact_displayNameOverridden = P.maybe (compactContact_displayNameOverridden default_CompactContact) (\(_,_val946) -> (case _val946 of {T.TString _val952 -> E.decodeUtf8 _val952; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_CompactContact _ = P.error "not a struct"
read_CompactContact :: T.Protocol p => p -> P.IO CompactContact
read_CompactContact iprot = to_CompactContact <$> T.readVal iprot (T.T_STRUCT typemap_CompactContact)
decode_CompactContact :: T.StatelessProtocol p => p -> LBS.ByteString -> CompactContact
decode_CompactContact iprot bs = to_CompactContact $ T.deserializeVal iprot (T.T_STRUCT typemap_CompactContact) bs
typemap_CompactContact :: T.TypeMap
typemap_CompactContact = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(3,("modifiedTime",T.T_I64)),(4,("status",T.T_I32)),(5,("settings",T.T_I64)),(6,("displayNameOverridden",T.T_STRING))]
default_CompactContact :: CompactContact
default_CompactContact = CompactContact{
  compactContact_mid = "",
  compactContact_createdTime = 0,
  compactContact_modifiedTime = 0,
  compactContact_status = (P.toEnum 0),
  compactContact_settings = 0,
  compactContact_displayNameOverridden = ""}
data ContactModification = ContactModification  { contactModification_type :: ModificationType
  , contactModification_luid :: LT.Text
  , contactModification_phones :: (Vector.Vector LT.Text)
  , contactModification_emails :: (Vector.Vector LT.Text)
  , contactModification_userids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactModification where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactModification_type record   `H.hashWithSalt` contactModification_luid record   `H.hashWithSalt` contactModification_phones record   `H.hashWithSalt` contactModification_emails record   `H.hashWithSalt` contactModification_userids record  
instance QC.Arbitrary ContactModification where 
  arbitrary = M.liftM ContactModification (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactModification = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactModification{contactModification_type = contactModification_type obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_type = contactModification_type obj}
    , if obj == default_ContactModification{contactModification_luid = contactModification_luid obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_luid = contactModification_luid obj}
    , if obj == default_ContactModification{contactModification_phones = contactModification_phones obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_phones = contactModification_phones obj}
    , if obj == default_ContactModification{contactModification_emails = contactModification_emails obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_emails = contactModification_emails obj}
    , if obj == default_ContactModification{contactModification_userids = contactModification_userids obj} then P.Nothing else P.Just $ default_ContactModification{contactModification_userids = contactModification_userids obj}
    ]
from_ContactModification :: ContactModification -> T.ThriftVal
from_ContactModification record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v955 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v955))) $ contactModification_type record
  , (\_v955 -> P.Just (2, ("luid",T.TString $ E.encodeUtf8 _v955))) $ contactModification_luid record
  , (\_v955 -> P.Just (11, ("phones",T.TList T.T_STRING $ P.map (\_v957 -> T.TString $ E.encodeUtf8 _v957) $ Vector.toList _v955))) $ contactModification_phones record
  , (\_v955 -> P.Just (12, ("emails",T.TList T.T_STRING $ P.map (\_v959 -> T.TString $ E.encodeUtf8 _v959) $ Vector.toList _v955))) $ contactModification_emails record
  , (\_v955 -> P.Just (13, ("userids",T.TList T.T_STRING $ P.map (\_v961 -> T.TString $ E.encodeUtf8 _v961) $ Vector.toList _v955))) $ contactModification_userids record
  ]
write_ContactModification :: T.Protocol p => p -> ContactModification -> P.IO ()
write_ContactModification oprot record = T.writeVal oprot $ from_ContactModification record
encode_ContactModification :: T.StatelessProtocol p => p -> ContactModification -> LBS.ByteString
encode_ContactModification oprot record = T.serializeVal oprot $ from_ContactModification record
to_ContactModification :: T.ThriftVal -> ContactModification
to_ContactModification (T.TStruct fields) = ContactModification{
  contactModification_type = P.maybe (contactModification_type default_ContactModification) (\(_,_val963) -> (case _val963 of {T.TI32 _val964 -> P.toEnum $ P.fromIntegral _val964; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactModification_luid = P.maybe (contactModification_luid default_ContactModification) (\(_,_val963) -> (case _val963 of {T.TString _val965 -> E.decodeUtf8 _val965; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contactModification_phones = P.maybe (contactModification_phones default_ContactModification) (\(_,_val963) -> (case _val963 of {T.TList _ _val966 -> (Vector.fromList $ P.map (\_v967 -> (case _v967 of {T.TString _val968 -> E.decodeUtf8 _val968; _ -> P.error "wrong type"})) _val966); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contactModification_emails = P.maybe (contactModification_emails default_ContactModification) (\(_,_val963) -> (case _val963 of {T.TList _ _val969 -> (Vector.fromList $ P.map (\_v970 -> (case _v970 of {T.TString _val971 -> E.decodeUtf8 _val971; _ -> P.error "wrong type"})) _val969); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  contactModification_userids = P.maybe (contactModification_userids default_ContactModification) (\(_,_val963) -> (case _val963 of {T.TList _ _val972 -> (Vector.fromList $ P.map (\_v973 -> (case _v973 of {T.TString _val974 -> E.decodeUtf8 _val974; _ -> P.error "wrong type"})) _val972); _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_ContactModification _ = P.error "not a struct"
read_ContactModification :: T.Protocol p => p -> P.IO ContactModification
read_ContactModification iprot = to_ContactModification <$> T.readVal iprot (T.T_STRUCT typemap_ContactModification)
decode_ContactModification :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactModification
decode_ContactModification iprot bs = to_ContactModification $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactModification) bs
typemap_ContactModification :: T.TypeMap
typemap_ContactModification = Map.fromList [(1,("type",T.T_I32)),(2,("luid",T.T_STRING)),(11,("phones",(T.T_LIST T.T_STRING))),(12,("emails",(T.T_LIST T.T_STRING))),(13,("userids",(T.T_LIST T.T_STRING)))]
default_ContactModification :: ContactModification
default_ContactModification = ContactModification{
  contactModification_type = (P.toEnum 0),
  contactModification_luid = "",
  contactModification_phones = Vector.empty,
  contactModification_emails = Vector.empty,
  contactModification_userids = Vector.empty}
data ContactRegistration = ContactRegistration  { contactRegistration_contact :: Contact
  , contactRegistration_luid :: LT.Text
  , contactRegistration_contactType :: ContactType
  , contactRegistration_contactKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactRegistration where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactRegistration_contact record   `H.hashWithSalt` contactRegistration_luid record   `H.hashWithSalt` contactRegistration_contactType record   `H.hashWithSalt` contactRegistration_contactKey record  
instance QC.Arbitrary ContactRegistration where 
  arbitrary = M.liftM ContactRegistration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactRegistration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactRegistration{contactRegistration_contact = contactRegistration_contact obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contact = contactRegistration_contact obj}
    , if obj == default_ContactRegistration{contactRegistration_luid = contactRegistration_luid obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_luid = contactRegistration_luid obj}
    , if obj == default_ContactRegistration{contactRegistration_contactType = contactRegistration_contactType obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contactType = contactRegistration_contactType obj}
    , if obj == default_ContactRegistration{contactRegistration_contactKey = contactRegistration_contactKey obj} then P.Nothing else P.Just $ default_ContactRegistration{contactRegistration_contactKey = contactRegistration_contactKey obj}
    ]
from_ContactRegistration :: ContactRegistration -> T.ThriftVal
from_ContactRegistration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v977 -> P.Just (1, ("contact",from_Contact _v977))) $ contactRegistration_contact record
  , (\_v977 -> P.Just (10, ("luid",T.TString $ E.encodeUtf8 _v977))) $ contactRegistration_luid record
  , (\_v977 -> P.Just (11, ("contactType",T.TI32 $ P.fromIntegral $ P.fromEnum _v977))) $ contactRegistration_contactType record
  , (\_v977 -> P.Just (12, ("contactKey",T.TString $ E.encodeUtf8 _v977))) $ contactRegistration_contactKey record
  ]
write_ContactRegistration :: T.Protocol p => p -> ContactRegistration -> P.IO ()
write_ContactRegistration oprot record = T.writeVal oprot $ from_ContactRegistration record
encode_ContactRegistration :: T.StatelessProtocol p => p -> ContactRegistration -> LBS.ByteString
encode_ContactRegistration oprot record = T.serializeVal oprot $ from_ContactRegistration record
to_ContactRegistration :: T.ThriftVal -> ContactRegistration
to_ContactRegistration (T.TStruct fields) = ContactRegistration{
  contactRegistration_contact = P.maybe (contactRegistration_contact default_ContactRegistration) (\(_,_val979) -> (case _val979 of {T.TStruct _val980 -> (to_Contact (T.TStruct _val980)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactRegistration_luid = P.maybe (contactRegistration_luid default_ContactRegistration) (\(_,_val979) -> (case _val979 of {T.TString _val981 -> E.decodeUtf8 _val981; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  contactRegistration_contactType = P.maybe (contactRegistration_contactType default_ContactRegistration) (\(_,_val979) -> (case _val979 of {T.TI32 _val982 -> P.toEnum $ P.fromIntegral _val982; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  contactRegistration_contactKey = P.maybe (contactRegistration_contactKey default_ContactRegistration) (\(_,_val979) -> (case _val979 of {T.TString _val983 -> E.decodeUtf8 _val983; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_ContactRegistration _ = P.error "not a struct"
read_ContactRegistration :: T.Protocol p => p -> P.IO ContactRegistration
read_ContactRegistration iprot = to_ContactRegistration <$> T.readVal iprot (T.T_STRUCT typemap_ContactRegistration)
decode_ContactRegistration :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactRegistration
decode_ContactRegistration iprot bs = to_ContactRegistration $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactRegistration) bs
typemap_ContactRegistration :: T.TypeMap
typemap_ContactRegistration = Map.fromList [(1,("contact",(T.T_STRUCT typemap_Contact))),(10,("luid",T.T_STRING)),(11,("contactType",T.T_I32)),(12,("contactKey",T.T_STRING))]
default_ContactRegistration :: ContactRegistration
default_ContactRegistration = ContactRegistration{
  contactRegistration_contact = default_Contact,
  contactRegistration_luid = "",
  contactRegistration_contactType = (P.toEnum 0),
  contactRegistration_contactKey = ""}
data ContactReport = ContactReport  { contactReport_mid :: LT.Text
  , contactReport_exists :: P.Bool
  , contactReport_contact :: Contact
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactReport where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactReport_mid record   `H.hashWithSalt` contactReport_exists record   `H.hashWithSalt` contactReport_contact record  
instance QC.Arbitrary ContactReport where 
  arbitrary = M.liftM ContactReport (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactReport = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactReport{contactReport_mid = contactReport_mid obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_mid = contactReport_mid obj}
    , if obj == default_ContactReport{contactReport_exists = contactReport_exists obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_exists = contactReport_exists obj}
    , if obj == default_ContactReport{contactReport_contact = contactReport_contact obj} then P.Nothing else P.Just $ default_ContactReport{contactReport_contact = contactReport_contact obj}
    ]
from_ContactReport :: ContactReport -> T.ThriftVal
from_ContactReport record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v986 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v986))) $ contactReport_mid record
  , (\_v986 -> P.Just (2, ("exists",T.TBool _v986))) $ contactReport_exists record
  , (\_v986 -> P.Just (3, ("contact",from_Contact _v986))) $ contactReport_contact record
  ]
write_ContactReport :: T.Protocol p => p -> ContactReport -> P.IO ()
write_ContactReport oprot record = T.writeVal oprot $ from_ContactReport record
encode_ContactReport :: T.StatelessProtocol p => p -> ContactReport -> LBS.ByteString
encode_ContactReport oprot record = T.serializeVal oprot $ from_ContactReport record
to_ContactReport :: T.ThriftVal -> ContactReport
to_ContactReport (T.TStruct fields) = ContactReport{
  contactReport_mid = P.maybe (contactReport_mid default_ContactReport) (\(_,_val988) -> (case _val988 of {T.TString _val989 -> E.decodeUtf8 _val989; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactReport_exists = P.maybe (contactReport_exists default_ContactReport) (\(_,_val988) -> (case _val988 of {T.TBool _val990 -> _val990; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contactReport_contact = P.maybe (contactReport_contact default_ContactReport) (\(_,_val988) -> (case _val988 of {T.TStruct _val991 -> (to_Contact (T.TStruct _val991)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ContactReport _ = P.error "not a struct"
read_ContactReport :: T.Protocol p => p -> P.IO ContactReport
read_ContactReport iprot = to_ContactReport <$> T.readVal iprot (T.T_STRUCT typemap_ContactReport)
decode_ContactReport :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactReport
decode_ContactReport iprot bs = to_ContactReport $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactReport) bs
typemap_ContactReport :: T.TypeMap
typemap_ContactReport = Map.fromList [(1,("mid",T.T_STRING)),(2,("exists",T.T_BOOL)),(3,("contact",(T.T_STRUCT typemap_Contact)))]
default_ContactReport :: ContactReport
default_ContactReport = ContactReport{
  contactReport_mid = "",
  contactReport_exists = P.False,
  contactReport_contact = default_Contact}
data ContactReportResult = ContactReportResult  { contactReportResult_mid :: LT.Text
  , contactReportResult_exists :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ContactReportResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` contactReportResult_mid record   `H.hashWithSalt` contactReportResult_exists record  
instance QC.Arbitrary ContactReportResult where 
  arbitrary = M.liftM ContactReportResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ContactReportResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ContactReportResult{contactReportResult_mid = contactReportResult_mid obj} then P.Nothing else P.Just $ default_ContactReportResult{contactReportResult_mid = contactReportResult_mid obj}
    , if obj == default_ContactReportResult{contactReportResult_exists = contactReportResult_exists obj} then P.Nothing else P.Just $ default_ContactReportResult{contactReportResult_exists = contactReportResult_exists obj}
    ]
from_ContactReportResult :: ContactReportResult -> T.ThriftVal
from_ContactReportResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v994 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v994))) $ contactReportResult_mid record
  , (\_v994 -> P.Just (2, ("exists",T.TBool _v994))) $ contactReportResult_exists record
  ]
write_ContactReportResult :: T.Protocol p => p -> ContactReportResult -> P.IO ()
write_ContactReportResult oprot record = T.writeVal oprot $ from_ContactReportResult record
encode_ContactReportResult :: T.StatelessProtocol p => p -> ContactReportResult -> LBS.ByteString
encode_ContactReportResult oprot record = T.serializeVal oprot $ from_ContactReportResult record
to_ContactReportResult :: T.ThriftVal -> ContactReportResult
to_ContactReportResult (T.TStruct fields) = ContactReportResult{
  contactReportResult_mid = P.maybe (contactReportResult_mid default_ContactReportResult) (\(_,_val996) -> (case _val996 of {T.TString _val997 -> E.decodeUtf8 _val997; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contactReportResult_exists = P.maybe (contactReportResult_exists default_ContactReportResult) (\(_,_val996) -> (case _val996 of {T.TBool _val998 -> _val998; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ContactReportResult _ = P.error "not a struct"
read_ContactReportResult :: T.Protocol p => p -> P.IO ContactReportResult
read_ContactReportResult iprot = to_ContactReportResult <$> T.readVal iprot (T.T_STRUCT typemap_ContactReportResult)
decode_ContactReportResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ContactReportResult
decode_ContactReportResult iprot bs = to_ContactReportResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ContactReportResult) bs
typemap_ContactReportResult :: T.TypeMap
typemap_ContactReportResult = Map.fromList [(1,("mid",T.T_STRING)),(2,("exists",T.T_BOOL))]
default_ContactReportResult :: ContactReportResult
default_ContactReportResult = ContactReportResult{
  contactReportResult_mid = "",
  contactReportResult_exists = P.False}
data DeviceInfo = DeviceInfo  { deviceInfo_deviceName :: LT.Text
  , deviceInfo_systemName :: LT.Text
  , deviceInfo_systemVersion :: LT.Text
  , deviceInfo_model :: LT.Text
  , deviceInfo_carrierCode :: CarrierCode
  , deviceInfo_carrierName :: LT.Text
  , deviceInfo_applicationType :: ApplicationType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeviceInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` deviceInfo_deviceName record   `H.hashWithSalt` deviceInfo_systemName record   `H.hashWithSalt` deviceInfo_systemVersion record   `H.hashWithSalt` deviceInfo_model record   `H.hashWithSalt` deviceInfo_carrierCode record   `H.hashWithSalt` deviceInfo_carrierName record   `H.hashWithSalt` deviceInfo_applicationType record  
instance QC.Arbitrary DeviceInfo where 
  arbitrary = M.liftM DeviceInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeviceInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeviceInfo{deviceInfo_deviceName = deviceInfo_deviceName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_deviceName = deviceInfo_deviceName obj}
    , if obj == default_DeviceInfo{deviceInfo_systemName = deviceInfo_systemName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_systemName = deviceInfo_systemName obj}
    , if obj == default_DeviceInfo{deviceInfo_systemVersion = deviceInfo_systemVersion obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_systemVersion = deviceInfo_systemVersion obj}
    , if obj == default_DeviceInfo{deviceInfo_model = deviceInfo_model obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_model = deviceInfo_model obj}
    , if obj == default_DeviceInfo{deviceInfo_carrierCode = deviceInfo_carrierCode obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_carrierCode = deviceInfo_carrierCode obj}
    , if obj == default_DeviceInfo{deviceInfo_carrierName = deviceInfo_carrierName obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_carrierName = deviceInfo_carrierName obj}
    , if obj == default_DeviceInfo{deviceInfo_applicationType = deviceInfo_applicationType obj} then P.Nothing else P.Just $ default_DeviceInfo{deviceInfo_applicationType = deviceInfo_applicationType obj}
    ]
from_DeviceInfo :: DeviceInfo -> T.ThriftVal
from_DeviceInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1001 -> P.Just (1, ("deviceName",T.TString $ E.encodeUtf8 _v1001))) $ deviceInfo_deviceName record
  , (\_v1001 -> P.Just (2, ("systemName",T.TString $ E.encodeUtf8 _v1001))) $ deviceInfo_systemName record
  , (\_v1001 -> P.Just (3, ("systemVersion",T.TString $ E.encodeUtf8 _v1001))) $ deviceInfo_systemVersion record
  , (\_v1001 -> P.Just (4, ("model",T.TString $ E.encodeUtf8 _v1001))) $ deviceInfo_model record
  , (\_v1001 -> P.Just (10, ("carrierCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v1001))) $ deviceInfo_carrierCode record
  , (\_v1001 -> P.Just (11, ("carrierName",T.TString $ E.encodeUtf8 _v1001))) $ deviceInfo_carrierName record
  , (\_v1001 -> P.Just (20, ("applicationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1001))) $ deviceInfo_applicationType record
  ]
write_DeviceInfo :: T.Protocol p => p -> DeviceInfo -> P.IO ()
write_DeviceInfo oprot record = T.writeVal oprot $ from_DeviceInfo record
encode_DeviceInfo :: T.StatelessProtocol p => p -> DeviceInfo -> LBS.ByteString
encode_DeviceInfo oprot record = T.serializeVal oprot $ from_DeviceInfo record
to_DeviceInfo :: T.ThriftVal -> DeviceInfo
to_DeviceInfo (T.TStruct fields) = DeviceInfo{
  deviceInfo_deviceName = P.maybe (deviceInfo_deviceName default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TString _val1004 -> E.decodeUtf8 _val1004; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  deviceInfo_systemName = P.maybe (deviceInfo_systemName default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TString _val1005 -> E.decodeUtf8 _val1005; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deviceInfo_systemVersion = P.maybe (deviceInfo_systemVersion default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TString _val1006 -> E.decodeUtf8 _val1006; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  deviceInfo_model = P.maybe (deviceInfo_model default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TString _val1007 -> E.decodeUtf8 _val1007; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  deviceInfo_carrierCode = P.maybe (deviceInfo_carrierCode default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TI32 _val1008 -> P.toEnum $ P.fromIntegral _val1008; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  deviceInfo_carrierName = P.maybe (deviceInfo_carrierName default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TString _val1009 -> E.decodeUtf8 _val1009; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  deviceInfo_applicationType = P.maybe (deviceInfo_applicationType default_DeviceInfo) (\(_,_val1003) -> (case _val1003 of {T.TI32 _val1010 -> P.toEnum $ P.fromIntegral _val1010; _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_DeviceInfo _ = P.error "not a struct"
read_DeviceInfo :: T.Protocol p => p -> P.IO DeviceInfo
read_DeviceInfo iprot = to_DeviceInfo <$> T.readVal iprot (T.T_STRUCT typemap_DeviceInfo)
decode_DeviceInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> DeviceInfo
decode_DeviceInfo iprot bs = to_DeviceInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_DeviceInfo) bs
typemap_DeviceInfo :: T.TypeMap
typemap_DeviceInfo = Map.fromList [(1,("deviceName",T.T_STRING)),(2,("systemName",T.T_STRING)),(3,("systemVersion",T.T_STRING)),(4,("model",T.T_STRING)),(10,("carrierCode",T.T_I32)),(11,("carrierName",T.T_STRING)),(20,("applicationType",T.T_I32))]
default_DeviceInfo :: DeviceInfo
default_DeviceInfo = DeviceInfo{
  deviceInfo_deviceName = "",
  deviceInfo_systemName = "",
  deviceInfo_systemVersion = "",
  deviceInfo_model = "",
  deviceInfo_carrierCode = (P.toEnum 0),
  deviceInfo_carrierName = "",
  deviceInfo_applicationType = (P.toEnum 0)}
data EmailConfirmation = EmailConfirmation  { emailConfirmation_usePasswordSet :: P.Bool
  , emailConfirmation_email :: LT.Text
  , emailConfirmation_password :: LT.Text
  , emailConfirmation_ignoreDuplication :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailConfirmation where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailConfirmation_usePasswordSet record   `H.hashWithSalt` emailConfirmation_email record   `H.hashWithSalt` emailConfirmation_password record   `H.hashWithSalt` emailConfirmation_ignoreDuplication record  
instance QC.Arbitrary EmailConfirmation where 
  arbitrary = M.liftM EmailConfirmation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EmailConfirmation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailConfirmation{emailConfirmation_usePasswordSet = emailConfirmation_usePasswordSet obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_usePasswordSet = emailConfirmation_usePasswordSet obj}
    , if obj == default_EmailConfirmation{emailConfirmation_email = emailConfirmation_email obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_email = emailConfirmation_email obj}
    , if obj == default_EmailConfirmation{emailConfirmation_password = emailConfirmation_password obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_password = emailConfirmation_password obj}
    , if obj == default_EmailConfirmation{emailConfirmation_ignoreDuplication = emailConfirmation_ignoreDuplication obj} then P.Nothing else P.Just $ default_EmailConfirmation{emailConfirmation_ignoreDuplication = emailConfirmation_ignoreDuplication obj}
    ]
from_EmailConfirmation :: EmailConfirmation -> T.ThriftVal
from_EmailConfirmation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1013 -> P.Just (1, ("usePasswordSet",T.TBool _v1013))) $ emailConfirmation_usePasswordSet record
  , (\_v1013 -> P.Just (2, ("email",T.TString $ E.encodeUtf8 _v1013))) $ emailConfirmation_email record
  , (\_v1013 -> P.Just (3, ("password",T.TString $ E.encodeUtf8 _v1013))) $ emailConfirmation_password record
  , (\_v1013 -> P.Just (4, ("ignoreDuplication",T.TBool _v1013))) $ emailConfirmation_ignoreDuplication record
  ]
write_EmailConfirmation :: T.Protocol p => p -> EmailConfirmation -> P.IO ()
write_EmailConfirmation oprot record = T.writeVal oprot $ from_EmailConfirmation record
encode_EmailConfirmation :: T.StatelessProtocol p => p -> EmailConfirmation -> LBS.ByteString
encode_EmailConfirmation oprot record = T.serializeVal oprot $ from_EmailConfirmation record
to_EmailConfirmation :: T.ThriftVal -> EmailConfirmation
to_EmailConfirmation (T.TStruct fields) = EmailConfirmation{
  emailConfirmation_usePasswordSet = P.maybe (emailConfirmation_usePasswordSet default_EmailConfirmation) (\(_,_val1015) -> (case _val1015 of {T.TBool _val1016 -> _val1016; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailConfirmation_email = P.maybe (emailConfirmation_email default_EmailConfirmation) (\(_,_val1015) -> (case _val1015 of {T.TString _val1017 -> E.decodeUtf8 _val1017; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  emailConfirmation_password = P.maybe (emailConfirmation_password default_EmailConfirmation) (\(_,_val1015) -> (case _val1015 of {T.TString _val1018 -> E.decodeUtf8 _val1018; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  emailConfirmation_ignoreDuplication = P.maybe (emailConfirmation_ignoreDuplication default_EmailConfirmation) (\(_,_val1015) -> (case _val1015 of {T.TBool _val1019 -> _val1019; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_EmailConfirmation _ = P.error "not a struct"
read_EmailConfirmation :: T.Protocol p => p -> P.IO EmailConfirmation
read_EmailConfirmation iprot = to_EmailConfirmation <$> T.readVal iprot (T.T_STRUCT typemap_EmailConfirmation)
decode_EmailConfirmation :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailConfirmation
decode_EmailConfirmation iprot bs = to_EmailConfirmation $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailConfirmation) bs
typemap_EmailConfirmation :: T.TypeMap
typemap_EmailConfirmation = Map.fromList [(1,("usePasswordSet",T.T_BOOL)),(2,("email",T.T_STRING)),(3,("password",T.T_STRING)),(4,("ignoreDuplication",T.T_BOOL))]
default_EmailConfirmation :: EmailConfirmation
default_EmailConfirmation = EmailConfirmation{
  emailConfirmation_usePasswordSet = P.False,
  emailConfirmation_email = "",
  emailConfirmation_password = "",
  emailConfirmation_ignoreDuplication = P.False}
data EmailConfirmationSession = EmailConfirmationSession  { emailConfirmationSession_emailConfirmationType :: EmailConfirmationType
  , emailConfirmationSession_verifier :: LT.Text
  , emailConfirmationSession_targetEmail :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailConfirmationSession where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailConfirmationSession_emailConfirmationType record   `H.hashWithSalt` emailConfirmationSession_verifier record   `H.hashWithSalt` emailConfirmationSession_targetEmail record  
instance QC.Arbitrary EmailConfirmationSession where 
  arbitrary = M.liftM EmailConfirmationSession (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EmailConfirmationSession = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailConfirmationSession{emailConfirmationSession_emailConfirmationType = emailConfirmationSession_emailConfirmationType obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_emailConfirmationType = emailConfirmationSession_emailConfirmationType obj}
    , if obj == default_EmailConfirmationSession{emailConfirmationSession_verifier = emailConfirmationSession_verifier obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_verifier = emailConfirmationSession_verifier obj}
    , if obj == default_EmailConfirmationSession{emailConfirmationSession_targetEmail = emailConfirmationSession_targetEmail obj} then P.Nothing else P.Just $ default_EmailConfirmationSession{emailConfirmationSession_targetEmail = emailConfirmationSession_targetEmail obj}
    ]
from_EmailConfirmationSession :: EmailConfirmationSession -> T.ThriftVal
from_EmailConfirmationSession record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1022 -> P.Just (1, ("emailConfirmationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1022))) $ emailConfirmationSession_emailConfirmationType record
  , (\_v1022 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v1022))) $ emailConfirmationSession_verifier record
  , (\_v1022 -> P.Just (3, ("targetEmail",T.TString $ E.encodeUtf8 _v1022))) $ emailConfirmationSession_targetEmail record
  ]
write_EmailConfirmationSession :: T.Protocol p => p -> EmailConfirmationSession -> P.IO ()
write_EmailConfirmationSession oprot record = T.writeVal oprot $ from_EmailConfirmationSession record
encode_EmailConfirmationSession :: T.StatelessProtocol p => p -> EmailConfirmationSession -> LBS.ByteString
encode_EmailConfirmationSession oprot record = T.serializeVal oprot $ from_EmailConfirmationSession record
to_EmailConfirmationSession :: T.ThriftVal -> EmailConfirmationSession
to_EmailConfirmationSession (T.TStruct fields) = EmailConfirmationSession{
  emailConfirmationSession_emailConfirmationType = P.maybe (emailConfirmationSession_emailConfirmationType default_EmailConfirmationSession) (\(_,_val1024) -> (case _val1024 of {T.TI32 _val1025 -> P.toEnum $ P.fromIntegral _val1025; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailConfirmationSession_verifier = P.maybe (emailConfirmationSession_verifier default_EmailConfirmationSession) (\(_,_val1024) -> (case _val1024 of {T.TString _val1026 -> E.decodeUtf8 _val1026; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  emailConfirmationSession_targetEmail = P.maybe (emailConfirmationSession_targetEmail default_EmailConfirmationSession) (\(_,_val1024) -> (case _val1024 of {T.TString _val1027 -> E.decodeUtf8 _val1027; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_EmailConfirmationSession _ = P.error "not a struct"
read_EmailConfirmationSession :: T.Protocol p => p -> P.IO EmailConfirmationSession
read_EmailConfirmationSession iprot = to_EmailConfirmationSession <$> T.readVal iprot (T.T_STRUCT typemap_EmailConfirmationSession)
decode_EmailConfirmationSession :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailConfirmationSession
decode_EmailConfirmationSession iprot bs = to_EmailConfirmationSession $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailConfirmationSession) bs
typemap_EmailConfirmationSession :: T.TypeMap
typemap_EmailConfirmationSession = Map.fromList [(1,("emailConfirmationType",T.T_I32)),(2,("verifier",T.T_STRING)),(3,("targetEmail",T.T_STRING))]
default_EmailConfirmationSession :: EmailConfirmationSession
default_EmailConfirmationSession = EmailConfirmationSession{
  emailConfirmationSession_emailConfirmationType = (P.toEnum 0),
  emailConfirmationSession_verifier = "",
  emailConfirmationSession_targetEmail = ""}
data FriendChannelMatrix = FriendChannelMatrix  { friendChannelMatrix_channelId :: LT.Text
  , friendChannelMatrix_representMid :: LT.Text
  , friendChannelMatrix_count :: I.Int32
  , friendChannelMatrix_point :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendChannelMatrix where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendChannelMatrix_channelId record   `H.hashWithSalt` friendChannelMatrix_representMid record   `H.hashWithSalt` friendChannelMatrix_count record   `H.hashWithSalt` friendChannelMatrix_point record  
instance QC.Arbitrary FriendChannelMatrix where 
  arbitrary = M.liftM FriendChannelMatrix (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendChannelMatrix = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendChannelMatrix{friendChannelMatrix_channelId = friendChannelMatrix_channelId obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_channelId = friendChannelMatrix_channelId obj}
    , if obj == default_FriendChannelMatrix{friendChannelMatrix_representMid = friendChannelMatrix_representMid obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_representMid = friendChannelMatrix_representMid obj}
    , if obj == default_FriendChannelMatrix{friendChannelMatrix_count = friendChannelMatrix_count obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_count = friendChannelMatrix_count obj}
    , if obj == default_FriendChannelMatrix{friendChannelMatrix_point = friendChannelMatrix_point obj} then P.Nothing else P.Just $ default_FriendChannelMatrix{friendChannelMatrix_point = friendChannelMatrix_point obj}
    ]
from_FriendChannelMatrix :: FriendChannelMatrix -> T.ThriftVal
from_FriendChannelMatrix record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1030 -> P.Just (1, ("channelId",T.TString $ E.encodeUtf8 _v1030))) $ friendChannelMatrix_channelId record
  , (\_v1030 -> P.Just (2, ("representMid",T.TString $ E.encodeUtf8 _v1030))) $ friendChannelMatrix_representMid record
  , (\_v1030 -> P.Just (3, ("count",T.TI32 _v1030))) $ friendChannelMatrix_count record
  , (\_v1030 -> P.Just (4, ("point",T.TI32 _v1030))) $ friendChannelMatrix_point record
  ]
write_FriendChannelMatrix :: T.Protocol p => p -> FriendChannelMatrix -> P.IO ()
write_FriendChannelMatrix oprot record = T.writeVal oprot $ from_FriendChannelMatrix record
encode_FriendChannelMatrix :: T.StatelessProtocol p => p -> FriendChannelMatrix -> LBS.ByteString
encode_FriendChannelMatrix oprot record = T.serializeVal oprot $ from_FriendChannelMatrix record
to_FriendChannelMatrix :: T.ThriftVal -> FriendChannelMatrix
to_FriendChannelMatrix (T.TStruct fields) = FriendChannelMatrix{
  friendChannelMatrix_channelId = P.maybe (friendChannelMatrix_channelId default_FriendChannelMatrix) (\(_,_val1032) -> (case _val1032 of {T.TString _val1033 -> E.decodeUtf8 _val1033; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendChannelMatrix_representMid = P.maybe (friendChannelMatrix_representMid default_FriendChannelMatrix) (\(_,_val1032) -> (case _val1032 of {T.TString _val1034 -> E.decodeUtf8 _val1034; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  friendChannelMatrix_count = P.maybe (friendChannelMatrix_count default_FriendChannelMatrix) (\(_,_val1032) -> (case _val1032 of {T.TI32 _val1035 -> _val1035; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  friendChannelMatrix_point = P.maybe (friendChannelMatrix_point default_FriendChannelMatrix) (\(_,_val1032) -> (case _val1032 of {T.TI32 _val1036 -> _val1036; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FriendChannelMatrix _ = P.error "not a struct"
read_FriendChannelMatrix :: T.Protocol p => p -> P.IO FriendChannelMatrix
read_FriendChannelMatrix iprot = to_FriendChannelMatrix <$> T.readVal iprot (T.T_STRUCT typemap_FriendChannelMatrix)
decode_FriendChannelMatrix :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendChannelMatrix
decode_FriendChannelMatrix iprot bs = to_FriendChannelMatrix $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendChannelMatrix) bs
typemap_FriendChannelMatrix :: T.TypeMap
typemap_FriendChannelMatrix = Map.fromList [(1,("channelId",T.T_STRING)),(2,("representMid",T.T_STRING)),(3,("count",T.T_I32)),(4,("point",T.T_I32))]
default_FriendChannelMatrix :: FriendChannelMatrix
default_FriendChannelMatrix = FriendChannelMatrix{
  friendChannelMatrix_channelId = "",
  friendChannelMatrix_representMid = "",
  friendChannelMatrix_count = 0,
  friendChannelMatrix_point = 0}
data FriendChannelMatricesResponse = FriendChannelMatricesResponse  { friendChannelMatricesResponse_expires :: I.Int64
  , friendChannelMatricesResponse_matrices :: (Vector.Vector FriendChannelMatrix)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendChannelMatricesResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendChannelMatricesResponse_expires record   `H.hashWithSalt` friendChannelMatricesResponse_matrices record  
instance QC.Arbitrary FriendChannelMatricesResponse where 
  arbitrary = M.liftM FriendChannelMatricesResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendChannelMatricesResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendChannelMatricesResponse{friendChannelMatricesResponse_expires = friendChannelMatricesResponse_expires obj} then P.Nothing else P.Just $ default_FriendChannelMatricesResponse{friendChannelMatricesResponse_expires = friendChannelMatricesResponse_expires obj}
    , if obj == default_FriendChannelMatricesResponse{friendChannelMatricesResponse_matrices = friendChannelMatricesResponse_matrices obj} then P.Nothing else P.Just $ default_FriendChannelMatricesResponse{friendChannelMatricesResponse_matrices = friendChannelMatricesResponse_matrices obj}
    ]
from_FriendChannelMatricesResponse :: FriendChannelMatricesResponse -> T.ThriftVal
from_FriendChannelMatricesResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1039 -> P.Just (1, ("expires",T.TI64 _v1039))) $ friendChannelMatricesResponse_expires record
  , (\_v1039 -> P.Just (2, ("matrices",T.TList (T.T_STRUCT typemap_FriendChannelMatrix) $ P.map (\_v1041 -> from_FriendChannelMatrix _v1041) $ Vector.toList _v1039))) $ friendChannelMatricesResponse_matrices record
  ]
write_FriendChannelMatricesResponse :: T.Protocol p => p -> FriendChannelMatricesResponse -> P.IO ()
write_FriendChannelMatricesResponse oprot record = T.writeVal oprot $ from_FriendChannelMatricesResponse record
encode_FriendChannelMatricesResponse :: T.StatelessProtocol p => p -> FriendChannelMatricesResponse -> LBS.ByteString
encode_FriendChannelMatricesResponse oprot record = T.serializeVal oprot $ from_FriendChannelMatricesResponse record
to_FriendChannelMatricesResponse :: T.ThriftVal -> FriendChannelMatricesResponse
to_FriendChannelMatricesResponse (T.TStruct fields) = FriendChannelMatricesResponse{
  friendChannelMatricesResponse_expires = P.maybe (friendChannelMatricesResponse_expires default_FriendChannelMatricesResponse) (\(_,_val1043) -> (case _val1043 of {T.TI64 _val1044 -> _val1044; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendChannelMatricesResponse_matrices = P.maybe (friendChannelMatricesResponse_matrices default_FriendChannelMatricesResponse) (\(_,_val1043) -> (case _val1043 of {T.TList _ _val1045 -> (Vector.fromList $ P.map (\_v1046 -> (case _v1046 of {T.TStruct _val1047 -> (to_FriendChannelMatrix (T.TStruct _val1047)); _ -> P.error "wrong type"})) _val1045); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FriendChannelMatricesResponse _ = P.error "not a struct"
read_FriendChannelMatricesResponse :: T.Protocol p => p -> P.IO FriendChannelMatricesResponse
read_FriendChannelMatricesResponse iprot = to_FriendChannelMatricesResponse <$> T.readVal iprot (T.T_STRUCT typemap_FriendChannelMatricesResponse)
decode_FriendChannelMatricesResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendChannelMatricesResponse
decode_FriendChannelMatricesResponse iprot bs = to_FriendChannelMatricesResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendChannelMatricesResponse) bs
typemap_FriendChannelMatricesResponse :: T.TypeMap
typemap_FriendChannelMatricesResponse = Map.fromList [(1,("expires",T.T_I64)),(2,("matrices",(T.T_LIST (T.T_STRUCT typemap_FriendChannelMatrix))))]
default_FriendChannelMatricesResponse :: FriendChannelMatricesResponse
default_FriendChannelMatricesResponse = FriendChannelMatricesResponse{
  friendChannelMatricesResponse_expires = 0,
  friendChannelMatricesResponse_matrices = Vector.empty}
data FriendRequest = FriendRequest  { friendRequest_eMid :: LT.Text
  , friendRequest_mid :: LT.Text
  , friendRequest_direction :: FriendRequestDirection
  , friendRequest_method :: FriendRequestMethod
  , friendRequest_param :: LT.Text
  , friendRequest_timestamp :: I.Int64
  , friendRequest_seqId :: I.Int64
  , friendRequest_displayName :: LT.Text
  , friendRequest_picturePath :: LT.Text
  , friendRequest_pictureStatus :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendRequest_eMid record   `H.hashWithSalt` friendRequest_mid record   `H.hashWithSalt` friendRequest_direction record   `H.hashWithSalt` friendRequest_method record   `H.hashWithSalt` friendRequest_param record   `H.hashWithSalt` friendRequest_timestamp record   `H.hashWithSalt` friendRequest_seqId record   `H.hashWithSalt` friendRequest_displayName record   `H.hashWithSalt` friendRequest_picturePath record   `H.hashWithSalt` friendRequest_pictureStatus record  
instance QC.Arbitrary FriendRequest where 
  arbitrary = M.liftM FriendRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendRequest{friendRequest_eMid = friendRequest_eMid obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_eMid = friendRequest_eMid obj}
    , if obj == default_FriendRequest{friendRequest_mid = friendRequest_mid obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_mid = friendRequest_mid obj}
    , if obj == default_FriendRequest{friendRequest_direction = friendRequest_direction obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_direction = friendRequest_direction obj}
    , if obj == default_FriendRequest{friendRequest_method = friendRequest_method obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_method = friendRequest_method obj}
    , if obj == default_FriendRequest{friendRequest_param = friendRequest_param obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_param = friendRequest_param obj}
    , if obj == default_FriendRequest{friendRequest_timestamp = friendRequest_timestamp obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_timestamp = friendRequest_timestamp obj}
    , if obj == default_FriendRequest{friendRequest_seqId = friendRequest_seqId obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_seqId = friendRequest_seqId obj}
    , if obj == default_FriendRequest{friendRequest_displayName = friendRequest_displayName obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_displayName = friendRequest_displayName obj}
    , if obj == default_FriendRequest{friendRequest_picturePath = friendRequest_picturePath obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_picturePath = friendRequest_picturePath obj}
    , if obj == default_FriendRequest{friendRequest_pictureStatus = friendRequest_pictureStatus obj} then P.Nothing else P.Just $ default_FriendRequest{friendRequest_pictureStatus = friendRequest_pictureStatus obj}
    ]
from_FriendRequest :: FriendRequest -> T.ThriftVal
from_FriendRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1050 -> P.Just (1, ("eMid",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_eMid record
  , (\_v1050 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_mid record
  , (\_v1050 -> P.Just (3, ("direction",T.TI32 $ P.fromIntegral $ P.fromEnum _v1050))) $ friendRequest_direction record
  , (\_v1050 -> P.Just (4, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v1050))) $ friendRequest_method record
  , (\_v1050 -> P.Just (5, ("param",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_param record
  , (\_v1050 -> P.Just (6, ("timestamp",T.TI64 _v1050))) $ friendRequest_timestamp record
  , (\_v1050 -> P.Just (7, ("seqId",T.TI64 _v1050))) $ friendRequest_seqId record
  , (\_v1050 -> P.Just (10, ("displayName",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_displayName record
  , (\_v1050 -> P.Just (11, ("picturePath",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_picturePath record
  , (\_v1050 -> P.Just (12, ("pictureStatus",T.TString $ E.encodeUtf8 _v1050))) $ friendRequest_pictureStatus record
  ]
write_FriendRequest :: T.Protocol p => p -> FriendRequest -> P.IO ()
write_FriendRequest oprot record = T.writeVal oprot $ from_FriendRequest record
encode_FriendRequest :: T.StatelessProtocol p => p -> FriendRequest -> LBS.ByteString
encode_FriendRequest oprot record = T.serializeVal oprot $ from_FriendRequest record
to_FriendRequest :: T.ThriftVal -> FriendRequest
to_FriendRequest (T.TStruct fields) = FriendRequest{
  friendRequest_eMid = P.maybe (friendRequest_eMid default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1053 -> E.decodeUtf8 _val1053; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendRequest_mid = P.maybe (friendRequest_mid default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1054 -> E.decodeUtf8 _val1054; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  friendRequest_direction = P.maybe (friendRequest_direction default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TI32 _val1055 -> P.toEnum $ P.fromIntegral _val1055; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  friendRequest_method = P.maybe (friendRequest_method default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TI32 _val1056 -> P.toEnum $ P.fromIntegral _val1056; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  friendRequest_param = P.maybe (friendRequest_param default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1057 -> E.decodeUtf8 _val1057; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  friendRequest_timestamp = P.maybe (friendRequest_timestamp default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TI64 _val1058 -> _val1058; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  friendRequest_seqId = P.maybe (friendRequest_seqId default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TI64 _val1059 -> _val1059; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  friendRequest_displayName = P.maybe (friendRequest_displayName default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1060 -> E.decodeUtf8 _val1060; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  friendRequest_picturePath = P.maybe (friendRequest_picturePath default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1061 -> E.decodeUtf8 _val1061; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  friendRequest_pictureStatus = P.maybe (friendRequest_pictureStatus default_FriendRequest) (\(_,_val1052) -> (case _val1052 of {T.TString _val1062 -> E.decodeUtf8 _val1062; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_FriendRequest _ = P.error "not a struct"
read_FriendRequest :: T.Protocol p => p -> P.IO FriendRequest
read_FriendRequest iprot = to_FriendRequest <$> T.readVal iprot (T.T_STRUCT typemap_FriendRequest)
decode_FriendRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendRequest
decode_FriendRequest iprot bs = to_FriendRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendRequest) bs
typemap_FriendRequest :: T.TypeMap
typemap_FriendRequest = Map.fromList [(1,("eMid",T.T_STRING)),(2,("mid",T.T_STRING)),(3,("direction",T.T_I32)),(4,("method",T.T_I32)),(5,("param",T.T_STRING)),(6,("timestamp",T.T_I64)),(7,("seqId",T.T_I64)),(10,("displayName",T.T_STRING)),(11,("picturePath",T.T_STRING)),(12,("pictureStatus",T.T_STRING))]
default_FriendRequest :: FriendRequest
default_FriendRequest = FriendRequest{
  friendRequest_eMid = "",
  friendRequest_mid = "",
  friendRequest_direction = (P.toEnum 0),
  friendRequest_method = (P.toEnum 0),
  friendRequest_param = "",
  friendRequest_timestamp = 0,
  friendRequest_seqId = 0,
  friendRequest_displayName = "",
  friendRequest_picturePath = "",
  friendRequest_pictureStatus = ""}
data FriendRequestsInfo = FriendRequestsInfo  { friendRequestsInfo_totalIncomingCount :: I.Int32
  , friendRequestsInfo_totalOutgoingCount :: I.Int32
  , friendRequestsInfo_recentIncomings :: (Vector.Vector FriendRequest)
  , friendRequestsInfo_recentOutgoings :: (Vector.Vector FriendRequest)
  , friendRequestsInfo_totalIncomingLimit :: I.Int32
  , friendRequestsInfo_totalOutgoingLimit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FriendRequestsInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` friendRequestsInfo_totalIncomingCount record   `H.hashWithSalt` friendRequestsInfo_totalOutgoingCount record   `H.hashWithSalt` friendRequestsInfo_recentIncomings record   `H.hashWithSalt` friendRequestsInfo_recentOutgoings record   `H.hashWithSalt` friendRequestsInfo_totalIncomingLimit record   `H.hashWithSalt` friendRequestsInfo_totalOutgoingLimit record  
instance QC.Arbitrary FriendRequestsInfo where 
  arbitrary = M.liftM FriendRequestsInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FriendRequestsInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FriendRequestsInfo{friendRequestsInfo_totalIncomingCount = friendRequestsInfo_totalIncomingCount obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_totalIncomingCount = friendRequestsInfo_totalIncomingCount obj}
    , if obj == default_FriendRequestsInfo{friendRequestsInfo_totalOutgoingCount = friendRequestsInfo_totalOutgoingCount obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_totalOutgoingCount = friendRequestsInfo_totalOutgoingCount obj}
    , if obj == default_FriendRequestsInfo{friendRequestsInfo_recentIncomings = friendRequestsInfo_recentIncomings obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_recentIncomings = friendRequestsInfo_recentIncomings obj}
    , if obj == default_FriendRequestsInfo{friendRequestsInfo_recentOutgoings = friendRequestsInfo_recentOutgoings obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_recentOutgoings = friendRequestsInfo_recentOutgoings obj}
    , if obj == default_FriendRequestsInfo{friendRequestsInfo_totalIncomingLimit = friendRequestsInfo_totalIncomingLimit obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_totalIncomingLimit = friendRequestsInfo_totalIncomingLimit obj}
    , if obj == default_FriendRequestsInfo{friendRequestsInfo_totalOutgoingLimit = friendRequestsInfo_totalOutgoingLimit obj} then P.Nothing else P.Just $ default_FriendRequestsInfo{friendRequestsInfo_totalOutgoingLimit = friendRequestsInfo_totalOutgoingLimit obj}
    ]
from_FriendRequestsInfo :: FriendRequestsInfo -> T.ThriftVal
from_FriendRequestsInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1065 -> P.Just (1, ("totalIncomingCount",T.TI32 _v1065))) $ friendRequestsInfo_totalIncomingCount record
  , (\_v1065 -> P.Just (2, ("totalOutgoingCount",T.TI32 _v1065))) $ friendRequestsInfo_totalOutgoingCount record
  , (\_v1065 -> P.Just (3, ("recentIncomings",T.TList (T.T_STRUCT typemap_FriendRequest) $ P.map (\_v1067 -> from_FriendRequest _v1067) $ Vector.toList _v1065))) $ friendRequestsInfo_recentIncomings record
  , (\_v1065 -> P.Just (4, ("recentOutgoings",T.TList (T.T_STRUCT typemap_FriendRequest) $ P.map (\_v1069 -> from_FriendRequest _v1069) $ Vector.toList _v1065))) $ friendRequestsInfo_recentOutgoings record
  , (\_v1065 -> P.Just (5, ("totalIncomingLimit",T.TI32 _v1065))) $ friendRequestsInfo_totalIncomingLimit record
  , (\_v1065 -> P.Just (6, ("totalOutgoingLimit",T.TI32 _v1065))) $ friendRequestsInfo_totalOutgoingLimit record
  ]
write_FriendRequestsInfo :: T.Protocol p => p -> FriendRequestsInfo -> P.IO ()
write_FriendRequestsInfo oprot record = T.writeVal oprot $ from_FriendRequestsInfo record
encode_FriendRequestsInfo :: T.StatelessProtocol p => p -> FriendRequestsInfo -> LBS.ByteString
encode_FriendRequestsInfo oprot record = T.serializeVal oprot $ from_FriendRequestsInfo record
to_FriendRequestsInfo :: T.ThriftVal -> FriendRequestsInfo
to_FriendRequestsInfo (T.TStruct fields) = FriendRequestsInfo{
  friendRequestsInfo_totalIncomingCount = P.maybe (friendRequestsInfo_totalIncomingCount default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TI32 _val1072 -> _val1072; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  friendRequestsInfo_totalOutgoingCount = P.maybe (friendRequestsInfo_totalOutgoingCount default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TI32 _val1073 -> _val1073; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  friendRequestsInfo_recentIncomings = P.maybe (friendRequestsInfo_recentIncomings default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TList _ _val1074 -> (Vector.fromList $ P.map (\_v1075 -> (case _v1075 of {T.TStruct _val1076 -> (to_FriendRequest (T.TStruct _val1076)); _ -> P.error "wrong type"})) _val1074); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  friendRequestsInfo_recentOutgoings = P.maybe (friendRequestsInfo_recentOutgoings default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TList _ _val1077 -> (Vector.fromList $ P.map (\_v1078 -> (case _v1078 of {T.TStruct _val1079 -> (to_FriendRequest (T.TStruct _val1079)); _ -> P.error "wrong type"})) _val1077); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  friendRequestsInfo_totalIncomingLimit = P.maybe (friendRequestsInfo_totalIncomingLimit default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TI32 _val1080 -> _val1080; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  friendRequestsInfo_totalOutgoingLimit = P.maybe (friendRequestsInfo_totalOutgoingLimit default_FriendRequestsInfo) (\(_,_val1071) -> (case _val1071 of {T.TI32 _val1081 -> _val1081; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_FriendRequestsInfo _ = P.error "not a struct"
read_FriendRequestsInfo :: T.Protocol p => p -> P.IO FriendRequestsInfo
read_FriendRequestsInfo iprot = to_FriendRequestsInfo <$> T.readVal iprot (T.T_STRUCT typemap_FriendRequestsInfo)
decode_FriendRequestsInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> FriendRequestsInfo
decode_FriendRequestsInfo iprot bs = to_FriendRequestsInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_FriendRequestsInfo) bs
typemap_FriendRequestsInfo :: T.TypeMap
typemap_FriendRequestsInfo = Map.fromList [(1,("totalIncomingCount",T.T_I32)),(2,("totalOutgoingCount",T.T_I32)),(3,("recentIncomings",(T.T_LIST (T.T_STRUCT typemap_FriendRequest)))),(4,("recentOutgoings",(T.T_LIST (T.T_STRUCT typemap_FriendRequest)))),(5,("totalIncomingLimit",T.T_I32)),(6,("totalOutgoingLimit",T.T_I32))]
default_FriendRequestsInfo :: FriendRequestsInfo
default_FriendRequestsInfo = FriendRequestsInfo{
  friendRequestsInfo_totalIncomingCount = 0,
  friendRequestsInfo_totalOutgoingCount = 0,
  friendRequestsInfo_recentIncomings = Vector.empty,
  friendRequestsInfo_recentOutgoings = Vector.empty,
  friendRequestsInfo_totalIncomingLimit = 0,
  friendRequestsInfo_totalOutgoingLimit = 0}
data Geolocation = Geolocation  { geolocation_longitude :: P.Double
  , geolocation_latitude :: P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Geolocation where
  hashWithSalt salt record = salt   `H.hashWithSalt` geolocation_longitude record   `H.hashWithSalt` geolocation_latitude record  
instance QC.Arbitrary Geolocation where 
  arbitrary = M.liftM Geolocation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Geolocation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Geolocation{geolocation_longitude = geolocation_longitude obj} then P.Nothing else P.Just $ default_Geolocation{geolocation_longitude = geolocation_longitude obj}
    , if obj == default_Geolocation{geolocation_latitude = geolocation_latitude obj} then P.Nothing else P.Just $ default_Geolocation{geolocation_latitude = geolocation_latitude obj}
    ]
from_Geolocation :: Geolocation -> T.ThriftVal
from_Geolocation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1084 -> P.Just (1, ("longitude",T.TDouble _v1084))) $ geolocation_longitude record
  , (\_v1084 -> P.Just (2, ("latitude",T.TDouble _v1084))) $ geolocation_latitude record
  ]
write_Geolocation :: T.Protocol p => p -> Geolocation -> P.IO ()
write_Geolocation oprot record = T.writeVal oprot $ from_Geolocation record
encode_Geolocation :: T.StatelessProtocol p => p -> Geolocation -> LBS.ByteString
encode_Geolocation oprot record = T.serializeVal oprot $ from_Geolocation record
to_Geolocation :: T.ThriftVal -> Geolocation
to_Geolocation (T.TStruct fields) = Geolocation{
  geolocation_longitude = P.maybe (geolocation_longitude default_Geolocation) (\(_,_val1086) -> (case _val1086 of {T.TDouble _val1087 -> _val1087; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  geolocation_latitude = P.maybe (geolocation_latitude default_Geolocation) (\(_,_val1086) -> (case _val1086 of {T.TDouble _val1088 -> _val1088; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Geolocation _ = P.error "not a struct"
read_Geolocation :: T.Protocol p => p -> P.IO Geolocation
read_Geolocation iprot = to_Geolocation <$> T.readVal iprot (T.T_STRUCT typemap_Geolocation)
decode_Geolocation :: T.StatelessProtocol p => p -> LBS.ByteString -> Geolocation
decode_Geolocation iprot bs = to_Geolocation $ T.deserializeVal iprot (T.T_STRUCT typemap_Geolocation) bs
typemap_Geolocation :: T.TypeMap
typemap_Geolocation = Map.fromList [(1,("longitude",T.T_DOUBLE)),(2,("latitude",T.T_DOUBLE))]
default_Geolocation :: Geolocation
default_Geolocation = Geolocation{
  geolocation_longitude = 0,
  geolocation_latitude = 0}
data NotificationTarget = NotificationTarget  { notificationTarget_applicationType :: LT.Text
  , notificationTarget_applicationVersion :: LT.Text
  , notificationTarget_region :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationTarget where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationTarget_applicationType record   `H.hashWithSalt` notificationTarget_applicationVersion record   `H.hashWithSalt` notificationTarget_region record  
instance QC.Arbitrary NotificationTarget where 
  arbitrary = M.liftM NotificationTarget (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationTarget = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationTarget{notificationTarget_applicationType = notificationTarget_applicationType obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_applicationType = notificationTarget_applicationType obj}
    , if obj == default_NotificationTarget{notificationTarget_applicationVersion = notificationTarget_applicationVersion obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_applicationVersion = notificationTarget_applicationVersion obj}
    , if obj == default_NotificationTarget{notificationTarget_region = notificationTarget_region obj} then P.Nothing else P.Just $ default_NotificationTarget{notificationTarget_region = notificationTarget_region obj}
    ]
from_NotificationTarget :: NotificationTarget -> T.ThriftVal
from_NotificationTarget record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1091 -> P.Just (1, ("applicationType",T.TString $ E.encodeUtf8 _v1091))) $ notificationTarget_applicationType record
  , (\_v1091 -> P.Just (2, ("applicationVersion",T.TString $ E.encodeUtf8 _v1091))) $ notificationTarget_applicationVersion record
  , (\_v1091 -> P.Just (3, ("region",T.TString $ E.encodeUtf8 _v1091))) $ notificationTarget_region record
  ]
write_NotificationTarget :: T.Protocol p => p -> NotificationTarget -> P.IO ()
write_NotificationTarget oprot record = T.writeVal oprot $ from_NotificationTarget record
encode_NotificationTarget :: T.StatelessProtocol p => p -> NotificationTarget -> LBS.ByteString
encode_NotificationTarget oprot record = T.serializeVal oprot $ from_NotificationTarget record
to_NotificationTarget :: T.ThriftVal -> NotificationTarget
to_NotificationTarget (T.TStruct fields) = NotificationTarget{
  notificationTarget_applicationType = P.maybe (notificationTarget_applicationType default_NotificationTarget) (\(_,_val1093) -> (case _val1093 of {T.TString _val1094 -> E.decodeUtf8 _val1094; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationTarget_applicationVersion = P.maybe (notificationTarget_applicationVersion default_NotificationTarget) (\(_,_val1093) -> (case _val1093 of {T.TString _val1095 -> E.decodeUtf8 _val1095; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notificationTarget_region = P.maybe (notificationTarget_region default_NotificationTarget) (\(_,_val1093) -> (case _val1093 of {T.TString _val1096 -> E.decodeUtf8 _val1096; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotificationTarget _ = P.error "not a struct"
read_NotificationTarget :: T.Protocol p => p -> P.IO NotificationTarget
read_NotificationTarget iprot = to_NotificationTarget <$> T.readVal iprot (T.T_STRUCT typemap_NotificationTarget)
decode_NotificationTarget :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationTarget
decode_NotificationTarget iprot bs = to_NotificationTarget $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationTarget) bs
typemap_NotificationTarget :: T.TypeMap
typemap_NotificationTarget = Map.fromList [(1,("applicationType",T.T_STRING)),(2,("applicationVersion",T.T_STRING)),(3,("region",T.T_STRING))]
default_NotificationTarget :: NotificationTarget
default_NotificationTarget = NotificationTarget{
  notificationTarget_applicationType = "",
  notificationTarget_applicationVersion = "",
  notificationTarget_region = ""}
data GlobalEvent = GlobalEvent  { globalEvent_key :: LT.Text
  , globalEvent_targets :: (Vector.Vector NotificationTarget)
  , globalEvent_createdTime :: I.Int64
  , globalEvent_data :: I.Int64
  , globalEvent_maxDelay :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GlobalEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` globalEvent_key record   `H.hashWithSalt` globalEvent_targets record   `H.hashWithSalt` globalEvent_createdTime record   `H.hashWithSalt` globalEvent_data record   `H.hashWithSalt` globalEvent_maxDelay record  
instance QC.Arbitrary GlobalEvent where 
  arbitrary = M.liftM GlobalEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GlobalEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GlobalEvent{globalEvent_key = globalEvent_key obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_key = globalEvent_key obj}
    , if obj == default_GlobalEvent{globalEvent_targets = globalEvent_targets obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_targets = globalEvent_targets obj}
    , if obj == default_GlobalEvent{globalEvent_createdTime = globalEvent_createdTime obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_createdTime = globalEvent_createdTime obj}
    , if obj == default_GlobalEvent{globalEvent_data = globalEvent_data obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_data = globalEvent_data obj}
    , if obj == default_GlobalEvent{globalEvent_maxDelay = globalEvent_maxDelay obj} then P.Nothing else P.Just $ default_GlobalEvent{globalEvent_maxDelay = globalEvent_maxDelay obj}
    ]
from_GlobalEvent :: GlobalEvent -> T.ThriftVal
from_GlobalEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1099 -> P.Just (1, ("key",T.TString $ E.encodeUtf8 _v1099))) $ globalEvent_key record
  , (\_v1099 -> P.Just (2, ("targets",T.TList (T.T_STRUCT typemap_NotificationTarget) $ P.map (\_v1101 -> from_NotificationTarget _v1101) $ Vector.toList _v1099))) $ globalEvent_targets record
  , (\_v1099 -> P.Just (3, ("createdTime",T.TI64 _v1099))) $ globalEvent_createdTime record
  , (\_v1099 -> P.Just (4, ("data",T.TI64 _v1099))) $ globalEvent_data record
  , (\_v1099 -> P.Just (5, ("maxDelay",T.TI32 _v1099))) $ globalEvent_maxDelay record
  ]
write_GlobalEvent :: T.Protocol p => p -> GlobalEvent -> P.IO ()
write_GlobalEvent oprot record = T.writeVal oprot $ from_GlobalEvent record
encode_GlobalEvent :: T.StatelessProtocol p => p -> GlobalEvent -> LBS.ByteString
encode_GlobalEvent oprot record = T.serializeVal oprot $ from_GlobalEvent record
to_GlobalEvent :: T.ThriftVal -> GlobalEvent
to_GlobalEvent (T.TStruct fields) = GlobalEvent{
  globalEvent_key = P.maybe (globalEvent_key default_GlobalEvent) (\(_,_val1103) -> (case _val1103 of {T.TString _val1104 -> E.decodeUtf8 _val1104; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  globalEvent_targets = P.maybe (globalEvent_targets default_GlobalEvent) (\(_,_val1103) -> (case _val1103 of {T.TList _ _val1105 -> (Vector.fromList $ P.map (\_v1106 -> (case _v1106 of {T.TStruct _val1107 -> (to_NotificationTarget (T.TStruct _val1107)); _ -> P.error "wrong type"})) _val1105); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  globalEvent_createdTime = P.maybe (globalEvent_createdTime default_GlobalEvent) (\(_,_val1103) -> (case _val1103 of {T.TI64 _val1108 -> _val1108; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  globalEvent_data = P.maybe (globalEvent_data default_GlobalEvent) (\(_,_val1103) -> (case _val1103 of {T.TI64 _val1109 -> _val1109; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  globalEvent_maxDelay = P.maybe (globalEvent_maxDelay default_GlobalEvent) (\(_,_val1103) -> (case _val1103 of {T.TI32 _val1110 -> _val1110; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GlobalEvent _ = P.error "not a struct"
read_GlobalEvent :: T.Protocol p => p -> P.IO GlobalEvent
read_GlobalEvent iprot = to_GlobalEvent <$> T.readVal iprot (T.T_STRUCT typemap_GlobalEvent)
decode_GlobalEvent :: T.StatelessProtocol p => p -> LBS.ByteString -> GlobalEvent
decode_GlobalEvent iprot bs = to_GlobalEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_GlobalEvent) bs
typemap_GlobalEvent :: T.TypeMap
typemap_GlobalEvent = Map.fromList [(1,("key",T.T_STRING)),(2,("targets",(T.T_LIST (T.T_STRUCT typemap_NotificationTarget)))),(3,("createdTime",T.T_I64)),(4,("data",T.T_I64)),(5,("maxDelay",T.T_I32))]
default_GlobalEvent :: GlobalEvent
default_GlobalEvent = GlobalEvent{
  globalEvent_key = "",
  globalEvent_targets = Vector.empty,
  globalEvent_createdTime = 0,
  globalEvent_data = 0,
  globalEvent_maxDelay = 0}
data GroupPreference = GroupPreference  { groupPreference_invitationTicket :: LT.Text
  , groupPreference_favoriteTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GroupPreference where
  hashWithSalt salt record = salt   `H.hashWithSalt` groupPreference_invitationTicket record   `H.hashWithSalt` groupPreference_favoriteTimestamp record  
instance QC.Arbitrary GroupPreference where 
  arbitrary = M.liftM GroupPreference (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GroupPreference = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GroupPreference{groupPreference_invitationTicket = groupPreference_invitationTicket obj} then P.Nothing else P.Just $ default_GroupPreference{groupPreference_invitationTicket = groupPreference_invitationTicket obj}
    , if obj == default_GroupPreference{groupPreference_favoriteTimestamp = groupPreference_favoriteTimestamp obj} then P.Nothing else P.Just $ default_GroupPreference{groupPreference_favoriteTimestamp = groupPreference_favoriteTimestamp obj}
    ]
from_GroupPreference :: GroupPreference -> T.ThriftVal
from_GroupPreference record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1113 -> P.Just (1, ("invitationTicket",T.TString $ E.encodeUtf8 _v1113))) $ groupPreference_invitationTicket record
  , (\_v1113 -> P.Just (2, ("favoriteTimestamp",T.TI64 _v1113))) $ groupPreference_favoriteTimestamp record
  ]
write_GroupPreference :: T.Protocol p => p -> GroupPreference -> P.IO ()
write_GroupPreference oprot record = T.writeVal oprot $ from_GroupPreference record
encode_GroupPreference :: T.StatelessProtocol p => p -> GroupPreference -> LBS.ByteString
encode_GroupPreference oprot record = T.serializeVal oprot $ from_GroupPreference record
to_GroupPreference :: T.ThriftVal -> GroupPreference
to_GroupPreference (T.TStruct fields) = GroupPreference{
  groupPreference_invitationTicket = P.maybe (groupPreference_invitationTicket default_GroupPreference) (\(_,_val1115) -> (case _val1115 of {T.TString _val1116 -> E.decodeUtf8 _val1116; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  groupPreference_favoriteTimestamp = P.maybe (groupPreference_favoriteTimestamp default_GroupPreference) (\(_,_val1115) -> (case _val1115 of {T.TI64 _val1117 -> _val1117; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GroupPreference _ = P.error "not a struct"
read_GroupPreference :: T.Protocol p => p -> P.IO GroupPreference
read_GroupPreference iprot = to_GroupPreference <$> T.readVal iprot (T.T_STRUCT typemap_GroupPreference)
decode_GroupPreference :: T.StatelessProtocol p => p -> LBS.ByteString -> GroupPreference
decode_GroupPreference iprot bs = to_GroupPreference $ T.deserializeVal iprot (T.T_STRUCT typemap_GroupPreference) bs
typemap_GroupPreference :: T.TypeMap
typemap_GroupPreference = Map.fromList [(1,("invitationTicket",T.T_STRING)),(2,("favoriteTimestamp",T.T_I64))]
default_GroupPreference :: GroupPreference
default_GroupPreference = GroupPreference{
  groupPreference_invitationTicket = "",
  groupPreference_favoriteTimestamp = 0}
data Group = Group  { group_id :: LT.Text
  , group_createdTime :: I.Int64
  , group_name :: LT.Text
  , group_pictureStatus :: LT.Text
  , group_preventedJoinByTicket :: P.Bool
  , group_groupPreference :: GroupPreference
  , group_members :: (Vector.Vector Contact)
  , group_creator :: Contact
  , group_invitee :: (Vector.Vector Contact)
  , group_notificationDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Group where
  hashWithSalt salt record = salt   `H.hashWithSalt` group_id record   `H.hashWithSalt` group_createdTime record   `H.hashWithSalt` group_name record   `H.hashWithSalt` group_pictureStatus record   `H.hashWithSalt` group_preventedJoinByTicket record   `H.hashWithSalt` group_groupPreference record   `H.hashWithSalt` group_members record   `H.hashWithSalt` group_creator record   `H.hashWithSalt` group_invitee record   `H.hashWithSalt` group_notificationDisabled record  
instance QC.Arbitrary Group where 
  arbitrary = M.liftM Group (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Group = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Group{group_id = group_id obj} then P.Nothing else P.Just $ default_Group{group_id = group_id obj}
    , if obj == default_Group{group_createdTime = group_createdTime obj} then P.Nothing else P.Just $ default_Group{group_createdTime = group_createdTime obj}
    , if obj == default_Group{group_name = group_name obj} then P.Nothing else P.Just $ default_Group{group_name = group_name obj}
    , if obj == default_Group{group_pictureStatus = group_pictureStatus obj} then P.Nothing else P.Just $ default_Group{group_pictureStatus = group_pictureStatus obj}
    , if obj == default_Group{group_preventedJoinByTicket = group_preventedJoinByTicket obj} then P.Nothing else P.Just $ default_Group{group_preventedJoinByTicket = group_preventedJoinByTicket obj}
    , if obj == default_Group{group_groupPreference = group_groupPreference obj} then P.Nothing else P.Just $ default_Group{group_groupPreference = group_groupPreference obj}
    , if obj == default_Group{group_members = group_members obj} then P.Nothing else P.Just $ default_Group{group_members = group_members obj}
    , if obj == default_Group{group_creator = group_creator obj} then P.Nothing else P.Just $ default_Group{group_creator = group_creator obj}
    , if obj == default_Group{group_invitee = group_invitee obj} then P.Nothing else P.Just $ default_Group{group_invitee = group_invitee obj}
    , if obj == default_Group{group_notificationDisabled = group_notificationDisabled obj} then P.Nothing else P.Just $ default_Group{group_notificationDisabled = group_notificationDisabled obj}
    ]
from_Group :: Group -> T.ThriftVal
from_Group record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1120 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1120))) $ group_id record
  , (\_v1120 -> P.Just (2, ("createdTime",T.TI64 _v1120))) $ group_createdTime record
  , (\_v1120 -> P.Just (10, ("name",T.TString $ E.encodeUtf8 _v1120))) $ group_name record
  , (\_v1120 -> P.Just (11, ("pictureStatus",T.TString $ E.encodeUtf8 _v1120))) $ group_pictureStatus record
  , (\_v1120 -> P.Just (12, ("preventedJoinByTicket",T.TBool _v1120))) $ group_preventedJoinByTicket record
  , (\_v1120 -> P.Just (13, ("groupPreference",from_GroupPreference _v1120))) $ group_groupPreference record
  , (\_v1120 -> P.Just (20, ("members",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1122 -> from_Contact _v1122) $ Vector.toList _v1120))) $ group_members record
  , (\_v1120 -> P.Just (21, ("creator",from_Contact _v1120))) $ group_creator record
  , (\_v1120 -> P.Just (22, ("invitee",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1124 -> from_Contact _v1124) $ Vector.toList _v1120))) $ group_invitee record
  , (\_v1120 -> P.Just (31, ("notificationDisabled",T.TBool _v1120))) $ group_notificationDisabled record
  ]
write_Group :: T.Protocol p => p -> Group -> P.IO ()
write_Group oprot record = T.writeVal oprot $ from_Group record
encode_Group :: T.StatelessProtocol p => p -> Group -> LBS.ByteString
encode_Group oprot record = T.serializeVal oprot $ from_Group record
to_Group :: T.ThriftVal -> Group
to_Group (T.TStruct fields) = Group{
  group_id = P.maybe (group_id default_Group) (\(_,_val1126) -> (case _val1126 of {T.TString _val1127 -> E.decodeUtf8 _val1127; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  group_createdTime = P.maybe (group_createdTime default_Group) (\(_,_val1126) -> (case _val1126 of {T.TI64 _val1128 -> _val1128; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  group_name = P.maybe (group_name default_Group) (\(_,_val1126) -> (case _val1126 of {T.TString _val1129 -> E.decodeUtf8 _val1129; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  group_pictureStatus = P.maybe (group_pictureStatus default_Group) (\(_,_val1126) -> (case _val1126 of {T.TString _val1130 -> E.decodeUtf8 _val1130; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  group_preventedJoinByTicket = P.maybe (group_preventedJoinByTicket default_Group) (\(_,_val1126) -> (case _val1126 of {T.TBool _val1131 -> _val1131; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  group_groupPreference = P.maybe (group_groupPreference default_Group) (\(_,_val1126) -> (case _val1126 of {T.TStruct _val1132 -> (to_GroupPreference (T.TStruct _val1132)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  group_members = P.maybe (group_members default_Group) (\(_,_val1126) -> (case _val1126 of {T.TList _ _val1133 -> (Vector.fromList $ P.map (\_v1134 -> (case _v1134 of {T.TStruct _val1135 -> (to_Contact (T.TStruct _val1135)); _ -> P.error "wrong type"})) _val1133); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  group_creator = P.maybe (group_creator default_Group) (\(_,_val1126) -> (case _val1126 of {T.TStruct _val1136 -> (to_Contact (T.TStruct _val1136)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  group_invitee = P.maybe (group_invitee default_Group) (\(_,_val1126) -> (case _val1126 of {T.TList _ _val1137 -> (Vector.fromList $ P.map (\_v1138 -> (case _v1138 of {T.TStruct _val1139 -> (to_Contact (T.TStruct _val1139)); _ -> P.error "wrong type"})) _val1137); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  group_notificationDisabled = P.maybe (group_notificationDisabled default_Group) (\(_,_val1126) -> (case _val1126 of {T.TBool _val1140 -> _val1140; _ -> P.error "wrong type"})) (Map.lookup (31) fields)
  }
to_Group _ = P.error "not a struct"
read_Group :: T.Protocol p => p -> P.IO Group
read_Group iprot = to_Group <$> T.readVal iprot (T.T_STRUCT typemap_Group)
decode_Group :: T.StatelessProtocol p => p -> LBS.ByteString -> Group
decode_Group iprot bs = to_Group $ T.deserializeVal iprot (T.T_STRUCT typemap_Group) bs
typemap_Group :: T.TypeMap
typemap_Group = Map.fromList [(1,("id",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("name",T.T_STRING)),(11,("pictureStatus",T.T_STRING)),(12,("preventedJoinByTicket",T.T_BOOL)),(13,("groupPreference",(T.T_STRUCT typemap_GroupPreference))),(20,("members",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(21,("creator",(T.T_STRUCT typemap_Contact))),(22,("invitee",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(31,("notificationDisabled",T.T_BOOL))]
default_Group :: Group
default_Group = Group{
  group_id = "",
  group_createdTime = 0,
  group_name = "",
  group_pictureStatus = "",
  group_preventedJoinByTicket = P.False,
  group_groupPreference = default_GroupPreference,
  group_members = Vector.empty,
  group_creator = default_Contact,
  group_invitee = Vector.empty,
  group_notificationDisabled = P.False}
data IdentityCredential = IdentityCredential  { identityCredential_provider :: IdentityProvider
  , identityCredential_identifier :: LT.Text
  , identityCredential_password :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IdentityCredential where
  hashWithSalt salt record = salt   `H.hashWithSalt` identityCredential_provider record   `H.hashWithSalt` identityCredential_identifier record   `H.hashWithSalt` identityCredential_password record  
instance QC.Arbitrary IdentityCredential where 
  arbitrary = M.liftM IdentityCredential (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IdentityCredential = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IdentityCredential{identityCredential_provider = identityCredential_provider obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_provider = identityCredential_provider obj}
    , if obj == default_IdentityCredential{identityCredential_identifier = identityCredential_identifier obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_identifier = identityCredential_identifier obj}
    , if obj == default_IdentityCredential{identityCredential_password = identityCredential_password obj} then P.Nothing else P.Just $ default_IdentityCredential{identityCredential_password = identityCredential_password obj}
    ]
from_IdentityCredential :: IdentityCredential -> T.ThriftVal
from_IdentityCredential record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1143 -> P.Just (1, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v1143))) $ identityCredential_provider record
  , (\_v1143 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v1143))) $ identityCredential_identifier record
  , (\_v1143 -> P.Just (3, ("password",T.TString $ E.encodeUtf8 _v1143))) $ identityCredential_password record
  ]
write_IdentityCredential :: T.Protocol p => p -> IdentityCredential -> P.IO ()
write_IdentityCredential oprot record = T.writeVal oprot $ from_IdentityCredential record
encode_IdentityCredential :: T.StatelessProtocol p => p -> IdentityCredential -> LBS.ByteString
encode_IdentityCredential oprot record = T.serializeVal oprot $ from_IdentityCredential record
to_IdentityCredential :: T.ThriftVal -> IdentityCredential
to_IdentityCredential (T.TStruct fields) = IdentityCredential{
  identityCredential_provider = P.maybe (identityCredential_provider default_IdentityCredential) (\(_,_val1145) -> (case _val1145 of {T.TI32 _val1146 -> P.toEnum $ P.fromIntegral _val1146; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  identityCredential_identifier = P.maybe (identityCredential_identifier default_IdentityCredential) (\(_,_val1145) -> (case _val1145 of {T.TString _val1147 -> E.decodeUtf8 _val1147; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  identityCredential_password = P.maybe (identityCredential_password default_IdentityCredential) (\(_,_val1145) -> (case _val1145 of {T.TString _val1148 -> E.decodeUtf8 _val1148; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_IdentityCredential _ = P.error "not a struct"
read_IdentityCredential :: T.Protocol p => p -> P.IO IdentityCredential
read_IdentityCredential iprot = to_IdentityCredential <$> T.readVal iprot (T.T_STRUCT typemap_IdentityCredential)
decode_IdentityCredential :: T.StatelessProtocol p => p -> LBS.ByteString -> IdentityCredential
decode_IdentityCredential iprot bs = to_IdentityCredential $ T.deserializeVal iprot (T.T_STRUCT typemap_IdentityCredential) bs
typemap_IdentityCredential :: T.TypeMap
typemap_IdentityCredential = Map.fromList [(1,("provider",T.T_I32)),(2,("identifier",T.T_STRING)),(3,("password",T.T_STRING))]
default_IdentityCredential :: IdentityCredential
default_IdentityCredential = IdentityCredential{
  identityCredential_provider = (P.toEnum 0),
  identityCredential_identifier = "",
  identityCredential_password = ""}
data LastReadMessageId = LastReadMessageId  { lastReadMessageId_mid :: LT.Text
  , lastReadMessageId_lastReadMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LastReadMessageId where
  hashWithSalt salt record = salt   `H.hashWithSalt` lastReadMessageId_mid record   `H.hashWithSalt` lastReadMessageId_lastReadMessageId record  
instance QC.Arbitrary LastReadMessageId where 
  arbitrary = M.liftM LastReadMessageId (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LastReadMessageId = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LastReadMessageId{lastReadMessageId_mid = lastReadMessageId_mid obj} then P.Nothing else P.Just $ default_LastReadMessageId{lastReadMessageId_mid = lastReadMessageId_mid obj}
    , if obj == default_LastReadMessageId{lastReadMessageId_lastReadMessageId = lastReadMessageId_lastReadMessageId obj} then P.Nothing else P.Just $ default_LastReadMessageId{lastReadMessageId_lastReadMessageId = lastReadMessageId_lastReadMessageId obj}
    ]
from_LastReadMessageId :: LastReadMessageId -> T.ThriftVal
from_LastReadMessageId record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1151 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v1151))) $ lastReadMessageId_mid record
  , (\_v1151 -> P.Just (2, ("lastReadMessageId",T.TString $ E.encodeUtf8 _v1151))) $ lastReadMessageId_lastReadMessageId record
  ]
write_LastReadMessageId :: T.Protocol p => p -> LastReadMessageId -> P.IO ()
write_LastReadMessageId oprot record = T.writeVal oprot $ from_LastReadMessageId record
encode_LastReadMessageId :: T.StatelessProtocol p => p -> LastReadMessageId -> LBS.ByteString
encode_LastReadMessageId oprot record = T.serializeVal oprot $ from_LastReadMessageId record
to_LastReadMessageId :: T.ThriftVal -> LastReadMessageId
to_LastReadMessageId (T.TStruct fields) = LastReadMessageId{
  lastReadMessageId_mid = P.maybe (lastReadMessageId_mid default_LastReadMessageId) (\(_,_val1153) -> (case _val1153 of {T.TString _val1154 -> E.decodeUtf8 _val1154; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lastReadMessageId_lastReadMessageId = P.maybe (lastReadMessageId_lastReadMessageId default_LastReadMessageId) (\(_,_val1153) -> (case _val1153 of {T.TString _val1155 -> E.decodeUtf8 _val1155; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LastReadMessageId _ = P.error "not a struct"
read_LastReadMessageId :: T.Protocol p => p -> P.IO LastReadMessageId
read_LastReadMessageId iprot = to_LastReadMessageId <$> T.readVal iprot (T.T_STRUCT typemap_LastReadMessageId)
decode_LastReadMessageId :: T.StatelessProtocol p => p -> LBS.ByteString -> LastReadMessageId
decode_LastReadMessageId iprot bs = to_LastReadMessageId $ T.deserializeVal iprot (T.T_STRUCT typemap_LastReadMessageId) bs
typemap_LastReadMessageId :: T.TypeMap
typemap_LastReadMessageId = Map.fromList [(1,("mid",T.T_STRING)),(2,("lastReadMessageId",T.T_STRING))]
default_LastReadMessageId :: LastReadMessageId
default_LastReadMessageId = LastReadMessageId{
  lastReadMessageId_mid = "",
  lastReadMessageId_lastReadMessageId = ""}
data LastReadMessageIds = LastReadMessageIds  { lastReadMessageIds_chatId :: LT.Text
  , lastReadMessageIds_lastReadMessageIds :: (Vector.Vector LastReadMessageId)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LastReadMessageIds where
  hashWithSalt salt record = salt   `H.hashWithSalt` lastReadMessageIds_chatId record   `H.hashWithSalt` lastReadMessageIds_lastReadMessageIds record  
instance QC.Arbitrary LastReadMessageIds where 
  arbitrary = M.liftM LastReadMessageIds (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LastReadMessageIds = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LastReadMessageIds{lastReadMessageIds_chatId = lastReadMessageIds_chatId obj} then P.Nothing else P.Just $ default_LastReadMessageIds{lastReadMessageIds_chatId = lastReadMessageIds_chatId obj}
    , if obj == default_LastReadMessageIds{lastReadMessageIds_lastReadMessageIds = lastReadMessageIds_lastReadMessageIds obj} then P.Nothing else P.Just $ default_LastReadMessageIds{lastReadMessageIds_lastReadMessageIds = lastReadMessageIds_lastReadMessageIds obj}
    ]
from_LastReadMessageIds :: LastReadMessageIds -> T.ThriftVal
from_LastReadMessageIds record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1158 -> P.Just (1, ("chatId",T.TString $ E.encodeUtf8 _v1158))) $ lastReadMessageIds_chatId record
  , (\_v1158 -> P.Just (2, ("lastReadMessageIds",T.TList (T.T_STRUCT typemap_LastReadMessageId) $ P.map (\_v1160 -> from_LastReadMessageId _v1160) $ Vector.toList _v1158))) $ lastReadMessageIds_lastReadMessageIds record
  ]
write_LastReadMessageIds :: T.Protocol p => p -> LastReadMessageIds -> P.IO ()
write_LastReadMessageIds oprot record = T.writeVal oprot $ from_LastReadMessageIds record
encode_LastReadMessageIds :: T.StatelessProtocol p => p -> LastReadMessageIds -> LBS.ByteString
encode_LastReadMessageIds oprot record = T.serializeVal oprot $ from_LastReadMessageIds record
to_LastReadMessageIds :: T.ThriftVal -> LastReadMessageIds
to_LastReadMessageIds (T.TStruct fields) = LastReadMessageIds{
  lastReadMessageIds_chatId = P.maybe (lastReadMessageIds_chatId default_LastReadMessageIds) (\(_,_val1162) -> (case _val1162 of {T.TString _val1163 -> E.decodeUtf8 _val1163; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lastReadMessageIds_lastReadMessageIds = P.maybe (lastReadMessageIds_lastReadMessageIds default_LastReadMessageIds) (\(_,_val1162) -> (case _val1162 of {T.TList _ _val1164 -> (Vector.fromList $ P.map (\_v1165 -> (case _v1165 of {T.TStruct _val1166 -> (to_LastReadMessageId (T.TStruct _val1166)); _ -> P.error "wrong type"})) _val1164); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LastReadMessageIds _ = P.error "not a struct"
read_LastReadMessageIds :: T.Protocol p => p -> P.IO LastReadMessageIds
read_LastReadMessageIds iprot = to_LastReadMessageIds <$> T.readVal iprot (T.T_STRUCT typemap_LastReadMessageIds)
decode_LastReadMessageIds :: T.StatelessProtocol p => p -> LBS.ByteString -> LastReadMessageIds
decode_LastReadMessageIds iprot bs = to_LastReadMessageIds $ T.deserializeVal iprot (T.T_STRUCT typemap_LastReadMessageIds) bs
typemap_LastReadMessageIds :: T.TypeMap
typemap_LastReadMessageIds = Map.fromList [(1,("chatId",T.T_STRING)),(2,("lastReadMessageIds",(T.T_LIST (T.T_STRUCT typemap_LastReadMessageId))))]
default_LastReadMessageIds :: LastReadMessageIds
default_LastReadMessageIds = LastReadMessageIds{
  lastReadMessageIds_chatId = "",
  lastReadMessageIds_lastReadMessageIds = Vector.empty}
data VerificationSessionData = VerificationSessionData  { verificationSessionData_sessionId :: LT.Text
  , verificationSessionData_method :: VerificationMethod
  , verificationSessionData_callback :: LT.Text
  , verificationSessionData_normalizedPhone :: LT.Text
  , verificationSessionData_countryCode :: LT.Text
  , verificationSessionData_nationalSignificantNumber :: LT.Text
  , verificationSessionData_availableVerificationMethods :: (Vector.Vector VerificationMethod)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerificationSessionData where
  hashWithSalt salt record = salt   `H.hashWithSalt` verificationSessionData_sessionId record   `H.hashWithSalt` verificationSessionData_method record   `H.hashWithSalt` verificationSessionData_callback record   `H.hashWithSalt` verificationSessionData_normalizedPhone record   `H.hashWithSalt` verificationSessionData_countryCode record   `H.hashWithSalt` verificationSessionData_nationalSignificantNumber record   `H.hashWithSalt` verificationSessionData_availableVerificationMethods record  
instance QC.Arbitrary VerificationSessionData where 
  arbitrary = M.liftM VerificationSessionData (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerificationSessionData = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerificationSessionData{verificationSessionData_sessionId = verificationSessionData_sessionId obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_sessionId = verificationSessionData_sessionId obj}
    , if obj == default_VerificationSessionData{verificationSessionData_method = verificationSessionData_method obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_method = verificationSessionData_method obj}
    , if obj == default_VerificationSessionData{verificationSessionData_callback = verificationSessionData_callback obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_callback = verificationSessionData_callback obj}
    , if obj == default_VerificationSessionData{verificationSessionData_normalizedPhone = verificationSessionData_normalizedPhone obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_normalizedPhone = verificationSessionData_normalizedPhone obj}
    , if obj == default_VerificationSessionData{verificationSessionData_countryCode = verificationSessionData_countryCode obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_countryCode = verificationSessionData_countryCode obj}
    , if obj == default_VerificationSessionData{verificationSessionData_nationalSignificantNumber = verificationSessionData_nationalSignificantNumber obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_nationalSignificantNumber = verificationSessionData_nationalSignificantNumber obj}
    , if obj == default_VerificationSessionData{verificationSessionData_availableVerificationMethods = verificationSessionData_availableVerificationMethods obj} then P.Nothing else P.Just $ default_VerificationSessionData{verificationSessionData_availableVerificationMethods = verificationSessionData_availableVerificationMethods obj}
    ]
from_VerificationSessionData :: VerificationSessionData -> T.ThriftVal
from_VerificationSessionData record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1169 -> P.Just (1, ("sessionId",T.TString $ E.encodeUtf8 _v1169))) $ verificationSessionData_sessionId record
  , (\_v1169 -> P.Just (2, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v1169))) $ verificationSessionData_method record
  , (\_v1169 -> P.Just (3, ("callback",T.TString $ E.encodeUtf8 _v1169))) $ verificationSessionData_callback record
  , (\_v1169 -> P.Just (4, ("normalizedPhone",T.TString $ E.encodeUtf8 _v1169))) $ verificationSessionData_normalizedPhone record
  , (\_v1169 -> P.Just (5, ("countryCode",T.TString $ E.encodeUtf8 _v1169))) $ verificationSessionData_countryCode record
  , (\_v1169 -> P.Just (6, ("nationalSignificantNumber",T.TString $ E.encodeUtf8 _v1169))) $ verificationSessionData_nationalSignificantNumber record
  , (\_v1169 -> P.Just (7, ("availableVerificationMethods",T.TList T.T_I32 $ P.map (\_v1171 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v1171) $ Vector.toList _v1169))) $ verificationSessionData_availableVerificationMethods record
  ]
write_VerificationSessionData :: T.Protocol p => p -> VerificationSessionData -> P.IO ()
write_VerificationSessionData oprot record = T.writeVal oprot $ from_VerificationSessionData record
encode_VerificationSessionData :: T.StatelessProtocol p => p -> VerificationSessionData -> LBS.ByteString
encode_VerificationSessionData oprot record = T.serializeVal oprot $ from_VerificationSessionData record
to_VerificationSessionData :: T.ThriftVal -> VerificationSessionData
to_VerificationSessionData (T.TStruct fields) = VerificationSessionData{
  verificationSessionData_sessionId = P.maybe (verificationSessionData_sessionId default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TString _val1174 -> E.decodeUtf8 _val1174; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  verificationSessionData_method = P.maybe (verificationSessionData_method default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TI32 _val1175 -> P.toEnum $ P.fromIntegral _val1175; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verificationSessionData_callback = P.maybe (verificationSessionData_callback default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TString _val1176 -> E.decodeUtf8 _val1176; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verificationSessionData_normalizedPhone = P.maybe (verificationSessionData_normalizedPhone default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TString _val1177 -> E.decodeUtf8 _val1177; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  verificationSessionData_countryCode = P.maybe (verificationSessionData_countryCode default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TString _val1178 -> E.decodeUtf8 _val1178; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  verificationSessionData_nationalSignificantNumber = P.maybe (verificationSessionData_nationalSignificantNumber default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TString _val1179 -> E.decodeUtf8 _val1179; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  verificationSessionData_availableVerificationMethods = P.maybe (verificationSessionData_availableVerificationMethods default_VerificationSessionData) (\(_,_val1173) -> (case _val1173 of {T.TList _ _val1180 -> (Vector.fromList $ P.map (\_v1181 -> (case _v1181 of {T.TI32 _val1182 -> P.toEnum $ P.fromIntegral _val1182; _ -> P.error "wrong type"})) _val1180); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_VerificationSessionData _ = P.error "not a struct"
read_VerificationSessionData :: T.Protocol p => p -> P.IO VerificationSessionData
read_VerificationSessionData iprot = to_VerificationSessionData <$> T.readVal iprot (T.T_STRUCT typemap_VerificationSessionData)
decode_VerificationSessionData :: T.StatelessProtocol p => p -> LBS.ByteString -> VerificationSessionData
decode_VerificationSessionData iprot bs = to_VerificationSessionData $ T.deserializeVal iprot (T.T_STRUCT typemap_VerificationSessionData) bs
typemap_VerificationSessionData :: T.TypeMap
typemap_VerificationSessionData = Map.fromList [(1,("sessionId",T.T_STRING)),(2,("method",T.T_I32)),(3,("callback",T.T_STRING)),(4,("normalizedPhone",T.T_STRING)),(5,("countryCode",T.T_STRING)),(6,("nationalSignificantNumber",T.T_STRING)),(7,("availableVerificationMethods",(T.T_LIST T.T_I32)))]
default_VerificationSessionData :: VerificationSessionData
default_VerificationSessionData = VerificationSessionData{
  verificationSessionData_sessionId = "",
  verificationSessionData_method = (P.toEnum 0),
  verificationSessionData_callback = "",
  verificationSessionData_normalizedPhone = "",
  verificationSessionData_countryCode = "",
  verificationSessionData_nationalSignificantNumber = "",
  verificationSessionData_availableVerificationMethods = Vector.empty}
data LoginResult = LoginResult  { loginResult_authToken :: LT.Text
  , loginResult_certificate :: LT.Text
  , loginResult_verifier :: LT.Text
  , loginResult_pinCode :: LT.Text
  , loginResult_type :: LoginResultType
  , loginResult_lastPrimaryBindTime :: I.Int64
  , loginResult_displayMessage :: LT.Text
  , loginResult_sessionForSMSConfirm :: VerificationSessionData
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginResult_authToken record   `H.hashWithSalt` loginResult_certificate record   `H.hashWithSalt` loginResult_verifier record   `H.hashWithSalt` loginResult_pinCode record   `H.hashWithSalt` loginResult_type record   `H.hashWithSalt` loginResult_lastPrimaryBindTime record   `H.hashWithSalt` loginResult_displayMessage record   `H.hashWithSalt` loginResult_sessionForSMSConfirm record  
instance QC.Arbitrary LoginResult where 
  arbitrary = M.liftM LoginResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginResult{loginResult_authToken = loginResult_authToken obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_authToken = loginResult_authToken obj}
    , if obj == default_LoginResult{loginResult_certificate = loginResult_certificate obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_certificate = loginResult_certificate obj}
    , if obj == default_LoginResult{loginResult_verifier = loginResult_verifier obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_verifier = loginResult_verifier obj}
    , if obj == default_LoginResult{loginResult_pinCode = loginResult_pinCode obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_pinCode = loginResult_pinCode obj}
    , if obj == default_LoginResult{loginResult_type = loginResult_type obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_type = loginResult_type obj}
    , if obj == default_LoginResult{loginResult_lastPrimaryBindTime = loginResult_lastPrimaryBindTime obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_lastPrimaryBindTime = loginResult_lastPrimaryBindTime obj}
    , if obj == default_LoginResult{loginResult_displayMessage = loginResult_displayMessage obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_displayMessage = loginResult_displayMessage obj}
    , if obj == default_LoginResult{loginResult_sessionForSMSConfirm = loginResult_sessionForSMSConfirm obj} then P.Nothing else P.Just $ default_LoginResult{loginResult_sessionForSMSConfirm = loginResult_sessionForSMSConfirm obj}
    ]
from_LoginResult :: LoginResult -> T.ThriftVal
from_LoginResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1185 -> P.Just (1, ("authToken",T.TString $ E.encodeUtf8 _v1185))) $ loginResult_authToken record
  , (\_v1185 -> P.Just (2, ("certificate",T.TString $ E.encodeUtf8 _v1185))) $ loginResult_certificate record
  , (\_v1185 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v1185))) $ loginResult_verifier record
  , (\_v1185 -> P.Just (4, ("pinCode",T.TString $ E.encodeUtf8 _v1185))) $ loginResult_pinCode record
  , (\_v1185 -> P.Just (5, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1185))) $ loginResult_type record
  , (\_v1185 -> P.Just (6, ("lastPrimaryBindTime",T.TI64 _v1185))) $ loginResult_lastPrimaryBindTime record
  , (\_v1185 -> P.Just (7, ("displayMessage",T.TString $ E.encodeUtf8 _v1185))) $ loginResult_displayMessage record
  , (\_v1185 -> P.Just (8, ("sessionForSMSConfirm",from_VerificationSessionData _v1185))) $ loginResult_sessionForSMSConfirm record
  ]
write_LoginResult :: T.Protocol p => p -> LoginResult -> P.IO ()
write_LoginResult oprot record = T.writeVal oprot $ from_LoginResult record
encode_LoginResult :: T.StatelessProtocol p => p -> LoginResult -> LBS.ByteString
encode_LoginResult oprot record = T.serializeVal oprot $ from_LoginResult record
to_LoginResult :: T.ThriftVal -> LoginResult
to_LoginResult (T.TStruct fields) = LoginResult{
  loginResult_authToken = P.maybe (loginResult_authToken default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TString _val1188 -> E.decodeUtf8 _val1188; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  loginResult_certificate = P.maybe (loginResult_certificate default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TString _val1189 -> E.decodeUtf8 _val1189; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  loginResult_verifier = P.maybe (loginResult_verifier default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TString _val1190 -> E.decodeUtf8 _val1190; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginResult_pinCode = P.maybe (loginResult_pinCode default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TString _val1191 -> E.decodeUtf8 _val1191; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginResult_type = P.maybe (loginResult_type default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TI32 _val1192 -> P.toEnum $ P.fromIntegral _val1192; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginResult_lastPrimaryBindTime = P.maybe (loginResult_lastPrimaryBindTime default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TI64 _val1193 -> _val1193; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginResult_displayMessage = P.maybe (loginResult_displayMessage default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TString _val1194 -> E.decodeUtf8 _val1194; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginResult_sessionForSMSConfirm = P.maybe (loginResult_sessionForSMSConfirm default_LoginResult) (\(_,_val1187) -> (case _val1187 of {T.TStruct _val1195 -> (to_VerificationSessionData (T.TStruct _val1195)); _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_LoginResult _ = P.error "not a struct"
read_LoginResult :: T.Protocol p => p -> P.IO LoginResult
read_LoginResult iprot = to_LoginResult <$> T.readVal iprot (T.T_STRUCT typemap_LoginResult)
decode_LoginResult :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginResult
decode_LoginResult iprot bs = to_LoginResult $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginResult) bs
typemap_LoginResult :: T.TypeMap
typemap_LoginResult = Map.fromList [(1,("authToken",T.T_STRING)),(2,("certificate",T.T_STRING)),(3,("verifier",T.T_STRING)),(4,("pinCode",T.T_STRING)),(5,("type",T.T_I32)),(6,("lastPrimaryBindTime",T.T_I64)),(7,("displayMessage",T.T_STRING)),(8,("sessionForSMSConfirm",(T.T_STRUCT typemap_VerificationSessionData)))]
default_LoginResult :: LoginResult
default_LoginResult = LoginResult{
  loginResult_authToken = "",
  loginResult_certificate = "",
  loginResult_verifier = "",
  loginResult_pinCode = "",
  loginResult_type = (P.toEnum 0),
  loginResult_lastPrimaryBindTime = 0,
  loginResult_displayMessage = "",
  loginResult_sessionForSMSConfirm = default_VerificationSessionData}
data LoginRequest = LoginRequest  { loginRequest_type :: I.Int32
  , loginRequest_identityProvider :: I.Int32
  , loginRequest_identifier :: LT.Text
  , loginRequest_password :: LT.Text
  , loginRequest_keepLoggedIn :: P.Bool
  , loginRequest_accessLocation :: LT.Text
  , loginRequest_systemName :: LT.Text
  , loginRequest_certificate :: LT.Text
  , loginRequest_verifier :: LT.Text
  , loginRequest_secret :: LT.Text
  , loginRequest_e2eeVersion :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginRequest_type record   `H.hashWithSalt` loginRequest_identityProvider record   `H.hashWithSalt` loginRequest_identifier record   `H.hashWithSalt` loginRequest_password record   `H.hashWithSalt` loginRequest_keepLoggedIn record   `H.hashWithSalt` loginRequest_accessLocation record   `H.hashWithSalt` loginRequest_systemName record   `H.hashWithSalt` loginRequest_certificate record   `H.hashWithSalt` loginRequest_verifier record   `H.hashWithSalt` loginRequest_secret record   `H.hashWithSalt` loginRequest_e2eeVersion record  
instance QC.Arbitrary LoginRequest where 
  arbitrary = M.liftM LoginRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginRequest{loginRequest_type = loginRequest_type obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_type = loginRequest_type obj}
    , if obj == default_LoginRequest{loginRequest_identityProvider = loginRequest_identityProvider obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_identityProvider = loginRequest_identityProvider obj}
    , if obj == default_LoginRequest{loginRequest_identifier = loginRequest_identifier obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_identifier = loginRequest_identifier obj}
    , if obj == default_LoginRequest{loginRequest_password = loginRequest_password obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_password = loginRequest_password obj}
    , if obj == default_LoginRequest{loginRequest_keepLoggedIn = loginRequest_keepLoggedIn obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_keepLoggedIn = loginRequest_keepLoggedIn obj}
    , if obj == default_LoginRequest{loginRequest_accessLocation = loginRequest_accessLocation obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_accessLocation = loginRequest_accessLocation obj}
    , if obj == default_LoginRequest{loginRequest_systemName = loginRequest_systemName obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_systemName = loginRequest_systemName obj}
    , if obj == default_LoginRequest{loginRequest_certificate = loginRequest_certificate obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_certificate = loginRequest_certificate obj}
    , if obj == default_LoginRequest{loginRequest_verifier = loginRequest_verifier obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_verifier = loginRequest_verifier obj}
    , if obj == default_LoginRequest{loginRequest_secret = loginRequest_secret obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_secret = loginRequest_secret obj}
    , if obj == default_LoginRequest{loginRequest_e2eeVersion = loginRequest_e2eeVersion obj} then P.Nothing else P.Just $ default_LoginRequest{loginRequest_e2eeVersion = loginRequest_e2eeVersion obj}
    ]
from_LoginRequest :: LoginRequest -> T.ThriftVal
from_LoginRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1198 -> P.Just (1, ("type",T.TI32 _v1198))) $ loginRequest_type record
  , (\_v1198 -> P.Just (2, ("identityProvider",T.TI32 _v1198))) $ loginRequest_identityProvider record
  , (\_v1198 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_identifier record
  , (\_v1198 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_password record
  , (\_v1198 -> P.Just (5, ("keepLoggedIn",T.TBool _v1198))) $ loginRequest_keepLoggedIn record
  , (\_v1198 -> P.Just (6, ("accessLocation",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_accessLocation record
  , (\_v1198 -> P.Just (7, ("systemName",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_systemName record
  , (\_v1198 -> P.Just (8, ("certificate",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_certificate record
  , (\_v1198 -> P.Just (9, ("verifier",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_verifier record
  , (\_v1198 -> P.Just (10, ("secret",T.TString $ E.encodeUtf8 _v1198))) $ loginRequest_secret record
  , (\_v1198 -> P.Just (11, ("e2eeVersion",T.TI32 _v1198))) $ loginRequest_e2eeVersion record
  ]
write_LoginRequest :: T.Protocol p => p -> LoginRequest -> P.IO ()
write_LoginRequest oprot record = T.writeVal oprot $ from_LoginRequest record
encode_LoginRequest :: T.StatelessProtocol p => p -> LoginRequest -> LBS.ByteString
encode_LoginRequest oprot record = T.serializeVal oprot $ from_LoginRequest record
to_LoginRequest :: T.ThriftVal -> LoginRequest
to_LoginRequest (T.TStruct fields) = LoginRequest{
  loginRequest_type = P.maybe (loginRequest_type default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TI32 _val1201 -> _val1201; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  loginRequest_identityProvider = P.maybe (loginRequest_identityProvider default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TI32 _val1202 -> _val1202; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  loginRequest_identifier = P.maybe (loginRequest_identifier default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1203 -> E.decodeUtf8 _val1203; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginRequest_password = P.maybe (loginRequest_password default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1204 -> E.decodeUtf8 _val1204; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginRequest_keepLoggedIn = P.maybe (loginRequest_keepLoggedIn default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TBool _val1205 -> _val1205; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginRequest_accessLocation = P.maybe (loginRequest_accessLocation default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1206 -> E.decodeUtf8 _val1206; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginRequest_systemName = P.maybe (loginRequest_systemName default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1207 -> E.decodeUtf8 _val1207; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginRequest_certificate = P.maybe (loginRequest_certificate default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1208 -> E.decodeUtf8 _val1208; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  loginRequest_verifier = P.maybe (loginRequest_verifier default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1209 -> E.decodeUtf8 _val1209; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  loginRequest_secret = P.maybe (loginRequest_secret default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TString _val1210 -> E.decodeUtf8 _val1210; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  loginRequest_e2eeVersion = P.maybe (loginRequest_e2eeVersion default_LoginRequest) (\(_,_val1200) -> (case _val1200 of {T.TI32 _val1211 -> _val1211; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_LoginRequest _ = P.error "not a struct"
read_LoginRequest :: T.Protocol p => p -> P.IO LoginRequest
read_LoginRequest iprot = to_LoginRequest <$> T.readVal iprot (T.T_STRUCT typemap_LoginRequest)
decode_LoginRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginRequest
decode_LoginRequest iprot bs = to_LoginRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginRequest) bs
typemap_LoginRequest :: T.TypeMap
typemap_LoginRequest = Map.fromList [(1,("type",T.T_I32)),(2,("identityProvider",T.T_I32)),(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(5,("keepLoggedIn",T.T_BOOL)),(6,("accessLocation",T.T_STRING)),(7,("systemName",T.T_STRING)),(8,("certificate",T.T_STRING)),(9,("verifier",T.T_STRING)),(10,("secret",T.T_STRING)),(11,("e2eeVersion",T.T_I32))]
default_LoginRequest :: LoginRequest
default_LoginRequest = LoginRequest{
  loginRequest_type = 0,
  loginRequest_identityProvider = 0,
  loginRequest_identifier = "",
  loginRequest_password = "",
  loginRequest_keepLoggedIn = P.False,
  loginRequest_accessLocation = "",
  loginRequest_systemName = "",
  loginRequest_certificate = "",
  loginRequest_verifier = "",
  loginRequest_secret = "",
  loginRequest_e2eeVersion = 0}
data LoginSession = LoginSession  { loginSession_tokenKey :: LT.Text
  , loginSession_expirationTime :: I.Int64
  , loginSession_applicationType :: ApplicationType
  , loginSession_systemName :: LT.Text
  , loginSession_accessLocation :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginSession where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginSession_tokenKey record   `H.hashWithSalt` loginSession_expirationTime record   `H.hashWithSalt` loginSession_applicationType record   `H.hashWithSalt` loginSession_systemName record   `H.hashWithSalt` loginSession_accessLocation record  
instance QC.Arbitrary LoginSession where 
  arbitrary = M.liftM LoginSession (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginSession = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginSession{loginSession_tokenKey = loginSession_tokenKey obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_tokenKey = loginSession_tokenKey obj}
    , if obj == default_LoginSession{loginSession_expirationTime = loginSession_expirationTime obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_expirationTime = loginSession_expirationTime obj}
    , if obj == default_LoginSession{loginSession_applicationType = loginSession_applicationType obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_applicationType = loginSession_applicationType obj}
    , if obj == default_LoginSession{loginSession_systemName = loginSession_systemName obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_systemName = loginSession_systemName obj}
    , if obj == default_LoginSession{loginSession_accessLocation = loginSession_accessLocation obj} then P.Nothing else P.Just $ default_LoginSession{loginSession_accessLocation = loginSession_accessLocation obj}
    ]
from_LoginSession :: LoginSession -> T.ThriftVal
from_LoginSession record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1214 -> P.Just (1, ("tokenKey",T.TString $ E.encodeUtf8 _v1214))) $ loginSession_tokenKey record
  , (\_v1214 -> P.Just (3, ("expirationTime",T.TI64 _v1214))) $ loginSession_expirationTime record
  , (\_v1214 -> P.Just (11, ("applicationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1214))) $ loginSession_applicationType record
  , (\_v1214 -> P.Just (12, ("systemName",T.TString $ E.encodeUtf8 _v1214))) $ loginSession_systemName record
  , (\_v1214 -> P.Just (22, ("accessLocation",T.TString $ E.encodeUtf8 _v1214))) $ loginSession_accessLocation record
  ]
write_LoginSession :: T.Protocol p => p -> LoginSession -> P.IO ()
write_LoginSession oprot record = T.writeVal oprot $ from_LoginSession record
encode_LoginSession :: T.StatelessProtocol p => p -> LoginSession -> LBS.ByteString
encode_LoginSession oprot record = T.serializeVal oprot $ from_LoginSession record
to_LoginSession :: T.ThriftVal -> LoginSession
to_LoginSession (T.TStruct fields) = LoginSession{
  loginSession_tokenKey = P.maybe (loginSession_tokenKey default_LoginSession) (\(_,_val1216) -> (case _val1216 of {T.TString _val1217 -> E.decodeUtf8 _val1217; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  loginSession_expirationTime = P.maybe (loginSession_expirationTime default_LoginSession) (\(_,_val1216) -> (case _val1216 of {T.TI64 _val1218 -> _val1218; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginSession_applicationType = P.maybe (loginSession_applicationType default_LoginSession) (\(_,_val1216) -> (case _val1216 of {T.TI32 _val1219 -> P.toEnum $ P.fromIntegral _val1219; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  loginSession_systemName = P.maybe (loginSession_systemName default_LoginSession) (\(_,_val1216) -> (case _val1216 of {T.TString _val1220 -> E.decodeUtf8 _val1220; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  loginSession_accessLocation = P.maybe (loginSession_accessLocation default_LoginSession) (\(_,_val1216) -> (case _val1216 of {T.TString _val1221 -> E.decodeUtf8 _val1221; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_LoginSession _ = P.error "not a struct"
read_LoginSession :: T.Protocol p => p -> P.IO LoginSession
read_LoginSession iprot = to_LoginSession <$> T.readVal iprot (T.T_STRUCT typemap_LoginSession)
decode_LoginSession :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginSession
decode_LoginSession iprot bs = to_LoginSession $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginSession) bs
typemap_LoginSession :: T.TypeMap
typemap_LoginSession = Map.fromList [(1,("tokenKey",T.T_STRING)),(3,("expirationTime",T.T_I64)),(11,("applicationType",T.T_I32)),(12,("systemName",T.T_STRING)),(22,("accessLocation",T.T_STRING))]
default_LoginSession :: LoginSession
default_LoginSession = LoginSession{
  loginSession_tokenKey = "",
  loginSession_expirationTime = 0,
  loginSession_applicationType = (P.toEnum 0),
  loginSession_systemName = "",
  loginSession_accessLocation = ""}
data Message = Message  { message__from :: LT.Text
  , message_to :: LT.Text
  , message_toType :: MIDType
  , message_id :: LT.Text
  , message_createdTime :: I.Int64
  , message_deliveredTime :: I.Int64
  , message_text :: LT.Text
  , message_location :: Location
  , message_hasContent :: P.Bool
  , message_contentType :: ContentType
  , message_contentPreview :: LBS.ByteString
  , message_contentMetadata :: (Map.HashMap LT.Text LT.Text)
  , message_sessionId :: I.Int8
  , message_chunks :: (Vector.Vector LBS.ByteString)
  , message_relatedMessageId :: LT.Text
  , message_messageRelationType :: MessageRelationType
  , message_readCount :: I.Int64
  , message_relatedMessageServiceCode :: ServiceCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Message where
  hashWithSalt salt record = salt   `H.hashWithSalt` message__from record   `H.hashWithSalt` message_to record   `H.hashWithSalt` message_toType record   `H.hashWithSalt` message_id record   `H.hashWithSalt` message_createdTime record   `H.hashWithSalt` message_deliveredTime record   `H.hashWithSalt` message_text record   `H.hashWithSalt` message_location record   `H.hashWithSalt` message_hasContent record   `H.hashWithSalt` message_contentType record   `H.hashWithSalt` message_contentPreview record   `H.hashWithSalt` message_contentMetadata record   `H.hashWithSalt` message_sessionId record   `H.hashWithSalt` message_chunks record   `H.hashWithSalt` message_relatedMessageId record   `H.hashWithSalt` message_messageRelationType record   `H.hashWithSalt` message_readCount record   `H.hashWithSalt` message_relatedMessageServiceCode record  
instance QC.Arbitrary Message where 
  arbitrary = M.liftM Message (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Message = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Message{message__from = message__from obj} then P.Nothing else P.Just $ default_Message{message__from = message__from obj}
    , if obj == default_Message{message_to = message_to obj} then P.Nothing else P.Just $ default_Message{message_to = message_to obj}
    , if obj == default_Message{message_toType = message_toType obj} then P.Nothing else P.Just $ default_Message{message_toType = message_toType obj}
    , if obj == default_Message{message_id = message_id obj} then P.Nothing else P.Just $ default_Message{message_id = message_id obj}
    , if obj == default_Message{message_createdTime = message_createdTime obj} then P.Nothing else P.Just $ default_Message{message_createdTime = message_createdTime obj}
    , if obj == default_Message{message_deliveredTime = message_deliveredTime obj} then P.Nothing else P.Just $ default_Message{message_deliveredTime = message_deliveredTime obj}
    , if obj == default_Message{message_text = message_text obj} then P.Nothing else P.Just $ default_Message{message_text = message_text obj}
    , if obj == default_Message{message_location = message_location obj} then P.Nothing else P.Just $ default_Message{message_location = message_location obj}
    , if obj == default_Message{message_hasContent = message_hasContent obj} then P.Nothing else P.Just $ default_Message{message_hasContent = message_hasContent obj}
    , if obj == default_Message{message_contentType = message_contentType obj} then P.Nothing else P.Just $ default_Message{message_contentType = message_contentType obj}
    , if obj == default_Message{message_contentPreview = message_contentPreview obj} then P.Nothing else P.Just $ default_Message{message_contentPreview = message_contentPreview obj}
    , if obj == default_Message{message_contentMetadata = message_contentMetadata obj} then P.Nothing else P.Just $ default_Message{message_contentMetadata = message_contentMetadata obj}
    , if obj == default_Message{message_sessionId = message_sessionId obj} then P.Nothing else P.Just $ default_Message{message_sessionId = message_sessionId obj}
    , if obj == default_Message{message_chunks = message_chunks obj} then P.Nothing else P.Just $ default_Message{message_chunks = message_chunks obj}
    , if obj == default_Message{message_relatedMessageId = message_relatedMessageId obj} then P.Nothing else P.Just $ default_Message{message_relatedMessageId = message_relatedMessageId obj}
    , if obj == default_Message{message_messageRelationType = message_messageRelationType obj} then P.Nothing else P.Just $ default_Message{message_messageRelationType = message_messageRelationType obj}
    , if obj == default_Message{message_readCount = message_readCount obj} then P.Nothing else P.Just $ default_Message{message_readCount = message_readCount obj}
    , if obj == default_Message{message_relatedMessageServiceCode = message_relatedMessageServiceCode obj} then P.Nothing else P.Just $ default_Message{message_relatedMessageServiceCode = message_relatedMessageServiceCode obj}
    ]
from_Message :: Message -> T.ThriftVal
from_Message record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1224 -> P.Just (1, ("_from",T.TString $ E.encodeUtf8 _v1224))) $ message__from record
  , (\_v1224 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v1224))) $ message_to record
  , (\_v1224 -> P.Just (3, ("toType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1224))) $ message_toType record
  , (\_v1224 -> P.Just (4, ("id",T.TString $ E.encodeUtf8 _v1224))) $ message_id record
  , (\_v1224 -> P.Just (5, ("createdTime",T.TI64 _v1224))) $ message_createdTime record
  , (\_v1224 -> P.Just (6, ("deliveredTime",T.TI64 _v1224))) $ message_deliveredTime record
  , (\_v1224 -> P.Just (10, ("text",T.TString $ E.encodeUtf8 _v1224))) $ message_text record
  , (\_v1224 -> P.Just (11, ("location",from_Location _v1224))) $ message_location record
  , (\_v1224 -> P.Just (14, ("hasContent",T.TBool _v1224))) $ message_hasContent record
  , (\_v1224 -> P.Just (15, ("contentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1224))) $ message_contentType record
  , (\_v1224 -> P.Just (17, ("contentPreview",T.TBinary _v1224))) $ message_contentPreview record
  , (\_v1224 -> P.Just (18, ("contentMetadata",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k1225,_v1226) -> (T.TString $ E.encodeUtf8 _k1225, T.TString $ E.encodeUtf8 _v1226)) $ Map.toList _v1224))) $ message_contentMetadata record
  , (\_v1224 -> P.Just (19, ("sessionId",T.TByte _v1224))) $ message_sessionId record
  , (\_v1224 -> P.Just (20, ("chunks",T.TList T.T_BINARY $ P.map (\_v1228 -> T.TBinary _v1228) $ Vector.toList _v1224))) $ message_chunks record
  , (\_v1224 -> P.Just (21, ("relatedMessageId",T.TString $ E.encodeUtf8 _v1224))) $ message_relatedMessageId record
  , (\_v1224 -> P.Just (22, ("messageRelationType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1224))) $ message_messageRelationType record
  , (\_v1224 -> P.Just (23, ("readCount",T.TI64 _v1224))) $ message_readCount record
  , (\_v1224 -> P.Just (24, ("relatedMessageServiceCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v1224))) $ message_relatedMessageServiceCode record
  ]
write_Message :: T.Protocol p => p -> Message -> P.IO ()
write_Message oprot record = T.writeVal oprot $ from_Message record
encode_Message :: T.StatelessProtocol p => p -> Message -> LBS.ByteString
encode_Message oprot record = T.serializeVal oprot $ from_Message record
to_Message :: T.ThriftVal -> Message
to_Message (T.TStruct fields) = Message{
  message__from = P.maybe (message__from default_Message) (\(_,_val1230) -> (case _val1230 of {T.TString _val1231 -> E.decodeUtf8 _val1231; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  message_to = P.maybe (message_to default_Message) (\(_,_val1230) -> (case _val1230 of {T.TString _val1232 -> E.decodeUtf8 _val1232; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  message_toType = P.maybe (message_toType default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI32 _val1233 -> P.toEnum $ P.fromIntegral _val1233; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  message_id = P.maybe (message_id default_Message) (\(_,_val1230) -> (case _val1230 of {T.TString _val1234 -> E.decodeUtf8 _val1234; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  message_createdTime = P.maybe (message_createdTime default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI64 _val1235 -> _val1235; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  message_deliveredTime = P.maybe (message_deliveredTime default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI64 _val1236 -> _val1236; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  message_text = P.maybe (message_text default_Message) (\(_,_val1230) -> (case _val1230 of {T.TString _val1237 -> E.decodeUtf8 _val1237; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  message_location = P.maybe (message_location default_Message) (\(_,_val1230) -> (case _val1230 of {T.TStruct _val1238 -> (to_Location (T.TStruct _val1238)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  message_hasContent = P.maybe (message_hasContent default_Message) (\(_,_val1230) -> (case _val1230 of {T.TBool _val1239 -> _val1239; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  message_contentType = P.maybe (message_contentType default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI32 _val1240 -> P.toEnum $ P.fromIntegral _val1240; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  message_contentPreview = P.maybe (message_contentPreview default_Message) (\(_,_val1230) -> (case _val1230 of {T.TBinary _val1241 -> _val1241; T.TString _val1241 -> _val1241; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  message_contentMetadata = P.maybe (message_contentMetadata default_Message) (\(_,_val1230) -> (case _val1230 of {T.TMap _ _ _val1242 -> (Map.fromList $ P.map (\(_k1244,_v1243) -> ((case _k1244 of {T.TString _val1245 -> E.decodeUtf8 _val1245; _ -> P.error "wrong type"}),(case _v1243 of {T.TString _val1246 -> E.decodeUtf8 _val1246; _ -> P.error "wrong type"}))) _val1242); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  message_sessionId = P.maybe (message_sessionId default_Message) (\(_,_val1230) -> (case _val1230 of {T.TByte _val1247 -> _val1247; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  message_chunks = P.maybe (message_chunks default_Message) (\(_,_val1230) -> (case _val1230 of {T.TList _ _val1248 -> (Vector.fromList $ P.map (\_v1249 -> (case _v1249 of {T.TBinary _val1250 -> _val1250; T.TString _val1250 -> _val1250; _ -> P.error "wrong type"})) _val1248); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  message_relatedMessageId = P.maybe (message_relatedMessageId default_Message) (\(_,_val1230) -> (case _val1230 of {T.TString _val1251 -> E.decodeUtf8 _val1251; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  message_messageRelationType = P.maybe (message_messageRelationType default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI32 _val1252 -> P.toEnum $ P.fromIntegral _val1252; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  message_readCount = P.maybe (message_readCount default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI64 _val1253 -> _val1253; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  message_relatedMessageServiceCode = P.maybe (message_relatedMessageServiceCode default_Message) (\(_,_val1230) -> (case _val1230 of {T.TI32 _val1254 -> P.toEnum $ P.fromIntegral _val1254; _ -> P.error "wrong type"})) (Map.lookup (24) fields)
  }
to_Message _ = P.error "not a struct"
read_Message :: T.Protocol p => p -> P.IO Message
read_Message iprot = to_Message <$> T.readVal iprot (T.T_STRUCT typemap_Message)
decode_Message :: T.StatelessProtocol p => p -> LBS.ByteString -> Message
decode_Message iprot bs = to_Message $ T.deserializeVal iprot (T.T_STRUCT typemap_Message) bs
typemap_Message :: T.TypeMap
typemap_Message = Map.fromList [(1,("_from",T.T_STRING)),(2,("to",T.T_STRING)),(3,("toType",T.T_I32)),(4,("id",T.T_STRING)),(5,("createdTime",T.T_I64)),(6,("deliveredTime",T.T_I64)),(10,("text",T.T_STRING)),(11,("location",(T.T_STRUCT typemap_Location))),(14,("hasContent",T.T_BOOL)),(15,("contentType",T.T_I32)),(17,("contentPreview",T.T_BINARY)),(18,("contentMetadata",(T.T_MAP T.T_STRING T.T_STRING))),(19,("sessionId",T.T_BYTE)),(20,("chunks",(T.T_LIST T.T_BINARY))),(21,("relatedMessageId",T.T_STRING)),(22,("messageRelationType",T.T_I32)),(23,("readCount",T.T_I64)),(24,("relatedMessageServiceCode",T.T_I32))]
default_Message :: Message
default_Message = Message{
  message__from = "",
  message_to = "",
  message_toType = (P.toEnum 0),
  message_id = "",
  message_createdTime = 0,
  message_deliveredTime = 0,
  message_text = "",
  message_location = default_Location,
  message_hasContent = P.False,
  message_contentType = (P.toEnum 0),
  message_contentPreview = "",
  message_contentMetadata = Map.empty,
  message_sessionId = 0,
  message_chunks = Vector.empty,
  message_relatedMessageId = "",
  message_messageRelationType = (P.toEnum 0),
  message_readCount = 0,
  message_relatedMessageServiceCode = (P.toEnum 0)}
data SquareMessage = SquareMessage  { squareMessage_message :: Message
  , squareMessage_fromType :: MIDType
  , squareMessage_squareMessageRevision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareMessage_message record   `H.hashWithSalt` squareMessage_fromType record   `H.hashWithSalt` squareMessage_squareMessageRevision record  
instance QC.Arbitrary SquareMessage where 
  arbitrary = M.liftM SquareMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareMessage{squareMessage_message = squareMessage_message obj} then P.Nothing else P.Just $ default_SquareMessage{squareMessage_message = squareMessage_message obj}
    , if obj == default_SquareMessage{squareMessage_fromType = squareMessage_fromType obj} then P.Nothing else P.Just $ default_SquareMessage{squareMessage_fromType = squareMessage_fromType obj}
    , if obj == default_SquareMessage{squareMessage_squareMessageRevision = squareMessage_squareMessageRevision obj} then P.Nothing else P.Just $ default_SquareMessage{squareMessage_squareMessageRevision = squareMessage_squareMessageRevision obj}
    ]
from_SquareMessage :: SquareMessage -> T.ThriftVal
from_SquareMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1257 -> P.Just (1, ("message",from_Message _v1257))) $ squareMessage_message record
  , (\_v1257 -> P.Just (3, ("fromType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1257))) $ squareMessage_fromType record
  , (\_v1257 -> P.Just (4, ("squareMessageRevision",T.TI64 _v1257))) $ squareMessage_squareMessageRevision record
  ]
write_SquareMessage :: T.Protocol p => p -> SquareMessage -> P.IO ()
write_SquareMessage oprot record = T.writeVal oprot $ from_SquareMessage record
encode_SquareMessage :: T.StatelessProtocol p => p -> SquareMessage -> LBS.ByteString
encode_SquareMessage oprot record = T.serializeVal oprot $ from_SquareMessage record
to_SquareMessage :: T.ThriftVal -> SquareMessage
to_SquareMessage (T.TStruct fields) = SquareMessage{
  squareMessage_message = P.maybe (squareMessage_message default_SquareMessage) (\(_,_val1259) -> (case _val1259 of {T.TStruct _val1260 -> (to_Message (T.TStruct _val1260)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareMessage_fromType = P.maybe (squareMessage_fromType default_SquareMessage) (\(_,_val1259) -> (case _val1259 of {T.TI32 _val1261 -> P.toEnum $ P.fromIntegral _val1261; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareMessage_squareMessageRevision = P.maybe (squareMessage_squareMessageRevision default_SquareMessage) (\(_,_val1259) -> (case _val1259 of {T.TI64 _val1262 -> _val1262; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareMessage _ = P.error "not a struct"
read_SquareMessage :: T.Protocol p => p -> P.IO SquareMessage
read_SquareMessage iprot = to_SquareMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareMessage)
decode_SquareMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareMessage
decode_SquareMessage iprot bs = to_SquareMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareMessage) bs
typemap_SquareMessage :: T.TypeMap
typemap_SquareMessage = Map.fromList [(1,("message",(T.T_STRUCT typemap_Message))),(3,("fromType",T.T_I32)),(4,("squareMessageRevision",T.T_I64))]
default_SquareMessage :: SquareMessage
default_SquareMessage = SquareMessage{
  squareMessage_message = default_Message,
  squareMessage_fromType = (P.toEnum 0),
  squareMessage_squareMessageRevision = 0}
data SquareChatStatusWithoutMessage = SquareChatStatusWithoutMessage  { squareChatStatusWithoutMessage_memberCount :: I.Int32
  , squareChatStatusWithoutMessage_unreadMessageCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChatStatusWithoutMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChatStatusWithoutMessage_memberCount record   `H.hashWithSalt` squareChatStatusWithoutMessage_unreadMessageCount record  
instance QC.Arbitrary SquareChatStatusWithoutMessage where 
  arbitrary = M.liftM SquareChatStatusWithoutMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareChatStatusWithoutMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChatStatusWithoutMessage{squareChatStatusWithoutMessage_memberCount = squareChatStatusWithoutMessage_memberCount obj} then P.Nothing else P.Just $ default_SquareChatStatusWithoutMessage{squareChatStatusWithoutMessage_memberCount = squareChatStatusWithoutMessage_memberCount obj}
    , if obj == default_SquareChatStatusWithoutMessage{squareChatStatusWithoutMessage_unreadMessageCount = squareChatStatusWithoutMessage_unreadMessageCount obj} then P.Nothing else P.Just $ default_SquareChatStatusWithoutMessage{squareChatStatusWithoutMessage_unreadMessageCount = squareChatStatusWithoutMessage_unreadMessageCount obj}
    ]
from_SquareChatStatusWithoutMessage :: SquareChatStatusWithoutMessage -> T.ThriftVal
from_SquareChatStatusWithoutMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1265 -> P.Just (1, ("memberCount",T.TI32 _v1265))) $ squareChatStatusWithoutMessage_memberCount record
  , (\_v1265 -> P.Just (2, ("unreadMessageCount",T.TI32 _v1265))) $ squareChatStatusWithoutMessage_unreadMessageCount record
  ]
write_SquareChatStatusWithoutMessage :: T.Protocol p => p -> SquareChatStatusWithoutMessage -> P.IO ()
write_SquareChatStatusWithoutMessage oprot record = T.writeVal oprot $ from_SquareChatStatusWithoutMessage record
encode_SquareChatStatusWithoutMessage :: T.StatelessProtocol p => p -> SquareChatStatusWithoutMessage -> LBS.ByteString
encode_SquareChatStatusWithoutMessage oprot record = T.serializeVal oprot $ from_SquareChatStatusWithoutMessage record
to_SquareChatStatusWithoutMessage :: T.ThriftVal -> SquareChatStatusWithoutMessage
to_SquareChatStatusWithoutMessage (T.TStruct fields) = SquareChatStatusWithoutMessage{
  squareChatStatusWithoutMessage_memberCount = P.maybe (squareChatStatusWithoutMessage_memberCount default_SquareChatStatusWithoutMessage) (\(_,_val1267) -> (case _val1267 of {T.TI32 _val1268 -> _val1268; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareChatStatusWithoutMessage_unreadMessageCount = P.maybe (squareChatStatusWithoutMessage_unreadMessageCount default_SquareChatStatusWithoutMessage) (\(_,_val1267) -> (case _val1267 of {T.TI32 _val1269 -> _val1269; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareChatStatusWithoutMessage _ = P.error "not a struct"
read_SquareChatStatusWithoutMessage :: T.Protocol p => p -> P.IO SquareChatStatusWithoutMessage
read_SquareChatStatusWithoutMessage iprot = to_SquareChatStatusWithoutMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareChatStatusWithoutMessage)
decode_SquareChatStatusWithoutMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChatStatusWithoutMessage
decode_SquareChatStatusWithoutMessage iprot bs = to_SquareChatStatusWithoutMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChatStatusWithoutMessage) bs
typemap_SquareChatStatusWithoutMessage :: T.TypeMap
typemap_SquareChatStatusWithoutMessage = Map.fromList [(1,("memberCount",T.T_I32)),(2,("unreadMessageCount",T.T_I32))]
default_SquareChatStatusWithoutMessage :: SquareChatStatusWithoutMessage
default_SquareChatStatusWithoutMessage = SquareChatStatusWithoutMessage{
  squareChatStatusWithoutMessage_memberCount = 0,
  squareChatStatusWithoutMessage_unreadMessageCount = 0}
data SquareChatStatus = SquareChatStatus  { squareChatStatus_lastMessage :: SquareMessage
  , squareChatStatus_senderDisplayName :: LT.Text
  , squareChatStatus_otherStatus :: SquareChatStatusWithoutMessage
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChatStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChatStatus_lastMessage record   `H.hashWithSalt` squareChatStatus_senderDisplayName record   `H.hashWithSalt` squareChatStatus_otherStatus record  
instance QC.Arbitrary SquareChatStatus where 
  arbitrary = M.liftM SquareChatStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareChatStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChatStatus{squareChatStatus_lastMessage = squareChatStatus_lastMessage obj} then P.Nothing else P.Just $ default_SquareChatStatus{squareChatStatus_lastMessage = squareChatStatus_lastMessage obj}
    , if obj == default_SquareChatStatus{squareChatStatus_senderDisplayName = squareChatStatus_senderDisplayName obj} then P.Nothing else P.Just $ default_SquareChatStatus{squareChatStatus_senderDisplayName = squareChatStatus_senderDisplayName obj}
    , if obj == default_SquareChatStatus{squareChatStatus_otherStatus = squareChatStatus_otherStatus obj} then P.Nothing else P.Just $ default_SquareChatStatus{squareChatStatus_otherStatus = squareChatStatus_otherStatus obj}
    ]
from_SquareChatStatus :: SquareChatStatus -> T.ThriftVal
from_SquareChatStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1272 -> P.Just (3, ("lastMessage",from_SquareMessage _v1272))) $ squareChatStatus_lastMessage record
  , (\_v1272 -> P.Just (4, ("senderDisplayName",T.TString $ E.encodeUtf8 _v1272))) $ squareChatStatus_senderDisplayName record
  , (\_v1272 -> P.Just (5, ("otherStatus",from_SquareChatStatusWithoutMessage _v1272))) $ squareChatStatus_otherStatus record
  ]
write_SquareChatStatus :: T.Protocol p => p -> SquareChatStatus -> P.IO ()
write_SquareChatStatus oprot record = T.writeVal oprot $ from_SquareChatStatus record
encode_SquareChatStatus :: T.StatelessProtocol p => p -> SquareChatStatus -> LBS.ByteString
encode_SquareChatStatus oprot record = T.serializeVal oprot $ from_SquareChatStatus record
to_SquareChatStatus :: T.ThriftVal -> SquareChatStatus
to_SquareChatStatus (T.TStruct fields) = SquareChatStatus{
  squareChatStatus_lastMessage = P.maybe (squareChatStatus_lastMessage default_SquareChatStatus) (\(_,_val1274) -> (case _val1274 of {T.TStruct _val1275 -> (to_SquareMessage (T.TStruct _val1275)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareChatStatus_senderDisplayName = P.maybe (squareChatStatus_senderDisplayName default_SquareChatStatus) (\(_,_val1274) -> (case _val1274 of {T.TString _val1276 -> E.decodeUtf8 _val1276; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareChatStatus_otherStatus = P.maybe (squareChatStatus_otherStatus default_SquareChatStatus) (\(_,_val1274) -> (case _val1274 of {T.TStruct _val1277 -> (to_SquareChatStatusWithoutMessage (T.TStruct _val1277)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SquareChatStatus _ = P.error "not a struct"
read_SquareChatStatus :: T.Protocol p => p -> P.IO SquareChatStatus
read_SquareChatStatus iprot = to_SquareChatStatus <$> T.readVal iprot (T.T_STRUCT typemap_SquareChatStatus)
decode_SquareChatStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChatStatus
decode_SquareChatStatus iprot bs = to_SquareChatStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChatStatus) bs
typemap_SquareChatStatus :: T.TypeMap
typemap_SquareChatStatus = Map.fromList [(3,("lastMessage",(T.T_STRUCT typemap_SquareMessage))),(4,("senderDisplayName",T.T_STRING)),(5,("otherStatus",(T.T_STRUCT typemap_SquareChatStatusWithoutMessage)))]
default_SquareChatStatus :: SquareChatStatus
default_SquareChatStatus = SquareChatStatus{
  squareChatStatus_lastMessage = default_SquareMessage,
  squareChatStatus_senderDisplayName = "",
  squareChatStatus_otherStatus = default_SquareChatStatusWithoutMessage}
data SquareChatMember = SquareChatMember  { squareChatMember_squareMemberMid :: LT.Text
  , squareChatMember_squareChatMid :: LT.Text
  , squareChatMember_revision :: I.Int64
  , squareChatMember_membershipState :: SquareChatMembershipState
  , squareChatMember_notificationForMessage :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareChatMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareChatMember_squareMemberMid record   `H.hashWithSalt` squareChatMember_squareChatMid record   `H.hashWithSalt` squareChatMember_revision record   `H.hashWithSalt` squareChatMember_membershipState record   `H.hashWithSalt` squareChatMember_notificationForMessage record  
instance QC.Arbitrary SquareChatMember where 
  arbitrary = M.liftM SquareChatMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareChatMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareChatMember{squareChatMember_squareMemberMid = squareChatMember_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareChatMember{squareChatMember_squareMemberMid = squareChatMember_squareMemberMid obj}
    , if obj == default_SquareChatMember{squareChatMember_squareChatMid = squareChatMember_squareChatMid obj} then P.Nothing else P.Just $ default_SquareChatMember{squareChatMember_squareChatMid = squareChatMember_squareChatMid obj}
    , if obj == default_SquareChatMember{squareChatMember_revision = squareChatMember_revision obj} then P.Nothing else P.Just $ default_SquareChatMember{squareChatMember_revision = squareChatMember_revision obj}
    , if obj == default_SquareChatMember{squareChatMember_membershipState = squareChatMember_membershipState obj} then P.Nothing else P.Just $ default_SquareChatMember{squareChatMember_membershipState = squareChatMember_membershipState obj}
    , if obj == default_SquareChatMember{squareChatMember_notificationForMessage = squareChatMember_notificationForMessage obj} then P.Nothing else P.Just $ default_SquareChatMember{squareChatMember_notificationForMessage = squareChatMember_notificationForMessage obj}
    ]
from_SquareChatMember :: SquareChatMember -> T.ThriftVal
from_SquareChatMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1280 -> P.Just (1, ("squareMemberMid",T.TString $ E.encodeUtf8 _v1280))) $ squareChatMember_squareMemberMid record
  , (\_v1280 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v1280))) $ squareChatMember_squareChatMid record
  , (\_v1280 -> P.Just (3, ("revision",T.TI64 _v1280))) $ squareChatMember_revision record
  , (\_v1280 -> P.Just (4, ("membershipState",T.TI32 $ P.fromIntegral $ P.fromEnum _v1280))) $ squareChatMember_membershipState record
  , (\_v1280 -> P.Just (5, ("notificationForMessage",T.TBool _v1280))) $ squareChatMember_notificationForMessage record
  ]
write_SquareChatMember :: T.Protocol p => p -> SquareChatMember -> P.IO ()
write_SquareChatMember oprot record = T.writeVal oprot $ from_SquareChatMember record
encode_SquareChatMember :: T.StatelessProtocol p => p -> SquareChatMember -> LBS.ByteString
encode_SquareChatMember oprot record = T.serializeVal oprot $ from_SquareChatMember record
to_SquareChatMember :: T.ThriftVal -> SquareChatMember
to_SquareChatMember (T.TStruct fields) = SquareChatMember{
  squareChatMember_squareMemberMid = P.maybe (squareChatMember_squareMemberMid default_SquareChatMember) (\(_,_val1282) -> (case _val1282 of {T.TString _val1283 -> E.decodeUtf8 _val1283; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareChatMember_squareChatMid = P.maybe (squareChatMember_squareChatMid default_SquareChatMember) (\(_,_val1282) -> (case _val1282 of {T.TString _val1284 -> E.decodeUtf8 _val1284; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareChatMember_revision = P.maybe (squareChatMember_revision default_SquareChatMember) (\(_,_val1282) -> (case _val1282 of {T.TI64 _val1285 -> _val1285; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareChatMember_membershipState = P.maybe (squareChatMember_membershipState default_SquareChatMember) (\(_,_val1282) -> (case _val1282 of {T.TI32 _val1286 -> P.toEnum $ P.fromIntegral _val1286; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareChatMember_notificationForMessage = P.maybe (squareChatMember_notificationForMessage default_SquareChatMember) (\(_,_val1282) -> (case _val1282 of {T.TBool _val1287 -> _val1287; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SquareChatMember _ = P.error "not a struct"
read_SquareChatMember :: T.Protocol p => p -> P.IO SquareChatMember
read_SquareChatMember iprot = to_SquareChatMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareChatMember)
decode_SquareChatMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareChatMember
decode_SquareChatMember iprot bs = to_SquareChatMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareChatMember) bs
typemap_SquareChatMember :: T.TypeMap
typemap_SquareChatMember = Map.fromList [(1,("squareMemberMid",T.T_STRING)),(2,("squareChatMid",T.T_STRING)),(3,("revision",T.T_I64)),(4,("membershipState",T.T_I32)),(5,("notificationForMessage",T.T_BOOL))]
default_SquareChatMember :: SquareChatMember
default_SquareChatMember = SquareChatMember{
  squareChatMember_squareMemberMid = "",
  squareChatMember_squareChatMid = "",
  squareChatMember_revision = 0,
  squareChatMember_membershipState = (P.toEnum 0),
  squareChatMember_notificationForMessage = P.False}
data MessageOperation = MessageOperation  { messageOperation_revision :: I.Int64
  , messageOperation_createdTime :: I.Int64
  , messageOperation_type :: MessageOperationType
  , messageOperation_reqSeq :: I.Int32
  , messageOperation_status :: OpStatus
  , messageOperation_param1 :: LT.Text
  , messageOperation_param2 :: LT.Text
  , messageOperation_param3 :: LT.Text
  , messageOperation_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageOperation where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageOperation_revision record   `H.hashWithSalt` messageOperation_createdTime record   `H.hashWithSalt` messageOperation_type record   `H.hashWithSalt` messageOperation_reqSeq record   `H.hashWithSalt` messageOperation_status record   `H.hashWithSalt` messageOperation_param1 record   `H.hashWithSalt` messageOperation_param2 record   `H.hashWithSalt` messageOperation_param3 record   `H.hashWithSalt` messageOperation_message record  
instance QC.Arbitrary MessageOperation where 
  arbitrary = M.liftM MessageOperation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageOperation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageOperation{messageOperation_revision = messageOperation_revision obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_revision = messageOperation_revision obj}
    , if obj == default_MessageOperation{messageOperation_createdTime = messageOperation_createdTime obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_createdTime = messageOperation_createdTime obj}
    , if obj == default_MessageOperation{messageOperation_type = messageOperation_type obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_type = messageOperation_type obj}
    , if obj == default_MessageOperation{messageOperation_reqSeq = messageOperation_reqSeq obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_reqSeq = messageOperation_reqSeq obj}
    , if obj == default_MessageOperation{messageOperation_status = messageOperation_status obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_status = messageOperation_status obj}
    , if obj == default_MessageOperation{messageOperation_param1 = messageOperation_param1 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param1 = messageOperation_param1 obj}
    , if obj == default_MessageOperation{messageOperation_param2 = messageOperation_param2 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param2 = messageOperation_param2 obj}
    , if obj == default_MessageOperation{messageOperation_param3 = messageOperation_param3 obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_param3 = messageOperation_param3 obj}
    , if obj == default_MessageOperation{messageOperation_message = messageOperation_message obj} then P.Nothing else P.Just $ default_MessageOperation{messageOperation_message = messageOperation_message obj}
    ]
from_MessageOperation :: MessageOperation -> T.ThriftVal
from_MessageOperation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1290 -> P.Just (1, ("revision",T.TI64 _v1290))) $ messageOperation_revision record
  , (\_v1290 -> P.Just (2, ("createdTime",T.TI64 _v1290))) $ messageOperation_createdTime record
  , (\_v1290 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1290))) $ messageOperation_type record
  , (\_v1290 -> P.Just (4, ("reqSeq",T.TI32 _v1290))) $ messageOperation_reqSeq record
  , (\_v1290 -> P.Just (5, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v1290))) $ messageOperation_status record
  , (\_v1290 -> P.Just (10, ("param1",T.TString $ E.encodeUtf8 _v1290))) $ messageOperation_param1 record
  , (\_v1290 -> P.Just (11, ("param2",T.TString $ E.encodeUtf8 _v1290))) $ messageOperation_param2 record
  , (\_v1290 -> P.Just (12, ("param3",T.TString $ E.encodeUtf8 _v1290))) $ messageOperation_param3 record
  , (\_v1290 -> P.Just (20, ("message",from_Message _v1290))) $ messageOperation_message record
  ]
write_MessageOperation :: T.Protocol p => p -> MessageOperation -> P.IO ()
write_MessageOperation oprot record = T.writeVal oprot $ from_MessageOperation record
encode_MessageOperation :: T.StatelessProtocol p => p -> MessageOperation -> LBS.ByteString
encode_MessageOperation oprot record = T.serializeVal oprot $ from_MessageOperation record
to_MessageOperation :: T.ThriftVal -> MessageOperation
to_MessageOperation (T.TStruct fields) = MessageOperation{
  messageOperation_revision = P.maybe (messageOperation_revision default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TI64 _val1293 -> _val1293; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageOperation_createdTime = P.maybe (messageOperation_createdTime default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TI64 _val1294 -> _val1294; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  messageOperation_type = P.maybe (messageOperation_type default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TI32 _val1295 -> P.toEnum $ P.fromIntegral _val1295; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  messageOperation_reqSeq = P.maybe (messageOperation_reqSeq default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TI32 _val1296 -> _val1296; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  messageOperation_status = P.maybe (messageOperation_status default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TI32 _val1297 -> P.toEnum $ P.fromIntegral _val1297; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  messageOperation_param1 = P.maybe (messageOperation_param1 default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TString _val1298 -> E.decodeUtf8 _val1298; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  messageOperation_param2 = P.maybe (messageOperation_param2 default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TString _val1299 -> E.decodeUtf8 _val1299; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  messageOperation_param3 = P.maybe (messageOperation_param3 default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TString _val1300 -> E.decodeUtf8 _val1300; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  messageOperation_message = P.maybe (messageOperation_message default_MessageOperation) (\(_,_val1292) -> (case _val1292 of {T.TStruct _val1301 -> (to_Message (T.TStruct _val1301)); _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_MessageOperation _ = P.error "not a struct"
read_MessageOperation :: T.Protocol p => p -> P.IO MessageOperation
read_MessageOperation iprot = to_MessageOperation <$> T.readVal iprot (T.T_STRUCT typemap_MessageOperation)
decode_MessageOperation :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageOperation
decode_MessageOperation iprot bs = to_MessageOperation $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageOperation) bs
typemap_MessageOperation :: T.TypeMap
typemap_MessageOperation = Map.fromList [(1,("revision",T.T_I64)),(2,("createdTime",T.T_I64)),(3,("type",T.T_I32)),(4,("reqSeq",T.T_I32)),(5,("status",T.T_I32)),(10,("param1",T.T_STRING)),(11,("param2",T.T_STRING)),(12,("param3",T.T_STRING)),(20,("message",(T.T_STRUCT typemap_Message)))]
default_MessageOperation :: MessageOperation
default_MessageOperation = MessageOperation{
  messageOperation_revision = 0,
  messageOperation_createdTime = 0,
  messageOperation_type = (P.toEnum 0),
  messageOperation_reqSeq = 0,
  messageOperation_status = (P.toEnum 0),
  messageOperation_param1 = "",
  messageOperation_param2 = "",
  messageOperation_param3 = "",
  messageOperation_message = default_Message}
data MessageOperations = MessageOperations  { messageOperations_operations :: (Vector.Vector MessageOperation)
  , messageOperations_endFlag :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageOperations where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageOperations_operations record   `H.hashWithSalt` messageOperations_endFlag record  
instance QC.Arbitrary MessageOperations where 
  arbitrary = M.liftM MessageOperations (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageOperations = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageOperations{messageOperations_operations = messageOperations_operations obj} then P.Nothing else P.Just $ default_MessageOperations{messageOperations_operations = messageOperations_operations obj}
    , if obj == default_MessageOperations{messageOperations_endFlag = messageOperations_endFlag obj} then P.Nothing else P.Just $ default_MessageOperations{messageOperations_endFlag = messageOperations_endFlag obj}
    ]
from_MessageOperations :: MessageOperations -> T.ThriftVal
from_MessageOperations record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1304 -> P.Just (1, ("operations",T.TList (T.T_STRUCT typemap_MessageOperation) $ P.map (\_v1306 -> from_MessageOperation _v1306) $ Vector.toList _v1304))) $ messageOperations_operations record
  , (\_v1304 -> P.Just (2, ("endFlag",T.TBool _v1304))) $ messageOperations_endFlag record
  ]
write_MessageOperations :: T.Protocol p => p -> MessageOperations -> P.IO ()
write_MessageOperations oprot record = T.writeVal oprot $ from_MessageOperations record
encode_MessageOperations :: T.StatelessProtocol p => p -> MessageOperations -> LBS.ByteString
encode_MessageOperations oprot record = T.serializeVal oprot $ from_MessageOperations record
to_MessageOperations :: T.ThriftVal -> MessageOperations
to_MessageOperations (T.TStruct fields) = MessageOperations{
  messageOperations_operations = P.maybe (messageOperations_operations default_MessageOperations) (\(_,_val1308) -> (case _val1308 of {T.TList _ _val1309 -> (Vector.fromList $ P.map (\_v1310 -> (case _v1310 of {T.TStruct _val1311 -> (to_MessageOperation (T.TStruct _val1311)); _ -> P.error "wrong type"})) _val1309); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageOperations_endFlag = P.maybe (messageOperations_endFlag default_MessageOperations) (\(_,_val1308) -> (case _val1308 of {T.TBool _val1312 -> _val1312; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MessageOperations _ = P.error "not a struct"
read_MessageOperations :: T.Protocol p => p -> P.IO MessageOperations
read_MessageOperations iprot = to_MessageOperations <$> T.readVal iprot (T.T_STRUCT typemap_MessageOperations)
decode_MessageOperations :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageOperations
decode_MessageOperations iprot bs = to_MessageOperations $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageOperations) bs
typemap_MessageOperations :: T.TypeMap
typemap_MessageOperations = Map.fromList [(1,("operations",(T.T_LIST (T.T_STRUCT typemap_MessageOperation)))),(2,("endFlag",T.T_BOOL))]
default_MessageOperations :: MessageOperations
default_MessageOperations = MessageOperations{
  messageOperations_operations = Vector.empty,
  messageOperations_endFlag = P.False}
data MessageStoreResult = MessageStoreResult  { messageStoreResult_requestId :: LT.Text
  , messageStoreResult_messageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MessageStoreResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` messageStoreResult_requestId record   `H.hashWithSalt` messageStoreResult_messageIds record  
instance QC.Arbitrary MessageStoreResult where 
  arbitrary = M.liftM MessageStoreResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MessageStoreResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MessageStoreResult{messageStoreResult_requestId = messageStoreResult_requestId obj} then P.Nothing else P.Just $ default_MessageStoreResult{messageStoreResult_requestId = messageStoreResult_requestId obj}
    , if obj == default_MessageStoreResult{messageStoreResult_messageIds = messageStoreResult_messageIds obj} then P.Nothing else P.Just $ default_MessageStoreResult{messageStoreResult_messageIds = messageStoreResult_messageIds obj}
    ]
from_MessageStoreResult :: MessageStoreResult -> T.ThriftVal
from_MessageStoreResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1315 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v1315))) $ messageStoreResult_requestId record
  , (\_v1315 -> P.Just (2, ("messageIds",T.TList T.T_STRING $ P.map (\_v1317 -> T.TString $ E.encodeUtf8 _v1317) $ Vector.toList _v1315))) $ messageStoreResult_messageIds record
  ]
write_MessageStoreResult :: T.Protocol p => p -> MessageStoreResult -> P.IO ()
write_MessageStoreResult oprot record = T.writeVal oprot $ from_MessageStoreResult record
encode_MessageStoreResult :: T.StatelessProtocol p => p -> MessageStoreResult -> LBS.ByteString
encode_MessageStoreResult oprot record = T.serializeVal oprot $ from_MessageStoreResult record
to_MessageStoreResult :: T.ThriftVal -> MessageStoreResult
to_MessageStoreResult (T.TStruct fields) = MessageStoreResult{
  messageStoreResult_requestId = P.maybe (messageStoreResult_requestId default_MessageStoreResult) (\(_,_val1319) -> (case _val1319 of {T.TString _val1320 -> E.decodeUtf8 _val1320; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  messageStoreResult_messageIds = P.maybe (messageStoreResult_messageIds default_MessageStoreResult) (\(_,_val1319) -> (case _val1319 of {T.TList _ _val1321 -> (Vector.fromList $ P.map (\_v1322 -> (case _v1322 of {T.TString _val1323 -> E.decodeUtf8 _val1323; _ -> P.error "wrong type"})) _val1321); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_MessageStoreResult _ = P.error "not a struct"
read_MessageStoreResult :: T.Protocol p => p -> P.IO MessageStoreResult
read_MessageStoreResult iprot = to_MessageStoreResult <$> T.readVal iprot (T.T_STRUCT typemap_MessageStoreResult)
decode_MessageStoreResult :: T.StatelessProtocol p => p -> LBS.ByteString -> MessageStoreResult
decode_MessageStoreResult iprot bs = to_MessageStoreResult $ T.deserializeVal iprot (T.T_STRUCT typemap_MessageStoreResult) bs
typemap_MessageStoreResult :: T.TypeMap
typemap_MessageStoreResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("messageIds",(T.T_LIST T.T_STRING)))]
default_MessageStoreResult :: MessageStoreResult
default_MessageStoreResult = MessageStoreResult{
  messageStoreResult_requestId = "",
  messageStoreResult_messageIds = Vector.empty}
data MetaProfile = MetaProfile  { metaProfile_createTime :: I.Int64
  , metaProfile_regionCode :: LT.Text
  , metaProfile_identities :: (Map.HashMap RegistrationType LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MetaProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` metaProfile_createTime record   `H.hashWithSalt` metaProfile_regionCode record   `H.hashWithSalt` metaProfile_identities record  
instance QC.Arbitrary MetaProfile where 
  arbitrary = M.liftM MetaProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MetaProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MetaProfile{metaProfile_createTime = metaProfile_createTime obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_createTime = metaProfile_createTime obj}
    , if obj == default_MetaProfile{metaProfile_regionCode = metaProfile_regionCode obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_regionCode = metaProfile_regionCode obj}
    , if obj == default_MetaProfile{metaProfile_identities = metaProfile_identities obj} then P.Nothing else P.Just $ default_MetaProfile{metaProfile_identities = metaProfile_identities obj}
    ]
from_MetaProfile :: MetaProfile -> T.ThriftVal
from_MetaProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1326 -> P.Just (1, ("createTime",T.TI64 _v1326))) $ metaProfile_createTime record
  , (\_v1326 -> P.Just (2, ("regionCode",T.TString $ E.encodeUtf8 _v1326))) $ metaProfile_regionCode record
  , (\_v1326 -> P.Just (3, ("identities",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k1327,_v1328) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k1327, T.TString $ E.encodeUtf8 _v1328)) $ Map.toList _v1326))) $ metaProfile_identities record
  ]
write_MetaProfile :: T.Protocol p => p -> MetaProfile -> P.IO ()
write_MetaProfile oprot record = T.writeVal oprot $ from_MetaProfile record
encode_MetaProfile :: T.StatelessProtocol p => p -> MetaProfile -> LBS.ByteString
encode_MetaProfile oprot record = T.serializeVal oprot $ from_MetaProfile record
to_MetaProfile :: T.ThriftVal -> MetaProfile
to_MetaProfile (T.TStruct fields) = MetaProfile{
  metaProfile_createTime = P.maybe (metaProfile_createTime default_MetaProfile) (\(_,_val1330) -> (case _val1330 of {T.TI64 _val1331 -> _val1331; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  metaProfile_regionCode = P.maybe (metaProfile_regionCode default_MetaProfile) (\(_,_val1330) -> (case _val1330 of {T.TString _val1332 -> E.decodeUtf8 _val1332; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  metaProfile_identities = P.maybe (metaProfile_identities default_MetaProfile) (\(_,_val1330) -> (case _val1330 of {T.TMap _ _ _val1333 -> (Map.fromList $ P.map (\(_k1335,_v1334) -> ((case _k1335 of {T.TI32 _val1336 -> P.toEnum $ P.fromIntegral _val1336; _ -> P.error "wrong type"}),(case _v1334 of {T.TString _val1337 -> E.decodeUtf8 _val1337; _ -> P.error "wrong type"}))) _val1333); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_MetaProfile _ = P.error "not a struct"
read_MetaProfile :: T.Protocol p => p -> P.IO MetaProfile
read_MetaProfile iprot = to_MetaProfile <$> T.readVal iprot (T.T_STRUCT typemap_MetaProfile)
decode_MetaProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> MetaProfile
decode_MetaProfile iprot bs = to_MetaProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_MetaProfile) bs
typemap_MetaProfile :: T.TypeMap
typemap_MetaProfile = Map.fromList [(1,("createTime",T.T_I64)),(2,("regionCode",T.T_STRING)),(3,("identities",(T.T_MAP T.T_I32 T.T_STRING)))]
default_MetaProfile :: MetaProfile
default_MetaProfile = MetaProfile{
  metaProfile_createTime = 0,
  metaProfile_regionCode = "",
  metaProfile_identities = Map.empty}
data NotificationItem = NotificationItem  { notificationItem_id :: LT.Text
  , notificationItem__from :: LT.Text
  , notificationItem_to :: LT.Text
  , notificationItem_fromChannel :: LT.Text
  , notificationItem_toChannel :: LT.Text
  , notificationItem_revision :: I.Int64
  , notificationItem_createdTime :: I.Int64
  , notificationItem_content :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationItem where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationItem_id record   `H.hashWithSalt` notificationItem__from record   `H.hashWithSalt` notificationItem_to record   `H.hashWithSalt` notificationItem_fromChannel record   `H.hashWithSalt` notificationItem_toChannel record   `H.hashWithSalt` notificationItem_revision record   `H.hashWithSalt` notificationItem_createdTime record   `H.hashWithSalt` notificationItem_content record  
instance QC.Arbitrary NotificationItem where 
  arbitrary = M.liftM NotificationItem (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationItem = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationItem{notificationItem_id = notificationItem_id obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_id = notificationItem_id obj}
    , if obj == default_NotificationItem{notificationItem__from = notificationItem__from obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem__from = notificationItem__from obj}
    , if obj == default_NotificationItem{notificationItem_to = notificationItem_to obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_to = notificationItem_to obj}
    , if obj == default_NotificationItem{notificationItem_fromChannel = notificationItem_fromChannel obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_fromChannel = notificationItem_fromChannel obj}
    , if obj == default_NotificationItem{notificationItem_toChannel = notificationItem_toChannel obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_toChannel = notificationItem_toChannel obj}
    , if obj == default_NotificationItem{notificationItem_revision = notificationItem_revision obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_revision = notificationItem_revision obj}
    , if obj == default_NotificationItem{notificationItem_createdTime = notificationItem_createdTime obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_createdTime = notificationItem_createdTime obj}
    , if obj == default_NotificationItem{notificationItem_content = notificationItem_content obj} then P.Nothing else P.Just $ default_NotificationItem{notificationItem_content = notificationItem_content obj}
    ]
from_NotificationItem :: NotificationItem -> T.ThriftVal
from_NotificationItem record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1340 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1340))) $ notificationItem_id record
  , (\_v1340 -> P.Just (2, ("_from",T.TString $ E.encodeUtf8 _v1340))) $ notificationItem__from record
  , (\_v1340 -> P.Just (3, ("to",T.TString $ E.encodeUtf8 _v1340))) $ notificationItem_to record
  , (\_v1340 -> P.Just (4, ("fromChannel",T.TString $ E.encodeUtf8 _v1340))) $ notificationItem_fromChannel record
  , (\_v1340 -> P.Just (5, ("toChannel",T.TString $ E.encodeUtf8 _v1340))) $ notificationItem_toChannel record
  , (\_v1340 -> P.Just (7, ("revision",T.TI64 _v1340))) $ notificationItem_revision record
  , (\_v1340 -> P.Just (8, ("createdTime",T.TI64 _v1340))) $ notificationItem_createdTime record
  , (\_v1340 -> P.Just (9, ("content",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k1341,_v1342) -> (T.TString $ E.encodeUtf8 _k1341, T.TString $ E.encodeUtf8 _v1342)) $ Map.toList _v1340))) $ notificationItem_content record
  ]
write_NotificationItem :: T.Protocol p => p -> NotificationItem -> P.IO ()
write_NotificationItem oprot record = T.writeVal oprot $ from_NotificationItem record
encode_NotificationItem :: T.StatelessProtocol p => p -> NotificationItem -> LBS.ByteString
encode_NotificationItem oprot record = T.serializeVal oprot $ from_NotificationItem record
to_NotificationItem :: T.ThriftVal -> NotificationItem
to_NotificationItem (T.TStruct fields) = NotificationItem{
  notificationItem_id = P.maybe (notificationItem_id default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TString _val1345 -> E.decodeUtf8 _val1345; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationItem__from = P.maybe (notificationItem__from default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TString _val1346 -> E.decodeUtf8 _val1346; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notificationItem_to = P.maybe (notificationItem_to default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TString _val1347 -> E.decodeUtf8 _val1347; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notificationItem_fromChannel = P.maybe (notificationItem_fromChannel default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TString _val1348 -> E.decodeUtf8 _val1348; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notificationItem_toChannel = P.maybe (notificationItem_toChannel default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TString _val1349 -> E.decodeUtf8 _val1349; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notificationItem_revision = P.maybe (notificationItem_revision default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TI64 _val1350 -> _val1350; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notificationItem_createdTime = P.maybe (notificationItem_createdTime default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TI64 _val1351 -> _val1351; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notificationItem_content = P.maybe (notificationItem_content default_NotificationItem) (\(_,_val1344) -> (case _val1344 of {T.TMap _ _ _val1352 -> (Map.fromList $ P.map (\(_k1354,_v1353) -> ((case _k1354 of {T.TString _val1355 -> E.decodeUtf8 _val1355; _ -> P.error "wrong type"}),(case _v1353 of {T.TString _val1356 -> E.decodeUtf8 _val1356; _ -> P.error "wrong type"}))) _val1352); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_NotificationItem _ = P.error "not a struct"
read_NotificationItem :: T.Protocol p => p -> P.IO NotificationItem
read_NotificationItem iprot = to_NotificationItem <$> T.readVal iprot (T.T_STRUCT typemap_NotificationItem)
decode_NotificationItem :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationItem
decode_NotificationItem iprot bs = to_NotificationItem $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationItem) bs
typemap_NotificationItem :: T.TypeMap
typemap_NotificationItem = Map.fromList [(1,("id",T.T_STRING)),(2,("_from",T.T_STRING)),(3,("to",T.T_STRING)),(4,("fromChannel",T.T_STRING)),(5,("toChannel",T.T_STRING)),(7,("revision",T.T_I64)),(8,("createdTime",T.T_I64)),(9,("content",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotificationItem :: NotificationItem
default_NotificationItem = NotificationItem{
  notificationItem_id = "",
  notificationItem__from = "",
  notificationItem_to = "",
  notificationItem_fromChannel = "",
  notificationItem_toChannel = "",
  notificationItem_revision = 0,
  notificationItem_createdTime = 0,
  notificationItem_content = Map.empty}
data NotificationFetchResult = NotificationFetchResult  { notificationFetchResult_fetchMode :: NotificationItemFetchMode
  , notificationFetchResult_itemList :: (Vector.Vector NotificationItem)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotificationFetchResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` notificationFetchResult_fetchMode record   `H.hashWithSalt` notificationFetchResult_itemList record  
instance QC.Arbitrary NotificationFetchResult where 
  arbitrary = M.liftM NotificationFetchResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotificationFetchResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotificationFetchResult{notificationFetchResult_fetchMode = notificationFetchResult_fetchMode obj} then P.Nothing else P.Just $ default_NotificationFetchResult{notificationFetchResult_fetchMode = notificationFetchResult_fetchMode obj}
    , if obj == default_NotificationFetchResult{notificationFetchResult_itemList = notificationFetchResult_itemList obj} then P.Nothing else P.Just $ default_NotificationFetchResult{notificationFetchResult_itemList = notificationFetchResult_itemList obj}
    ]
from_NotificationFetchResult :: NotificationFetchResult -> T.ThriftVal
from_NotificationFetchResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1359 -> P.Just (1, ("fetchMode",T.TI32 $ P.fromIntegral $ P.fromEnum _v1359))) $ notificationFetchResult_fetchMode record
  , (\_v1359 -> P.Just (2, ("itemList",T.TList (T.T_STRUCT typemap_NotificationItem) $ P.map (\_v1361 -> from_NotificationItem _v1361) $ Vector.toList _v1359))) $ notificationFetchResult_itemList record
  ]
write_NotificationFetchResult :: T.Protocol p => p -> NotificationFetchResult -> P.IO ()
write_NotificationFetchResult oprot record = T.writeVal oprot $ from_NotificationFetchResult record
encode_NotificationFetchResult :: T.StatelessProtocol p => p -> NotificationFetchResult -> LBS.ByteString
encode_NotificationFetchResult oprot record = T.serializeVal oprot $ from_NotificationFetchResult record
to_NotificationFetchResult :: T.ThriftVal -> NotificationFetchResult
to_NotificationFetchResult (T.TStruct fields) = NotificationFetchResult{
  notificationFetchResult_fetchMode = P.maybe (notificationFetchResult_fetchMode default_NotificationFetchResult) (\(_,_val1363) -> (case _val1363 of {T.TI32 _val1364 -> P.toEnum $ P.fromIntegral _val1364; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notificationFetchResult_itemList = P.maybe (notificationFetchResult_itemList default_NotificationFetchResult) (\(_,_val1363) -> (case _val1363 of {T.TList _ _val1365 -> (Vector.fromList $ P.map (\_v1366 -> (case _v1366 of {T.TStruct _val1367 -> (to_NotificationItem (T.TStruct _val1367)); _ -> P.error "wrong type"})) _val1365); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotificationFetchResult _ = P.error "not a struct"
read_NotificationFetchResult :: T.Protocol p => p -> P.IO NotificationFetchResult
read_NotificationFetchResult iprot = to_NotificationFetchResult <$> T.readVal iprot (T.T_STRUCT typemap_NotificationFetchResult)
decode_NotificationFetchResult :: T.StatelessProtocol p => p -> LBS.ByteString -> NotificationFetchResult
decode_NotificationFetchResult iprot bs = to_NotificationFetchResult $ T.deserializeVal iprot (T.T_STRUCT typemap_NotificationFetchResult) bs
typemap_NotificationFetchResult :: T.TypeMap
typemap_NotificationFetchResult = Map.fromList [(1,("fetchMode",T.T_I32)),(2,("itemList",(T.T_LIST (T.T_STRUCT typemap_NotificationItem))))]
default_NotificationFetchResult :: NotificationFetchResult
default_NotificationFetchResult = NotificationFetchResult{
  notificationFetchResult_fetchMode = (P.toEnum 0),
  notificationFetchResult_itemList = Vector.empty}
data Operation = Operation  { operation_revision :: I.Int64
  , operation_createdTime :: I.Int64
  , operation_type :: OpType
  , operation_reqSeq :: I.Int32
  , operation_checksum :: LT.Text
  , operation_status :: OpStatus
  , operation_param1 :: LT.Text
  , operation_param2 :: LT.Text
  , operation_param3 :: LT.Text
  , operation_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Operation where
  hashWithSalt salt record = salt   `H.hashWithSalt` operation_revision record   `H.hashWithSalt` operation_createdTime record   `H.hashWithSalt` operation_type record   `H.hashWithSalt` operation_reqSeq record   `H.hashWithSalt` operation_checksum record   `H.hashWithSalt` operation_status record   `H.hashWithSalt` operation_param1 record   `H.hashWithSalt` operation_param2 record   `H.hashWithSalt` operation_param3 record   `H.hashWithSalt` operation_message record  
instance QC.Arbitrary Operation where 
  arbitrary = M.liftM Operation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Operation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Operation{operation_revision = operation_revision obj} then P.Nothing else P.Just $ default_Operation{operation_revision = operation_revision obj}
    , if obj == default_Operation{operation_createdTime = operation_createdTime obj} then P.Nothing else P.Just $ default_Operation{operation_createdTime = operation_createdTime obj}
    , if obj == default_Operation{operation_type = operation_type obj} then P.Nothing else P.Just $ default_Operation{operation_type = operation_type obj}
    , if obj == default_Operation{operation_reqSeq = operation_reqSeq obj} then P.Nothing else P.Just $ default_Operation{operation_reqSeq = operation_reqSeq obj}
    , if obj == default_Operation{operation_checksum = operation_checksum obj} then P.Nothing else P.Just $ default_Operation{operation_checksum = operation_checksum obj}
    , if obj == default_Operation{operation_status = operation_status obj} then P.Nothing else P.Just $ default_Operation{operation_status = operation_status obj}
    , if obj == default_Operation{operation_param1 = operation_param1 obj} then P.Nothing else P.Just $ default_Operation{operation_param1 = operation_param1 obj}
    , if obj == default_Operation{operation_param2 = operation_param2 obj} then P.Nothing else P.Just $ default_Operation{operation_param2 = operation_param2 obj}
    , if obj == default_Operation{operation_param3 = operation_param3 obj} then P.Nothing else P.Just $ default_Operation{operation_param3 = operation_param3 obj}
    , if obj == default_Operation{operation_message = operation_message obj} then P.Nothing else P.Just $ default_Operation{operation_message = operation_message obj}
    ]
from_Operation :: Operation -> T.ThriftVal
from_Operation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1370 -> P.Just (1, ("revision",T.TI64 _v1370))) $ operation_revision record
  , (\_v1370 -> P.Just (2, ("createdTime",T.TI64 _v1370))) $ operation_createdTime record
  , (\_v1370 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1370))) $ operation_type record
  , (\_v1370 -> P.Just (4, ("reqSeq",T.TI32 _v1370))) $ operation_reqSeq record
  , (\_v1370 -> P.Just (5, ("checksum",T.TString $ E.encodeUtf8 _v1370))) $ operation_checksum record
  , (\_v1370 -> P.Just (7, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v1370))) $ operation_status record
  , (\_v1370 -> P.Just (10, ("param1",T.TString $ E.encodeUtf8 _v1370))) $ operation_param1 record
  , (\_v1370 -> P.Just (11, ("param2",T.TString $ E.encodeUtf8 _v1370))) $ operation_param2 record
  , (\_v1370 -> P.Just (12, ("param3",T.TString $ E.encodeUtf8 _v1370))) $ operation_param3 record
  , (\_v1370 -> P.Just (20, ("message",from_Message _v1370))) $ operation_message record
  ]
write_Operation :: T.Protocol p => p -> Operation -> P.IO ()
write_Operation oprot record = T.writeVal oprot $ from_Operation record
encode_Operation :: T.StatelessProtocol p => p -> Operation -> LBS.ByteString
encode_Operation oprot record = T.serializeVal oprot $ from_Operation record
to_Operation :: T.ThriftVal -> Operation
to_Operation (T.TStruct fields) = Operation{
  operation_revision = P.maybe (operation_revision default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TI64 _val1373 -> _val1373; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  operation_createdTime = P.maybe (operation_createdTime default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TI64 _val1374 -> _val1374; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  operation_type = P.maybe (operation_type default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TI32 _val1375 -> P.toEnum $ P.fromIntegral _val1375; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  operation_reqSeq = P.maybe (operation_reqSeq default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TI32 _val1376 -> _val1376; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  operation_checksum = P.maybe (operation_checksum default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TString _val1377 -> E.decodeUtf8 _val1377; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  operation_status = P.maybe (operation_status default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TI32 _val1378 -> P.toEnum $ P.fromIntegral _val1378; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  operation_param1 = P.maybe (operation_param1 default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TString _val1379 -> E.decodeUtf8 _val1379; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  operation_param2 = P.maybe (operation_param2 default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TString _val1380 -> E.decodeUtf8 _val1380; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  operation_param3 = P.maybe (operation_param3 default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TString _val1381 -> E.decodeUtf8 _val1381; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  operation_message = P.maybe (operation_message default_Operation) (\(_,_val1372) -> (case _val1372 of {T.TStruct _val1382 -> (to_Message (T.TStruct _val1382)); _ -> P.error "wrong type"})) (Map.lookup (20) fields)
  }
to_Operation _ = P.error "not a struct"
read_Operation :: T.Protocol p => p -> P.IO Operation
read_Operation iprot = to_Operation <$> T.readVal iprot (T.T_STRUCT typemap_Operation)
decode_Operation :: T.StatelessProtocol p => p -> LBS.ByteString -> Operation
decode_Operation iprot bs = to_Operation $ T.deserializeVal iprot (T.T_STRUCT typemap_Operation) bs
typemap_Operation :: T.TypeMap
typemap_Operation = Map.fromList [(1,("revision",T.T_I64)),(2,("createdTime",T.T_I64)),(3,("type",T.T_I32)),(4,("reqSeq",T.T_I32)),(5,("checksum",T.T_STRING)),(7,("status",T.T_I32)),(10,("param1",T.T_STRING)),(11,("param2",T.T_STRING)),(12,("param3",T.T_STRING)),(20,("message",(T.T_STRUCT typemap_Message)))]
default_Operation :: Operation
default_Operation = Operation{
  operation_revision = 0,
  operation_createdTime = 0,
  operation_type = (P.toEnum 0),
  operation_reqSeq = 0,
  operation_checksum = "",
  operation_status = (P.toEnum 0),
  operation_param1 = "",
  operation_param2 = "",
  operation_param3 = "",
  operation_message = default_Message}
data PaymentReservation = PaymentReservation  { paymentReservation_receiverMid :: LT.Text
  , paymentReservation_productId :: LT.Text
  , paymentReservation_language :: LT.Text
  , paymentReservation_location :: LT.Text
  , paymentReservation_currency :: LT.Text
  , paymentReservation_price :: LT.Text
  , paymentReservation_appStoreCode :: PaymentType
  , paymentReservation_messageText :: LT.Text
  , paymentReservation_messageTemplate :: I.Int32
  , paymentReservation_packageId :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaymentReservation where
  hashWithSalt salt record = salt   `H.hashWithSalt` paymentReservation_receiverMid record   `H.hashWithSalt` paymentReservation_productId record   `H.hashWithSalt` paymentReservation_language record   `H.hashWithSalt` paymentReservation_location record   `H.hashWithSalt` paymentReservation_currency record   `H.hashWithSalt` paymentReservation_price record   `H.hashWithSalt` paymentReservation_appStoreCode record   `H.hashWithSalt` paymentReservation_messageText record   `H.hashWithSalt` paymentReservation_messageTemplate record   `H.hashWithSalt` paymentReservation_packageId record  
instance QC.Arbitrary PaymentReservation where 
  arbitrary = M.liftM PaymentReservation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaymentReservation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaymentReservation{paymentReservation_receiverMid = paymentReservation_receiverMid obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_receiverMid = paymentReservation_receiverMid obj}
    , if obj == default_PaymentReservation{paymentReservation_productId = paymentReservation_productId obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_productId = paymentReservation_productId obj}
    , if obj == default_PaymentReservation{paymentReservation_language = paymentReservation_language obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_language = paymentReservation_language obj}
    , if obj == default_PaymentReservation{paymentReservation_location = paymentReservation_location obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_location = paymentReservation_location obj}
    , if obj == default_PaymentReservation{paymentReservation_currency = paymentReservation_currency obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_currency = paymentReservation_currency obj}
    , if obj == default_PaymentReservation{paymentReservation_price = paymentReservation_price obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_price = paymentReservation_price obj}
    , if obj == default_PaymentReservation{paymentReservation_appStoreCode = paymentReservation_appStoreCode obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_appStoreCode = paymentReservation_appStoreCode obj}
    , if obj == default_PaymentReservation{paymentReservation_messageText = paymentReservation_messageText obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_messageText = paymentReservation_messageText obj}
    , if obj == default_PaymentReservation{paymentReservation_messageTemplate = paymentReservation_messageTemplate obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_messageTemplate = paymentReservation_messageTemplate obj}
    , if obj == default_PaymentReservation{paymentReservation_packageId = paymentReservation_packageId obj} then P.Nothing else P.Just $ default_PaymentReservation{paymentReservation_packageId = paymentReservation_packageId obj}
    ]
from_PaymentReservation :: PaymentReservation -> T.ThriftVal
from_PaymentReservation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1385 -> P.Just (1, ("receiverMid",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_receiverMid record
  , (\_v1385 -> P.Just (2, ("productId",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_productId record
  , (\_v1385 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_language record
  , (\_v1385 -> P.Just (4, ("location",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_location record
  , (\_v1385 -> P.Just (5, ("currency",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_currency record
  , (\_v1385 -> P.Just (6, ("price",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_price record
  , (\_v1385 -> P.Just (7, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v1385))) $ paymentReservation_appStoreCode record
  , (\_v1385 -> P.Just (8, ("messageText",T.TString $ E.encodeUtf8 _v1385))) $ paymentReservation_messageText record
  , (\_v1385 -> P.Just (9, ("messageTemplate",T.TI32 _v1385))) $ paymentReservation_messageTemplate record
  , (\_v1385 -> P.Just (10, ("packageId",T.TI64 _v1385))) $ paymentReservation_packageId record
  ]
write_PaymentReservation :: T.Protocol p => p -> PaymentReservation -> P.IO ()
write_PaymentReservation oprot record = T.writeVal oprot $ from_PaymentReservation record
encode_PaymentReservation :: T.StatelessProtocol p => p -> PaymentReservation -> LBS.ByteString
encode_PaymentReservation oprot record = T.serializeVal oprot $ from_PaymentReservation record
to_PaymentReservation :: T.ThriftVal -> PaymentReservation
to_PaymentReservation (T.TStruct fields) = PaymentReservation{
  paymentReservation_receiverMid = P.maybe (paymentReservation_receiverMid default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1388 -> E.decodeUtf8 _val1388; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paymentReservation_productId = P.maybe (paymentReservation_productId default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1389 -> E.decodeUtf8 _val1389; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paymentReservation_language = P.maybe (paymentReservation_language default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1390 -> E.decodeUtf8 _val1390; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  paymentReservation_location = P.maybe (paymentReservation_location default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1391 -> E.decodeUtf8 _val1391; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  paymentReservation_currency = P.maybe (paymentReservation_currency default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1392 -> E.decodeUtf8 _val1392; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  paymentReservation_price = P.maybe (paymentReservation_price default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1393 -> E.decodeUtf8 _val1393; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  paymentReservation_appStoreCode = P.maybe (paymentReservation_appStoreCode default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TI32 _val1394 -> P.toEnum $ P.fromIntegral _val1394; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  paymentReservation_messageText = P.maybe (paymentReservation_messageText default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TString _val1395 -> E.decodeUtf8 _val1395; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  paymentReservation_messageTemplate = P.maybe (paymentReservation_messageTemplate default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TI32 _val1396 -> _val1396; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  paymentReservation_packageId = P.maybe (paymentReservation_packageId default_PaymentReservation) (\(_,_val1387) -> (case _val1387 of {T.TI64 _val1397 -> _val1397; _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_PaymentReservation _ = P.error "not a struct"
read_PaymentReservation :: T.Protocol p => p -> P.IO PaymentReservation
read_PaymentReservation iprot = to_PaymentReservation <$> T.readVal iprot (T.T_STRUCT typemap_PaymentReservation)
decode_PaymentReservation :: T.StatelessProtocol p => p -> LBS.ByteString -> PaymentReservation
decode_PaymentReservation iprot bs = to_PaymentReservation $ T.deserializeVal iprot (T.T_STRUCT typemap_PaymentReservation) bs
typemap_PaymentReservation :: T.TypeMap
typemap_PaymentReservation = Map.fromList [(1,("receiverMid",T.T_STRING)),(2,("productId",T.T_STRING)),(3,("language",T.T_STRING)),(4,("location",T.T_STRING)),(5,("currency",T.T_STRING)),(6,("price",T.T_STRING)),(7,("appStoreCode",T.T_I32)),(8,("messageText",T.T_STRING)),(9,("messageTemplate",T.T_I32)),(10,("packageId",T.T_I64))]
default_PaymentReservation :: PaymentReservation
default_PaymentReservation = PaymentReservation{
  paymentReservation_receiverMid = "",
  paymentReservation_productId = "",
  paymentReservation_language = "",
  paymentReservation_location = "",
  paymentReservation_currency = "",
  paymentReservation_price = "",
  paymentReservation_appStoreCode = (P.toEnum 0),
  paymentReservation_messageText = "",
  paymentReservation_messageTemplate = 0,
  paymentReservation_packageId = 0}
data PaymentReservationResult = PaymentReservationResult  { paymentReservationResult_orderId :: LT.Text
  , paymentReservationResult_confirmUrl :: LT.Text
  , paymentReservationResult_extras :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PaymentReservationResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` paymentReservationResult_orderId record   `H.hashWithSalt` paymentReservationResult_confirmUrl record   `H.hashWithSalt` paymentReservationResult_extras record  
instance QC.Arbitrary PaymentReservationResult where 
  arbitrary = M.liftM PaymentReservationResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PaymentReservationResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PaymentReservationResult{paymentReservationResult_orderId = paymentReservationResult_orderId obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_orderId = paymentReservationResult_orderId obj}
    , if obj == default_PaymentReservationResult{paymentReservationResult_confirmUrl = paymentReservationResult_confirmUrl obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_confirmUrl = paymentReservationResult_confirmUrl obj}
    , if obj == default_PaymentReservationResult{paymentReservationResult_extras = paymentReservationResult_extras obj} then P.Nothing else P.Just $ default_PaymentReservationResult{paymentReservationResult_extras = paymentReservationResult_extras obj}
    ]
from_PaymentReservationResult :: PaymentReservationResult -> T.ThriftVal
from_PaymentReservationResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1400 -> P.Just (1, ("orderId",T.TString $ E.encodeUtf8 _v1400))) $ paymentReservationResult_orderId record
  , (\_v1400 -> P.Just (2, ("confirmUrl",T.TString $ E.encodeUtf8 _v1400))) $ paymentReservationResult_confirmUrl record
  , (\_v1400 -> P.Just (3, ("extras",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k1401,_v1402) -> (T.TString $ E.encodeUtf8 _k1401, T.TString $ E.encodeUtf8 _v1402)) $ Map.toList _v1400))) $ paymentReservationResult_extras record
  ]
write_PaymentReservationResult :: T.Protocol p => p -> PaymentReservationResult -> P.IO ()
write_PaymentReservationResult oprot record = T.writeVal oprot $ from_PaymentReservationResult record
encode_PaymentReservationResult :: T.StatelessProtocol p => p -> PaymentReservationResult -> LBS.ByteString
encode_PaymentReservationResult oprot record = T.serializeVal oprot $ from_PaymentReservationResult record
to_PaymentReservationResult :: T.ThriftVal -> PaymentReservationResult
to_PaymentReservationResult (T.TStruct fields) = PaymentReservationResult{
  paymentReservationResult_orderId = P.maybe (paymentReservationResult_orderId default_PaymentReservationResult) (\(_,_val1404) -> (case _val1404 of {T.TString _val1405 -> E.decodeUtf8 _val1405; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  paymentReservationResult_confirmUrl = P.maybe (paymentReservationResult_confirmUrl default_PaymentReservationResult) (\(_,_val1404) -> (case _val1404 of {T.TString _val1406 -> E.decodeUtf8 _val1406; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  paymentReservationResult_extras = P.maybe (paymentReservationResult_extras default_PaymentReservationResult) (\(_,_val1404) -> (case _val1404 of {T.TMap _ _ _val1407 -> (Map.fromList $ P.map (\(_k1409,_v1408) -> ((case _k1409 of {T.TString _val1410 -> E.decodeUtf8 _val1410; _ -> P.error "wrong type"}),(case _v1408 of {T.TString _val1411 -> E.decodeUtf8 _val1411; _ -> P.error "wrong type"}))) _val1407); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PaymentReservationResult _ = P.error "not a struct"
read_PaymentReservationResult :: T.Protocol p => p -> P.IO PaymentReservationResult
read_PaymentReservationResult iprot = to_PaymentReservationResult <$> T.readVal iprot (T.T_STRUCT typemap_PaymentReservationResult)
decode_PaymentReservationResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PaymentReservationResult
decode_PaymentReservationResult iprot bs = to_PaymentReservationResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PaymentReservationResult) bs
typemap_PaymentReservationResult :: T.TypeMap
typemap_PaymentReservationResult = Map.fromList [(1,("orderId",T.T_STRING)),(2,("confirmUrl",T.T_STRING)),(3,("extras",(T.T_MAP T.T_STRING T.T_STRING)))]
default_PaymentReservationResult :: PaymentReservationResult
default_PaymentReservationResult = PaymentReservationResult{
  paymentReservationResult_orderId = "",
  paymentReservationResult_confirmUrl = "",
  paymentReservationResult_extras = Map.empty}
data Product = Product  { product_productId :: LT.Text
  , product_packageId :: I.Int64
  , product_version :: I.Int32
  , product_authorName :: LT.Text
  , product_onSale :: P.Bool
  , product_validDays :: I.Int32
  , product_saleType :: I.Int32
  , product_copyright :: LT.Text
  , product_title :: LT.Text
  , product_descriptionText :: LT.Text
  , product_shopOrderId :: I.Int64
  , product_fromMid :: LT.Text
  , product_toMid :: LT.Text
  , product_validUntil :: I.Int64
  , product_priceTier :: I.Int32
  , product_price :: LT.Text
  , product_currency :: LT.Text
  , product_currencySymbol :: LT.Text
  , product_paymentType :: PaymentType
  , product_createDate :: I.Int64
  , product_ownFlag :: P.Bool
  , product_eventType :: ProductEventType
  , product_urlSchema :: LT.Text
  , product_downloadUrl :: LT.Text
  , product_buddyMid :: LT.Text
  , product_publishSince :: I.Int64
  , product_newFlag :: P.Bool
  , product_missionFlag :: P.Bool
  , product_categories :: (Vector.Vector ProductCategory)
  , product_missionButtonText :: LT.Text
  , product_missionShortDescription :: LT.Text
  , product_authorId :: LT.Text
  , product_grantedByDefault :: P.Bool
  , product_displayOrder :: I.Int32
  , product_availableForPresent :: P.Bool
  , product_availableForMyself :: P.Bool
  , product_hasAnimation :: P.Bool
  , product_hasSound :: P.Bool
  , product_recommendationsEnabled :: P.Bool
  , product_stickerResourceType :: StickerResourceType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Product where
  hashWithSalt salt record = salt   `H.hashWithSalt` product_productId record   `H.hashWithSalt` product_packageId record   `H.hashWithSalt` product_version record   `H.hashWithSalt` product_authorName record   `H.hashWithSalt` product_onSale record   `H.hashWithSalt` product_validDays record   `H.hashWithSalt` product_saleType record   `H.hashWithSalt` product_copyright record   `H.hashWithSalt` product_title record   `H.hashWithSalt` product_descriptionText record   `H.hashWithSalt` product_shopOrderId record   `H.hashWithSalt` product_fromMid record   `H.hashWithSalt` product_toMid record   `H.hashWithSalt` product_validUntil record   `H.hashWithSalt` product_priceTier record   `H.hashWithSalt` product_price record   `H.hashWithSalt` product_currency record   `H.hashWithSalt` product_currencySymbol record   `H.hashWithSalt` product_paymentType record   `H.hashWithSalt` product_createDate record   `H.hashWithSalt` product_ownFlag record   `H.hashWithSalt` product_eventType record   `H.hashWithSalt` product_urlSchema record   `H.hashWithSalt` product_downloadUrl record   `H.hashWithSalt` product_buddyMid record   `H.hashWithSalt` product_publishSince record   `H.hashWithSalt` product_newFlag record   `H.hashWithSalt` product_missionFlag record   `H.hashWithSalt` product_categories record   `H.hashWithSalt` product_missionButtonText record   `H.hashWithSalt` product_missionShortDescription record   `H.hashWithSalt` product_authorId record   `H.hashWithSalt` product_grantedByDefault record   `H.hashWithSalt` product_displayOrder record   `H.hashWithSalt` product_availableForPresent record   `H.hashWithSalt` product_availableForMyself record   `H.hashWithSalt` product_hasAnimation record   `H.hashWithSalt` product_hasSound record   `H.hashWithSalt` product_recommendationsEnabled record   `H.hashWithSalt` product_stickerResourceType record  
instance QC.Arbitrary Product where 
  arbitrary = M.liftM Product (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Product = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Product{product_productId = product_productId obj} then P.Nothing else P.Just $ default_Product{product_productId = product_productId obj}
    , if obj == default_Product{product_packageId = product_packageId obj} then P.Nothing else P.Just $ default_Product{product_packageId = product_packageId obj}
    , if obj == default_Product{product_version = product_version obj} then P.Nothing else P.Just $ default_Product{product_version = product_version obj}
    , if obj == default_Product{product_authorName = product_authorName obj} then P.Nothing else P.Just $ default_Product{product_authorName = product_authorName obj}
    , if obj == default_Product{product_onSale = product_onSale obj} then P.Nothing else P.Just $ default_Product{product_onSale = product_onSale obj}
    , if obj == default_Product{product_validDays = product_validDays obj} then P.Nothing else P.Just $ default_Product{product_validDays = product_validDays obj}
    , if obj == default_Product{product_saleType = product_saleType obj} then P.Nothing else P.Just $ default_Product{product_saleType = product_saleType obj}
    , if obj == default_Product{product_copyright = product_copyright obj} then P.Nothing else P.Just $ default_Product{product_copyright = product_copyright obj}
    , if obj == default_Product{product_title = product_title obj} then P.Nothing else P.Just $ default_Product{product_title = product_title obj}
    , if obj == default_Product{product_descriptionText = product_descriptionText obj} then P.Nothing else P.Just $ default_Product{product_descriptionText = product_descriptionText obj}
    , if obj == default_Product{product_shopOrderId = product_shopOrderId obj} then P.Nothing else P.Just $ default_Product{product_shopOrderId = product_shopOrderId obj}
    , if obj == default_Product{product_fromMid = product_fromMid obj} then P.Nothing else P.Just $ default_Product{product_fromMid = product_fromMid obj}
    , if obj == default_Product{product_toMid = product_toMid obj} then P.Nothing else P.Just $ default_Product{product_toMid = product_toMid obj}
    , if obj == default_Product{product_validUntil = product_validUntil obj} then P.Nothing else P.Just $ default_Product{product_validUntil = product_validUntil obj}
    , if obj == default_Product{product_priceTier = product_priceTier obj} then P.Nothing else P.Just $ default_Product{product_priceTier = product_priceTier obj}
    , if obj == default_Product{product_price = product_price obj} then P.Nothing else P.Just $ default_Product{product_price = product_price obj}
    , if obj == default_Product{product_currency = product_currency obj} then P.Nothing else P.Just $ default_Product{product_currency = product_currency obj}
    , if obj == default_Product{product_currencySymbol = product_currencySymbol obj} then P.Nothing else P.Just $ default_Product{product_currencySymbol = product_currencySymbol obj}
    , if obj == default_Product{product_paymentType = product_paymentType obj} then P.Nothing else P.Just $ default_Product{product_paymentType = product_paymentType obj}
    , if obj == default_Product{product_createDate = product_createDate obj} then P.Nothing else P.Just $ default_Product{product_createDate = product_createDate obj}
    , if obj == default_Product{product_ownFlag = product_ownFlag obj} then P.Nothing else P.Just $ default_Product{product_ownFlag = product_ownFlag obj}
    , if obj == default_Product{product_eventType = product_eventType obj} then P.Nothing else P.Just $ default_Product{product_eventType = product_eventType obj}
    , if obj == default_Product{product_urlSchema = product_urlSchema obj} then P.Nothing else P.Just $ default_Product{product_urlSchema = product_urlSchema obj}
    , if obj == default_Product{product_downloadUrl = product_downloadUrl obj} then P.Nothing else P.Just $ default_Product{product_downloadUrl = product_downloadUrl obj}
    , if obj == default_Product{product_buddyMid = product_buddyMid obj} then P.Nothing else P.Just $ default_Product{product_buddyMid = product_buddyMid obj}
    , if obj == default_Product{product_publishSince = product_publishSince obj} then P.Nothing else P.Just $ default_Product{product_publishSince = product_publishSince obj}
    , if obj == default_Product{product_newFlag = product_newFlag obj} then P.Nothing else P.Just $ default_Product{product_newFlag = product_newFlag obj}
    , if obj == default_Product{product_missionFlag = product_missionFlag obj} then P.Nothing else P.Just $ default_Product{product_missionFlag = product_missionFlag obj}
    , if obj == default_Product{product_categories = product_categories obj} then P.Nothing else P.Just $ default_Product{product_categories = product_categories obj}
    , if obj == default_Product{product_missionButtonText = product_missionButtonText obj} then P.Nothing else P.Just $ default_Product{product_missionButtonText = product_missionButtonText obj}
    , if obj == default_Product{product_missionShortDescription = product_missionShortDescription obj} then P.Nothing else P.Just $ default_Product{product_missionShortDescription = product_missionShortDescription obj}
    , if obj == default_Product{product_authorId = product_authorId obj} then P.Nothing else P.Just $ default_Product{product_authorId = product_authorId obj}
    , if obj == default_Product{product_grantedByDefault = product_grantedByDefault obj} then P.Nothing else P.Just $ default_Product{product_grantedByDefault = product_grantedByDefault obj}
    , if obj == default_Product{product_displayOrder = product_displayOrder obj} then P.Nothing else P.Just $ default_Product{product_displayOrder = product_displayOrder obj}
    , if obj == default_Product{product_availableForPresent = product_availableForPresent obj} then P.Nothing else P.Just $ default_Product{product_availableForPresent = product_availableForPresent obj}
    , if obj == default_Product{product_availableForMyself = product_availableForMyself obj} then P.Nothing else P.Just $ default_Product{product_availableForMyself = product_availableForMyself obj}
    , if obj == default_Product{product_hasAnimation = product_hasAnimation obj} then P.Nothing else P.Just $ default_Product{product_hasAnimation = product_hasAnimation obj}
    , if obj == default_Product{product_hasSound = product_hasSound obj} then P.Nothing else P.Just $ default_Product{product_hasSound = product_hasSound obj}
    , if obj == default_Product{product_recommendationsEnabled = product_recommendationsEnabled obj} then P.Nothing else P.Just $ default_Product{product_recommendationsEnabled = product_recommendationsEnabled obj}
    , if obj == default_Product{product_stickerResourceType = product_stickerResourceType obj} then P.Nothing else P.Just $ default_Product{product_stickerResourceType = product_stickerResourceType obj}
    ]
from_Product :: Product -> T.ThriftVal
from_Product record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1414 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v1414))) $ product_productId record
  , (\_v1414 -> P.Just (2, ("packageId",T.TI64 _v1414))) $ product_packageId record
  , (\_v1414 -> P.Just (3, ("version",T.TI32 _v1414))) $ product_version record
  , (\_v1414 -> P.Just (4, ("authorName",T.TString $ E.encodeUtf8 _v1414))) $ product_authorName record
  , (\_v1414 -> P.Just (5, ("onSale",T.TBool _v1414))) $ product_onSale record
  , (\_v1414 -> P.Just (6, ("validDays",T.TI32 _v1414))) $ product_validDays record
  , (\_v1414 -> P.Just (7, ("saleType",T.TI32 _v1414))) $ product_saleType record
  , (\_v1414 -> P.Just (8, ("copyright",T.TString $ E.encodeUtf8 _v1414))) $ product_copyright record
  , (\_v1414 -> P.Just (9, ("title",T.TString $ E.encodeUtf8 _v1414))) $ product_title record
  , (\_v1414 -> P.Just (10, ("descriptionText",T.TString $ E.encodeUtf8 _v1414))) $ product_descriptionText record
  , (\_v1414 -> P.Just (11, ("shopOrderId",T.TI64 _v1414))) $ product_shopOrderId record
  , (\_v1414 -> P.Just (12, ("fromMid",T.TString $ E.encodeUtf8 _v1414))) $ product_fromMid record
  , (\_v1414 -> P.Just (13, ("toMid",T.TString $ E.encodeUtf8 _v1414))) $ product_toMid record
  , (\_v1414 -> P.Just (14, ("validUntil",T.TI64 _v1414))) $ product_validUntil record
  , (\_v1414 -> P.Just (15, ("priceTier",T.TI32 _v1414))) $ product_priceTier record
  , (\_v1414 -> P.Just (16, ("price",T.TString $ E.encodeUtf8 _v1414))) $ product_price record
  , (\_v1414 -> P.Just (17, ("currency",T.TString $ E.encodeUtf8 _v1414))) $ product_currency record
  , (\_v1414 -> P.Just (18, ("currencySymbol",T.TString $ E.encodeUtf8 _v1414))) $ product_currencySymbol record
  , (\_v1414 -> P.Just (19, ("paymentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1414))) $ product_paymentType record
  , (\_v1414 -> P.Just (20, ("createDate",T.TI64 _v1414))) $ product_createDate record
  , (\_v1414 -> P.Just (21, ("ownFlag",T.TBool _v1414))) $ product_ownFlag record
  , (\_v1414 -> P.Just (22, ("eventType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1414))) $ product_eventType record
  , (\_v1414 -> P.Just (23, ("urlSchema",T.TString $ E.encodeUtf8 _v1414))) $ product_urlSchema record
  , (\_v1414 -> P.Just (24, ("downloadUrl",T.TString $ E.encodeUtf8 _v1414))) $ product_downloadUrl record
  , (\_v1414 -> P.Just (25, ("buddyMid",T.TString $ E.encodeUtf8 _v1414))) $ product_buddyMid record
  , (\_v1414 -> P.Just (26, ("publishSince",T.TI64 _v1414))) $ product_publishSince record
  , (\_v1414 -> P.Just (27, ("newFlag",T.TBool _v1414))) $ product_newFlag record
  , (\_v1414 -> P.Just (28, ("missionFlag",T.TBool _v1414))) $ product_missionFlag record
  , (\_v1414 -> P.Just (29, ("categories",T.TList (T.T_STRUCT typemap_ProductCategory) $ P.map (\_v1416 -> from_ProductCategory _v1416) $ Vector.toList _v1414))) $ product_categories record
  , (\_v1414 -> P.Just (30, ("missionButtonText",T.TString $ E.encodeUtf8 _v1414))) $ product_missionButtonText record
  , (\_v1414 -> P.Just (31, ("missionShortDescription",T.TString $ E.encodeUtf8 _v1414))) $ product_missionShortDescription record
  , (\_v1414 -> P.Just (32, ("authorId",T.TString $ E.encodeUtf8 _v1414))) $ product_authorId record
  , (\_v1414 -> P.Just (41, ("grantedByDefault",T.TBool _v1414))) $ product_grantedByDefault record
  , (\_v1414 -> P.Just (42, ("displayOrder",T.TI32 _v1414))) $ product_displayOrder record
  , (\_v1414 -> P.Just (43, ("availableForPresent",T.TBool _v1414))) $ product_availableForPresent record
  , (\_v1414 -> P.Just (44, ("availableForMyself",T.TBool _v1414))) $ product_availableForMyself record
  , (\_v1414 -> P.Just (51, ("hasAnimation",T.TBool _v1414))) $ product_hasAnimation record
  , (\_v1414 -> P.Just (52, ("hasSound",T.TBool _v1414))) $ product_hasSound record
  , (\_v1414 -> P.Just (53, ("recommendationsEnabled",T.TBool _v1414))) $ product_recommendationsEnabled record
  , (\_v1414 -> P.Just (54, ("stickerResourceType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1414))) $ product_stickerResourceType record
  ]
write_Product :: T.Protocol p => p -> Product -> P.IO ()
write_Product oprot record = T.writeVal oprot $ from_Product record
encode_Product :: T.StatelessProtocol p => p -> Product -> LBS.ByteString
encode_Product oprot record = T.serializeVal oprot $ from_Product record
to_Product :: T.ThriftVal -> Product
to_Product (T.TStruct fields) = Product{
  product_productId = P.maybe (product_productId default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1419 -> E.decodeUtf8 _val1419; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  product_packageId = P.maybe (product_packageId default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI64 _val1420 -> _val1420; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  product_version = P.maybe (product_version default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1421 -> _val1421; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  product_authorName = P.maybe (product_authorName default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1422 -> E.decodeUtf8 _val1422; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  product_onSale = P.maybe (product_onSale default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1423 -> _val1423; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  product_validDays = P.maybe (product_validDays default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1424 -> _val1424; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  product_saleType = P.maybe (product_saleType default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1425 -> _val1425; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  product_copyright = P.maybe (product_copyright default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1426 -> E.decodeUtf8 _val1426; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  product_title = P.maybe (product_title default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1427 -> E.decodeUtf8 _val1427; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  product_descriptionText = P.maybe (product_descriptionText default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1428 -> E.decodeUtf8 _val1428; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  product_shopOrderId = P.maybe (product_shopOrderId default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI64 _val1429 -> _val1429; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  product_fromMid = P.maybe (product_fromMid default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1430 -> E.decodeUtf8 _val1430; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  product_toMid = P.maybe (product_toMid default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1431 -> E.decodeUtf8 _val1431; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  product_validUntil = P.maybe (product_validUntil default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI64 _val1432 -> _val1432; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  product_priceTier = P.maybe (product_priceTier default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1433 -> _val1433; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  product_price = P.maybe (product_price default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1434 -> E.decodeUtf8 _val1434; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  product_currency = P.maybe (product_currency default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1435 -> E.decodeUtf8 _val1435; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  product_currencySymbol = P.maybe (product_currencySymbol default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1436 -> E.decodeUtf8 _val1436; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  product_paymentType = P.maybe (product_paymentType default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1437 -> P.toEnum $ P.fromIntegral _val1437; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  product_createDate = P.maybe (product_createDate default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI64 _val1438 -> _val1438; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  product_ownFlag = P.maybe (product_ownFlag default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1439 -> _val1439; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  product_eventType = P.maybe (product_eventType default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1440 -> P.toEnum $ P.fromIntegral _val1440; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  product_urlSchema = P.maybe (product_urlSchema default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1441 -> E.decodeUtf8 _val1441; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  product_downloadUrl = P.maybe (product_downloadUrl default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1442 -> E.decodeUtf8 _val1442; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  product_buddyMid = P.maybe (product_buddyMid default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1443 -> E.decodeUtf8 _val1443; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  product_publishSince = P.maybe (product_publishSince default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI64 _val1444 -> _val1444; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  product_newFlag = P.maybe (product_newFlag default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1445 -> _val1445; _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  product_missionFlag = P.maybe (product_missionFlag default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1446 -> _val1446; _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  product_categories = P.maybe (product_categories default_Product) (\(_,_val1418) -> (case _val1418 of {T.TList _ _val1447 -> (Vector.fromList $ P.map (\_v1448 -> (case _v1448 of {T.TStruct _val1449 -> (to_ProductCategory (T.TStruct _val1449)); _ -> P.error "wrong type"})) _val1447); _ -> P.error "wrong type"})) (Map.lookup (29) fields),
  product_missionButtonText = P.maybe (product_missionButtonText default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1450 -> E.decodeUtf8 _val1450; _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  product_missionShortDescription = P.maybe (product_missionShortDescription default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1451 -> E.decodeUtf8 _val1451; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  product_authorId = P.maybe (product_authorId default_Product) (\(_,_val1418) -> (case _val1418 of {T.TString _val1452 -> E.decodeUtf8 _val1452; _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  product_grantedByDefault = P.maybe (product_grantedByDefault default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1453 -> _val1453; _ -> P.error "wrong type"})) (Map.lookup (41) fields),
  product_displayOrder = P.maybe (product_displayOrder default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1454 -> _val1454; _ -> P.error "wrong type"})) (Map.lookup (42) fields),
  product_availableForPresent = P.maybe (product_availableForPresent default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1455 -> _val1455; _ -> P.error "wrong type"})) (Map.lookup (43) fields),
  product_availableForMyself = P.maybe (product_availableForMyself default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1456 -> _val1456; _ -> P.error "wrong type"})) (Map.lookup (44) fields),
  product_hasAnimation = P.maybe (product_hasAnimation default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1457 -> _val1457; _ -> P.error "wrong type"})) (Map.lookup (51) fields),
  product_hasSound = P.maybe (product_hasSound default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1458 -> _val1458; _ -> P.error "wrong type"})) (Map.lookup (52) fields),
  product_recommendationsEnabled = P.maybe (product_recommendationsEnabled default_Product) (\(_,_val1418) -> (case _val1418 of {T.TBool _val1459 -> _val1459; _ -> P.error "wrong type"})) (Map.lookup (53) fields),
  product_stickerResourceType = P.maybe (product_stickerResourceType default_Product) (\(_,_val1418) -> (case _val1418 of {T.TI32 _val1460 -> P.toEnum $ P.fromIntegral _val1460; _ -> P.error "wrong type"})) (Map.lookup (54) fields)
  }
to_Product _ = P.error "not a struct"
read_Product :: T.Protocol p => p -> P.IO Product
read_Product iprot = to_Product <$> T.readVal iprot (T.T_STRUCT typemap_Product)
decode_Product :: T.StatelessProtocol p => p -> LBS.ByteString -> Product
decode_Product iprot bs = to_Product $ T.deserializeVal iprot (T.T_STRUCT typemap_Product) bs
typemap_Product :: T.TypeMap
typemap_Product = Map.fromList [(1,("productId",T.T_STRING)),(2,("packageId",T.T_I64)),(3,("version",T.T_I32)),(4,("authorName",T.T_STRING)),(5,("onSale",T.T_BOOL)),(6,("validDays",T.T_I32)),(7,("saleType",T.T_I32)),(8,("copyright",T.T_STRING)),(9,("title",T.T_STRING)),(10,("descriptionText",T.T_STRING)),(11,("shopOrderId",T.T_I64)),(12,("fromMid",T.T_STRING)),(13,("toMid",T.T_STRING)),(14,("validUntil",T.T_I64)),(15,("priceTier",T.T_I32)),(16,("price",T.T_STRING)),(17,("currency",T.T_STRING)),(18,("currencySymbol",T.T_STRING)),(19,("paymentType",T.T_I32)),(20,("createDate",T.T_I64)),(21,("ownFlag",T.T_BOOL)),(22,("eventType",T.T_I32)),(23,("urlSchema",T.T_STRING)),(24,("downloadUrl",T.T_STRING)),(25,("buddyMid",T.T_STRING)),(26,("publishSince",T.T_I64)),(27,("newFlag",T.T_BOOL)),(28,("missionFlag",T.T_BOOL)),(29,("categories",(T.T_LIST (T.T_STRUCT typemap_ProductCategory)))),(30,("missionButtonText",T.T_STRING)),(31,("missionShortDescription",T.T_STRING)),(32,("authorId",T.T_STRING)),(41,("grantedByDefault",T.T_BOOL)),(42,("displayOrder",T.T_I32)),(43,("availableForPresent",T.T_BOOL)),(44,("availableForMyself",T.T_BOOL)),(51,("hasAnimation",T.T_BOOL)),(52,("hasSound",T.T_BOOL)),(53,("recommendationsEnabled",T.T_BOOL)),(54,("stickerResourceType",T.T_I32))]
default_Product :: Product
default_Product = Product{
  product_productId = "",
  product_packageId = 0,
  product_version = 0,
  product_authorName = "",
  product_onSale = P.False,
  product_validDays = 0,
  product_saleType = 0,
  product_copyright = "",
  product_title = "",
  product_descriptionText = "",
  product_shopOrderId = 0,
  product_fromMid = "",
  product_toMid = "",
  product_validUntil = 0,
  product_priceTier = 0,
  product_price = "",
  product_currency = "",
  product_currencySymbol = "",
  product_paymentType = (P.toEnum 0),
  product_createDate = 0,
  product_ownFlag = P.False,
  product_eventType = (P.toEnum 0),
  product_urlSchema = "",
  product_downloadUrl = "",
  product_buddyMid = "",
  product_publishSince = 0,
  product_newFlag = P.False,
  product_missionFlag = P.False,
  product_categories = Vector.empty,
  product_missionButtonText = "",
  product_missionShortDescription = "",
  product_authorId = "",
  product_grantedByDefault = P.False,
  product_displayOrder = 0,
  product_availableForPresent = P.False,
  product_availableForMyself = P.False,
  product_hasAnimation = P.False,
  product_hasSound = P.False,
  product_recommendationsEnabled = P.False,
  product_stickerResourceType = (P.toEnum 0)}
data ProductList = ProductList  { productList_hasNext :: P.Bool
  , productList_bannerSequence :: I.Int64
  , productList_bannerTargetType :: ProductBannerLinkType
  , productList_bannerTargetPath :: LT.Text
  , productList_productList :: (Vector.Vector Product)
  , productList_bannerLang :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductList where
  hashWithSalt salt record = salt   `H.hashWithSalt` productList_hasNext record   `H.hashWithSalt` productList_bannerSequence record   `H.hashWithSalt` productList_bannerTargetType record   `H.hashWithSalt` productList_bannerTargetPath record   `H.hashWithSalt` productList_productList record   `H.hashWithSalt` productList_bannerLang record  
instance QC.Arbitrary ProductList where 
  arbitrary = M.liftM ProductList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductList{productList_hasNext = productList_hasNext obj} then P.Nothing else P.Just $ default_ProductList{productList_hasNext = productList_hasNext obj}
    , if obj == default_ProductList{productList_bannerSequence = productList_bannerSequence obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerSequence = productList_bannerSequence obj}
    , if obj == default_ProductList{productList_bannerTargetType = productList_bannerTargetType obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerTargetType = productList_bannerTargetType obj}
    , if obj == default_ProductList{productList_bannerTargetPath = productList_bannerTargetPath obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerTargetPath = productList_bannerTargetPath obj}
    , if obj == default_ProductList{productList_productList = productList_productList obj} then P.Nothing else P.Just $ default_ProductList{productList_productList = productList_productList obj}
    , if obj == default_ProductList{productList_bannerLang = productList_bannerLang obj} then P.Nothing else P.Just $ default_ProductList{productList_bannerLang = productList_bannerLang obj}
    ]
from_ProductList :: ProductList -> T.ThriftVal
from_ProductList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1463 -> P.Just (1, ("hasNext",T.TBool _v1463))) $ productList_hasNext record
  , (\_v1463 -> P.Just (4, ("bannerSequence",T.TI64 _v1463))) $ productList_bannerSequence record
  , (\_v1463 -> P.Just (5, ("bannerTargetType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1463))) $ productList_bannerTargetType record
  , (\_v1463 -> P.Just (6, ("bannerTargetPath",T.TString $ E.encodeUtf8 _v1463))) $ productList_bannerTargetPath record
  , (\_v1463 -> P.Just (7, ("productList",T.TList (T.T_STRUCT typemap_Product) $ P.map (\_v1465 -> from_Product _v1465) $ Vector.toList _v1463))) $ productList_productList record
  , (\_v1463 -> P.Just (8, ("bannerLang",T.TString $ E.encodeUtf8 _v1463))) $ productList_bannerLang record
  ]
write_ProductList :: T.Protocol p => p -> ProductList -> P.IO ()
write_ProductList oprot record = T.writeVal oprot $ from_ProductList record
encode_ProductList :: T.StatelessProtocol p => p -> ProductList -> LBS.ByteString
encode_ProductList oprot record = T.serializeVal oprot $ from_ProductList record
to_ProductList :: T.ThriftVal -> ProductList
to_ProductList (T.TStruct fields) = ProductList{
  productList_hasNext = P.maybe (productList_hasNext default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TBool _val1468 -> _val1468; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productList_bannerSequence = P.maybe (productList_bannerSequence default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TI64 _val1469 -> _val1469; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productList_bannerTargetType = P.maybe (productList_bannerTargetType default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TI32 _val1470 -> P.toEnum $ P.fromIntegral _val1470; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  productList_bannerTargetPath = P.maybe (productList_bannerTargetPath default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TString _val1471 -> E.decodeUtf8 _val1471; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  productList_productList = P.maybe (productList_productList default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TList _ _val1472 -> (Vector.fromList $ P.map (\_v1473 -> (case _v1473 of {T.TStruct _val1474 -> (to_Product (T.TStruct _val1474)); _ -> P.error "wrong type"})) _val1472); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  productList_bannerLang = P.maybe (productList_bannerLang default_ProductList) (\(_,_val1467) -> (case _val1467 of {T.TString _val1475 -> E.decodeUtf8 _val1475; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_ProductList _ = P.error "not a struct"
read_ProductList :: T.Protocol p => p -> P.IO ProductList
read_ProductList iprot = to_ProductList <$> T.readVal iprot (T.T_STRUCT typemap_ProductList)
decode_ProductList :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductList
decode_ProductList iprot bs = to_ProductList $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductList) bs
typemap_ProductList :: T.TypeMap
typemap_ProductList = Map.fromList [(1,("hasNext",T.T_BOOL)),(4,("bannerSequence",T.T_I64)),(5,("bannerTargetType",T.T_I32)),(6,("bannerTargetPath",T.T_STRING)),(7,("productList",(T.T_LIST (T.T_STRUCT typemap_Product)))),(8,("bannerLang",T.T_STRING))]
default_ProductList :: ProductList
default_ProductList = ProductList{
  productList_hasNext = P.False,
  productList_bannerSequence = 0,
  productList_bannerTargetType = (P.toEnum 0),
  productList_bannerTargetPath = "",
  productList_productList = Vector.empty,
  productList_bannerLang = ""}
data StickerIdRange = StickerIdRange  { stickerIdRange_start :: I.Int64
  , stickerIdRange_size :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StickerIdRange where
  hashWithSalt salt record = salt   `H.hashWithSalt` stickerIdRange_start record   `H.hashWithSalt` stickerIdRange_size record  
instance QC.Arbitrary StickerIdRange where 
  arbitrary = M.liftM StickerIdRange (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StickerIdRange = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StickerIdRange{stickerIdRange_start = stickerIdRange_start obj} then P.Nothing else P.Just $ default_StickerIdRange{stickerIdRange_start = stickerIdRange_start obj}
    , if obj == default_StickerIdRange{stickerIdRange_size = stickerIdRange_size obj} then P.Nothing else P.Just $ default_StickerIdRange{stickerIdRange_size = stickerIdRange_size obj}
    ]
from_StickerIdRange :: StickerIdRange -> T.ThriftVal
from_StickerIdRange record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1478 -> P.Just (1, ("start",T.TI64 _v1478))) $ stickerIdRange_start record
  , (\_v1478 -> P.Just (2, ("size",T.TI32 _v1478))) $ stickerIdRange_size record
  ]
write_StickerIdRange :: T.Protocol p => p -> StickerIdRange -> P.IO ()
write_StickerIdRange oprot record = T.writeVal oprot $ from_StickerIdRange record
encode_StickerIdRange :: T.StatelessProtocol p => p -> StickerIdRange -> LBS.ByteString
encode_StickerIdRange oprot record = T.serializeVal oprot $ from_StickerIdRange record
to_StickerIdRange :: T.ThriftVal -> StickerIdRange
to_StickerIdRange (T.TStruct fields) = StickerIdRange{
  stickerIdRange_start = P.maybe (stickerIdRange_start default_StickerIdRange) (\(_,_val1480) -> (case _val1480 of {T.TI64 _val1481 -> _val1481; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  stickerIdRange_size = P.maybe (stickerIdRange_size default_StickerIdRange) (\(_,_val1480) -> (case _val1480 of {T.TI32 _val1482 -> _val1482; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StickerIdRange _ = P.error "not a struct"
read_StickerIdRange :: T.Protocol p => p -> P.IO StickerIdRange
read_StickerIdRange iprot = to_StickerIdRange <$> T.readVal iprot (T.T_STRUCT typemap_StickerIdRange)
decode_StickerIdRange :: T.StatelessProtocol p => p -> LBS.ByteString -> StickerIdRange
decode_StickerIdRange iprot bs = to_StickerIdRange $ T.deserializeVal iprot (T.T_STRUCT typemap_StickerIdRange) bs
typemap_StickerIdRange :: T.TypeMap
typemap_StickerIdRange = Map.fromList [(1,("start",T.T_I64)),(2,("size",T.T_I32))]
default_StickerIdRange :: StickerIdRange
default_StickerIdRange = StickerIdRange{
  stickerIdRange_start = 0,
  stickerIdRange_size = 0}
data ProductSimple = ProductSimple  { productSimple_productId :: LT.Text
  , productSimple_packageId :: I.Int64
  , productSimple_version :: I.Int32
  , productSimple_onSale :: P.Bool
  , productSimple_validUntil :: I.Int64
  , productSimple_stickerIdRanges :: (Vector.Vector StickerIdRange)
  , productSimple_grantedByDefault :: P.Bool
  , productSimple_displayOrder :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductSimple where
  hashWithSalt salt record = salt   `H.hashWithSalt` productSimple_productId record   `H.hashWithSalt` productSimple_packageId record   `H.hashWithSalt` productSimple_version record   `H.hashWithSalt` productSimple_onSale record   `H.hashWithSalt` productSimple_validUntil record   `H.hashWithSalt` productSimple_stickerIdRanges record   `H.hashWithSalt` productSimple_grantedByDefault record   `H.hashWithSalt` productSimple_displayOrder record  
instance QC.Arbitrary ProductSimple where 
  arbitrary = M.liftM ProductSimple (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductSimple = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductSimple{productSimple_productId = productSimple_productId obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_productId = productSimple_productId obj}
    , if obj == default_ProductSimple{productSimple_packageId = productSimple_packageId obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_packageId = productSimple_packageId obj}
    , if obj == default_ProductSimple{productSimple_version = productSimple_version obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_version = productSimple_version obj}
    , if obj == default_ProductSimple{productSimple_onSale = productSimple_onSale obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_onSale = productSimple_onSale obj}
    , if obj == default_ProductSimple{productSimple_validUntil = productSimple_validUntil obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_validUntil = productSimple_validUntil obj}
    , if obj == default_ProductSimple{productSimple_stickerIdRanges = productSimple_stickerIdRanges obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_stickerIdRanges = productSimple_stickerIdRanges obj}
    , if obj == default_ProductSimple{productSimple_grantedByDefault = productSimple_grantedByDefault obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_grantedByDefault = productSimple_grantedByDefault obj}
    , if obj == default_ProductSimple{productSimple_displayOrder = productSimple_displayOrder obj} then P.Nothing else P.Just $ default_ProductSimple{productSimple_displayOrder = productSimple_displayOrder obj}
    ]
from_ProductSimple :: ProductSimple -> T.ThriftVal
from_ProductSimple record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1485 -> P.Just (1, ("productId",T.TString $ E.encodeUtf8 _v1485))) $ productSimple_productId record
  , (\_v1485 -> P.Just (2, ("packageId",T.TI64 _v1485))) $ productSimple_packageId record
  , (\_v1485 -> P.Just (3, ("version",T.TI32 _v1485))) $ productSimple_version record
  , (\_v1485 -> P.Just (4, ("onSale",T.TBool _v1485))) $ productSimple_onSale record
  , (\_v1485 -> P.Just (5, ("validUntil",T.TI64 _v1485))) $ productSimple_validUntil record
  , (\_v1485 -> P.Just (10, ("stickerIdRanges",T.TList (T.T_STRUCT typemap_StickerIdRange) $ P.map (\_v1487 -> from_StickerIdRange _v1487) $ Vector.toList _v1485))) $ productSimple_stickerIdRanges record
  , (\_v1485 -> P.Just (41, ("grantedByDefault",T.TBool _v1485))) $ productSimple_grantedByDefault record
  , (\_v1485 -> P.Just (42, ("displayOrder",T.TI32 _v1485))) $ productSimple_displayOrder record
  ]
write_ProductSimple :: T.Protocol p => p -> ProductSimple -> P.IO ()
write_ProductSimple oprot record = T.writeVal oprot $ from_ProductSimple record
encode_ProductSimple :: T.StatelessProtocol p => p -> ProductSimple -> LBS.ByteString
encode_ProductSimple oprot record = T.serializeVal oprot $ from_ProductSimple record
to_ProductSimple :: T.ThriftVal -> ProductSimple
to_ProductSimple (T.TStruct fields) = ProductSimple{
  productSimple_productId = P.maybe (productSimple_productId default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TString _val1490 -> E.decodeUtf8 _val1490; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productSimple_packageId = P.maybe (productSimple_packageId default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TI64 _val1491 -> _val1491; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  productSimple_version = P.maybe (productSimple_version default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TI32 _val1492 -> _val1492; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  productSimple_onSale = P.maybe (productSimple_onSale default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TBool _val1493 -> _val1493; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productSimple_validUntil = P.maybe (productSimple_validUntil default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TI64 _val1494 -> _val1494; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  productSimple_stickerIdRanges = P.maybe (productSimple_stickerIdRanges default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TList _ _val1495 -> (Vector.fromList $ P.map (\_v1496 -> (case _v1496 of {T.TStruct _val1497 -> (to_StickerIdRange (T.TStruct _val1497)); _ -> P.error "wrong type"})) _val1495); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  productSimple_grantedByDefault = P.maybe (productSimple_grantedByDefault default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TBool _val1498 -> _val1498; _ -> P.error "wrong type"})) (Map.lookup (41) fields),
  productSimple_displayOrder = P.maybe (productSimple_displayOrder default_ProductSimple) (\(_,_val1489) -> (case _val1489 of {T.TI32 _val1499 -> _val1499; _ -> P.error "wrong type"})) (Map.lookup (42) fields)
  }
to_ProductSimple _ = P.error "not a struct"
read_ProductSimple :: T.Protocol p => p -> P.IO ProductSimple
read_ProductSimple iprot = to_ProductSimple <$> T.readVal iprot (T.T_STRUCT typemap_ProductSimple)
decode_ProductSimple :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductSimple
decode_ProductSimple iprot bs = to_ProductSimple $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductSimple) bs
typemap_ProductSimple :: T.TypeMap
typemap_ProductSimple = Map.fromList [(1,("productId",T.T_STRING)),(2,("packageId",T.T_I64)),(3,("version",T.T_I32)),(4,("onSale",T.T_BOOL)),(5,("validUntil",T.T_I64)),(10,("stickerIdRanges",(T.T_LIST (T.T_STRUCT typemap_StickerIdRange)))),(41,("grantedByDefault",T.T_BOOL)),(42,("displayOrder",T.T_I32))]
default_ProductSimple :: ProductSimple
default_ProductSimple = ProductSimple{
  productSimple_productId = "",
  productSimple_packageId = 0,
  productSimple_version = 0,
  productSimple_onSale = P.False,
  productSimple_validUntil = 0,
  productSimple_stickerIdRanges = Vector.empty,
  productSimple_grantedByDefault = P.False,
  productSimple_displayOrder = 0}
data ProductSimpleList = ProductSimpleList  { productSimpleList_hasNext :: P.Bool
  , productSimpleList_reinvokeHour :: I.Int32
  , productSimpleList_lastVersionSeq :: I.Int64
  , productSimpleList_productList :: (Vector.Vector ProductSimple)
  , productSimpleList_recentNewReleaseDate :: I.Int64
  , productSimpleList_recentEventReleaseDate :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProductSimpleList where
  hashWithSalt salt record = salt   `H.hashWithSalt` productSimpleList_hasNext record   `H.hashWithSalt` productSimpleList_reinvokeHour record   `H.hashWithSalt` productSimpleList_lastVersionSeq record   `H.hashWithSalt` productSimpleList_productList record   `H.hashWithSalt` productSimpleList_recentNewReleaseDate record   `H.hashWithSalt` productSimpleList_recentEventReleaseDate record  
instance QC.Arbitrary ProductSimpleList where 
  arbitrary = M.liftM ProductSimpleList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProductSimpleList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProductSimpleList{productSimpleList_hasNext = productSimpleList_hasNext obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_hasNext = productSimpleList_hasNext obj}
    , if obj == default_ProductSimpleList{productSimpleList_reinvokeHour = productSimpleList_reinvokeHour obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_reinvokeHour = productSimpleList_reinvokeHour obj}
    , if obj == default_ProductSimpleList{productSimpleList_lastVersionSeq = productSimpleList_lastVersionSeq obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_lastVersionSeq = productSimpleList_lastVersionSeq obj}
    , if obj == default_ProductSimpleList{productSimpleList_productList = productSimpleList_productList obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_productList = productSimpleList_productList obj}
    , if obj == default_ProductSimpleList{productSimpleList_recentNewReleaseDate = productSimpleList_recentNewReleaseDate obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_recentNewReleaseDate = productSimpleList_recentNewReleaseDate obj}
    , if obj == default_ProductSimpleList{productSimpleList_recentEventReleaseDate = productSimpleList_recentEventReleaseDate obj} then P.Nothing else P.Just $ default_ProductSimpleList{productSimpleList_recentEventReleaseDate = productSimpleList_recentEventReleaseDate obj}
    ]
from_ProductSimpleList :: ProductSimpleList -> T.ThriftVal
from_ProductSimpleList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1502 -> P.Just (1, ("hasNext",T.TBool _v1502))) $ productSimpleList_hasNext record
  , (\_v1502 -> P.Just (2, ("reinvokeHour",T.TI32 _v1502))) $ productSimpleList_reinvokeHour record
  , (\_v1502 -> P.Just (3, ("lastVersionSeq",T.TI64 _v1502))) $ productSimpleList_lastVersionSeq record
  , (\_v1502 -> P.Just (4, ("productList",T.TList (T.T_STRUCT typemap_ProductSimple) $ P.map (\_v1504 -> from_ProductSimple _v1504) $ Vector.toList _v1502))) $ productSimpleList_productList record
  , (\_v1502 -> P.Just (5, ("recentNewReleaseDate",T.TI64 _v1502))) $ productSimpleList_recentNewReleaseDate record
  , (\_v1502 -> P.Just (6, ("recentEventReleaseDate",T.TI64 _v1502))) $ productSimpleList_recentEventReleaseDate record
  ]
write_ProductSimpleList :: T.Protocol p => p -> ProductSimpleList -> P.IO ()
write_ProductSimpleList oprot record = T.writeVal oprot $ from_ProductSimpleList record
encode_ProductSimpleList :: T.StatelessProtocol p => p -> ProductSimpleList -> LBS.ByteString
encode_ProductSimpleList oprot record = T.serializeVal oprot $ from_ProductSimpleList record
to_ProductSimpleList :: T.ThriftVal -> ProductSimpleList
to_ProductSimpleList (T.TStruct fields) = ProductSimpleList{
  productSimpleList_hasNext = P.maybe (productSimpleList_hasNext default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TBool _val1507 -> _val1507; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  productSimpleList_reinvokeHour = P.maybe (productSimpleList_reinvokeHour default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TI32 _val1508 -> _val1508; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  productSimpleList_lastVersionSeq = P.maybe (productSimpleList_lastVersionSeq default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TI64 _val1509 -> _val1509; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  productSimpleList_productList = P.maybe (productSimpleList_productList default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TList _ _val1510 -> (Vector.fromList $ P.map (\_v1511 -> (case _v1511 of {T.TStruct _val1512 -> (to_ProductSimple (T.TStruct _val1512)); _ -> P.error "wrong type"})) _val1510); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  productSimpleList_recentNewReleaseDate = P.maybe (productSimpleList_recentNewReleaseDate default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TI64 _val1513 -> _val1513; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  productSimpleList_recentEventReleaseDate = P.maybe (productSimpleList_recentEventReleaseDate default_ProductSimpleList) (\(_,_val1506) -> (case _val1506 of {T.TI64 _val1514 -> _val1514; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_ProductSimpleList _ = P.error "not a struct"
read_ProductSimpleList :: T.Protocol p => p -> P.IO ProductSimpleList
read_ProductSimpleList iprot = to_ProductSimpleList <$> T.readVal iprot (T.T_STRUCT typemap_ProductSimpleList)
decode_ProductSimpleList :: T.StatelessProtocol p => p -> LBS.ByteString -> ProductSimpleList
decode_ProductSimpleList iprot bs = to_ProductSimpleList $ T.deserializeVal iprot (T.T_STRUCT typemap_ProductSimpleList) bs
typemap_ProductSimpleList :: T.TypeMap
typemap_ProductSimpleList = Map.fromList [(1,("hasNext",T.T_BOOL)),(2,("reinvokeHour",T.T_I32)),(3,("lastVersionSeq",T.T_I64)),(4,("productList",(T.T_LIST (T.T_STRUCT typemap_ProductSimple)))),(5,("recentNewReleaseDate",T.T_I64)),(6,("recentEventReleaseDate",T.T_I64))]
default_ProductSimpleList :: ProductSimpleList
default_ProductSimpleList = ProductSimpleList{
  productSimpleList_hasNext = P.False,
  productSimpleList_reinvokeHour = 0,
  productSimpleList_lastVersionSeq = 0,
  productSimpleList_productList = Vector.empty,
  productSimpleList_recentNewReleaseDate = 0,
  productSimpleList_recentEventReleaseDate = 0}
data Profile = Profile  { profile_mid :: LT.Text
  , profile_userid :: LT.Text
  , profile_phone :: LT.Text
  , profile_email :: LT.Text
  , profile_regionCode :: LT.Text
  , profile_displayName :: LT.Text
  , profile_phoneticName :: LT.Text
  , profile_pictureStatus :: LT.Text
  , profile_thumbnailUrl :: LT.Text
  , profile_statusMessage :: LT.Text
  , profile_allowSearchByUserid :: P.Bool
  , profile_allowSearchByEmail :: P.Bool
  , profile_picturePath :: LT.Text
  , profile_musicProfile :: LT.Text
  , profile_videoProfile :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Profile where
  hashWithSalt salt record = salt   `H.hashWithSalt` profile_mid record   `H.hashWithSalt` profile_userid record   `H.hashWithSalt` profile_phone record   `H.hashWithSalt` profile_email record   `H.hashWithSalt` profile_regionCode record   `H.hashWithSalt` profile_displayName record   `H.hashWithSalt` profile_phoneticName record   `H.hashWithSalt` profile_pictureStatus record   `H.hashWithSalt` profile_thumbnailUrl record   `H.hashWithSalt` profile_statusMessage record   `H.hashWithSalt` profile_allowSearchByUserid record   `H.hashWithSalt` profile_allowSearchByEmail record   `H.hashWithSalt` profile_picturePath record   `H.hashWithSalt` profile_musicProfile record   `H.hashWithSalt` profile_videoProfile record  
instance QC.Arbitrary Profile where 
  arbitrary = M.liftM Profile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Profile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Profile{profile_mid = profile_mid obj} then P.Nothing else P.Just $ default_Profile{profile_mid = profile_mid obj}
    , if obj == default_Profile{profile_userid = profile_userid obj} then P.Nothing else P.Just $ default_Profile{profile_userid = profile_userid obj}
    , if obj == default_Profile{profile_phone = profile_phone obj} then P.Nothing else P.Just $ default_Profile{profile_phone = profile_phone obj}
    , if obj == default_Profile{profile_email = profile_email obj} then P.Nothing else P.Just $ default_Profile{profile_email = profile_email obj}
    , if obj == default_Profile{profile_regionCode = profile_regionCode obj} then P.Nothing else P.Just $ default_Profile{profile_regionCode = profile_regionCode obj}
    , if obj == default_Profile{profile_displayName = profile_displayName obj} then P.Nothing else P.Just $ default_Profile{profile_displayName = profile_displayName obj}
    , if obj == default_Profile{profile_phoneticName = profile_phoneticName obj} then P.Nothing else P.Just $ default_Profile{profile_phoneticName = profile_phoneticName obj}
    , if obj == default_Profile{profile_pictureStatus = profile_pictureStatus obj} then P.Nothing else P.Just $ default_Profile{profile_pictureStatus = profile_pictureStatus obj}
    , if obj == default_Profile{profile_thumbnailUrl = profile_thumbnailUrl obj} then P.Nothing else P.Just $ default_Profile{profile_thumbnailUrl = profile_thumbnailUrl obj}
    , if obj == default_Profile{profile_statusMessage = profile_statusMessage obj} then P.Nothing else P.Just $ default_Profile{profile_statusMessage = profile_statusMessage obj}
    , if obj == default_Profile{profile_allowSearchByUserid = profile_allowSearchByUserid obj} then P.Nothing else P.Just $ default_Profile{profile_allowSearchByUserid = profile_allowSearchByUserid obj}
    , if obj == default_Profile{profile_allowSearchByEmail = profile_allowSearchByEmail obj} then P.Nothing else P.Just $ default_Profile{profile_allowSearchByEmail = profile_allowSearchByEmail obj}
    , if obj == default_Profile{profile_picturePath = profile_picturePath obj} then P.Nothing else P.Just $ default_Profile{profile_picturePath = profile_picturePath obj}
    , if obj == default_Profile{profile_musicProfile = profile_musicProfile obj} then P.Nothing else P.Just $ default_Profile{profile_musicProfile = profile_musicProfile obj}
    , if obj == default_Profile{profile_videoProfile = profile_videoProfile obj} then P.Nothing else P.Just $ default_Profile{profile_videoProfile = profile_videoProfile obj}
    ]
from_Profile :: Profile -> T.ThriftVal
from_Profile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1517 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v1517))) $ profile_mid record
  , (\_v1517 -> P.Just (3, ("userid",T.TString $ E.encodeUtf8 _v1517))) $ profile_userid record
  , (\_v1517 -> P.Just (10, ("phone",T.TString $ E.encodeUtf8 _v1517))) $ profile_phone record
  , (\_v1517 -> P.Just (11, ("email",T.TString $ E.encodeUtf8 _v1517))) $ profile_email record
  , (\_v1517 -> P.Just (12, ("regionCode",T.TString $ E.encodeUtf8 _v1517))) $ profile_regionCode record
  , (\_v1517 -> P.Just (20, ("displayName",T.TString $ E.encodeUtf8 _v1517))) $ profile_displayName record
  , (\_v1517 -> P.Just (21, ("phoneticName",T.TString $ E.encodeUtf8 _v1517))) $ profile_phoneticName record
  , (\_v1517 -> P.Just (22, ("pictureStatus",T.TString $ E.encodeUtf8 _v1517))) $ profile_pictureStatus record
  , (\_v1517 -> P.Just (23, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v1517))) $ profile_thumbnailUrl record
  , (\_v1517 -> P.Just (24, ("statusMessage",T.TString $ E.encodeUtf8 _v1517))) $ profile_statusMessage record
  , (\_v1517 -> P.Just (31, ("allowSearchByUserid",T.TBool _v1517))) $ profile_allowSearchByUserid record
  , (\_v1517 -> P.Just (32, ("allowSearchByEmail",T.TBool _v1517))) $ profile_allowSearchByEmail record
  , (\_v1517 -> P.Just (33, ("picturePath",T.TString $ E.encodeUtf8 _v1517))) $ profile_picturePath record
  , (\_v1517 -> P.Just (34, ("musicProfile",T.TString $ E.encodeUtf8 _v1517))) $ profile_musicProfile record
  , (\_v1517 -> P.Just (35, ("videoProfile",T.TString $ E.encodeUtf8 _v1517))) $ profile_videoProfile record
  ]
write_Profile :: T.Protocol p => p -> Profile -> P.IO ()
write_Profile oprot record = T.writeVal oprot $ from_Profile record
encode_Profile :: T.StatelessProtocol p => p -> Profile -> LBS.ByteString
encode_Profile oprot record = T.serializeVal oprot $ from_Profile record
to_Profile :: T.ThriftVal -> Profile
to_Profile (T.TStruct fields) = Profile{
  profile_mid = P.maybe (profile_mid default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1520 -> E.decodeUtf8 _val1520; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  profile_userid = P.maybe (profile_userid default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1521 -> E.decodeUtf8 _val1521; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  profile_phone = P.maybe (profile_phone default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1522 -> E.decodeUtf8 _val1522; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  profile_email = P.maybe (profile_email default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1523 -> E.decodeUtf8 _val1523; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  profile_regionCode = P.maybe (profile_regionCode default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1524 -> E.decodeUtf8 _val1524; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  profile_displayName = P.maybe (profile_displayName default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1525 -> E.decodeUtf8 _val1525; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  profile_phoneticName = P.maybe (profile_phoneticName default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1526 -> E.decodeUtf8 _val1526; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  profile_pictureStatus = P.maybe (profile_pictureStatus default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1527 -> E.decodeUtf8 _val1527; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  profile_thumbnailUrl = P.maybe (profile_thumbnailUrl default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1528 -> E.decodeUtf8 _val1528; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  profile_statusMessage = P.maybe (profile_statusMessage default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1529 -> E.decodeUtf8 _val1529; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  profile_allowSearchByUserid = P.maybe (profile_allowSearchByUserid default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TBool _val1530 -> _val1530; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  profile_allowSearchByEmail = P.maybe (profile_allowSearchByEmail default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TBool _val1531 -> _val1531; _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  profile_picturePath = P.maybe (profile_picturePath default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1532 -> E.decodeUtf8 _val1532; _ -> P.error "wrong type"})) (Map.lookup (33) fields),
  profile_musicProfile = P.maybe (profile_musicProfile default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1533 -> E.decodeUtf8 _val1533; _ -> P.error "wrong type"})) (Map.lookup (34) fields),
  profile_videoProfile = P.maybe (profile_videoProfile default_Profile) (\(_,_val1519) -> (case _val1519 of {T.TString _val1534 -> E.decodeUtf8 _val1534; _ -> P.error "wrong type"})) (Map.lookup (35) fields)
  }
to_Profile _ = P.error "not a struct"
read_Profile :: T.Protocol p => p -> P.IO Profile
read_Profile iprot = to_Profile <$> T.readVal iprot (T.T_STRUCT typemap_Profile)
decode_Profile :: T.StatelessProtocol p => p -> LBS.ByteString -> Profile
decode_Profile iprot bs = to_Profile $ T.deserializeVal iprot (T.T_STRUCT typemap_Profile) bs
typemap_Profile :: T.TypeMap
typemap_Profile = Map.fromList [(1,("mid",T.T_STRING)),(3,("userid",T.T_STRING)),(10,("phone",T.T_STRING)),(11,("email",T.T_STRING)),(12,("regionCode",T.T_STRING)),(20,("displayName",T.T_STRING)),(21,("phoneticName",T.T_STRING)),(22,("pictureStatus",T.T_STRING)),(23,("thumbnailUrl",T.T_STRING)),(24,("statusMessage",T.T_STRING)),(31,("allowSearchByUserid",T.T_BOOL)),(32,("allowSearchByEmail",T.T_BOOL)),(33,("picturePath",T.T_STRING)),(34,("musicProfile",T.T_STRING)),(35,("videoProfile",T.T_STRING))]
default_Profile :: Profile
default_Profile = Profile{
  profile_mid = "",
  profile_userid = "",
  profile_phone = "",
  profile_email = "",
  profile_regionCode = "",
  profile_displayName = "",
  profile_phoneticName = "",
  profile_pictureStatus = "",
  profile_thumbnailUrl = "",
  profile_statusMessage = "",
  profile_allowSearchByUserid = P.False,
  profile_allowSearchByEmail = P.False,
  profile_picturePath = "",
  profile_musicProfile = "",
  profile_videoProfile = ""}
data ProximityMatchCandidateResult = ProximityMatchCandidateResult  { proximityMatchCandidateResult_users :: (Vector.Vector Contact)
  , proximityMatchCandidateResult_buddies :: (Vector.Vector Contact)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ProximityMatchCandidateResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` proximityMatchCandidateResult_users record   `H.hashWithSalt` proximityMatchCandidateResult_buddies record  
instance QC.Arbitrary ProximityMatchCandidateResult where 
  arbitrary = M.liftM ProximityMatchCandidateResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ProximityMatchCandidateResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ProximityMatchCandidateResult{proximityMatchCandidateResult_users = proximityMatchCandidateResult_users obj} then P.Nothing else P.Just $ default_ProximityMatchCandidateResult{proximityMatchCandidateResult_users = proximityMatchCandidateResult_users obj}
    , if obj == default_ProximityMatchCandidateResult{proximityMatchCandidateResult_buddies = proximityMatchCandidateResult_buddies obj} then P.Nothing else P.Just $ default_ProximityMatchCandidateResult{proximityMatchCandidateResult_buddies = proximityMatchCandidateResult_buddies obj}
    ]
from_ProximityMatchCandidateResult :: ProximityMatchCandidateResult -> T.ThriftVal
from_ProximityMatchCandidateResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1537 -> P.Just (1, ("users",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1539 -> from_Contact _v1539) $ Vector.toList _v1537))) $ proximityMatchCandidateResult_users record
  , (\_v1537 -> P.Just (2, ("buddies",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1541 -> from_Contact _v1541) $ Vector.toList _v1537))) $ proximityMatchCandidateResult_buddies record
  ]
write_ProximityMatchCandidateResult :: T.Protocol p => p -> ProximityMatchCandidateResult -> P.IO ()
write_ProximityMatchCandidateResult oprot record = T.writeVal oprot $ from_ProximityMatchCandidateResult record
encode_ProximityMatchCandidateResult :: T.StatelessProtocol p => p -> ProximityMatchCandidateResult -> LBS.ByteString
encode_ProximityMatchCandidateResult oprot record = T.serializeVal oprot $ from_ProximityMatchCandidateResult record
to_ProximityMatchCandidateResult :: T.ThriftVal -> ProximityMatchCandidateResult
to_ProximityMatchCandidateResult (T.TStruct fields) = ProximityMatchCandidateResult{
  proximityMatchCandidateResult_users = P.maybe (proximityMatchCandidateResult_users default_ProximityMatchCandidateResult) (\(_,_val1543) -> (case _val1543 of {T.TList _ _val1544 -> (Vector.fromList $ P.map (\_v1545 -> (case _v1545 of {T.TStruct _val1546 -> (to_Contact (T.TStruct _val1546)); _ -> P.error "wrong type"})) _val1544); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  proximityMatchCandidateResult_buddies = P.maybe (proximityMatchCandidateResult_buddies default_ProximityMatchCandidateResult) (\(_,_val1543) -> (case _val1543 of {T.TList _ _val1547 -> (Vector.fromList $ P.map (\_v1548 -> (case _v1548 of {T.TStruct _val1549 -> (to_Contact (T.TStruct _val1549)); _ -> P.error "wrong type"})) _val1547); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ProximityMatchCandidateResult _ = P.error "not a struct"
read_ProximityMatchCandidateResult :: T.Protocol p => p -> P.IO ProximityMatchCandidateResult
read_ProximityMatchCandidateResult iprot = to_ProximityMatchCandidateResult <$> T.readVal iprot (T.T_STRUCT typemap_ProximityMatchCandidateResult)
decode_ProximityMatchCandidateResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ProximityMatchCandidateResult
decode_ProximityMatchCandidateResult iprot bs = to_ProximityMatchCandidateResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ProximityMatchCandidateResult) bs
typemap_ProximityMatchCandidateResult :: T.TypeMap
typemap_ProximityMatchCandidateResult = Map.fromList [(1,("users",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(2,("buddies",(T.T_LIST (T.T_STRUCT typemap_Contact))))]
default_ProximityMatchCandidateResult :: ProximityMatchCandidateResult
default_ProximityMatchCandidateResult = ProximityMatchCandidateResult{
  proximityMatchCandidateResult_users = Vector.empty,
  proximityMatchCandidateResult_buddies = Vector.empty}
data RegisterWithSnsIdResult = RegisterWithSnsIdResult  { registerWithSnsIdResult_authToken :: LT.Text
  , registerWithSnsIdResult_userCreated :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdResult_authToken record   `H.hashWithSalt` registerWithSnsIdResult_userCreated record  
instance QC.Arbitrary RegisterWithSnsIdResult where 
  arbitrary = M.liftM RegisterWithSnsIdResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdResult{registerWithSnsIdResult_authToken = registerWithSnsIdResult_authToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdResult{registerWithSnsIdResult_authToken = registerWithSnsIdResult_authToken obj}
    , if obj == default_RegisterWithSnsIdResult{registerWithSnsIdResult_userCreated = registerWithSnsIdResult_userCreated obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdResult{registerWithSnsIdResult_userCreated = registerWithSnsIdResult_userCreated obj}
    ]
from_RegisterWithSnsIdResult :: RegisterWithSnsIdResult -> T.ThriftVal
from_RegisterWithSnsIdResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1552 -> P.Just (1, ("authToken",T.TString $ E.encodeUtf8 _v1552))) $ registerWithSnsIdResult_authToken record
  , (\_v1552 -> P.Just (2, ("userCreated",T.TBool _v1552))) $ registerWithSnsIdResult_userCreated record
  ]
write_RegisterWithSnsIdResult :: T.Protocol p => p -> RegisterWithSnsIdResult -> P.IO ()
write_RegisterWithSnsIdResult oprot record = T.writeVal oprot $ from_RegisterWithSnsIdResult record
encode_RegisterWithSnsIdResult :: T.StatelessProtocol p => p -> RegisterWithSnsIdResult -> LBS.ByteString
encode_RegisterWithSnsIdResult oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdResult record
to_RegisterWithSnsIdResult :: T.ThriftVal -> RegisterWithSnsIdResult
to_RegisterWithSnsIdResult (T.TStruct fields) = RegisterWithSnsIdResult{
  registerWithSnsIdResult_authToken = P.maybe (registerWithSnsIdResult_authToken default_RegisterWithSnsIdResult) (\(_,_val1554) -> (case _val1554 of {T.TString _val1555 -> E.decodeUtf8 _val1555; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerWithSnsIdResult_userCreated = P.maybe (registerWithSnsIdResult_userCreated default_RegisterWithSnsIdResult) (\(_,_val1554) -> (case _val1554 of {T.TBool _val1556 -> _val1556; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterWithSnsIdResult _ = P.error "not a struct"
read_RegisterWithSnsIdResult :: T.Protocol p => p -> P.IO RegisterWithSnsIdResult
read_RegisterWithSnsIdResult iprot = to_RegisterWithSnsIdResult <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdResult)
decode_RegisterWithSnsIdResult :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdResult
decode_RegisterWithSnsIdResult iprot bs = to_RegisterWithSnsIdResult $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdResult) bs
typemap_RegisterWithSnsIdResult :: T.TypeMap
typemap_RegisterWithSnsIdResult = Map.fromList [(1,("authToken",T.T_STRING)),(2,("userCreated",T.T_BOOL))]
default_RegisterWithSnsIdResult :: RegisterWithSnsIdResult
default_RegisterWithSnsIdResult = RegisterWithSnsIdResult{
  registerWithSnsIdResult_authToken = "",
  registerWithSnsIdResult_userCreated = P.False}
data RequestTokenResponse = RequestTokenResponse  { requestTokenResponse_requestToken :: LT.Text
  , requestTokenResponse_returnUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestTokenResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestTokenResponse_requestToken record   `H.hashWithSalt` requestTokenResponse_returnUrl record  
instance QC.Arbitrary RequestTokenResponse where 
  arbitrary = M.liftM RequestTokenResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestTokenResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestTokenResponse{requestTokenResponse_requestToken = requestTokenResponse_requestToken obj} then P.Nothing else P.Just $ default_RequestTokenResponse{requestTokenResponse_requestToken = requestTokenResponse_requestToken obj}
    , if obj == default_RequestTokenResponse{requestTokenResponse_returnUrl = requestTokenResponse_returnUrl obj} then P.Nothing else P.Just $ default_RequestTokenResponse{requestTokenResponse_returnUrl = requestTokenResponse_returnUrl obj}
    ]
from_RequestTokenResponse :: RequestTokenResponse -> T.ThriftVal
from_RequestTokenResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1559 -> P.Just (1, ("requestToken",T.TString $ E.encodeUtf8 _v1559))) $ requestTokenResponse_requestToken record
  , (\_v1559 -> P.Just (2, ("returnUrl",T.TString $ E.encodeUtf8 _v1559))) $ requestTokenResponse_returnUrl record
  ]
write_RequestTokenResponse :: T.Protocol p => p -> RequestTokenResponse -> P.IO ()
write_RequestTokenResponse oprot record = T.writeVal oprot $ from_RequestTokenResponse record
encode_RequestTokenResponse :: T.StatelessProtocol p => p -> RequestTokenResponse -> LBS.ByteString
encode_RequestTokenResponse oprot record = T.serializeVal oprot $ from_RequestTokenResponse record
to_RequestTokenResponse :: T.ThriftVal -> RequestTokenResponse
to_RequestTokenResponse (T.TStruct fields) = RequestTokenResponse{
  requestTokenResponse_requestToken = P.maybe (requestTokenResponse_requestToken default_RequestTokenResponse) (\(_,_val1561) -> (case _val1561 of {T.TString _val1562 -> E.decodeUtf8 _val1562; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  requestTokenResponse_returnUrl = P.maybe (requestTokenResponse_returnUrl default_RequestTokenResponse) (\(_,_val1561) -> (case _val1561 of {T.TString _val1563 -> E.decodeUtf8 _val1563; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestTokenResponse _ = P.error "not a struct"
read_RequestTokenResponse :: T.Protocol p => p -> P.IO RequestTokenResponse
read_RequestTokenResponse iprot = to_RequestTokenResponse <$> T.readVal iprot (T.T_STRUCT typemap_RequestTokenResponse)
decode_RequestTokenResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestTokenResponse
decode_RequestTokenResponse iprot bs = to_RequestTokenResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestTokenResponse) bs
typemap_RequestTokenResponse :: T.TypeMap
typemap_RequestTokenResponse = Map.fromList [(1,("requestToken",T.T_STRING)),(2,("returnUrl",T.T_STRING))]
default_RequestTokenResponse :: RequestTokenResponse
default_RequestTokenResponse = RequestTokenResponse{
  requestTokenResponse_requestToken = "",
  requestTokenResponse_returnUrl = ""}
data Room = Room  { room_mid :: LT.Text
  , room_createdTime :: I.Int64
  , room_contacts :: (Vector.Vector Contact)
  , room_notificationDisabled :: P.Bool
  , room_memberMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Room where
  hashWithSalt salt record = salt   `H.hashWithSalt` room_mid record   `H.hashWithSalt` room_createdTime record   `H.hashWithSalt` room_contacts record   `H.hashWithSalt` room_notificationDisabled record   `H.hashWithSalt` room_memberMids record  
instance QC.Arbitrary Room where 
  arbitrary = M.liftM Room (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Room = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Room{room_mid = room_mid obj} then P.Nothing else P.Just $ default_Room{room_mid = room_mid obj}
    , if obj == default_Room{room_createdTime = room_createdTime obj} then P.Nothing else P.Just $ default_Room{room_createdTime = room_createdTime obj}
    , if obj == default_Room{room_contacts = room_contacts obj} then P.Nothing else P.Just $ default_Room{room_contacts = room_contacts obj}
    , if obj == default_Room{room_notificationDisabled = room_notificationDisabled obj} then P.Nothing else P.Just $ default_Room{room_notificationDisabled = room_notificationDisabled obj}
    , if obj == default_Room{room_memberMids = room_memberMids obj} then P.Nothing else P.Just $ default_Room{room_memberMids = room_memberMids obj}
    ]
from_Room :: Room -> T.ThriftVal
from_Room record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1566 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v1566))) $ room_mid record
  , (\_v1566 -> P.Just (2, ("createdTime",T.TI64 _v1566))) $ room_createdTime record
  , (\_v1566 -> P.Just (10, ("contacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1568 -> from_Contact _v1568) $ Vector.toList _v1566))) $ room_contacts record
  , (\_v1566 -> P.Just (31, ("notificationDisabled",T.TBool _v1566))) $ room_notificationDisabled record
  , (\_v1566 -> P.Just (40, ("memberMids",T.TList T.T_STRING $ P.map (\_v1570 -> T.TString $ E.encodeUtf8 _v1570) $ Vector.toList _v1566))) $ room_memberMids record
  ]
write_Room :: T.Protocol p => p -> Room -> P.IO ()
write_Room oprot record = T.writeVal oprot $ from_Room record
encode_Room :: T.StatelessProtocol p => p -> Room -> LBS.ByteString
encode_Room oprot record = T.serializeVal oprot $ from_Room record
to_Room :: T.ThriftVal -> Room
to_Room (T.TStruct fields) = Room{
  room_mid = P.maybe (room_mid default_Room) (\(_,_val1572) -> (case _val1572 of {T.TString _val1573 -> E.decodeUtf8 _val1573; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  room_createdTime = P.maybe (room_createdTime default_Room) (\(_,_val1572) -> (case _val1572 of {T.TI64 _val1574 -> _val1574; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  room_contacts = P.maybe (room_contacts default_Room) (\(_,_val1572) -> (case _val1572 of {T.TList _ _val1575 -> (Vector.fromList $ P.map (\_v1576 -> (case _v1576 of {T.TStruct _val1577 -> (to_Contact (T.TStruct _val1577)); _ -> P.error "wrong type"})) _val1575); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  room_notificationDisabled = P.maybe (room_notificationDisabled default_Room) (\(_,_val1572) -> (case _val1572 of {T.TBool _val1578 -> _val1578; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  room_memberMids = P.maybe (room_memberMids default_Room) (\(_,_val1572) -> (case _val1572 of {T.TList _ _val1579 -> (Vector.fromList $ P.map (\_v1580 -> (case _v1580 of {T.TString _val1581 -> E.decodeUtf8 _val1581; _ -> P.error "wrong type"})) _val1579); _ -> P.error "wrong type"})) (Map.lookup (40) fields)
  }
to_Room _ = P.error "not a struct"
read_Room :: T.Protocol p => p -> P.IO Room
read_Room iprot = to_Room <$> T.readVal iprot (T.T_STRUCT typemap_Room)
decode_Room :: T.StatelessProtocol p => p -> LBS.ByteString -> Room
decode_Room iprot bs = to_Room $ T.deserializeVal iprot (T.T_STRUCT typemap_Room) bs
typemap_Room :: T.TypeMap
typemap_Room = Map.fromList [(1,("mid",T.T_STRING)),(2,("createdTime",T.T_I64)),(10,("contacts",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(31,("notificationDisabled",T.T_BOOL)),(40,("memberMids",(T.T_LIST T.T_STRING)))]
default_Room :: Room
default_Room = Room{
  room_mid = "",
  room_createdTime = 0,
  room_contacts = Vector.empty,
  room_notificationDisabled = P.False,
  room_memberMids = Vector.empty}
data SuggestDictionary = SuggestDictionary  { suggestDictionary_language :: LT.Text
  , suggestDictionary_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestDictionary where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestDictionary_language record   `H.hashWithSalt` suggestDictionary_name record  
instance QC.Arbitrary SuggestDictionary where 
  arbitrary = M.liftM SuggestDictionary (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestDictionary = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestDictionary{suggestDictionary_language = suggestDictionary_language obj} then P.Nothing else P.Just $ default_SuggestDictionary{suggestDictionary_language = suggestDictionary_language obj}
    , if obj == default_SuggestDictionary{suggestDictionary_name = suggestDictionary_name obj} then P.Nothing else P.Just $ default_SuggestDictionary{suggestDictionary_name = suggestDictionary_name obj}
    ]
from_SuggestDictionary :: SuggestDictionary -> T.ThriftVal
from_SuggestDictionary record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1584 -> P.Just (1, ("language",T.TString $ E.encodeUtf8 _v1584))) $ suggestDictionary_language record
  , (\_v1584 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v1584))) $ suggestDictionary_name record
  ]
write_SuggestDictionary :: T.Protocol p => p -> SuggestDictionary -> P.IO ()
write_SuggestDictionary oprot record = T.writeVal oprot $ from_SuggestDictionary record
encode_SuggestDictionary :: T.StatelessProtocol p => p -> SuggestDictionary -> LBS.ByteString
encode_SuggestDictionary oprot record = T.serializeVal oprot $ from_SuggestDictionary record
to_SuggestDictionary :: T.ThriftVal -> SuggestDictionary
to_SuggestDictionary (T.TStruct fields) = SuggestDictionary{
  suggestDictionary_language = P.maybe (suggestDictionary_language default_SuggestDictionary) (\(_,_val1586) -> (case _val1586 of {T.TString _val1587 -> E.decodeUtf8 _val1587; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestDictionary_name = P.maybe (suggestDictionary_name default_SuggestDictionary) (\(_,_val1586) -> (case _val1586 of {T.TString _val1588 -> E.decodeUtf8 _val1588; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SuggestDictionary _ = P.error "not a struct"
read_SuggestDictionary :: T.Protocol p => p -> P.IO SuggestDictionary
read_SuggestDictionary iprot = to_SuggestDictionary <$> T.readVal iprot (T.T_STRUCT typemap_SuggestDictionary)
decode_SuggestDictionary :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestDictionary
decode_SuggestDictionary iprot bs = to_SuggestDictionary $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestDictionary) bs
typemap_SuggestDictionary :: T.TypeMap
typemap_SuggestDictionary = Map.fromList [(1,("language",T.T_STRING)),(2,("name",T.T_STRING))]
default_SuggestDictionary :: SuggestDictionary
default_SuggestDictionary = SuggestDictionary{
  suggestDictionary_language = "",
  suggestDictionary_name = ""}
data SuggestItemDictionaryIncrement = SuggestItemDictionaryIncrement  { suggestItemDictionaryIncrement_status :: SuggestDictionaryIncrementStatus
  , suggestItemDictionaryIncrement_revision :: I.Int64
  , suggestItemDictionaryIncrement_scheme :: LT.Text
  , suggestItemDictionaryIncrement_data :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestItemDictionaryIncrement where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestItemDictionaryIncrement_status record   `H.hashWithSalt` suggestItemDictionaryIncrement_revision record   `H.hashWithSalt` suggestItemDictionaryIncrement_scheme record   `H.hashWithSalt` suggestItemDictionaryIncrement_data record  
instance QC.Arbitrary SuggestItemDictionaryIncrement where 
  arbitrary = M.liftM SuggestItemDictionaryIncrement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestItemDictionaryIncrement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_status = suggestItemDictionaryIncrement_status obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_status = suggestItemDictionaryIncrement_status obj}
    , if obj == default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_revision = suggestItemDictionaryIncrement_revision obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_revision = suggestItemDictionaryIncrement_revision obj}
    , if obj == default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_scheme = suggestItemDictionaryIncrement_scheme obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_scheme = suggestItemDictionaryIncrement_scheme obj}
    , if obj == default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_data = suggestItemDictionaryIncrement_data obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryIncrement{suggestItemDictionaryIncrement_data = suggestItemDictionaryIncrement_data obj}
    ]
from_SuggestItemDictionaryIncrement :: SuggestItemDictionaryIncrement -> T.ThriftVal
from_SuggestItemDictionaryIncrement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1591 -> P.Just (1, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v1591))) $ suggestItemDictionaryIncrement_status record
  , (\_v1591 -> P.Just (2, ("revision",T.TI64 _v1591))) $ suggestItemDictionaryIncrement_revision record
  , (\_v1591 -> P.Just (3, ("scheme",T.TString $ E.encodeUtf8 _v1591))) $ suggestItemDictionaryIncrement_scheme record
  , (\_v1591 -> P.Just (4, ("data",T.TBinary _v1591))) $ suggestItemDictionaryIncrement_data record
  ]
write_SuggestItemDictionaryIncrement :: T.Protocol p => p -> SuggestItemDictionaryIncrement -> P.IO ()
write_SuggestItemDictionaryIncrement oprot record = T.writeVal oprot $ from_SuggestItemDictionaryIncrement record
encode_SuggestItemDictionaryIncrement :: T.StatelessProtocol p => p -> SuggestItemDictionaryIncrement -> LBS.ByteString
encode_SuggestItemDictionaryIncrement oprot record = T.serializeVal oprot $ from_SuggestItemDictionaryIncrement record
to_SuggestItemDictionaryIncrement :: T.ThriftVal -> SuggestItemDictionaryIncrement
to_SuggestItemDictionaryIncrement (T.TStruct fields) = SuggestItemDictionaryIncrement{
  suggestItemDictionaryIncrement_status = P.maybe (suggestItemDictionaryIncrement_status default_SuggestItemDictionaryIncrement) (\(_,_val1593) -> (case _val1593 of {T.TI32 _val1594 -> P.toEnum $ P.fromIntegral _val1594; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestItemDictionaryIncrement_revision = P.maybe (suggestItemDictionaryIncrement_revision default_SuggestItemDictionaryIncrement) (\(_,_val1593) -> (case _val1593 of {T.TI64 _val1595 -> _val1595; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  suggestItemDictionaryIncrement_scheme = P.maybe (suggestItemDictionaryIncrement_scheme default_SuggestItemDictionaryIncrement) (\(_,_val1593) -> (case _val1593 of {T.TString _val1596 -> E.decodeUtf8 _val1596; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  suggestItemDictionaryIncrement_data = P.maybe (suggestItemDictionaryIncrement_data default_SuggestItemDictionaryIncrement) (\(_,_val1593) -> (case _val1593 of {T.TBinary _val1597 -> _val1597; T.TString _val1597 -> _val1597; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SuggestItemDictionaryIncrement _ = P.error "not a struct"
read_SuggestItemDictionaryIncrement :: T.Protocol p => p -> P.IO SuggestItemDictionaryIncrement
read_SuggestItemDictionaryIncrement iprot = to_SuggestItemDictionaryIncrement <$> T.readVal iprot (T.T_STRUCT typemap_SuggestItemDictionaryIncrement)
decode_SuggestItemDictionaryIncrement :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestItemDictionaryIncrement
decode_SuggestItemDictionaryIncrement iprot bs = to_SuggestItemDictionaryIncrement $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestItemDictionaryIncrement) bs
typemap_SuggestItemDictionaryIncrement :: T.TypeMap
typemap_SuggestItemDictionaryIncrement = Map.fromList [(1,("status",T.T_I32)),(2,("revision",T.T_I64)),(3,("scheme",T.T_STRING)),(4,("data",T.T_BINARY))]
default_SuggestItemDictionaryIncrement :: SuggestItemDictionaryIncrement
default_SuggestItemDictionaryIncrement = SuggestItemDictionaryIncrement{
  suggestItemDictionaryIncrement_status = (P.toEnum 0),
  suggestItemDictionaryIncrement_revision = 0,
  suggestItemDictionaryIncrement_scheme = "",
  suggestItemDictionaryIncrement_data = ""}
data SuggestTagDictionaryIncrement = SuggestTagDictionaryIncrement  { suggestTagDictionaryIncrement_status :: SuggestDictionaryIncrementStatus
  , suggestTagDictionaryIncrement_language :: LT.Text
  , suggestTagDictionaryIncrement_revision :: I.Int64
  , suggestTagDictionaryIncrement_scheme :: LT.Text
  , suggestTagDictionaryIncrement_data :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestTagDictionaryIncrement where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestTagDictionaryIncrement_status record   `H.hashWithSalt` suggestTagDictionaryIncrement_language record   `H.hashWithSalt` suggestTagDictionaryIncrement_revision record   `H.hashWithSalt` suggestTagDictionaryIncrement_scheme record   `H.hashWithSalt` suggestTagDictionaryIncrement_data record  
instance QC.Arbitrary SuggestTagDictionaryIncrement where 
  arbitrary = M.liftM SuggestTagDictionaryIncrement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestTagDictionaryIncrement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_status = suggestTagDictionaryIncrement_status obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_status = suggestTagDictionaryIncrement_status obj}
    , if obj == default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_language = suggestTagDictionaryIncrement_language obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_language = suggestTagDictionaryIncrement_language obj}
    , if obj == default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_revision = suggestTagDictionaryIncrement_revision obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_revision = suggestTagDictionaryIncrement_revision obj}
    , if obj == default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_scheme = suggestTagDictionaryIncrement_scheme obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_scheme = suggestTagDictionaryIncrement_scheme obj}
    , if obj == default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_data = suggestTagDictionaryIncrement_data obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryIncrement{suggestTagDictionaryIncrement_data = suggestTagDictionaryIncrement_data obj}
    ]
from_SuggestTagDictionaryIncrement :: SuggestTagDictionaryIncrement -> T.ThriftVal
from_SuggestTagDictionaryIncrement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1600 -> P.Just (1, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v1600))) $ suggestTagDictionaryIncrement_status record
  , (\_v1600 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v1600))) $ suggestTagDictionaryIncrement_language record
  , (\_v1600 -> P.Just (3, ("revision",T.TI64 _v1600))) $ suggestTagDictionaryIncrement_revision record
  , (\_v1600 -> P.Just (4, ("scheme",T.TString $ E.encodeUtf8 _v1600))) $ suggestTagDictionaryIncrement_scheme record
  , (\_v1600 -> P.Just (5, ("data",T.TBinary _v1600))) $ suggestTagDictionaryIncrement_data record
  ]
write_SuggestTagDictionaryIncrement :: T.Protocol p => p -> SuggestTagDictionaryIncrement -> P.IO ()
write_SuggestTagDictionaryIncrement oprot record = T.writeVal oprot $ from_SuggestTagDictionaryIncrement record
encode_SuggestTagDictionaryIncrement :: T.StatelessProtocol p => p -> SuggestTagDictionaryIncrement -> LBS.ByteString
encode_SuggestTagDictionaryIncrement oprot record = T.serializeVal oprot $ from_SuggestTagDictionaryIncrement record
to_SuggestTagDictionaryIncrement :: T.ThriftVal -> SuggestTagDictionaryIncrement
to_SuggestTagDictionaryIncrement (T.TStruct fields) = SuggestTagDictionaryIncrement{
  suggestTagDictionaryIncrement_status = P.maybe (suggestTagDictionaryIncrement_status default_SuggestTagDictionaryIncrement) (\(_,_val1602) -> (case _val1602 of {T.TI32 _val1603 -> P.toEnum $ P.fromIntegral _val1603; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestTagDictionaryIncrement_language = P.maybe (suggestTagDictionaryIncrement_language default_SuggestTagDictionaryIncrement) (\(_,_val1602) -> (case _val1602 of {T.TString _val1604 -> E.decodeUtf8 _val1604; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  suggestTagDictionaryIncrement_revision = P.maybe (suggestTagDictionaryIncrement_revision default_SuggestTagDictionaryIncrement) (\(_,_val1602) -> (case _val1602 of {T.TI64 _val1605 -> _val1605; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  suggestTagDictionaryIncrement_scheme = P.maybe (suggestTagDictionaryIncrement_scheme default_SuggestTagDictionaryIncrement) (\(_,_val1602) -> (case _val1602 of {T.TString _val1606 -> E.decodeUtf8 _val1606; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  suggestTagDictionaryIncrement_data = P.maybe (suggestTagDictionaryIncrement_data default_SuggestTagDictionaryIncrement) (\(_,_val1602) -> (case _val1602 of {T.TBinary _val1607 -> _val1607; T.TString _val1607 -> _val1607; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SuggestTagDictionaryIncrement _ = P.error "not a struct"
read_SuggestTagDictionaryIncrement :: T.Protocol p => p -> P.IO SuggestTagDictionaryIncrement
read_SuggestTagDictionaryIncrement iprot = to_SuggestTagDictionaryIncrement <$> T.readVal iprot (T.T_STRUCT typemap_SuggestTagDictionaryIncrement)
decode_SuggestTagDictionaryIncrement :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestTagDictionaryIncrement
decode_SuggestTagDictionaryIncrement iprot bs = to_SuggestTagDictionaryIncrement $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestTagDictionaryIncrement) bs
typemap_SuggestTagDictionaryIncrement :: T.TypeMap
typemap_SuggestTagDictionaryIncrement = Map.fromList [(1,("status",T.T_I32)),(2,("language",T.T_STRING)),(3,("revision",T.T_I64)),(4,("scheme",T.T_STRING)),(5,("data",T.T_BINARY))]
default_SuggestTagDictionaryIncrement :: SuggestTagDictionaryIncrement
default_SuggestTagDictionaryIncrement = SuggestTagDictionaryIncrement{
  suggestTagDictionaryIncrement_status = (P.toEnum 0),
  suggestTagDictionaryIncrement_language = "",
  suggestTagDictionaryIncrement_revision = 0,
  suggestTagDictionaryIncrement_scheme = "",
  suggestTagDictionaryIncrement_data = ""}
data SuggestDictionaryIncrements = SuggestDictionaryIncrements  { suggestDictionaryIncrements_itemIncrement :: SuggestItemDictionaryIncrement
  , suggestDictionaryIncrements_tagIncrements :: (Vector.Vector SuggestTagDictionaryIncrement)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestDictionaryIncrements where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestDictionaryIncrements_itemIncrement record   `H.hashWithSalt` suggestDictionaryIncrements_tagIncrements record  
instance QC.Arbitrary SuggestDictionaryIncrements where 
  arbitrary = M.liftM SuggestDictionaryIncrements (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestDictionaryIncrements = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestDictionaryIncrements{suggestDictionaryIncrements_itemIncrement = suggestDictionaryIncrements_itemIncrement obj} then P.Nothing else P.Just $ default_SuggestDictionaryIncrements{suggestDictionaryIncrements_itemIncrement = suggestDictionaryIncrements_itemIncrement obj}
    , if obj == default_SuggestDictionaryIncrements{suggestDictionaryIncrements_tagIncrements = suggestDictionaryIncrements_tagIncrements obj} then P.Nothing else P.Just $ default_SuggestDictionaryIncrements{suggestDictionaryIncrements_tagIncrements = suggestDictionaryIncrements_tagIncrements obj}
    ]
from_SuggestDictionaryIncrements :: SuggestDictionaryIncrements -> T.ThriftVal
from_SuggestDictionaryIncrements record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1610 -> P.Just (1, ("itemIncrement",from_SuggestItemDictionaryIncrement _v1610))) $ suggestDictionaryIncrements_itemIncrement record
  , (\_v1610 -> P.Just (2, ("tagIncrements",T.TList (T.T_STRUCT typemap_SuggestTagDictionaryIncrement) $ P.map (\_v1612 -> from_SuggestTagDictionaryIncrement _v1612) $ Vector.toList _v1610))) $ suggestDictionaryIncrements_tagIncrements record
  ]
write_SuggestDictionaryIncrements :: T.Protocol p => p -> SuggestDictionaryIncrements -> P.IO ()
write_SuggestDictionaryIncrements oprot record = T.writeVal oprot $ from_SuggestDictionaryIncrements record
encode_SuggestDictionaryIncrements :: T.StatelessProtocol p => p -> SuggestDictionaryIncrements -> LBS.ByteString
encode_SuggestDictionaryIncrements oprot record = T.serializeVal oprot $ from_SuggestDictionaryIncrements record
to_SuggestDictionaryIncrements :: T.ThriftVal -> SuggestDictionaryIncrements
to_SuggestDictionaryIncrements (T.TStruct fields) = SuggestDictionaryIncrements{
  suggestDictionaryIncrements_itemIncrement = P.maybe (suggestDictionaryIncrements_itemIncrement default_SuggestDictionaryIncrements) (\(_,_val1614) -> (case _val1614 of {T.TStruct _val1615 -> (to_SuggestItemDictionaryIncrement (T.TStruct _val1615)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestDictionaryIncrements_tagIncrements = P.maybe (suggestDictionaryIncrements_tagIncrements default_SuggestDictionaryIncrements) (\(_,_val1614) -> (case _val1614 of {T.TList _ _val1616 -> (Vector.fromList $ P.map (\_v1617 -> (case _v1617 of {T.TStruct _val1618 -> (to_SuggestTagDictionaryIncrement (T.TStruct _val1618)); _ -> P.error "wrong type"})) _val1616); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SuggestDictionaryIncrements _ = P.error "not a struct"
read_SuggestDictionaryIncrements :: T.Protocol p => p -> P.IO SuggestDictionaryIncrements
read_SuggestDictionaryIncrements iprot = to_SuggestDictionaryIncrements <$> T.readVal iprot (T.T_STRUCT typemap_SuggestDictionaryIncrements)
decode_SuggestDictionaryIncrements :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestDictionaryIncrements
decode_SuggestDictionaryIncrements iprot bs = to_SuggestDictionaryIncrements $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestDictionaryIncrements) bs
typemap_SuggestDictionaryIncrements :: T.TypeMap
typemap_SuggestDictionaryIncrements = Map.fromList [(1,("itemIncrement",(T.T_STRUCT typemap_SuggestItemDictionaryIncrement))),(2,("tagIncrements",(T.T_LIST (T.T_STRUCT typemap_SuggestTagDictionaryIncrement))))]
default_SuggestDictionaryIncrements :: SuggestDictionaryIncrements
default_SuggestDictionaryIncrements = SuggestDictionaryIncrements{
  suggestDictionaryIncrements_itemIncrement = default_SuggestItemDictionaryIncrement,
  suggestDictionaryIncrements_tagIncrements = Vector.empty}
data SuggestItemDictionaryRevision = SuggestItemDictionaryRevision  { suggestItemDictionaryRevision_revision :: I.Int64
  , suggestItemDictionaryRevision_scheme :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestItemDictionaryRevision where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestItemDictionaryRevision_revision record   `H.hashWithSalt` suggestItemDictionaryRevision_scheme record  
instance QC.Arbitrary SuggestItemDictionaryRevision where 
  arbitrary = M.liftM SuggestItemDictionaryRevision (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestItemDictionaryRevision = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestItemDictionaryRevision{suggestItemDictionaryRevision_revision = suggestItemDictionaryRevision_revision obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryRevision{suggestItemDictionaryRevision_revision = suggestItemDictionaryRevision_revision obj}
    , if obj == default_SuggestItemDictionaryRevision{suggestItemDictionaryRevision_scheme = suggestItemDictionaryRevision_scheme obj} then P.Nothing else P.Just $ default_SuggestItemDictionaryRevision{suggestItemDictionaryRevision_scheme = suggestItemDictionaryRevision_scheme obj}
    ]
from_SuggestItemDictionaryRevision :: SuggestItemDictionaryRevision -> T.ThriftVal
from_SuggestItemDictionaryRevision record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1621 -> P.Just (1, ("revision",T.TI64 _v1621))) $ suggestItemDictionaryRevision_revision record
  , (\_v1621 -> P.Just (2, ("scheme",T.TString $ E.encodeUtf8 _v1621))) $ suggestItemDictionaryRevision_scheme record
  ]
write_SuggestItemDictionaryRevision :: T.Protocol p => p -> SuggestItemDictionaryRevision -> P.IO ()
write_SuggestItemDictionaryRevision oprot record = T.writeVal oprot $ from_SuggestItemDictionaryRevision record
encode_SuggestItemDictionaryRevision :: T.StatelessProtocol p => p -> SuggestItemDictionaryRevision -> LBS.ByteString
encode_SuggestItemDictionaryRevision oprot record = T.serializeVal oprot $ from_SuggestItemDictionaryRevision record
to_SuggestItemDictionaryRevision :: T.ThriftVal -> SuggestItemDictionaryRevision
to_SuggestItemDictionaryRevision (T.TStruct fields) = SuggestItemDictionaryRevision{
  suggestItemDictionaryRevision_revision = P.maybe (suggestItemDictionaryRevision_revision default_SuggestItemDictionaryRevision) (\(_,_val1623) -> (case _val1623 of {T.TI64 _val1624 -> _val1624; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestItemDictionaryRevision_scheme = P.maybe (suggestItemDictionaryRevision_scheme default_SuggestItemDictionaryRevision) (\(_,_val1623) -> (case _val1623 of {T.TString _val1625 -> E.decodeUtf8 _val1625; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SuggestItemDictionaryRevision _ = P.error "not a struct"
read_SuggestItemDictionaryRevision :: T.Protocol p => p -> P.IO SuggestItemDictionaryRevision
read_SuggestItemDictionaryRevision iprot = to_SuggestItemDictionaryRevision <$> T.readVal iprot (T.T_STRUCT typemap_SuggestItemDictionaryRevision)
decode_SuggestItemDictionaryRevision :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestItemDictionaryRevision
decode_SuggestItemDictionaryRevision iprot bs = to_SuggestItemDictionaryRevision $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestItemDictionaryRevision) bs
typemap_SuggestItemDictionaryRevision :: T.TypeMap
typemap_SuggestItemDictionaryRevision = Map.fromList [(1,("revision",T.T_I64)),(2,("scheme",T.T_STRING))]
default_SuggestItemDictionaryRevision :: SuggestItemDictionaryRevision
default_SuggestItemDictionaryRevision = SuggestItemDictionaryRevision{
  suggestItemDictionaryRevision_revision = 0,
  suggestItemDictionaryRevision_scheme = ""}
data SuggestTagDictionaryRevision = SuggestTagDictionaryRevision  { suggestTagDictionaryRevision_language :: LT.Text
  , suggestTagDictionaryRevision_revision :: I.Int64
  , suggestTagDictionaryRevision_scheme :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestTagDictionaryRevision where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestTagDictionaryRevision_language record   `H.hashWithSalt` suggestTagDictionaryRevision_revision record   `H.hashWithSalt` suggestTagDictionaryRevision_scheme record  
instance QC.Arbitrary SuggestTagDictionaryRevision where 
  arbitrary = M.liftM SuggestTagDictionaryRevision (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestTagDictionaryRevision = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_language = suggestTagDictionaryRevision_language obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_language = suggestTagDictionaryRevision_language obj}
    , if obj == default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_revision = suggestTagDictionaryRevision_revision obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_revision = suggestTagDictionaryRevision_revision obj}
    , if obj == default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_scheme = suggestTagDictionaryRevision_scheme obj} then P.Nothing else P.Just $ default_SuggestTagDictionaryRevision{suggestTagDictionaryRevision_scheme = suggestTagDictionaryRevision_scheme obj}
    ]
from_SuggestTagDictionaryRevision :: SuggestTagDictionaryRevision -> T.ThriftVal
from_SuggestTagDictionaryRevision record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1628 -> P.Just (1, ("language",T.TString $ E.encodeUtf8 _v1628))) $ suggestTagDictionaryRevision_language record
  , (\_v1628 -> P.Just (2, ("revision",T.TI64 _v1628))) $ suggestTagDictionaryRevision_revision record
  , (\_v1628 -> P.Just (3, ("scheme",T.TString $ E.encodeUtf8 _v1628))) $ suggestTagDictionaryRevision_scheme record
  ]
write_SuggestTagDictionaryRevision :: T.Protocol p => p -> SuggestTagDictionaryRevision -> P.IO ()
write_SuggestTagDictionaryRevision oprot record = T.writeVal oprot $ from_SuggestTagDictionaryRevision record
encode_SuggestTagDictionaryRevision :: T.StatelessProtocol p => p -> SuggestTagDictionaryRevision -> LBS.ByteString
encode_SuggestTagDictionaryRevision oprot record = T.serializeVal oprot $ from_SuggestTagDictionaryRevision record
to_SuggestTagDictionaryRevision :: T.ThriftVal -> SuggestTagDictionaryRevision
to_SuggestTagDictionaryRevision (T.TStruct fields) = SuggestTagDictionaryRevision{
  suggestTagDictionaryRevision_language = P.maybe (suggestTagDictionaryRevision_language default_SuggestTagDictionaryRevision) (\(_,_val1630) -> (case _val1630 of {T.TString _val1631 -> E.decodeUtf8 _val1631; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestTagDictionaryRevision_revision = P.maybe (suggestTagDictionaryRevision_revision default_SuggestTagDictionaryRevision) (\(_,_val1630) -> (case _val1630 of {T.TI64 _val1632 -> _val1632; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  suggestTagDictionaryRevision_scheme = P.maybe (suggestTagDictionaryRevision_scheme default_SuggestTagDictionaryRevision) (\(_,_val1630) -> (case _val1630 of {T.TString _val1633 -> E.decodeUtf8 _val1633; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SuggestTagDictionaryRevision _ = P.error "not a struct"
read_SuggestTagDictionaryRevision :: T.Protocol p => p -> P.IO SuggestTagDictionaryRevision
read_SuggestTagDictionaryRevision iprot = to_SuggestTagDictionaryRevision <$> T.readVal iprot (T.T_STRUCT typemap_SuggestTagDictionaryRevision)
decode_SuggestTagDictionaryRevision :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestTagDictionaryRevision
decode_SuggestTagDictionaryRevision iprot bs = to_SuggestTagDictionaryRevision $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestTagDictionaryRevision) bs
typemap_SuggestTagDictionaryRevision :: T.TypeMap
typemap_SuggestTagDictionaryRevision = Map.fromList [(1,("language",T.T_STRING)),(2,("revision",T.T_I64)),(3,("scheme",T.T_STRING))]
default_SuggestTagDictionaryRevision :: SuggestTagDictionaryRevision
default_SuggestTagDictionaryRevision = SuggestTagDictionaryRevision{
  suggestTagDictionaryRevision_language = "",
  suggestTagDictionaryRevision_revision = 0,
  suggestTagDictionaryRevision_scheme = ""}
data SuggestDictionaryRevisions = SuggestDictionaryRevisions  { suggestDictionaryRevisions_itemRevision :: SuggestItemDictionaryRevision
  , suggestDictionaryRevisions_tagRevisions :: (Vector.Vector SuggestTagDictionaryRevision)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestDictionaryRevisions where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestDictionaryRevisions_itemRevision record   `H.hashWithSalt` suggestDictionaryRevisions_tagRevisions record  
instance QC.Arbitrary SuggestDictionaryRevisions where 
  arbitrary = M.liftM SuggestDictionaryRevisions (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestDictionaryRevisions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestDictionaryRevisions{suggestDictionaryRevisions_itemRevision = suggestDictionaryRevisions_itemRevision obj} then P.Nothing else P.Just $ default_SuggestDictionaryRevisions{suggestDictionaryRevisions_itemRevision = suggestDictionaryRevisions_itemRevision obj}
    , if obj == default_SuggestDictionaryRevisions{suggestDictionaryRevisions_tagRevisions = suggestDictionaryRevisions_tagRevisions obj} then P.Nothing else P.Just $ default_SuggestDictionaryRevisions{suggestDictionaryRevisions_tagRevisions = suggestDictionaryRevisions_tagRevisions obj}
    ]
from_SuggestDictionaryRevisions :: SuggestDictionaryRevisions -> T.ThriftVal
from_SuggestDictionaryRevisions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1636 -> P.Just (1, ("itemRevision",from_SuggestItemDictionaryRevision _v1636))) $ suggestDictionaryRevisions_itemRevision record
  , (\_v1636 -> P.Just (2, ("tagRevisions",T.TList (T.T_STRUCT typemap_SuggestTagDictionaryRevision) $ P.map (\_v1638 -> from_SuggestTagDictionaryRevision _v1638) $ Vector.toList _v1636))) $ suggestDictionaryRevisions_tagRevisions record
  ]
write_SuggestDictionaryRevisions :: T.Protocol p => p -> SuggestDictionaryRevisions -> P.IO ()
write_SuggestDictionaryRevisions oprot record = T.writeVal oprot $ from_SuggestDictionaryRevisions record
encode_SuggestDictionaryRevisions :: T.StatelessProtocol p => p -> SuggestDictionaryRevisions -> LBS.ByteString
encode_SuggestDictionaryRevisions oprot record = T.serializeVal oprot $ from_SuggestDictionaryRevisions record
to_SuggestDictionaryRevisions :: T.ThriftVal -> SuggestDictionaryRevisions
to_SuggestDictionaryRevisions (T.TStruct fields) = SuggestDictionaryRevisions{
  suggestDictionaryRevisions_itemRevision = P.maybe (suggestDictionaryRevisions_itemRevision default_SuggestDictionaryRevisions) (\(_,_val1640) -> (case _val1640 of {T.TStruct _val1641 -> (to_SuggestItemDictionaryRevision (T.TStruct _val1641)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestDictionaryRevisions_tagRevisions = P.maybe (suggestDictionaryRevisions_tagRevisions default_SuggestDictionaryRevisions) (\(_,_val1640) -> (case _val1640 of {T.TList _ _val1642 -> (Vector.fromList $ P.map (\_v1643 -> (case _v1643 of {T.TStruct _val1644 -> (to_SuggestTagDictionaryRevision (T.TStruct _val1644)); _ -> P.error "wrong type"})) _val1642); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SuggestDictionaryRevisions _ = P.error "not a struct"
read_SuggestDictionaryRevisions :: T.Protocol p => p -> P.IO SuggestDictionaryRevisions
read_SuggestDictionaryRevisions iprot = to_SuggestDictionaryRevisions <$> T.readVal iprot (T.T_STRUCT typemap_SuggestDictionaryRevisions)
decode_SuggestDictionaryRevisions :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestDictionaryRevisions
decode_SuggestDictionaryRevisions iprot bs = to_SuggestDictionaryRevisions $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestDictionaryRevisions) bs
typemap_SuggestDictionaryRevisions :: T.TypeMap
typemap_SuggestDictionaryRevisions = Map.fromList [(1,("itemRevision",(T.T_STRUCT typemap_SuggestItemDictionaryRevision))),(2,("tagRevisions",(T.T_LIST (T.T_STRUCT typemap_SuggestTagDictionaryRevision))))]
default_SuggestDictionaryRevisions :: SuggestDictionaryRevisions
default_SuggestDictionaryRevisions = SuggestDictionaryRevisions{
  suggestDictionaryRevisions_itemRevision = default_SuggestItemDictionaryRevision,
  suggestDictionaryRevisions_tagRevisions = Vector.empty}
data SuggestDictionarySettings = SuggestDictionarySettings  { suggestDictionarySettings_revision :: I.Int64
  , suggestDictionarySettings_newRevision :: I.Int64
  , suggestDictionarySettings_dictionaries :: (Vector.Vector SuggestDictionary)
  , suggestDictionarySettings_preloadedDictionaries :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SuggestDictionarySettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` suggestDictionarySettings_revision record   `H.hashWithSalt` suggestDictionarySettings_newRevision record   `H.hashWithSalt` suggestDictionarySettings_dictionaries record   `H.hashWithSalt` suggestDictionarySettings_preloadedDictionaries record  
instance QC.Arbitrary SuggestDictionarySettings where 
  arbitrary = M.liftM SuggestDictionarySettings (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SuggestDictionarySettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SuggestDictionarySettings{suggestDictionarySettings_revision = suggestDictionarySettings_revision obj} then P.Nothing else P.Just $ default_SuggestDictionarySettings{suggestDictionarySettings_revision = suggestDictionarySettings_revision obj}
    , if obj == default_SuggestDictionarySettings{suggestDictionarySettings_newRevision = suggestDictionarySettings_newRevision obj} then P.Nothing else P.Just $ default_SuggestDictionarySettings{suggestDictionarySettings_newRevision = suggestDictionarySettings_newRevision obj}
    , if obj == default_SuggestDictionarySettings{suggestDictionarySettings_dictionaries = suggestDictionarySettings_dictionaries obj} then P.Nothing else P.Just $ default_SuggestDictionarySettings{suggestDictionarySettings_dictionaries = suggestDictionarySettings_dictionaries obj}
    , if obj == default_SuggestDictionarySettings{suggestDictionarySettings_preloadedDictionaries = suggestDictionarySettings_preloadedDictionaries obj} then P.Nothing else P.Just $ default_SuggestDictionarySettings{suggestDictionarySettings_preloadedDictionaries = suggestDictionarySettings_preloadedDictionaries obj}
    ]
from_SuggestDictionarySettings :: SuggestDictionarySettings -> T.ThriftVal
from_SuggestDictionarySettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1647 -> P.Just (1, ("revision",T.TI64 _v1647))) $ suggestDictionarySettings_revision record
  , (\_v1647 -> P.Just (2, ("newRevision",T.TI64 _v1647))) $ suggestDictionarySettings_newRevision record
  , (\_v1647 -> P.Just (3, ("dictionaries",T.TList (T.T_STRUCT typemap_SuggestDictionary) $ P.map (\_v1649 -> from_SuggestDictionary _v1649) $ Vector.toList _v1647))) $ suggestDictionarySettings_dictionaries record
  , (\_v1647 -> P.Just (4, ("preloadedDictionaries",T.TList T.T_STRING $ P.map (\_v1651 -> T.TString $ E.encodeUtf8 _v1651) $ Vector.toList _v1647))) $ suggestDictionarySettings_preloadedDictionaries record
  ]
write_SuggestDictionarySettings :: T.Protocol p => p -> SuggestDictionarySettings -> P.IO ()
write_SuggestDictionarySettings oprot record = T.writeVal oprot $ from_SuggestDictionarySettings record
encode_SuggestDictionarySettings :: T.StatelessProtocol p => p -> SuggestDictionarySettings -> LBS.ByteString
encode_SuggestDictionarySettings oprot record = T.serializeVal oprot $ from_SuggestDictionarySettings record
to_SuggestDictionarySettings :: T.ThriftVal -> SuggestDictionarySettings
to_SuggestDictionarySettings (T.TStruct fields) = SuggestDictionarySettings{
  suggestDictionarySettings_revision = P.maybe (suggestDictionarySettings_revision default_SuggestDictionarySettings) (\(_,_val1653) -> (case _val1653 of {T.TI64 _val1654 -> _val1654; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  suggestDictionarySettings_newRevision = P.maybe (suggestDictionarySettings_newRevision default_SuggestDictionarySettings) (\(_,_val1653) -> (case _val1653 of {T.TI64 _val1655 -> _val1655; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  suggestDictionarySettings_dictionaries = P.maybe (suggestDictionarySettings_dictionaries default_SuggestDictionarySettings) (\(_,_val1653) -> (case _val1653 of {T.TList _ _val1656 -> (Vector.fromList $ P.map (\_v1657 -> (case _v1657 of {T.TStruct _val1658 -> (to_SuggestDictionary (T.TStruct _val1658)); _ -> P.error "wrong type"})) _val1656); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  suggestDictionarySettings_preloadedDictionaries = P.maybe (suggestDictionarySettings_preloadedDictionaries default_SuggestDictionarySettings) (\(_,_val1653) -> (case _val1653 of {T.TList _ _val1659 -> (Vector.fromList $ P.map (\_v1660 -> (case _v1660 of {T.TString _val1661 -> E.decodeUtf8 _val1661; _ -> P.error "wrong type"})) _val1659); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SuggestDictionarySettings _ = P.error "not a struct"
read_SuggestDictionarySettings :: T.Protocol p => p -> P.IO SuggestDictionarySettings
read_SuggestDictionarySettings iprot = to_SuggestDictionarySettings <$> T.readVal iprot (T.T_STRUCT typemap_SuggestDictionarySettings)
decode_SuggestDictionarySettings :: T.StatelessProtocol p => p -> LBS.ByteString -> SuggestDictionarySettings
decode_SuggestDictionarySettings iprot bs = to_SuggestDictionarySettings $ T.deserializeVal iprot (T.T_STRUCT typemap_SuggestDictionarySettings) bs
typemap_SuggestDictionarySettings :: T.TypeMap
typemap_SuggestDictionarySettings = Map.fromList [(1,("revision",T.T_I64)),(2,("newRevision",T.T_I64)),(3,("dictionaries",(T.T_LIST (T.T_STRUCT typemap_SuggestDictionary)))),(4,("preloadedDictionaries",(T.T_LIST T.T_STRING)))]
default_SuggestDictionarySettings :: SuggestDictionarySettings
default_SuggestDictionarySettings = SuggestDictionarySettings{
  suggestDictionarySettings_revision = 0,
  suggestDictionarySettings_newRevision = 0,
  suggestDictionarySettings_dictionaries = Vector.empty,
  suggestDictionarySettings_preloadedDictionaries = Vector.empty}
data PhoneInfoForChannel = PhoneInfoForChannel  { phoneInfoForChannel_mid :: LT.Text
  , phoneInfoForChannel_normalizedPhoneNumber :: LT.Text
  , phoneInfoForChannel_allowedToSearchByPhoneNumber :: P.Bool
  , phoneInfoForChannel_allowedToReceiveMessageFromNonFriend :: P.Bool
  , phoneInfoForChannel_region :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PhoneInfoForChannel where
  hashWithSalt salt record = salt   `H.hashWithSalt` phoneInfoForChannel_mid record   `H.hashWithSalt` phoneInfoForChannel_normalizedPhoneNumber record   `H.hashWithSalt` phoneInfoForChannel_allowedToSearchByPhoneNumber record   `H.hashWithSalt` phoneInfoForChannel_allowedToReceiveMessageFromNonFriend record   `H.hashWithSalt` phoneInfoForChannel_region record  
instance QC.Arbitrary PhoneInfoForChannel where 
  arbitrary = M.liftM PhoneInfoForChannel (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PhoneInfoForChannel = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PhoneInfoForChannel{phoneInfoForChannel_mid = phoneInfoForChannel_mid obj} then P.Nothing else P.Just $ default_PhoneInfoForChannel{phoneInfoForChannel_mid = phoneInfoForChannel_mid obj}
    , if obj == default_PhoneInfoForChannel{phoneInfoForChannel_normalizedPhoneNumber = phoneInfoForChannel_normalizedPhoneNumber obj} then P.Nothing else P.Just $ default_PhoneInfoForChannel{phoneInfoForChannel_normalizedPhoneNumber = phoneInfoForChannel_normalizedPhoneNumber obj}
    , if obj == default_PhoneInfoForChannel{phoneInfoForChannel_allowedToSearchByPhoneNumber = phoneInfoForChannel_allowedToSearchByPhoneNumber obj} then P.Nothing else P.Just $ default_PhoneInfoForChannel{phoneInfoForChannel_allowedToSearchByPhoneNumber = phoneInfoForChannel_allowedToSearchByPhoneNumber obj}
    , if obj == default_PhoneInfoForChannel{phoneInfoForChannel_allowedToReceiveMessageFromNonFriend = phoneInfoForChannel_allowedToReceiveMessageFromNonFriend obj} then P.Nothing else P.Just $ default_PhoneInfoForChannel{phoneInfoForChannel_allowedToReceiveMessageFromNonFriend = phoneInfoForChannel_allowedToReceiveMessageFromNonFriend obj}
    , if obj == default_PhoneInfoForChannel{phoneInfoForChannel_region = phoneInfoForChannel_region obj} then P.Nothing else P.Just $ default_PhoneInfoForChannel{phoneInfoForChannel_region = phoneInfoForChannel_region obj}
    ]
from_PhoneInfoForChannel :: PhoneInfoForChannel -> T.ThriftVal
from_PhoneInfoForChannel record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1664 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v1664))) $ phoneInfoForChannel_mid record
  , (\_v1664 -> P.Just (2, ("normalizedPhoneNumber",T.TString $ E.encodeUtf8 _v1664))) $ phoneInfoForChannel_normalizedPhoneNumber record
  , (\_v1664 -> P.Just (3, ("allowedToSearchByPhoneNumber",T.TBool _v1664))) $ phoneInfoForChannel_allowedToSearchByPhoneNumber record
  , (\_v1664 -> P.Just (4, ("allowedToReceiveMessageFromNonFriend",T.TBool _v1664))) $ phoneInfoForChannel_allowedToReceiveMessageFromNonFriend record
  , (\_v1664 -> P.Just (5, ("region",T.TString $ E.encodeUtf8 _v1664))) $ phoneInfoForChannel_region record
  ]
write_PhoneInfoForChannel :: T.Protocol p => p -> PhoneInfoForChannel -> P.IO ()
write_PhoneInfoForChannel oprot record = T.writeVal oprot $ from_PhoneInfoForChannel record
encode_PhoneInfoForChannel :: T.StatelessProtocol p => p -> PhoneInfoForChannel -> LBS.ByteString
encode_PhoneInfoForChannel oprot record = T.serializeVal oprot $ from_PhoneInfoForChannel record
to_PhoneInfoForChannel :: T.ThriftVal -> PhoneInfoForChannel
to_PhoneInfoForChannel (T.TStruct fields) = PhoneInfoForChannel{
  phoneInfoForChannel_mid = P.maybe (phoneInfoForChannel_mid default_PhoneInfoForChannel) (\(_,_val1666) -> (case _val1666 of {T.TString _val1667 -> E.decodeUtf8 _val1667; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  phoneInfoForChannel_normalizedPhoneNumber = P.maybe (phoneInfoForChannel_normalizedPhoneNumber default_PhoneInfoForChannel) (\(_,_val1666) -> (case _val1666 of {T.TString _val1668 -> E.decodeUtf8 _val1668; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  phoneInfoForChannel_allowedToSearchByPhoneNumber = P.maybe (phoneInfoForChannel_allowedToSearchByPhoneNumber default_PhoneInfoForChannel) (\(_,_val1666) -> (case _val1666 of {T.TBool _val1669 -> _val1669; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  phoneInfoForChannel_allowedToReceiveMessageFromNonFriend = P.maybe (phoneInfoForChannel_allowedToReceiveMessageFromNonFriend default_PhoneInfoForChannel) (\(_,_val1666) -> (case _val1666 of {T.TBool _val1670 -> _val1670; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  phoneInfoForChannel_region = P.maybe (phoneInfoForChannel_region default_PhoneInfoForChannel) (\(_,_val1666) -> (case _val1666 of {T.TString _val1671 -> E.decodeUtf8 _val1671; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_PhoneInfoForChannel _ = P.error "not a struct"
read_PhoneInfoForChannel :: T.Protocol p => p -> P.IO PhoneInfoForChannel
read_PhoneInfoForChannel iprot = to_PhoneInfoForChannel <$> T.readVal iprot (T.T_STRUCT typemap_PhoneInfoForChannel)
decode_PhoneInfoForChannel :: T.StatelessProtocol p => p -> LBS.ByteString -> PhoneInfoForChannel
decode_PhoneInfoForChannel iprot bs = to_PhoneInfoForChannel $ T.deserializeVal iprot (T.T_STRUCT typemap_PhoneInfoForChannel) bs
typemap_PhoneInfoForChannel :: T.TypeMap
typemap_PhoneInfoForChannel = Map.fromList [(1,("mid",T.T_STRING)),(2,("normalizedPhoneNumber",T.T_STRING)),(3,("allowedToSearchByPhoneNumber",T.T_BOOL)),(4,("allowedToReceiveMessageFromNonFriend",T.T_BOOL)),(5,("region",T.T_STRING))]
default_PhoneInfoForChannel :: PhoneInfoForChannel
default_PhoneInfoForChannel = PhoneInfoForChannel{
  phoneInfoForChannel_mid = "",
  phoneInfoForChannel_normalizedPhoneNumber = "",
  phoneInfoForChannel_allowedToSearchByPhoneNumber = P.False,
  phoneInfoForChannel_allowedToReceiveMessageFromNonFriend = P.False,
  phoneInfoForChannel_region = ""}
data PhoneVerificationResult = PhoneVerificationResult  { phoneVerificationResult_verificationResult :: VerificationResult
  , phoneVerificationResult_accountMigrationCheckType :: AccountMigrationCheckType
  , phoneVerificationResult_recommendAddFriends :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PhoneVerificationResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` phoneVerificationResult_verificationResult record   `H.hashWithSalt` phoneVerificationResult_accountMigrationCheckType record   `H.hashWithSalt` phoneVerificationResult_recommendAddFriends record  
instance QC.Arbitrary PhoneVerificationResult where 
  arbitrary = M.liftM PhoneVerificationResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PhoneVerificationResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PhoneVerificationResult{phoneVerificationResult_verificationResult = phoneVerificationResult_verificationResult obj} then P.Nothing else P.Just $ default_PhoneVerificationResult{phoneVerificationResult_verificationResult = phoneVerificationResult_verificationResult obj}
    , if obj == default_PhoneVerificationResult{phoneVerificationResult_accountMigrationCheckType = phoneVerificationResult_accountMigrationCheckType obj} then P.Nothing else P.Just $ default_PhoneVerificationResult{phoneVerificationResult_accountMigrationCheckType = phoneVerificationResult_accountMigrationCheckType obj}
    , if obj == default_PhoneVerificationResult{phoneVerificationResult_recommendAddFriends = phoneVerificationResult_recommendAddFriends obj} then P.Nothing else P.Just $ default_PhoneVerificationResult{phoneVerificationResult_recommendAddFriends = phoneVerificationResult_recommendAddFriends obj}
    ]
from_PhoneVerificationResult :: PhoneVerificationResult -> T.ThriftVal
from_PhoneVerificationResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1674 -> P.Just (1, ("verificationResult",T.TI32 $ P.fromIntegral $ P.fromEnum _v1674))) $ phoneVerificationResult_verificationResult record
  , (\_v1674 -> P.Just (2, ("accountMigrationCheckType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1674))) $ phoneVerificationResult_accountMigrationCheckType record
  , (\_v1674 -> P.Just (3, ("recommendAddFriends",T.TBool _v1674))) $ phoneVerificationResult_recommendAddFriends record
  ]
write_PhoneVerificationResult :: T.Protocol p => p -> PhoneVerificationResult -> P.IO ()
write_PhoneVerificationResult oprot record = T.writeVal oprot $ from_PhoneVerificationResult record
encode_PhoneVerificationResult :: T.StatelessProtocol p => p -> PhoneVerificationResult -> LBS.ByteString
encode_PhoneVerificationResult oprot record = T.serializeVal oprot $ from_PhoneVerificationResult record
to_PhoneVerificationResult :: T.ThriftVal -> PhoneVerificationResult
to_PhoneVerificationResult (T.TStruct fields) = PhoneVerificationResult{
  phoneVerificationResult_verificationResult = P.maybe (phoneVerificationResult_verificationResult default_PhoneVerificationResult) (\(_,_val1676) -> (case _val1676 of {T.TI32 _val1677 -> P.toEnum $ P.fromIntegral _val1677; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  phoneVerificationResult_accountMigrationCheckType = P.maybe (phoneVerificationResult_accountMigrationCheckType default_PhoneVerificationResult) (\(_,_val1676) -> (case _val1676 of {T.TI32 _val1678 -> P.toEnum $ P.fromIntegral _val1678; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  phoneVerificationResult_recommendAddFriends = P.maybe (phoneVerificationResult_recommendAddFriends default_PhoneVerificationResult) (\(_,_val1676) -> (case _val1676 of {T.TBool _val1679 -> _val1679; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PhoneVerificationResult _ = P.error "not a struct"
read_PhoneVerificationResult :: T.Protocol p => p -> P.IO PhoneVerificationResult
read_PhoneVerificationResult iprot = to_PhoneVerificationResult <$> T.readVal iprot (T.T_STRUCT typemap_PhoneVerificationResult)
decode_PhoneVerificationResult :: T.StatelessProtocol p => p -> LBS.ByteString -> PhoneVerificationResult
decode_PhoneVerificationResult iprot bs = to_PhoneVerificationResult $ T.deserializeVal iprot (T.T_STRUCT typemap_PhoneVerificationResult) bs
typemap_PhoneVerificationResult :: T.TypeMap
typemap_PhoneVerificationResult = Map.fromList [(1,("verificationResult",T.T_I32)),(2,("accountMigrationCheckType",T.T_I32)),(3,("recommendAddFriends",T.T_BOOL))]
default_PhoneVerificationResult :: PhoneVerificationResult
default_PhoneVerificationResult = PhoneVerificationResult{
  phoneVerificationResult_verificationResult = (P.toEnum 0),
  phoneVerificationResult_accountMigrationCheckType = (P.toEnum 0),
  phoneVerificationResult_recommendAddFriends = P.False}
data PlaceSearchInfo = PlaceSearchInfo  { placeSearchInfo_name :: LT.Text
  , placeSearchInfo_address :: LT.Text
  , placeSearchInfo_latitude :: P.Double
  , placeSearchInfo_longitude :: P.Double
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PlaceSearchInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` placeSearchInfo_name record   `H.hashWithSalt` placeSearchInfo_address record   `H.hashWithSalt` placeSearchInfo_latitude record   `H.hashWithSalt` placeSearchInfo_longitude record  
instance QC.Arbitrary PlaceSearchInfo where 
  arbitrary = M.liftM PlaceSearchInfo (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PlaceSearchInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PlaceSearchInfo{placeSearchInfo_name = placeSearchInfo_name obj} then P.Nothing else P.Just $ default_PlaceSearchInfo{placeSearchInfo_name = placeSearchInfo_name obj}
    , if obj == default_PlaceSearchInfo{placeSearchInfo_address = placeSearchInfo_address obj} then P.Nothing else P.Just $ default_PlaceSearchInfo{placeSearchInfo_address = placeSearchInfo_address obj}
    , if obj == default_PlaceSearchInfo{placeSearchInfo_latitude = placeSearchInfo_latitude obj} then P.Nothing else P.Just $ default_PlaceSearchInfo{placeSearchInfo_latitude = placeSearchInfo_latitude obj}
    , if obj == default_PlaceSearchInfo{placeSearchInfo_longitude = placeSearchInfo_longitude obj} then P.Nothing else P.Just $ default_PlaceSearchInfo{placeSearchInfo_longitude = placeSearchInfo_longitude obj}
    ]
from_PlaceSearchInfo :: PlaceSearchInfo -> T.ThriftVal
from_PlaceSearchInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1682 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v1682))) $ placeSearchInfo_name record
  , (\_v1682 -> P.Just (2, ("address",T.TString $ E.encodeUtf8 _v1682))) $ placeSearchInfo_address record
  , (\_v1682 -> P.Just (3, ("latitude",T.TDouble _v1682))) $ placeSearchInfo_latitude record
  , (\_v1682 -> P.Just (4, ("longitude",T.TDouble _v1682))) $ placeSearchInfo_longitude record
  ]
write_PlaceSearchInfo :: T.Protocol p => p -> PlaceSearchInfo -> P.IO ()
write_PlaceSearchInfo oprot record = T.writeVal oprot $ from_PlaceSearchInfo record
encode_PlaceSearchInfo :: T.StatelessProtocol p => p -> PlaceSearchInfo -> LBS.ByteString
encode_PlaceSearchInfo oprot record = T.serializeVal oprot $ from_PlaceSearchInfo record
to_PlaceSearchInfo :: T.ThriftVal -> PlaceSearchInfo
to_PlaceSearchInfo (T.TStruct fields) = PlaceSearchInfo{
  placeSearchInfo_name = P.maybe (placeSearchInfo_name default_PlaceSearchInfo) (\(_,_val1684) -> (case _val1684 of {T.TString _val1685 -> E.decodeUtf8 _val1685; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  placeSearchInfo_address = P.maybe (placeSearchInfo_address default_PlaceSearchInfo) (\(_,_val1684) -> (case _val1684 of {T.TString _val1686 -> E.decodeUtf8 _val1686; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  placeSearchInfo_latitude = P.maybe (placeSearchInfo_latitude default_PlaceSearchInfo) (\(_,_val1684) -> (case _val1684 of {T.TDouble _val1687 -> _val1687; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  placeSearchInfo_longitude = P.maybe (placeSearchInfo_longitude default_PlaceSearchInfo) (\(_,_val1684) -> (case _val1684 of {T.TDouble _val1688 -> _val1688; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_PlaceSearchInfo _ = P.error "not a struct"
read_PlaceSearchInfo :: T.Protocol p => p -> P.IO PlaceSearchInfo
read_PlaceSearchInfo iprot = to_PlaceSearchInfo <$> T.readVal iprot (T.T_STRUCT typemap_PlaceSearchInfo)
decode_PlaceSearchInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> PlaceSearchInfo
decode_PlaceSearchInfo iprot bs = to_PlaceSearchInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_PlaceSearchInfo) bs
typemap_PlaceSearchInfo :: T.TypeMap
typemap_PlaceSearchInfo = Map.fromList [(1,("name",T.T_STRING)),(2,("address",T.T_STRING)),(3,("latitude",T.T_DOUBLE)),(4,("longitude",T.T_DOUBLE))]
default_PlaceSearchInfo :: PlaceSearchInfo
default_PlaceSearchInfo = PlaceSearchInfo{
  placeSearchInfo_name = "",
  placeSearchInfo_address = "",
  placeSearchInfo_latitude = 0,
  placeSearchInfo_longitude = 0}
data RSAKey = RSAKey  { rSAKey_keynm :: LT.Text
  , rSAKey_nvalue :: LT.Text
  , rSAKey_evalue :: LT.Text
  , rSAKey_sessionKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RSAKey where
  hashWithSalt salt record = salt   `H.hashWithSalt` rSAKey_keynm record   `H.hashWithSalt` rSAKey_nvalue record   `H.hashWithSalt` rSAKey_evalue record   `H.hashWithSalt` rSAKey_sessionKey record  
instance QC.Arbitrary RSAKey where 
  arbitrary = M.liftM RSAKey (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RSAKey = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RSAKey{rSAKey_keynm = rSAKey_keynm obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_keynm = rSAKey_keynm obj}
    , if obj == default_RSAKey{rSAKey_nvalue = rSAKey_nvalue obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_nvalue = rSAKey_nvalue obj}
    , if obj == default_RSAKey{rSAKey_evalue = rSAKey_evalue obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_evalue = rSAKey_evalue obj}
    , if obj == default_RSAKey{rSAKey_sessionKey = rSAKey_sessionKey obj} then P.Nothing else P.Just $ default_RSAKey{rSAKey_sessionKey = rSAKey_sessionKey obj}
    ]
from_RSAKey :: RSAKey -> T.ThriftVal
from_RSAKey record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1691 -> P.Just (1, ("keynm",T.TString $ E.encodeUtf8 _v1691))) $ rSAKey_keynm record
  , (\_v1691 -> P.Just (2, ("nvalue",T.TString $ E.encodeUtf8 _v1691))) $ rSAKey_nvalue record
  , (\_v1691 -> P.Just (3, ("evalue",T.TString $ E.encodeUtf8 _v1691))) $ rSAKey_evalue record
  , (\_v1691 -> P.Just (4, ("sessionKey",T.TString $ E.encodeUtf8 _v1691))) $ rSAKey_sessionKey record
  ]
write_RSAKey :: T.Protocol p => p -> RSAKey -> P.IO ()
write_RSAKey oprot record = T.writeVal oprot $ from_RSAKey record
encode_RSAKey :: T.StatelessProtocol p => p -> RSAKey -> LBS.ByteString
encode_RSAKey oprot record = T.serializeVal oprot $ from_RSAKey record
to_RSAKey :: T.ThriftVal -> RSAKey
to_RSAKey (T.TStruct fields) = RSAKey{
  rSAKey_keynm = P.maybe (rSAKey_keynm default_RSAKey) (\(_,_val1693) -> (case _val1693 of {T.TString _val1694 -> E.decodeUtf8 _val1694; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rSAKey_nvalue = P.maybe (rSAKey_nvalue default_RSAKey) (\(_,_val1693) -> (case _val1693 of {T.TString _val1695 -> E.decodeUtf8 _val1695; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  rSAKey_evalue = P.maybe (rSAKey_evalue default_RSAKey) (\(_,_val1693) -> (case _val1693 of {T.TString _val1696 -> E.decodeUtf8 _val1696; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  rSAKey_sessionKey = P.maybe (rSAKey_sessionKey default_RSAKey) (\(_,_val1693) -> (case _val1693 of {T.TString _val1697 -> E.decodeUtf8 _val1697; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RSAKey _ = P.error "not a struct"
read_RSAKey :: T.Protocol p => p -> P.IO RSAKey
read_RSAKey iprot = to_RSAKey <$> T.readVal iprot (T.T_STRUCT typemap_RSAKey)
decode_RSAKey :: T.StatelessProtocol p => p -> LBS.ByteString -> RSAKey
decode_RSAKey iprot bs = to_RSAKey $ T.deserializeVal iprot (T.T_STRUCT typemap_RSAKey) bs
typemap_RSAKey :: T.TypeMap
typemap_RSAKey = Map.fromList [(1,("keynm",T.T_STRING)),(2,("nvalue",T.T_STRING)),(3,("evalue",T.T_STRING)),(4,("sessionKey",T.T_STRING))]
default_RSAKey :: RSAKey
default_RSAKey = RSAKey{
  rSAKey_keynm = "",
  rSAKey_nvalue = "",
  rSAKey_evalue = "",
  rSAKey_sessionKey = ""}
data SecurityCenterResult = SecurityCenterResult  { securityCenterResult_uri :: LT.Text
  , securityCenterResult_token :: LT.Text
  , securityCenterResult_cookiePath :: LT.Text
  , securityCenterResult_skip :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SecurityCenterResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` securityCenterResult_uri record   `H.hashWithSalt` securityCenterResult_token record   `H.hashWithSalt` securityCenterResult_cookiePath record   `H.hashWithSalt` securityCenterResult_skip record  
instance QC.Arbitrary SecurityCenterResult where 
  arbitrary = M.liftM SecurityCenterResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SecurityCenterResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SecurityCenterResult{securityCenterResult_uri = securityCenterResult_uri obj} then P.Nothing else P.Just $ default_SecurityCenterResult{securityCenterResult_uri = securityCenterResult_uri obj}
    , if obj == default_SecurityCenterResult{securityCenterResult_token = securityCenterResult_token obj} then P.Nothing else P.Just $ default_SecurityCenterResult{securityCenterResult_token = securityCenterResult_token obj}
    , if obj == default_SecurityCenterResult{securityCenterResult_cookiePath = securityCenterResult_cookiePath obj} then P.Nothing else P.Just $ default_SecurityCenterResult{securityCenterResult_cookiePath = securityCenterResult_cookiePath obj}
    , if obj == default_SecurityCenterResult{securityCenterResult_skip = securityCenterResult_skip obj} then P.Nothing else P.Just $ default_SecurityCenterResult{securityCenterResult_skip = securityCenterResult_skip obj}
    ]
from_SecurityCenterResult :: SecurityCenterResult -> T.ThriftVal
from_SecurityCenterResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1700 -> P.Just (1, ("uri",T.TString $ E.encodeUtf8 _v1700))) $ securityCenterResult_uri record
  , (\_v1700 -> P.Just (2, ("token",T.TString $ E.encodeUtf8 _v1700))) $ securityCenterResult_token record
  , (\_v1700 -> P.Just (3, ("cookiePath",T.TString $ E.encodeUtf8 _v1700))) $ securityCenterResult_cookiePath record
  , (\_v1700 -> P.Just (4, ("skip",T.TBool _v1700))) $ securityCenterResult_skip record
  ]
write_SecurityCenterResult :: T.Protocol p => p -> SecurityCenterResult -> P.IO ()
write_SecurityCenterResult oprot record = T.writeVal oprot $ from_SecurityCenterResult record
encode_SecurityCenterResult :: T.StatelessProtocol p => p -> SecurityCenterResult -> LBS.ByteString
encode_SecurityCenterResult oprot record = T.serializeVal oprot $ from_SecurityCenterResult record
to_SecurityCenterResult :: T.ThriftVal -> SecurityCenterResult
to_SecurityCenterResult (T.TStruct fields) = SecurityCenterResult{
  securityCenterResult_uri = P.maybe (securityCenterResult_uri default_SecurityCenterResult) (\(_,_val1702) -> (case _val1702 of {T.TString _val1703 -> E.decodeUtf8 _val1703; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  securityCenterResult_token = P.maybe (securityCenterResult_token default_SecurityCenterResult) (\(_,_val1702) -> (case _val1702 of {T.TString _val1704 -> E.decodeUtf8 _val1704; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  securityCenterResult_cookiePath = P.maybe (securityCenterResult_cookiePath default_SecurityCenterResult) (\(_,_val1702) -> (case _val1702 of {T.TString _val1705 -> E.decodeUtf8 _val1705; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  securityCenterResult_skip = P.maybe (securityCenterResult_skip default_SecurityCenterResult) (\(_,_val1702) -> (case _val1702 of {T.TBool _val1706 -> _val1706; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SecurityCenterResult _ = P.error "not a struct"
read_SecurityCenterResult :: T.Protocol p => p -> P.IO SecurityCenterResult
read_SecurityCenterResult iprot = to_SecurityCenterResult <$> T.readVal iprot (T.T_STRUCT typemap_SecurityCenterResult)
decode_SecurityCenterResult :: T.StatelessProtocol p => p -> LBS.ByteString -> SecurityCenterResult
decode_SecurityCenterResult iprot bs = to_SecurityCenterResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SecurityCenterResult) bs
typemap_SecurityCenterResult :: T.TypeMap
typemap_SecurityCenterResult = Map.fromList [(1,("uri",T.T_STRING)),(2,("token",T.T_STRING)),(3,("cookiePath",T.T_STRING)),(4,("skip",T.T_BOOL))]
default_SecurityCenterResult :: SecurityCenterResult
default_SecurityCenterResult = SecurityCenterResult{
  securityCenterResult_uri = "",
  securityCenterResult_token = "",
  securityCenterResult_cookiePath = "",
  securityCenterResult_skip = P.False}
data SendBuddyMessageResult = SendBuddyMessageResult  { sendBuddyMessageResult_requestId :: LT.Text
  , sendBuddyMessageResult_state :: BuddyResultState
  , sendBuddyMessageResult_messageId :: LT.Text
  , sendBuddyMessageResult_eventNo :: I.Int32
  , sendBuddyMessageResult_receiverCount :: I.Int64
  , sendBuddyMessageResult_successCount :: I.Int64
  , sendBuddyMessageResult_failCount :: I.Int64
  , sendBuddyMessageResult_cancelCount :: I.Int64
  , sendBuddyMessageResult_blockCount :: I.Int64
  , sendBuddyMessageResult_unregisterCount :: I.Int64
  , sendBuddyMessageResult_timestamp :: I.Int64
  , sendBuddyMessageResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendBuddyMessageResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendBuddyMessageResult_requestId record   `H.hashWithSalt` sendBuddyMessageResult_state record   `H.hashWithSalt` sendBuddyMessageResult_messageId record   `H.hashWithSalt` sendBuddyMessageResult_eventNo record   `H.hashWithSalt` sendBuddyMessageResult_receiverCount record   `H.hashWithSalt` sendBuddyMessageResult_successCount record   `H.hashWithSalt` sendBuddyMessageResult_failCount record   `H.hashWithSalt` sendBuddyMessageResult_cancelCount record   `H.hashWithSalt` sendBuddyMessageResult_blockCount record   `H.hashWithSalt` sendBuddyMessageResult_unregisterCount record   `H.hashWithSalt` sendBuddyMessageResult_timestamp record   `H.hashWithSalt` sendBuddyMessageResult_message record  
instance QC.Arbitrary SendBuddyMessageResult where 
  arbitrary = M.liftM SendBuddyMessageResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendBuddyMessageResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_requestId = sendBuddyMessageResult_requestId obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_requestId = sendBuddyMessageResult_requestId obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_state = sendBuddyMessageResult_state obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_state = sendBuddyMessageResult_state obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_messageId = sendBuddyMessageResult_messageId obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_messageId = sendBuddyMessageResult_messageId obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_eventNo = sendBuddyMessageResult_eventNo obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_eventNo = sendBuddyMessageResult_eventNo obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_receiverCount = sendBuddyMessageResult_receiverCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_receiverCount = sendBuddyMessageResult_receiverCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_successCount = sendBuddyMessageResult_successCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_successCount = sendBuddyMessageResult_successCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_failCount = sendBuddyMessageResult_failCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_failCount = sendBuddyMessageResult_failCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_cancelCount = sendBuddyMessageResult_cancelCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_cancelCount = sendBuddyMessageResult_cancelCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_blockCount = sendBuddyMessageResult_blockCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_blockCount = sendBuddyMessageResult_blockCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_unregisterCount = sendBuddyMessageResult_unregisterCount obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_unregisterCount = sendBuddyMessageResult_unregisterCount obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_timestamp = sendBuddyMessageResult_timestamp obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_timestamp = sendBuddyMessageResult_timestamp obj}
    , if obj == default_SendBuddyMessageResult{sendBuddyMessageResult_message = sendBuddyMessageResult_message obj} then P.Nothing else P.Just $ default_SendBuddyMessageResult{sendBuddyMessageResult_message = sendBuddyMessageResult_message obj}
    ]
from_SendBuddyMessageResult :: SendBuddyMessageResult -> T.ThriftVal
from_SendBuddyMessageResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1709 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v1709))) $ sendBuddyMessageResult_requestId record
  , (\_v1709 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v1709))) $ sendBuddyMessageResult_state record
  , (\_v1709 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v1709))) $ sendBuddyMessageResult_messageId record
  , (\_v1709 -> P.Just (4, ("eventNo",T.TI32 _v1709))) $ sendBuddyMessageResult_eventNo record
  , (\_v1709 -> P.Just (11, ("receiverCount",T.TI64 _v1709))) $ sendBuddyMessageResult_receiverCount record
  , (\_v1709 -> P.Just (12, ("successCount",T.TI64 _v1709))) $ sendBuddyMessageResult_successCount record
  , (\_v1709 -> P.Just (13, ("failCount",T.TI64 _v1709))) $ sendBuddyMessageResult_failCount record
  , (\_v1709 -> P.Just (14, ("cancelCount",T.TI64 _v1709))) $ sendBuddyMessageResult_cancelCount record
  , (\_v1709 -> P.Just (15, ("blockCount",T.TI64 _v1709))) $ sendBuddyMessageResult_blockCount record
  , (\_v1709 -> P.Just (16, ("unregisterCount",T.TI64 _v1709))) $ sendBuddyMessageResult_unregisterCount record
  , (\_v1709 -> P.Just (21, ("timestamp",T.TI64 _v1709))) $ sendBuddyMessageResult_timestamp record
  , (\_v1709 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v1709))) $ sendBuddyMessageResult_message record
  ]
write_SendBuddyMessageResult :: T.Protocol p => p -> SendBuddyMessageResult -> P.IO ()
write_SendBuddyMessageResult oprot record = T.writeVal oprot $ from_SendBuddyMessageResult record
encode_SendBuddyMessageResult :: T.StatelessProtocol p => p -> SendBuddyMessageResult -> LBS.ByteString
encode_SendBuddyMessageResult oprot record = T.serializeVal oprot $ from_SendBuddyMessageResult record
to_SendBuddyMessageResult :: T.ThriftVal -> SendBuddyMessageResult
to_SendBuddyMessageResult (T.TStruct fields) = SendBuddyMessageResult{
  sendBuddyMessageResult_requestId = P.maybe (sendBuddyMessageResult_requestId default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TString _val1712 -> E.decodeUtf8 _val1712; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendBuddyMessageResult_state = P.maybe (sendBuddyMessageResult_state default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI32 _val1713 -> P.toEnum $ P.fromIntegral _val1713; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendBuddyMessageResult_messageId = P.maybe (sendBuddyMessageResult_messageId default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TString _val1714 -> E.decodeUtf8 _val1714; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sendBuddyMessageResult_eventNo = P.maybe (sendBuddyMessageResult_eventNo default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI32 _val1715 -> _val1715; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sendBuddyMessageResult_receiverCount = P.maybe (sendBuddyMessageResult_receiverCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1716 -> _val1716; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  sendBuddyMessageResult_successCount = P.maybe (sendBuddyMessageResult_successCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1717 -> _val1717; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  sendBuddyMessageResult_failCount = P.maybe (sendBuddyMessageResult_failCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1718 -> _val1718; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  sendBuddyMessageResult_cancelCount = P.maybe (sendBuddyMessageResult_cancelCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1719 -> _val1719; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  sendBuddyMessageResult_blockCount = P.maybe (sendBuddyMessageResult_blockCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1720 -> _val1720; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  sendBuddyMessageResult_unregisterCount = P.maybe (sendBuddyMessageResult_unregisterCount default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1721 -> _val1721; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  sendBuddyMessageResult_timestamp = P.maybe (sendBuddyMessageResult_timestamp default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TI64 _val1722 -> _val1722; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  sendBuddyMessageResult_message = P.maybe (sendBuddyMessageResult_message default_SendBuddyMessageResult) (\(_,_val1711) -> (case _val1711 of {T.TString _val1723 -> E.decodeUtf8 _val1723; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_SendBuddyMessageResult _ = P.error "not a struct"
read_SendBuddyMessageResult :: T.Protocol p => p -> P.IO SendBuddyMessageResult
read_SendBuddyMessageResult iprot = to_SendBuddyMessageResult <$> T.readVal iprot (T.T_STRUCT typemap_SendBuddyMessageResult)
decode_SendBuddyMessageResult :: T.StatelessProtocol p => p -> LBS.ByteString -> SendBuddyMessageResult
decode_SendBuddyMessageResult iprot bs = to_SendBuddyMessageResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SendBuddyMessageResult) bs
typemap_SendBuddyMessageResult :: T.TypeMap
typemap_SendBuddyMessageResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("messageId",T.T_STRING)),(4,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("blockCount",T.T_I64)),(16,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_SendBuddyMessageResult :: SendBuddyMessageResult
default_SendBuddyMessageResult = SendBuddyMessageResult{
  sendBuddyMessageResult_requestId = "",
  sendBuddyMessageResult_state = (P.toEnum 0),
  sendBuddyMessageResult_messageId = "",
  sendBuddyMessageResult_eventNo = 0,
  sendBuddyMessageResult_receiverCount = 0,
  sendBuddyMessageResult_successCount = 0,
  sendBuddyMessageResult_failCount = 0,
  sendBuddyMessageResult_cancelCount = 0,
  sendBuddyMessageResult_blockCount = 0,
  sendBuddyMessageResult_unregisterCount = 0,
  sendBuddyMessageResult_timestamp = 0,
  sendBuddyMessageResult_message = ""}
data SetBuddyOnAirResult = SetBuddyOnAirResult  { setBuddyOnAirResult_requestId :: LT.Text
  , setBuddyOnAirResult_state :: BuddyResultState
  , setBuddyOnAirResult_eventNo :: I.Int32
  , setBuddyOnAirResult_receiverCount :: I.Int64
  , setBuddyOnAirResult_successCount :: I.Int64
  , setBuddyOnAirResult_failCount :: I.Int64
  , setBuddyOnAirResult_cancelCount :: I.Int64
  , setBuddyOnAirResult_unregisterCount :: I.Int64
  , setBuddyOnAirResult_timestamp :: I.Int64
  , setBuddyOnAirResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyOnAirResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyOnAirResult_requestId record   `H.hashWithSalt` setBuddyOnAirResult_state record   `H.hashWithSalt` setBuddyOnAirResult_eventNo record   `H.hashWithSalt` setBuddyOnAirResult_receiverCount record   `H.hashWithSalt` setBuddyOnAirResult_successCount record   `H.hashWithSalt` setBuddyOnAirResult_failCount record   `H.hashWithSalt` setBuddyOnAirResult_cancelCount record   `H.hashWithSalt` setBuddyOnAirResult_unregisterCount record   `H.hashWithSalt` setBuddyOnAirResult_timestamp record   `H.hashWithSalt` setBuddyOnAirResult_message record  
instance QC.Arbitrary SetBuddyOnAirResult where 
  arbitrary = M.liftM SetBuddyOnAirResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetBuddyOnAirResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_requestId = setBuddyOnAirResult_requestId obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_requestId = setBuddyOnAirResult_requestId obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_state = setBuddyOnAirResult_state obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_state = setBuddyOnAirResult_state obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_eventNo = setBuddyOnAirResult_eventNo obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_eventNo = setBuddyOnAirResult_eventNo obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_receiverCount = setBuddyOnAirResult_receiverCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_receiverCount = setBuddyOnAirResult_receiverCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_successCount = setBuddyOnAirResult_successCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_successCount = setBuddyOnAirResult_successCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_failCount = setBuddyOnAirResult_failCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_failCount = setBuddyOnAirResult_failCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_cancelCount = setBuddyOnAirResult_cancelCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_cancelCount = setBuddyOnAirResult_cancelCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_unregisterCount = setBuddyOnAirResult_unregisterCount obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_unregisterCount = setBuddyOnAirResult_unregisterCount obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_timestamp = setBuddyOnAirResult_timestamp obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_timestamp = setBuddyOnAirResult_timestamp obj}
    , if obj == default_SetBuddyOnAirResult{setBuddyOnAirResult_message = setBuddyOnAirResult_message obj} then P.Nothing else P.Just $ default_SetBuddyOnAirResult{setBuddyOnAirResult_message = setBuddyOnAirResult_message obj}
    ]
from_SetBuddyOnAirResult :: SetBuddyOnAirResult -> T.ThriftVal
from_SetBuddyOnAirResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1726 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v1726))) $ setBuddyOnAirResult_requestId record
  , (\_v1726 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v1726))) $ setBuddyOnAirResult_state record
  , (\_v1726 -> P.Just (3, ("eventNo",T.TI32 _v1726))) $ setBuddyOnAirResult_eventNo record
  , (\_v1726 -> P.Just (11, ("receiverCount",T.TI64 _v1726))) $ setBuddyOnAirResult_receiverCount record
  , (\_v1726 -> P.Just (12, ("successCount",T.TI64 _v1726))) $ setBuddyOnAirResult_successCount record
  , (\_v1726 -> P.Just (13, ("failCount",T.TI64 _v1726))) $ setBuddyOnAirResult_failCount record
  , (\_v1726 -> P.Just (14, ("cancelCount",T.TI64 _v1726))) $ setBuddyOnAirResult_cancelCount record
  , (\_v1726 -> P.Just (15, ("unregisterCount",T.TI64 _v1726))) $ setBuddyOnAirResult_unregisterCount record
  , (\_v1726 -> P.Just (21, ("timestamp",T.TI64 _v1726))) $ setBuddyOnAirResult_timestamp record
  , (\_v1726 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v1726))) $ setBuddyOnAirResult_message record
  ]
write_SetBuddyOnAirResult :: T.Protocol p => p -> SetBuddyOnAirResult -> P.IO ()
write_SetBuddyOnAirResult oprot record = T.writeVal oprot $ from_SetBuddyOnAirResult record
encode_SetBuddyOnAirResult :: T.StatelessProtocol p => p -> SetBuddyOnAirResult -> LBS.ByteString
encode_SetBuddyOnAirResult oprot record = T.serializeVal oprot $ from_SetBuddyOnAirResult record
to_SetBuddyOnAirResult :: T.ThriftVal -> SetBuddyOnAirResult
to_SetBuddyOnAirResult (T.TStruct fields) = SetBuddyOnAirResult{
  setBuddyOnAirResult_requestId = P.maybe (setBuddyOnAirResult_requestId default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TString _val1729 -> E.decodeUtf8 _val1729; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setBuddyOnAirResult_state = P.maybe (setBuddyOnAirResult_state default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI32 _val1730 -> P.toEnum $ P.fromIntegral _val1730; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setBuddyOnAirResult_eventNo = P.maybe (setBuddyOnAirResult_eventNo default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI32 _val1731 -> _val1731; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setBuddyOnAirResult_receiverCount = P.maybe (setBuddyOnAirResult_receiverCount default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1732 -> _val1732; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  setBuddyOnAirResult_successCount = P.maybe (setBuddyOnAirResult_successCount default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1733 -> _val1733; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  setBuddyOnAirResult_failCount = P.maybe (setBuddyOnAirResult_failCount default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1734 -> _val1734; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  setBuddyOnAirResult_cancelCount = P.maybe (setBuddyOnAirResult_cancelCount default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1735 -> _val1735; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  setBuddyOnAirResult_unregisterCount = P.maybe (setBuddyOnAirResult_unregisterCount default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1736 -> _val1736; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  setBuddyOnAirResult_timestamp = P.maybe (setBuddyOnAirResult_timestamp default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TI64 _val1737 -> _val1737; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  setBuddyOnAirResult_message = P.maybe (setBuddyOnAirResult_message default_SetBuddyOnAirResult) (\(_,_val1728) -> (case _val1728 of {T.TString _val1738 -> E.decodeUtf8 _val1738; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_SetBuddyOnAirResult _ = P.error "not a struct"
read_SetBuddyOnAirResult :: T.Protocol p => p -> P.IO SetBuddyOnAirResult
read_SetBuddyOnAirResult iprot = to_SetBuddyOnAirResult <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyOnAirResult)
decode_SetBuddyOnAirResult :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyOnAirResult
decode_SetBuddyOnAirResult iprot bs = to_SetBuddyOnAirResult $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyOnAirResult) bs
typemap_SetBuddyOnAirResult :: T.TypeMap
typemap_SetBuddyOnAirResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_SetBuddyOnAirResult :: SetBuddyOnAirResult
default_SetBuddyOnAirResult = SetBuddyOnAirResult{
  setBuddyOnAirResult_requestId = "",
  setBuddyOnAirResult_state = (P.toEnum 0),
  setBuddyOnAirResult_eventNo = 0,
  setBuddyOnAirResult_receiverCount = 0,
  setBuddyOnAirResult_successCount = 0,
  setBuddyOnAirResult_failCount = 0,
  setBuddyOnAirResult_cancelCount = 0,
  setBuddyOnAirResult_unregisterCount = 0,
  setBuddyOnAirResult_timestamp = 0,
  setBuddyOnAirResult_message = ""}
data Settings = Settings  { settings_notificationEnable :: P.Bool
  , settings_notificationMuteExpiration :: I.Int64
  , settings_notificationNewMessage :: P.Bool
  , settings_notificationGroupInvitation :: P.Bool
  , settings_notificationShowMessage :: P.Bool
  , settings_notificationIncomingCall :: P.Bool
  , settings_notificationSoundMessage :: LT.Text
  , settings_notificationSoundGroup :: LT.Text
  , settings_notificationDisabledWithSub :: P.Bool
  , settings_privacySyncContacts :: P.Bool
  , settings_privacySearchByPhoneNumber :: P.Bool
  , settings_privacySearchByUserid :: P.Bool
  , settings_privacySearchByEmail :: P.Bool
  , settings_privacyAllowSecondaryDeviceLogin :: P.Bool
  , settings_privacyProfileImagePostToMyhome :: P.Bool
  , settings_privacyReceiveMessagesFromNotFriend :: P.Bool
  , settings_contactMyTicket :: LT.Text
  , settings_identityProvider :: IdentityProvider
  , settings_identityIdentifier :: LT.Text
  , settings_snsAccounts :: (Map.HashMap SnsIdType LT.Text)
  , settings_phoneRegistration :: P.Bool
  , settings_emailConfirmationStatus :: EmailConfirmationStatus
  , settings_preferenceLocale :: LT.Text
  , settings_customModes :: (Map.HashMap CustomMode LT.Text)
  , settings_e2eeEnable :: P.Bool
  , settings_hitokotoBackupRequested :: P.Bool
  , settings_privacyProfileMusicPostToMyhome :: P.Bool
  , settings_privacyAllowNearby :: P.Bool
  , settings_agreementNearbyTime :: I.Int64
  , settings_agreementSquareTime :: I.Int64
  , settings_notificationMention :: P.Bool
  , settings_botUseAgreementAcceptedAt :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Settings where
  hashWithSalt salt record = salt   `H.hashWithSalt` settings_notificationEnable record   `H.hashWithSalt` settings_notificationMuteExpiration record   `H.hashWithSalt` settings_notificationNewMessage record   `H.hashWithSalt` settings_notificationGroupInvitation record   `H.hashWithSalt` settings_notificationShowMessage record   `H.hashWithSalt` settings_notificationIncomingCall record   `H.hashWithSalt` settings_notificationSoundMessage record   `H.hashWithSalt` settings_notificationSoundGroup record   `H.hashWithSalt` settings_notificationDisabledWithSub record   `H.hashWithSalt` settings_privacySyncContacts record   `H.hashWithSalt` settings_privacySearchByPhoneNumber record   `H.hashWithSalt` settings_privacySearchByUserid record   `H.hashWithSalt` settings_privacySearchByEmail record   `H.hashWithSalt` settings_privacyAllowSecondaryDeviceLogin record   `H.hashWithSalt` settings_privacyProfileImagePostToMyhome record   `H.hashWithSalt` settings_privacyReceiveMessagesFromNotFriend record   `H.hashWithSalt` settings_contactMyTicket record   `H.hashWithSalt` settings_identityProvider record   `H.hashWithSalt` settings_identityIdentifier record   `H.hashWithSalt` settings_snsAccounts record   `H.hashWithSalt` settings_phoneRegistration record   `H.hashWithSalt` settings_emailConfirmationStatus record   `H.hashWithSalt` settings_preferenceLocale record   `H.hashWithSalt` settings_customModes record   `H.hashWithSalt` settings_e2eeEnable record   `H.hashWithSalt` settings_hitokotoBackupRequested record   `H.hashWithSalt` settings_privacyProfileMusicPostToMyhome record   `H.hashWithSalt` settings_privacyAllowNearby record   `H.hashWithSalt` settings_agreementNearbyTime record   `H.hashWithSalt` settings_agreementSquareTime record   `H.hashWithSalt` settings_notificationMention record   `H.hashWithSalt` settings_botUseAgreementAcceptedAt record  
instance QC.Arbitrary Settings where 
  arbitrary = M.liftM Settings (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Settings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Settings{settings_notificationEnable = settings_notificationEnable obj} then P.Nothing else P.Just $ default_Settings{settings_notificationEnable = settings_notificationEnable obj}
    , if obj == default_Settings{settings_notificationMuteExpiration = settings_notificationMuteExpiration obj} then P.Nothing else P.Just $ default_Settings{settings_notificationMuteExpiration = settings_notificationMuteExpiration obj}
    , if obj == default_Settings{settings_notificationNewMessage = settings_notificationNewMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationNewMessage = settings_notificationNewMessage obj}
    , if obj == default_Settings{settings_notificationGroupInvitation = settings_notificationGroupInvitation obj} then P.Nothing else P.Just $ default_Settings{settings_notificationGroupInvitation = settings_notificationGroupInvitation obj}
    , if obj == default_Settings{settings_notificationShowMessage = settings_notificationShowMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationShowMessage = settings_notificationShowMessage obj}
    , if obj == default_Settings{settings_notificationIncomingCall = settings_notificationIncomingCall obj} then P.Nothing else P.Just $ default_Settings{settings_notificationIncomingCall = settings_notificationIncomingCall obj}
    , if obj == default_Settings{settings_notificationSoundMessage = settings_notificationSoundMessage obj} then P.Nothing else P.Just $ default_Settings{settings_notificationSoundMessage = settings_notificationSoundMessage obj}
    , if obj == default_Settings{settings_notificationSoundGroup = settings_notificationSoundGroup obj} then P.Nothing else P.Just $ default_Settings{settings_notificationSoundGroup = settings_notificationSoundGroup obj}
    , if obj == default_Settings{settings_notificationDisabledWithSub = settings_notificationDisabledWithSub obj} then P.Nothing else P.Just $ default_Settings{settings_notificationDisabledWithSub = settings_notificationDisabledWithSub obj}
    , if obj == default_Settings{settings_privacySyncContacts = settings_privacySyncContacts obj} then P.Nothing else P.Just $ default_Settings{settings_privacySyncContacts = settings_privacySyncContacts obj}
    , if obj == default_Settings{settings_privacySearchByPhoneNumber = settings_privacySearchByPhoneNumber obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByPhoneNumber = settings_privacySearchByPhoneNumber obj}
    , if obj == default_Settings{settings_privacySearchByUserid = settings_privacySearchByUserid obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByUserid = settings_privacySearchByUserid obj}
    , if obj == default_Settings{settings_privacySearchByEmail = settings_privacySearchByEmail obj} then P.Nothing else P.Just $ default_Settings{settings_privacySearchByEmail = settings_privacySearchByEmail obj}
    , if obj == default_Settings{settings_privacyAllowSecondaryDeviceLogin = settings_privacyAllowSecondaryDeviceLogin obj} then P.Nothing else P.Just $ default_Settings{settings_privacyAllowSecondaryDeviceLogin = settings_privacyAllowSecondaryDeviceLogin obj}
    , if obj == default_Settings{settings_privacyProfileImagePostToMyhome = settings_privacyProfileImagePostToMyhome obj} then P.Nothing else P.Just $ default_Settings{settings_privacyProfileImagePostToMyhome = settings_privacyProfileImagePostToMyhome obj}
    , if obj == default_Settings{settings_privacyReceiveMessagesFromNotFriend = settings_privacyReceiveMessagesFromNotFriend obj} then P.Nothing else P.Just $ default_Settings{settings_privacyReceiveMessagesFromNotFriend = settings_privacyReceiveMessagesFromNotFriend obj}
    , if obj == default_Settings{settings_contactMyTicket = settings_contactMyTicket obj} then P.Nothing else P.Just $ default_Settings{settings_contactMyTicket = settings_contactMyTicket obj}
    , if obj == default_Settings{settings_identityProvider = settings_identityProvider obj} then P.Nothing else P.Just $ default_Settings{settings_identityProvider = settings_identityProvider obj}
    , if obj == default_Settings{settings_identityIdentifier = settings_identityIdentifier obj} then P.Nothing else P.Just $ default_Settings{settings_identityIdentifier = settings_identityIdentifier obj}
    , if obj == default_Settings{settings_snsAccounts = settings_snsAccounts obj} then P.Nothing else P.Just $ default_Settings{settings_snsAccounts = settings_snsAccounts obj}
    , if obj == default_Settings{settings_phoneRegistration = settings_phoneRegistration obj} then P.Nothing else P.Just $ default_Settings{settings_phoneRegistration = settings_phoneRegistration obj}
    , if obj == default_Settings{settings_emailConfirmationStatus = settings_emailConfirmationStatus obj} then P.Nothing else P.Just $ default_Settings{settings_emailConfirmationStatus = settings_emailConfirmationStatus obj}
    , if obj == default_Settings{settings_preferenceLocale = settings_preferenceLocale obj} then P.Nothing else P.Just $ default_Settings{settings_preferenceLocale = settings_preferenceLocale obj}
    , if obj == default_Settings{settings_customModes = settings_customModes obj} then P.Nothing else P.Just $ default_Settings{settings_customModes = settings_customModes obj}
    , if obj == default_Settings{settings_e2eeEnable = settings_e2eeEnable obj} then P.Nothing else P.Just $ default_Settings{settings_e2eeEnable = settings_e2eeEnable obj}
    , if obj == default_Settings{settings_hitokotoBackupRequested = settings_hitokotoBackupRequested obj} then P.Nothing else P.Just $ default_Settings{settings_hitokotoBackupRequested = settings_hitokotoBackupRequested obj}
    , if obj == default_Settings{settings_privacyProfileMusicPostToMyhome = settings_privacyProfileMusicPostToMyhome obj} then P.Nothing else P.Just $ default_Settings{settings_privacyProfileMusicPostToMyhome = settings_privacyProfileMusicPostToMyhome obj}
    , if obj == default_Settings{settings_privacyAllowNearby = settings_privacyAllowNearby obj} then P.Nothing else P.Just $ default_Settings{settings_privacyAllowNearby = settings_privacyAllowNearby obj}
    , if obj == default_Settings{settings_agreementNearbyTime = settings_agreementNearbyTime obj} then P.Nothing else P.Just $ default_Settings{settings_agreementNearbyTime = settings_agreementNearbyTime obj}
    , if obj == default_Settings{settings_agreementSquareTime = settings_agreementSquareTime obj} then P.Nothing else P.Just $ default_Settings{settings_agreementSquareTime = settings_agreementSquareTime obj}
    , if obj == default_Settings{settings_notificationMention = settings_notificationMention obj} then P.Nothing else P.Just $ default_Settings{settings_notificationMention = settings_notificationMention obj}
    , if obj == default_Settings{settings_botUseAgreementAcceptedAt = settings_botUseAgreementAcceptedAt obj} then P.Nothing else P.Just $ default_Settings{settings_botUseAgreementAcceptedAt = settings_botUseAgreementAcceptedAt obj}
    ]
from_Settings :: Settings -> T.ThriftVal
from_Settings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1741 -> P.Just (10, ("notificationEnable",T.TBool _v1741))) $ settings_notificationEnable record
  , (\_v1741 -> P.Just (11, ("notificationMuteExpiration",T.TI64 _v1741))) $ settings_notificationMuteExpiration record
  , (\_v1741 -> P.Just (12, ("notificationNewMessage",T.TBool _v1741))) $ settings_notificationNewMessage record
  , (\_v1741 -> P.Just (13, ("notificationGroupInvitation",T.TBool _v1741))) $ settings_notificationGroupInvitation record
  , (\_v1741 -> P.Just (14, ("notificationShowMessage",T.TBool _v1741))) $ settings_notificationShowMessage record
  , (\_v1741 -> P.Just (15, ("notificationIncomingCall",T.TBool _v1741))) $ settings_notificationIncomingCall record
  , (\_v1741 -> P.Just (16, ("notificationSoundMessage",T.TString $ E.encodeUtf8 _v1741))) $ settings_notificationSoundMessage record
  , (\_v1741 -> P.Just (17, ("notificationSoundGroup",T.TString $ E.encodeUtf8 _v1741))) $ settings_notificationSoundGroup record
  , (\_v1741 -> P.Just (18, ("notificationDisabledWithSub",T.TBool _v1741))) $ settings_notificationDisabledWithSub record
  , (\_v1741 -> P.Just (20, ("privacySyncContacts",T.TBool _v1741))) $ settings_privacySyncContacts record
  , (\_v1741 -> P.Just (21, ("privacySearchByPhoneNumber",T.TBool _v1741))) $ settings_privacySearchByPhoneNumber record
  , (\_v1741 -> P.Just (22, ("privacySearchByUserid",T.TBool _v1741))) $ settings_privacySearchByUserid record
  , (\_v1741 -> P.Just (23, ("privacySearchByEmail",T.TBool _v1741))) $ settings_privacySearchByEmail record
  , (\_v1741 -> P.Just (24, ("privacyAllowSecondaryDeviceLogin",T.TBool _v1741))) $ settings_privacyAllowSecondaryDeviceLogin record
  , (\_v1741 -> P.Just (25, ("privacyProfileImagePostToMyhome",T.TBool _v1741))) $ settings_privacyProfileImagePostToMyhome record
  , (\_v1741 -> P.Just (26, ("privacyReceiveMessagesFromNotFriend",T.TBool _v1741))) $ settings_privacyReceiveMessagesFromNotFriend record
  , (\_v1741 -> P.Just (30, ("contactMyTicket",T.TString $ E.encodeUtf8 _v1741))) $ settings_contactMyTicket record
  , (\_v1741 -> P.Just (40, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v1741))) $ settings_identityProvider record
  , (\_v1741 -> P.Just (41, ("identityIdentifier",T.TString $ E.encodeUtf8 _v1741))) $ settings_identityIdentifier record
  , (\_v1741 -> P.Just (42, ("snsAccounts",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k1742,_v1743) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k1742, T.TString $ E.encodeUtf8 _v1743)) $ Map.toList _v1741))) $ settings_snsAccounts record
  , (\_v1741 -> P.Just (43, ("phoneRegistration",T.TBool _v1741))) $ settings_phoneRegistration record
  , (\_v1741 -> P.Just (44, ("emailConfirmationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v1741))) $ settings_emailConfirmationStatus record
  , (\_v1741 -> P.Just (50, ("preferenceLocale",T.TString $ E.encodeUtf8 _v1741))) $ settings_preferenceLocale record
  , (\_v1741 -> P.Just (60, ("customModes",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k1744,_v1745) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k1744, T.TString $ E.encodeUtf8 _v1745)) $ Map.toList _v1741))) $ settings_customModes record
  , (\_v1741 -> P.Just (61, ("e2eeEnable",T.TBool _v1741))) $ settings_e2eeEnable record
  , (\_v1741 -> P.Just (62, ("hitokotoBackupRequested",T.TBool _v1741))) $ settings_hitokotoBackupRequested record
  , (\_v1741 -> P.Just (63, ("privacyProfileMusicPostToMyhome",T.TBool _v1741))) $ settings_privacyProfileMusicPostToMyhome record
  , (\_v1741 -> P.Just (65, ("privacyAllowNearby",T.TBool _v1741))) $ settings_privacyAllowNearby record
  , (\_v1741 -> P.Just (66, ("agreementNearbyTime",T.TI64 _v1741))) $ settings_agreementNearbyTime record
  , (\_v1741 -> P.Just (67, ("agreementSquareTime",T.TI64 _v1741))) $ settings_agreementSquareTime record
  , (\_v1741 -> P.Just (68, ("notificationMention",T.TBool _v1741))) $ settings_notificationMention record
  , (\_v1741 -> P.Just (69, ("botUseAgreementAcceptedAt",T.TI64 _v1741))) $ settings_botUseAgreementAcceptedAt record
  ]
write_Settings :: T.Protocol p => p -> Settings -> P.IO ()
write_Settings oprot record = T.writeVal oprot $ from_Settings record
encode_Settings :: T.StatelessProtocol p => p -> Settings -> LBS.ByteString
encode_Settings oprot record = T.serializeVal oprot $ from_Settings record
to_Settings :: T.ThriftVal -> Settings
to_Settings (T.TStruct fields) = Settings{
  settings_notificationEnable = P.maybe (settings_notificationEnable default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1748 -> _val1748; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  settings_notificationMuteExpiration = P.maybe (settings_notificationMuteExpiration default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI64 _val1749 -> _val1749; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  settings_notificationNewMessage = P.maybe (settings_notificationNewMessage default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1750 -> _val1750; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  settings_notificationGroupInvitation = P.maybe (settings_notificationGroupInvitation default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1751 -> _val1751; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  settings_notificationShowMessage = P.maybe (settings_notificationShowMessage default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1752 -> _val1752; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  settings_notificationIncomingCall = P.maybe (settings_notificationIncomingCall default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1753 -> _val1753; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  settings_notificationSoundMessage = P.maybe (settings_notificationSoundMessage default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TString _val1754 -> E.decodeUtf8 _val1754; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  settings_notificationSoundGroup = P.maybe (settings_notificationSoundGroup default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TString _val1755 -> E.decodeUtf8 _val1755; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  settings_notificationDisabledWithSub = P.maybe (settings_notificationDisabledWithSub default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1756 -> _val1756; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  settings_privacySyncContacts = P.maybe (settings_privacySyncContacts default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1757 -> _val1757; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  settings_privacySearchByPhoneNumber = P.maybe (settings_privacySearchByPhoneNumber default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1758 -> _val1758; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  settings_privacySearchByUserid = P.maybe (settings_privacySearchByUserid default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1759 -> _val1759; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  settings_privacySearchByEmail = P.maybe (settings_privacySearchByEmail default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1760 -> _val1760; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  settings_privacyAllowSecondaryDeviceLogin = P.maybe (settings_privacyAllowSecondaryDeviceLogin default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1761 -> _val1761; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  settings_privacyProfileImagePostToMyhome = P.maybe (settings_privacyProfileImagePostToMyhome default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1762 -> _val1762; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  settings_privacyReceiveMessagesFromNotFriend = P.maybe (settings_privacyReceiveMessagesFromNotFriend default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1763 -> _val1763; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  settings_contactMyTicket = P.maybe (settings_contactMyTicket default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TString _val1764 -> E.decodeUtf8 _val1764; _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  settings_identityProvider = P.maybe (settings_identityProvider default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI32 _val1765 -> P.toEnum $ P.fromIntegral _val1765; _ -> P.error "wrong type"})) (Map.lookup (40) fields),
  settings_identityIdentifier = P.maybe (settings_identityIdentifier default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TString _val1766 -> E.decodeUtf8 _val1766; _ -> P.error "wrong type"})) (Map.lookup (41) fields),
  settings_snsAccounts = P.maybe (settings_snsAccounts default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TMap _ _ _val1767 -> (Map.fromList $ P.map (\(_k1769,_v1768) -> ((case _k1769 of {T.TI32 _val1770 -> P.toEnum $ P.fromIntegral _val1770; _ -> P.error "wrong type"}),(case _v1768 of {T.TString _val1771 -> E.decodeUtf8 _val1771; _ -> P.error "wrong type"}))) _val1767); _ -> P.error "wrong type"})) (Map.lookup (42) fields),
  settings_phoneRegistration = P.maybe (settings_phoneRegistration default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1772 -> _val1772; _ -> P.error "wrong type"})) (Map.lookup (43) fields),
  settings_emailConfirmationStatus = P.maybe (settings_emailConfirmationStatus default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI32 _val1773 -> P.toEnum $ P.fromIntegral _val1773; _ -> P.error "wrong type"})) (Map.lookup (44) fields),
  settings_preferenceLocale = P.maybe (settings_preferenceLocale default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TString _val1774 -> E.decodeUtf8 _val1774; _ -> P.error "wrong type"})) (Map.lookup (50) fields),
  settings_customModes = P.maybe (settings_customModes default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TMap _ _ _val1775 -> (Map.fromList $ P.map (\(_k1777,_v1776) -> ((case _k1777 of {T.TI32 _val1778 -> P.toEnum $ P.fromIntegral _val1778; _ -> P.error "wrong type"}),(case _v1776 of {T.TString _val1779 -> E.decodeUtf8 _val1779; _ -> P.error "wrong type"}))) _val1775); _ -> P.error "wrong type"})) (Map.lookup (60) fields),
  settings_e2eeEnable = P.maybe (settings_e2eeEnable default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1780 -> _val1780; _ -> P.error "wrong type"})) (Map.lookup (61) fields),
  settings_hitokotoBackupRequested = P.maybe (settings_hitokotoBackupRequested default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1781 -> _val1781; _ -> P.error "wrong type"})) (Map.lookup (62) fields),
  settings_privacyProfileMusicPostToMyhome = P.maybe (settings_privacyProfileMusicPostToMyhome default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1782 -> _val1782; _ -> P.error "wrong type"})) (Map.lookup (63) fields),
  settings_privacyAllowNearby = P.maybe (settings_privacyAllowNearby default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1783 -> _val1783; _ -> P.error "wrong type"})) (Map.lookup (65) fields),
  settings_agreementNearbyTime = P.maybe (settings_agreementNearbyTime default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI64 _val1784 -> _val1784; _ -> P.error "wrong type"})) (Map.lookup (66) fields),
  settings_agreementSquareTime = P.maybe (settings_agreementSquareTime default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI64 _val1785 -> _val1785; _ -> P.error "wrong type"})) (Map.lookup (67) fields),
  settings_notificationMention = P.maybe (settings_notificationMention default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TBool _val1786 -> _val1786; _ -> P.error "wrong type"})) (Map.lookup (68) fields),
  settings_botUseAgreementAcceptedAt = P.maybe (settings_botUseAgreementAcceptedAt default_Settings) (\(_,_val1747) -> (case _val1747 of {T.TI64 _val1787 -> _val1787; _ -> P.error "wrong type"})) (Map.lookup (69) fields)
  }
to_Settings _ = P.error "not a struct"
read_Settings :: T.Protocol p => p -> P.IO Settings
read_Settings iprot = to_Settings <$> T.readVal iprot (T.T_STRUCT typemap_Settings)
decode_Settings :: T.StatelessProtocol p => p -> LBS.ByteString -> Settings
decode_Settings iprot bs = to_Settings $ T.deserializeVal iprot (T.T_STRUCT typemap_Settings) bs
typemap_Settings :: T.TypeMap
typemap_Settings = Map.fromList [(10,("notificationEnable",T.T_BOOL)),(11,("notificationMuteExpiration",T.T_I64)),(12,("notificationNewMessage",T.T_BOOL)),(13,("notificationGroupInvitation",T.T_BOOL)),(14,("notificationShowMessage",T.T_BOOL)),(15,("notificationIncomingCall",T.T_BOOL)),(16,("notificationSoundMessage",T.T_STRING)),(17,("notificationSoundGroup",T.T_STRING)),(18,("notificationDisabledWithSub",T.T_BOOL)),(20,("privacySyncContacts",T.T_BOOL)),(21,("privacySearchByPhoneNumber",T.T_BOOL)),(22,("privacySearchByUserid",T.T_BOOL)),(23,("privacySearchByEmail",T.T_BOOL)),(24,("privacyAllowSecondaryDeviceLogin",T.T_BOOL)),(25,("privacyProfileImagePostToMyhome",T.T_BOOL)),(26,("privacyReceiveMessagesFromNotFriend",T.T_BOOL)),(30,("contactMyTicket",T.T_STRING)),(40,("identityProvider",T.T_I32)),(41,("identityIdentifier",T.T_STRING)),(42,("snsAccounts",(T.T_MAP T.T_I32 T.T_STRING))),(43,("phoneRegistration",T.T_BOOL)),(44,("emailConfirmationStatus",T.T_I32)),(50,("preferenceLocale",T.T_STRING)),(60,("customModes",(T.T_MAP T.T_I32 T.T_STRING))),(61,("e2eeEnable",T.T_BOOL)),(62,("hitokotoBackupRequested",T.T_BOOL)),(63,("privacyProfileMusicPostToMyhome",T.T_BOOL)),(65,("privacyAllowNearby",T.T_BOOL)),(66,("agreementNearbyTime",T.T_I64)),(67,("agreementSquareTime",T.T_I64)),(68,("notificationMention",T.T_BOOL)),(69,("botUseAgreementAcceptedAt",T.T_I64))]
default_Settings :: Settings
default_Settings = Settings{
  settings_notificationEnable = P.False,
  settings_notificationMuteExpiration = 0,
  settings_notificationNewMessage = P.False,
  settings_notificationGroupInvitation = P.False,
  settings_notificationShowMessage = P.False,
  settings_notificationIncomingCall = P.False,
  settings_notificationSoundMessage = "",
  settings_notificationSoundGroup = "",
  settings_notificationDisabledWithSub = P.False,
  settings_privacySyncContacts = P.False,
  settings_privacySearchByPhoneNumber = P.False,
  settings_privacySearchByUserid = P.False,
  settings_privacySearchByEmail = P.False,
  settings_privacyAllowSecondaryDeviceLogin = P.False,
  settings_privacyProfileImagePostToMyhome = P.False,
  settings_privacyReceiveMessagesFromNotFriend = P.False,
  settings_contactMyTicket = "",
  settings_identityProvider = (P.toEnum 0),
  settings_identityIdentifier = "",
  settings_snsAccounts = Map.empty,
  settings_phoneRegistration = P.False,
  settings_emailConfirmationStatus = (P.toEnum 0),
  settings_preferenceLocale = "",
  settings_customModes = Map.empty,
  settings_e2eeEnable = P.False,
  settings_hitokotoBackupRequested = P.False,
  settings_privacyProfileMusicPostToMyhome = P.False,
  settings_privacyAllowNearby = P.False,
  settings_agreementNearbyTime = 0,
  settings_agreementSquareTime = 0,
  settings_notificationMention = P.False,
  settings_botUseAgreementAcceptedAt = 0}
data SimpleChannelClient = SimpleChannelClient  { simpleChannelClient_applicationType :: LT.Text
  , simpleChannelClient_applicationVersion :: LT.Text
  , simpleChannelClient_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SimpleChannelClient where
  hashWithSalt salt record = salt   `H.hashWithSalt` simpleChannelClient_applicationType record   `H.hashWithSalt` simpleChannelClient_applicationVersion record   `H.hashWithSalt` simpleChannelClient_locale record  
instance QC.Arbitrary SimpleChannelClient where 
  arbitrary = M.liftM SimpleChannelClient (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SimpleChannelClient = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SimpleChannelClient{simpleChannelClient_applicationType = simpleChannelClient_applicationType obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_applicationType = simpleChannelClient_applicationType obj}
    , if obj == default_SimpleChannelClient{simpleChannelClient_applicationVersion = simpleChannelClient_applicationVersion obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_applicationVersion = simpleChannelClient_applicationVersion obj}
    , if obj == default_SimpleChannelClient{simpleChannelClient_locale = simpleChannelClient_locale obj} then P.Nothing else P.Just $ default_SimpleChannelClient{simpleChannelClient_locale = simpleChannelClient_locale obj}
    ]
from_SimpleChannelClient :: SimpleChannelClient -> T.ThriftVal
from_SimpleChannelClient record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1790 -> P.Just (1, ("applicationType",T.TString $ E.encodeUtf8 _v1790))) $ simpleChannelClient_applicationType record
  , (\_v1790 -> P.Just (2, ("applicationVersion",T.TString $ E.encodeUtf8 _v1790))) $ simpleChannelClient_applicationVersion record
  , (\_v1790 -> P.Just (3, ("locale",T.TString $ E.encodeUtf8 _v1790))) $ simpleChannelClient_locale record
  ]
write_SimpleChannelClient :: T.Protocol p => p -> SimpleChannelClient -> P.IO ()
write_SimpleChannelClient oprot record = T.writeVal oprot $ from_SimpleChannelClient record
encode_SimpleChannelClient :: T.StatelessProtocol p => p -> SimpleChannelClient -> LBS.ByteString
encode_SimpleChannelClient oprot record = T.serializeVal oprot $ from_SimpleChannelClient record
to_SimpleChannelClient :: T.ThriftVal -> SimpleChannelClient
to_SimpleChannelClient (T.TStruct fields) = SimpleChannelClient{
  simpleChannelClient_applicationType = P.maybe (simpleChannelClient_applicationType default_SimpleChannelClient) (\(_,_val1792) -> (case _val1792 of {T.TString _val1793 -> E.decodeUtf8 _val1793; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  simpleChannelClient_applicationVersion = P.maybe (simpleChannelClient_applicationVersion default_SimpleChannelClient) (\(_,_val1792) -> (case _val1792 of {T.TString _val1794 -> E.decodeUtf8 _val1794; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  simpleChannelClient_locale = P.maybe (simpleChannelClient_locale default_SimpleChannelClient) (\(_,_val1792) -> (case _val1792 of {T.TString _val1795 -> E.decodeUtf8 _val1795; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SimpleChannelClient _ = P.error "not a struct"
read_SimpleChannelClient :: T.Protocol p => p -> P.IO SimpleChannelClient
read_SimpleChannelClient iprot = to_SimpleChannelClient <$> T.readVal iprot (T.T_STRUCT typemap_SimpleChannelClient)
decode_SimpleChannelClient :: T.StatelessProtocol p => p -> LBS.ByteString -> SimpleChannelClient
decode_SimpleChannelClient iprot bs = to_SimpleChannelClient $ T.deserializeVal iprot (T.T_STRUCT typemap_SimpleChannelClient) bs
typemap_SimpleChannelClient :: T.TypeMap
typemap_SimpleChannelClient = Map.fromList [(1,("applicationType",T.T_STRING)),(2,("applicationVersion",T.T_STRING)),(3,("locale",T.T_STRING))]
default_SimpleChannelClient :: SimpleChannelClient
default_SimpleChannelClient = SimpleChannelClient{
  simpleChannelClient_applicationType = "",
  simpleChannelClient_applicationVersion = "",
  simpleChannelClient_locale = ""}
data SimpleChannelContact = SimpleChannelContact  { simpleChannelContact_mid :: LT.Text
  , simpleChannelContact_displayName :: LT.Text
  , simpleChannelContact_pictureStatus :: LT.Text
  , simpleChannelContact_picturePath :: LT.Text
  , simpleChannelContact_statusMessage :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SimpleChannelContact where
  hashWithSalt salt record = salt   `H.hashWithSalt` simpleChannelContact_mid record   `H.hashWithSalt` simpleChannelContact_displayName record   `H.hashWithSalt` simpleChannelContact_pictureStatus record   `H.hashWithSalt` simpleChannelContact_picturePath record   `H.hashWithSalt` simpleChannelContact_statusMessage record  
instance QC.Arbitrary SimpleChannelContact where 
  arbitrary = M.liftM SimpleChannelContact (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SimpleChannelContact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SimpleChannelContact{simpleChannelContact_mid = simpleChannelContact_mid obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_mid = simpleChannelContact_mid obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_displayName = simpleChannelContact_displayName obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_displayName = simpleChannelContact_displayName obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_pictureStatus = simpleChannelContact_pictureStatus obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_pictureStatus = simpleChannelContact_pictureStatus obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_picturePath = simpleChannelContact_picturePath obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_picturePath = simpleChannelContact_picturePath obj}
    , if obj == default_SimpleChannelContact{simpleChannelContact_statusMessage = simpleChannelContact_statusMessage obj} then P.Nothing else P.Just $ default_SimpleChannelContact{simpleChannelContact_statusMessage = simpleChannelContact_statusMessage obj}
    ]
from_SimpleChannelContact :: SimpleChannelContact -> T.ThriftVal
from_SimpleChannelContact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1798 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v1798))) $ simpleChannelContact_mid record
  , (\_v1798 -> P.Just (2, ("displayName",T.TString $ E.encodeUtf8 _v1798))) $ simpleChannelContact_displayName record
  , (\_v1798 -> P.Just (3, ("pictureStatus",T.TString $ E.encodeUtf8 _v1798))) $ simpleChannelContact_pictureStatus record
  , (\_v1798 -> P.Just (4, ("picturePath",T.TString $ E.encodeUtf8 _v1798))) $ simpleChannelContact_picturePath record
  , (\_v1798 -> P.Just (5, ("statusMessage",T.TString $ E.encodeUtf8 _v1798))) $ simpleChannelContact_statusMessage record
  ]
write_SimpleChannelContact :: T.Protocol p => p -> SimpleChannelContact -> P.IO ()
write_SimpleChannelContact oprot record = T.writeVal oprot $ from_SimpleChannelContact record
encode_SimpleChannelContact :: T.StatelessProtocol p => p -> SimpleChannelContact -> LBS.ByteString
encode_SimpleChannelContact oprot record = T.serializeVal oprot $ from_SimpleChannelContact record
to_SimpleChannelContact :: T.ThriftVal -> SimpleChannelContact
to_SimpleChannelContact (T.TStruct fields) = SimpleChannelContact{
  simpleChannelContact_mid = P.maybe (simpleChannelContact_mid default_SimpleChannelContact) (\(_,_val1800) -> (case _val1800 of {T.TString _val1801 -> E.decodeUtf8 _val1801; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  simpleChannelContact_displayName = P.maybe (simpleChannelContact_displayName default_SimpleChannelContact) (\(_,_val1800) -> (case _val1800 of {T.TString _val1802 -> E.decodeUtf8 _val1802; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  simpleChannelContact_pictureStatus = P.maybe (simpleChannelContact_pictureStatus default_SimpleChannelContact) (\(_,_val1800) -> (case _val1800 of {T.TString _val1803 -> E.decodeUtf8 _val1803; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  simpleChannelContact_picturePath = P.maybe (simpleChannelContact_picturePath default_SimpleChannelContact) (\(_,_val1800) -> (case _val1800 of {T.TString _val1804 -> E.decodeUtf8 _val1804; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  simpleChannelContact_statusMessage = P.maybe (simpleChannelContact_statusMessage default_SimpleChannelContact) (\(_,_val1800) -> (case _val1800 of {T.TString _val1805 -> E.decodeUtf8 _val1805; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SimpleChannelContact _ = P.error "not a struct"
read_SimpleChannelContact :: T.Protocol p => p -> P.IO SimpleChannelContact
read_SimpleChannelContact iprot = to_SimpleChannelContact <$> T.readVal iprot (T.T_STRUCT typemap_SimpleChannelContact)
decode_SimpleChannelContact :: T.StatelessProtocol p => p -> LBS.ByteString -> SimpleChannelContact
decode_SimpleChannelContact iprot bs = to_SimpleChannelContact $ T.deserializeVal iprot (T.T_STRUCT typemap_SimpleChannelContact) bs
typemap_SimpleChannelContact :: T.TypeMap
typemap_SimpleChannelContact = Map.fromList [(1,("mid",T.T_STRING)),(2,("displayName",T.T_STRING)),(3,("pictureStatus",T.T_STRING)),(4,("picturePath",T.T_STRING)),(5,("statusMessage",T.T_STRING))]
default_SimpleChannelContact :: SimpleChannelContact
default_SimpleChannelContact = SimpleChannelContact{
  simpleChannelContact_mid = "",
  simpleChannelContact_displayName = "",
  simpleChannelContact_pictureStatus = "",
  simpleChannelContact_picturePath = "",
  simpleChannelContact_statusMessage = ""}
data SnsFriend = SnsFriend  { snsFriend_snsUserId :: LT.Text
  , snsFriend_snsUserName :: LT.Text
  , snsFriend_snsIdType :: SnsIdType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriend where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriend_snsUserId record   `H.hashWithSalt` snsFriend_snsUserName record   `H.hashWithSalt` snsFriend_snsIdType record  
instance QC.Arbitrary SnsFriend where 
  arbitrary = M.liftM SnsFriend (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriend = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriend{snsFriend_snsUserId = snsFriend_snsUserId obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsUserId = snsFriend_snsUserId obj}
    , if obj == default_SnsFriend{snsFriend_snsUserName = snsFriend_snsUserName obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsUserName = snsFriend_snsUserName obj}
    , if obj == default_SnsFriend{snsFriend_snsIdType = snsFriend_snsIdType obj} then P.Nothing else P.Just $ default_SnsFriend{snsFriend_snsIdType = snsFriend_snsIdType obj}
    ]
from_SnsFriend :: SnsFriend -> T.ThriftVal
from_SnsFriend record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1808 -> P.Just (1, ("snsUserId",T.TString $ E.encodeUtf8 _v1808))) $ snsFriend_snsUserId record
  , (\_v1808 -> P.Just (2, ("snsUserName",T.TString $ E.encodeUtf8 _v1808))) $ snsFriend_snsUserName record
  , (\_v1808 -> P.Just (3, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1808))) $ snsFriend_snsIdType record
  ]
write_SnsFriend :: T.Protocol p => p -> SnsFriend -> P.IO ()
write_SnsFriend oprot record = T.writeVal oprot $ from_SnsFriend record
encode_SnsFriend :: T.StatelessProtocol p => p -> SnsFriend -> LBS.ByteString
encode_SnsFriend oprot record = T.serializeVal oprot $ from_SnsFriend record
to_SnsFriend :: T.ThriftVal -> SnsFriend
to_SnsFriend (T.TStruct fields) = SnsFriend{
  snsFriend_snsUserId = P.maybe (snsFriend_snsUserId default_SnsFriend) (\(_,_val1810) -> (case _val1810 of {T.TString _val1811 -> E.decodeUtf8 _val1811; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriend_snsUserName = P.maybe (snsFriend_snsUserName default_SnsFriend) (\(_,_val1810) -> (case _val1810 of {T.TString _val1812 -> E.decodeUtf8 _val1812; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsFriend_snsIdType = P.maybe (snsFriend_snsIdType default_SnsFriend) (\(_,_val1810) -> (case _val1810 of {T.TI32 _val1813 -> P.toEnum $ P.fromIntegral _val1813; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsFriend _ = P.error "not a struct"
read_SnsFriend :: T.Protocol p => p -> P.IO SnsFriend
read_SnsFriend iprot = to_SnsFriend <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriend)
decode_SnsFriend :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriend
decode_SnsFriend iprot bs = to_SnsFriend $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriend) bs
typemap_SnsFriend :: T.TypeMap
typemap_SnsFriend = Map.fromList [(1,("snsUserId",T.T_STRING)),(2,("snsUserName",T.T_STRING)),(3,("snsIdType",T.T_I32))]
default_SnsFriend :: SnsFriend
default_SnsFriend = SnsFriend{
  snsFriend_snsUserId = "",
  snsFriend_snsUserName = "",
  snsFriend_snsIdType = (P.toEnum 0)}
data SnsFriendContactRegistration = SnsFriendContactRegistration  { snsFriendContactRegistration_contact :: Contact
  , snsFriendContactRegistration_snsIdType :: SnsIdType
  , snsFriendContactRegistration_snsUserId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriendContactRegistration where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriendContactRegistration_contact record   `H.hashWithSalt` snsFriendContactRegistration_snsIdType record   `H.hashWithSalt` snsFriendContactRegistration_snsUserId record  
instance QC.Arbitrary SnsFriendContactRegistration where 
  arbitrary = M.liftM SnsFriendContactRegistration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriendContactRegistration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_contact = snsFriendContactRegistration_contact obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_contact = snsFriendContactRegistration_contact obj}
    , if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_snsIdType = snsFriendContactRegistration_snsIdType obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_snsIdType = snsFriendContactRegistration_snsIdType obj}
    , if obj == default_SnsFriendContactRegistration{snsFriendContactRegistration_snsUserId = snsFriendContactRegistration_snsUserId obj} then P.Nothing else P.Just $ default_SnsFriendContactRegistration{snsFriendContactRegistration_snsUserId = snsFriendContactRegistration_snsUserId obj}
    ]
from_SnsFriendContactRegistration :: SnsFriendContactRegistration -> T.ThriftVal
from_SnsFriendContactRegistration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1816 -> P.Just (1, ("contact",from_Contact _v1816))) $ snsFriendContactRegistration_contact record
  , (\_v1816 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1816))) $ snsFriendContactRegistration_snsIdType record
  , (\_v1816 -> P.Just (3, ("snsUserId",T.TString $ E.encodeUtf8 _v1816))) $ snsFriendContactRegistration_snsUserId record
  ]
write_SnsFriendContactRegistration :: T.Protocol p => p -> SnsFriendContactRegistration -> P.IO ()
write_SnsFriendContactRegistration oprot record = T.writeVal oprot $ from_SnsFriendContactRegistration record
encode_SnsFriendContactRegistration :: T.StatelessProtocol p => p -> SnsFriendContactRegistration -> LBS.ByteString
encode_SnsFriendContactRegistration oprot record = T.serializeVal oprot $ from_SnsFriendContactRegistration record
to_SnsFriendContactRegistration :: T.ThriftVal -> SnsFriendContactRegistration
to_SnsFriendContactRegistration (T.TStruct fields) = SnsFriendContactRegistration{
  snsFriendContactRegistration_contact = P.maybe (snsFriendContactRegistration_contact default_SnsFriendContactRegistration) (\(_,_val1818) -> (case _val1818 of {T.TStruct _val1819 -> (to_Contact (T.TStruct _val1819)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriendContactRegistration_snsIdType = P.maybe (snsFriendContactRegistration_snsIdType default_SnsFriendContactRegistration) (\(_,_val1818) -> (case _val1818 of {T.TI32 _val1820 -> P.toEnum $ P.fromIntegral _val1820; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsFriendContactRegistration_snsUserId = P.maybe (snsFriendContactRegistration_snsUserId default_SnsFriendContactRegistration) (\(_,_val1818) -> (case _val1818 of {T.TString _val1821 -> E.decodeUtf8 _val1821; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsFriendContactRegistration _ = P.error "not a struct"
read_SnsFriendContactRegistration :: T.Protocol p => p -> P.IO SnsFriendContactRegistration
read_SnsFriendContactRegistration iprot = to_SnsFriendContactRegistration <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriendContactRegistration)
decode_SnsFriendContactRegistration :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriendContactRegistration
decode_SnsFriendContactRegistration iprot bs = to_SnsFriendContactRegistration $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriendContactRegistration) bs
typemap_SnsFriendContactRegistration :: T.TypeMap
typemap_SnsFriendContactRegistration = Map.fromList [(1,("contact",(T.T_STRUCT typemap_Contact))),(2,("snsIdType",T.T_I32)),(3,("snsUserId",T.T_STRING))]
default_SnsFriendContactRegistration :: SnsFriendContactRegistration
default_SnsFriendContactRegistration = SnsFriendContactRegistration{
  snsFriendContactRegistration_contact = default_Contact,
  snsFriendContactRegistration_snsIdType = (P.toEnum 0),
  snsFriendContactRegistration_snsUserId = ""}
data SnsFriendModification = SnsFriendModification  { snsFriendModification_type :: ModificationType
  , snsFriendModification_snsFriend :: SnsFriend
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriendModification where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriendModification_type record   `H.hashWithSalt` snsFriendModification_snsFriend record  
instance QC.Arbitrary SnsFriendModification where 
  arbitrary = M.liftM SnsFriendModification (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriendModification = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriendModification{snsFriendModification_type = snsFriendModification_type obj} then P.Nothing else P.Just $ default_SnsFriendModification{snsFriendModification_type = snsFriendModification_type obj}
    , if obj == default_SnsFriendModification{snsFriendModification_snsFriend = snsFriendModification_snsFriend obj} then P.Nothing else P.Just $ default_SnsFriendModification{snsFriendModification_snsFriend = snsFriendModification_snsFriend obj}
    ]
from_SnsFriendModification :: SnsFriendModification -> T.ThriftVal
from_SnsFriendModification record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1824 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1824))) $ snsFriendModification_type record
  , (\_v1824 -> P.Just (2, ("snsFriend",from_SnsFriend _v1824))) $ snsFriendModification_snsFriend record
  ]
write_SnsFriendModification :: T.Protocol p => p -> SnsFriendModification -> P.IO ()
write_SnsFriendModification oprot record = T.writeVal oprot $ from_SnsFriendModification record
encode_SnsFriendModification :: T.StatelessProtocol p => p -> SnsFriendModification -> LBS.ByteString
encode_SnsFriendModification oprot record = T.serializeVal oprot $ from_SnsFriendModification record
to_SnsFriendModification :: T.ThriftVal -> SnsFriendModification
to_SnsFriendModification (T.TStruct fields) = SnsFriendModification{
  snsFriendModification_type = P.maybe (snsFriendModification_type default_SnsFriendModification) (\(_,_val1826) -> (case _val1826 of {T.TI32 _val1827 -> P.toEnum $ P.fromIntegral _val1827; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriendModification_snsFriend = P.maybe (snsFriendModification_snsFriend default_SnsFriendModification) (\(_,_val1826) -> (case _val1826 of {T.TStruct _val1828 -> (to_SnsFriend (T.TStruct _val1828)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SnsFriendModification _ = P.error "not a struct"
read_SnsFriendModification :: T.Protocol p => p -> P.IO SnsFriendModification
read_SnsFriendModification iprot = to_SnsFriendModification <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriendModification)
decode_SnsFriendModification :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriendModification
decode_SnsFriendModification iprot bs = to_SnsFriendModification $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriendModification) bs
typemap_SnsFriendModification :: T.TypeMap
typemap_SnsFriendModification = Map.fromList [(1,("type",T.T_I32)),(2,("snsFriend",(T.T_STRUCT typemap_SnsFriend)))]
default_SnsFriendModification :: SnsFriendModification
default_SnsFriendModification = SnsFriendModification{
  snsFriendModification_type = (P.toEnum 0),
  snsFriendModification_snsFriend = default_SnsFriend}
data SnsFriends = SnsFriends  { snsFriends_snsFriends :: (Vector.Vector SnsFriend)
  , snsFriends_hasMore :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsFriends where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsFriends_snsFriends record   `H.hashWithSalt` snsFriends_hasMore record  
instance QC.Arbitrary SnsFriends where 
  arbitrary = M.liftM SnsFriends (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsFriends = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsFriends{snsFriends_snsFriends = snsFriends_snsFriends obj} then P.Nothing else P.Just $ default_SnsFriends{snsFriends_snsFriends = snsFriends_snsFriends obj}
    , if obj == default_SnsFriends{snsFriends_hasMore = snsFriends_hasMore obj} then P.Nothing else P.Just $ default_SnsFriends{snsFriends_hasMore = snsFriends_hasMore obj}
    ]
from_SnsFriends :: SnsFriends -> T.ThriftVal
from_SnsFriends record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1831 -> P.Just (1, ("snsFriends",T.TList (T.T_STRUCT typemap_SnsFriend) $ P.map (\_v1833 -> from_SnsFriend _v1833) $ Vector.toList _v1831))) $ snsFriends_snsFriends record
  , (\_v1831 -> P.Just (2, ("hasMore",T.TBool _v1831))) $ snsFriends_hasMore record
  ]
write_SnsFriends :: T.Protocol p => p -> SnsFriends -> P.IO ()
write_SnsFriends oprot record = T.writeVal oprot $ from_SnsFriends record
encode_SnsFriends :: T.StatelessProtocol p => p -> SnsFriends -> LBS.ByteString
encode_SnsFriends oprot record = T.serializeVal oprot $ from_SnsFriends record
to_SnsFriends :: T.ThriftVal -> SnsFriends
to_SnsFriends (T.TStruct fields) = SnsFriends{
  snsFriends_snsFriends = P.maybe (snsFriends_snsFriends default_SnsFriends) (\(_,_val1835) -> (case _val1835 of {T.TList _ _val1836 -> (Vector.fromList $ P.map (\_v1837 -> (case _v1837 of {T.TStruct _val1838 -> (to_SnsFriend (T.TStruct _val1838)); _ -> P.error "wrong type"})) _val1836); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsFriends_hasMore = P.maybe (snsFriends_hasMore default_SnsFriends) (\(_,_val1835) -> (case _val1835 of {T.TBool _val1839 -> _val1839; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SnsFriends _ = P.error "not a struct"
read_SnsFriends :: T.Protocol p => p -> P.IO SnsFriends
read_SnsFriends iprot = to_SnsFriends <$> T.readVal iprot (T.T_STRUCT typemap_SnsFriends)
decode_SnsFriends :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsFriends
decode_SnsFriends iprot bs = to_SnsFriends $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsFriends) bs
typemap_SnsFriends :: T.TypeMap
typemap_SnsFriends = Map.fromList [(1,("snsFriends",(T.T_LIST (T.T_STRUCT typemap_SnsFriend)))),(2,("hasMore",T.T_BOOL))]
default_SnsFriends :: SnsFriends
default_SnsFriends = SnsFriends{
  snsFriends_snsFriends = Vector.empty,
  snsFriends_hasMore = P.False}
data SnsIdUserStatus = SnsIdUserStatus  { snsIdUserStatus_userExisting :: P.Bool
  , snsIdUserStatus_phoneNumberRegistered :: P.Bool
  , snsIdUserStatus_sameDevice :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsIdUserStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsIdUserStatus_userExisting record   `H.hashWithSalt` snsIdUserStatus_phoneNumberRegistered record   `H.hashWithSalt` snsIdUserStatus_sameDevice record  
instance QC.Arbitrary SnsIdUserStatus where 
  arbitrary = M.liftM SnsIdUserStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsIdUserStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsIdUserStatus{snsIdUserStatus_userExisting = snsIdUserStatus_userExisting obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_userExisting = snsIdUserStatus_userExisting obj}
    , if obj == default_SnsIdUserStatus{snsIdUserStatus_phoneNumberRegistered = snsIdUserStatus_phoneNumberRegistered obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_phoneNumberRegistered = snsIdUserStatus_phoneNumberRegistered obj}
    , if obj == default_SnsIdUserStatus{snsIdUserStatus_sameDevice = snsIdUserStatus_sameDevice obj} then P.Nothing else P.Just $ default_SnsIdUserStatus{snsIdUserStatus_sameDevice = snsIdUserStatus_sameDevice obj}
    ]
from_SnsIdUserStatus :: SnsIdUserStatus -> T.ThriftVal
from_SnsIdUserStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1842 -> P.Just (1, ("userExisting",T.TBool _v1842))) $ snsIdUserStatus_userExisting record
  , (\_v1842 -> P.Just (2, ("phoneNumberRegistered",T.TBool _v1842))) $ snsIdUserStatus_phoneNumberRegistered record
  , (\_v1842 -> P.Just (3, ("sameDevice",T.TBool _v1842))) $ snsIdUserStatus_sameDevice record
  ]
write_SnsIdUserStatus :: T.Protocol p => p -> SnsIdUserStatus -> P.IO ()
write_SnsIdUserStatus oprot record = T.writeVal oprot $ from_SnsIdUserStatus record
encode_SnsIdUserStatus :: T.StatelessProtocol p => p -> SnsIdUserStatus -> LBS.ByteString
encode_SnsIdUserStatus oprot record = T.serializeVal oprot $ from_SnsIdUserStatus record
to_SnsIdUserStatus :: T.ThriftVal -> SnsIdUserStatus
to_SnsIdUserStatus (T.TStruct fields) = SnsIdUserStatus{
  snsIdUserStatus_userExisting = P.maybe (snsIdUserStatus_userExisting default_SnsIdUserStatus) (\(_,_val1844) -> (case _val1844 of {T.TBool _val1845 -> _val1845; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsIdUserStatus_phoneNumberRegistered = P.maybe (snsIdUserStatus_phoneNumberRegistered default_SnsIdUserStatus) (\(_,_val1844) -> (case _val1844 of {T.TBool _val1846 -> _val1846; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsIdUserStatus_sameDevice = P.maybe (snsIdUserStatus_sameDevice default_SnsIdUserStatus) (\(_,_val1844) -> (case _val1844 of {T.TBool _val1847 -> _val1847; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SnsIdUserStatus _ = P.error "not a struct"
read_SnsIdUserStatus :: T.Protocol p => p -> P.IO SnsIdUserStatus
read_SnsIdUserStatus iprot = to_SnsIdUserStatus <$> T.readVal iprot (T.T_STRUCT typemap_SnsIdUserStatus)
decode_SnsIdUserStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsIdUserStatus
decode_SnsIdUserStatus iprot bs = to_SnsIdUserStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsIdUserStatus) bs
typemap_SnsIdUserStatus :: T.TypeMap
typemap_SnsIdUserStatus = Map.fromList [(1,("userExisting",T.T_BOOL)),(2,("phoneNumberRegistered",T.T_BOOL)),(3,("sameDevice",T.T_BOOL))]
default_SnsIdUserStatus :: SnsIdUserStatus
default_SnsIdUserStatus = SnsIdUserStatus{
  snsIdUserStatus_userExisting = P.False,
  snsIdUserStatus_phoneNumberRegistered = P.False,
  snsIdUserStatus_sameDevice = P.False}
data SnsProfile = SnsProfile  { snsProfile_snsUserId :: LT.Text
  , snsProfile_snsUserName :: LT.Text
  , snsProfile_email :: LT.Text
  , snsProfile_thumbnailUrl :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SnsProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` snsProfile_snsUserId record   `H.hashWithSalt` snsProfile_snsUserName record   `H.hashWithSalt` snsProfile_email record   `H.hashWithSalt` snsProfile_thumbnailUrl record  
instance QC.Arbitrary SnsProfile where 
  arbitrary = M.liftM SnsProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SnsProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SnsProfile{snsProfile_snsUserId = snsProfile_snsUserId obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_snsUserId = snsProfile_snsUserId obj}
    , if obj == default_SnsProfile{snsProfile_snsUserName = snsProfile_snsUserName obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_snsUserName = snsProfile_snsUserName obj}
    , if obj == default_SnsProfile{snsProfile_email = snsProfile_email obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_email = snsProfile_email obj}
    , if obj == default_SnsProfile{snsProfile_thumbnailUrl = snsProfile_thumbnailUrl obj} then P.Nothing else P.Just $ default_SnsProfile{snsProfile_thumbnailUrl = snsProfile_thumbnailUrl obj}
    ]
from_SnsProfile :: SnsProfile -> T.ThriftVal
from_SnsProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1850 -> P.Just (1, ("snsUserId",T.TString $ E.encodeUtf8 _v1850))) $ snsProfile_snsUserId record
  , (\_v1850 -> P.Just (2, ("snsUserName",T.TString $ E.encodeUtf8 _v1850))) $ snsProfile_snsUserName record
  , (\_v1850 -> P.Just (3, ("email",T.TString $ E.encodeUtf8 _v1850))) $ snsProfile_email record
  , (\_v1850 -> P.Just (4, ("thumbnailUrl",T.TString $ E.encodeUtf8 _v1850))) $ snsProfile_thumbnailUrl record
  ]
write_SnsProfile :: T.Protocol p => p -> SnsProfile -> P.IO ()
write_SnsProfile oprot record = T.writeVal oprot $ from_SnsProfile record
encode_SnsProfile :: T.StatelessProtocol p => p -> SnsProfile -> LBS.ByteString
encode_SnsProfile oprot record = T.serializeVal oprot $ from_SnsProfile record
to_SnsProfile :: T.ThriftVal -> SnsProfile
to_SnsProfile (T.TStruct fields) = SnsProfile{
  snsProfile_snsUserId = P.maybe (snsProfile_snsUserId default_SnsProfile) (\(_,_val1852) -> (case _val1852 of {T.TString _val1853 -> E.decodeUtf8 _val1853; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  snsProfile_snsUserName = P.maybe (snsProfile_snsUserName default_SnsProfile) (\(_,_val1852) -> (case _val1852 of {T.TString _val1854 -> E.decodeUtf8 _val1854; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  snsProfile_email = P.maybe (snsProfile_email default_SnsProfile) (\(_,_val1852) -> (case _val1852 of {T.TString _val1855 -> E.decodeUtf8 _val1855; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  snsProfile_thumbnailUrl = P.maybe (snsProfile_thumbnailUrl default_SnsProfile) (\(_,_val1852) -> (case _val1852 of {T.TString _val1856 -> E.decodeUtf8 _val1856; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SnsProfile _ = P.error "not a struct"
read_SnsProfile :: T.Protocol p => p -> P.IO SnsProfile
read_SnsProfile iprot = to_SnsProfile <$> T.readVal iprot (T.T_STRUCT typemap_SnsProfile)
decode_SnsProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> SnsProfile
decode_SnsProfile iprot bs = to_SnsProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_SnsProfile) bs
typemap_SnsProfile :: T.TypeMap
typemap_SnsProfile = Map.fromList [(1,("snsUserId",T.T_STRING)),(2,("snsUserName",T.T_STRING)),(3,("email",T.T_STRING)),(4,("thumbnailUrl",T.T_STRING))]
default_SnsProfile :: SnsProfile
default_SnsProfile = SnsProfile{
  snsProfile_snsUserId = "",
  snsProfile_snsUserName = "",
  snsProfile_email = "",
  snsProfile_thumbnailUrl = ""}
data SystemConfiguration = SystemConfiguration  { systemConfiguration_endpoint :: LT.Text
  , systemConfiguration_endpointSsl :: LT.Text
  , systemConfiguration_updateUrl :: LT.Text
  , systemConfiguration_c2dmAccount :: LT.Text
  , systemConfiguration_nniServer :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SystemConfiguration where
  hashWithSalt salt record = salt   `H.hashWithSalt` systemConfiguration_endpoint record   `H.hashWithSalt` systemConfiguration_endpointSsl record   `H.hashWithSalt` systemConfiguration_updateUrl record   `H.hashWithSalt` systemConfiguration_c2dmAccount record   `H.hashWithSalt` systemConfiguration_nniServer record  
instance QC.Arbitrary SystemConfiguration where 
  arbitrary = M.liftM SystemConfiguration (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SystemConfiguration = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SystemConfiguration{systemConfiguration_endpoint = systemConfiguration_endpoint obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_endpoint = systemConfiguration_endpoint obj}
    , if obj == default_SystemConfiguration{systemConfiguration_endpointSsl = systemConfiguration_endpointSsl obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_endpointSsl = systemConfiguration_endpointSsl obj}
    , if obj == default_SystemConfiguration{systemConfiguration_updateUrl = systemConfiguration_updateUrl obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_updateUrl = systemConfiguration_updateUrl obj}
    , if obj == default_SystemConfiguration{systemConfiguration_c2dmAccount = systemConfiguration_c2dmAccount obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_c2dmAccount = systemConfiguration_c2dmAccount obj}
    , if obj == default_SystemConfiguration{systemConfiguration_nniServer = systemConfiguration_nniServer obj} then P.Nothing else P.Just $ default_SystemConfiguration{systemConfiguration_nniServer = systemConfiguration_nniServer obj}
    ]
from_SystemConfiguration :: SystemConfiguration -> T.ThriftVal
from_SystemConfiguration record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1859 -> P.Just (1, ("endpoint",T.TString $ E.encodeUtf8 _v1859))) $ systemConfiguration_endpoint record
  , (\_v1859 -> P.Just (2, ("endpointSsl",T.TString $ E.encodeUtf8 _v1859))) $ systemConfiguration_endpointSsl record
  , (\_v1859 -> P.Just (3, ("updateUrl",T.TString $ E.encodeUtf8 _v1859))) $ systemConfiguration_updateUrl record
  , (\_v1859 -> P.Just (11, ("c2dmAccount",T.TString $ E.encodeUtf8 _v1859))) $ systemConfiguration_c2dmAccount record
  , (\_v1859 -> P.Just (12, ("nniServer",T.TString $ E.encodeUtf8 _v1859))) $ systemConfiguration_nniServer record
  ]
write_SystemConfiguration :: T.Protocol p => p -> SystemConfiguration -> P.IO ()
write_SystemConfiguration oprot record = T.writeVal oprot $ from_SystemConfiguration record
encode_SystemConfiguration :: T.StatelessProtocol p => p -> SystemConfiguration -> LBS.ByteString
encode_SystemConfiguration oprot record = T.serializeVal oprot $ from_SystemConfiguration record
to_SystemConfiguration :: T.ThriftVal -> SystemConfiguration
to_SystemConfiguration (T.TStruct fields) = SystemConfiguration{
  systemConfiguration_endpoint = P.maybe (systemConfiguration_endpoint default_SystemConfiguration) (\(_,_val1861) -> (case _val1861 of {T.TString _val1862 -> E.decodeUtf8 _val1862; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  systemConfiguration_endpointSsl = P.maybe (systemConfiguration_endpointSsl default_SystemConfiguration) (\(_,_val1861) -> (case _val1861 of {T.TString _val1863 -> E.decodeUtf8 _val1863; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  systemConfiguration_updateUrl = P.maybe (systemConfiguration_updateUrl default_SystemConfiguration) (\(_,_val1861) -> (case _val1861 of {T.TString _val1864 -> E.decodeUtf8 _val1864; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  systemConfiguration_c2dmAccount = P.maybe (systemConfiguration_c2dmAccount default_SystemConfiguration) (\(_,_val1861) -> (case _val1861 of {T.TString _val1865 -> E.decodeUtf8 _val1865; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  systemConfiguration_nniServer = P.maybe (systemConfiguration_nniServer default_SystemConfiguration) (\(_,_val1861) -> (case _val1861 of {T.TString _val1866 -> E.decodeUtf8 _val1866; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_SystemConfiguration _ = P.error "not a struct"
read_SystemConfiguration :: T.Protocol p => p -> P.IO SystemConfiguration
read_SystemConfiguration iprot = to_SystemConfiguration <$> T.readVal iprot (T.T_STRUCT typemap_SystemConfiguration)
decode_SystemConfiguration :: T.StatelessProtocol p => p -> LBS.ByteString -> SystemConfiguration
decode_SystemConfiguration iprot bs = to_SystemConfiguration $ T.deserializeVal iprot (T.T_STRUCT typemap_SystemConfiguration) bs
typemap_SystemConfiguration :: T.TypeMap
typemap_SystemConfiguration = Map.fromList [(1,("endpoint",T.T_STRING)),(2,("endpointSsl",T.T_STRING)),(3,("updateUrl",T.T_STRING)),(11,("c2dmAccount",T.T_STRING)),(12,("nniServer",T.T_STRING))]
default_SystemConfiguration :: SystemConfiguration
default_SystemConfiguration = SystemConfiguration{
  systemConfiguration_endpoint = "",
  systemConfiguration_endpointSsl = "",
  systemConfiguration_updateUrl = "",
  systemConfiguration_c2dmAccount = "",
  systemConfiguration_nniServer = ""}
data Ticket = Ticket  { ticket_id :: LT.Text
  , ticket_expirationTime :: I.Int64
  , ticket_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Ticket where
  hashWithSalt salt record = salt   `H.hashWithSalt` ticket_id record   `H.hashWithSalt` ticket_expirationTime record   `H.hashWithSalt` ticket_maxUseCount record  
instance QC.Arbitrary Ticket where 
  arbitrary = M.liftM Ticket (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Ticket = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Ticket{ticket_id = ticket_id obj} then P.Nothing else P.Just $ default_Ticket{ticket_id = ticket_id obj}
    , if obj == default_Ticket{ticket_expirationTime = ticket_expirationTime obj} then P.Nothing else P.Just $ default_Ticket{ticket_expirationTime = ticket_expirationTime obj}
    , if obj == default_Ticket{ticket_maxUseCount = ticket_maxUseCount obj} then P.Nothing else P.Just $ default_Ticket{ticket_maxUseCount = ticket_maxUseCount obj}
    ]
from_Ticket :: Ticket -> T.ThriftVal
from_Ticket record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1869 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1869))) $ ticket_id record
  , (\_v1869 -> P.Just (10, ("expirationTime",T.TI64 _v1869))) $ ticket_expirationTime record
  , (\_v1869 -> P.Just (21, ("maxUseCount",T.TI32 _v1869))) $ ticket_maxUseCount record
  ]
write_Ticket :: T.Protocol p => p -> Ticket -> P.IO ()
write_Ticket oprot record = T.writeVal oprot $ from_Ticket record
encode_Ticket :: T.StatelessProtocol p => p -> Ticket -> LBS.ByteString
encode_Ticket oprot record = T.serializeVal oprot $ from_Ticket record
to_Ticket :: T.ThriftVal -> Ticket
to_Ticket (T.TStruct fields) = Ticket{
  ticket_id = P.maybe (ticket_id default_Ticket) (\(_,_val1871) -> (case _val1871 of {T.TString _val1872 -> E.decodeUtf8 _val1872; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  ticket_expirationTime = P.maybe (ticket_expirationTime default_Ticket) (\(_,_val1871) -> (case _val1871 of {T.TI64 _val1873 -> _val1873; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  ticket_maxUseCount = P.maybe (ticket_maxUseCount default_Ticket) (\(_,_val1871) -> (case _val1871 of {T.TI32 _val1874 -> _val1874; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_Ticket _ = P.error "not a struct"
read_Ticket :: T.Protocol p => p -> P.IO Ticket
read_Ticket iprot = to_Ticket <$> T.readVal iprot (T.T_STRUCT typemap_Ticket)
decode_Ticket :: T.StatelessProtocol p => p -> LBS.ByteString -> Ticket
decode_Ticket iprot bs = to_Ticket $ T.deserializeVal iprot (T.T_STRUCT typemap_Ticket) bs
typemap_Ticket :: T.TypeMap
typemap_Ticket = Map.fromList [(1,("id",T.T_STRING)),(10,("expirationTime",T.T_I64)),(21,("maxUseCount",T.T_I32))]
default_Ticket :: Ticket
default_Ticket = Ticket{
  ticket_id = "",
  ticket_expirationTime = 0,
  ticket_maxUseCount = 0}
data TMessageBox = TMessageBox  { tMessageBox_id :: LT.Text
  , tMessageBox_channelId :: LT.Text
  , tMessageBox_lastSeq :: I.Int64
  , tMessageBox_unreadCount :: I.Int64
  , tMessageBox_lastModifiedTime :: I.Int64
  , tMessageBox_status :: I.Int32
  , tMessageBox_midType :: MIDType
  , tMessageBox_lastMessages :: (Vector.Vector Message)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBox where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBox_id record   `H.hashWithSalt` tMessageBox_channelId record   `H.hashWithSalt` tMessageBox_lastSeq record   `H.hashWithSalt` tMessageBox_unreadCount record   `H.hashWithSalt` tMessageBox_lastModifiedTime record   `H.hashWithSalt` tMessageBox_status record   `H.hashWithSalt` tMessageBox_midType record   `H.hashWithSalt` tMessageBox_lastMessages record  
instance QC.Arbitrary TMessageBox where 
  arbitrary = M.liftM TMessageBox (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBox = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBox{tMessageBox_id = tMessageBox_id obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_id = tMessageBox_id obj}
    , if obj == default_TMessageBox{tMessageBox_channelId = tMessageBox_channelId obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_channelId = tMessageBox_channelId obj}
    , if obj == default_TMessageBox{tMessageBox_lastSeq = tMessageBox_lastSeq obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastSeq = tMessageBox_lastSeq obj}
    , if obj == default_TMessageBox{tMessageBox_unreadCount = tMessageBox_unreadCount obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_unreadCount = tMessageBox_unreadCount obj}
    , if obj == default_TMessageBox{tMessageBox_lastModifiedTime = tMessageBox_lastModifiedTime obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastModifiedTime = tMessageBox_lastModifiedTime obj}
    , if obj == default_TMessageBox{tMessageBox_status = tMessageBox_status obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_status = tMessageBox_status obj}
    , if obj == default_TMessageBox{tMessageBox_midType = tMessageBox_midType obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_midType = tMessageBox_midType obj}
    , if obj == default_TMessageBox{tMessageBox_lastMessages = tMessageBox_lastMessages obj} then P.Nothing else P.Just $ default_TMessageBox{tMessageBox_lastMessages = tMessageBox_lastMessages obj}
    ]
from_TMessageBox :: TMessageBox -> T.ThriftVal
from_TMessageBox record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1877 -> P.Just (1, ("id",T.TString $ E.encodeUtf8 _v1877))) $ tMessageBox_id record
  , (\_v1877 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v1877))) $ tMessageBox_channelId record
  , (\_v1877 -> P.Just (5, ("lastSeq",T.TI64 _v1877))) $ tMessageBox_lastSeq record
  , (\_v1877 -> P.Just (6, ("unreadCount",T.TI64 _v1877))) $ tMessageBox_unreadCount record
  , (\_v1877 -> P.Just (7, ("lastModifiedTime",T.TI64 _v1877))) $ tMessageBox_lastModifiedTime record
  , (\_v1877 -> P.Just (8, ("status",T.TI32 _v1877))) $ tMessageBox_status record
  , (\_v1877 -> P.Just (9, ("midType",T.TI32 $ P.fromIntegral $ P.fromEnum _v1877))) $ tMessageBox_midType record
  , (\_v1877 -> P.Just (10, ("lastMessages",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v1879 -> from_Message _v1879) $ Vector.toList _v1877))) $ tMessageBox_lastMessages record
  ]
write_TMessageBox :: T.Protocol p => p -> TMessageBox -> P.IO ()
write_TMessageBox oprot record = T.writeVal oprot $ from_TMessageBox record
encode_TMessageBox :: T.StatelessProtocol p => p -> TMessageBox -> LBS.ByteString
encode_TMessageBox oprot record = T.serializeVal oprot $ from_TMessageBox record
to_TMessageBox :: T.ThriftVal -> TMessageBox
to_TMessageBox (T.TStruct fields) = TMessageBox{
  tMessageBox_id = P.maybe (tMessageBox_id default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TString _val1882 -> E.decodeUtf8 _val1882; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBox_channelId = P.maybe (tMessageBox_channelId default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TString _val1883 -> E.decodeUtf8 _val1883; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tMessageBox_lastSeq = P.maybe (tMessageBox_lastSeq default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TI64 _val1884 -> _val1884; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  tMessageBox_unreadCount = P.maybe (tMessageBox_unreadCount default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TI64 _val1885 -> _val1885; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  tMessageBox_lastModifiedTime = P.maybe (tMessageBox_lastModifiedTime default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TI64 _val1886 -> _val1886; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  tMessageBox_status = P.maybe (tMessageBox_status default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TI32 _val1887 -> _val1887; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  tMessageBox_midType = P.maybe (tMessageBox_midType default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TI32 _val1888 -> P.toEnum $ P.fromIntegral _val1888; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  tMessageBox_lastMessages = P.maybe (tMessageBox_lastMessages default_TMessageBox) (\(_,_val1881) -> (case _val1881 of {T.TList _ _val1889 -> (Vector.fromList $ P.map (\_v1890 -> (case _v1890 of {T.TStruct _val1891 -> (to_Message (T.TStruct _val1891)); _ -> P.error "wrong type"})) _val1889); _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_TMessageBox _ = P.error "not a struct"
read_TMessageBox :: T.Protocol p => p -> P.IO TMessageBox
read_TMessageBox iprot = to_TMessageBox <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBox)
decode_TMessageBox :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBox
decode_TMessageBox iprot bs = to_TMessageBox $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBox) bs
typemap_TMessageBox :: T.TypeMap
typemap_TMessageBox = Map.fromList [(1,("id",T.T_STRING)),(2,("channelId",T.T_STRING)),(5,("lastSeq",T.T_I64)),(6,("unreadCount",T.T_I64)),(7,("lastModifiedTime",T.T_I64)),(8,("status",T.T_I32)),(9,("midType",T.T_I32)),(10,("lastMessages",(T.T_LIST (T.T_STRUCT typemap_Message))))]
default_TMessageBox :: TMessageBox
default_TMessageBox = TMessageBox{
  tMessageBox_id = "",
  tMessageBox_channelId = "",
  tMessageBox_lastSeq = 0,
  tMessageBox_unreadCount = 0,
  tMessageBox_lastModifiedTime = 0,
  tMessageBox_status = 0,
  tMessageBox_midType = (P.toEnum 0),
  tMessageBox_lastMessages = Vector.empty}
data TMessageBoxWrapUp = TMessageBoxWrapUp  { tMessageBoxWrapUp_messageBox :: TMessageBox
  , tMessageBoxWrapUp_name :: LT.Text
  , tMessageBoxWrapUp_contacts :: (Vector.Vector Contact)
  , tMessageBoxWrapUp_pictureRevision :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBoxWrapUp where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBoxWrapUp_messageBox record   `H.hashWithSalt` tMessageBoxWrapUp_name record   `H.hashWithSalt` tMessageBoxWrapUp_contacts record   `H.hashWithSalt` tMessageBoxWrapUp_pictureRevision record  
instance QC.Arbitrary TMessageBoxWrapUp where 
  arbitrary = M.liftM TMessageBoxWrapUp (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBoxWrapUp = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_messageBox = tMessageBoxWrapUp_messageBox obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_messageBox = tMessageBoxWrapUp_messageBox obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_name = tMessageBoxWrapUp_name obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_name = tMessageBoxWrapUp_name obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_contacts = tMessageBoxWrapUp_contacts obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_contacts = tMessageBoxWrapUp_contacts obj}
    , if obj == default_TMessageBoxWrapUp{tMessageBoxWrapUp_pictureRevision = tMessageBoxWrapUp_pictureRevision obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUp{tMessageBoxWrapUp_pictureRevision = tMessageBoxWrapUp_pictureRevision obj}
    ]
from_TMessageBoxWrapUp :: TMessageBoxWrapUp -> T.ThriftVal
from_TMessageBoxWrapUp record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1894 -> P.Just (1, ("messageBox",from_TMessageBox _v1894))) $ tMessageBoxWrapUp_messageBox record
  , (\_v1894 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v1894))) $ tMessageBoxWrapUp_name record
  , (\_v1894 -> P.Just (3, ("contacts",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v1896 -> from_Contact _v1896) $ Vector.toList _v1894))) $ tMessageBoxWrapUp_contacts record
  , (\_v1894 -> P.Just (4, ("pictureRevision",T.TString $ E.encodeUtf8 _v1894))) $ tMessageBoxWrapUp_pictureRevision record
  ]
write_TMessageBoxWrapUp :: T.Protocol p => p -> TMessageBoxWrapUp -> P.IO ()
write_TMessageBoxWrapUp oprot record = T.writeVal oprot $ from_TMessageBoxWrapUp record
encode_TMessageBoxWrapUp :: T.StatelessProtocol p => p -> TMessageBoxWrapUp -> LBS.ByteString
encode_TMessageBoxWrapUp oprot record = T.serializeVal oprot $ from_TMessageBoxWrapUp record
to_TMessageBoxWrapUp :: T.ThriftVal -> TMessageBoxWrapUp
to_TMessageBoxWrapUp (T.TStruct fields) = TMessageBoxWrapUp{
  tMessageBoxWrapUp_messageBox = P.maybe (tMessageBoxWrapUp_messageBox default_TMessageBoxWrapUp) (\(_,_val1898) -> (case _val1898 of {T.TStruct _val1899 -> (to_TMessageBox (T.TStruct _val1899)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBoxWrapUp_name = P.maybe (tMessageBoxWrapUp_name default_TMessageBoxWrapUp) (\(_,_val1898) -> (case _val1898 of {T.TString _val1900 -> E.decodeUtf8 _val1900; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tMessageBoxWrapUp_contacts = P.maybe (tMessageBoxWrapUp_contacts default_TMessageBoxWrapUp) (\(_,_val1898) -> (case _val1898 of {T.TList _ _val1901 -> (Vector.fromList $ P.map (\_v1902 -> (case _v1902 of {T.TStruct _val1903 -> (to_Contact (T.TStruct _val1903)); _ -> P.error "wrong type"})) _val1901); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tMessageBoxWrapUp_pictureRevision = P.maybe (tMessageBoxWrapUp_pictureRevision default_TMessageBoxWrapUp) (\(_,_val1898) -> (case _val1898 of {T.TString _val1904 -> E.decodeUtf8 _val1904; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TMessageBoxWrapUp _ = P.error "not a struct"
read_TMessageBoxWrapUp :: T.Protocol p => p -> P.IO TMessageBoxWrapUp
read_TMessageBoxWrapUp iprot = to_TMessageBoxWrapUp <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUp)
decode_TMessageBoxWrapUp :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBoxWrapUp
decode_TMessageBoxWrapUp iprot bs = to_TMessageBoxWrapUp $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUp) bs
typemap_TMessageBoxWrapUp :: T.TypeMap
typemap_TMessageBoxWrapUp = Map.fromList [(1,("messageBox",(T.T_STRUCT typemap_TMessageBox))),(2,("name",T.T_STRING)),(3,("contacts",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(4,("pictureRevision",T.T_STRING))]
default_TMessageBoxWrapUp :: TMessageBoxWrapUp
default_TMessageBoxWrapUp = TMessageBoxWrapUp{
  tMessageBoxWrapUp_messageBox = default_TMessageBox,
  tMessageBoxWrapUp_name = "",
  tMessageBoxWrapUp_contacts = Vector.empty,
  tMessageBoxWrapUp_pictureRevision = ""}
data TMessageBoxWrapUpResponse = TMessageBoxWrapUpResponse  { tMessageBoxWrapUpResponse_messageBoxWrapUpList :: (Vector.Vector TMessageBoxWrapUp)
  , tMessageBoxWrapUpResponse_totalSize :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageBoxWrapUpResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageBoxWrapUpResponse_messageBoxWrapUpList record   `H.hashWithSalt` tMessageBoxWrapUpResponse_totalSize record  
instance QC.Arbitrary TMessageBoxWrapUpResponse where 
  arbitrary = M.liftM TMessageBoxWrapUpResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageBoxWrapUpResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_messageBoxWrapUpList = tMessageBoxWrapUpResponse_messageBoxWrapUpList obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_messageBoxWrapUpList = tMessageBoxWrapUpResponse_messageBoxWrapUpList obj}
    , if obj == default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_totalSize = tMessageBoxWrapUpResponse_totalSize obj} then P.Nothing else P.Just $ default_TMessageBoxWrapUpResponse{tMessageBoxWrapUpResponse_totalSize = tMessageBoxWrapUpResponse_totalSize obj}
    ]
from_TMessageBoxWrapUpResponse :: TMessageBoxWrapUpResponse -> T.ThriftVal
from_TMessageBoxWrapUpResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1907 -> P.Just (1, ("messageBoxWrapUpList",T.TList (T.T_STRUCT typemap_TMessageBoxWrapUp) $ P.map (\_v1909 -> from_TMessageBoxWrapUp _v1909) $ Vector.toList _v1907))) $ tMessageBoxWrapUpResponse_messageBoxWrapUpList record
  , (\_v1907 -> P.Just (2, ("totalSize",T.TI32 _v1907))) $ tMessageBoxWrapUpResponse_totalSize record
  ]
write_TMessageBoxWrapUpResponse :: T.Protocol p => p -> TMessageBoxWrapUpResponse -> P.IO ()
write_TMessageBoxWrapUpResponse oprot record = T.writeVal oprot $ from_TMessageBoxWrapUpResponse record
encode_TMessageBoxWrapUpResponse :: T.StatelessProtocol p => p -> TMessageBoxWrapUpResponse -> LBS.ByteString
encode_TMessageBoxWrapUpResponse oprot record = T.serializeVal oprot $ from_TMessageBoxWrapUpResponse record
to_TMessageBoxWrapUpResponse :: T.ThriftVal -> TMessageBoxWrapUpResponse
to_TMessageBoxWrapUpResponse (T.TStruct fields) = TMessageBoxWrapUpResponse{
  tMessageBoxWrapUpResponse_messageBoxWrapUpList = P.maybe (tMessageBoxWrapUpResponse_messageBoxWrapUpList default_TMessageBoxWrapUpResponse) (\(_,_val1911) -> (case _val1911 of {T.TList _ _val1912 -> (Vector.fromList $ P.map (\_v1913 -> (case _v1913 of {T.TStruct _val1914 -> (to_TMessageBoxWrapUp (T.TStruct _val1914)); _ -> P.error "wrong type"})) _val1912); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageBoxWrapUpResponse_totalSize = P.maybe (tMessageBoxWrapUpResponse_totalSize default_TMessageBoxWrapUpResponse) (\(_,_val1911) -> (case _val1911 of {T.TI32 _val1915 -> _val1915; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TMessageBoxWrapUpResponse _ = P.error "not a struct"
read_TMessageBoxWrapUpResponse :: T.Protocol p => p -> P.IO TMessageBoxWrapUpResponse
read_TMessageBoxWrapUpResponse iprot = to_TMessageBoxWrapUpResponse <$> T.readVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUpResponse)
decode_TMessageBoxWrapUpResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageBoxWrapUpResponse
decode_TMessageBoxWrapUpResponse iprot bs = to_TMessageBoxWrapUpResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageBoxWrapUpResponse) bs
typemap_TMessageBoxWrapUpResponse :: T.TypeMap
typemap_TMessageBoxWrapUpResponse = Map.fromList [(1,("messageBoxWrapUpList",(T.T_LIST (T.T_STRUCT typemap_TMessageBoxWrapUp)))),(2,("totalSize",T.T_I32))]
default_TMessageBoxWrapUpResponse :: TMessageBoxWrapUpResponse
default_TMessageBoxWrapUpResponse = TMessageBoxWrapUpResponse{
  tMessageBoxWrapUpResponse_messageBoxWrapUpList = Vector.empty,
  tMessageBoxWrapUpResponse_totalSize = 0}
data TMessageReadRangeEntry = TMessageReadRangeEntry  { tMessageReadRangeEntry_startMessageId :: I.Int64
  , tMessageReadRangeEntry_endMessageId :: I.Int64
  , tMessageReadRangeEntry_startTime :: I.Int64
  , tMessageReadRangeEntry_endTime :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageReadRangeEntry where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageReadRangeEntry_startMessageId record   `H.hashWithSalt` tMessageReadRangeEntry_endMessageId record   `H.hashWithSalt` tMessageReadRangeEntry_startTime record   `H.hashWithSalt` tMessageReadRangeEntry_endTime record  
instance QC.Arbitrary TMessageReadRangeEntry where 
  arbitrary = M.liftM TMessageReadRangeEntry (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageReadRangeEntry = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageReadRangeEntry{tMessageReadRangeEntry_startMessageId = tMessageReadRangeEntry_startMessageId obj} then P.Nothing else P.Just $ default_TMessageReadRangeEntry{tMessageReadRangeEntry_startMessageId = tMessageReadRangeEntry_startMessageId obj}
    , if obj == default_TMessageReadRangeEntry{tMessageReadRangeEntry_endMessageId = tMessageReadRangeEntry_endMessageId obj} then P.Nothing else P.Just $ default_TMessageReadRangeEntry{tMessageReadRangeEntry_endMessageId = tMessageReadRangeEntry_endMessageId obj}
    , if obj == default_TMessageReadRangeEntry{tMessageReadRangeEntry_startTime = tMessageReadRangeEntry_startTime obj} then P.Nothing else P.Just $ default_TMessageReadRangeEntry{tMessageReadRangeEntry_startTime = tMessageReadRangeEntry_startTime obj}
    , if obj == default_TMessageReadRangeEntry{tMessageReadRangeEntry_endTime = tMessageReadRangeEntry_endTime obj} then P.Nothing else P.Just $ default_TMessageReadRangeEntry{tMessageReadRangeEntry_endTime = tMessageReadRangeEntry_endTime obj}
    ]
from_TMessageReadRangeEntry :: TMessageReadRangeEntry -> T.ThriftVal
from_TMessageReadRangeEntry record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1918 -> P.Just (1, ("startMessageId",T.TI64 _v1918))) $ tMessageReadRangeEntry_startMessageId record
  , (\_v1918 -> P.Just (2, ("endMessageId",T.TI64 _v1918))) $ tMessageReadRangeEntry_endMessageId record
  , (\_v1918 -> P.Just (3, ("startTime",T.TI64 _v1918))) $ tMessageReadRangeEntry_startTime record
  , (\_v1918 -> P.Just (4, ("endTime",T.TI64 _v1918))) $ tMessageReadRangeEntry_endTime record
  ]
write_TMessageReadRangeEntry :: T.Protocol p => p -> TMessageReadRangeEntry -> P.IO ()
write_TMessageReadRangeEntry oprot record = T.writeVal oprot $ from_TMessageReadRangeEntry record
encode_TMessageReadRangeEntry :: T.StatelessProtocol p => p -> TMessageReadRangeEntry -> LBS.ByteString
encode_TMessageReadRangeEntry oprot record = T.serializeVal oprot $ from_TMessageReadRangeEntry record
to_TMessageReadRangeEntry :: T.ThriftVal -> TMessageReadRangeEntry
to_TMessageReadRangeEntry (T.TStruct fields) = TMessageReadRangeEntry{
  tMessageReadRangeEntry_startMessageId = P.maybe (tMessageReadRangeEntry_startMessageId default_TMessageReadRangeEntry) (\(_,_val1920) -> (case _val1920 of {T.TI64 _val1921 -> _val1921; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageReadRangeEntry_endMessageId = P.maybe (tMessageReadRangeEntry_endMessageId default_TMessageReadRangeEntry) (\(_,_val1920) -> (case _val1920 of {T.TI64 _val1922 -> _val1922; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tMessageReadRangeEntry_startTime = P.maybe (tMessageReadRangeEntry_startTime default_TMessageReadRangeEntry) (\(_,_val1920) -> (case _val1920 of {T.TI64 _val1923 -> _val1923; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tMessageReadRangeEntry_endTime = P.maybe (tMessageReadRangeEntry_endTime default_TMessageReadRangeEntry) (\(_,_val1920) -> (case _val1920 of {T.TI64 _val1924 -> _val1924; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_TMessageReadRangeEntry _ = P.error "not a struct"
read_TMessageReadRangeEntry :: T.Protocol p => p -> P.IO TMessageReadRangeEntry
read_TMessageReadRangeEntry iprot = to_TMessageReadRangeEntry <$> T.readVal iprot (T.T_STRUCT typemap_TMessageReadRangeEntry)
decode_TMessageReadRangeEntry :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageReadRangeEntry
decode_TMessageReadRangeEntry iprot bs = to_TMessageReadRangeEntry $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageReadRangeEntry) bs
typemap_TMessageReadRangeEntry :: T.TypeMap
typemap_TMessageReadRangeEntry = Map.fromList [(1,("startMessageId",T.T_I64)),(2,("endMessageId",T.T_I64)),(3,("startTime",T.T_I64)),(4,("endTime",T.T_I64))]
default_TMessageReadRangeEntry :: TMessageReadRangeEntry
default_TMessageReadRangeEntry = TMessageReadRangeEntry{
  tMessageReadRangeEntry_startMessageId = 0,
  tMessageReadRangeEntry_endMessageId = 0,
  tMessageReadRangeEntry_startTime = 0,
  tMessageReadRangeEntry_endTime = 0}
data TMessageReadRange = TMessageReadRange  { tMessageReadRange_chatId :: LT.Text
  , tMessageReadRange_ranges :: (Map.HashMap LT.Text (Vector.Vector TMessageReadRangeEntry))
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TMessageReadRange where
  hashWithSalt salt record = salt   `H.hashWithSalt` tMessageReadRange_chatId record   `H.hashWithSalt` tMessageReadRange_ranges record  
instance QC.Arbitrary TMessageReadRange where 
  arbitrary = M.liftM TMessageReadRange (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TMessageReadRange = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TMessageReadRange{tMessageReadRange_chatId = tMessageReadRange_chatId obj} then P.Nothing else P.Just $ default_TMessageReadRange{tMessageReadRange_chatId = tMessageReadRange_chatId obj}
    , if obj == default_TMessageReadRange{tMessageReadRange_ranges = tMessageReadRange_ranges obj} then P.Nothing else P.Just $ default_TMessageReadRange{tMessageReadRange_ranges = tMessageReadRange_ranges obj}
    ]
from_TMessageReadRange :: TMessageReadRange -> T.ThriftVal
from_TMessageReadRange record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1927 -> P.Just (1, ("chatId",T.TString $ E.encodeUtf8 _v1927))) $ tMessageReadRange_chatId record
  , (\_v1927 -> P.Just (2, ("ranges",T.TMap T.T_STRING (T.T_LIST (T.T_STRUCT typemap_TMessageReadRangeEntry)) $ P.map (\(_k1928,_v1929) -> (T.TString $ E.encodeUtf8 _k1928, T.TList (T.T_STRUCT typemap_TMessageReadRangeEntry) $ P.map (\_v1931 -> from_TMessageReadRangeEntry _v1931) $ Vector.toList _v1929)) $ Map.toList _v1927))) $ tMessageReadRange_ranges record
  ]
write_TMessageReadRange :: T.Protocol p => p -> TMessageReadRange -> P.IO ()
write_TMessageReadRange oprot record = T.writeVal oprot $ from_TMessageReadRange record
encode_TMessageReadRange :: T.StatelessProtocol p => p -> TMessageReadRange -> LBS.ByteString
encode_TMessageReadRange oprot record = T.serializeVal oprot $ from_TMessageReadRange record
to_TMessageReadRange :: T.ThriftVal -> TMessageReadRange
to_TMessageReadRange (T.TStruct fields) = TMessageReadRange{
  tMessageReadRange_chatId = P.maybe (tMessageReadRange_chatId default_TMessageReadRange) (\(_,_val1933) -> (case _val1933 of {T.TString _val1934 -> E.decodeUtf8 _val1934; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tMessageReadRange_ranges = P.maybe (tMessageReadRange_ranges default_TMessageReadRange) (\(_,_val1933) -> (case _val1933 of {T.TMap _ _ _val1935 -> (Map.fromList $ P.map (\(_k1937,_v1936) -> ((case _k1937 of {T.TString _val1938 -> E.decodeUtf8 _val1938; _ -> P.error "wrong type"}),(case _v1936 of {T.TList _ _val1939 -> (Vector.fromList $ P.map (\_v1940 -> (case _v1940 of {T.TStruct _val1941 -> (to_TMessageReadRangeEntry (T.TStruct _val1941)); _ -> P.error "wrong type"})) _val1939); _ -> P.error "wrong type"}))) _val1935); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TMessageReadRange _ = P.error "not a struct"
read_TMessageReadRange :: T.Protocol p => p -> P.IO TMessageReadRange
read_TMessageReadRange iprot = to_TMessageReadRange <$> T.readVal iprot (T.T_STRUCT typemap_TMessageReadRange)
decode_TMessageReadRange :: T.StatelessProtocol p => p -> LBS.ByteString -> TMessageReadRange
decode_TMessageReadRange iprot bs = to_TMessageReadRange $ T.deserializeVal iprot (T.T_STRUCT typemap_TMessageReadRange) bs
typemap_TMessageReadRange :: T.TypeMap
typemap_TMessageReadRange = Map.fromList [(1,("chatId",T.T_STRING)),(2,("ranges",(T.T_MAP T.T_STRING (T.T_LIST (T.T_STRUCT typemap_TMessageReadRangeEntry)))))]
default_TMessageReadRange :: TMessageReadRange
default_TMessageReadRange = TMessageReadRange{
  tMessageReadRange_chatId = "",
  tMessageReadRange_ranges = Map.empty}
data ChatRoomAnnouncementContents = ChatRoomAnnouncementContents  { chatRoomAnnouncementContents_displayFields :: I.Int32
  , chatRoomAnnouncementContents_text :: LT.Text
  , chatRoomAnnouncementContents_link :: LT.Text
  , chatRoomAnnouncementContents_thumbnail :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChatRoomAnnouncementContents where
  hashWithSalt salt record = salt   `H.hashWithSalt` chatRoomAnnouncementContents_displayFields record   `H.hashWithSalt` chatRoomAnnouncementContents_text record   `H.hashWithSalt` chatRoomAnnouncementContents_link record   `H.hashWithSalt` chatRoomAnnouncementContents_thumbnail record  
instance QC.Arbitrary ChatRoomAnnouncementContents where 
  arbitrary = M.liftM ChatRoomAnnouncementContents (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChatRoomAnnouncementContents = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_displayFields = chatRoomAnnouncementContents_displayFields obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_displayFields = chatRoomAnnouncementContents_displayFields obj}
    , if obj == default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_text = chatRoomAnnouncementContents_text obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_text = chatRoomAnnouncementContents_text obj}
    , if obj == default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_link = chatRoomAnnouncementContents_link obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_link = chatRoomAnnouncementContents_link obj}
    , if obj == default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_thumbnail = chatRoomAnnouncementContents_thumbnail obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncementContents{chatRoomAnnouncementContents_thumbnail = chatRoomAnnouncementContents_thumbnail obj}
    ]
from_ChatRoomAnnouncementContents :: ChatRoomAnnouncementContents -> T.ThriftVal
from_ChatRoomAnnouncementContents record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1944 -> P.Just (1, ("displayFields",T.TI32 _v1944))) $ chatRoomAnnouncementContents_displayFields record
  , (\_v1944 -> P.Just (2, ("text",T.TString $ E.encodeUtf8 _v1944))) $ chatRoomAnnouncementContents_text record
  , (\_v1944 -> P.Just (3, ("link",T.TString $ E.encodeUtf8 _v1944))) $ chatRoomAnnouncementContents_link record
  , (\_v1944 -> P.Just (4, ("thumbnail",T.TString $ E.encodeUtf8 _v1944))) $ chatRoomAnnouncementContents_thumbnail record
  ]
write_ChatRoomAnnouncementContents :: T.Protocol p => p -> ChatRoomAnnouncementContents -> P.IO ()
write_ChatRoomAnnouncementContents oprot record = T.writeVal oprot $ from_ChatRoomAnnouncementContents record
encode_ChatRoomAnnouncementContents :: T.StatelessProtocol p => p -> ChatRoomAnnouncementContents -> LBS.ByteString
encode_ChatRoomAnnouncementContents oprot record = T.serializeVal oprot $ from_ChatRoomAnnouncementContents record
to_ChatRoomAnnouncementContents :: T.ThriftVal -> ChatRoomAnnouncementContents
to_ChatRoomAnnouncementContents (T.TStruct fields) = ChatRoomAnnouncementContents{
  chatRoomAnnouncementContents_displayFields = P.maybe (chatRoomAnnouncementContents_displayFields default_ChatRoomAnnouncementContents) (\(_,_val1946) -> (case _val1946 of {T.TI32 _val1947 -> _val1947; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  chatRoomAnnouncementContents_text = P.maybe (chatRoomAnnouncementContents_text default_ChatRoomAnnouncementContents) (\(_,_val1946) -> (case _val1946 of {T.TString _val1948 -> E.decodeUtf8 _val1948; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  chatRoomAnnouncementContents_link = P.maybe (chatRoomAnnouncementContents_link default_ChatRoomAnnouncementContents) (\(_,_val1946) -> (case _val1946 of {T.TString _val1949 -> E.decodeUtf8 _val1949; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  chatRoomAnnouncementContents_thumbnail = P.maybe (chatRoomAnnouncementContents_thumbnail default_ChatRoomAnnouncementContents) (\(_,_val1946) -> (case _val1946 of {T.TString _val1950 -> E.decodeUtf8 _val1950; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ChatRoomAnnouncementContents _ = P.error "not a struct"
read_ChatRoomAnnouncementContents :: T.Protocol p => p -> P.IO ChatRoomAnnouncementContents
read_ChatRoomAnnouncementContents iprot = to_ChatRoomAnnouncementContents <$> T.readVal iprot (T.T_STRUCT typemap_ChatRoomAnnouncementContents)
decode_ChatRoomAnnouncementContents :: T.StatelessProtocol p => p -> LBS.ByteString -> ChatRoomAnnouncementContents
decode_ChatRoomAnnouncementContents iprot bs = to_ChatRoomAnnouncementContents $ T.deserializeVal iprot (T.T_STRUCT typemap_ChatRoomAnnouncementContents) bs
typemap_ChatRoomAnnouncementContents :: T.TypeMap
typemap_ChatRoomAnnouncementContents = Map.fromList [(1,("displayFields",T.T_I32)),(2,("text",T.T_STRING)),(3,("link",T.T_STRING)),(4,("thumbnail",T.T_STRING))]
default_ChatRoomAnnouncementContents :: ChatRoomAnnouncementContents
default_ChatRoomAnnouncementContents = ChatRoomAnnouncementContents{
  chatRoomAnnouncementContents_displayFields = 0,
  chatRoomAnnouncementContents_text = "",
  chatRoomAnnouncementContents_link = "",
  chatRoomAnnouncementContents_thumbnail = ""}
data ChatRoomAnnouncement = ChatRoomAnnouncement  { chatRoomAnnouncement_announcementSeq :: I.Int64
  , chatRoomAnnouncement_type :: ChatRoomAnnouncementType
  , chatRoomAnnouncement_contents :: ChatRoomAnnouncementContents
  , chatRoomAnnouncement_creatorMid :: LT.Text
  , chatRoomAnnouncement_createdTime :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChatRoomAnnouncement where
  hashWithSalt salt record = salt   `H.hashWithSalt` chatRoomAnnouncement_announcementSeq record   `H.hashWithSalt` chatRoomAnnouncement_type record   `H.hashWithSalt` chatRoomAnnouncement_contents record   `H.hashWithSalt` chatRoomAnnouncement_creatorMid record   `H.hashWithSalt` chatRoomAnnouncement_createdTime record  
instance QC.Arbitrary ChatRoomAnnouncement where 
  arbitrary = M.liftM ChatRoomAnnouncement (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChatRoomAnnouncement = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChatRoomAnnouncement{chatRoomAnnouncement_announcementSeq = chatRoomAnnouncement_announcementSeq obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncement{chatRoomAnnouncement_announcementSeq = chatRoomAnnouncement_announcementSeq obj}
    , if obj == default_ChatRoomAnnouncement{chatRoomAnnouncement_type = chatRoomAnnouncement_type obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncement{chatRoomAnnouncement_type = chatRoomAnnouncement_type obj}
    , if obj == default_ChatRoomAnnouncement{chatRoomAnnouncement_contents = chatRoomAnnouncement_contents obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncement{chatRoomAnnouncement_contents = chatRoomAnnouncement_contents obj}
    , if obj == default_ChatRoomAnnouncement{chatRoomAnnouncement_creatorMid = chatRoomAnnouncement_creatorMid obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncement{chatRoomAnnouncement_creatorMid = chatRoomAnnouncement_creatorMid obj}
    , if obj == default_ChatRoomAnnouncement{chatRoomAnnouncement_createdTime = chatRoomAnnouncement_createdTime obj} then P.Nothing else P.Just $ default_ChatRoomAnnouncement{chatRoomAnnouncement_createdTime = chatRoomAnnouncement_createdTime obj}
    ]
from_ChatRoomAnnouncement :: ChatRoomAnnouncement -> T.ThriftVal
from_ChatRoomAnnouncement record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1953 -> P.Just (1, ("announcementSeq",T.TI64 _v1953))) $ chatRoomAnnouncement_announcementSeq record
  , (\_v1953 -> P.Just (2, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v1953))) $ chatRoomAnnouncement_type record
  , (\_v1953 -> P.Just (3, ("contents",from_ChatRoomAnnouncementContents _v1953))) $ chatRoomAnnouncement_contents record
  , (\_v1953 -> P.Just (4, ("creatorMid",T.TString $ E.encodeUtf8 _v1953))) $ chatRoomAnnouncement_creatorMid record
  , (\_v1953 -> P.Just (5, ("createdTime",T.TI64 _v1953))) $ chatRoomAnnouncement_createdTime record
  ]
write_ChatRoomAnnouncement :: T.Protocol p => p -> ChatRoomAnnouncement -> P.IO ()
write_ChatRoomAnnouncement oprot record = T.writeVal oprot $ from_ChatRoomAnnouncement record
encode_ChatRoomAnnouncement :: T.StatelessProtocol p => p -> ChatRoomAnnouncement -> LBS.ByteString
encode_ChatRoomAnnouncement oprot record = T.serializeVal oprot $ from_ChatRoomAnnouncement record
to_ChatRoomAnnouncement :: T.ThriftVal -> ChatRoomAnnouncement
to_ChatRoomAnnouncement (T.TStruct fields) = ChatRoomAnnouncement{
  chatRoomAnnouncement_announcementSeq = P.maybe (chatRoomAnnouncement_announcementSeq default_ChatRoomAnnouncement) (\(_,_val1955) -> (case _val1955 of {T.TI64 _val1956 -> _val1956; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  chatRoomAnnouncement_type = P.maybe (chatRoomAnnouncement_type default_ChatRoomAnnouncement) (\(_,_val1955) -> (case _val1955 of {T.TI32 _val1957 -> P.toEnum $ P.fromIntegral _val1957; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  chatRoomAnnouncement_contents = P.maybe (chatRoomAnnouncement_contents default_ChatRoomAnnouncement) (\(_,_val1955) -> (case _val1955 of {T.TStruct _val1958 -> (to_ChatRoomAnnouncementContents (T.TStruct _val1958)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  chatRoomAnnouncement_creatorMid = P.maybe (chatRoomAnnouncement_creatorMid default_ChatRoomAnnouncement) (\(_,_val1955) -> (case _val1955 of {T.TString _val1959 -> E.decodeUtf8 _val1959; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  chatRoomAnnouncement_createdTime = P.maybe (chatRoomAnnouncement_createdTime default_ChatRoomAnnouncement) (\(_,_val1955) -> (case _val1955 of {T.TI64 _val1960 -> _val1960; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ChatRoomAnnouncement _ = P.error "not a struct"
read_ChatRoomAnnouncement :: T.Protocol p => p -> P.IO ChatRoomAnnouncement
read_ChatRoomAnnouncement iprot = to_ChatRoomAnnouncement <$> T.readVal iprot (T.T_STRUCT typemap_ChatRoomAnnouncement)
decode_ChatRoomAnnouncement :: T.StatelessProtocol p => p -> LBS.ByteString -> ChatRoomAnnouncement
decode_ChatRoomAnnouncement iprot bs = to_ChatRoomAnnouncement $ T.deserializeVal iprot (T.T_STRUCT typemap_ChatRoomAnnouncement) bs
typemap_ChatRoomAnnouncement :: T.TypeMap
typemap_ChatRoomAnnouncement = Map.fromList [(1,("announcementSeq",T.T_I64)),(2,("type",T.T_I32)),(3,("contents",(T.T_STRUCT typemap_ChatRoomAnnouncementContents))),(4,("creatorMid",T.T_STRING)),(5,("createdTime",T.T_I64))]
default_ChatRoomAnnouncement :: ChatRoomAnnouncement
default_ChatRoomAnnouncement = ChatRoomAnnouncement{
  chatRoomAnnouncement_announcementSeq = 0,
  chatRoomAnnouncement_type = (P.toEnum 0),
  chatRoomAnnouncement_contents = default_ChatRoomAnnouncementContents,
  chatRoomAnnouncement_creatorMid = "",
  chatRoomAnnouncement_createdTime = 0}
data ErrorExtraInfo = ErrorExtraInfo  { errorExtraInfo_preconditionFailedExtraInfo :: PreconditionFailedExtraInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ErrorExtraInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` errorExtraInfo_preconditionFailedExtraInfo record  
instance QC.Arbitrary ErrorExtraInfo where 
  arbitrary = M.liftM ErrorExtraInfo (QC.arbitrary)
  shrink obj | obj == default_ErrorExtraInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ErrorExtraInfo{errorExtraInfo_preconditionFailedExtraInfo = errorExtraInfo_preconditionFailedExtraInfo obj} then P.Nothing else P.Just $ default_ErrorExtraInfo{errorExtraInfo_preconditionFailedExtraInfo = errorExtraInfo_preconditionFailedExtraInfo obj}
    ]
from_ErrorExtraInfo :: ErrorExtraInfo -> T.ThriftVal
from_ErrorExtraInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1963 -> P.Just (1, ("preconditionFailedExtraInfo",T.TI32 $ P.fromIntegral $ P.fromEnum _v1963))) $ errorExtraInfo_preconditionFailedExtraInfo record
  ]
write_ErrorExtraInfo :: T.Protocol p => p -> ErrorExtraInfo -> P.IO ()
write_ErrorExtraInfo oprot record = T.writeVal oprot $ from_ErrorExtraInfo record
encode_ErrorExtraInfo :: T.StatelessProtocol p => p -> ErrorExtraInfo -> LBS.ByteString
encode_ErrorExtraInfo oprot record = T.serializeVal oprot $ from_ErrorExtraInfo record
to_ErrorExtraInfo :: T.ThriftVal -> ErrorExtraInfo
to_ErrorExtraInfo (T.TStruct fields) = ErrorExtraInfo{
  errorExtraInfo_preconditionFailedExtraInfo = P.maybe (errorExtraInfo_preconditionFailedExtraInfo default_ErrorExtraInfo) (\(_,_val1965) -> (case _val1965 of {T.TI32 _val1966 -> P.toEnum $ P.fromIntegral _val1966; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ErrorExtraInfo _ = P.error "not a struct"
read_ErrorExtraInfo :: T.Protocol p => p -> P.IO ErrorExtraInfo
read_ErrorExtraInfo iprot = to_ErrorExtraInfo <$> T.readVal iprot (T.T_STRUCT typemap_ErrorExtraInfo)
decode_ErrorExtraInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> ErrorExtraInfo
decode_ErrorExtraInfo iprot bs = to_ErrorExtraInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_ErrorExtraInfo) bs
typemap_ErrorExtraInfo :: T.TypeMap
typemap_ErrorExtraInfo = Map.fromList [(1,("preconditionFailedExtraInfo",T.T_I32))]
default_ErrorExtraInfo :: ErrorExtraInfo
default_ErrorExtraInfo = ErrorExtraInfo{
  errorExtraInfo_preconditionFailedExtraInfo = (P.toEnum 0)}
data SyncRelations = SyncRelations  { syncRelations_syncAll :: P.Bool
  , syncRelations_syncParamContact :: (Vector.Vector SyncParamContact)
  , syncRelations_syncParamMid :: (Vector.Vector SyncParamMid)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncRelations where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncRelations_syncAll record   `H.hashWithSalt` syncRelations_syncParamContact record   `H.hashWithSalt` syncRelations_syncParamMid record  
instance QC.Arbitrary SyncRelations where 
  arbitrary = M.liftM SyncRelations (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncRelations = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncRelations{syncRelations_syncAll = syncRelations_syncAll obj} then P.Nothing else P.Just $ default_SyncRelations{syncRelations_syncAll = syncRelations_syncAll obj}
    , if obj == default_SyncRelations{syncRelations_syncParamContact = syncRelations_syncParamContact obj} then P.Nothing else P.Just $ default_SyncRelations{syncRelations_syncParamContact = syncRelations_syncParamContact obj}
    , if obj == default_SyncRelations{syncRelations_syncParamMid = syncRelations_syncParamMid obj} then P.Nothing else P.Just $ default_SyncRelations{syncRelations_syncParamMid = syncRelations_syncParamMid obj}
    ]
from_SyncRelations :: SyncRelations -> T.ThriftVal
from_SyncRelations record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1969 -> P.Just (1, ("syncAll",T.TBool _v1969))) $ syncRelations_syncAll record
  , (\_v1969 -> P.Just (2, ("syncParamContact",T.TList (T.T_STRUCT typemap_SyncParamContact) $ P.map (\_v1971 -> from_SyncParamContact _v1971) $ Vector.toList _v1969))) $ syncRelations_syncParamContact record
  , (\_v1969 -> P.Just (3, ("syncParamMid",T.TList (T.T_STRUCT typemap_SyncParamMid) $ P.map (\_v1973 -> from_SyncParamMid _v1973) $ Vector.toList _v1969))) $ syncRelations_syncParamMid record
  ]
write_SyncRelations :: T.Protocol p => p -> SyncRelations -> P.IO ()
write_SyncRelations oprot record = T.writeVal oprot $ from_SyncRelations record
encode_SyncRelations :: T.StatelessProtocol p => p -> SyncRelations -> LBS.ByteString
encode_SyncRelations oprot record = T.serializeVal oprot $ from_SyncRelations record
to_SyncRelations :: T.ThriftVal -> SyncRelations
to_SyncRelations (T.TStruct fields) = SyncRelations{
  syncRelations_syncAll = P.maybe (syncRelations_syncAll default_SyncRelations) (\(_,_val1975) -> (case _val1975 of {T.TBool _val1976 -> _val1976; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncRelations_syncParamContact = P.maybe (syncRelations_syncParamContact default_SyncRelations) (\(_,_val1975) -> (case _val1975 of {T.TList _ _val1977 -> (Vector.fromList $ P.map (\_v1978 -> (case _v1978 of {T.TStruct _val1979 -> (to_SyncParamContact (T.TStruct _val1979)); _ -> P.error "wrong type"})) _val1977); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncRelations_syncParamMid = P.maybe (syncRelations_syncParamMid default_SyncRelations) (\(_,_val1975) -> (case _val1975 of {T.TList _ _val1980 -> (Vector.fromList $ P.map (\_v1981 -> (case _v1981 of {T.TStruct _val1982 -> (to_SyncParamMid (T.TStruct _val1982)); _ -> P.error "wrong type"})) _val1980); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SyncRelations _ = P.error "not a struct"
read_SyncRelations :: T.Protocol p => p -> P.IO SyncRelations
read_SyncRelations iprot = to_SyncRelations <$> T.readVal iprot (T.T_STRUCT typemap_SyncRelations)
decode_SyncRelations :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncRelations
decode_SyncRelations iprot bs = to_SyncRelations $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncRelations) bs
typemap_SyncRelations :: T.TypeMap
typemap_SyncRelations = Map.fromList [(1,("syncAll",T.T_BOOL)),(2,("syncParamContact",(T.T_LIST (T.T_STRUCT typemap_SyncParamContact)))),(3,("syncParamMid",(T.T_LIST (T.T_STRUCT typemap_SyncParamMid))))]
default_SyncRelations :: SyncRelations
default_SyncRelations = SyncRelations{
  syncRelations_syncAll = P.False,
  syncRelations_syncParamContact = Vector.empty,
  syncRelations_syncParamMid = Vector.empty}
data SyncScope = SyncScope  { syncScope_syncProfile :: P.Bool
  , syncScope_syncSettings :: P.Bool
  , syncScope_syncSticker :: P.Bool
  , syncScope_syncThemeShop :: P.Bool
  , syncScope_contact :: SyncRelations
  , syncScope_group :: SyncRelations
  , syncScope_room :: SyncRelations
  , syncScope_chat :: SyncRelations
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncScope where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncScope_syncProfile record   `H.hashWithSalt` syncScope_syncSettings record   `H.hashWithSalt` syncScope_syncSticker record   `H.hashWithSalt` syncScope_syncThemeShop record   `H.hashWithSalt` syncScope_contact record   `H.hashWithSalt` syncScope_group record   `H.hashWithSalt` syncScope_room record   `H.hashWithSalt` syncScope_chat record  
instance QC.Arbitrary SyncScope where 
  arbitrary = M.liftM SyncScope (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncScope = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncScope{syncScope_syncProfile = syncScope_syncProfile obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_syncProfile = syncScope_syncProfile obj}
    , if obj == default_SyncScope{syncScope_syncSettings = syncScope_syncSettings obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_syncSettings = syncScope_syncSettings obj}
    , if obj == default_SyncScope{syncScope_syncSticker = syncScope_syncSticker obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_syncSticker = syncScope_syncSticker obj}
    , if obj == default_SyncScope{syncScope_syncThemeShop = syncScope_syncThemeShop obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_syncThemeShop = syncScope_syncThemeShop obj}
    , if obj == default_SyncScope{syncScope_contact = syncScope_contact obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_contact = syncScope_contact obj}
    , if obj == default_SyncScope{syncScope_group = syncScope_group obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_group = syncScope_group obj}
    , if obj == default_SyncScope{syncScope_room = syncScope_room obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_room = syncScope_room obj}
    , if obj == default_SyncScope{syncScope_chat = syncScope_chat obj} then P.Nothing else P.Just $ default_SyncScope{syncScope_chat = syncScope_chat obj}
    ]
from_SyncScope :: SyncScope -> T.ThriftVal
from_SyncScope record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1985 -> P.Just (1, ("syncProfile",T.TBool _v1985))) $ syncScope_syncProfile record
  , (\_v1985 -> P.Just (2, ("syncSettings",T.TBool _v1985))) $ syncScope_syncSettings record
  , (\_v1985 -> P.Just (3, ("syncSticker",T.TBool _v1985))) $ syncScope_syncSticker record
  , (\_v1985 -> P.Just (4, ("syncThemeShop",T.TBool _v1985))) $ syncScope_syncThemeShop record
  , (\_v1985 -> P.Just (10, ("contact",from_SyncRelations _v1985))) $ syncScope_contact record
  , (\_v1985 -> P.Just (11, ("group",from_SyncRelations _v1985))) $ syncScope_group record
  , (\_v1985 -> P.Just (12, ("room",from_SyncRelations _v1985))) $ syncScope_room record
  , (\_v1985 -> P.Just (13, ("chat",from_SyncRelations _v1985))) $ syncScope_chat record
  ]
write_SyncScope :: T.Protocol p => p -> SyncScope -> P.IO ()
write_SyncScope oprot record = T.writeVal oprot $ from_SyncScope record
encode_SyncScope :: T.StatelessProtocol p => p -> SyncScope -> LBS.ByteString
encode_SyncScope oprot record = T.serializeVal oprot $ from_SyncScope record
to_SyncScope :: T.ThriftVal -> SyncScope
to_SyncScope (T.TStruct fields) = SyncScope{
  syncScope_syncProfile = P.maybe (syncScope_syncProfile default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TBool _val1988 -> _val1988; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncScope_syncSettings = P.maybe (syncScope_syncSettings default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TBool _val1989 -> _val1989; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncScope_syncSticker = P.maybe (syncScope_syncSticker default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TBool _val1990 -> _val1990; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  syncScope_syncThemeShop = P.maybe (syncScope_syncThemeShop default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TBool _val1991 -> _val1991; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  syncScope_contact = P.maybe (syncScope_contact default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TStruct _val1992 -> (to_SyncRelations (T.TStruct _val1992)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  syncScope_group = P.maybe (syncScope_group default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TStruct _val1993 -> (to_SyncRelations (T.TStruct _val1993)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  syncScope_room = P.maybe (syncScope_room default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TStruct _val1994 -> (to_SyncRelations (T.TStruct _val1994)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  syncScope_chat = P.maybe (syncScope_chat default_SyncScope) (\(_,_val1987) -> (case _val1987 of {T.TStruct _val1995 -> (to_SyncRelations (T.TStruct _val1995)); _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_SyncScope _ = P.error "not a struct"
read_SyncScope :: T.Protocol p => p -> P.IO SyncScope
read_SyncScope iprot = to_SyncScope <$> T.readVal iprot (T.T_STRUCT typemap_SyncScope)
decode_SyncScope :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncScope
decode_SyncScope iprot bs = to_SyncScope $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncScope) bs
typemap_SyncScope :: T.TypeMap
typemap_SyncScope = Map.fromList [(1,("syncProfile",T.T_BOOL)),(2,("syncSettings",T.T_BOOL)),(3,("syncSticker",T.T_BOOL)),(4,("syncThemeShop",T.T_BOOL)),(10,("contact",(T.T_STRUCT typemap_SyncRelations))),(11,("group",(T.T_STRUCT typemap_SyncRelations))),(12,("room",(T.T_STRUCT typemap_SyncRelations))),(13,("chat",(T.T_STRUCT typemap_SyncRelations)))]
default_SyncScope :: SyncScope
default_SyncScope = SyncScope{
  syncScope_syncProfile = P.False,
  syncScope_syncSettings = P.False,
  syncScope_syncSticker = P.False,
  syncScope_syncThemeShop = P.False,
  syncScope_contact = default_SyncRelations,
  syncScope_group = default_SyncRelations,
  syncScope_room = default_SyncRelations,
  syncScope_chat = default_SyncRelations}
data JoinSquareResponse = JoinSquareResponse  { joinSquareResponse_square :: Square
  , joinSquareResponse_squareAuthority :: SquareAuthority
  , joinSquareResponse_squareStatus :: SquareStatus
  , joinSquareResponse_squareMember :: SquareMember
  , joinSquareResponse_squareFeatureSet :: SquareFeatureSet
  , joinSquareResponse_noteStatus :: NoteStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareResponse_square record   `H.hashWithSalt` joinSquareResponse_squareAuthority record   `H.hashWithSalt` joinSquareResponse_squareStatus record   `H.hashWithSalt` joinSquareResponse_squareMember record   `H.hashWithSalt` joinSquareResponse_squareFeatureSet record   `H.hashWithSalt` joinSquareResponse_noteStatus record  
instance QC.Arbitrary JoinSquareResponse where 
  arbitrary = M.liftM JoinSquareResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JoinSquareResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareResponse{joinSquareResponse_square = joinSquareResponse_square obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_square = joinSquareResponse_square obj}
    , if obj == default_JoinSquareResponse{joinSquareResponse_squareAuthority = joinSquareResponse_squareAuthority obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_squareAuthority = joinSquareResponse_squareAuthority obj}
    , if obj == default_JoinSquareResponse{joinSquareResponse_squareStatus = joinSquareResponse_squareStatus obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_squareStatus = joinSquareResponse_squareStatus obj}
    , if obj == default_JoinSquareResponse{joinSquareResponse_squareMember = joinSquareResponse_squareMember obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_squareMember = joinSquareResponse_squareMember obj}
    , if obj == default_JoinSquareResponse{joinSquareResponse_squareFeatureSet = joinSquareResponse_squareFeatureSet obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_squareFeatureSet = joinSquareResponse_squareFeatureSet obj}
    , if obj == default_JoinSquareResponse{joinSquareResponse_noteStatus = joinSquareResponse_noteStatus obj} then P.Nothing else P.Just $ default_JoinSquareResponse{joinSquareResponse_noteStatus = joinSquareResponse_noteStatus obj}
    ]
from_JoinSquareResponse :: JoinSquareResponse -> T.ThriftVal
from_JoinSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1998 -> P.Just (1, ("square",from_Square _v1998))) $ joinSquareResponse_square record
  , (\_v1998 -> P.Just (2, ("squareAuthority",from_SquareAuthority _v1998))) $ joinSquareResponse_squareAuthority record
  , (\_v1998 -> P.Just (3, ("squareStatus",from_SquareStatus _v1998))) $ joinSquareResponse_squareStatus record
  , (\_v1998 -> P.Just (4, ("squareMember",from_SquareMember _v1998))) $ joinSquareResponse_squareMember record
  , (\_v1998 -> P.Just (5, ("squareFeatureSet",from_SquareFeatureSet _v1998))) $ joinSquareResponse_squareFeatureSet record
  , (\_v1998 -> P.Just (6, ("noteStatus",from_NoteStatus _v1998))) $ joinSquareResponse_noteStatus record
  ]
write_JoinSquareResponse :: T.Protocol p => p -> JoinSquareResponse -> P.IO ()
write_JoinSquareResponse oprot record = T.writeVal oprot $ from_JoinSquareResponse record
encode_JoinSquareResponse :: T.StatelessProtocol p => p -> JoinSquareResponse -> LBS.ByteString
encode_JoinSquareResponse oprot record = T.serializeVal oprot $ from_JoinSquareResponse record
to_JoinSquareResponse :: T.ThriftVal -> JoinSquareResponse
to_JoinSquareResponse (T.TStruct fields) = JoinSquareResponse{
  joinSquareResponse_square = P.maybe (joinSquareResponse_square default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2001 -> (to_Square (T.TStruct _val2001)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  joinSquareResponse_squareAuthority = P.maybe (joinSquareResponse_squareAuthority default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2002 -> (to_SquareAuthority (T.TStruct _val2002)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  joinSquareResponse_squareStatus = P.maybe (joinSquareResponse_squareStatus default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2003 -> (to_SquareStatus (T.TStruct _val2003)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  joinSquareResponse_squareMember = P.maybe (joinSquareResponse_squareMember default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2004 -> (to_SquareMember (T.TStruct _val2004)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  joinSquareResponse_squareFeatureSet = P.maybe (joinSquareResponse_squareFeatureSet default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2005 -> (to_SquareFeatureSet (T.TStruct _val2005)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  joinSquareResponse_noteStatus = P.maybe (joinSquareResponse_noteStatus default_JoinSquareResponse) (\(_,_val2000) -> (case _val2000 of {T.TStruct _val2006 -> (to_NoteStatus (T.TStruct _val2006)); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_JoinSquareResponse _ = P.error "not a struct"
read_JoinSquareResponse :: T.Protocol p => p -> P.IO JoinSquareResponse
read_JoinSquareResponse iprot = to_JoinSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareResponse)
decode_JoinSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareResponse
decode_JoinSquareResponse iprot bs = to_JoinSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareResponse) bs
typemap_JoinSquareResponse :: T.TypeMap
typemap_JoinSquareResponse = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("squareAuthority",(T.T_STRUCT typemap_SquareAuthority))),(3,("squareStatus",(T.T_STRUCT typemap_SquareStatus))),(4,("squareMember",(T.T_STRUCT typemap_SquareMember))),(5,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet))),(6,("noteStatus",(T.T_STRUCT typemap_NoteStatus)))]
default_JoinSquareResponse :: JoinSquareResponse
default_JoinSquareResponse = JoinSquareResponse{
  joinSquareResponse_square = default_Square,
  joinSquareResponse_squareAuthority = default_SquareAuthority,
  joinSquareResponse_squareStatus = default_SquareStatus,
  joinSquareResponse_squareMember = default_SquareMember,
  joinSquareResponse_squareFeatureSet = default_SquareFeatureSet,
  joinSquareResponse_noteStatus = default_NoteStatus}
data JoinSquareRequest = JoinSquareRequest  { joinSquareRequest_squareMid :: LT.Text
  , joinSquareRequest_member :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareRequest_squareMid record   `H.hashWithSalt` joinSquareRequest_member record  
instance QC.Arbitrary JoinSquareRequest where 
  arbitrary = M.liftM JoinSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JoinSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareRequest{joinSquareRequest_squareMid = joinSquareRequest_squareMid obj} then P.Nothing else P.Just $ default_JoinSquareRequest{joinSquareRequest_squareMid = joinSquareRequest_squareMid obj}
    , if obj == default_JoinSquareRequest{joinSquareRequest_member = joinSquareRequest_member obj} then P.Nothing else P.Just $ default_JoinSquareRequest{joinSquareRequest_member = joinSquareRequest_member obj}
    ]
from_JoinSquareRequest :: JoinSquareRequest -> T.ThriftVal
from_JoinSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2009 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2009))) $ joinSquareRequest_squareMid record
  , (\_v2009 -> P.Just (3, ("member",from_SquareMember _v2009))) $ joinSquareRequest_member record
  ]
write_JoinSquareRequest :: T.Protocol p => p -> JoinSquareRequest -> P.IO ()
write_JoinSquareRequest oprot record = T.writeVal oprot $ from_JoinSquareRequest record
encode_JoinSquareRequest :: T.StatelessProtocol p => p -> JoinSquareRequest -> LBS.ByteString
encode_JoinSquareRequest oprot record = T.serializeVal oprot $ from_JoinSquareRequest record
to_JoinSquareRequest :: T.ThriftVal -> JoinSquareRequest
to_JoinSquareRequest (T.TStruct fields) = JoinSquareRequest{
  joinSquareRequest_squareMid = P.maybe (joinSquareRequest_squareMid default_JoinSquareRequest) (\(_,_val2011) -> (case _val2011 of {T.TString _val2012 -> E.decodeUtf8 _val2012; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  joinSquareRequest_member = P.maybe (joinSquareRequest_member default_JoinSquareRequest) (\(_,_val2011) -> (case _val2011 of {T.TStruct _val2013 -> (to_SquareMember (T.TStruct _val2013)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JoinSquareRequest _ = P.error "not a struct"
read_JoinSquareRequest :: T.Protocol p => p -> P.IO JoinSquareRequest
read_JoinSquareRequest iprot = to_JoinSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareRequest)
decode_JoinSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareRequest
decode_JoinSquareRequest iprot bs = to_JoinSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareRequest) bs
typemap_JoinSquareRequest :: T.TypeMap
typemap_JoinSquareRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("member",(T.T_STRUCT typemap_SquareMember)))]
default_JoinSquareRequest :: JoinSquareRequest
default_JoinSquareRequest = JoinSquareRequest{
  joinSquareRequest_squareMid = "",
  joinSquareRequest_member = default_SquareMember}
data JoinSquareChatResponse = JoinSquareChatResponse  { joinSquareChatResponse_squareChat :: SquareChat
  , joinSquareChatResponse_squareChatStatus :: SquareChatStatus
  , joinSquareChatResponse_squareChatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareChatResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareChatResponse_squareChat record   `H.hashWithSalt` joinSquareChatResponse_squareChatStatus record   `H.hashWithSalt` joinSquareChatResponse_squareChatMember record  
instance QC.Arbitrary JoinSquareChatResponse where 
  arbitrary = M.liftM JoinSquareChatResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_JoinSquareChatResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareChatResponse{joinSquareChatResponse_squareChat = joinSquareChatResponse_squareChat obj} then P.Nothing else P.Just $ default_JoinSquareChatResponse{joinSquareChatResponse_squareChat = joinSquareChatResponse_squareChat obj}
    , if obj == default_JoinSquareChatResponse{joinSquareChatResponse_squareChatStatus = joinSquareChatResponse_squareChatStatus obj} then P.Nothing else P.Just $ default_JoinSquareChatResponse{joinSquareChatResponse_squareChatStatus = joinSquareChatResponse_squareChatStatus obj}
    , if obj == default_JoinSquareChatResponse{joinSquareChatResponse_squareChatMember = joinSquareChatResponse_squareChatMember obj} then P.Nothing else P.Just $ default_JoinSquareChatResponse{joinSquareChatResponse_squareChatMember = joinSquareChatResponse_squareChatMember obj}
    ]
from_JoinSquareChatResponse :: JoinSquareChatResponse -> T.ThriftVal
from_JoinSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2016 -> P.Just (1, ("squareChat",from_SquareChat _v2016))) $ joinSquareChatResponse_squareChat record
  , (\_v2016 -> P.Just (2, ("squareChatStatus",from_SquareChatStatus _v2016))) $ joinSquareChatResponse_squareChatStatus record
  , (\_v2016 -> P.Just (3, ("squareChatMember",from_SquareChatMember _v2016))) $ joinSquareChatResponse_squareChatMember record
  ]
write_JoinSquareChatResponse :: T.Protocol p => p -> JoinSquareChatResponse -> P.IO ()
write_JoinSquareChatResponse oprot record = T.writeVal oprot $ from_JoinSquareChatResponse record
encode_JoinSquareChatResponse :: T.StatelessProtocol p => p -> JoinSquareChatResponse -> LBS.ByteString
encode_JoinSquareChatResponse oprot record = T.serializeVal oprot $ from_JoinSquareChatResponse record
to_JoinSquareChatResponse :: T.ThriftVal -> JoinSquareChatResponse
to_JoinSquareChatResponse (T.TStruct fields) = JoinSquareChatResponse{
  joinSquareChatResponse_squareChat = P.maybe (joinSquareChatResponse_squareChat default_JoinSquareChatResponse) (\(_,_val2018) -> (case _val2018 of {T.TStruct _val2019 -> (to_SquareChat (T.TStruct _val2019)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  joinSquareChatResponse_squareChatStatus = P.maybe (joinSquareChatResponse_squareChatStatus default_JoinSquareChatResponse) (\(_,_val2018) -> (case _val2018 of {T.TStruct _val2020 -> (to_SquareChatStatus (T.TStruct _val2020)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  joinSquareChatResponse_squareChatMember = P.maybe (joinSquareChatResponse_squareChatMember default_JoinSquareChatResponse) (\(_,_val2018) -> (case _val2018 of {T.TStruct _val2021 -> (to_SquareChatMember (T.TStruct _val2021)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_JoinSquareChatResponse _ = P.error "not a struct"
read_JoinSquareChatResponse :: T.Protocol p => p -> P.IO JoinSquareChatResponse
read_JoinSquareChatResponse iprot = to_JoinSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareChatResponse)
decode_JoinSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareChatResponse
decode_JoinSquareChatResponse iprot bs = to_JoinSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareChatResponse) bs
typemap_JoinSquareChatResponse :: T.TypeMap
typemap_JoinSquareChatResponse = Map.fromList [(1,("squareChat",(T.T_STRUCT typemap_SquareChat))),(2,("squareChatStatus",(T.T_STRUCT typemap_SquareChatStatus))),(3,("squareChatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_JoinSquareChatResponse :: JoinSquareChatResponse
default_JoinSquareChatResponse = JoinSquareChatResponse{
  joinSquareChatResponse_squareChat = default_SquareChat,
  joinSquareChatResponse_squareChatStatus = default_SquareChatStatus,
  joinSquareChatResponse_squareChatMember = default_SquareChatMember}
data JoinSquareChatRequest = JoinSquareChatRequest  { joinSquareChatRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareChatRequest_squareChatMid record  
instance QC.Arbitrary JoinSquareChatRequest where 
  arbitrary = M.liftM JoinSquareChatRequest (QC.arbitrary)
  shrink obj | obj == default_JoinSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareChatRequest{joinSquareChatRequest_squareChatMid = joinSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_JoinSquareChatRequest{joinSquareChatRequest_squareChatMid = joinSquareChatRequest_squareChatMid obj}
    ]
from_JoinSquareChatRequest :: JoinSquareChatRequest -> T.ThriftVal
from_JoinSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2024 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2024))) $ joinSquareChatRequest_squareChatMid record
  ]
write_JoinSquareChatRequest :: T.Protocol p => p -> JoinSquareChatRequest -> P.IO ()
write_JoinSquareChatRequest oprot record = T.writeVal oprot $ from_JoinSquareChatRequest record
encode_JoinSquareChatRequest :: T.StatelessProtocol p => p -> JoinSquareChatRequest -> LBS.ByteString
encode_JoinSquareChatRequest oprot record = T.serializeVal oprot $ from_JoinSquareChatRequest record
to_JoinSquareChatRequest :: T.ThriftVal -> JoinSquareChatRequest
to_JoinSquareChatRequest (T.TStruct fields) = JoinSquareChatRequest{
  joinSquareChatRequest_squareChatMid = P.maybe (joinSquareChatRequest_squareChatMid default_JoinSquareChatRequest) (\(_,_val2026) -> (case _val2026 of {T.TString _val2027 -> E.decodeUtf8 _val2027; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinSquareChatRequest _ = P.error "not a struct"
read_JoinSquareChatRequest :: T.Protocol p => p -> P.IO JoinSquareChatRequest
read_JoinSquareChatRequest iprot = to_JoinSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareChatRequest)
decode_JoinSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareChatRequest
decode_JoinSquareChatRequest iprot bs = to_JoinSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareChatRequest) bs
typemap_JoinSquareChatRequest :: T.TypeMap
typemap_JoinSquareChatRequest = Map.fromList [(1,("squareChatMid",T.T_STRING))]
default_JoinSquareChatRequest :: JoinSquareChatRequest
default_JoinSquareChatRequest = JoinSquareChatRequest{
  joinSquareChatRequest_squareChatMid = ""}
data SendMessageResponse = SendMessageResponse  { sendMessageResponse_createdSquareMessage :: SquareMessage
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageResponse_createdSquareMessage record  
instance QC.Arbitrary SendMessageResponse where 
  arbitrary = M.liftM SendMessageResponse (QC.arbitrary)
  shrink obj | obj == default_SendMessageResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageResponse{sendMessageResponse_createdSquareMessage = sendMessageResponse_createdSquareMessage obj} then P.Nothing else P.Just $ default_SendMessageResponse{sendMessageResponse_createdSquareMessage = sendMessageResponse_createdSquareMessage obj}
    ]
from_SendMessageResponse :: SendMessageResponse -> T.ThriftVal
from_SendMessageResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2030 -> P.Just (1, ("createdSquareMessage",from_SquareMessage _v2030))) $ sendMessageResponse_createdSquareMessage record
  ]
write_SendMessageResponse :: T.Protocol p => p -> SendMessageResponse -> P.IO ()
write_SendMessageResponse oprot record = T.writeVal oprot $ from_SendMessageResponse record
encode_SendMessageResponse :: T.StatelessProtocol p => p -> SendMessageResponse -> LBS.ByteString
encode_SendMessageResponse oprot record = T.serializeVal oprot $ from_SendMessageResponse record
to_SendMessageResponse :: T.ThriftVal -> SendMessageResponse
to_SendMessageResponse (T.TStruct fields) = SendMessageResponse{
  sendMessageResponse_createdSquareMessage = P.maybe (sendMessageResponse_createdSquareMessage default_SendMessageResponse) (\(_,_val2032) -> (case _val2032 of {T.TStruct _val2033 -> (to_SquareMessage (T.TStruct _val2033)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageResponse _ = P.error "not a struct"
read_SendMessageResponse :: T.Protocol p => p -> P.IO SendMessageResponse
read_SendMessageResponse iprot = to_SendMessageResponse <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageResponse)
decode_SendMessageResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageResponse
decode_SendMessageResponse iprot bs = to_SendMessageResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageResponse) bs
typemap_SendMessageResponse :: T.TypeMap
typemap_SendMessageResponse = Map.fromList [(1,("createdSquareMessage",(T.T_STRUCT typemap_SquareMessage)))]
default_SendMessageResponse :: SendMessageResponse
default_SendMessageResponse = SendMessageResponse{
  sendMessageResponse_createdSquareMessage = default_SquareMessage}
data SendMessageRequest = SendMessageRequest  { sendMessageRequest_reqSeq :: I.Int32
  , sendMessageRequest_squareChatMid :: LT.Text
  , sendMessageRequest_squareMessage :: SquareMessage
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageRequest_reqSeq record   `H.hashWithSalt` sendMessageRequest_squareChatMid record   `H.hashWithSalt` sendMessageRequest_squareMessage record  
instance QC.Arbitrary SendMessageRequest where 
  arbitrary = M.liftM SendMessageRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageRequest{sendMessageRequest_reqSeq = sendMessageRequest_reqSeq obj} then P.Nothing else P.Just $ default_SendMessageRequest{sendMessageRequest_reqSeq = sendMessageRequest_reqSeq obj}
    , if obj == default_SendMessageRequest{sendMessageRequest_squareChatMid = sendMessageRequest_squareChatMid obj} then P.Nothing else P.Just $ default_SendMessageRequest{sendMessageRequest_squareChatMid = sendMessageRequest_squareChatMid obj}
    , if obj == default_SendMessageRequest{sendMessageRequest_squareMessage = sendMessageRequest_squareMessage obj} then P.Nothing else P.Just $ default_SendMessageRequest{sendMessageRequest_squareMessage = sendMessageRequest_squareMessage obj}
    ]
from_SendMessageRequest :: SendMessageRequest -> T.ThriftVal
from_SendMessageRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2036 -> P.Just (1, ("reqSeq",T.TI32 _v2036))) $ sendMessageRequest_reqSeq record
  , (\_v2036 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2036))) $ sendMessageRequest_squareChatMid record
  , (\_v2036 -> P.Just (3, ("squareMessage",from_SquareMessage _v2036))) $ sendMessageRequest_squareMessage record
  ]
write_SendMessageRequest :: T.Protocol p => p -> SendMessageRequest -> P.IO ()
write_SendMessageRequest oprot record = T.writeVal oprot $ from_SendMessageRequest record
encode_SendMessageRequest :: T.StatelessProtocol p => p -> SendMessageRequest -> LBS.ByteString
encode_SendMessageRequest oprot record = T.serializeVal oprot $ from_SendMessageRequest record
to_SendMessageRequest :: T.ThriftVal -> SendMessageRequest
to_SendMessageRequest (T.TStruct fields) = SendMessageRequest{
  sendMessageRequest_reqSeq = P.maybe (sendMessageRequest_reqSeq default_SendMessageRequest) (\(_,_val2038) -> (case _val2038 of {T.TI32 _val2039 -> _val2039; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageRequest_squareChatMid = P.maybe (sendMessageRequest_squareChatMid default_SendMessageRequest) (\(_,_val2038) -> (case _val2038 of {T.TString _val2040 -> E.decodeUtf8 _val2040; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendMessageRequest_squareMessage = P.maybe (sendMessageRequest_squareMessage default_SendMessageRequest) (\(_,_val2038) -> (case _val2038 of {T.TStruct _val2041 -> (to_SquareMessage (T.TStruct _val2041)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendMessageRequest _ = P.error "not a struct"
read_SendMessageRequest :: T.Protocol p => p -> P.IO SendMessageRequest
read_SendMessageRequest iprot = to_SendMessageRequest <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageRequest)
decode_SendMessageRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageRequest
decode_SendMessageRequest iprot bs = to_SendMessageRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageRequest) bs
typemap_SendMessageRequest :: T.TypeMap
typemap_SendMessageRequest = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("squareChatMid",T.T_STRING)),(3,("squareMessage",(T.T_STRUCT typemap_SquareMessage)))]
default_SendMessageRequest :: SendMessageRequest
default_SendMessageRequest = SendMessageRequest{
  sendMessageRequest_reqSeq = 0,
  sendMessageRequest_squareChatMid = "",
  sendMessageRequest_squareMessage = default_SquareMessage}
data MarkAsReadRequest = MarkAsReadRequest  { markAsReadRequest_squareChatMid :: LT.Text
  , markAsReadRequest_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkAsReadRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` markAsReadRequest_squareChatMid record   `H.hashWithSalt` markAsReadRequest_messageId record  
instance QC.Arbitrary MarkAsReadRequest where 
  arbitrary = M.liftM MarkAsReadRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MarkAsReadRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkAsReadRequest{markAsReadRequest_squareChatMid = markAsReadRequest_squareChatMid obj} then P.Nothing else P.Just $ default_MarkAsReadRequest{markAsReadRequest_squareChatMid = markAsReadRequest_squareChatMid obj}
    , if obj == default_MarkAsReadRequest{markAsReadRequest_messageId = markAsReadRequest_messageId obj} then P.Nothing else P.Just $ default_MarkAsReadRequest{markAsReadRequest_messageId = markAsReadRequest_messageId obj}
    ]
from_MarkAsReadRequest :: MarkAsReadRequest -> T.ThriftVal
from_MarkAsReadRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2044 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2044))) $ markAsReadRequest_squareChatMid record
  , (\_v2044 -> P.Just (4, ("messageId",T.TString $ E.encodeUtf8 _v2044))) $ markAsReadRequest_messageId record
  ]
write_MarkAsReadRequest :: T.Protocol p => p -> MarkAsReadRequest -> P.IO ()
write_MarkAsReadRequest oprot record = T.writeVal oprot $ from_MarkAsReadRequest record
encode_MarkAsReadRequest :: T.StatelessProtocol p => p -> MarkAsReadRequest -> LBS.ByteString
encode_MarkAsReadRequest oprot record = T.serializeVal oprot $ from_MarkAsReadRequest record
to_MarkAsReadRequest :: T.ThriftVal -> MarkAsReadRequest
to_MarkAsReadRequest (T.TStruct fields) = MarkAsReadRequest{
  markAsReadRequest_squareChatMid = P.maybe (markAsReadRequest_squareChatMid default_MarkAsReadRequest) (\(_,_val2046) -> (case _val2046 of {T.TString _val2047 -> E.decodeUtf8 _val2047; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  markAsReadRequest_messageId = P.maybe (markAsReadRequest_messageId default_MarkAsReadRequest) (\(_,_val2046) -> (case _val2046 of {T.TString _val2048 -> E.decodeUtf8 _val2048; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_MarkAsReadRequest _ = P.error "not a struct"
read_MarkAsReadRequest :: T.Protocol p => p -> P.IO MarkAsReadRequest
read_MarkAsReadRequest iprot = to_MarkAsReadRequest <$> T.readVal iprot (T.T_STRUCT typemap_MarkAsReadRequest)
decode_MarkAsReadRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkAsReadRequest
decode_MarkAsReadRequest iprot bs = to_MarkAsReadRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkAsReadRequest) bs
typemap_MarkAsReadRequest :: T.TypeMap
typemap_MarkAsReadRequest = Map.fromList [(2,("squareChatMid",T.T_STRING)),(4,("messageId",T.T_STRING))]
default_MarkAsReadRequest :: MarkAsReadRequest
default_MarkAsReadRequest = MarkAsReadRequest{
  markAsReadRequest_squareChatMid = "",
  markAsReadRequest_messageId = ""}
data MarkAsReadResponse = MarkAsReadResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkAsReadResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary MarkAsReadResponse where 
  arbitrary = QC.elements [MarkAsReadResponse]
from_MarkAsReadResponse :: MarkAsReadResponse -> T.ThriftVal
from_MarkAsReadResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_MarkAsReadResponse :: T.Protocol p => p -> MarkAsReadResponse -> P.IO ()
write_MarkAsReadResponse oprot record = T.writeVal oprot $ from_MarkAsReadResponse record
encode_MarkAsReadResponse :: T.StatelessProtocol p => p -> MarkAsReadResponse -> LBS.ByteString
encode_MarkAsReadResponse oprot record = T.serializeVal oprot $ from_MarkAsReadResponse record
to_MarkAsReadResponse :: T.ThriftVal -> MarkAsReadResponse
to_MarkAsReadResponse (T.TStruct fields) = MarkAsReadResponse{

  }
to_MarkAsReadResponse _ = P.error "not a struct"
read_MarkAsReadResponse :: T.Protocol p => p -> P.IO MarkAsReadResponse
read_MarkAsReadResponse iprot = to_MarkAsReadResponse <$> T.readVal iprot (T.T_STRUCT typemap_MarkAsReadResponse)
decode_MarkAsReadResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkAsReadResponse
decode_MarkAsReadResponse iprot bs = to_MarkAsReadResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkAsReadResponse) bs
typemap_MarkAsReadResponse :: T.TypeMap
typemap_MarkAsReadResponse = Map.fromList []
default_MarkAsReadResponse :: MarkAsReadResponse
default_MarkAsReadResponse = MarkAsReadResponse{
}
data SubscriptionState = SubscriptionState  { subscriptionState_subscriptionId :: I.Int64
  , subscriptionState_ttlMillis :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SubscriptionState where
  hashWithSalt salt record = salt   `H.hashWithSalt` subscriptionState_subscriptionId record   `H.hashWithSalt` subscriptionState_ttlMillis record  
instance QC.Arbitrary SubscriptionState where 
  arbitrary = M.liftM SubscriptionState (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SubscriptionState = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SubscriptionState{subscriptionState_subscriptionId = subscriptionState_subscriptionId obj} then P.Nothing else P.Just $ default_SubscriptionState{subscriptionState_subscriptionId = subscriptionState_subscriptionId obj}
    , if obj == default_SubscriptionState{subscriptionState_ttlMillis = subscriptionState_ttlMillis obj} then P.Nothing else P.Just $ default_SubscriptionState{subscriptionState_ttlMillis = subscriptionState_ttlMillis obj}
    ]
from_SubscriptionState :: SubscriptionState -> T.ThriftVal
from_SubscriptionState record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2056 -> P.Just (1, ("subscriptionId",T.TI64 _v2056))) $ subscriptionState_subscriptionId record
  , (\_v2056 -> P.Just (2, ("ttlMillis",T.TI64 _v2056))) $ subscriptionState_ttlMillis record
  ]
write_SubscriptionState :: T.Protocol p => p -> SubscriptionState -> P.IO ()
write_SubscriptionState oprot record = T.writeVal oprot $ from_SubscriptionState record
encode_SubscriptionState :: T.StatelessProtocol p => p -> SubscriptionState -> LBS.ByteString
encode_SubscriptionState oprot record = T.serializeVal oprot $ from_SubscriptionState record
to_SubscriptionState :: T.ThriftVal -> SubscriptionState
to_SubscriptionState (T.TStruct fields) = SubscriptionState{
  subscriptionState_subscriptionId = P.maybe (subscriptionState_subscriptionId default_SubscriptionState) (\(_,_val2058) -> (case _val2058 of {T.TI64 _val2059 -> _val2059; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  subscriptionState_ttlMillis = P.maybe (subscriptionState_ttlMillis default_SubscriptionState) (\(_,_val2058) -> (case _val2058 of {T.TI64 _val2060 -> _val2060; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SubscriptionState _ = P.error "not a struct"
read_SubscriptionState :: T.Protocol p => p -> P.IO SubscriptionState
read_SubscriptionState iprot = to_SubscriptionState <$> T.readVal iprot (T.T_STRUCT typemap_SubscriptionState)
decode_SubscriptionState :: T.StatelessProtocol p => p -> LBS.ByteString -> SubscriptionState
decode_SubscriptionState iprot bs = to_SubscriptionState $ T.deserializeVal iprot (T.T_STRUCT typemap_SubscriptionState) bs
typemap_SubscriptionState :: T.TypeMap
typemap_SubscriptionState = Map.fromList [(1,("subscriptionId",T.T_I64)),(2,("ttlMillis",T.T_I64))]
default_SubscriptionState :: SubscriptionState
default_SubscriptionState = SubscriptionState{
  subscriptionState_subscriptionId = 0,
  subscriptionState_ttlMillis = 0}
data ApproveSquareMembersResponse = ApproveSquareMembersResponse  { approveSquareMembersResponse_approvedMembers :: (Vector.Vector SquareMember)
  , approveSquareMembersResponse_status :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveSquareMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveSquareMembersResponse_approvedMembers record   `H.hashWithSalt` approveSquareMembersResponse_status record  
instance QC.Arbitrary ApproveSquareMembersResponse where 
  arbitrary = M.liftM ApproveSquareMembersResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApproveSquareMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveSquareMembersResponse{approveSquareMembersResponse_approvedMembers = approveSquareMembersResponse_approvedMembers obj} then P.Nothing else P.Just $ default_ApproveSquareMembersResponse{approveSquareMembersResponse_approvedMembers = approveSquareMembersResponse_approvedMembers obj}
    , if obj == default_ApproveSquareMembersResponse{approveSquareMembersResponse_status = approveSquareMembersResponse_status obj} then P.Nothing else P.Just $ default_ApproveSquareMembersResponse{approveSquareMembersResponse_status = approveSquareMembersResponse_status obj}
    ]
from_ApproveSquareMembersResponse :: ApproveSquareMembersResponse -> T.ThriftVal
from_ApproveSquareMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2063 -> P.Just (1, ("approvedMembers",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2065 -> from_SquareMember _v2065) $ Vector.toList _v2063))) $ approveSquareMembersResponse_approvedMembers record
  , (\_v2063 -> P.Just (2, ("status",from_SquareStatus _v2063))) $ approveSquareMembersResponse_status record
  ]
write_ApproveSquareMembersResponse :: T.Protocol p => p -> ApproveSquareMembersResponse -> P.IO ()
write_ApproveSquareMembersResponse oprot record = T.writeVal oprot $ from_ApproveSquareMembersResponse record
encode_ApproveSquareMembersResponse :: T.StatelessProtocol p => p -> ApproveSquareMembersResponse -> LBS.ByteString
encode_ApproveSquareMembersResponse oprot record = T.serializeVal oprot $ from_ApproveSquareMembersResponse record
to_ApproveSquareMembersResponse :: T.ThriftVal -> ApproveSquareMembersResponse
to_ApproveSquareMembersResponse (T.TStruct fields) = ApproveSquareMembersResponse{
  approveSquareMembersResponse_approvedMembers = P.maybe (approveSquareMembersResponse_approvedMembers default_ApproveSquareMembersResponse) (\(_,_val2067) -> (case _val2067 of {T.TList _ _val2068 -> (Vector.fromList $ P.map (\_v2069 -> (case _v2069 of {T.TStruct _val2070 -> (to_SquareMember (T.TStruct _val2070)); _ -> P.error "wrong type"})) _val2068); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  approveSquareMembersResponse_status = P.maybe (approveSquareMembersResponse_status default_ApproveSquareMembersResponse) (\(_,_val2067) -> (case _val2067 of {T.TStruct _val2071 -> (to_SquareStatus (T.TStruct _val2071)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ApproveSquareMembersResponse _ = P.error "not a struct"
read_ApproveSquareMembersResponse :: T.Protocol p => p -> P.IO ApproveSquareMembersResponse
read_ApproveSquareMembersResponse iprot = to_ApproveSquareMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_ApproveSquareMembersResponse)
decode_ApproveSquareMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveSquareMembersResponse
decode_ApproveSquareMembersResponse iprot bs = to_ApproveSquareMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveSquareMembersResponse) bs
typemap_ApproveSquareMembersResponse :: T.TypeMap
typemap_ApproveSquareMembersResponse = Map.fromList [(1,("approvedMembers",(T.T_LIST (T.T_STRUCT typemap_SquareMember)))),(2,("status",(T.T_STRUCT typemap_SquareStatus)))]
default_ApproveSquareMembersResponse :: ApproveSquareMembersResponse
default_ApproveSquareMembersResponse = ApproveSquareMembersResponse{
  approveSquareMembersResponse_approvedMembers = Vector.empty,
  approveSquareMembersResponse_status = default_SquareStatus}
data ApproveSquareMembersRequest = ApproveSquareMembersRequest  { approveSquareMembersRequest_squareMid :: LT.Text
  , approveSquareMembersRequest_requestedMemberMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveSquareMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveSquareMembersRequest_squareMid record   `H.hashWithSalt` approveSquareMembersRequest_requestedMemberMids record  
instance QC.Arbitrary ApproveSquareMembersRequest where 
  arbitrary = M.liftM ApproveSquareMembersRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ApproveSquareMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveSquareMembersRequest{approveSquareMembersRequest_squareMid = approveSquareMembersRequest_squareMid obj} then P.Nothing else P.Just $ default_ApproveSquareMembersRequest{approveSquareMembersRequest_squareMid = approveSquareMembersRequest_squareMid obj}
    , if obj == default_ApproveSquareMembersRequest{approveSquareMembersRequest_requestedMemberMids = approveSquareMembersRequest_requestedMemberMids obj} then P.Nothing else P.Just $ default_ApproveSquareMembersRequest{approveSquareMembersRequest_requestedMemberMids = approveSquareMembersRequest_requestedMemberMids obj}
    ]
from_ApproveSquareMembersRequest :: ApproveSquareMembersRequest -> T.ThriftVal
from_ApproveSquareMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2074 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2074))) $ approveSquareMembersRequest_squareMid record
  , (\_v2074 -> P.Just (3, ("requestedMemberMids",T.TList T.T_STRING $ P.map (\_v2076 -> T.TString $ E.encodeUtf8 _v2076) $ Vector.toList _v2074))) $ approveSquareMembersRequest_requestedMemberMids record
  ]
write_ApproveSquareMembersRequest :: T.Protocol p => p -> ApproveSquareMembersRequest -> P.IO ()
write_ApproveSquareMembersRequest oprot record = T.writeVal oprot $ from_ApproveSquareMembersRequest record
encode_ApproveSquareMembersRequest :: T.StatelessProtocol p => p -> ApproveSquareMembersRequest -> LBS.ByteString
encode_ApproveSquareMembersRequest oprot record = T.serializeVal oprot $ from_ApproveSquareMembersRequest record
to_ApproveSquareMembersRequest :: T.ThriftVal -> ApproveSquareMembersRequest
to_ApproveSquareMembersRequest (T.TStruct fields) = ApproveSquareMembersRequest{
  approveSquareMembersRequest_squareMid = P.maybe (approveSquareMembersRequest_squareMid default_ApproveSquareMembersRequest) (\(_,_val2078) -> (case _val2078 of {T.TString _val2079 -> E.decodeUtf8 _val2079; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  approveSquareMembersRequest_requestedMemberMids = P.maybe (approveSquareMembersRequest_requestedMemberMids default_ApproveSquareMembersRequest) (\(_,_val2078) -> (case _val2078 of {T.TList _ _val2080 -> (Vector.fromList $ P.map (\_v2081 -> (case _v2081 of {T.TString _val2082 -> E.decodeUtf8 _val2082; _ -> P.error "wrong type"})) _val2080); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ApproveSquareMembersRequest _ = P.error "not a struct"
read_ApproveSquareMembersRequest :: T.Protocol p => p -> P.IO ApproveSquareMembersRequest
read_ApproveSquareMembersRequest iprot = to_ApproveSquareMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_ApproveSquareMembersRequest)
decode_ApproveSquareMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveSquareMembersRequest
decode_ApproveSquareMembersRequest iprot bs = to_ApproveSquareMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveSquareMembersRequest) bs
typemap_ApproveSquareMembersRequest :: T.TypeMap
typemap_ApproveSquareMembersRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("requestedMemberMids",(T.T_LIST T.T_STRING)))]
default_ApproveSquareMembersRequest :: ApproveSquareMembersRequest
default_ApproveSquareMembersRequest = ApproveSquareMembersRequest{
  approveSquareMembersRequest_squareMid = "",
  approveSquareMembersRequest_requestedMemberMids = Vector.empty}
data CreateSquareChatResponse = CreateSquareChatResponse  { createSquareChatResponse_squareChat :: SquareChat
  , createSquareChatResponse_squareChatStatus :: SquareChatStatus
  , createSquareChatResponse_squareChatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatResponse_squareChat record   `H.hashWithSalt` createSquareChatResponse_squareChatStatus record   `H.hashWithSalt` createSquareChatResponse_squareChatMember record  
instance QC.Arbitrary CreateSquareChatResponse where 
  arbitrary = M.liftM CreateSquareChatResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatResponse{createSquareChatResponse_squareChat = createSquareChatResponse_squareChat obj} then P.Nothing else P.Just $ default_CreateSquareChatResponse{createSquareChatResponse_squareChat = createSquareChatResponse_squareChat obj}
    , if obj == default_CreateSquareChatResponse{createSquareChatResponse_squareChatStatus = createSquareChatResponse_squareChatStatus obj} then P.Nothing else P.Just $ default_CreateSquareChatResponse{createSquareChatResponse_squareChatStatus = createSquareChatResponse_squareChatStatus obj}
    , if obj == default_CreateSquareChatResponse{createSquareChatResponse_squareChatMember = createSquareChatResponse_squareChatMember obj} then P.Nothing else P.Just $ default_CreateSquareChatResponse{createSquareChatResponse_squareChatMember = createSquareChatResponse_squareChatMember obj}
    ]
from_CreateSquareChatResponse :: CreateSquareChatResponse -> T.ThriftVal
from_CreateSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2085 -> P.Just (1, ("squareChat",from_SquareChat _v2085))) $ createSquareChatResponse_squareChat record
  , (\_v2085 -> P.Just (2, ("squareChatStatus",from_SquareChatStatus _v2085))) $ createSquareChatResponse_squareChatStatus record
  , (\_v2085 -> P.Just (3, ("squareChatMember",from_SquareChatMember _v2085))) $ createSquareChatResponse_squareChatMember record
  ]
write_CreateSquareChatResponse :: T.Protocol p => p -> CreateSquareChatResponse -> P.IO ()
write_CreateSquareChatResponse oprot record = T.writeVal oprot $ from_CreateSquareChatResponse record
encode_CreateSquareChatResponse :: T.StatelessProtocol p => p -> CreateSquareChatResponse -> LBS.ByteString
encode_CreateSquareChatResponse oprot record = T.serializeVal oprot $ from_CreateSquareChatResponse record
to_CreateSquareChatResponse :: T.ThriftVal -> CreateSquareChatResponse
to_CreateSquareChatResponse (T.TStruct fields) = CreateSquareChatResponse{
  createSquareChatResponse_squareChat = P.maybe (createSquareChatResponse_squareChat default_CreateSquareChatResponse) (\(_,_val2087) -> (case _val2087 of {T.TStruct _val2088 -> (to_SquareChat (T.TStruct _val2088)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSquareChatResponse_squareChatStatus = P.maybe (createSquareChatResponse_squareChatStatus default_CreateSquareChatResponse) (\(_,_val2087) -> (case _val2087 of {T.TStruct _val2089 -> (to_SquareChatStatus (T.TStruct _val2089)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createSquareChatResponse_squareChatMember = P.maybe (createSquareChatResponse_squareChatMember default_CreateSquareChatResponse) (\(_,_val2087) -> (case _val2087 of {T.TStruct _val2090 -> (to_SquareChatMember (T.TStruct _val2090)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateSquareChatResponse _ = P.error "not a struct"
read_CreateSquareChatResponse :: T.Protocol p => p -> P.IO CreateSquareChatResponse
read_CreateSquareChatResponse iprot = to_CreateSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatResponse)
decode_CreateSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatResponse
decode_CreateSquareChatResponse iprot bs = to_CreateSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatResponse) bs
typemap_CreateSquareChatResponse :: T.TypeMap
typemap_CreateSquareChatResponse = Map.fromList [(1,("squareChat",(T.T_STRUCT typemap_SquareChat))),(2,("squareChatStatus",(T.T_STRUCT typemap_SquareChatStatus))),(3,("squareChatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_CreateSquareChatResponse :: CreateSquareChatResponse
default_CreateSquareChatResponse = CreateSquareChatResponse{
  createSquareChatResponse_squareChat = default_SquareChat,
  createSquareChatResponse_squareChatStatus = default_SquareChatStatus,
  createSquareChatResponse_squareChatMember = default_SquareChatMember}
data CreateSquareChatRequest = CreateSquareChatRequest  { createSquareChatRequest_reqSeq :: I.Int32
  , createSquareChatRequest_squareChat :: SquareChat
  , createSquareChatRequest_squareMemberMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatRequest_reqSeq record   `H.hashWithSalt` createSquareChatRequest_squareChat record   `H.hashWithSalt` createSquareChatRequest_squareMemberMids record  
instance QC.Arbitrary CreateSquareChatRequest where 
  arbitrary = M.liftM CreateSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatRequest{createSquareChatRequest_reqSeq = createSquareChatRequest_reqSeq obj} then P.Nothing else P.Just $ default_CreateSquareChatRequest{createSquareChatRequest_reqSeq = createSquareChatRequest_reqSeq obj}
    , if obj == default_CreateSquareChatRequest{createSquareChatRequest_squareChat = createSquareChatRequest_squareChat obj} then P.Nothing else P.Just $ default_CreateSquareChatRequest{createSquareChatRequest_squareChat = createSquareChatRequest_squareChat obj}
    , if obj == default_CreateSquareChatRequest{createSquareChatRequest_squareMemberMids = createSquareChatRequest_squareMemberMids obj} then P.Nothing else P.Just $ default_CreateSquareChatRequest{createSquareChatRequest_squareMemberMids = createSquareChatRequest_squareMemberMids obj}
    ]
from_CreateSquareChatRequest :: CreateSquareChatRequest -> T.ThriftVal
from_CreateSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2093 -> P.Just (1, ("reqSeq",T.TI32 _v2093))) $ createSquareChatRequest_reqSeq record
  , (\_v2093 -> P.Just (2, ("squareChat",from_SquareChat _v2093))) $ createSquareChatRequest_squareChat record
  , (\_v2093 -> P.Just (3, ("squareMemberMids",T.TList T.T_STRING $ P.map (\_v2095 -> T.TString $ E.encodeUtf8 _v2095) $ Vector.toList _v2093))) $ createSquareChatRequest_squareMemberMids record
  ]
write_CreateSquareChatRequest :: T.Protocol p => p -> CreateSquareChatRequest -> P.IO ()
write_CreateSquareChatRequest oprot record = T.writeVal oprot $ from_CreateSquareChatRequest record
encode_CreateSquareChatRequest :: T.StatelessProtocol p => p -> CreateSquareChatRequest -> LBS.ByteString
encode_CreateSquareChatRequest oprot record = T.serializeVal oprot $ from_CreateSquareChatRequest record
to_CreateSquareChatRequest :: T.ThriftVal -> CreateSquareChatRequest
to_CreateSquareChatRequest (T.TStruct fields) = CreateSquareChatRequest{
  createSquareChatRequest_reqSeq = P.maybe (createSquareChatRequest_reqSeq default_CreateSquareChatRequest) (\(_,_val2097) -> (case _val2097 of {T.TI32 _val2098 -> _val2098; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSquareChatRequest_squareChat = P.maybe (createSquareChatRequest_squareChat default_CreateSquareChatRequest) (\(_,_val2097) -> (case _val2097 of {T.TStruct _val2099 -> (to_SquareChat (T.TStruct _val2099)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createSquareChatRequest_squareMemberMids = P.maybe (createSquareChatRequest_squareMemberMids default_CreateSquareChatRequest) (\(_,_val2097) -> (case _val2097 of {T.TList _ _val2100 -> (Vector.fromList $ P.map (\_v2101 -> (case _v2101 of {T.TString _val2102 -> E.decodeUtf8 _val2102; _ -> P.error "wrong type"})) _val2100); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateSquareChatRequest _ = P.error "not a struct"
read_CreateSquareChatRequest :: T.Protocol p => p -> P.IO CreateSquareChatRequest
read_CreateSquareChatRequest iprot = to_CreateSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatRequest)
decode_CreateSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatRequest
decode_CreateSquareChatRequest iprot bs = to_CreateSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatRequest) bs
typemap_CreateSquareChatRequest :: T.TypeMap
typemap_CreateSquareChatRequest = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("squareChat",(T.T_STRUCT typemap_SquareChat))),(3,("squareMemberMids",(T.T_LIST T.T_STRING)))]
default_CreateSquareChatRequest :: CreateSquareChatRequest
default_CreateSquareChatRequest = CreateSquareChatRequest{
  createSquareChatRequest_reqSeq = 0,
  createSquareChatRequest_squareChat = default_SquareChat,
  createSquareChatRequest_squareMemberMids = Vector.empty}
data CreateSquareResponse = CreateSquareResponse  { createSquareResponse_square :: Square
  , createSquareResponse_creator :: SquareMember
  , createSquareResponse_authority :: SquareAuthority
  , createSquareResponse_status :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareResponse_square record   `H.hashWithSalt` createSquareResponse_creator record   `H.hashWithSalt` createSquareResponse_authority record   `H.hashWithSalt` createSquareResponse_status record  
instance QC.Arbitrary CreateSquareResponse where 
  arbitrary = M.liftM CreateSquareResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSquareResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareResponse{createSquareResponse_square = createSquareResponse_square obj} then P.Nothing else P.Just $ default_CreateSquareResponse{createSquareResponse_square = createSquareResponse_square obj}
    , if obj == default_CreateSquareResponse{createSquareResponse_creator = createSquareResponse_creator obj} then P.Nothing else P.Just $ default_CreateSquareResponse{createSquareResponse_creator = createSquareResponse_creator obj}
    , if obj == default_CreateSquareResponse{createSquareResponse_authority = createSquareResponse_authority obj} then P.Nothing else P.Just $ default_CreateSquareResponse{createSquareResponse_authority = createSquareResponse_authority obj}
    , if obj == default_CreateSquareResponse{createSquareResponse_status = createSquareResponse_status obj} then P.Nothing else P.Just $ default_CreateSquareResponse{createSquareResponse_status = createSquareResponse_status obj}
    ]
from_CreateSquareResponse :: CreateSquareResponse -> T.ThriftVal
from_CreateSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2105 -> P.Just (1, ("square",from_Square _v2105))) $ createSquareResponse_square record
  , (\_v2105 -> P.Just (2, ("creator",from_SquareMember _v2105))) $ createSquareResponse_creator record
  , (\_v2105 -> P.Just (3, ("authority",from_SquareAuthority _v2105))) $ createSquareResponse_authority record
  , (\_v2105 -> P.Just (4, ("status",from_SquareStatus _v2105))) $ createSquareResponse_status record
  ]
write_CreateSquareResponse :: T.Protocol p => p -> CreateSquareResponse -> P.IO ()
write_CreateSquareResponse oprot record = T.writeVal oprot $ from_CreateSquareResponse record
encode_CreateSquareResponse :: T.StatelessProtocol p => p -> CreateSquareResponse -> LBS.ByteString
encode_CreateSquareResponse oprot record = T.serializeVal oprot $ from_CreateSquareResponse record
to_CreateSquareResponse :: T.ThriftVal -> CreateSquareResponse
to_CreateSquareResponse (T.TStruct fields) = CreateSquareResponse{
  createSquareResponse_square = P.maybe (createSquareResponse_square default_CreateSquareResponse) (\(_,_val2107) -> (case _val2107 of {T.TStruct _val2108 -> (to_Square (T.TStruct _val2108)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSquareResponse_creator = P.maybe (createSquareResponse_creator default_CreateSquareResponse) (\(_,_val2107) -> (case _val2107 of {T.TStruct _val2109 -> (to_SquareMember (T.TStruct _val2109)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createSquareResponse_authority = P.maybe (createSquareResponse_authority default_CreateSquareResponse) (\(_,_val2107) -> (case _val2107 of {T.TStruct _val2110 -> (to_SquareAuthority (T.TStruct _val2110)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createSquareResponse_status = P.maybe (createSquareResponse_status default_CreateSquareResponse) (\(_,_val2107) -> (case _val2107 of {T.TStruct _val2111 -> (to_SquareStatus (T.TStruct _val2111)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CreateSquareResponse _ = P.error "not a struct"
read_CreateSquareResponse :: T.Protocol p => p -> P.IO CreateSquareResponse
read_CreateSquareResponse iprot = to_CreateSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareResponse)
decode_CreateSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareResponse
decode_CreateSquareResponse iprot bs = to_CreateSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareResponse) bs
typemap_CreateSquareResponse :: T.TypeMap
typemap_CreateSquareResponse = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("creator",(T.T_STRUCT typemap_SquareMember))),(3,("authority",(T.T_STRUCT typemap_SquareAuthority))),(4,("status",(T.T_STRUCT typemap_SquareStatus)))]
default_CreateSquareResponse :: CreateSquareResponse
default_CreateSquareResponse = CreateSquareResponse{
  createSquareResponse_square = default_Square,
  createSquareResponse_creator = default_SquareMember,
  createSquareResponse_authority = default_SquareAuthority,
  createSquareResponse_status = default_SquareStatus}
data CreateSquareRequest = CreateSquareRequest  { createSquareRequest_reqSeq :: I.Int32
  , createSquareRequest_square :: Square
  , createSquareRequest_creator :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareRequest_reqSeq record   `H.hashWithSalt` createSquareRequest_square record   `H.hashWithSalt` createSquareRequest_creator record  
instance QC.Arbitrary CreateSquareRequest where 
  arbitrary = M.liftM CreateSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareRequest{createSquareRequest_reqSeq = createSquareRequest_reqSeq obj} then P.Nothing else P.Just $ default_CreateSquareRequest{createSquareRequest_reqSeq = createSquareRequest_reqSeq obj}
    , if obj == default_CreateSquareRequest{createSquareRequest_square = createSquareRequest_square obj} then P.Nothing else P.Just $ default_CreateSquareRequest{createSquareRequest_square = createSquareRequest_square obj}
    , if obj == default_CreateSquareRequest{createSquareRequest_creator = createSquareRequest_creator obj} then P.Nothing else P.Just $ default_CreateSquareRequest{createSquareRequest_creator = createSquareRequest_creator obj}
    ]
from_CreateSquareRequest :: CreateSquareRequest -> T.ThriftVal
from_CreateSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2114 -> P.Just (1, ("reqSeq",T.TI32 _v2114))) $ createSquareRequest_reqSeq record
  , (\_v2114 -> P.Just (2, ("square",from_Square _v2114))) $ createSquareRequest_square record
  , (\_v2114 -> P.Just (3, ("creator",from_SquareMember _v2114))) $ createSquareRequest_creator record
  ]
write_CreateSquareRequest :: T.Protocol p => p -> CreateSquareRequest -> P.IO ()
write_CreateSquareRequest oprot record = T.writeVal oprot $ from_CreateSquareRequest record
encode_CreateSquareRequest :: T.StatelessProtocol p => p -> CreateSquareRequest -> LBS.ByteString
encode_CreateSquareRequest oprot record = T.serializeVal oprot $ from_CreateSquareRequest record
to_CreateSquareRequest :: T.ThriftVal -> CreateSquareRequest
to_CreateSquareRequest (T.TStruct fields) = CreateSquareRequest{
  createSquareRequest_reqSeq = P.maybe (createSquareRequest_reqSeq default_CreateSquareRequest) (\(_,_val2116) -> (case _val2116 of {T.TI32 _val2117 -> _val2117; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSquareRequest_square = P.maybe (createSquareRequest_square default_CreateSquareRequest) (\(_,_val2116) -> (case _val2116 of {T.TStruct _val2118 -> (to_Square (T.TStruct _val2118)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createSquareRequest_creator = P.maybe (createSquareRequest_creator default_CreateSquareRequest) (\(_,_val2116) -> (case _val2116 of {T.TStruct _val2119 -> (to_SquareMember (T.TStruct _val2119)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateSquareRequest _ = P.error "not a struct"
read_CreateSquareRequest :: T.Protocol p => p -> P.IO CreateSquareRequest
read_CreateSquareRequest iprot = to_CreateSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareRequest)
decode_CreateSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareRequest
decode_CreateSquareRequest iprot bs = to_CreateSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareRequest) bs
typemap_CreateSquareRequest :: T.TypeMap
typemap_CreateSquareRequest = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("square",(T.T_STRUCT typemap_Square))),(3,("creator",(T.T_STRUCT typemap_SquareMember)))]
default_CreateSquareRequest :: CreateSquareRequest
default_CreateSquareRequest = CreateSquareRequest{
  createSquareRequest_reqSeq = 0,
  createSquareRequest_square = default_Square,
  createSquareRequest_creator = default_SquareMember}
data DeleteSquareResponse = DeleteSquareResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DeleteSquareResponse where 
  arbitrary = QC.elements [DeleteSquareResponse]
from_DeleteSquareResponse :: DeleteSquareResponse -> T.ThriftVal
from_DeleteSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DeleteSquareResponse :: T.Protocol p => p -> DeleteSquareResponse -> P.IO ()
write_DeleteSquareResponse oprot record = T.writeVal oprot $ from_DeleteSquareResponse record
encode_DeleteSquareResponse :: T.StatelessProtocol p => p -> DeleteSquareResponse -> LBS.ByteString
encode_DeleteSquareResponse oprot record = T.serializeVal oprot $ from_DeleteSquareResponse record
to_DeleteSquareResponse :: T.ThriftVal -> DeleteSquareResponse
to_DeleteSquareResponse (T.TStruct fields) = DeleteSquareResponse{

  }
to_DeleteSquareResponse _ = P.error "not a struct"
read_DeleteSquareResponse :: T.Protocol p => p -> P.IO DeleteSquareResponse
read_DeleteSquareResponse iprot = to_DeleteSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareResponse)
decode_DeleteSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareResponse
decode_DeleteSquareResponse iprot bs = to_DeleteSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareResponse) bs
typemap_DeleteSquareResponse :: T.TypeMap
typemap_DeleteSquareResponse = Map.fromList []
default_DeleteSquareResponse :: DeleteSquareResponse
default_DeleteSquareResponse = DeleteSquareResponse{
}
data DeleteSquareRequest = DeleteSquareRequest  { deleteSquareRequest_mid :: LT.Text
  , deleteSquareRequest_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareRequest_mid record   `H.hashWithSalt` deleteSquareRequest_revision record  
instance QC.Arbitrary DeleteSquareRequest where 
  arbitrary = M.liftM DeleteSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeleteSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareRequest{deleteSquareRequest_mid = deleteSquareRequest_mid obj} then P.Nothing else P.Just $ default_DeleteSquareRequest{deleteSquareRequest_mid = deleteSquareRequest_mid obj}
    , if obj == default_DeleteSquareRequest{deleteSquareRequest_revision = deleteSquareRequest_revision obj} then P.Nothing else P.Just $ default_DeleteSquareRequest{deleteSquareRequest_revision = deleteSquareRequest_revision obj}
    ]
from_DeleteSquareRequest :: DeleteSquareRequest -> T.ThriftVal
from_DeleteSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2127 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v2127))) $ deleteSquareRequest_mid record
  , (\_v2127 -> P.Just (3, ("revision",T.TI64 _v2127))) $ deleteSquareRequest_revision record
  ]
write_DeleteSquareRequest :: T.Protocol p => p -> DeleteSquareRequest -> P.IO ()
write_DeleteSquareRequest oprot record = T.writeVal oprot $ from_DeleteSquareRequest record
encode_DeleteSquareRequest :: T.StatelessProtocol p => p -> DeleteSquareRequest -> LBS.ByteString
encode_DeleteSquareRequest oprot record = T.serializeVal oprot $ from_DeleteSquareRequest record
to_DeleteSquareRequest :: T.ThriftVal -> DeleteSquareRequest
to_DeleteSquareRequest (T.TStruct fields) = DeleteSquareRequest{
  deleteSquareRequest_mid = P.maybe (deleteSquareRequest_mid default_DeleteSquareRequest) (\(_,_val2129) -> (case _val2129 of {T.TString _val2130 -> E.decodeUtf8 _val2130; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deleteSquareRequest_revision = P.maybe (deleteSquareRequest_revision default_DeleteSquareRequest) (\(_,_val2129) -> (case _val2129 of {T.TI64 _val2131 -> _val2131; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_DeleteSquareRequest _ = P.error "not a struct"
read_DeleteSquareRequest :: T.Protocol p => p -> P.IO DeleteSquareRequest
read_DeleteSquareRequest iprot = to_DeleteSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareRequest)
decode_DeleteSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareRequest
decode_DeleteSquareRequest iprot bs = to_DeleteSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareRequest) bs
typemap_DeleteSquareRequest :: T.TypeMap
typemap_DeleteSquareRequest = Map.fromList [(2,("mid",T.T_STRING)),(3,("revision",T.T_I64))]
default_DeleteSquareRequest :: DeleteSquareRequest
default_DeleteSquareRequest = DeleteSquareRequest{
  deleteSquareRequest_mid = "",
  deleteSquareRequest_revision = 0}
data DestroyMessageResponse = DestroyMessageResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessageResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DestroyMessageResponse where 
  arbitrary = QC.elements [DestroyMessageResponse]
from_DestroyMessageResponse :: DestroyMessageResponse -> T.ThriftVal
from_DestroyMessageResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DestroyMessageResponse :: T.Protocol p => p -> DestroyMessageResponse -> P.IO ()
write_DestroyMessageResponse oprot record = T.writeVal oprot $ from_DestroyMessageResponse record
encode_DestroyMessageResponse :: T.StatelessProtocol p => p -> DestroyMessageResponse -> LBS.ByteString
encode_DestroyMessageResponse oprot record = T.serializeVal oprot $ from_DestroyMessageResponse record
to_DestroyMessageResponse :: T.ThriftVal -> DestroyMessageResponse
to_DestroyMessageResponse (T.TStruct fields) = DestroyMessageResponse{

  }
to_DestroyMessageResponse _ = P.error "not a struct"
read_DestroyMessageResponse :: T.Protocol p => p -> P.IO DestroyMessageResponse
read_DestroyMessageResponse iprot = to_DestroyMessageResponse <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessageResponse)
decode_DestroyMessageResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessageResponse
decode_DestroyMessageResponse iprot bs = to_DestroyMessageResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessageResponse) bs
typemap_DestroyMessageResponse :: T.TypeMap
typemap_DestroyMessageResponse = Map.fromList []
default_DestroyMessageResponse :: DestroyMessageResponse
default_DestroyMessageResponse = DestroyMessageResponse{
}
data DestroyMessageRequest = DestroyMessageRequest  { destroyMessageRequest_squareChatMid :: LT.Text
  , destroyMessageRequest_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessageRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` destroyMessageRequest_squareChatMid record   `H.hashWithSalt` destroyMessageRequest_messageId record  
instance QC.Arbitrary DestroyMessageRequest where 
  arbitrary = M.liftM DestroyMessageRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DestroyMessageRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DestroyMessageRequest{destroyMessageRequest_squareChatMid = destroyMessageRequest_squareChatMid obj} then P.Nothing else P.Just $ default_DestroyMessageRequest{destroyMessageRequest_squareChatMid = destroyMessageRequest_squareChatMid obj}
    , if obj == default_DestroyMessageRequest{destroyMessageRequest_messageId = destroyMessageRequest_messageId obj} then P.Nothing else P.Just $ default_DestroyMessageRequest{destroyMessageRequest_messageId = destroyMessageRequest_messageId obj}
    ]
from_DestroyMessageRequest :: DestroyMessageRequest -> T.ThriftVal
from_DestroyMessageRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2139 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2139))) $ destroyMessageRequest_squareChatMid record
  , (\_v2139 -> P.Just (4, ("messageId",T.TString $ E.encodeUtf8 _v2139))) $ destroyMessageRequest_messageId record
  ]
write_DestroyMessageRequest :: T.Protocol p => p -> DestroyMessageRequest -> P.IO ()
write_DestroyMessageRequest oprot record = T.writeVal oprot $ from_DestroyMessageRequest record
encode_DestroyMessageRequest :: T.StatelessProtocol p => p -> DestroyMessageRequest -> LBS.ByteString
encode_DestroyMessageRequest oprot record = T.serializeVal oprot $ from_DestroyMessageRequest record
to_DestroyMessageRequest :: T.ThriftVal -> DestroyMessageRequest
to_DestroyMessageRequest (T.TStruct fields) = DestroyMessageRequest{
  destroyMessageRequest_squareChatMid = P.maybe (destroyMessageRequest_squareChatMid default_DestroyMessageRequest) (\(_,_val2141) -> (case _val2141 of {T.TString _val2142 -> E.decodeUtf8 _val2142; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  destroyMessageRequest_messageId = P.maybe (destroyMessageRequest_messageId default_DestroyMessageRequest) (\(_,_val2141) -> (case _val2141 of {T.TString _val2143 -> E.decodeUtf8 _val2143; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DestroyMessageRequest _ = P.error "not a struct"
read_DestroyMessageRequest :: T.Protocol p => p -> P.IO DestroyMessageRequest
read_DestroyMessageRequest iprot = to_DestroyMessageRequest <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessageRequest)
decode_DestroyMessageRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessageRequest
decode_DestroyMessageRequest iprot bs = to_DestroyMessageRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessageRequest) bs
typemap_DestroyMessageRequest :: T.TypeMap
typemap_DestroyMessageRequest = Map.fromList [(2,("squareChatMid",T.T_STRING)),(4,("messageId",T.T_STRING))]
default_DestroyMessageRequest :: DestroyMessageRequest
default_DestroyMessageRequest = DestroyMessageRequest{
  destroyMessageRequest_squareChatMid = "",
  destroyMessageRequest_messageId = ""}
data GetSquareChatMembersRequest = GetSquareChatMembersRequest  { getSquareChatMembersRequest_squareChatMid :: LT.Text
  , getSquareChatMembersRequest_continuationToken :: LT.Text
  , getSquareChatMembersRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatMembersRequest_squareChatMid record   `H.hashWithSalt` getSquareChatMembersRequest_continuationToken record   `H.hashWithSalt` getSquareChatMembersRequest_limit record  
instance QC.Arbitrary GetSquareChatMembersRequest where 
  arbitrary = M.liftM GetSquareChatMembersRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareChatMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatMembersRequest{getSquareChatMembersRequest_squareChatMid = getSquareChatMembersRequest_squareChatMid obj} then P.Nothing else P.Just $ default_GetSquareChatMembersRequest{getSquareChatMembersRequest_squareChatMid = getSquareChatMembersRequest_squareChatMid obj}
    , if obj == default_GetSquareChatMembersRequest{getSquareChatMembersRequest_continuationToken = getSquareChatMembersRequest_continuationToken obj} then P.Nothing else P.Just $ default_GetSquareChatMembersRequest{getSquareChatMembersRequest_continuationToken = getSquareChatMembersRequest_continuationToken obj}
    , if obj == default_GetSquareChatMembersRequest{getSquareChatMembersRequest_limit = getSquareChatMembersRequest_limit obj} then P.Nothing else P.Just $ default_GetSquareChatMembersRequest{getSquareChatMembersRequest_limit = getSquareChatMembersRequest_limit obj}
    ]
from_GetSquareChatMembersRequest :: GetSquareChatMembersRequest -> T.ThriftVal
from_GetSquareChatMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2146 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2146))) $ getSquareChatMembersRequest_squareChatMid record
  , (\_v2146 -> P.Just (2, ("continuationToken",T.TString $ E.encodeUtf8 _v2146))) $ getSquareChatMembersRequest_continuationToken record
  , (\_v2146 -> P.Just (3, ("limit",T.TI32 _v2146))) $ getSquareChatMembersRequest_limit record
  ]
write_GetSquareChatMembersRequest :: T.Protocol p => p -> GetSquareChatMembersRequest -> P.IO ()
write_GetSquareChatMembersRequest oprot record = T.writeVal oprot $ from_GetSquareChatMembersRequest record
encode_GetSquareChatMembersRequest :: T.StatelessProtocol p => p -> GetSquareChatMembersRequest -> LBS.ByteString
encode_GetSquareChatMembersRequest oprot record = T.serializeVal oprot $ from_GetSquareChatMembersRequest record
to_GetSquareChatMembersRequest :: T.ThriftVal -> GetSquareChatMembersRequest
to_GetSquareChatMembersRequest (T.TStruct fields) = GetSquareChatMembersRequest{
  getSquareChatMembersRequest_squareChatMid = P.maybe (getSquareChatMembersRequest_squareChatMid default_GetSquareChatMembersRequest) (\(_,_val2148) -> (case _val2148 of {T.TString _val2149 -> E.decodeUtf8 _val2149; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareChatMembersRequest_continuationToken = P.maybe (getSquareChatMembersRequest_continuationToken default_GetSquareChatMembersRequest) (\(_,_val2148) -> (case _val2148 of {T.TString _val2150 -> E.decodeUtf8 _val2150; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareChatMembersRequest_limit = P.maybe (getSquareChatMembersRequest_limit default_GetSquareChatMembersRequest) (\(_,_val2148) -> (case _val2148 of {T.TI32 _val2151 -> _val2151; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareChatMembersRequest _ = P.error "not a struct"
read_GetSquareChatMembersRequest :: T.Protocol p => p -> P.IO GetSquareChatMembersRequest
read_GetSquareChatMembersRequest iprot = to_GetSquareChatMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatMembersRequest)
decode_GetSquareChatMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatMembersRequest
decode_GetSquareChatMembersRequest iprot bs = to_GetSquareChatMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatMembersRequest) bs
typemap_GetSquareChatMembersRequest :: T.TypeMap
typemap_GetSquareChatMembersRequest = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("continuationToken",T.T_STRING)),(3,("limit",T.T_I32))]
default_GetSquareChatMembersRequest :: GetSquareChatMembersRequest
default_GetSquareChatMembersRequest = GetSquareChatMembersRequest{
  getSquareChatMembersRequest_squareChatMid = "",
  getSquareChatMembersRequest_continuationToken = "",
  getSquareChatMembersRequest_limit = 0}
data GetSquareChatMembersResponse = GetSquareChatMembersResponse  { getSquareChatMembersResponse_squareChatMembers :: SquareMember
  , getSquareChatMembersResponse_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatMembersResponse_squareChatMembers record   `H.hashWithSalt` getSquareChatMembersResponse_continuationToken record  
instance QC.Arbitrary GetSquareChatMembersResponse where 
  arbitrary = M.liftM GetSquareChatMembersResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareChatMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatMembersResponse{getSquareChatMembersResponse_squareChatMembers = getSquareChatMembersResponse_squareChatMembers obj} then P.Nothing else P.Just $ default_GetSquareChatMembersResponse{getSquareChatMembersResponse_squareChatMembers = getSquareChatMembersResponse_squareChatMembers obj}
    , if obj == default_GetSquareChatMembersResponse{getSquareChatMembersResponse_continuationToken = getSquareChatMembersResponse_continuationToken obj} then P.Nothing else P.Just $ default_GetSquareChatMembersResponse{getSquareChatMembersResponse_continuationToken = getSquareChatMembersResponse_continuationToken obj}
    ]
from_GetSquareChatMembersResponse :: GetSquareChatMembersResponse -> T.ThriftVal
from_GetSquareChatMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2154 -> P.Just (1, ("squareChatMembers",from_SquareMember _v2154))) $ getSquareChatMembersResponse_squareChatMembers record
  , (\_v2154 -> P.Just (2, ("continuationToken",T.TString $ E.encodeUtf8 _v2154))) $ getSquareChatMembersResponse_continuationToken record
  ]
write_GetSquareChatMembersResponse :: T.Protocol p => p -> GetSquareChatMembersResponse -> P.IO ()
write_GetSquareChatMembersResponse oprot record = T.writeVal oprot $ from_GetSquareChatMembersResponse record
encode_GetSquareChatMembersResponse :: T.StatelessProtocol p => p -> GetSquareChatMembersResponse -> LBS.ByteString
encode_GetSquareChatMembersResponse oprot record = T.serializeVal oprot $ from_GetSquareChatMembersResponse record
to_GetSquareChatMembersResponse :: T.ThriftVal -> GetSquareChatMembersResponse
to_GetSquareChatMembersResponse (T.TStruct fields) = GetSquareChatMembersResponse{
  getSquareChatMembersResponse_squareChatMembers = P.maybe (getSquareChatMembersResponse_squareChatMembers default_GetSquareChatMembersResponse) (\(_,_val2156) -> (case _val2156 of {T.TStruct _val2157 -> (to_SquareMember (T.TStruct _val2157)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareChatMembersResponse_continuationToken = P.maybe (getSquareChatMembersResponse_continuationToken default_GetSquareChatMembersResponse) (\(_,_val2156) -> (case _val2156 of {T.TString _val2158 -> E.decodeUtf8 _val2158; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareChatMembersResponse _ = P.error "not a struct"
read_GetSquareChatMembersResponse :: T.Protocol p => p -> P.IO GetSquareChatMembersResponse
read_GetSquareChatMembersResponse iprot = to_GetSquareChatMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatMembersResponse)
decode_GetSquareChatMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatMembersResponse
decode_GetSquareChatMembersResponse iprot bs = to_GetSquareChatMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatMembersResponse) bs
typemap_GetSquareChatMembersResponse :: T.TypeMap
typemap_GetSquareChatMembersResponse = Map.fromList [(1,("squareChatMembers",(T.T_STRUCT typemap_SquareMember))),(2,("continuationToken",T.T_STRING))]
default_GetSquareChatMembersResponse :: GetSquareChatMembersResponse
default_GetSquareChatMembersResponse = GetSquareChatMembersResponse{
  getSquareChatMembersResponse_squareChatMembers = default_SquareMember,
  getSquareChatMembersResponse_continuationToken = ""}
data GetSquareChatStatusRequest = GetSquareChatStatusRequest  { getSquareChatStatusRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatStatusRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatStatusRequest_squareChatMid record  
instance QC.Arbitrary GetSquareChatStatusRequest where 
  arbitrary = M.liftM GetSquareChatStatusRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatStatusRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatStatusRequest{getSquareChatStatusRequest_squareChatMid = getSquareChatStatusRequest_squareChatMid obj} then P.Nothing else P.Just $ default_GetSquareChatStatusRequest{getSquareChatStatusRequest_squareChatMid = getSquareChatStatusRequest_squareChatMid obj}
    ]
from_GetSquareChatStatusRequest :: GetSquareChatStatusRequest -> T.ThriftVal
from_GetSquareChatStatusRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2161 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2161))) $ getSquareChatStatusRequest_squareChatMid record
  ]
write_GetSquareChatStatusRequest :: T.Protocol p => p -> GetSquareChatStatusRequest -> P.IO ()
write_GetSquareChatStatusRequest oprot record = T.writeVal oprot $ from_GetSquareChatStatusRequest record
encode_GetSquareChatStatusRequest :: T.StatelessProtocol p => p -> GetSquareChatStatusRequest -> LBS.ByteString
encode_GetSquareChatStatusRequest oprot record = T.serializeVal oprot $ from_GetSquareChatStatusRequest record
to_GetSquareChatStatusRequest :: T.ThriftVal -> GetSquareChatStatusRequest
to_GetSquareChatStatusRequest (T.TStruct fields) = GetSquareChatStatusRequest{
  getSquareChatStatusRequest_squareChatMid = P.maybe (getSquareChatStatusRequest_squareChatMid default_GetSquareChatStatusRequest) (\(_,_val2163) -> (case _val2163 of {T.TString _val2164 -> E.decodeUtf8 _val2164; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareChatStatusRequest _ = P.error "not a struct"
read_GetSquareChatStatusRequest :: T.Protocol p => p -> P.IO GetSquareChatStatusRequest
read_GetSquareChatStatusRequest iprot = to_GetSquareChatStatusRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatStatusRequest)
decode_GetSquareChatStatusRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatStatusRequest
decode_GetSquareChatStatusRequest iprot bs = to_GetSquareChatStatusRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatStatusRequest) bs
typemap_GetSquareChatStatusRequest :: T.TypeMap
typemap_GetSquareChatStatusRequest = Map.fromList [(2,("squareChatMid",T.T_STRING))]
default_GetSquareChatStatusRequest :: GetSquareChatStatusRequest
default_GetSquareChatStatusRequest = GetSquareChatStatusRequest{
  getSquareChatStatusRequest_squareChatMid = ""}
data GetSquareChatStatusResponse = GetSquareChatStatusResponse  { getSquareChatStatusResponse_chatStatus :: SquareChatStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatStatusResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatStatusResponse_chatStatus record  
instance QC.Arbitrary GetSquareChatStatusResponse where 
  arbitrary = M.liftM GetSquareChatStatusResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatStatusResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatStatusResponse{getSquareChatStatusResponse_chatStatus = getSquareChatStatusResponse_chatStatus obj} then P.Nothing else P.Just $ default_GetSquareChatStatusResponse{getSquareChatStatusResponse_chatStatus = getSquareChatStatusResponse_chatStatus obj}
    ]
from_GetSquareChatStatusResponse :: GetSquareChatStatusResponse -> T.ThriftVal
from_GetSquareChatStatusResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2167 -> P.Just (1, ("chatStatus",from_SquareChatStatus _v2167))) $ getSquareChatStatusResponse_chatStatus record
  ]
write_GetSquareChatStatusResponse :: T.Protocol p => p -> GetSquareChatStatusResponse -> P.IO ()
write_GetSquareChatStatusResponse oprot record = T.writeVal oprot $ from_GetSquareChatStatusResponse record
encode_GetSquareChatStatusResponse :: T.StatelessProtocol p => p -> GetSquareChatStatusResponse -> LBS.ByteString
encode_GetSquareChatStatusResponse oprot record = T.serializeVal oprot $ from_GetSquareChatStatusResponse record
to_GetSquareChatStatusResponse :: T.ThriftVal -> GetSquareChatStatusResponse
to_GetSquareChatStatusResponse (T.TStruct fields) = GetSquareChatStatusResponse{
  getSquareChatStatusResponse_chatStatus = P.maybe (getSquareChatStatusResponse_chatStatus default_GetSquareChatStatusResponse) (\(_,_val2169) -> (case _val2169 of {T.TStruct _val2170 -> (to_SquareChatStatus (T.TStruct _val2170)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatStatusResponse _ = P.error "not a struct"
read_GetSquareChatStatusResponse :: T.Protocol p => p -> P.IO GetSquareChatStatusResponse
read_GetSquareChatStatusResponse iprot = to_GetSquareChatStatusResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatStatusResponse)
decode_GetSquareChatStatusResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatStatusResponse
decode_GetSquareChatStatusResponse iprot bs = to_GetSquareChatStatusResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatStatusResponse) bs
typemap_GetSquareChatStatusResponse :: T.TypeMap
typemap_GetSquareChatStatusResponse = Map.fromList [(1,("chatStatus",(T.T_STRUCT typemap_SquareChatStatus)))]
default_GetSquareChatStatusResponse :: GetSquareChatStatusResponse
default_GetSquareChatStatusResponse = GetSquareChatStatusResponse{
  getSquareChatStatusResponse_chatStatus = default_SquareChatStatus}
data GetSquareChatRequest = GetSquareChatRequest  { getSquareChatRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatRequest_squareChatMid record  
instance QC.Arbitrary GetSquareChatRequest where 
  arbitrary = M.liftM GetSquareChatRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatRequest{getSquareChatRequest_squareChatMid = getSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_GetSquareChatRequest{getSquareChatRequest_squareChatMid = getSquareChatRequest_squareChatMid obj}
    ]
from_GetSquareChatRequest :: GetSquareChatRequest -> T.ThriftVal
from_GetSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2173 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2173))) $ getSquareChatRequest_squareChatMid record
  ]
write_GetSquareChatRequest :: T.Protocol p => p -> GetSquareChatRequest -> P.IO ()
write_GetSquareChatRequest oprot record = T.writeVal oprot $ from_GetSquareChatRequest record
encode_GetSquareChatRequest :: T.StatelessProtocol p => p -> GetSquareChatRequest -> LBS.ByteString
encode_GetSquareChatRequest oprot record = T.serializeVal oprot $ from_GetSquareChatRequest record
to_GetSquareChatRequest :: T.ThriftVal -> GetSquareChatRequest
to_GetSquareChatRequest (T.TStruct fields) = GetSquareChatRequest{
  getSquareChatRequest_squareChatMid = P.maybe (getSquareChatRequest_squareChatMid default_GetSquareChatRequest) (\(_,_val2175) -> (case _val2175 of {T.TString _val2176 -> E.decodeUtf8 _val2176; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatRequest _ = P.error "not a struct"
read_GetSquareChatRequest :: T.Protocol p => p -> P.IO GetSquareChatRequest
read_GetSquareChatRequest iprot = to_GetSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatRequest)
decode_GetSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatRequest
decode_GetSquareChatRequest iprot bs = to_GetSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatRequest) bs
typemap_GetSquareChatRequest :: T.TypeMap
typemap_GetSquareChatRequest = Map.fromList [(1,("squareChatMid",T.T_STRING))]
default_GetSquareChatRequest :: GetSquareChatRequest
default_GetSquareChatRequest = GetSquareChatRequest{
  getSquareChatRequest_squareChatMid = ""}
data GetSquareChatResponse = GetSquareChatResponse  { getSquareChatResponse_squareChat :: SquareChat
  , getSquareChatResponse_squareChatMember :: SquareChatMember
  , getSquareChatResponse_squareChatStatus :: SquareChatStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatResponse_squareChat record   `H.hashWithSalt` getSquareChatResponse_squareChatMember record   `H.hashWithSalt` getSquareChatResponse_squareChatStatus record  
instance QC.Arbitrary GetSquareChatResponse where 
  arbitrary = M.liftM GetSquareChatResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareChatResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatResponse{getSquareChatResponse_squareChat = getSquareChatResponse_squareChat obj} then P.Nothing else P.Just $ default_GetSquareChatResponse{getSquareChatResponse_squareChat = getSquareChatResponse_squareChat obj}
    , if obj == default_GetSquareChatResponse{getSquareChatResponse_squareChatMember = getSquareChatResponse_squareChatMember obj} then P.Nothing else P.Just $ default_GetSquareChatResponse{getSquareChatResponse_squareChatMember = getSquareChatResponse_squareChatMember obj}
    , if obj == default_GetSquareChatResponse{getSquareChatResponse_squareChatStatus = getSquareChatResponse_squareChatStatus obj} then P.Nothing else P.Just $ default_GetSquareChatResponse{getSquareChatResponse_squareChatStatus = getSquareChatResponse_squareChatStatus obj}
    ]
from_GetSquareChatResponse :: GetSquareChatResponse -> T.ThriftVal
from_GetSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2179 -> P.Just (1, ("squareChat",from_SquareChat _v2179))) $ getSquareChatResponse_squareChat record
  , (\_v2179 -> P.Just (2, ("squareChatMember",from_SquareChatMember _v2179))) $ getSquareChatResponse_squareChatMember record
  , (\_v2179 -> P.Just (3, ("squareChatStatus",from_SquareChatStatus _v2179))) $ getSquareChatResponse_squareChatStatus record
  ]
write_GetSquareChatResponse :: T.Protocol p => p -> GetSquareChatResponse -> P.IO ()
write_GetSquareChatResponse oprot record = T.writeVal oprot $ from_GetSquareChatResponse record
encode_GetSquareChatResponse :: T.StatelessProtocol p => p -> GetSquareChatResponse -> LBS.ByteString
encode_GetSquareChatResponse oprot record = T.serializeVal oprot $ from_GetSquareChatResponse record
to_GetSquareChatResponse :: T.ThriftVal -> GetSquareChatResponse
to_GetSquareChatResponse (T.TStruct fields) = GetSquareChatResponse{
  getSquareChatResponse_squareChat = P.maybe (getSquareChatResponse_squareChat default_GetSquareChatResponse) (\(_,_val2181) -> (case _val2181 of {T.TStruct _val2182 -> (to_SquareChat (T.TStruct _val2182)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareChatResponse_squareChatMember = P.maybe (getSquareChatResponse_squareChatMember default_GetSquareChatResponse) (\(_,_val2181) -> (case _val2181 of {T.TStruct _val2183 -> (to_SquareChatMember (T.TStruct _val2183)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareChatResponse_squareChatStatus = P.maybe (getSquareChatResponse_squareChatStatus default_GetSquareChatResponse) (\(_,_val2181) -> (case _val2181 of {T.TStruct _val2184 -> (to_SquareChatStatus (T.TStruct _val2184)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareChatResponse _ = P.error "not a struct"
read_GetSquareChatResponse :: T.Protocol p => p -> P.IO GetSquareChatResponse
read_GetSquareChatResponse iprot = to_GetSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatResponse)
decode_GetSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatResponse
decode_GetSquareChatResponse iprot bs = to_GetSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatResponse) bs
typemap_GetSquareChatResponse :: T.TypeMap
typemap_GetSquareChatResponse = Map.fromList [(1,("squareChat",(T.T_STRUCT typemap_SquareChat))),(2,("squareChatMember",(T.T_STRUCT typemap_SquareChatMember))),(3,("squareChatStatus",(T.T_STRUCT typemap_SquareChatStatus)))]
default_GetSquareChatResponse :: GetSquareChatResponse
default_GetSquareChatResponse = GetSquareChatResponse{
  getSquareChatResponse_squareChat = default_SquareChat,
  getSquareChatResponse_squareChatMember = default_SquareChatMember,
  getSquareChatResponse_squareChatStatus = default_SquareChatStatus}
data GetSquareAuthorityRequest = GetSquareAuthorityRequest  { getSquareAuthorityRequest_squareMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareAuthorityRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareAuthorityRequest_squareMid record  
instance QC.Arbitrary GetSquareAuthorityRequest where 
  arbitrary = M.liftM GetSquareAuthorityRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareAuthorityRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareAuthorityRequest{getSquareAuthorityRequest_squareMid = getSquareAuthorityRequest_squareMid obj} then P.Nothing else P.Just $ default_GetSquareAuthorityRequest{getSquareAuthorityRequest_squareMid = getSquareAuthorityRequest_squareMid obj}
    ]
from_GetSquareAuthorityRequest :: GetSquareAuthorityRequest -> T.ThriftVal
from_GetSquareAuthorityRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2187 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2187))) $ getSquareAuthorityRequest_squareMid record
  ]
write_GetSquareAuthorityRequest :: T.Protocol p => p -> GetSquareAuthorityRequest -> P.IO ()
write_GetSquareAuthorityRequest oprot record = T.writeVal oprot $ from_GetSquareAuthorityRequest record
encode_GetSquareAuthorityRequest :: T.StatelessProtocol p => p -> GetSquareAuthorityRequest -> LBS.ByteString
encode_GetSquareAuthorityRequest oprot record = T.serializeVal oprot $ from_GetSquareAuthorityRequest record
to_GetSquareAuthorityRequest :: T.ThriftVal -> GetSquareAuthorityRequest
to_GetSquareAuthorityRequest (T.TStruct fields) = GetSquareAuthorityRequest{
  getSquareAuthorityRequest_squareMid = P.maybe (getSquareAuthorityRequest_squareMid default_GetSquareAuthorityRequest) (\(_,_val2189) -> (case _val2189 of {T.TString _val2190 -> E.decodeUtf8 _val2190; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareAuthorityRequest _ = P.error "not a struct"
read_GetSquareAuthorityRequest :: T.Protocol p => p -> P.IO GetSquareAuthorityRequest
read_GetSquareAuthorityRequest iprot = to_GetSquareAuthorityRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareAuthorityRequest)
decode_GetSquareAuthorityRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareAuthorityRequest
decode_GetSquareAuthorityRequest iprot bs = to_GetSquareAuthorityRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareAuthorityRequest) bs
typemap_GetSquareAuthorityRequest :: T.TypeMap
typemap_GetSquareAuthorityRequest = Map.fromList [(1,("squareMid",T.T_STRING))]
default_GetSquareAuthorityRequest :: GetSquareAuthorityRequest
default_GetSquareAuthorityRequest = GetSquareAuthorityRequest{
  getSquareAuthorityRequest_squareMid = ""}
data GetSquareAuthorityResponse = GetSquareAuthorityResponse  { getSquareAuthorityResponse_authority :: SquareAuthority
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareAuthorityResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareAuthorityResponse_authority record  
instance QC.Arbitrary GetSquareAuthorityResponse where 
  arbitrary = M.liftM GetSquareAuthorityResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareAuthorityResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareAuthorityResponse{getSquareAuthorityResponse_authority = getSquareAuthorityResponse_authority obj} then P.Nothing else P.Just $ default_GetSquareAuthorityResponse{getSquareAuthorityResponse_authority = getSquareAuthorityResponse_authority obj}
    ]
from_GetSquareAuthorityResponse :: GetSquareAuthorityResponse -> T.ThriftVal
from_GetSquareAuthorityResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2193 -> P.Just (1, ("authority",from_SquareAuthority _v2193))) $ getSquareAuthorityResponse_authority record
  ]
write_GetSquareAuthorityResponse :: T.Protocol p => p -> GetSquareAuthorityResponse -> P.IO ()
write_GetSquareAuthorityResponse oprot record = T.writeVal oprot $ from_GetSquareAuthorityResponse record
encode_GetSquareAuthorityResponse :: T.StatelessProtocol p => p -> GetSquareAuthorityResponse -> LBS.ByteString
encode_GetSquareAuthorityResponse oprot record = T.serializeVal oprot $ from_GetSquareAuthorityResponse record
to_GetSquareAuthorityResponse :: T.ThriftVal -> GetSquareAuthorityResponse
to_GetSquareAuthorityResponse (T.TStruct fields) = GetSquareAuthorityResponse{
  getSquareAuthorityResponse_authority = P.maybe (getSquareAuthorityResponse_authority default_GetSquareAuthorityResponse) (\(_,_val2195) -> (case _val2195 of {T.TStruct _val2196 -> (to_SquareAuthority (T.TStruct _val2196)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareAuthorityResponse _ = P.error "not a struct"
read_GetSquareAuthorityResponse :: T.Protocol p => p -> P.IO GetSquareAuthorityResponse
read_GetSquareAuthorityResponse iprot = to_GetSquareAuthorityResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareAuthorityResponse)
decode_GetSquareAuthorityResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareAuthorityResponse
decode_GetSquareAuthorityResponse iprot bs = to_GetSquareAuthorityResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareAuthorityResponse) bs
typemap_GetSquareAuthorityResponse :: T.TypeMap
typemap_GetSquareAuthorityResponse = Map.fromList [(1,("authority",(T.T_STRUCT typemap_SquareAuthority)))]
default_GetSquareAuthorityResponse :: GetSquareAuthorityResponse
default_GetSquareAuthorityResponse = GetSquareAuthorityResponse{
  getSquareAuthorityResponse_authority = default_SquareAuthority}
data GetJoinedSquaresRequest = GetJoinedSquaresRequest  { getJoinedSquaresRequest_continuationToken :: LT.Text
  , getJoinedSquaresRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquaresRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquaresRequest_continuationToken record   `H.hashWithSalt` getJoinedSquaresRequest_limit record  
instance QC.Arbitrary GetJoinedSquaresRequest where 
  arbitrary = M.liftM GetJoinedSquaresRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquaresRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquaresRequest{getJoinedSquaresRequest_continuationToken = getJoinedSquaresRequest_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinedSquaresRequest{getJoinedSquaresRequest_continuationToken = getJoinedSquaresRequest_continuationToken obj}
    , if obj == default_GetJoinedSquaresRequest{getJoinedSquaresRequest_limit = getJoinedSquaresRequest_limit obj} then P.Nothing else P.Just $ default_GetJoinedSquaresRequest{getJoinedSquaresRequest_limit = getJoinedSquaresRequest_limit obj}
    ]
from_GetJoinedSquaresRequest :: GetJoinedSquaresRequest -> T.ThriftVal
from_GetJoinedSquaresRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2199 -> P.Just (2, ("continuationToken",T.TString $ E.encodeUtf8 _v2199))) $ getJoinedSquaresRequest_continuationToken record
  , (\_v2199 -> P.Just (3, ("limit",T.TI32 _v2199))) $ getJoinedSquaresRequest_limit record
  ]
write_GetJoinedSquaresRequest :: T.Protocol p => p -> GetJoinedSquaresRequest -> P.IO ()
write_GetJoinedSquaresRequest oprot record = T.writeVal oprot $ from_GetJoinedSquaresRequest record
encode_GetJoinedSquaresRequest :: T.StatelessProtocol p => p -> GetJoinedSquaresRequest -> LBS.ByteString
encode_GetJoinedSquaresRequest oprot record = T.serializeVal oprot $ from_GetJoinedSquaresRequest record
to_GetJoinedSquaresRequest :: T.ThriftVal -> GetJoinedSquaresRequest
to_GetJoinedSquaresRequest (T.TStruct fields) = GetJoinedSquaresRequest{
  getJoinedSquaresRequest_continuationToken = P.maybe (getJoinedSquaresRequest_continuationToken default_GetJoinedSquaresRequest) (\(_,_val2201) -> (case _val2201 of {T.TString _val2202 -> E.decodeUtf8 _val2202; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getJoinedSquaresRequest_limit = P.maybe (getJoinedSquaresRequest_limit default_GetJoinedSquaresRequest) (\(_,_val2201) -> (case _val2201 of {T.TI32 _val2203 -> _val2203; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetJoinedSquaresRequest _ = P.error "not a struct"
read_GetJoinedSquaresRequest :: T.Protocol p => p -> P.IO GetJoinedSquaresRequest
read_GetJoinedSquaresRequest iprot = to_GetJoinedSquaresRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquaresRequest)
decode_GetJoinedSquaresRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquaresRequest
decode_GetJoinedSquaresRequest iprot bs = to_GetJoinedSquaresRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquaresRequest) bs
typemap_GetJoinedSquaresRequest :: T.TypeMap
typemap_GetJoinedSquaresRequest = Map.fromList [(2,("continuationToken",T.T_STRING)),(3,("limit",T.T_I32))]
default_GetJoinedSquaresRequest :: GetJoinedSquaresRequest
default_GetJoinedSquaresRequest = GetJoinedSquaresRequest{
  getJoinedSquaresRequest_continuationToken = "",
  getJoinedSquaresRequest_limit = 0}
data GetJoinedSquaresResponse = GetJoinedSquaresResponse  { getJoinedSquaresResponse_squares :: (Vector.Vector Square)
  , getJoinedSquaresResponse_members :: (Map.HashMap LT.Text SquareMember)
  , getJoinedSquaresResponse_authorities :: (Map.HashMap LT.Text SquareAuthority)
  , getJoinedSquaresResponse_statuses :: (Map.HashMap LT.Text SquareStatus)
  , getJoinedSquaresResponse_continuationToken :: LT.Text
  , getJoinedSquaresResponse_noteStatuses :: (Map.HashMap LT.Text NoteStatus)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquaresResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquaresResponse_squares record   `H.hashWithSalt` getJoinedSquaresResponse_members record   `H.hashWithSalt` getJoinedSquaresResponse_authorities record   `H.hashWithSalt` getJoinedSquaresResponse_statuses record   `H.hashWithSalt` getJoinedSquaresResponse_continuationToken record   `H.hashWithSalt` getJoinedSquaresResponse_noteStatuses record  
instance QC.Arbitrary GetJoinedSquaresResponse where 
  arbitrary = M.liftM GetJoinedSquaresResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquaresResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_squares = getJoinedSquaresResponse_squares obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_squares = getJoinedSquaresResponse_squares obj}
    , if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_members = getJoinedSquaresResponse_members obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_members = getJoinedSquaresResponse_members obj}
    , if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_authorities = getJoinedSquaresResponse_authorities obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_authorities = getJoinedSquaresResponse_authorities obj}
    , if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_statuses = getJoinedSquaresResponse_statuses obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_statuses = getJoinedSquaresResponse_statuses obj}
    , if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_continuationToken = getJoinedSquaresResponse_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_continuationToken = getJoinedSquaresResponse_continuationToken obj}
    , if obj == default_GetJoinedSquaresResponse{getJoinedSquaresResponse_noteStatuses = getJoinedSquaresResponse_noteStatuses obj} then P.Nothing else P.Just $ default_GetJoinedSquaresResponse{getJoinedSquaresResponse_noteStatuses = getJoinedSquaresResponse_noteStatuses obj}
    ]
from_GetJoinedSquaresResponse :: GetJoinedSquaresResponse -> T.ThriftVal
from_GetJoinedSquaresResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2206 -> P.Just (1, ("squares",T.TList (T.T_STRUCT typemap_Square) $ P.map (\_v2208 -> from_Square _v2208) $ Vector.toList _v2206))) $ getJoinedSquaresResponse_squares record
  , (\_v2206 -> P.Just (2, ("members",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareMember) $ P.map (\(_k2209,_v2210) -> (T.TString $ E.encodeUtf8 _k2209, from_SquareMember _v2210)) $ Map.toList _v2206))) $ getJoinedSquaresResponse_members record
  , (\_v2206 -> P.Just (3, ("authorities",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareAuthority) $ P.map (\(_k2211,_v2212) -> (T.TString $ E.encodeUtf8 _k2211, from_SquareAuthority _v2212)) $ Map.toList _v2206))) $ getJoinedSquaresResponse_authorities record
  , (\_v2206 -> P.Just (4, ("statuses",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareStatus) $ P.map (\(_k2213,_v2214) -> (T.TString $ E.encodeUtf8 _k2213, from_SquareStatus _v2214)) $ Map.toList _v2206))) $ getJoinedSquaresResponse_statuses record
  , (\_v2206 -> P.Just (5, ("continuationToken",T.TString $ E.encodeUtf8 _v2206))) $ getJoinedSquaresResponse_continuationToken record
  , (\_v2206 -> P.Just (6, ("noteStatuses",T.TMap T.T_STRING (T.T_STRUCT typemap_NoteStatus) $ P.map (\(_k2215,_v2216) -> (T.TString $ E.encodeUtf8 _k2215, from_NoteStatus _v2216)) $ Map.toList _v2206))) $ getJoinedSquaresResponse_noteStatuses record
  ]
write_GetJoinedSquaresResponse :: T.Protocol p => p -> GetJoinedSquaresResponse -> P.IO ()
write_GetJoinedSquaresResponse oprot record = T.writeVal oprot $ from_GetJoinedSquaresResponse record
encode_GetJoinedSquaresResponse :: T.StatelessProtocol p => p -> GetJoinedSquaresResponse -> LBS.ByteString
encode_GetJoinedSquaresResponse oprot record = T.serializeVal oprot $ from_GetJoinedSquaresResponse record
to_GetJoinedSquaresResponse :: T.ThriftVal -> GetJoinedSquaresResponse
to_GetJoinedSquaresResponse (T.TStruct fields) = GetJoinedSquaresResponse{
  getJoinedSquaresResponse_squares = P.maybe (getJoinedSquaresResponse_squares default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TList _ _val2219 -> (Vector.fromList $ P.map (\_v2220 -> (case _v2220 of {T.TStruct _val2221 -> (to_Square (T.TStruct _val2221)); _ -> P.error "wrong type"})) _val2219); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getJoinedSquaresResponse_members = P.maybe (getJoinedSquaresResponse_members default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TMap _ _ _val2222 -> (Map.fromList $ P.map (\(_k2224,_v2223) -> ((case _k2224 of {T.TString _val2225 -> E.decodeUtf8 _val2225; _ -> P.error "wrong type"}),(case _v2223 of {T.TStruct _val2226 -> (to_SquareMember (T.TStruct _val2226)); _ -> P.error "wrong type"}))) _val2222); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getJoinedSquaresResponse_authorities = P.maybe (getJoinedSquaresResponse_authorities default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TMap _ _ _val2227 -> (Map.fromList $ P.map (\(_k2229,_v2228) -> ((case _k2229 of {T.TString _val2230 -> E.decodeUtf8 _val2230; _ -> P.error "wrong type"}),(case _v2228 of {T.TStruct _val2231 -> (to_SquareAuthority (T.TStruct _val2231)); _ -> P.error "wrong type"}))) _val2227); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getJoinedSquaresResponse_statuses = P.maybe (getJoinedSquaresResponse_statuses default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TMap _ _ _val2232 -> (Map.fromList $ P.map (\(_k2234,_v2233) -> ((case _k2234 of {T.TString _val2235 -> E.decodeUtf8 _val2235; _ -> P.error "wrong type"}),(case _v2233 of {T.TStruct _val2236 -> (to_SquareStatus (T.TStruct _val2236)); _ -> P.error "wrong type"}))) _val2232); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getJoinedSquaresResponse_continuationToken = P.maybe (getJoinedSquaresResponse_continuationToken default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TString _val2237 -> E.decodeUtf8 _val2237; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getJoinedSquaresResponse_noteStatuses = P.maybe (getJoinedSquaresResponse_noteStatuses default_GetJoinedSquaresResponse) (\(_,_val2218) -> (case _val2218 of {T.TMap _ _ _val2238 -> (Map.fromList $ P.map (\(_k2240,_v2239) -> ((case _k2240 of {T.TString _val2241 -> E.decodeUtf8 _val2241; _ -> P.error "wrong type"}),(case _v2239 of {T.TStruct _val2242 -> (to_NoteStatus (T.TStruct _val2242)); _ -> P.error "wrong type"}))) _val2238); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetJoinedSquaresResponse _ = P.error "not a struct"
read_GetJoinedSquaresResponse :: T.Protocol p => p -> P.IO GetJoinedSquaresResponse
read_GetJoinedSquaresResponse iprot = to_GetJoinedSquaresResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquaresResponse)
decode_GetJoinedSquaresResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquaresResponse
decode_GetJoinedSquaresResponse iprot bs = to_GetJoinedSquaresResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquaresResponse) bs
typemap_GetJoinedSquaresResponse :: T.TypeMap
typemap_GetJoinedSquaresResponse = Map.fromList [(1,("squares",(T.T_LIST (T.T_STRUCT typemap_Square)))),(2,("members",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareMember)))),(3,("authorities",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareAuthority)))),(4,("statuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareStatus)))),(5,("continuationToken",T.T_STRING)),(6,("noteStatuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_NoteStatus))))]
default_GetJoinedSquaresResponse :: GetJoinedSquaresResponse
default_GetJoinedSquaresResponse = GetJoinedSquaresResponse{
  getJoinedSquaresResponse_squares = Vector.empty,
  getJoinedSquaresResponse_members = Map.empty,
  getJoinedSquaresResponse_authorities = Map.empty,
  getJoinedSquaresResponse_statuses = Map.empty,
  getJoinedSquaresResponse_continuationToken = "",
  getJoinedSquaresResponse_noteStatuses = Map.empty}
data GetJoinableSquareChatsRequest = GetJoinableSquareChatsRequest  { getJoinableSquareChatsRequest_squareMid :: LT.Text
  , getJoinableSquareChatsRequest_continuationToken :: LT.Text
  , getJoinableSquareChatsRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinableSquareChatsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinableSquareChatsRequest_squareMid record   `H.hashWithSalt` getJoinableSquareChatsRequest_continuationToken record   `H.hashWithSalt` getJoinableSquareChatsRequest_limit record  
instance QC.Arbitrary GetJoinableSquareChatsRequest where 
  arbitrary = M.liftM GetJoinableSquareChatsRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinableSquareChatsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_squareMid = getJoinableSquareChatsRequest_squareMid obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_squareMid = getJoinableSquareChatsRequest_squareMid obj}
    , if obj == default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_continuationToken = getJoinableSquareChatsRequest_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_continuationToken = getJoinableSquareChatsRequest_continuationToken obj}
    , if obj == default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_limit = getJoinableSquareChatsRequest_limit obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsRequest{getJoinableSquareChatsRequest_limit = getJoinableSquareChatsRequest_limit obj}
    ]
from_GetJoinableSquareChatsRequest :: GetJoinableSquareChatsRequest -> T.ThriftVal
from_GetJoinableSquareChatsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2245 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2245))) $ getJoinableSquareChatsRequest_squareMid record
  , (\_v2245 -> P.Just (10, ("continuationToken",T.TString $ E.encodeUtf8 _v2245))) $ getJoinableSquareChatsRequest_continuationToken record
  , (\_v2245 -> P.Just (11, ("limit",T.TI32 _v2245))) $ getJoinableSquareChatsRequest_limit record
  ]
write_GetJoinableSquareChatsRequest :: T.Protocol p => p -> GetJoinableSquareChatsRequest -> P.IO ()
write_GetJoinableSquareChatsRequest oprot record = T.writeVal oprot $ from_GetJoinableSquareChatsRequest record
encode_GetJoinableSquareChatsRequest :: T.StatelessProtocol p => p -> GetJoinableSquareChatsRequest -> LBS.ByteString
encode_GetJoinableSquareChatsRequest oprot record = T.serializeVal oprot $ from_GetJoinableSquareChatsRequest record
to_GetJoinableSquareChatsRequest :: T.ThriftVal -> GetJoinableSquareChatsRequest
to_GetJoinableSquareChatsRequest (T.TStruct fields) = GetJoinableSquareChatsRequest{
  getJoinableSquareChatsRequest_squareMid = P.maybe (getJoinableSquareChatsRequest_squareMid default_GetJoinableSquareChatsRequest) (\(_,_val2247) -> (case _val2247 of {T.TString _val2248 -> E.decodeUtf8 _val2248; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getJoinableSquareChatsRequest_continuationToken = P.maybe (getJoinableSquareChatsRequest_continuationToken default_GetJoinableSquareChatsRequest) (\(_,_val2247) -> (case _val2247 of {T.TString _val2249 -> E.decodeUtf8 _val2249; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  getJoinableSquareChatsRequest_limit = P.maybe (getJoinableSquareChatsRequest_limit default_GetJoinableSquareChatsRequest) (\(_,_val2247) -> (case _val2247 of {T.TI32 _val2250 -> _val2250; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_GetJoinableSquareChatsRequest _ = P.error "not a struct"
read_GetJoinableSquareChatsRequest :: T.Protocol p => p -> P.IO GetJoinableSquareChatsRequest
read_GetJoinableSquareChatsRequest iprot = to_GetJoinableSquareChatsRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinableSquareChatsRequest)
decode_GetJoinableSquareChatsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinableSquareChatsRequest
decode_GetJoinableSquareChatsRequest iprot bs = to_GetJoinableSquareChatsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinableSquareChatsRequest) bs
typemap_GetJoinableSquareChatsRequest :: T.TypeMap
typemap_GetJoinableSquareChatsRequest = Map.fromList [(1,("squareMid",T.T_STRING)),(10,("continuationToken",T.T_STRING)),(11,("limit",T.T_I32))]
default_GetJoinableSquareChatsRequest :: GetJoinableSquareChatsRequest
default_GetJoinableSquareChatsRequest = GetJoinableSquareChatsRequest{
  getJoinableSquareChatsRequest_squareMid = "",
  getJoinableSquareChatsRequest_continuationToken = "",
  getJoinableSquareChatsRequest_limit = 0}
data GetJoinableSquareChatsResponse = GetJoinableSquareChatsResponse  { getJoinableSquareChatsResponse_squareChats :: (Vector.Vector SquareChat)
  , getJoinableSquareChatsResponse_continuationToken :: LT.Text
  , getJoinableSquareChatsResponse_totalSquareChatCount :: I.Int32
  , getJoinableSquareChatsResponse_squareChatStatuses :: (Map.HashMap LT.Text SquareChatStatus)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinableSquareChatsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinableSquareChatsResponse_squareChats record   `H.hashWithSalt` getJoinableSquareChatsResponse_continuationToken record   `H.hashWithSalt` getJoinableSquareChatsResponse_totalSquareChatCount record   `H.hashWithSalt` getJoinableSquareChatsResponse_squareChatStatuses record  
instance QC.Arbitrary GetJoinableSquareChatsResponse where 
  arbitrary = M.liftM GetJoinableSquareChatsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinableSquareChatsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_squareChats = getJoinableSquareChatsResponse_squareChats obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_squareChats = getJoinableSquareChatsResponse_squareChats obj}
    , if obj == default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_continuationToken = getJoinableSquareChatsResponse_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_continuationToken = getJoinableSquareChatsResponse_continuationToken obj}
    , if obj == default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_totalSquareChatCount = getJoinableSquareChatsResponse_totalSquareChatCount obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_totalSquareChatCount = getJoinableSquareChatsResponse_totalSquareChatCount obj}
    , if obj == default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_squareChatStatuses = getJoinableSquareChatsResponse_squareChatStatuses obj} then P.Nothing else P.Just $ default_GetJoinableSquareChatsResponse{getJoinableSquareChatsResponse_squareChatStatuses = getJoinableSquareChatsResponse_squareChatStatuses obj}
    ]
from_GetJoinableSquareChatsResponse :: GetJoinableSquareChatsResponse -> T.ThriftVal
from_GetJoinableSquareChatsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2253 -> P.Just (1, ("squareChats",T.TList (T.T_STRUCT typemap_SquareChat) $ P.map (\_v2255 -> from_SquareChat _v2255) $ Vector.toList _v2253))) $ getJoinableSquareChatsResponse_squareChats record
  , (\_v2253 -> P.Just (2, ("continuationToken",T.TString $ E.encodeUtf8 _v2253))) $ getJoinableSquareChatsResponse_continuationToken record
  , (\_v2253 -> P.Just (3, ("totalSquareChatCount",T.TI32 _v2253))) $ getJoinableSquareChatsResponse_totalSquareChatCount record
  , (\_v2253 -> P.Just (4, ("squareChatStatuses",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareChatStatus) $ P.map (\(_k2256,_v2257) -> (T.TString $ E.encodeUtf8 _k2256, from_SquareChatStatus _v2257)) $ Map.toList _v2253))) $ getJoinableSquareChatsResponse_squareChatStatuses record
  ]
write_GetJoinableSquareChatsResponse :: T.Protocol p => p -> GetJoinableSquareChatsResponse -> P.IO ()
write_GetJoinableSquareChatsResponse oprot record = T.writeVal oprot $ from_GetJoinableSquareChatsResponse record
encode_GetJoinableSquareChatsResponse :: T.StatelessProtocol p => p -> GetJoinableSquareChatsResponse -> LBS.ByteString
encode_GetJoinableSquareChatsResponse oprot record = T.serializeVal oprot $ from_GetJoinableSquareChatsResponse record
to_GetJoinableSquareChatsResponse :: T.ThriftVal -> GetJoinableSquareChatsResponse
to_GetJoinableSquareChatsResponse (T.TStruct fields) = GetJoinableSquareChatsResponse{
  getJoinableSquareChatsResponse_squareChats = P.maybe (getJoinableSquareChatsResponse_squareChats default_GetJoinableSquareChatsResponse) (\(_,_val2259) -> (case _val2259 of {T.TList _ _val2260 -> (Vector.fromList $ P.map (\_v2261 -> (case _v2261 of {T.TStruct _val2262 -> (to_SquareChat (T.TStruct _val2262)); _ -> P.error "wrong type"})) _val2260); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getJoinableSquareChatsResponse_continuationToken = P.maybe (getJoinableSquareChatsResponse_continuationToken default_GetJoinableSquareChatsResponse) (\(_,_val2259) -> (case _val2259 of {T.TString _val2263 -> E.decodeUtf8 _val2263; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getJoinableSquareChatsResponse_totalSquareChatCount = P.maybe (getJoinableSquareChatsResponse_totalSquareChatCount default_GetJoinableSquareChatsResponse) (\(_,_val2259) -> (case _val2259 of {T.TI32 _val2264 -> _val2264; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getJoinableSquareChatsResponse_squareChatStatuses = P.maybe (getJoinableSquareChatsResponse_squareChatStatuses default_GetJoinableSquareChatsResponse) (\(_,_val2259) -> (case _val2259 of {T.TMap _ _ _val2265 -> (Map.fromList $ P.map (\(_k2267,_v2266) -> ((case _k2267 of {T.TString _val2268 -> E.decodeUtf8 _val2268; _ -> P.error "wrong type"}),(case _v2266 of {T.TStruct _val2269 -> (to_SquareChatStatus (T.TStruct _val2269)); _ -> P.error "wrong type"}))) _val2265); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetJoinableSquareChatsResponse _ = P.error "not a struct"
read_GetJoinableSquareChatsResponse :: T.Protocol p => p -> P.IO GetJoinableSquareChatsResponse
read_GetJoinableSquareChatsResponse iprot = to_GetJoinableSquareChatsResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinableSquareChatsResponse)
decode_GetJoinableSquareChatsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinableSquareChatsResponse
decode_GetJoinableSquareChatsResponse iprot bs = to_GetJoinableSquareChatsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinableSquareChatsResponse) bs
typemap_GetJoinableSquareChatsResponse :: T.TypeMap
typemap_GetJoinableSquareChatsResponse = Map.fromList [(1,("squareChats",(T.T_LIST (T.T_STRUCT typemap_SquareChat)))),(2,("continuationToken",T.T_STRING)),(3,("totalSquareChatCount",T.T_I32)),(4,("squareChatStatuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareChatStatus))))]
default_GetJoinableSquareChatsResponse :: GetJoinableSquareChatsResponse
default_GetJoinableSquareChatsResponse = GetJoinableSquareChatsResponse{
  getJoinableSquareChatsResponse_squareChats = Vector.empty,
  getJoinableSquareChatsResponse_continuationToken = "",
  getJoinableSquareChatsResponse_totalSquareChatCount = 0,
  getJoinableSquareChatsResponse_squareChatStatuses = Map.empty}
data GetInvitationTicketUrlRequest = GetInvitationTicketUrlRequest  { getInvitationTicketUrlRequest_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetInvitationTicketUrlRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getInvitationTicketUrlRequest_mid record  
instance QC.Arbitrary GetInvitationTicketUrlRequest where 
  arbitrary = M.liftM GetInvitationTicketUrlRequest (QC.arbitrary)
  shrink obj | obj == default_GetInvitationTicketUrlRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetInvitationTicketUrlRequest{getInvitationTicketUrlRequest_mid = getInvitationTicketUrlRequest_mid obj} then P.Nothing else P.Just $ default_GetInvitationTicketUrlRequest{getInvitationTicketUrlRequest_mid = getInvitationTicketUrlRequest_mid obj}
    ]
from_GetInvitationTicketUrlRequest :: GetInvitationTicketUrlRequest -> T.ThriftVal
from_GetInvitationTicketUrlRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2272 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v2272))) $ getInvitationTicketUrlRequest_mid record
  ]
write_GetInvitationTicketUrlRequest :: T.Protocol p => p -> GetInvitationTicketUrlRequest -> P.IO ()
write_GetInvitationTicketUrlRequest oprot record = T.writeVal oprot $ from_GetInvitationTicketUrlRequest record
encode_GetInvitationTicketUrlRequest :: T.StatelessProtocol p => p -> GetInvitationTicketUrlRequest -> LBS.ByteString
encode_GetInvitationTicketUrlRequest oprot record = T.serializeVal oprot $ from_GetInvitationTicketUrlRequest record
to_GetInvitationTicketUrlRequest :: T.ThriftVal -> GetInvitationTicketUrlRequest
to_GetInvitationTicketUrlRequest (T.TStruct fields) = GetInvitationTicketUrlRequest{
  getInvitationTicketUrlRequest_mid = P.maybe (getInvitationTicketUrlRequest_mid default_GetInvitationTicketUrlRequest) (\(_,_val2274) -> (case _val2274 of {T.TString _val2275 -> E.decodeUtf8 _val2275; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetInvitationTicketUrlRequest _ = P.error "not a struct"
read_GetInvitationTicketUrlRequest :: T.Protocol p => p -> P.IO GetInvitationTicketUrlRequest
read_GetInvitationTicketUrlRequest iprot = to_GetInvitationTicketUrlRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrlRequest)
decode_GetInvitationTicketUrlRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetInvitationTicketUrlRequest
decode_GetInvitationTicketUrlRequest iprot bs = to_GetInvitationTicketUrlRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrlRequest) bs
typemap_GetInvitationTicketUrlRequest :: T.TypeMap
typemap_GetInvitationTicketUrlRequest = Map.fromList [(2,("mid",T.T_STRING))]
default_GetInvitationTicketUrlRequest :: GetInvitationTicketUrlRequest
default_GetInvitationTicketUrlRequest = GetInvitationTicketUrlRequest{
  getInvitationTicketUrlRequest_mid = ""}
data GetInvitationTicketUrlResponse = GetInvitationTicketUrlResponse  { getInvitationTicketUrlResponse_invitationURL :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetInvitationTicketUrlResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getInvitationTicketUrlResponse_invitationURL record  
instance QC.Arbitrary GetInvitationTicketUrlResponse where 
  arbitrary = M.liftM GetInvitationTicketUrlResponse (QC.arbitrary)
  shrink obj | obj == default_GetInvitationTicketUrlResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetInvitationTicketUrlResponse{getInvitationTicketUrlResponse_invitationURL = getInvitationTicketUrlResponse_invitationURL obj} then P.Nothing else P.Just $ default_GetInvitationTicketUrlResponse{getInvitationTicketUrlResponse_invitationURL = getInvitationTicketUrlResponse_invitationURL obj}
    ]
from_GetInvitationTicketUrlResponse :: GetInvitationTicketUrlResponse -> T.ThriftVal
from_GetInvitationTicketUrlResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2278 -> P.Just (1, ("invitationURL",T.TString $ E.encodeUtf8 _v2278))) $ getInvitationTicketUrlResponse_invitationURL record
  ]
write_GetInvitationTicketUrlResponse :: T.Protocol p => p -> GetInvitationTicketUrlResponse -> P.IO ()
write_GetInvitationTicketUrlResponse oprot record = T.writeVal oprot $ from_GetInvitationTicketUrlResponse record
encode_GetInvitationTicketUrlResponse :: T.StatelessProtocol p => p -> GetInvitationTicketUrlResponse -> LBS.ByteString
encode_GetInvitationTicketUrlResponse oprot record = T.serializeVal oprot $ from_GetInvitationTicketUrlResponse record
to_GetInvitationTicketUrlResponse :: T.ThriftVal -> GetInvitationTicketUrlResponse
to_GetInvitationTicketUrlResponse (T.TStruct fields) = GetInvitationTicketUrlResponse{
  getInvitationTicketUrlResponse_invitationURL = P.maybe (getInvitationTicketUrlResponse_invitationURL default_GetInvitationTicketUrlResponse) (\(_,_val2280) -> (case _val2280 of {T.TString _val2281 -> E.decodeUtf8 _val2281; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetInvitationTicketUrlResponse _ = P.error "not a struct"
read_GetInvitationTicketUrlResponse :: T.Protocol p => p -> P.IO GetInvitationTicketUrlResponse
read_GetInvitationTicketUrlResponse iprot = to_GetInvitationTicketUrlResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrlResponse)
decode_GetInvitationTicketUrlResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetInvitationTicketUrlResponse
decode_GetInvitationTicketUrlResponse iprot bs = to_GetInvitationTicketUrlResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrlResponse) bs
typemap_GetInvitationTicketUrlResponse :: T.TypeMap
typemap_GetInvitationTicketUrlResponse = Map.fromList [(1,("invitationURL",T.T_STRING))]
default_GetInvitationTicketUrlResponse :: GetInvitationTicketUrlResponse
default_GetInvitationTicketUrlResponse = GetInvitationTicketUrlResponse{
  getInvitationTicketUrlResponse_invitationURL = ""}
data LeaveSquareRequest = LeaveSquareRequest  { leaveSquareRequest_squareMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquareRequest_squareMid record  
instance QC.Arbitrary LeaveSquareRequest where 
  arbitrary = M.liftM LeaveSquareRequest (QC.arbitrary)
  shrink obj | obj == default_LeaveSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquareRequest{leaveSquareRequest_squareMid = leaveSquareRequest_squareMid obj} then P.Nothing else P.Just $ default_LeaveSquareRequest{leaveSquareRequest_squareMid = leaveSquareRequest_squareMid obj}
    ]
from_LeaveSquareRequest :: LeaveSquareRequest -> T.ThriftVal
from_LeaveSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2284 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2284))) $ leaveSquareRequest_squareMid record
  ]
write_LeaveSquareRequest :: T.Protocol p => p -> LeaveSquareRequest -> P.IO ()
write_LeaveSquareRequest oprot record = T.writeVal oprot $ from_LeaveSquareRequest record
encode_LeaveSquareRequest :: T.StatelessProtocol p => p -> LeaveSquareRequest -> LBS.ByteString
encode_LeaveSquareRequest oprot record = T.serializeVal oprot $ from_LeaveSquareRequest record
to_LeaveSquareRequest :: T.ThriftVal -> LeaveSquareRequest
to_LeaveSquareRequest (T.TStruct fields) = LeaveSquareRequest{
  leaveSquareRequest_squareMid = P.maybe (leaveSquareRequest_squareMid default_LeaveSquareRequest) (\(_,_val2286) -> (case _val2286 of {T.TString _val2287 -> E.decodeUtf8 _val2287; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LeaveSquareRequest _ = P.error "not a struct"
read_LeaveSquareRequest :: T.Protocol p => p -> P.IO LeaveSquareRequest
read_LeaveSquareRequest iprot = to_LeaveSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareRequest)
decode_LeaveSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareRequest
decode_LeaveSquareRequest iprot bs = to_LeaveSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareRequest) bs
typemap_LeaveSquareRequest :: T.TypeMap
typemap_LeaveSquareRequest = Map.fromList [(2,("squareMid",T.T_STRING))]
default_LeaveSquareRequest :: LeaveSquareRequest
default_LeaveSquareRequest = LeaveSquareRequest{
  leaveSquareRequest_squareMid = ""}
data LeaveSquareResponse = LeaveSquareResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary LeaveSquareResponse where 
  arbitrary = QC.elements [LeaveSquareResponse]
from_LeaveSquareResponse :: LeaveSquareResponse -> T.ThriftVal
from_LeaveSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_LeaveSquareResponse :: T.Protocol p => p -> LeaveSquareResponse -> P.IO ()
write_LeaveSquareResponse oprot record = T.writeVal oprot $ from_LeaveSquareResponse record
encode_LeaveSquareResponse :: T.StatelessProtocol p => p -> LeaveSquareResponse -> LBS.ByteString
encode_LeaveSquareResponse oprot record = T.serializeVal oprot $ from_LeaveSquareResponse record
to_LeaveSquareResponse :: T.ThriftVal -> LeaveSquareResponse
to_LeaveSquareResponse (T.TStruct fields) = LeaveSquareResponse{

  }
to_LeaveSquareResponse _ = P.error "not a struct"
read_LeaveSquareResponse :: T.Protocol p => p -> P.IO LeaveSquareResponse
read_LeaveSquareResponse iprot = to_LeaveSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareResponse)
decode_LeaveSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareResponse
decode_LeaveSquareResponse iprot bs = to_LeaveSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareResponse) bs
typemap_LeaveSquareResponse :: T.TypeMap
typemap_LeaveSquareResponse = Map.fromList []
default_LeaveSquareResponse :: LeaveSquareResponse
default_LeaveSquareResponse = LeaveSquareResponse{
}
data LeaveSquareChatRequest = LeaveSquareChatRequest  { leaveSquareChatRequest_squareChatMid :: LT.Text
  , leaveSquareChatRequest_sayGoodbye :: P.Bool
  , leaveSquareChatRequest_squareChatMemberRevision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquareChatRequest_squareChatMid record   `H.hashWithSalt` leaveSquareChatRequest_sayGoodbye record   `H.hashWithSalt` leaveSquareChatRequest_squareChatMemberRevision record  
instance QC.Arbitrary LeaveSquareChatRequest where 
  arbitrary = M.liftM LeaveSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LeaveSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquareChatRequest{leaveSquareChatRequest_squareChatMid = leaveSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_LeaveSquareChatRequest{leaveSquareChatRequest_squareChatMid = leaveSquareChatRequest_squareChatMid obj}
    , if obj == default_LeaveSquareChatRequest{leaveSquareChatRequest_sayGoodbye = leaveSquareChatRequest_sayGoodbye obj} then P.Nothing else P.Just $ default_LeaveSquareChatRequest{leaveSquareChatRequest_sayGoodbye = leaveSquareChatRequest_sayGoodbye obj}
    , if obj == default_LeaveSquareChatRequest{leaveSquareChatRequest_squareChatMemberRevision = leaveSquareChatRequest_squareChatMemberRevision obj} then P.Nothing else P.Just $ default_LeaveSquareChatRequest{leaveSquareChatRequest_squareChatMemberRevision = leaveSquareChatRequest_squareChatMemberRevision obj}
    ]
from_LeaveSquareChatRequest :: LeaveSquareChatRequest -> T.ThriftVal
from_LeaveSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2295 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2295))) $ leaveSquareChatRequest_squareChatMid record
  , (\_v2295 -> P.Just (3, ("sayGoodbye",T.TBool _v2295))) $ leaveSquareChatRequest_sayGoodbye record
  , (\_v2295 -> P.Just (4, ("squareChatMemberRevision",T.TI64 _v2295))) $ leaveSquareChatRequest_squareChatMemberRevision record
  ]
write_LeaveSquareChatRequest :: T.Protocol p => p -> LeaveSquareChatRequest -> P.IO ()
write_LeaveSquareChatRequest oprot record = T.writeVal oprot $ from_LeaveSquareChatRequest record
encode_LeaveSquareChatRequest :: T.StatelessProtocol p => p -> LeaveSquareChatRequest -> LBS.ByteString
encode_LeaveSquareChatRequest oprot record = T.serializeVal oprot $ from_LeaveSquareChatRequest record
to_LeaveSquareChatRequest :: T.ThriftVal -> LeaveSquareChatRequest
to_LeaveSquareChatRequest (T.TStruct fields) = LeaveSquareChatRequest{
  leaveSquareChatRequest_squareChatMid = P.maybe (leaveSquareChatRequest_squareChatMid default_LeaveSquareChatRequest) (\(_,_val2297) -> (case _val2297 of {T.TString _val2298 -> E.decodeUtf8 _val2298; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  leaveSquareChatRequest_sayGoodbye = P.maybe (leaveSquareChatRequest_sayGoodbye default_LeaveSquareChatRequest) (\(_,_val2297) -> (case _val2297 of {T.TBool _val2299 -> _val2299; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  leaveSquareChatRequest_squareChatMemberRevision = P.maybe (leaveSquareChatRequest_squareChatMemberRevision default_LeaveSquareChatRequest) (\(_,_val2297) -> (case _val2297 of {T.TI64 _val2300 -> _val2300; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_LeaveSquareChatRequest _ = P.error "not a struct"
read_LeaveSquareChatRequest :: T.Protocol p => p -> P.IO LeaveSquareChatRequest
read_LeaveSquareChatRequest iprot = to_LeaveSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareChatRequest)
decode_LeaveSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareChatRequest
decode_LeaveSquareChatRequest iprot bs = to_LeaveSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareChatRequest) bs
typemap_LeaveSquareChatRequest :: T.TypeMap
typemap_LeaveSquareChatRequest = Map.fromList [(2,("squareChatMid",T.T_STRING)),(3,("sayGoodbye",T.T_BOOL)),(4,("squareChatMemberRevision",T.T_I64))]
default_LeaveSquareChatRequest :: LeaveSquareChatRequest
default_LeaveSquareChatRequest = LeaveSquareChatRequest{
  leaveSquareChatRequest_squareChatMid = "",
  leaveSquareChatRequest_sayGoodbye = P.False,
  leaveSquareChatRequest_squareChatMemberRevision = 0}
data LeaveSquareChatResponse = LeaveSquareChatResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareChatResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary LeaveSquareChatResponse where 
  arbitrary = QC.elements [LeaveSquareChatResponse]
from_LeaveSquareChatResponse :: LeaveSquareChatResponse -> T.ThriftVal
from_LeaveSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_LeaveSquareChatResponse :: T.Protocol p => p -> LeaveSquareChatResponse -> P.IO ()
write_LeaveSquareChatResponse oprot record = T.writeVal oprot $ from_LeaveSquareChatResponse record
encode_LeaveSquareChatResponse :: T.StatelessProtocol p => p -> LeaveSquareChatResponse -> LBS.ByteString
encode_LeaveSquareChatResponse oprot record = T.serializeVal oprot $ from_LeaveSquareChatResponse record
to_LeaveSquareChatResponse :: T.ThriftVal -> LeaveSquareChatResponse
to_LeaveSquareChatResponse (T.TStruct fields) = LeaveSquareChatResponse{

  }
to_LeaveSquareChatResponse _ = P.error "not a struct"
read_LeaveSquareChatResponse :: T.Protocol p => p -> P.IO LeaveSquareChatResponse
read_LeaveSquareChatResponse iprot = to_LeaveSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareChatResponse)
decode_LeaveSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareChatResponse
decode_LeaveSquareChatResponse iprot bs = to_LeaveSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareChatResponse) bs
typemap_LeaveSquareChatResponse :: T.TypeMap
typemap_LeaveSquareChatResponse = Map.fromList []
default_LeaveSquareChatResponse :: LeaveSquareChatResponse
default_LeaveSquareChatResponse = LeaveSquareChatResponse{
}
data SquareMemberSearchOption = SquareMemberSearchOption  { squareMemberSearchOption_membershipState :: SquareMembershipState
  , squareMemberSearchOption_memberRoles :: (Set.HashSet SquareMemberRole)
  , squareMemberSearchOption_displayName :: LT.Text
  , squareMemberSearchOption_ableToReceiveMessage :: BooleanState
  , squareMemberSearchOption_ableToReceiveFriendRequest :: BooleanState
  , squareMemberSearchOption_chatMidToExcludeMembers :: LT.Text
  , squareMemberSearchOption_includingMe :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareMemberSearchOption where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareMemberSearchOption_membershipState record   `H.hashWithSalt` squareMemberSearchOption_memberRoles record   `H.hashWithSalt` squareMemberSearchOption_displayName record   `H.hashWithSalt` squareMemberSearchOption_ableToReceiveMessage record   `H.hashWithSalt` squareMemberSearchOption_ableToReceiveFriendRequest record   `H.hashWithSalt` squareMemberSearchOption_chatMidToExcludeMembers record   `H.hashWithSalt` squareMemberSearchOption_includingMe record  
instance QC.Arbitrary SquareMemberSearchOption where 
  arbitrary = M.liftM SquareMemberSearchOption (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareMemberSearchOption = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareMemberSearchOption{squareMemberSearchOption_membershipState = squareMemberSearchOption_membershipState obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_membershipState = squareMemberSearchOption_membershipState obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_memberRoles = squareMemberSearchOption_memberRoles obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_memberRoles = squareMemberSearchOption_memberRoles obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_displayName = squareMemberSearchOption_displayName obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_displayName = squareMemberSearchOption_displayName obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_ableToReceiveMessage = squareMemberSearchOption_ableToReceiveMessage obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_ableToReceiveMessage = squareMemberSearchOption_ableToReceiveMessage obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_ableToReceiveFriendRequest = squareMemberSearchOption_ableToReceiveFriendRequest obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_ableToReceiveFriendRequest = squareMemberSearchOption_ableToReceiveFriendRequest obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_chatMidToExcludeMembers = squareMemberSearchOption_chatMidToExcludeMembers obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_chatMidToExcludeMembers = squareMemberSearchOption_chatMidToExcludeMembers obj}
    , if obj == default_SquareMemberSearchOption{squareMemberSearchOption_includingMe = squareMemberSearchOption_includingMe obj} then P.Nothing else P.Just $ default_SquareMemberSearchOption{squareMemberSearchOption_includingMe = squareMemberSearchOption_includingMe obj}
    ]
from_SquareMemberSearchOption :: SquareMemberSearchOption -> T.ThriftVal
from_SquareMemberSearchOption record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2308 -> P.Just (1, ("membershipState",T.TI32 $ P.fromIntegral $ P.fromEnum _v2308))) $ squareMemberSearchOption_membershipState record
  , (\_v2308 -> P.Just (2, ("memberRoles",T.TSet T.T_I32 $ P.map (\_v2310 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2310) $ Set.toList _v2308))) $ squareMemberSearchOption_memberRoles record
  , (\_v2308 -> P.Just (3, ("displayName",T.TString $ E.encodeUtf8 _v2308))) $ squareMemberSearchOption_displayName record
  , (\_v2308 -> P.Just (4, ("ableToReceiveMessage",T.TI32 $ P.fromIntegral $ P.fromEnum _v2308))) $ squareMemberSearchOption_ableToReceiveMessage record
  , (\_v2308 -> P.Just (5, ("ableToReceiveFriendRequest",T.TI32 $ P.fromIntegral $ P.fromEnum _v2308))) $ squareMemberSearchOption_ableToReceiveFriendRequest record
  , (\_v2308 -> P.Just (6, ("chatMidToExcludeMembers",T.TString $ E.encodeUtf8 _v2308))) $ squareMemberSearchOption_chatMidToExcludeMembers record
  , (\_v2308 -> P.Just (7, ("includingMe",T.TBool _v2308))) $ squareMemberSearchOption_includingMe record
  ]
write_SquareMemberSearchOption :: T.Protocol p => p -> SquareMemberSearchOption -> P.IO ()
write_SquareMemberSearchOption oprot record = T.writeVal oprot $ from_SquareMemberSearchOption record
encode_SquareMemberSearchOption :: T.StatelessProtocol p => p -> SquareMemberSearchOption -> LBS.ByteString
encode_SquareMemberSearchOption oprot record = T.serializeVal oprot $ from_SquareMemberSearchOption record
to_SquareMemberSearchOption :: T.ThriftVal -> SquareMemberSearchOption
to_SquareMemberSearchOption (T.TStruct fields) = SquareMemberSearchOption{
  squareMemberSearchOption_membershipState = P.maybe (squareMemberSearchOption_membershipState default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TI32 _val2313 -> P.toEnum $ P.fromIntegral _val2313; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareMemberSearchOption_memberRoles = P.maybe (squareMemberSearchOption_memberRoles default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TSet _ _val2314 -> (Set.fromList $ P.map (\_v2315 -> (case _v2315 of {T.TI32 _val2316 -> P.toEnum $ P.fromIntegral _val2316; _ -> P.error "wrong type"})) _val2314); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareMemberSearchOption_displayName = P.maybe (squareMemberSearchOption_displayName default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TString _val2317 -> E.decodeUtf8 _val2317; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareMemberSearchOption_ableToReceiveMessage = P.maybe (squareMemberSearchOption_ableToReceiveMessage default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TI32 _val2318 -> P.toEnum $ P.fromIntegral _val2318; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareMemberSearchOption_ableToReceiveFriendRequest = P.maybe (squareMemberSearchOption_ableToReceiveFriendRequest default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TI32 _val2319 -> P.toEnum $ P.fromIntegral _val2319; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareMemberSearchOption_chatMidToExcludeMembers = P.maybe (squareMemberSearchOption_chatMidToExcludeMembers default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TString _val2320 -> E.decodeUtf8 _val2320; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  squareMemberSearchOption_includingMe = P.maybe (squareMemberSearchOption_includingMe default_SquareMemberSearchOption) (\(_,_val2312) -> (case _val2312 of {T.TBool _val2321 -> _val2321; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_SquareMemberSearchOption _ = P.error "not a struct"
read_SquareMemberSearchOption :: T.Protocol p => p -> P.IO SquareMemberSearchOption
read_SquareMemberSearchOption iprot = to_SquareMemberSearchOption <$> T.readVal iprot (T.T_STRUCT typemap_SquareMemberSearchOption)
decode_SquareMemberSearchOption :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareMemberSearchOption
decode_SquareMemberSearchOption iprot bs = to_SquareMemberSearchOption $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareMemberSearchOption) bs
typemap_SquareMemberSearchOption :: T.TypeMap
typemap_SquareMemberSearchOption = Map.fromList [(1,("membershipState",T.T_I32)),(2,("memberRoles",(T.T_SET T.T_I32))),(3,("displayName",T.T_STRING)),(4,("ableToReceiveMessage",T.T_I32)),(5,("ableToReceiveFriendRequest",T.T_I32)),(6,("chatMidToExcludeMembers",T.T_STRING)),(7,("includingMe",T.T_BOOL))]
default_SquareMemberSearchOption :: SquareMemberSearchOption
default_SquareMemberSearchOption = SquareMemberSearchOption{
  squareMemberSearchOption_membershipState = (P.toEnum 0),
  squareMemberSearchOption_memberRoles = Set.empty,
  squareMemberSearchOption_displayName = "",
  squareMemberSearchOption_ableToReceiveMessage = (P.toEnum 0),
  squareMemberSearchOption_ableToReceiveFriendRequest = (P.toEnum 0),
  squareMemberSearchOption_chatMidToExcludeMembers = "",
  squareMemberSearchOption_includingMe = P.False}
data SearchSquareMembersRequest = SearchSquareMembersRequest  { searchSquareMembersRequest_squareMid :: LT.Text
  , searchSquareMembersRequest_searchOption :: SquareMemberSearchOption
  , searchSquareMembersRequest_continuationToken :: LT.Text
  , searchSquareMembersRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquareMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquareMembersRequest_squareMid record   `H.hashWithSalt` searchSquareMembersRequest_searchOption record   `H.hashWithSalt` searchSquareMembersRequest_continuationToken record   `H.hashWithSalt` searchSquareMembersRequest_limit record  
instance QC.Arbitrary SearchSquareMembersRequest where 
  arbitrary = M.liftM SearchSquareMembersRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchSquareMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquareMembersRequest{searchSquareMembersRequest_squareMid = searchSquareMembersRequest_squareMid obj} then P.Nothing else P.Just $ default_SearchSquareMembersRequest{searchSquareMembersRequest_squareMid = searchSquareMembersRequest_squareMid obj}
    , if obj == default_SearchSquareMembersRequest{searchSquareMembersRequest_searchOption = searchSquareMembersRequest_searchOption obj} then P.Nothing else P.Just $ default_SearchSquareMembersRequest{searchSquareMembersRequest_searchOption = searchSquareMembersRequest_searchOption obj}
    , if obj == default_SearchSquareMembersRequest{searchSquareMembersRequest_continuationToken = searchSquareMembersRequest_continuationToken obj} then P.Nothing else P.Just $ default_SearchSquareMembersRequest{searchSquareMembersRequest_continuationToken = searchSquareMembersRequest_continuationToken obj}
    , if obj == default_SearchSquareMembersRequest{searchSquareMembersRequest_limit = searchSquareMembersRequest_limit obj} then P.Nothing else P.Just $ default_SearchSquareMembersRequest{searchSquareMembersRequest_limit = searchSquareMembersRequest_limit obj}
    ]
from_SearchSquareMembersRequest :: SearchSquareMembersRequest -> T.ThriftVal
from_SearchSquareMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2324 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2324))) $ searchSquareMembersRequest_squareMid record
  , (\_v2324 -> P.Just (3, ("searchOption",from_SquareMemberSearchOption _v2324))) $ searchSquareMembersRequest_searchOption record
  , (\_v2324 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v2324))) $ searchSquareMembersRequest_continuationToken record
  , (\_v2324 -> P.Just (5, ("limit",T.TI32 _v2324))) $ searchSquareMembersRequest_limit record
  ]
write_SearchSquareMembersRequest :: T.Protocol p => p -> SearchSquareMembersRequest -> P.IO ()
write_SearchSquareMembersRequest oprot record = T.writeVal oprot $ from_SearchSquareMembersRequest record
encode_SearchSquareMembersRequest :: T.StatelessProtocol p => p -> SearchSquareMembersRequest -> LBS.ByteString
encode_SearchSquareMembersRequest oprot record = T.serializeVal oprot $ from_SearchSquareMembersRequest record
to_SearchSquareMembersRequest :: T.ThriftVal -> SearchSquareMembersRequest
to_SearchSquareMembersRequest (T.TStruct fields) = SearchSquareMembersRequest{
  searchSquareMembersRequest_squareMid = P.maybe (searchSquareMembersRequest_squareMid default_SearchSquareMembersRequest) (\(_,_val2326) -> (case _val2326 of {T.TString _val2327 -> E.decodeUtf8 _val2327; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchSquareMembersRequest_searchOption = P.maybe (searchSquareMembersRequest_searchOption default_SearchSquareMembersRequest) (\(_,_val2326) -> (case _val2326 of {T.TStruct _val2328 -> (to_SquareMemberSearchOption (T.TStruct _val2328)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchSquareMembersRequest_continuationToken = P.maybe (searchSquareMembersRequest_continuationToken default_SearchSquareMembersRequest) (\(_,_val2326) -> (case _val2326 of {T.TString _val2329 -> E.decodeUtf8 _val2329; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  searchSquareMembersRequest_limit = P.maybe (searchSquareMembersRequest_limit default_SearchSquareMembersRequest) (\(_,_val2326) -> (case _val2326 of {T.TI32 _val2330 -> _val2330; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SearchSquareMembersRequest _ = P.error "not a struct"
read_SearchSquareMembersRequest :: T.Protocol p => p -> P.IO SearchSquareMembersRequest
read_SearchSquareMembersRequest iprot = to_SearchSquareMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquareMembersRequest)
decode_SearchSquareMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquareMembersRequest
decode_SearchSquareMembersRequest iprot bs = to_SearchSquareMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquareMembersRequest) bs
typemap_SearchSquareMembersRequest :: T.TypeMap
typemap_SearchSquareMembersRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("searchOption",(T.T_STRUCT typemap_SquareMemberSearchOption))),(4,("continuationToken",T.T_STRING)),(5,("limit",T.T_I32))]
default_SearchSquareMembersRequest :: SearchSquareMembersRequest
default_SearchSquareMembersRequest = SearchSquareMembersRequest{
  searchSquareMembersRequest_squareMid = "",
  searchSquareMembersRequest_searchOption = default_SquareMemberSearchOption,
  searchSquareMembersRequest_continuationToken = "",
  searchSquareMembersRequest_limit = 0}
data SearchSquareMembersResponse = SearchSquareMembersResponse  { searchSquareMembersResponse_members :: (Vector.Vector SquareMember)
  , searchSquareMembersResponse_revision :: I.Int64
  , searchSquareMembersResponse_continuationToken :: LT.Text
  , searchSquareMembersResponse_totalCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquareMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquareMembersResponse_members record   `H.hashWithSalt` searchSquareMembersResponse_revision record   `H.hashWithSalt` searchSquareMembersResponse_continuationToken record   `H.hashWithSalt` searchSquareMembersResponse_totalCount record  
instance QC.Arbitrary SearchSquareMembersResponse where 
  arbitrary = M.liftM SearchSquareMembersResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchSquareMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquareMembersResponse{searchSquareMembersResponse_members = searchSquareMembersResponse_members obj} then P.Nothing else P.Just $ default_SearchSquareMembersResponse{searchSquareMembersResponse_members = searchSquareMembersResponse_members obj}
    , if obj == default_SearchSquareMembersResponse{searchSquareMembersResponse_revision = searchSquareMembersResponse_revision obj} then P.Nothing else P.Just $ default_SearchSquareMembersResponse{searchSquareMembersResponse_revision = searchSquareMembersResponse_revision obj}
    , if obj == default_SearchSquareMembersResponse{searchSquareMembersResponse_continuationToken = searchSquareMembersResponse_continuationToken obj} then P.Nothing else P.Just $ default_SearchSquareMembersResponse{searchSquareMembersResponse_continuationToken = searchSquareMembersResponse_continuationToken obj}
    , if obj == default_SearchSquareMembersResponse{searchSquareMembersResponse_totalCount = searchSquareMembersResponse_totalCount obj} then P.Nothing else P.Just $ default_SearchSquareMembersResponse{searchSquareMembersResponse_totalCount = searchSquareMembersResponse_totalCount obj}
    ]
from_SearchSquareMembersResponse :: SearchSquareMembersResponse -> T.ThriftVal
from_SearchSquareMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2333 -> P.Just (1, ("members",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2335 -> from_SquareMember _v2335) $ Vector.toList _v2333))) $ searchSquareMembersResponse_members record
  , (\_v2333 -> P.Just (2, ("revision",T.TI64 _v2333))) $ searchSquareMembersResponse_revision record
  , (\_v2333 -> P.Just (3, ("continuationToken",T.TString $ E.encodeUtf8 _v2333))) $ searchSquareMembersResponse_continuationToken record
  , (\_v2333 -> P.Just (4, ("totalCount",T.TI32 _v2333))) $ searchSquareMembersResponse_totalCount record
  ]
write_SearchSquareMembersResponse :: T.Protocol p => p -> SearchSquareMembersResponse -> P.IO ()
write_SearchSquareMembersResponse oprot record = T.writeVal oprot $ from_SearchSquareMembersResponse record
encode_SearchSquareMembersResponse :: T.StatelessProtocol p => p -> SearchSquareMembersResponse -> LBS.ByteString
encode_SearchSquareMembersResponse oprot record = T.serializeVal oprot $ from_SearchSquareMembersResponse record
to_SearchSquareMembersResponse :: T.ThriftVal -> SearchSquareMembersResponse
to_SearchSquareMembersResponse (T.TStruct fields) = SearchSquareMembersResponse{
  searchSquareMembersResponse_members = P.maybe (searchSquareMembersResponse_members default_SearchSquareMembersResponse) (\(_,_val2337) -> (case _val2337 of {T.TList _ _val2338 -> (Vector.fromList $ P.map (\_v2339 -> (case _v2339 of {T.TStruct _val2340 -> (to_SquareMember (T.TStruct _val2340)); _ -> P.error "wrong type"})) _val2338); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchSquareMembersResponse_revision = P.maybe (searchSquareMembersResponse_revision default_SearchSquareMembersResponse) (\(_,_val2337) -> (case _val2337 of {T.TI64 _val2341 -> _val2341; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchSquareMembersResponse_continuationToken = P.maybe (searchSquareMembersResponse_continuationToken default_SearchSquareMembersResponse) (\(_,_val2337) -> (case _val2337 of {T.TString _val2342 -> E.decodeUtf8 _val2342; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchSquareMembersResponse_totalCount = P.maybe (searchSquareMembersResponse_totalCount default_SearchSquareMembersResponse) (\(_,_val2337) -> (case _val2337 of {T.TI32 _val2343 -> _val2343; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SearchSquareMembersResponse _ = P.error "not a struct"
read_SearchSquareMembersResponse :: T.Protocol p => p -> P.IO SearchSquareMembersResponse
read_SearchSquareMembersResponse iprot = to_SearchSquareMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquareMembersResponse)
decode_SearchSquareMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquareMembersResponse
decode_SearchSquareMembersResponse iprot bs = to_SearchSquareMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquareMembersResponse) bs
typemap_SearchSquareMembersResponse :: T.TypeMap
typemap_SearchSquareMembersResponse = Map.fromList [(1,("members",(T.T_LIST (T.T_STRUCT typemap_SquareMember)))),(2,("revision",T.T_I64)),(3,("continuationToken",T.T_STRING)),(4,("totalCount",T.T_I32))]
default_SearchSquareMembersResponse :: SearchSquareMembersResponse
default_SearchSquareMembersResponse = SearchSquareMembersResponse{
  searchSquareMembersResponse_members = Vector.empty,
  searchSquareMembersResponse_revision = 0,
  searchSquareMembersResponse_continuationToken = "",
  searchSquareMembersResponse_totalCount = 0}
data FindSquareByInvitationTicketRequest = FindSquareByInvitationTicketRequest  { findSquareByInvitationTicketRequest_invitationTicket :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSquareByInvitationTicketRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSquareByInvitationTicketRequest_invitationTicket record  
instance QC.Arbitrary FindSquareByInvitationTicketRequest where 
  arbitrary = M.liftM FindSquareByInvitationTicketRequest (QC.arbitrary)
  shrink obj | obj == default_FindSquareByInvitationTicketRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSquareByInvitationTicketRequest{findSquareByInvitationTicketRequest_invitationTicket = findSquareByInvitationTicketRequest_invitationTicket obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicketRequest{findSquareByInvitationTicketRequest_invitationTicket = findSquareByInvitationTicketRequest_invitationTicket obj}
    ]
from_FindSquareByInvitationTicketRequest :: FindSquareByInvitationTicketRequest -> T.ThriftVal
from_FindSquareByInvitationTicketRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2346 -> P.Just (2, ("invitationTicket",T.TString $ E.encodeUtf8 _v2346))) $ findSquareByInvitationTicketRequest_invitationTicket record
  ]
write_FindSquareByInvitationTicketRequest :: T.Protocol p => p -> FindSquareByInvitationTicketRequest -> P.IO ()
write_FindSquareByInvitationTicketRequest oprot record = T.writeVal oprot $ from_FindSquareByInvitationTicketRequest record
encode_FindSquareByInvitationTicketRequest :: T.StatelessProtocol p => p -> FindSquareByInvitationTicketRequest -> LBS.ByteString
encode_FindSquareByInvitationTicketRequest oprot record = T.serializeVal oprot $ from_FindSquareByInvitationTicketRequest record
to_FindSquareByInvitationTicketRequest :: T.ThriftVal -> FindSquareByInvitationTicketRequest
to_FindSquareByInvitationTicketRequest (T.TStruct fields) = FindSquareByInvitationTicketRequest{
  findSquareByInvitationTicketRequest_invitationTicket = P.maybe (findSquareByInvitationTicketRequest_invitationTicket default_FindSquareByInvitationTicketRequest) (\(_,_val2348) -> (case _val2348 of {T.TString _val2349 -> E.decodeUtf8 _val2349; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindSquareByInvitationTicketRequest _ = P.error "not a struct"
read_FindSquareByInvitationTicketRequest :: T.Protocol p => p -> P.IO FindSquareByInvitationTicketRequest
read_FindSquareByInvitationTicketRequest iprot = to_FindSquareByInvitationTicketRequest <$> T.readVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicketRequest)
decode_FindSquareByInvitationTicketRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSquareByInvitationTicketRequest
decode_FindSquareByInvitationTicketRequest iprot bs = to_FindSquareByInvitationTicketRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicketRequest) bs
typemap_FindSquareByInvitationTicketRequest :: T.TypeMap
typemap_FindSquareByInvitationTicketRequest = Map.fromList [(2,("invitationTicket",T.T_STRING))]
default_FindSquareByInvitationTicketRequest :: FindSquareByInvitationTicketRequest
default_FindSquareByInvitationTicketRequest = FindSquareByInvitationTicketRequest{
  findSquareByInvitationTicketRequest_invitationTicket = ""}
data FindSquareByInvitationTicketResponse = FindSquareByInvitationTicketResponse  { findSquareByInvitationTicketResponse_square :: Square
  , findSquareByInvitationTicketResponse_myMembership :: SquareMember
  , findSquareByInvitationTicketResponse_squareAuthority :: SquareAuthority
  , findSquareByInvitationTicketResponse_squareStatus :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSquareByInvitationTicketResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSquareByInvitationTicketResponse_square record   `H.hashWithSalt` findSquareByInvitationTicketResponse_myMembership record   `H.hashWithSalt` findSquareByInvitationTicketResponse_squareAuthority record   `H.hashWithSalt` findSquareByInvitationTicketResponse_squareStatus record  
instance QC.Arbitrary FindSquareByInvitationTicketResponse where 
  arbitrary = M.liftM FindSquareByInvitationTicketResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindSquareByInvitationTicketResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_square = findSquareByInvitationTicketResponse_square obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_square = findSquareByInvitationTicketResponse_square obj}
    , if obj == default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_myMembership = findSquareByInvitationTicketResponse_myMembership obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_myMembership = findSquareByInvitationTicketResponse_myMembership obj}
    , if obj == default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_squareAuthority = findSquareByInvitationTicketResponse_squareAuthority obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_squareAuthority = findSquareByInvitationTicketResponse_squareAuthority obj}
    , if obj == default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_squareStatus = findSquareByInvitationTicketResponse_squareStatus obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicketResponse{findSquareByInvitationTicketResponse_squareStatus = findSquareByInvitationTicketResponse_squareStatus obj}
    ]
from_FindSquareByInvitationTicketResponse :: FindSquareByInvitationTicketResponse -> T.ThriftVal
from_FindSquareByInvitationTicketResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2352 -> P.Just (1, ("square",from_Square _v2352))) $ findSquareByInvitationTicketResponse_square record
  , (\_v2352 -> P.Just (2, ("myMembership",from_SquareMember _v2352))) $ findSquareByInvitationTicketResponse_myMembership record
  , (\_v2352 -> P.Just (3, ("squareAuthority",from_SquareAuthority _v2352))) $ findSquareByInvitationTicketResponse_squareAuthority record
  , (\_v2352 -> P.Just (4, ("squareStatus",from_SquareStatus _v2352))) $ findSquareByInvitationTicketResponse_squareStatus record
  ]
write_FindSquareByInvitationTicketResponse :: T.Protocol p => p -> FindSquareByInvitationTicketResponse -> P.IO ()
write_FindSquareByInvitationTicketResponse oprot record = T.writeVal oprot $ from_FindSquareByInvitationTicketResponse record
encode_FindSquareByInvitationTicketResponse :: T.StatelessProtocol p => p -> FindSquareByInvitationTicketResponse -> LBS.ByteString
encode_FindSquareByInvitationTicketResponse oprot record = T.serializeVal oprot $ from_FindSquareByInvitationTicketResponse record
to_FindSquareByInvitationTicketResponse :: T.ThriftVal -> FindSquareByInvitationTicketResponse
to_FindSquareByInvitationTicketResponse (T.TStruct fields) = FindSquareByInvitationTicketResponse{
  findSquareByInvitationTicketResponse_square = P.maybe (findSquareByInvitationTicketResponse_square default_FindSquareByInvitationTicketResponse) (\(_,_val2354) -> (case _val2354 of {T.TStruct _val2355 -> (to_Square (T.TStruct _val2355)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findSquareByInvitationTicketResponse_myMembership = P.maybe (findSquareByInvitationTicketResponse_myMembership default_FindSquareByInvitationTicketResponse) (\(_,_val2354) -> (case _val2354 of {T.TStruct _val2356 -> (to_SquareMember (T.TStruct _val2356)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findSquareByInvitationTicketResponse_squareAuthority = P.maybe (findSquareByInvitationTicketResponse_squareAuthority default_FindSquareByInvitationTicketResponse) (\(_,_val2354) -> (case _val2354 of {T.TStruct _val2357 -> (to_SquareAuthority (T.TStruct _val2357)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  findSquareByInvitationTicketResponse_squareStatus = P.maybe (findSquareByInvitationTicketResponse_squareStatus default_FindSquareByInvitationTicketResponse) (\(_,_val2354) -> (case _val2354 of {T.TStruct _val2358 -> (to_SquareStatus (T.TStruct _val2358)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FindSquareByInvitationTicketResponse _ = P.error "not a struct"
read_FindSquareByInvitationTicketResponse :: T.Protocol p => p -> P.IO FindSquareByInvitationTicketResponse
read_FindSquareByInvitationTicketResponse iprot = to_FindSquareByInvitationTicketResponse <$> T.readVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicketResponse)
decode_FindSquareByInvitationTicketResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSquareByInvitationTicketResponse
decode_FindSquareByInvitationTicketResponse iprot bs = to_FindSquareByInvitationTicketResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicketResponse) bs
typemap_FindSquareByInvitationTicketResponse :: T.TypeMap
typemap_FindSquareByInvitationTicketResponse = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("myMembership",(T.T_STRUCT typemap_SquareMember))),(3,("squareAuthority",(T.T_STRUCT typemap_SquareAuthority))),(4,("squareStatus",(T.T_STRUCT typemap_SquareStatus)))]
default_FindSquareByInvitationTicketResponse :: FindSquareByInvitationTicketResponse
default_FindSquareByInvitationTicketResponse = FindSquareByInvitationTicketResponse{
  findSquareByInvitationTicketResponse_square = default_Square,
  findSquareByInvitationTicketResponse_myMembership = default_SquareMember,
  findSquareByInvitationTicketResponse_squareAuthority = default_SquareAuthority,
  findSquareByInvitationTicketResponse_squareStatus = default_SquareStatus}
data SquareEventReceiveMessage = SquareEventReceiveMessage  { squareEventReceiveMessage_squareChatMid :: LT.Text
  , squareEventReceiveMessage_squareMessage :: SquareMessage
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventReceiveMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventReceiveMessage_squareChatMid record   `H.hashWithSalt` squareEventReceiveMessage_squareMessage record  
instance QC.Arbitrary SquareEventReceiveMessage where 
  arbitrary = M.liftM SquareEventReceiveMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventReceiveMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventReceiveMessage{squareEventReceiveMessage_squareChatMid = squareEventReceiveMessage_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventReceiveMessage{squareEventReceiveMessage_squareChatMid = squareEventReceiveMessage_squareChatMid obj}
    , if obj == default_SquareEventReceiveMessage{squareEventReceiveMessage_squareMessage = squareEventReceiveMessage_squareMessage obj} then P.Nothing else P.Just $ default_SquareEventReceiveMessage{squareEventReceiveMessage_squareMessage = squareEventReceiveMessage_squareMessage obj}
    ]
from_SquareEventReceiveMessage :: SquareEventReceiveMessage -> T.ThriftVal
from_SquareEventReceiveMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2361 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2361))) $ squareEventReceiveMessage_squareChatMid record
  , (\_v2361 -> P.Just (2, ("squareMessage",from_SquareMessage _v2361))) $ squareEventReceiveMessage_squareMessage record
  ]
write_SquareEventReceiveMessage :: T.Protocol p => p -> SquareEventReceiveMessage -> P.IO ()
write_SquareEventReceiveMessage oprot record = T.writeVal oprot $ from_SquareEventReceiveMessage record
encode_SquareEventReceiveMessage :: T.StatelessProtocol p => p -> SquareEventReceiveMessage -> LBS.ByteString
encode_SquareEventReceiveMessage oprot record = T.serializeVal oprot $ from_SquareEventReceiveMessage record
to_SquareEventReceiveMessage :: T.ThriftVal -> SquareEventReceiveMessage
to_SquareEventReceiveMessage (T.TStruct fields) = SquareEventReceiveMessage{
  squareEventReceiveMessage_squareChatMid = P.maybe (squareEventReceiveMessage_squareChatMid default_SquareEventReceiveMessage) (\(_,_val2363) -> (case _val2363 of {T.TString _val2364 -> E.decodeUtf8 _val2364; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventReceiveMessage_squareMessage = P.maybe (squareEventReceiveMessage_squareMessage default_SquareEventReceiveMessage) (\(_,_val2363) -> (case _val2363 of {T.TStruct _val2365 -> (to_SquareMessage (T.TStruct _val2365)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventReceiveMessage _ = P.error "not a struct"
read_SquareEventReceiveMessage :: T.Protocol p => p -> P.IO SquareEventReceiveMessage
read_SquareEventReceiveMessage iprot = to_SquareEventReceiveMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventReceiveMessage)
decode_SquareEventReceiveMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventReceiveMessage
decode_SquareEventReceiveMessage iprot bs = to_SquareEventReceiveMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventReceiveMessage) bs
typemap_SquareEventReceiveMessage :: T.TypeMap
typemap_SquareEventReceiveMessage = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMessage",(T.T_STRUCT typemap_SquareMessage)))]
default_SquareEventReceiveMessage :: SquareEventReceiveMessage
default_SquareEventReceiveMessage = SquareEventReceiveMessage{
  squareEventReceiveMessage_squareChatMid = "",
  squareEventReceiveMessage_squareMessage = default_SquareMessage}
data SquareEventSendMessage = SquareEventSendMessage  { squareEventSendMessage_squareChatMid :: LT.Text
  , squareEventSendMessage_squareMessage :: SquareMessage
  , squareEventSendMessage_reqSeq :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventSendMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventSendMessage_squareChatMid record   `H.hashWithSalt` squareEventSendMessage_squareMessage record   `H.hashWithSalt` squareEventSendMessage_reqSeq record  
instance QC.Arbitrary SquareEventSendMessage where 
  arbitrary = M.liftM SquareEventSendMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventSendMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventSendMessage{squareEventSendMessage_squareChatMid = squareEventSendMessage_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventSendMessage{squareEventSendMessage_squareChatMid = squareEventSendMessage_squareChatMid obj}
    , if obj == default_SquareEventSendMessage{squareEventSendMessage_squareMessage = squareEventSendMessage_squareMessage obj} then P.Nothing else P.Just $ default_SquareEventSendMessage{squareEventSendMessage_squareMessage = squareEventSendMessage_squareMessage obj}
    , if obj == default_SquareEventSendMessage{squareEventSendMessage_reqSeq = squareEventSendMessage_reqSeq obj} then P.Nothing else P.Just $ default_SquareEventSendMessage{squareEventSendMessage_reqSeq = squareEventSendMessage_reqSeq obj}
    ]
from_SquareEventSendMessage :: SquareEventSendMessage -> T.ThriftVal
from_SquareEventSendMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2368 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2368))) $ squareEventSendMessage_squareChatMid record
  , (\_v2368 -> P.Just (2, ("squareMessage",from_SquareMessage _v2368))) $ squareEventSendMessage_squareMessage record
  , (\_v2368 -> P.Just (3, ("reqSeq",T.TI32 _v2368))) $ squareEventSendMessage_reqSeq record
  ]
write_SquareEventSendMessage :: T.Protocol p => p -> SquareEventSendMessage -> P.IO ()
write_SquareEventSendMessage oprot record = T.writeVal oprot $ from_SquareEventSendMessage record
encode_SquareEventSendMessage :: T.StatelessProtocol p => p -> SquareEventSendMessage -> LBS.ByteString
encode_SquareEventSendMessage oprot record = T.serializeVal oprot $ from_SquareEventSendMessage record
to_SquareEventSendMessage :: T.ThriftVal -> SquareEventSendMessage
to_SquareEventSendMessage (T.TStruct fields) = SquareEventSendMessage{
  squareEventSendMessage_squareChatMid = P.maybe (squareEventSendMessage_squareChatMid default_SquareEventSendMessage) (\(_,_val2370) -> (case _val2370 of {T.TString _val2371 -> E.decodeUtf8 _val2371; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventSendMessage_squareMessage = P.maybe (squareEventSendMessage_squareMessage default_SquareEventSendMessage) (\(_,_val2370) -> (case _val2370 of {T.TStruct _val2372 -> (to_SquareMessage (T.TStruct _val2372)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventSendMessage_reqSeq = P.maybe (squareEventSendMessage_reqSeq default_SquareEventSendMessage) (\(_,_val2370) -> (case _val2370 of {T.TI32 _val2373 -> _val2373; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventSendMessage _ = P.error "not a struct"
read_SquareEventSendMessage :: T.Protocol p => p -> P.IO SquareEventSendMessage
read_SquareEventSendMessage iprot = to_SquareEventSendMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventSendMessage)
decode_SquareEventSendMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventSendMessage
decode_SquareEventSendMessage iprot bs = to_SquareEventSendMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventSendMessage) bs
typemap_SquareEventSendMessage :: T.TypeMap
typemap_SquareEventSendMessage = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMessage",(T.T_STRUCT typemap_SquareMessage))),(3,("reqSeq",T.T_I32))]
default_SquareEventSendMessage :: SquareEventSendMessage
default_SquareEventSendMessage = SquareEventSendMessage{
  squareEventSendMessage_squareChatMid = "",
  squareEventSendMessage_squareMessage = default_SquareMessage,
  squareEventSendMessage_reqSeq = 0}
data SquareEventNotifiedJoinSquareChat = SquareEventNotifiedJoinSquareChat  { squareEventNotifiedJoinSquareChat_squareChatMid :: LT.Text
  , squareEventNotifiedJoinSquareChat_joinedMember :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedJoinSquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedJoinSquareChat_squareChatMid record   `H.hashWithSalt` squareEventNotifiedJoinSquareChat_joinedMember record  
instance QC.Arbitrary SquareEventNotifiedJoinSquareChat where 
  arbitrary = M.liftM SquareEventNotifiedJoinSquareChat (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedJoinSquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedJoinSquareChat{squareEventNotifiedJoinSquareChat_squareChatMid = squareEventNotifiedJoinSquareChat_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedJoinSquareChat{squareEventNotifiedJoinSquareChat_squareChatMid = squareEventNotifiedJoinSquareChat_squareChatMid obj}
    , if obj == default_SquareEventNotifiedJoinSquareChat{squareEventNotifiedJoinSquareChat_joinedMember = squareEventNotifiedJoinSquareChat_joinedMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedJoinSquareChat{squareEventNotifiedJoinSquareChat_joinedMember = squareEventNotifiedJoinSquareChat_joinedMember obj}
    ]
from_SquareEventNotifiedJoinSquareChat :: SquareEventNotifiedJoinSquareChat -> T.ThriftVal
from_SquareEventNotifiedJoinSquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2376 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2376))) $ squareEventNotifiedJoinSquareChat_squareChatMid record
  , (\_v2376 -> P.Just (2, ("joinedMember",from_SquareMember _v2376))) $ squareEventNotifiedJoinSquareChat_joinedMember record
  ]
write_SquareEventNotifiedJoinSquareChat :: T.Protocol p => p -> SquareEventNotifiedJoinSquareChat -> P.IO ()
write_SquareEventNotifiedJoinSquareChat oprot record = T.writeVal oprot $ from_SquareEventNotifiedJoinSquareChat record
encode_SquareEventNotifiedJoinSquareChat :: T.StatelessProtocol p => p -> SquareEventNotifiedJoinSquareChat -> LBS.ByteString
encode_SquareEventNotifiedJoinSquareChat oprot record = T.serializeVal oprot $ from_SquareEventNotifiedJoinSquareChat record
to_SquareEventNotifiedJoinSquareChat :: T.ThriftVal -> SquareEventNotifiedJoinSquareChat
to_SquareEventNotifiedJoinSquareChat (T.TStruct fields) = SquareEventNotifiedJoinSquareChat{
  squareEventNotifiedJoinSquareChat_squareChatMid = P.maybe (squareEventNotifiedJoinSquareChat_squareChatMid default_SquareEventNotifiedJoinSquareChat) (\(_,_val2378) -> (case _val2378 of {T.TString _val2379 -> E.decodeUtf8 _val2379; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedJoinSquareChat_joinedMember = P.maybe (squareEventNotifiedJoinSquareChat_joinedMember default_SquareEventNotifiedJoinSquareChat) (\(_,_val2378) -> (case _val2378 of {T.TStruct _val2380 -> (to_SquareMember (T.TStruct _val2380)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedJoinSquareChat _ = P.error "not a struct"
read_SquareEventNotifiedJoinSquareChat :: T.Protocol p => p -> P.IO SquareEventNotifiedJoinSquareChat
read_SquareEventNotifiedJoinSquareChat iprot = to_SquareEventNotifiedJoinSquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedJoinSquareChat)
decode_SquareEventNotifiedJoinSquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedJoinSquareChat
decode_SquareEventNotifiedJoinSquareChat iprot bs = to_SquareEventNotifiedJoinSquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedJoinSquareChat) bs
typemap_SquareEventNotifiedJoinSquareChat :: T.TypeMap
typemap_SquareEventNotifiedJoinSquareChat = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("joinedMember",(T.T_STRUCT typemap_SquareMember)))]
default_SquareEventNotifiedJoinSquareChat :: SquareEventNotifiedJoinSquareChat
default_SquareEventNotifiedJoinSquareChat = SquareEventNotifiedJoinSquareChat{
  squareEventNotifiedJoinSquareChat_squareChatMid = "",
  squareEventNotifiedJoinSquareChat_joinedMember = default_SquareMember}
data SquareEventNotifiedInviteIntoSquareChat = SquareEventNotifiedInviteIntoSquareChat  { squareEventNotifiedInviteIntoSquareChat_squareChatMid :: LT.Text
  , squareEventNotifiedInviteIntoSquareChat_invitees :: (Vector.Vector SquareMember)
  , squareEventNotifiedInviteIntoSquareChat_invitor :: SquareMember
  , squareEventNotifiedInviteIntoSquareChat_invitorRelation :: SquareMemberRelation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedInviteIntoSquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedInviteIntoSquareChat_squareChatMid record   `H.hashWithSalt` squareEventNotifiedInviteIntoSquareChat_invitees record   `H.hashWithSalt` squareEventNotifiedInviteIntoSquareChat_invitor record   `H.hashWithSalt` squareEventNotifiedInviteIntoSquareChat_invitorRelation record  
instance QC.Arbitrary SquareEventNotifiedInviteIntoSquareChat where 
  arbitrary = M.liftM SquareEventNotifiedInviteIntoSquareChat (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedInviteIntoSquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_squareChatMid = squareEventNotifiedInviteIntoSquareChat_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_squareChatMid = squareEventNotifiedInviteIntoSquareChat_squareChatMid obj}
    , if obj == default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitees = squareEventNotifiedInviteIntoSquareChat_invitees obj} then P.Nothing else P.Just $ default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitees = squareEventNotifiedInviteIntoSquareChat_invitees obj}
    , if obj == default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitor = squareEventNotifiedInviteIntoSquareChat_invitor obj} then P.Nothing else P.Just $ default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitor = squareEventNotifiedInviteIntoSquareChat_invitor obj}
    , if obj == default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitorRelation = squareEventNotifiedInviteIntoSquareChat_invitorRelation obj} then P.Nothing else P.Just $ default_SquareEventNotifiedInviteIntoSquareChat{squareEventNotifiedInviteIntoSquareChat_invitorRelation = squareEventNotifiedInviteIntoSquareChat_invitorRelation obj}
    ]
from_SquareEventNotifiedInviteIntoSquareChat :: SquareEventNotifiedInviteIntoSquareChat -> T.ThriftVal
from_SquareEventNotifiedInviteIntoSquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2383 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2383))) $ squareEventNotifiedInviteIntoSquareChat_squareChatMid record
  , (\_v2383 -> P.Just (2, ("invitees",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2385 -> from_SquareMember _v2385) $ Vector.toList _v2383))) $ squareEventNotifiedInviteIntoSquareChat_invitees record
  , (\_v2383 -> P.Just (3, ("invitor",from_SquareMember _v2383))) $ squareEventNotifiedInviteIntoSquareChat_invitor record
  , (\_v2383 -> P.Just (4, ("invitorRelation",from_SquareMemberRelation _v2383))) $ squareEventNotifiedInviteIntoSquareChat_invitorRelation record
  ]
write_SquareEventNotifiedInviteIntoSquareChat :: T.Protocol p => p -> SquareEventNotifiedInviteIntoSquareChat -> P.IO ()
write_SquareEventNotifiedInviteIntoSquareChat oprot record = T.writeVal oprot $ from_SquareEventNotifiedInviteIntoSquareChat record
encode_SquareEventNotifiedInviteIntoSquareChat :: T.StatelessProtocol p => p -> SquareEventNotifiedInviteIntoSquareChat -> LBS.ByteString
encode_SquareEventNotifiedInviteIntoSquareChat oprot record = T.serializeVal oprot $ from_SquareEventNotifiedInviteIntoSquareChat record
to_SquareEventNotifiedInviteIntoSquareChat :: T.ThriftVal -> SquareEventNotifiedInviteIntoSquareChat
to_SquareEventNotifiedInviteIntoSquareChat (T.TStruct fields) = SquareEventNotifiedInviteIntoSquareChat{
  squareEventNotifiedInviteIntoSquareChat_squareChatMid = P.maybe (squareEventNotifiedInviteIntoSquareChat_squareChatMid default_SquareEventNotifiedInviteIntoSquareChat) (\(_,_val2387) -> (case _val2387 of {T.TString _val2388 -> E.decodeUtf8 _val2388; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedInviteIntoSquareChat_invitees = P.maybe (squareEventNotifiedInviteIntoSquareChat_invitees default_SquareEventNotifiedInviteIntoSquareChat) (\(_,_val2387) -> (case _val2387 of {T.TList _ _val2389 -> (Vector.fromList $ P.map (\_v2390 -> (case _v2390 of {T.TStruct _val2391 -> (to_SquareMember (T.TStruct _val2391)); _ -> P.error "wrong type"})) _val2389); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedInviteIntoSquareChat_invitor = P.maybe (squareEventNotifiedInviteIntoSquareChat_invitor default_SquareEventNotifiedInviteIntoSquareChat) (\(_,_val2387) -> (case _val2387 of {T.TStruct _val2392 -> (to_SquareMember (T.TStruct _val2392)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotifiedInviteIntoSquareChat_invitorRelation = P.maybe (squareEventNotifiedInviteIntoSquareChat_invitorRelation default_SquareEventNotifiedInviteIntoSquareChat) (\(_,_val2387) -> (case _val2387 of {T.TStruct _val2393 -> (to_SquareMemberRelation (T.TStruct _val2393)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareEventNotifiedInviteIntoSquareChat _ = P.error "not a struct"
read_SquareEventNotifiedInviteIntoSquareChat :: T.Protocol p => p -> P.IO SquareEventNotifiedInviteIntoSquareChat
read_SquareEventNotifiedInviteIntoSquareChat iprot = to_SquareEventNotifiedInviteIntoSquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedInviteIntoSquareChat)
decode_SquareEventNotifiedInviteIntoSquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedInviteIntoSquareChat
decode_SquareEventNotifiedInviteIntoSquareChat iprot bs = to_SquareEventNotifiedInviteIntoSquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedInviteIntoSquareChat) bs
typemap_SquareEventNotifiedInviteIntoSquareChat :: T.TypeMap
typemap_SquareEventNotifiedInviteIntoSquareChat = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("invitees",(T.T_LIST (T.T_STRUCT typemap_SquareMember)))),(3,("invitor",(T.T_STRUCT typemap_SquareMember))),(4,("invitorRelation",(T.T_STRUCT typemap_SquareMemberRelation)))]
default_SquareEventNotifiedInviteIntoSquareChat :: SquareEventNotifiedInviteIntoSquareChat
default_SquareEventNotifiedInviteIntoSquareChat = SquareEventNotifiedInviteIntoSquareChat{
  squareEventNotifiedInviteIntoSquareChat_squareChatMid = "",
  squareEventNotifiedInviteIntoSquareChat_invitees = Vector.empty,
  squareEventNotifiedInviteIntoSquareChat_invitor = default_SquareMember,
  squareEventNotifiedInviteIntoSquareChat_invitorRelation = default_SquareMemberRelation}
data SquareEventNotifiedLeaveSquareChat = SquareEventNotifiedLeaveSquareChat  { squareEventNotifiedLeaveSquareChat_squareChatMid :: LT.Text
  , squareEventNotifiedLeaveSquareChat_squareMemberMid :: LT.Text
  , squareEventNotifiedLeaveSquareChat_sayGoodbye :: P.Bool
  , squareEventNotifiedLeaveSquareChat_squareMember :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedLeaveSquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedLeaveSquareChat_squareChatMid record   `H.hashWithSalt` squareEventNotifiedLeaveSquareChat_squareMemberMid record   `H.hashWithSalt` squareEventNotifiedLeaveSquareChat_sayGoodbye record   `H.hashWithSalt` squareEventNotifiedLeaveSquareChat_squareMember record  
instance QC.Arbitrary SquareEventNotifiedLeaveSquareChat where 
  arbitrary = M.liftM SquareEventNotifiedLeaveSquareChat (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedLeaveSquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareChatMid = squareEventNotifiedLeaveSquareChat_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareChatMid = squareEventNotifiedLeaveSquareChat_squareChatMid obj}
    , if obj == default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareMemberMid = squareEventNotifiedLeaveSquareChat_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareMemberMid = squareEventNotifiedLeaveSquareChat_squareMemberMid obj}
    , if obj == default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_sayGoodbye = squareEventNotifiedLeaveSquareChat_sayGoodbye obj} then P.Nothing else P.Just $ default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_sayGoodbye = squareEventNotifiedLeaveSquareChat_sayGoodbye obj}
    , if obj == default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareMember = squareEventNotifiedLeaveSquareChat_squareMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedLeaveSquareChat{squareEventNotifiedLeaveSquareChat_squareMember = squareEventNotifiedLeaveSquareChat_squareMember obj}
    ]
from_SquareEventNotifiedLeaveSquareChat :: SquareEventNotifiedLeaveSquareChat -> T.ThriftVal
from_SquareEventNotifiedLeaveSquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2396 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2396))) $ squareEventNotifiedLeaveSquareChat_squareChatMid record
  , (\_v2396 -> P.Just (2, ("squareMemberMid",T.TString $ E.encodeUtf8 _v2396))) $ squareEventNotifiedLeaveSquareChat_squareMemberMid record
  , (\_v2396 -> P.Just (3, ("sayGoodbye",T.TBool _v2396))) $ squareEventNotifiedLeaveSquareChat_sayGoodbye record
  , (\_v2396 -> P.Just (4, ("squareMember",from_SquareMember _v2396))) $ squareEventNotifiedLeaveSquareChat_squareMember record
  ]
write_SquareEventNotifiedLeaveSquareChat :: T.Protocol p => p -> SquareEventNotifiedLeaveSquareChat -> P.IO ()
write_SquareEventNotifiedLeaveSquareChat oprot record = T.writeVal oprot $ from_SquareEventNotifiedLeaveSquareChat record
encode_SquareEventNotifiedLeaveSquareChat :: T.StatelessProtocol p => p -> SquareEventNotifiedLeaveSquareChat -> LBS.ByteString
encode_SquareEventNotifiedLeaveSquareChat oprot record = T.serializeVal oprot $ from_SquareEventNotifiedLeaveSquareChat record
to_SquareEventNotifiedLeaveSquareChat :: T.ThriftVal -> SquareEventNotifiedLeaveSquareChat
to_SquareEventNotifiedLeaveSquareChat (T.TStruct fields) = SquareEventNotifiedLeaveSquareChat{
  squareEventNotifiedLeaveSquareChat_squareChatMid = P.maybe (squareEventNotifiedLeaveSquareChat_squareChatMid default_SquareEventNotifiedLeaveSquareChat) (\(_,_val2398) -> (case _val2398 of {T.TString _val2399 -> E.decodeUtf8 _val2399; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedLeaveSquareChat_squareMemberMid = P.maybe (squareEventNotifiedLeaveSquareChat_squareMemberMid default_SquareEventNotifiedLeaveSquareChat) (\(_,_val2398) -> (case _val2398 of {T.TString _val2400 -> E.decodeUtf8 _val2400; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedLeaveSquareChat_sayGoodbye = P.maybe (squareEventNotifiedLeaveSquareChat_sayGoodbye default_SquareEventNotifiedLeaveSquareChat) (\(_,_val2398) -> (case _val2398 of {T.TBool _val2401 -> _val2401; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotifiedLeaveSquareChat_squareMember = P.maybe (squareEventNotifiedLeaveSquareChat_squareMember default_SquareEventNotifiedLeaveSquareChat) (\(_,_val2398) -> (case _val2398 of {T.TStruct _val2402 -> (to_SquareMember (T.TStruct _val2402)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareEventNotifiedLeaveSquareChat _ = P.error "not a struct"
read_SquareEventNotifiedLeaveSquareChat :: T.Protocol p => p -> P.IO SquareEventNotifiedLeaveSquareChat
read_SquareEventNotifiedLeaveSquareChat iprot = to_SquareEventNotifiedLeaveSquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedLeaveSquareChat)
decode_SquareEventNotifiedLeaveSquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedLeaveSquareChat
decode_SquareEventNotifiedLeaveSquareChat iprot bs = to_SquareEventNotifiedLeaveSquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedLeaveSquareChat) bs
typemap_SquareEventNotifiedLeaveSquareChat :: T.TypeMap
typemap_SquareEventNotifiedLeaveSquareChat = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMemberMid",T.T_STRING)),(3,("sayGoodbye",T.T_BOOL)),(4,("squareMember",(T.T_STRUCT typemap_SquareMember)))]
default_SquareEventNotifiedLeaveSquareChat :: SquareEventNotifiedLeaveSquareChat
default_SquareEventNotifiedLeaveSquareChat = SquareEventNotifiedLeaveSquareChat{
  squareEventNotifiedLeaveSquareChat_squareChatMid = "",
  squareEventNotifiedLeaveSquareChat_squareMemberMid = "",
  squareEventNotifiedLeaveSquareChat_sayGoodbye = P.False,
  squareEventNotifiedLeaveSquareChat_squareMember = default_SquareMember}
data SquareEventNotifiedDestroyMessage = SquareEventNotifiedDestroyMessage  { squareEventNotifiedDestroyMessage_squareChatMid :: LT.Text
  , squareEventNotifiedDestroyMessage_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedDestroyMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedDestroyMessage_squareChatMid record   `H.hashWithSalt` squareEventNotifiedDestroyMessage_messageId record  
instance QC.Arbitrary SquareEventNotifiedDestroyMessage where 
  arbitrary = M.liftM SquareEventNotifiedDestroyMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedDestroyMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedDestroyMessage{squareEventNotifiedDestroyMessage_squareChatMid = squareEventNotifiedDestroyMessage_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedDestroyMessage{squareEventNotifiedDestroyMessage_squareChatMid = squareEventNotifiedDestroyMessage_squareChatMid obj}
    , if obj == default_SquareEventNotifiedDestroyMessage{squareEventNotifiedDestroyMessage_messageId = squareEventNotifiedDestroyMessage_messageId obj} then P.Nothing else P.Just $ default_SquareEventNotifiedDestroyMessage{squareEventNotifiedDestroyMessage_messageId = squareEventNotifiedDestroyMessage_messageId obj}
    ]
from_SquareEventNotifiedDestroyMessage :: SquareEventNotifiedDestroyMessage -> T.ThriftVal
from_SquareEventNotifiedDestroyMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2405 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2405))) $ squareEventNotifiedDestroyMessage_squareChatMid record
  , (\_v2405 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v2405))) $ squareEventNotifiedDestroyMessage_messageId record
  ]
write_SquareEventNotifiedDestroyMessage :: T.Protocol p => p -> SquareEventNotifiedDestroyMessage -> P.IO ()
write_SquareEventNotifiedDestroyMessage oprot record = T.writeVal oprot $ from_SquareEventNotifiedDestroyMessage record
encode_SquareEventNotifiedDestroyMessage :: T.StatelessProtocol p => p -> SquareEventNotifiedDestroyMessage -> LBS.ByteString
encode_SquareEventNotifiedDestroyMessage oprot record = T.serializeVal oprot $ from_SquareEventNotifiedDestroyMessage record
to_SquareEventNotifiedDestroyMessage :: T.ThriftVal -> SquareEventNotifiedDestroyMessage
to_SquareEventNotifiedDestroyMessage (T.TStruct fields) = SquareEventNotifiedDestroyMessage{
  squareEventNotifiedDestroyMessage_squareChatMid = P.maybe (squareEventNotifiedDestroyMessage_squareChatMid default_SquareEventNotifiedDestroyMessage) (\(_,_val2407) -> (case _val2407 of {T.TString _val2408 -> E.decodeUtf8 _val2408; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedDestroyMessage_messageId = P.maybe (squareEventNotifiedDestroyMessage_messageId default_SquareEventNotifiedDestroyMessage) (\(_,_val2407) -> (case _val2407 of {T.TString _val2409 -> E.decodeUtf8 _val2409; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedDestroyMessage _ = P.error "not a struct"
read_SquareEventNotifiedDestroyMessage :: T.Protocol p => p -> P.IO SquareEventNotifiedDestroyMessage
read_SquareEventNotifiedDestroyMessage iprot = to_SquareEventNotifiedDestroyMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedDestroyMessage)
decode_SquareEventNotifiedDestroyMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedDestroyMessage
decode_SquareEventNotifiedDestroyMessage iprot bs = to_SquareEventNotifiedDestroyMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedDestroyMessage) bs
typemap_SquareEventNotifiedDestroyMessage :: T.TypeMap
typemap_SquareEventNotifiedDestroyMessage = Map.fromList [(1,("squareChatMid",T.T_STRING)),(3,("messageId",T.T_STRING))]
default_SquareEventNotifiedDestroyMessage :: SquareEventNotifiedDestroyMessage
default_SquareEventNotifiedDestroyMessage = SquareEventNotifiedDestroyMessage{
  squareEventNotifiedDestroyMessage_squareChatMid = "",
  squareEventNotifiedDestroyMessage_messageId = ""}
data SquareEventNotifiedMarkAsRead = SquareEventNotifiedMarkAsRead  { squareEventNotifiedMarkAsRead_squareChatMid :: LT.Text
  , squareEventNotifiedMarkAsRead_sMemberMid :: LT.Text
  , squareEventNotifiedMarkAsRead_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedMarkAsRead where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedMarkAsRead_squareChatMid record   `H.hashWithSalt` squareEventNotifiedMarkAsRead_sMemberMid record   `H.hashWithSalt` squareEventNotifiedMarkAsRead_messageId record  
instance QC.Arbitrary SquareEventNotifiedMarkAsRead where 
  arbitrary = M.liftM SquareEventNotifiedMarkAsRead (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedMarkAsRead = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_squareChatMid = squareEventNotifiedMarkAsRead_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_squareChatMid = squareEventNotifiedMarkAsRead_squareChatMid obj}
    , if obj == default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_sMemberMid = squareEventNotifiedMarkAsRead_sMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_sMemberMid = squareEventNotifiedMarkAsRead_sMemberMid obj}
    , if obj == default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_messageId = squareEventNotifiedMarkAsRead_messageId obj} then P.Nothing else P.Just $ default_SquareEventNotifiedMarkAsRead{squareEventNotifiedMarkAsRead_messageId = squareEventNotifiedMarkAsRead_messageId obj}
    ]
from_SquareEventNotifiedMarkAsRead :: SquareEventNotifiedMarkAsRead -> T.ThriftVal
from_SquareEventNotifiedMarkAsRead record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2412 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2412))) $ squareEventNotifiedMarkAsRead_squareChatMid record
  , (\_v2412 -> P.Just (2, ("sMemberMid",T.TString $ E.encodeUtf8 _v2412))) $ squareEventNotifiedMarkAsRead_sMemberMid record
  , (\_v2412 -> P.Just (4, ("messageId",T.TString $ E.encodeUtf8 _v2412))) $ squareEventNotifiedMarkAsRead_messageId record
  ]
write_SquareEventNotifiedMarkAsRead :: T.Protocol p => p -> SquareEventNotifiedMarkAsRead -> P.IO ()
write_SquareEventNotifiedMarkAsRead oprot record = T.writeVal oprot $ from_SquareEventNotifiedMarkAsRead record
encode_SquareEventNotifiedMarkAsRead :: T.StatelessProtocol p => p -> SquareEventNotifiedMarkAsRead -> LBS.ByteString
encode_SquareEventNotifiedMarkAsRead oprot record = T.serializeVal oprot $ from_SquareEventNotifiedMarkAsRead record
to_SquareEventNotifiedMarkAsRead :: T.ThriftVal -> SquareEventNotifiedMarkAsRead
to_SquareEventNotifiedMarkAsRead (T.TStruct fields) = SquareEventNotifiedMarkAsRead{
  squareEventNotifiedMarkAsRead_squareChatMid = P.maybe (squareEventNotifiedMarkAsRead_squareChatMid default_SquareEventNotifiedMarkAsRead) (\(_,_val2414) -> (case _val2414 of {T.TString _val2415 -> E.decodeUtf8 _val2415; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedMarkAsRead_sMemberMid = P.maybe (squareEventNotifiedMarkAsRead_sMemberMid default_SquareEventNotifiedMarkAsRead) (\(_,_val2414) -> (case _val2414 of {T.TString _val2416 -> E.decodeUtf8 _val2416; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedMarkAsRead_messageId = P.maybe (squareEventNotifiedMarkAsRead_messageId default_SquareEventNotifiedMarkAsRead) (\(_,_val2414) -> (case _val2414 of {T.TString _val2417 -> E.decodeUtf8 _val2417; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareEventNotifiedMarkAsRead _ = P.error "not a struct"
read_SquareEventNotifiedMarkAsRead :: T.Protocol p => p -> P.IO SquareEventNotifiedMarkAsRead
read_SquareEventNotifiedMarkAsRead iprot = to_SquareEventNotifiedMarkAsRead <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedMarkAsRead)
decode_SquareEventNotifiedMarkAsRead :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedMarkAsRead
decode_SquareEventNotifiedMarkAsRead iprot bs = to_SquareEventNotifiedMarkAsRead $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedMarkAsRead) bs
typemap_SquareEventNotifiedMarkAsRead :: T.TypeMap
typemap_SquareEventNotifiedMarkAsRead = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("sMemberMid",T.T_STRING)),(4,("messageId",T.T_STRING))]
default_SquareEventNotifiedMarkAsRead :: SquareEventNotifiedMarkAsRead
default_SquareEventNotifiedMarkAsRead = SquareEventNotifiedMarkAsRead{
  squareEventNotifiedMarkAsRead_squareChatMid = "",
  squareEventNotifiedMarkAsRead_sMemberMid = "",
  squareEventNotifiedMarkAsRead_messageId = ""}
data SquareEventNotifiedUpdateSquareMemberProfile = SquareEventNotifiedUpdateSquareMemberProfile  { squareEventNotifiedUpdateSquareMemberProfile_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareMemberProfile_squareMember :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareMemberProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberProfile_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberProfile_squareMember record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareMemberProfile where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareMemberProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareMemberProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareMemberProfile{squareEventNotifiedUpdateSquareMemberProfile_squareChatMid = squareEventNotifiedUpdateSquareMemberProfile_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberProfile{squareEventNotifiedUpdateSquareMemberProfile_squareChatMid = squareEventNotifiedUpdateSquareMemberProfile_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMemberProfile{squareEventNotifiedUpdateSquareMemberProfile_squareMember = squareEventNotifiedUpdateSquareMemberProfile_squareMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberProfile{squareEventNotifiedUpdateSquareMemberProfile_squareMember = squareEventNotifiedUpdateSquareMemberProfile_squareMember obj}
    ]
from_SquareEventNotifiedUpdateSquareMemberProfile :: SquareEventNotifiedUpdateSquareMemberProfile -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareMemberProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2420 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2420))) $ squareEventNotifiedUpdateSquareMemberProfile_squareChatMid record
  , (\_v2420 -> P.Just (2, ("squareMember",from_SquareMember _v2420))) $ squareEventNotifiedUpdateSquareMemberProfile_squareMember record
  ]
write_SquareEventNotifiedUpdateSquareMemberProfile :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareMemberProfile -> P.IO ()
write_SquareEventNotifiedUpdateSquareMemberProfile oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareMemberProfile record
encode_SquareEventNotifiedUpdateSquareMemberProfile :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareMemberProfile -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareMemberProfile oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareMemberProfile record
to_SquareEventNotifiedUpdateSquareMemberProfile :: T.ThriftVal -> SquareEventNotifiedUpdateSquareMemberProfile
to_SquareEventNotifiedUpdateSquareMemberProfile (T.TStruct fields) = SquareEventNotifiedUpdateSquareMemberProfile{
  squareEventNotifiedUpdateSquareMemberProfile_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareMemberProfile_squareChatMid default_SquareEventNotifiedUpdateSquareMemberProfile) (\(_,_val2422) -> (case _val2422 of {T.TString _val2423 -> E.decodeUtf8 _val2423; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareMemberProfile_squareMember = P.maybe (squareEventNotifiedUpdateSquareMemberProfile_squareMember default_SquareEventNotifiedUpdateSquareMemberProfile) (\(_,_val2422) -> (case _val2422 of {T.TStruct _val2424 -> (to_SquareMember (T.TStruct _val2424)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquareMemberProfile _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareMemberProfile :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareMemberProfile
read_SquareEventNotifiedUpdateSquareMemberProfile iprot = to_SquareEventNotifiedUpdateSquareMemberProfile <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberProfile)
decode_SquareEventNotifiedUpdateSquareMemberProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareMemberProfile
decode_SquareEventNotifiedUpdateSquareMemberProfile iprot bs = to_SquareEventNotifiedUpdateSquareMemberProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberProfile) bs
typemap_SquareEventNotifiedUpdateSquareMemberProfile :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareMemberProfile = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMember",(T.T_STRUCT typemap_SquareMember)))]
default_SquareEventNotifiedUpdateSquareMemberProfile :: SquareEventNotifiedUpdateSquareMemberProfile
default_SquareEventNotifiedUpdateSquareMemberProfile = SquareEventNotifiedUpdateSquareMemberProfile{
  squareEventNotifiedUpdateSquareMemberProfile_squareChatMid = "",
  squareEventNotifiedUpdateSquareMemberProfile_squareMember = default_SquareMember}
data SquareEventNotifiedKickoutFromSquare = SquareEventNotifiedKickoutFromSquare  { squareEventNotifiedKickoutFromSquare_squareChatMid :: LT.Text
  , squareEventNotifiedKickoutFromSquare_kickees :: (Vector.Vector SquareMember)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedKickoutFromSquare where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedKickoutFromSquare_squareChatMid record   `H.hashWithSalt` squareEventNotifiedKickoutFromSquare_kickees record  
instance QC.Arbitrary SquareEventNotifiedKickoutFromSquare where 
  arbitrary = M.liftM SquareEventNotifiedKickoutFromSquare (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedKickoutFromSquare = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedKickoutFromSquare{squareEventNotifiedKickoutFromSquare_squareChatMid = squareEventNotifiedKickoutFromSquare_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedKickoutFromSquare{squareEventNotifiedKickoutFromSquare_squareChatMid = squareEventNotifiedKickoutFromSquare_squareChatMid obj}
    , if obj == default_SquareEventNotifiedKickoutFromSquare{squareEventNotifiedKickoutFromSquare_kickees = squareEventNotifiedKickoutFromSquare_kickees obj} then P.Nothing else P.Just $ default_SquareEventNotifiedKickoutFromSquare{squareEventNotifiedKickoutFromSquare_kickees = squareEventNotifiedKickoutFromSquare_kickees obj}
    ]
from_SquareEventNotifiedKickoutFromSquare :: SquareEventNotifiedKickoutFromSquare -> T.ThriftVal
from_SquareEventNotifiedKickoutFromSquare record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2427 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2427))) $ squareEventNotifiedKickoutFromSquare_squareChatMid record
  , (\_v2427 -> P.Just (2, ("kickees",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2429 -> from_SquareMember _v2429) $ Vector.toList _v2427))) $ squareEventNotifiedKickoutFromSquare_kickees record
  ]
write_SquareEventNotifiedKickoutFromSquare :: T.Protocol p => p -> SquareEventNotifiedKickoutFromSquare -> P.IO ()
write_SquareEventNotifiedKickoutFromSquare oprot record = T.writeVal oprot $ from_SquareEventNotifiedKickoutFromSquare record
encode_SquareEventNotifiedKickoutFromSquare :: T.StatelessProtocol p => p -> SquareEventNotifiedKickoutFromSquare -> LBS.ByteString
encode_SquareEventNotifiedKickoutFromSquare oprot record = T.serializeVal oprot $ from_SquareEventNotifiedKickoutFromSquare record
to_SquareEventNotifiedKickoutFromSquare :: T.ThriftVal -> SquareEventNotifiedKickoutFromSquare
to_SquareEventNotifiedKickoutFromSquare (T.TStruct fields) = SquareEventNotifiedKickoutFromSquare{
  squareEventNotifiedKickoutFromSquare_squareChatMid = P.maybe (squareEventNotifiedKickoutFromSquare_squareChatMid default_SquareEventNotifiedKickoutFromSquare) (\(_,_val2431) -> (case _val2431 of {T.TString _val2432 -> E.decodeUtf8 _val2432; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedKickoutFromSquare_kickees = P.maybe (squareEventNotifiedKickoutFromSquare_kickees default_SquareEventNotifiedKickoutFromSquare) (\(_,_val2431) -> (case _val2431 of {T.TList _ _val2433 -> (Vector.fromList $ P.map (\_v2434 -> (case _v2434 of {T.TStruct _val2435 -> (to_SquareMember (T.TStruct _val2435)); _ -> P.error "wrong type"})) _val2433); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedKickoutFromSquare _ = P.error "not a struct"
read_SquareEventNotifiedKickoutFromSquare :: T.Protocol p => p -> P.IO SquareEventNotifiedKickoutFromSquare
read_SquareEventNotifiedKickoutFromSquare iprot = to_SquareEventNotifiedKickoutFromSquare <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedKickoutFromSquare)
decode_SquareEventNotifiedKickoutFromSquare :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedKickoutFromSquare
decode_SquareEventNotifiedKickoutFromSquare iprot bs = to_SquareEventNotifiedKickoutFromSquare $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedKickoutFromSquare) bs
typemap_SquareEventNotifiedKickoutFromSquare :: T.TypeMap
typemap_SquareEventNotifiedKickoutFromSquare = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("kickees",(T.T_LIST (T.T_STRUCT typemap_SquareMember))))]
default_SquareEventNotifiedKickoutFromSquare :: SquareEventNotifiedKickoutFromSquare
default_SquareEventNotifiedKickoutFromSquare = SquareEventNotifiedKickoutFromSquare{
  squareEventNotifiedKickoutFromSquare_squareChatMid = "",
  squareEventNotifiedKickoutFromSquare_kickees = Vector.empty}
data SquareEventNotifiedShutdownSquare = SquareEventNotifiedShutdownSquare  { squareEventNotifiedShutdownSquare_squareChatMid :: LT.Text
  , squareEventNotifiedShutdownSquare_square :: Square
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedShutdownSquare where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedShutdownSquare_squareChatMid record   `H.hashWithSalt` squareEventNotifiedShutdownSquare_square record  
instance QC.Arbitrary SquareEventNotifiedShutdownSquare where 
  arbitrary = M.liftM SquareEventNotifiedShutdownSquare (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedShutdownSquare = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedShutdownSquare{squareEventNotifiedShutdownSquare_squareChatMid = squareEventNotifiedShutdownSquare_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedShutdownSquare{squareEventNotifiedShutdownSquare_squareChatMid = squareEventNotifiedShutdownSquare_squareChatMid obj}
    , if obj == default_SquareEventNotifiedShutdownSquare{squareEventNotifiedShutdownSquare_square = squareEventNotifiedShutdownSquare_square obj} then P.Nothing else P.Just $ default_SquareEventNotifiedShutdownSquare{squareEventNotifiedShutdownSquare_square = squareEventNotifiedShutdownSquare_square obj}
    ]
from_SquareEventNotifiedShutdownSquare :: SquareEventNotifiedShutdownSquare -> T.ThriftVal
from_SquareEventNotifiedShutdownSquare record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2438 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2438))) $ squareEventNotifiedShutdownSquare_squareChatMid record
  , (\_v2438 -> P.Just (2, ("square",from_Square _v2438))) $ squareEventNotifiedShutdownSquare_square record
  ]
write_SquareEventNotifiedShutdownSquare :: T.Protocol p => p -> SquareEventNotifiedShutdownSquare -> P.IO ()
write_SquareEventNotifiedShutdownSquare oprot record = T.writeVal oprot $ from_SquareEventNotifiedShutdownSquare record
encode_SquareEventNotifiedShutdownSquare :: T.StatelessProtocol p => p -> SquareEventNotifiedShutdownSquare -> LBS.ByteString
encode_SquareEventNotifiedShutdownSquare oprot record = T.serializeVal oprot $ from_SquareEventNotifiedShutdownSquare record
to_SquareEventNotifiedShutdownSquare :: T.ThriftVal -> SquareEventNotifiedShutdownSquare
to_SquareEventNotifiedShutdownSquare (T.TStruct fields) = SquareEventNotifiedShutdownSquare{
  squareEventNotifiedShutdownSquare_squareChatMid = P.maybe (squareEventNotifiedShutdownSquare_squareChatMid default_SquareEventNotifiedShutdownSquare) (\(_,_val2440) -> (case _val2440 of {T.TString _val2441 -> E.decodeUtf8 _val2441; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedShutdownSquare_square = P.maybe (squareEventNotifiedShutdownSquare_square default_SquareEventNotifiedShutdownSquare) (\(_,_val2440) -> (case _val2440 of {T.TStruct _val2442 -> (to_Square (T.TStruct _val2442)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedShutdownSquare _ = P.error "not a struct"
read_SquareEventNotifiedShutdownSquare :: T.Protocol p => p -> P.IO SquareEventNotifiedShutdownSquare
read_SquareEventNotifiedShutdownSquare iprot = to_SquareEventNotifiedShutdownSquare <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedShutdownSquare)
decode_SquareEventNotifiedShutdownSquare :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedShutdownSquare
decode_SquareEventNotifiedShutdownSquare iprot bs = to_SquareEventNotifiedShutdownSquare $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedShutdownSquare) bs
typemap_SquareEventNotifiedShutdownSquare :: T.TypeMap
typemap_SquareEventNotifiedShutdownSquare = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("square",(T.T_STRUCT typemap_Square)))]
default_SquareEventNotifiedShutdownSquare :: SquareEventNotifiedShutdownSquare
default_SquareEventNotifiedShutdownSquare = SquareEventNotifiedShutdownSquare{
  squareEventNotifiedShutdownSquare_squareChatMid = "",
  squareEventNotifiedShutdownSquare_square = default_Square}
data SquareEventNotifiedDeleteSquareChat = SquareEventNotifiedDeleteSquareChat  { squareEventNotifiedDeleteSquareChat_squareChat :: SquareChat
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedDeleteSquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedDeleteSquareChat_squareChat record  
instance QC.Arbitrary SquareEventNotifiedDeleteSquareChat where 
  arbitrary = M.liftM SquareEventNotifiedDeleteSquareChat (QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedDeleteSquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedDeleteSquareChat{squareEventNotifiedDeleteSquareChat_squareChat = squareEventNotifiedDeleteSquareChat_squareChat obj} then P.Nothing else P.Just $ default_SquareEventNotifiedDeleteSquareChat{squareEventNotifiedDeleteSquareChat_squareChat = squareEventNotifiedDeleteSquareChat_squareChat obj}
    ]
from_SquareEventNotifiedDeleteSquareChat :: SquareEventNotifiedDeleteSquareChat -> T.ThriftVal
from_SquareEventNotifiedDeleteSquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2445 -> P.Just (1, ("squareChat",from_SquareChat _v2445))) $ squareEventNotifiedDeleteSquareChat_squareChat record
  ]
write_SquareEventNotifiedDeleteSquareChat :: T.Protocol p => p -> SquareEventNotifiedDeleteSquareChat -> P.IO ()
write_SquareEventNotifiedDeleteSquareChat oprot record = T.writeVal oprot $ from_SquareEventNotifiedDeleteSquareChat record
encode_SquareEventNotifiedDeleteSquareChat :: T.StatelessProtocol p => p -> SquareEventNotifiedDeleteSquareChat -> LBS.ByteString
encode_SquareEventNotifiedDeleteSquareChat oprot record = T.serializeVal oprot $ from_SquareEventNotifiedDeleteSquareChat record
to_SquareEventNotifiedDeleteSquareChat :: T.ThriftVal -> SquareEventNotifiedDeleteSquareChat
to_SquareEventNotifiedDeleteSquareChat (T.TStruct fields) = SquareEventNotifiedDeleteSquareChat{
  squareEventNotifiedDeleteSquareChat_squareChat = P.maybe (squareEventNotifiedDeleteSquareChat_squareChat default_SquareEventNotifiedDeleteSquareChat) (\(_,_val2447) -> (case _val2447 of {T.TStruct _val2448 -> (to_SquareChat (T.TStruct _val2448)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SquareEventNotifiedDeleteSquareChat _ = P.error "not a struct"
read_SquareEventNotifiedDeleteSquareChat :: T.Protocol p => p -> P.IO SquareEventNotifiedDeleteSquareChat
read_SquareEventNotifiedDeleteSquareChat iprot = to_SquareEventNotifiedDeleteSquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedDeleteSquareChat)
decode_SquareEventNotifiedDeleteSquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedDeleteSquareChat
decode_SquareEventNotifiedDeleteSquareChat iprot bs = to_SquareEventNotifiedDeleteSquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedDeleteSquareChat) bs
typemap_SquareEventNotifiedDeleteSquareChat :: T.TypeMap
typemap_SquareEventNotifiedDeleteSquareChat = Map.fromList [(1,("squareChat",(T.T_STRUCT typemap_SquareChat)))]
default_SquareEventNotifiedDeleteSquareChat :: SquareEventNotifiedDeleteSquareChat
default_SquareEventNotifiedDeleteSquareChat = SquareEventNotifiedDeleteSquareChat{
  squareEventNotifiedDeleteSquareChat_squareChat = default_SquareChat}
data SquareEventNotifiedUpdateSquareChatProfileName = SquareEventNotifiedUpdateSquareChatProfileName  { squareEventNotifiedUpdateSquareChatProfileName_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareChatProfileName_editor :: SquareMember
  , squareEventNotifiedUpdateSquareChatProfileName_updatedChatName :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareChatProfileName where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatProfileName_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatProfileName_editor record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatProfileName_updatedChatName record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareChatProfileName where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareChatProfileName (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareChatProfileName = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_squareChatMid = squareEventNotifiedUpdateSquareChatProfileName_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_squareChatMid = squareEventNotifiedUpdateSquareChatProfileName_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_editor = squareEventNotifiedUpdateSquareChatProfileName_editor obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_editor = squareEventNotifiedUpdateSquareChatProfileName_editor obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_updatedChatName = squareEventNotifiedUpdateSquareChatProfileName_updatedChatName obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatProfileName{squareEventNotifiedUpdateSquareChatProfileName_updatedChatName = squareEventNotifiedUpdateSquareChatProfileName_updatedChatName obj}
    ]
from_SquareEventNotifiedUpdateSquareChatProfileName :: SquareEventNotifiedUpdateSquareChatProfileName -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareChatProfileName record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2451 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2451))) $ squareEventNotifiedUpdateSquareChatProfileName_squareChatMid record
  , (\_v2451 -> P.Just (2, ("editor",from_SquareMember _v2451))) $ squareEventNotifiedUpdateSquareChatProfileName_editor record
  , (\_v2451 -> P.Just (3, ("updatedChatName",T.TString $ E.encodeUtf8 _v2451))) $ squareEventNotifiedUpdateSquareChatProfileName_updatedChatName record
  ]
write_SquareEventNotifiedUpdateSquareChatProfileName :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareChatProfileName -> P.IO ()
write_SquareEventNotifiedUpdateSquareChatProfileName oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareChatProfileName record
encode_SquareEventNotifiedUpdateSquareChatProfileName :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareChatProfileName -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareChatProfileName oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareChatProfileName record
to_SquareEventNotifiedUpdateSquareChatProfileName :: T.ThriftVal -> SquareEventNotifiedUpdateSquareChatProfileName
to_SquareEventNotifiedUpdateSquareChatProfileName (T.TStruct fields) = SquareEventNotifiedUpdateSquareChatProfileName{
  squareEventNotifiedUpdateSquareChatProfileName_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareChatProfileName_squareChatMid default_SquareEventNotifiedUpdateSquareChatProfileName) (\(_,_val2453) -> (case _val2453 of {T.TString _val2454 -> E.decodeUtf8 _val2454; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareChatProfileName_editor = P.maybe (squareEventNotifiedUpdateSquareChatProfileName_editor default_SquareEventNotifiedUpdateSquareChatProfileName) (\(_,_val2453) -> (case _val2453 of {T.TStruct _val2455 -> (to_SquareMember (T.TStruct _val2455)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedUpdateSquareChatProfileName_updatedChatName = P.maybe (squareEventNotifiedUpdateSquareChatProfileName_updatedChatName default_SquareEventNotifiedUpdateSquareChatProfileName) (\(_,_val2453) -> (case _val2453 of {T.TString _val2456 -> E.decodeUtf8 _val2456; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedUpdateSquareChatProfileName _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareChatProfileName :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareChatProfileName
read_SquareEventNotifiedUpdateSquareChatProfileName iprot = to_SquareEventNotifiedUpdateSquareChatProfileName <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileName)
decode_SquareEventNotifiedUpdateSquareChatProfileName :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareChatProfileName
decode_SquareEventNotifiedUpdateSquareChatProfileName iprot bs = to_SquareEventNotifiedUpdateSquareChatProfileName $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileName) bs
typemap_SquareEventNotifiedUpdateSquareChatProfileName :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareChatProfileName = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("editor",(T.T_STRUCT typemap_SquareMember))),(3,("updatedChatName",T.T_STRING))]
default_SquareEventNotifiedUpdateSquareChatProfileName :: SquareEventNotifiedUpdateSquareChatProfileName
default_SquareEventNotifiedUpdateSquareChatProfileName = SquareEventNotifiedUpdateSquareChatProfileName{
  squareEventNotifiedUpdateSquareChatProfileName_squareChatMid = "",
  squareEventNotifiedUpdateSquareChatProfileName_editor = default_SquareMember,
  squareEventNotifiedUpdateSquareChatProfileName_updatedChatName = ""}
data SquareEventNotifiedUpdateSquareChatProfileImage = SquareEventNotifiedUpdateSquareChatProfileImage  { squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareChatProfileImage_editor :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareChatProfileImage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatProfileImage_editor record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareChatProfileImage where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareChatProfileImage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareChatProfileImage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareChatProfileImage{squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid = squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatProfileImage{squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid = squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatProfileImage{squareEventNotifiedUpdateSquareChatProfileImage_editor = squareEventNotifiedUpdateSquareChatProfileImage_editor obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatProfileImage{squareEventNotifiedUpdateSquareChatProfileImage_editor = squareEventNotifiedUpdateSquareChatProfileImage_editor obj}
    ]
from_SquareEventNotifiedUpdateSquareChatProfileImage :: SquareEventNotifiedUpdateSquareChatProfileImage -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareChatProfileImage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2459 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2459))) $ squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid record
  , (\_v2459 -> P.Just (2, ("editor",from_SquareMember _v2459))) $ squareEventNotifiedUpdateSquareChatProfileImage_editor record
  ]
write_SquareEventNotifiedUpdateSquareChatProfileImage :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareChatProfileImage -> P.IO ()
write_SquareEventNotifiedUpdateSquareChatProfileImage oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareChatProfileImage record
encode_SquareEventNotifiedUpdateSquareChatProfileImage :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareChatProfileImage -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareChatProfileImage oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareChatProfileImage record
to_SquareEventNotifiedUpdateSquareChatProfileImage :: T.ThriftVal -> SquareEventNotifiedUpdateSquareChatProfileImage
to_SquareEventNotifiedUpdateSquareChatProfileImage (T.TStruct fields) = SquareEventNotifiedUpdateSquareChatProfileImage{
  squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid default_SquareEventNotifiedUpdateSquareChatProfileImage) (\(_,_val2461) -> (case _val2461 of {T.TString _val2462 -> E.decodeUtf8 _val2462; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareChatProfileImage_editor = P.maybe (squareEventNotifiedUpdateSquareChatProfileImage_editor default_SquareEventNotifiedUpdateSquareChatProfileImage) (\(_,_val2461) -> (case _val2461 of {T.TStruct _val2463 -> (to_SquareMember (T.TStruct _val2463)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquareChatProfileImage _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareChatProfileImage :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareChatProfileImage
read_SquareEventNotifiedUpdateSquareChatProfileImage iprot = to_SquareEventNotifiedUpdateSquareChatProfileImage <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileImage)
decode_SquareEventNotifiedUpdateSquareChatProfileImage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareChatProfileImage
decode_SquareEventNotifiedUpdateSquareChatProfileImage iprot bs = to_SquareEventNotifiedUpdateSquareChatProfileImage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileImage) bs
typemap_SquareEventNotifiedUpdateSquareChatProfileImage :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareChatProfileImage = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("editor",(T.T_STRUCT typemap_SquareMember)))]
default_SquareEventNotifiedUpdateSquareChatProfileImage :: SquareEventNotifiedUpdateSquareChatProfileImage
default_SquareEventNotifiedUpdateSquareChatProfileImage = SquareEventNotifiedUpdateSquareChatProfileImage{
  squareEventNotifiedUpdateSquareChatProfileImage_squareChatMid = "",
  squareEventNotifiedUpdateSquareChatProfileImage_editor = default_SquareMember}
data SquareEventNotifiedUpdateSquareChatStatus = SquareEventNotifiedUpdateSquareChatStatus  { squareEventNotifiedUpdateSquareChatStatus_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage :: SquareChatStatusWithoutMessage
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareChatStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatStatus_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareChatStatus where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareChatStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareChatStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareChatStatus{squareEventNotifiedUpdateSquareChatStatus_squareChatMid = squareEventNotifiedUpdateSquareChatStatus_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatStatus{squareEventNotifiedUpdateSquareChatStatus_squareChatMid = squareEventNotifiedUpdateSquareChatStatus_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatStatus{squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage = squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatStatus{squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage = squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage obj}
    ]
from_SquareEventNotifiedUpdateSquareChatStatus :: SquareEventNotifiedUpdateSquareChatStatus -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareChatStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2466 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2466))) $ squareEventNotifiedUpdateSquareChatStatus_squareChatMid record
  , (\_v2466 -> P.Just (2, ("statusWithoutMessage",from_SquareChatStatusWithoutMessage _v2466))) $ squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage record
  ]
write_SquareEventNotifiedUpdateSquareChatStatus :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareChatStatus -> P.IO ()
write_SquareEventNotifiedUpdateSquareChatStatus oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareChatStatus record
encode_SquareEventNotifiedUpdateSquareChatStatus :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareChatStatus -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareChatStatus oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareChatStatus record
to_SquareEventNotifiedUpdateSquareChatStatus :: T.ThriftVal -> SquareEventNotifiedUpdateSquareChatStatus
to_SquareEventNotifiedUpdateSquareChatStatus (T.TStruct fields) = SquareEventNotifiedUpdateSquareChatStatus{
  squareEventNotifiedUpdateSquareChatStatus_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareChatStatus_squareChatMid default_SquareEventNotifiedUpdateSquareChatStatus) (\(_,_val2468) -> (case _val2468 of {T.TString _val2469 -> E.decodeUtf8 _val2469; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage = P.maybe (squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage default_SquareEventNotifiedUpdateSquareChatStatus) (\(_,_val2468) -> (case _val2468 of {T.TStruct _val2470 -> (to_SquareChatStatusWithoutMessage (T.TStruct _val2470)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquareChatStatus _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareChatStatus :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareChatStatus
read_SquareEventNotifiedUpdateSquareChatStatus iprot = to_SquareEventNotifiedUpdateSquareChatStatus <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatStatus)
decode_SquareEventNotifiedUpdateSquareChatStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareChatStatus
decode_SquareEventNotifiedUpdateSquareChatStatus iprot bs = to_SquareEventNotifiedUpdateSquareChatStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatStatus) bs
typemap_SquareEventNotifiedUpdateSquareChatStatus :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareChatStatus = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("statusWithoutMessage",(T.T_STRUCT typemap_SquareChatStatusWithoutMessage)))]
default_SquareEventNotifiedUpdateSquareChatStatus :: SquareEventNotifiedUpdateSquareChatStatus
default_SquareEventNotifiedUpdateSquareChatStatus = SquareEventNotifiedUpdateSquareChatStatus{
  squareEventNotifiedUpdateSquareChatStatus_squareChatMid = "",
  squareEventNotifiedUpdateSquareChatStatus_statusWithoutMessage = default_SquareChatStatusWithoutMessage}
data SquareEventNotifiedUpdateSquareStatus = SquareEventNotifiedUpdateSquareStatus  { squareEventNotifiedUpdateSquareStatus_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquareStatus_squareStatus :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareStatus_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareStatus_squareStatus record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareStatus where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareStatus{squareEventNotifiedUpdateSquareStatus_squareMid = squareEventNotifiedUpdateSquareStatus_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareStatus{squareEventNotifiedUpdateSquareStatus_squareMid = squareEventNotifiedUpdateSquareStatus_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareStatus{squareEventNotifiedUpdateSquareStatus_squareStatus = squareEventNotifiedUpdateSquareStatus_squareStatus obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareStatus{squareEventNotifiedUpdateSquareStatus_squareStatus = squareEventNotifiedUpdateSquareStatus_squareStatus obj}
    ]
from_SquareEventNotifiedUpdateSquareStatus :: SquareEventNotifiedUpdateSquareStatus -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2473 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2473))) $ squareEventNotifiedUpdateSquareStatus_squareMid record
  , (\_v2473 -> P.Just (2, ("squareStatus",from_SquareStatus _v2473))) $ squareEventNotifiedUpdateSquareStatus_squareStatus record
  ]
write_SquareEventNotifiedUpdateSquareStatus :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareStatus -> P.IO ()
write_SquareEventNotifiedUpdateSquareStatus oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareStatus record
encode_SquareEventNotifiedUpdateSquareStatus :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareStatus -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareStatus oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareStatus record
to_SquareEventNotifiedUpdateSquareStatus :: T.ThriftVal -> SquareEventNotifiedUpdateSquareStatus
to_SquareEventNotifiedUpdateSquareStatus (T.TStruct fields) = SquareEventNotifiedUpdateSquareStatus{
  squareEventNotifiedUpdateSquareStatus_squareMid = P.maybe (squareEventNotifiedUpdateSquareStatus_squareMid default_SquareEventNotifiedUpdateSquareStatus) (\(_,_val2475) -> (case _val2475 of {T.TString _val2476 -> E.decodeUtf8 _val2476; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareStatus_squareStatus = P.maybe (squareEventNotifiedUpdateSquareStatus_squareStatus default_SquareEventNotifiedUpdateSquareStatus) (\(_,_val2475) -> (case _val2475 of {T.TStruct _val2477 -> (to_SquareStatus (T.TStruct _val2477)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquareStatus _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareStatus :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareStatus
read_SquareEventNotifiedUpdateSquareStatus iprot = to_SquareEventNotifiedUpdateSquareStatus <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareStatus)
decode_SquareEventNotifiedUpdateSquareStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareStatus
decode_SquareEventNotifiedUpdateSquareStatus iprot bs = to_SquareEventNotifiedUpdateSquareStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareStatus) bs
typemap_SquareEventNotifiedUpdateSquareStatus :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareStatus = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareStatus",(T.T_STRUCT typemap_SquareStatus)))]
default_SquareEventNotifiedUpdateSquareStatus :: SquareEventNotifiedUpdateSquareStatus
default_SquareEventNotifiedUpdateSquareStatus = SquareEventNotifiedUpdateSquareStatus{
  squareEventNotifiedUpdateSquareStatus_squareMid = "",
  squareEventNotifiedUpdateSquareStatus_squareStatus = default_SquareStatus}
data SquareEventNotifiedCreateSquareMember = SquareEventNotifiedCreateSquareMember  { squareEventNotifiedCreateSquareMember_square :: Square
  , squareEventNotifiedCreateSquareMember_squareAuthority :: SquareAuthority
  , squareEventNotifiedCreateSquareMember_squareStatus :: SquareStatus
  , squareEventNotifiedCreateSquareMember_squareMember :: SquareMember
  , squareEventNotifiedCreateSquareMember_squareFeatureSet :: SquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedCreateSquareMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedCreateSquareMember_square record   `H.hashWithSalt` squareEventNotifiedCreateSquareMember_squareAuthority record   `H.hashWithSalt` squareEventNotifiedCreateSquareMember_squareStatus record   `H.hashWithSalt` squareEventNotifiedCreateSquareMember_squareMember record   `H.hashWithSalt` squareEventNotifiedCreateSquareMember_squareFeatureSet record  
instance QC.Arbitrary SquareEventNotifiedCreateSquareMember where 
  arbitrary = M.liftM SquareEventNotifiedCreateSquareMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedCreateSquareMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_square = squareEventNotifiedCreateSquareMember_square obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_square = squareEventNotifiedCreateSquareMember_square obj}
    , if obj == default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareAuthority = squareEventNotifiedCreateSquareMember_squareAuthority obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareAuthority = squareEventNotifiedCreateSquareMember_squareAuthority obj}
    , if obj == default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareStatus = squareEventNotifiedCreateSquareMember_squareStatus obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareStatus = squareEventNotifiedCreateSquareMember_squareStatus obj}
    , if obj == default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareMember = squareEventNotifiedCreateSquareMember_squareMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareMember = squareEventNotifiedCreateSquareMember_squareMember obj}
    , if obj == default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareFeatureSet = squareEventNotifiedCreateSquareMember_squareFeatureSet obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareMember{squareEventNotifiedCreateSquareMember_squareFeatureSet = squareEventNotifiedCreateSquareMember_squareFeatureSet obj}
    ]
from_SquareEventNotifiedCreateSquareMember :: SquareEventNotifiedCreateSquareMember -> T.ThriftVal
from_SquareEventNotifiedCreateSquareMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2480 -> P.Just (1, ("square",from_Square _v2480))) $ squareEventNotifiedCreateSquareMember_square record
  , (\_v2480 -> P.Just (2, ("squareAuthority",from_SquareAuthority _v2480))) $ squareEventNotifiedCreateSquareMember_squareAuthority record
  , (\_v2480 -> P.Just (3, ("squareStatus",from_SquareStatus _v2480))) $ squareEventNotifiedCreateSquareMember_squareStatus record
  , (\_v2480 -> P.Just (4, ("squareMember",from_SquareMember _v2480))) $ squareEventNotifiedCreateSquareMember_squareMember record
  , (\_v2480 -> P.Just (5, ("squareFeatureSet",from_SquareFeatureSet _v2480))) $ squareEventNotifiedCreateSquareMember_squareFeatureSet record
  ]
write_SquareEventNotifiedCreateSquareMember :: T.Protocol p => p -> SquareEventNotifiedCreateSquareMember -> P.IO ()
write_SquareEventNotifiedCreateSquareMember oprot record = T.writeVal oprot $ from_SquareEventNotifiedCreateSquareMember record
encode_SquareEventNotifiedCreateSquareMember :: T.StatelessProtocol p => p -> SquareEventNotifiedCreateSquareMember -> LBS.ByteString
encode_SquareEventNotifiedCreateSquareMember oprot record = T.serializeVal oprot $ from_SquareEventNotifiedCreateSquareMember record
to_SquareEventNotifiedCreateSquareMember :: T.ThriftVal -> SquareEventNotifiedCreateSquareMember
to_SquareEventNotifiedCreateSquareMember (T.TStruct fields) = SquareEventNotifiedCreateSquareMember{
  squareEventNotifiedCreateSquareMember_square = P.maybe (squareEventNotifiedCreateSquareMember_square default_SquareEventNotifiedCreateSquareMember) (\(_,_val2482) -> (case _val2482 of {T.TStruct _val2483 -> (to_Square (T.TStruct _val2483)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedCreateSquareMember_squareAuthority = P.maybe (squareEventNotifiedCreateSquareMember_squareAuthority default_SquareEventNotifiedCreateSquareMember) (\(_,_val2482) -> (case _val2482 of {T.TStruct _val2484 -> (to_SquareAuthority (T.TStruct _val2484)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedCreateSquareMember_squareStatus = P.maybe (squareEventNotifiedCreateSquareMember_squareStatus default_SquareEventNotifiedCreateSquareMember) (\(_,_val2482) -> (case _val2482 of {T.TStruct _val2485 -> (to_SquareStatus (T.TStruct _val2485)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotifiedCreateSquareMember_squareMember = P.maybe (squareEventNotifiedCreateSquareMember_squareMember default_SquareEventNotifiedCreateSquareMember) (\(_,_val2482) -> (case _val2482 of {T.TStruct _val2486 -> (to_SquareMember (T.TStruct _val2486)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareEventNotifiedCreateSquareMember_squareFeatureSet = P.maybe (squareEventNotifiedCreateSquareMember_squareFeatureSet default_SquareEventNotifiedCreateSquareMember) (\(_,_val2482) -> (case _val2482 of {T.TStruct _val2487 -> (to_SquareFeatureSet (T.TStruct _val2487)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SquareEventNotifiedCreateSquareMember _ = P.error "not a struct"
read_SquareEventNotifiedCreateSquareMember :: T.Protocol p => p -> P.IO SquareEventNotifiedCreateSquareMember
read_SquareEventNotifiedCreateSquareMember iprot = to_SquareEventNotifiedCreateSquareMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedCreateSquareMember)
decode_SquareEventNotifiedCreateSquareMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedCreateSquareMember
decode_SquareEventNotifiedCreateSquareMember iprot bs = to_SquareEventNotifiedCreateSquareMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedCreateSquareMember) bs
typemap_SquareEventNotifiedCreateSquareMember :: T.TypeMap
typemap_SquareEventNotifiedCreateSquareMember = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("squareAuthority",(T.T_STRUCT typemap_SquareAuthority))),(3,("squareStatus",(T.T_STRUCT typemap_SquareStatus))),(4,("squareMember",(T.T_STRUCT typemap_SquareMember))),(5,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet)))]
default_SquareEventNotifiedCreateSquareMember :: SquareEventNotifiedCreateSquareMember
default_SquareEventNotifiedCreateSquareMember = SquareEventNotifiedCreateSquareMember{
  squareEventNotifiedCreateSquareMember_square = default_Square,
  squareEventNotifiedCreateSquareMember_squareAuthority = default_SquareAuthority,
  squareEventNotifiedCreateSquareMember_squareStatus = default_SquareStatus,
  squareEventNotifiedCreateSquareMember_squareMember = default_SquareMember,
  squareEventNotifiedCreateSquareMember_squareFeatureSet = default_SquareFeatureSet}
data SquareEventNotifiedCreateSquareChatMember = SquareEventNotifiedCreateSquareChatMember  { squareEventNotifiedCreateSquareChatMember_squareChatMid :: LT.Text
  , squareEventNotifiedCreateSquareChatMember_squareMemberMid :: LT.Text
  , squareEventNotifiedCreateSquareChatMember_squareChatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedCreateSquareChatMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedCreateSquareChatMember_squareChatMid record   `H.hashWithSalt` squareEventNotifiedCreateSquareChatMember_squareMemberMid record   `H.hashWithSalt` squareEventNotifiedCreateSquareChatMember_squareChatMember record  
instance QC.Arbitrary SquareEventNotifiedCreateSquareChatMember where 
  arbitrary = M.liftM SquareEventNotifiedCreateSquareChatMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedCreateSquareChatMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareChatMid = squareEventNotifiedCreateSquareChatMember_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareChatMid = squareEventNotifiedCreateSquareChatMember_squareChatMid obj}
    , if obj == default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareMemberMid = squareEventNotifiedCreateSquareChatMember_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareMemberMid = squareEventNotifiedCreateSquareChatMember_squareMemberMid obj}
    , if obj == default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareChatMember = squareEventNotifiedCreateSquareChatMember_squareChatMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedCreateSquareChatMember{squareEventNotifiedCreateSquareChatMember_squareChatMember = squareEventNotifiedCreateSquareChatMember_squareChatMember obj}
    ]
from_SquareEventNotifiedCreateSquareChatMember :: SquareEventNotifiedCreateSquareChatMember -> T.ThriftVal
from_SquareEventNotifiedCreateSquareChatMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2490 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2490))) $ squareEventNotifiedCreateSquareChatMember_squareChatMid record
  , (\_v2490 -> P.Just (2, ("squareMemberMid",T.TString $ E.encodeUtf8 _v2490))) $ squareEventNotifiedCreateSquareChatMember_squareMemberMid record
  , (\_v2490 -> P.Just (3, ("squareChatMember",from_SquareChatMember _v2490))) $ squareEventNotifiedCreateSquareChatMember_squareChatMember record
  ]
write_SquareEventNotifiedCreateSquareChatMember :: T.Protocol p => p -> SquareEventNotifiedCreateSquareChatMember -> P.IO ()
write_SquareEventNotifiedCreateSquareChatMember oprot record = T.writeVal oprot $ from_SquareEventNotifiedCreateSquareChatMember record
encode_SquareEventNotifiedCreateSquareChatMember :: T.StatelessProtocol p => p -> SquareEventNotifiedCreateSquareChatMember -> LBS.ByteString
encode_SquareEventNotifiedCreateSquareChatMember oprot record = T.serializeVal oprot $ from_SquareEventNotifiedCreateSquareChatMember record
to_SquareEventNotifiedCreateSquareChatMember :: T.ThriftVal -> SquareEventNotifiedCreateSquareChatMember
to_SquareEventNotifiedCreateSquareChatMember (T.TStruct fields) = SquareEventNotifiedCreateSquareChatMember{
  squareEventNotifiedCreateSquareChatMember_squareChatMid = P.maybe (squareEventNotifiedCreateSquareChatMember_squareChatMid default_SquareEventNotifiedCreateSquareChatMember) (\(_,_val2492) -> (case _val2492 of {T.TString _val2493 -> E.decodeUtf8 _val2493; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedCreateSquareChatMember_squareMemberMid = P.maybe (squareEventNotifiedCreateSquareChatMember_squareMemberMid default_SquareEventNotifiedCreateSquareChatMember) (\(_,_val2492) -> (case _val2492 of {T.TString _val2494 -> E.decodeUtf8 _val2494; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedCreateSquareChatMember_squareChatMember = P.maybe (squareEventNotifiedCreateSquareChatMember_squareChatMember default_SquareEventNotifiedCreateSquareChatMember) (\(_,_val2492) -> (case _val2492 of {T.TStruct _val2495 -> (to_SquareChatMember (T.TStruct _val2495)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedCreateSquareChatMember _ = P.error "not a struct"
read_SquareEventNotifiedCreateSquareChatMember :: T.Protocol p => p -> P.IO SquareEventNotifiedCreateSquareChatMember
read_SquareEventNotifiedCreateSquareChatMember iprot = to_SquareEventNotifiedCreateSquareChatMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedCreateSquareChatMember)
decode_SquareEventNotifiedCreateSquareChatMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedCreateSquareChatMember
decode_SquareEventNotifiedCreateSquareChatMember iprot bs = to_SquareEventNotifiedCreateSquareChatMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedCreateSquareChatMember) bs
typemap_SquareEventNotifiedCreateSquareChatMember :: T.TypeMap
typemap_SquareEventNotifiedCreateSquareChatMember = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMemberMid",T.T_STRING)),(3,("squareChatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_SquareEventNotifiedCreateSquareChatMember :: SquareEventNotifiedCreateSquareChatMember
default_SquareEventNotifiedCreateSquareChatMember = SquareEventNotifiedCreateSquareChatMember{
  squareEventNotifiedCreateSquareChatMember_squareChatMid = "",
  squareEventNotifiedCreateSquareChatMember_squareMemberMid = "",
  squareEventNotifiedCreateSquareChatMember_squareChatMember = default_SquareChatMember}
data SquareEventNotifiedUpdateSquareMemberRelation = SquareEventNotifiedUpdateSquareMemberRelation  { squareEventNotifiedUpdateSquareMemberRelation_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquareMemberRelation_myMemberMid :: LT.Text
  , squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid :: LT.Text
  , squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation :: SquareMemberRelation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareMemberRelation where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberRelation_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberRelation_myMemberMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareMemberRelation where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareMemberRelation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareMemberRelation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_squareMid = squareEventNotifiedUpdateSquareMemberRelation_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_squareMid = squareEventNotifiedUpdateSquareMemberRelation_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_myMemberMid = squareEventNotifiedUpdateSquareMemberRelation_myMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_myMemberMid = squareEventNotifiedUpdateSquareMemberRelation_myMemberMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid = squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid = squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation = squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMemberRelation{squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation = squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation obj}
    ]
from_SquareEventNotifiedUpdateSquareMemberRelation :: SquareEventNotifiedUpdateSquareMemberRelation -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareMemberRelation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2498 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2498))) $ squareEventNotifiedUpdateSquareMemberRelation_squareMid record
  , (\_v2498 -> P.Just (2, ("myMemberMid",T.TString $ E.encodeUtf8 _v2498))) $ squareEventNotifiedUpdateSquareMemberRelation_myMemberMid record
  , (\_v2498 -> P.Just (3, ("targetSquareMemberMid",T.TString $ E.encodeUtf8 _v2498))) $ squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid record
  , (\_v2498 -> P.Just (4, ("squareMemberRelation",from_SquareMemberRelation _v2498))) $ squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation record
  ]
write_SquareEventNotifiedUpdateSquareMemberRelation :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareMemberRelation -> P.IO ()
write_SquareEventNotifiedUpdateSquareMemberRelation oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareMemberRelation record
encode_SquareEventNotifiedUpdateSquareMemberRelation :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareMemberRelation -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareMemberRelation oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareMemberRelation record
to_SquareEventNotifiedUpdateSquareMemberRelation :: T.ThriftVal -> SquareEventNotifiedUpdateSquareMemberRelation
to_SquareEventNotifiedUpdateSquareMemberRelation (T.TStruct fields) = SquareEventNotifiedUpdateSquareMemberRelation{
  squareEventNotifiedUpdateSquareMemberRelation_squareMid = P.maybe (squareEventNotifiedUpdateSquareMemberRelation_squareMid default_SquareEventNotifiedUpdateSquareMemberRelation) (\(_,_val2500) -> (case _val2500 of {T.TString _val2501 -> E.decodeUtf8 _val2501; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareMemberRelation_myMemberMid = P.maybe (squareEventNotifiedUpdateSquareMemberRelation_myMemberMid default_SquareEventNotifiedUpdateSquareMemberRelation) (\(_,_val2500) -> (case _val2500 of {T.TString _val2502 -> E.decodeUtf8 _val2502; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid = P.maybe (squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid default_SquareEventNotifiedUpdateSquareMemberRelation) (\(_,_val2500) -> (case _val2500 of {T.TString _val2503 -> E.decodeUtf8 _val2503; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation = P.maybe (squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation default_SquareEventNotifiedUpdateSquareMemberRelation) (\(_,_val2500) -> (case _val2500 of {T.TStruct _val2504 -> (to_SquareMemberRelation (T.TStruct _val2504)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareEventNotifiedUpdateSquareMemberRelation _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareMemberRelation :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareMemberRelation
read_SquareEventNotifiedUpdateSquareMemberRelation iprot = to_SquareEventNotifiedUpdateSquareMemberRelation <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberRelation)
decode_SquareEventNotifiedUpdateSquareMemberRelation :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareMemberRelation
decode_SquareEventNotifiedUpdateSquareMemberRelation iprot bs = to_SquareEventNotifiedUpdateSquareMemberRelation $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberRelation) bs
typemap_SquareEventNotifiedUpdateSquareMemberRelation :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareMemberRelation = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("myMemberMid",T.T_STRING)),(3,("targetSquareMemberMid",T.T_STRING)),(4,("squareMemberRelation",(T.T_STRUCT typemap_SquareMemberRelation)))]
default_SquareEventNotifiedUpdateSquareMemberRelation :: SquareEventNotifiedUpdateSquareMemberRelation
default_SquareEventNotifiedUpdateSquareMemberRelation = SquareEventNotifiedUpdateSquareMemberRelation{
  squareEventNotifiedUpdateSquareMemberRelation_squareMid = "",
  squareEventNotifiedUpdateSquareMemberRelation_myMemberMid = "",
  squareEventNotifiedUpdateSquareMemberRelation_targetSquareMemberMid = "",
  squareEventNotifiedUpdateSquareMemberRelation_squareMemberRelation = default_SquareMemberRelation}
data SquareEventNotifiedUpdateSquare = SquareEventNotifiedUpdateSquare  { squareEventNotifiedUpdateSquare_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquare_square :: Square
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquare where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquare_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquare_square record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquare where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquare (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquare = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquare{squareEventNotifiedUpdateSquare_squareMid = squareEventNotifiedUpdateSquare_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquare{squareEventNotifiedUpdateSquare_squareMid = squareEventNotifiedUpdateSquare_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquare{squareEventNotifiedUpdateSquare_square = squareEventNotifiedUpdateSquare_square obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquare{squareEventNotifiedUpdateSquare_square = squareEventNotifiedUpdateSquare_square obj}
    ]
from_SquareEventNotifiedUpdateSquare :: SquareEventNotifiedUpdateSquare -> T.ThriftVal
from_SquareEventNotifiedUpdateSquare record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2507 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2507))) $ squareEventNotifiedUpdateSquare_squareMid record
  , (\_v2507 -> P.Just (2, ("square",from_Square _v2507))) $ squareEventNotifiedUpdateSquare_square record
  ]
write_SquareEventNotifiedUpdateSquare :: T.Protocol p => p -> SquareEventNotifiedUpdateSquare -> P.IO ()
write_SquareEventNotifiedUpdateSquare oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquare record
encode_SquareEventNotifiedUpdateSquare :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquare -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquare oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquare record
to_SquareEventNotifiedUpdateSquare :: T.ThriftVal -> SquareEventNotifiedUpdateSquare
to_SquareEventNotifiedUpdateSquare (T.TStruct fields) = SquareEventNotifiedUpdateSquare{
  squareEventNotifiedUpdateSquare_squareMid = P.maybe (squareEventNotifiedUpdateSquare_squareMid default_SquareEventNotifiedUpdateSquare) (\(_,_val2509) -> (case _val2509 of {T.TString _val2510 -> E.decodeUtf8 _val2510; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquare_square = P.maybe (squareEventNotifiedUpdateSquare_square default_SquareEventNotifiedUpdateSquare) (\(_,_val2509) -> (case _val2509 of {T.TStruct _val2511 -> (to_Square (T.TStruct _val2511)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquare _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquare :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquare
read_SquareEventNotifiedUpdateSquare iprot = to_SquareEventNotifiedUpdateSquare <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquare)
decode_SquareEventNotifiedUpdateSquare :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquare
decode_SquareEventNotifiedUpdateSquare iprot bs = to_SquareEventNotifiedUpdateSquare $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquare) bs
typemap_SquareEventNotifiedUpdateSquare :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquare = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("square",(T.T_STRUCT typemap_Square)))]
default_SquareEventNotifiedUpdateSquare :: SquareEventNotifiedUpdateSquare
default_SquareEventNotifiedUpdateSquare = SquareEventNotifiedUpdateSquare{
  squareEventNotifiedUpdateSquare_squareMid = "",
  squareEventNotifiedUpdateSquare_square = default_Square}
data SquareEventNotifiedUpdateSquareMember = SquareEventNotifiedUpdateSquareMember  { squareEventNotifiedUpdateSquareMember_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquareMember_squareMemberMid :: LT.Text
  , squareEventNotifiedUpdateSquareMember_squareMember :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareMember_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMember_squareMemberMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareMember_squareMember record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareMember where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMid = squareEventNotifiedUpdateSquareMember_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMid = squareEventNotifiedUpdateSquareMember_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMemberMid = squareEventNotifiedUpdateSquareMember_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMemberMid = squareEventNotifiedUpdateSquareMember_squareMemberMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMember = squareEventNotifiedUpdateSquareMember_squareMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareMember{squareEventNotifiedUpdateSquareMember_squareMember = squareEventNotifiedUpdateSquareMember_squareMember obj}
    ]
from_SquareEventNotifiedUpdateSquareMember :: SquareEventNotifiedUpdateSquareMember -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2514 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2514))) $ squareEventNotifiedUpdateSquareMember_squareMid record
  , (\_v2514 -> P.Just (2, ("squareMemberMid",T.TString $ E.encodeUtf8 _v2514))) $ squareEventNotifiedUpdateSquareMember_squareMemberMid record
  , (\_v2514 -> P.Just (3, ("squareMember",from_SquareMember _v2514))) $ squareEventNotifiedUpdateSquareMember_squareMember record
  ]
write_SquareEventNotifiedUpdateSquareMember :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareMember -> P.IO ()
write_SquareEventNotifiedUpdateSquareMember oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareMember record
encode_SquareEventNotifiedUpdateSquareMember :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareMember -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareMember oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareMember record
to_SquareEventNotifiedUpdateSquareMember :: T.ThriftVal -> SquareEventNotifiedUpdateSquareMember
to_SquareEventNotifiedUpdateSquareMember (T.TStruct fields) = SquareEventNotifiedUpdateSquareMember{
  squareEventNotifiedUpdateSquareMember_squareMid = P.maybe (squareEventNotifiedUpdateSquareMember_squareMid default_SquareEventNotifiedUpdateSquareMember) (\(_,_val2516) -> (case _val2516 of {T.TString _val2517 -> E.decodeUtf8 _val2517; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareMember_squareMemberMid = P.maybe (squareEventNotifiedUpdateSquareMember_squareMemberMid default_SquareEventNotifiedUpdateSquareMember) (\(_,_val2516) -> (case _val2516 of {T.TString _val2518 -> E.decodeUtf8 _val2518; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedUpdateSquareMember_squareMember = P.maybe (squareEventNotifiedUpdateSquareMember_squareMember default_SquareEventNotifiedUpdateSquareMember) (\(_,_val2516) -> (case _val2516 of {T.TStruct _val2519 -> (to_SquareMember (T.TStruct _val2519)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedUpdateSquareMember _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareMember :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareMember
read_SquareEventNotifiedUpdateSquareMember iprot = to_SquareEventNotifiedUpdateSquareMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMember)
decode_SquareEventNotifiedUpdateSquareMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareMember
decode_SquareEventNotifiedUpdateSquareMember iprot bs = to_SquareEventNotifiedUpdateSquareMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMember) bs
typemap_SquareEventNotifiedUpdateSquareMember :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareMember = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareMemberMid",T.T_STRING)),(3,("squareMember",(T.T_STRUCT typemap_SquareMember)))]
default_SquareEventNotifiedUpdateSquareMember :: SquareEventNotifiedUpdateSquareMember
default_SquareEventNotifiedUpdateSquareMember = SquareEventNotifiedUpdateSquareMember{
  squareEventNotifiedUpdateSquareMember_squareMid = "",
  squareEventNotifiedUpdateSquareMember_squareMemberMid = "",
  squareEventNotifiedUpdateSquareMember_squareMember = default_SquareMember}
data SquareEventNotifiedUpdateSquareChat = SquareEventNotifiedUpdateSquareChat  { squareEventNotifiedUpdateSquareChat_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquareChat_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareChat_squareChat :: SquareChat
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareChat where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareChat_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChat_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChat_squareChat record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareChat where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareChat (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareChat = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareMid = squareEventNotifiedUpdateSquareChat_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareMid = squareEventNotifiedUpdateSquareChat_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareChatMid = squareEventNotifiedUpdateSquareChat_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareChatMid = squareEventNotifiedUpdateSquareChat_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareChat = squareEventNotifiedUpdateSquareChat_squareChat obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChat{squareEventNotifiedUpdateSquareChat_squareChat = squareEventNotifiedUpdateSquareChat_squareChat obj}
    ]
from_SquareEventNotifiedUpdateSquareChat :: SquareEventNotifiedUpdateSquareChat -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareChat record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2522 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2522))) $ squareEventNotifiedUpdateSquareChat_squareMid record
  , (\_v2522 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2522))) $ squareEventNotifiedUpdateSquareChat_squareChatMid record
  , (\_v2522 -> P.Just (3, ("squareChat",from_SquareChat _v2522))) $ squareEventNotifiedUpdateSquareChat_squareChat record
  ]
write_SquareEventNotifiedUpdateSquareChat :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareChat -> P.IO ()
write_SquareEventNotifiedUpdateSquareChat oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareChat record
encode_SquareEventNotifiedUpdateSquareChat :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareChat -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareChat oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareChat record
to_SquareEventNotifiedUpdateSquareChat :: T.ThriftVal -> SquareEventNotifiedUpdateSquareChat
to_SquareEventNotifiedUpdateSquareChat (T.TStruct fields) = SquareEventNotifiedUpdateSquareChat{
  squareEventNotifiedUpdateSquareChat_squareMid = P.maybe (squareEventNotifiedUpdateSquareChat_squareMid default_SquareEventNotifiedUpdateSquareChat) (\(_,_val2524) -> (case _val2524 of {T.TString _val2525 -> E.decodeUtf8 _val2525; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareChat_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareChat_squareChatMid default_SquareEventNotifiedUpdateSquareChat) (\(_,_val2524) -> (case _val2524 of {T.TString _val2526 -> E.decodeUtf8 _val2526; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedUpdateSquareChat_squareChat = P.maybe (squareEventNotifiedUpdateSquareChat_squareChat default_SquareEventNotifiedUpdateSquareChat) (\(_,_val2524) -> (case _val2524 of {T.TStruct _val2527 -> (to_SquareChat (T.TStruct _val2527)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedUpdateSquareChat _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareChat :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareChat
read_SquareEventNotifiedUpdateSquareChat iprot = to_SquareEventNotifiedUpdateSquareChat <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChat)
decode_SquareEventNotifiedUpdateSquareChat :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareChat
decode_SquareEventNotifiedUpdateSquareChat iprot bs = to_SquareEventNotifiedUpdateSquareChat $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChat) bs
typemap_SquareEventNotifiedUpdateSquareChat :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareChat = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareChatMid",T.T_STRING)),(3,("squareChat",(T.T_STRUCT typemap_SquareChat)))]
default_SquareEventNotifiedUpdateSquareChat :: SquareEventNotifiedUpdateSquareChat
default_SquareEventNotifiedUpdateSquareChat = SquareEventNotifiedUpdateSquareChat{
  squareEventNotifiedUpdateSquareChat_squareMid = "",
  squareEventNotifiedUpdateSquareChat_squareChatMid = "",
  squareEventNotifiedUpdateSquareChat_squareChat = default_SquareChat}
data SquareEventNotificationJoinRequest = SquareEventNotificationJoinRequest  { squareEventNotificationJoinRequest_squareMid :: LT.Text
  , squareEventNotificationJoinRequest_squareName :: LT.Text
  , squareEventNotificationJoinRequest_requestMemberName :: LT.Text
  , squareEventNotificationJoinRequest_profileImageObsHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotificationJoinRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotificationJoinRequest_squareMid record   `H.hashWithSalt` squareEventNotificationJoinRequest_squareName record   `H.hashWithSalt` squareEventNotificationJoinRequest_requestMemberName record   `H.hashWithSalt` squareEventNotificationJoinRequest_profileImageObsHash record  
instance QC.Arbitrary SquareEventNotificationJoinRequest where 
  arbitrary = M.liftM SquareEventNotificationJoinRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotificationJoinRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_squareMid = squareEventNotificationJoinRequest_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_squareMid = squareEventNotificationJoinRequest_squareMid obj}
    , if obj == default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_squareName = squareEventNotificationJoinRequest_squareName obj} then P.Nothing else P.Just $ default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_squareName = squareEventNotificationJoinRequest_squareName obj}
    , if obj == default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_requestMemberName = squareEventNotificationJoinRequest_requestMemberName obj} then P.Nothing else P.Just $ default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_requestMemberName = squareEventNotificationJoinRequest_requestMemberName obj}
    , if obj == default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_profileImageObsHash = squareEventNotificationJoinRequest_profileImageObsHash obj} then P.Nothing else P.Just $ default_SquareEventNotificationJoinRequest{squareEventNotificationJoinRequest_profileImageObsHash = squareEventNotificationJoinRequest_profileImageObsHash obj}
    ]
from_SquareEventNotificationJoinRequest :: SquareEventNotificationJoinRequest -> T.ThriftVal
from_SquareEventNotificationJoinRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2530 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2530))) $ squareEventNotificationJoinRequest_squareMid record
  , (\_v2530 -> P.Just (2, ("squareName",T.TString $ E.encodeUtf8 _v2530))) $ squareEventNotificationJoinRequest_squareName record
  , (\_v2530 -> P.Just (3, ("requestMemberName",T.TString $ E.encodeUtf8 _v2530))) $ squareEventNotificationJoinRequest_requestMemberName record
  , (\_v2530 -> P.Just (4, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v2530))) $ squareEventNotificationJoinRequest_profileImageObsHash record
  ]
write_SquareEventNotificationJoinRequest :: T.Protocol p => p -> SquareEventNotificationJoinRequest -> P.IO ()
write_SquareEventNotificationJoinRequest oprot record = T.writeVal oprot $ from_SquareEventNotificationJoinRequest record
encode_SquareEventNotificationJoinRequest :: T.StatelessProtocol p => p -> SquareEventNotificationJoinRequest -> LBS.ByteString
encode_SquareEventNotificationJoinRequest oprot record = T.serializeVal oprot $ from_SquareEventNotificationJoinRequest record
to_SquareEventNotificationJoinRequest :: T.ThriftVal -> SquareEventNotificationJoinRequest
to_SquareEventNotificationJoinRequest (T.TStruct fields) = SquareEventNotificationJoinRequest{
  squareEventNotificationJoinRequest_squareMid = P.maybe (squareEventNotificationJoinRequest_squareMid default_SquareEventNotificationJoinRequest) (\(_,_val2532) -> (case _val2532 of {T.TString _val2533 -> E.decodeUtf8 _val2533; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotificationJoinRequest_squareName = P.maybe (squareEventNotificationJoinRequest_squareName default_SquareEventNotificationJoinRequest) (\(_,_val2532) -> (case _val2532 of {T.TString _val2534 -> E.decodeUtf8 _val2534; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotificationJoinRequest_requestMemberName = P.maybe (squareEventNotificationJoinRequest_requestMemberName default_SquareEventNotificationJoinRequest) (\(_,_val2532) -> (case _val2532 of {T.TString _val2535 -> E.decodeUtf8 _val2535; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotificationJoinRequest_profileImageObsHash = P.maybe (squareEventNotificationJoinRequest_profileImageObsHash default_SquareEventNotificationJoinRequest) (\(_,_val2532) -> (case _val2532 of {T.TString _val2536 -> E.decodeUtf8 _val2536; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SquareEventNotificationJoinRequest _ = P.error "not a struct"
read_SquareEventNotificationJoinRequest :: T.Protocol p => p -> P.IO SquareEventNotificationJoinRequest
read_SquareEventNotificationJoinRequest iprot = to_SquareEventNotificationJoinRequest <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotificationJoinRequest)
decode_SquareEventNotificationJoinRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotificationJoinRequest
decode_SquareEventNotificationJoinRequest iprot bs = to_SquareEventNotificationJoinRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotificationJoinRequest) bs
typemap_SquareEventNotificationJoinRequest :: T.TypeMap
typemap_SquareEventNotificationJoinRequest = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareName",T.T_STRING)),(3,("requestMemberName",T.T_STRING)),(4,("profileImageObsHash",T.T_STRING))]
default_SquareEventNotificationJoinRequest :: SquareEventNotificationJoinRequest
default_SquareEventNotificationJoinRequest = SquareEventNotificationJoinRequest{
  squareEventNotificationJoinRequest_squareMid = "",
  squareEventNotificationJoinRequest_squareName = "",
  squareEventNotificationJoinRequest_requestMemberName = "",
  squareEventNotificationJoinRequest_profileImageObsHash = ""}
data SquareEventNotificationMemberUpdate = SquareEventNotificationMemberUpdate  { squareEventNotificationMemberUpdate_squareMid :: LT.Text
  , squareEventNotificationMemberUpdate_squareName :: LT.Text
  , squareEventNotificationMemberUpdate_profileImageObsHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotificationMemberUpdate where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotificationMemberUpdate_squareMid record   `H.hashWithSalt` squareEventNotificationMemberUpdate_squareName record   `H.hashWithSalt` squareEventNotificationMemberUpdate_profileImageObsHash record  
instance QC.Arbitrary SquareEventNotificationMemberUpdate where 
  arbitrary = M.liftM SquareEventNotificationMemberUpdate (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotificationMemberUpdate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_squareMid = squareEventNotificationMemberUpdate_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_squareMid = squareEventNotificationMemberUpdate_squareMid obj}
    , if obj == default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_squareName = squareEventNotificationMemberUpdate_squareName obj} then P.Nothing else P.Just $ default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_squareName = squareEventNotificationMemberUpdate_squareName obj}
    , if obj == default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_profileImageObsHash = squareEventNotificationMemberUpdate_profileImageObsHash obj} then P.Nothing else P.Just $ default_SquareEventNotificationMemberUpdate{squareEventNotificationMemberUpdate_profileImageObsHash = squareEventNotificationMemberUpdate_profileImageObsHash obj}
    ]
from_SquareEventNotificationMemberUpdate :: SquareEventNotificationMemberUpdate -> T.ThriftVal
from_SquareEventNotificationMemberUpdate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2539 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2539))) $ squareEventNotificationMemberUpdate_squareMid record
  , (\_v2539 -> P.Just (2, ("squareName",T.TString $ E.encodeUtf8 _v2539))) $ squareEventNotificationMemberUpdate_squareName record
  , (\_v2539 -> P.Just (3, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v2539))) $ squareEventNotificationMemberUpdate_profileImageObsHash record
  ]
write_SquareEventNotificationMemberUpdate :: T.Protocol p => p -> SquareEventNotificationMemberUpdate -> P.IO ()
write_SquareEventNotificationMemberUpdate oprot record = T.writeVal oprot $ from_SquareEventNotificationMemberUpdate record
encode_SquareEventNotificationMemberUpdate :: T.StatelessProtocol p => p -> SquareEventNotificationMemberUpdate -> LBS.ByteString
encode_SquareEventNotificationMemberUpdate oprot record = T.serializeVal oprot $ from_SquareEventNotificationMemberUpdate record
to_SquareEventNotificationMemberUpdate :: T.ThriftVal -> SquareEventNotificationMemberUpdate
to_SquareEventNotificationMemberUpdate (T.TStruct fields) = SquareEventNotificationMemberUpdate{
  squareEventNotificationMemberUpdate_squareMid = P.maybe (squareEventNotificationMemberUpdate_squareMid default_SquareEventNotificationMemberUpdate) (\(_,_val2541) -> (case _val2541 of {T.TString _val2542 -> E.decodeUtf8 _val2542; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotificationMemberUpdate_squareName = P.maybe (squareEventNotificationMemberUpdate_squareName default_SquareEventNotificationMemberUpdate) (\(_,_val2541) -> (case _val2541 of {T.TString _val2543 -> E.decodeUtf8 _val2543; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotificationMemberUpdate_profileImageObsHash = P.maybe (squareEventNotificationMemberUpdate_profileImageObsHash default_SquareEventNotificationMemberUpdate) (\(_,_val2541) -> (case _val2541 of {T.TString _val2544 -> E.decodeUtf8 _val2544; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotificationMemberUpdate _ = P.error "not a struct"
read_SquareEventNotificationMemberUpdate :: T.Protocol p => p -> P.IO SquareEventNotificationMemberUpdate
read_SquareEventNotificationMemberUpdate iprot = to_SquareEventNotificationMemberUpdate <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotificationMemberUpdate)
decode_SquareEventNotificationMemberUpdate :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotificationMemberUpdate
decode_SquareEventNotificationMemberUpdate iprot bs = to_SquareEventNotificationMemberUpdate $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotificationMemberUpdate) bs
typemap_SquareEventNotificationMemberUpdate :: T.TypeMap
typemap_SquareEventNotificationMemberUpdate = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareName",T.T_STRING)),(3,("profileImageObsHash",T.T_STRING))]
default_SquareEventNotificationMemberUpdate :: SquareEventNotificationMemberUpdate
default_SquareEventNotificationMemberUpdate = SquareEventNotificationMemberUpdate{
  squareEventNotificationMemberUpdate_squareMid = "",
  squareEventNotificationMemberUpdate_squareName = "",
  squareEventNotificationMemberUpdate_profileImageObsHash = ""}
data SquareEventNotificationSquareDelete = SquareEventNotificationSquareDelete  { squareEventNotificationSquareDelete_squareMid :: LT.Text
  , squareEventNotificationSquareDelete_squareName :: LT.Text
  , squareEventNotificationSquareDelete_profileImageObsHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotificationSquareDelete where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotificationSquareDelete_squareMid record   `H.hashWithSalt` squareEventNotificationSquareDelete_squareName record   `H.hashWithSalt` squareEventNotificationSquareDelete_profileImageObsHash record  
instance QC.Arbitrary SquareEventNotificationSquareDelete where 
  arbitrary = M.liftM SquareEventNotificationSquareDelete (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotificationSquareDelete = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_squareMid = squareEventNotificationSquareDelete_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_squareMid = squareEventNotificationSquareDelete_squareMid obj}
    , if obj == default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_squareName = squareEventNotificationSquareDelete_squareName obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_squareName = squareEventNotificationSquareDelete_squareName obj}
    , if obj == default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_profileImageObsHash = squareEventNotificationSquareDelete_profileImageObsHash obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareDelete{squareEventNotificationSquareDelete_profileImageObsHash = squareEventNotificationSquareDelete_profileImageObsHash obj}
    ]
from_SquareEventNotificationSquareDelete :: SquareEventNotificationSquareDelete -> T.ThriftVal
from_SquareEventNotificationSquareDelete record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2547 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2547))) $ squareEventNotificationSquareDelete_squareMid record
  , (\_v2547 -> P.Just (2, ("squareName",T.TString $ E.encodeUtf8 _v2547))) $ squareEventNotificationSquareDelete_squareName record
  , (\_v2547 -> P.Just (3, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v2547))) $ squareEventNotificationSquareDelete_profileImageObsHash record
  ]
write_SquareEventNotificationSquareDelete :: T.Protocol p => p -> SquareEventNotificationSquareDelete -> P.IO ()
write_SquareEventNotificationSquareDelete oprot record = T.writeVal oprot $ from_SquareEventNotificationSquareDelete record
encode_SquareEventNotificationSquareDelete :: T.StatelessProtocol p => p -> SquareEventNotificationSquareDelete -> LBS.ByteString
encode_SquareEventNotificationSquareDelete oprot record = T.serializeVal oprot $ from_SquareEventNotificationSquareDelete record
to_SquareEventNotificationSquareDelete :: T.ThriftVal -> SquareEventNotificationSquareDelete
to_SquareEventNotificationSquareDelete (T.TStruct fields) = SquareEventNotificationSquareDelete{
  squareEventNotificationSquareDelete_squareMid = P.maybe (squareEventNotificationSquareDelete_squareMid default_SquareEventNotificationSquareDelete) (\(_,_val2549) -> (case _val2549 of {T.TString _val2550 -> E.decodeUtf8 _val2550; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotificationSquareDelete_squareName = P.maybe (squareEventNotificationSquareDelete_squareName default_SquareEventNotificationSquareDelete) (\(_,_val2549) -> (case _val2549 of {T.TString _val2551 -> E.decodeUtf8 _val2551; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotificationSquareDelete_profileImageObsHash = P.maybe (squareEventNotificationSquareDelete_profileImageObsHash default_SquareEventNotificationSquareDelete) (\(_,_val2549) -> (case _val2549 of {T.TString _val2552 -> E.decodeUtf8 _val2552; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotificationSquareDelete _ = P.error "not a struct"
read_SquareEventNotificationSquareDelete :: T.Protocol p => p -> P.IO SquareEventNotificationSquareDelete
read_SquareEventNotificationSquareDelete iprot = to_SquareEventNotificationSquareDelete <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotificationSquareDelete)
decode_SquareEventNotificationSquareDelete :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotificationSquareDelete
decode_SquareEventNotificationSquareDelete iprot bs = to_SquareEventNotificationSquareDelete $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotificationSquareDelete) bs
typemap_SquareEventNotificationSquareDelete :: T.TypeMap
typemap_SquareEventNotificationSquareDelete = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareName",T.T_STRING)),(3,("profileImageObsHash",T.T_STRING))]
default_SquareEventNotificationSquareDelete :: SquareEventNotificationSquareDelete
default_SquareEventNotificationSquareDelete = SquareEventNotificationSquareDelete{
  squareEventNotificationSquareDelete_squareMid = "",
  squareEventNotificationSquareDelete_squareName = "",
  squareEventNotificationSquareDelete_profileImageObsHash = ""}
data SquareEventNotificationSquareChatDelete = SquareEventNotificationSquareChatDelete  { squareEventNotificationSquareChatDelete_squareChatMid :: LT.Text
  , squareEventNotificationSquareChatDelete_squareChatName :: LT.Text
  , squareEventNotificationSquareChatDelete_profileImageObsHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotificationSquareChatDelete where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotificationSquareChatDelete_squareChatMid record   `H.hashWithSalt` squareEventNotificationSquareChatDelete_squareChatName record   `H.hashWithSalt` squareEventNotificationSquareChatDelete_profileImageObsHash record  
instance QC.Arbitrary SquareEventNotificationSquareChatDelete where 
  arbitrary = M.liftM SquareEventNotificationSquareChatDelete (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotificationSquareChatDelete = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_squareChatMid = squareEventNotificationSquareChatDelete_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_squareChatMid = squareEventNotificationSquareChatDelete_squareChatMid obj}
    , if obj == default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_squareChatName = squareEventNotificationSquareChatDelete_squareChatName obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_squareChatName = squareEventNotificationSquareChatDelete_squareChatName obj}
    , if obj == default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_profileImageObsHash = squareEventNotificationSquareChatDelete_profileImageObsHash obj} then P.Nothing else P.Just $ default_SquareEventNotificationSquareChatDelete{squareEventNotificationSquareChatDelete_profileImageObsHash = squareEventNotificationSquareChatDelete_profileImageObsHash obj}
    ]
from_SquareEventNotificationSquareChatDelete :: SquareEventNotificationSquareChatDelete -> T.ThriftVal
from_SquareEventNotificationSquareChatDelete record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2555 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2555))) $ squareEventNotificationSquareChatDelete_squareChatMid record
  , (\_v2555 -> P.Just (2, ("squareChatName",T.TString $ E.encodeUtf8 _v2555))) $ squareEventNotificationSquareChatDelete_squareChatName record
  , (\_v2555 -> P.Just (3, ("profileImageObsHash",T.TString $ E.encodeUtf8 _v2555))) $ squareEventNotificationSquareChatDelete_profileImageObsHash record
  ]
write_SquareEventNotificationSquareChatDelete :: T.Protocol p => p -> SquareEventNotificationSquareChatDelete -> P.IO ()
write_SquareEventNotificationSquareChatDelete oprot record = T.writeVal oprot $ from_SquareEventNotificationSquareChatDelete record
encode_SquareEventNotificationSquareChatDelete :: T.StatelessProtocol p => p -> SquareEventNotificationSquareChatDelete -> LBS.ByteString
encode_SquareEventNotificationSquareChatDelete oprot record = T.serializeVal oprot $ from_SquareEventNotificationSquareChatDelete record
to_SquareEventNotificationSquareChatDelete :: T.ThriftVal -> SquareEventNotificationSquareChatDelete
to_SquareEventNotificationSquareChatDelete (T.TStruct fields) = SquareEventNotificationSquareChatDelete{
  squareEventNotificationSquareChatDelete_squareChatMid = P.maybe (squareEventNotificationSquareChatDelete_squareChatMid default_SquareEventNotificationSquareChatDelete) (\(_,_val2557) -> (case _val2557 of {T.TString _val2558 -> E.decodeUtf8 _val2558; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotificationSquareChatDelete_squareChatName = P.maybe (squareEventNotificationSquareChatDelete_squareChatName default_SquareEventNotificationSquareChatDelete) (\(_,_val2557) -> (case _val2557 of {T.TString _val2559 -> E.decodeUtf8 _val2559; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotificationSquareChatDelete_profileImageObsHash = P.maybe (squareEventNotificationSquareChatDelete_profileImageObsHash default_SquareEventNotificationSquareChatDelete) (\(_,_val2557) -> (case _val2557 of {T.TString _val2560 -> E.decodeUtf8 _val2560; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotificationSquareChatDelete _ = P.error "not a struct"
read_SquareEventNotificationSquareChatDelete :: T.Protocol p => p -> P.IO SquareEventNotificationSquareChatDelete
read_SquareEventNotificationSquareChatDelete iprot = to_SquareEventNotificationSquareChatDelete <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotificationSquareChatDelete)
decode_SquareEventNotificationSquareChatDelete :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotificationSquareChatDelete
decode_SquareEventNotificationSquareChatDelete iprot bs = to_SquareEventNotificationSquareChatDelete $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotificationSquareChatDelete) bs
typemap_SquareEventNotificationSquareChatDelete :: T.TypeMap
typemap_SquareEventNotificationSquareChatDelete = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareChatName",T.T_STRING)),(3,("profileImageObsHash",T.T_STRING))]
default_SquareEventNotificationSquareChatDelete :: SquareEventNotificationSquareChatDelete
default_SquareEventNotificationSquareChatDelete = SquareEventNotificationSquareChatDelete{
  squareEventNotificationSquareChatDelete_squareChatMid = "",
  squareEventNotificationSquareChatDelete_squareChatName = "",
  squareEventNotificationSquareChatDelete_profileImageObsHash = ""}
data SquareEventNotificationMessage = SquareEventNotificationMessage  { squareEventNotificationMessage_squareChatMid :: LT.Text
  , squareEventNotificationMessage_squareMessage :: SquareMessage
  , squareEventNotificationMessage_senderDisplayName :: LT.Text
  , squareEventNotificationMessage_unreadCount :: I.Int32
  , squareEventNotificationMessage_requiredToFetchChatEvents :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotificationMessage where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotificationMessage_squareChatMid record   `H.hashWithSalt` squareEventNotificationMessage_squareMessage record   `H.hashWithSalt` squareEventNotificationMessage_senderDisplayName record   `H.hashWithSalt` squareEventNotificationMessage_unreadCount record   `H.hashWithSalt` squareEventNotificationMessage_requiredToFetchChatEvents record  
instance QC.Arbitrary SquareEventNotificationMessage where 
  arbitrary = M.liftM SquareEventNotificationMessage (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotificationMessage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotificationMessage{squareEventNotificationMessage_squareChatMid = squareEventNotificationMessage_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotificationMessage{squareEventNotificationMessage_squareChatMid = squareEventNotificationMessage_squareChatMid obj}
    , if obj == default_SquareEventNotificationMessage{squareEventNotificationMessage_squareMessage = squareEventNotificationMessage_squareMessage obj} then P.Nothing else P.Just $ default_SquareEventNotificationMessage{squareEventNotificationMessage_squareMessage = squareEventNotificationMessage_squareMessage obj}
    , if obj == default_SquareEventNotificationMessage{squareEventNotificationMessage_senderDisplayName = squareEventNotificationMessage_senderDisplayName obj} then P.Nothing else P.Just $ default_SquareEventNotificationMessage{squareEventNotificationMessage_senderDisplayName = squareEventNotificationMessage_senderDisplayName obj}
    , if obj == default_SquareEventNotificationMessage{squareEventNotificationMessage_unreadCount = squareEventNotificationMessage_unreadCount obj} then P.Nothing else P.Just $ default_SquareEventNotificationMessage{squareEventNotificationMessage_unreadCount = squareEventNotificationMessage_unreadCount obj}
    , if obj == default_SquareEventNotificationMessage{squareEventNotificationMessage_requiredToFetchChatEvents = squareEventNotificationMessage_requiredToFetchChatEvents obj} then P.Nothing else P.Just $ default_SquareEventNotificationMessage{squareEventNotificationMessage_requiredToFetchChatEvents = squareEventNotificationMessage_requiredToFetchChatEvents obj}
    ]
from_SquareEventNotificationMessage :: SquareEventNotificationMessage -> T.ThriftVal
from_SquareEventNotificationMessage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2563 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2563))) $ squareEventNotificationMessage_squareChatMid record
  , (\_v2563 -> P.Just (2, ("squareMessage",from_SquareMessage _v2563))) $ squareEventNotificationMessage_squareMessage record
  , (\_v2563 -> P.Just (3, ("senderDisplayName",T.TString $ E.encodeUtf8 _v2563))) $ squareEventNotificationMessage_senderDisplayName record
  , (\_v2563 -> P.Just (4, ("unreadCount",T.TI32 _v2563))) $ squareEventNotificationMessage_unreadCount record
  , (\_v2563 -> P.Just (5, ("requiredToFetchChatEvents",T.TBool _v2563))) $ squareEventNotificationMessage_requiredToFetchChatEvents record
  ]
write_SquareEventNotificationMessage :: T.Protocol p => p -> SquareEventNotificationMessage -> P.IO ()
write_SquareEventNotificationMessage oprot record = T.writeVal oprot $ from_SquareEventNotificationMessage record
encode_SquareEventNotificationMessage :: T.StatelessProtocol p => p -> SquareEventNotificationMessage -> LBS.ByteString
encode_SquareEventNotificationMessage oprot record = T.serializeVal oprot $ from_SquareEventNotificationMessage record
to_SquareEventNotificationMessage :: T.ThriftVal -> SquareEventNotificationMessage
to_SquareEventNotificationMessage (T.TStruct fields) = SquareEventNotificationMessage{
  squareEventNotificationMessage_squareChatMid = P.maybe (squareEventNotificationMessage_squareChatMid default_SquareEventNotificationMessage) (\(_,_val2565) -> (case _val2565 of {T.TString _val2566 -> E.decodeUtf8 _val2566; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotificationMessage_squareMessage = P.maybe (squareEventNotificationMessage_squareMessage default_SquareEventNotificationMessage) (\(_,_val2565) -> (case _val2565 of {T.TStruct _val2567 -> (to_SquareMessage (T.TStruct _val2567)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotificationMessage_senderDisplayName = P.maybe (squareEventNotificationMessage_senderDisplayName default_SquareEventNotificationMessage) (\(_,_val2565) -> (case _val2565 of {T.TString _val2568 -> E.decodeUtf8 _val2568; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventNotificationMessage_unreadCount = P.maybe (squareEventNotificationMessage_unreadCount default_SquareEventNotificationMessage) (\(_,_val2565) -> (case _val2565 of {T.TI32 _val2569 -> _val2569; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareEventNotificationMessage_requiredToFetchChatEvents = P.maybe (squareEventNotificationMessage_requiredToFetchChatEvents default_SquareEventNotificationMessage) (\(_,_val2565) -> (case _val2565 of {T.TBool _val2570 -> _val2570; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SquareEventNotificationMessage _ = P.error "not a struct"
read_SquareEventNotificationMessage :: T.Protocol p => p -> P.IO SquareEventNotificationMessage
read_SquareEventNotificationMessage iprot = to_SquareEventNotificationMessage <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotificationMessage)
decode_SquareEventNotificationMessage :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotificationMessage
decode_SquareEventNotificationMessage iprot bs = to_SquareEventNotificationMessage $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotificationMessage) bs
typemap_SquareEventNotificationMessage :: T.TypeMap
typemap_SquareEventNotificationMessage = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMessage",(T.T_STRUCT typemap_SquareMessage))),(3,("senderDisplayName",T.T_STRING)),(4,("unreadCount",T.T_I32)),(5,("requiredToFetchChatEvents",T.T_BOOL))]
default_SquareEventNotificationMessage :: SquareEventNotificationMessage
default_SquareEventNotificationMessage = SquareEventNotificationMessage{
  squareEventNotificationMessage_squareChatMid = "",
  squareEventNotificationMessage_squareMessage = default_SquareMessage,
  squareEventNotificationMessage_senderDisplayName = "",
  squareEventNotificationMessage_unreadCount = 0,
  squareEventNotificationMessage_requiredToFetchChatEvents = P.False}
data SquareEventNotifiedUpdateSquareChatMember = SquareEventNotifiedUpdateSquareChatMember  { squareEventNotifiedUpdateSquareChatMember_squareChatMid :: LT.Text
  , squareEventNotifiedUpdateSquareChatMember_squareMemberMid :: LT.Text
  , squareEventNotifiedUpdateSquareChatMember_squareChatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareChatMember where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatMember_squareChatMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatMember_squareMemberMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareChatMember_squareChatMember record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareChatMember where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareChatMember (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareChatMember = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareChatMid = squareEventNotifiedUpdateSquareChatMember_squareChatMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareChatMid = squareEventNotifiedUpdateSquareChatMember_squareChatMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareMemberMid = squareEventNotifiedUpdateSquareChatMember_squareMemberMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareMemberMid = squareEventNotifiedUpdateSquareChatMember_squareMemberMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareChatMember = squareEventNotifiedUpdateSquareChatMember_squareChatMember obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareChatMember{squareEventNotifiedUpdateSquareChatMember_squareChatMember = squareEventNotifiedUpdateSquareChatMember_squareChatMember obj}
    ]
from_SquareEventNotifiedUpdateSquareChatMember :: SquareEventNotifiedUpdateSquareChatMember -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareChatMember record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2573 -> P.Just (1, ("squareChatMid",T.TString $ E.encodeUtf8 _v2573))) $ squareEventNotifiedUpdateSquareChatMember_squareChatMid record
  , (\_v2573 -> P.Just (2, ("squareMemberMid",T.TString $ E.encodeUtf8 _v2573))) $ squareEventNotifiedUpdateSquareChatMember_squareMemberMid record
  , (\_v2573 -> P.Just (3, ("squareChatMember",from_SquareChatMember _v2573))) $ squareEventNotifiedUpdateSquareChatMember_squareChatMember record
  ]
write_SquareEventNotifiedUpdateSquareChatMember :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareChatMember -> P.IO ()
write_SquareEventNotifiedUpdateSquareChatMember oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareChatMember record
encode_SquareEventNotifiedUpdateSquareChatMember :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareChatMember -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareChatMember oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareChatMember record
to_SquareEventNotifiedUpdateSquareChatMember :: T.ThriftVal -> SquareEventNotifiedUpdateSquareChatMember
to_SquareEventNotifiedUpdateSquareChatMember (T.TStruct fields) = SquareEventNotifiedUpdateSquareChatMember{
  squareEventNotifiedUpdateSquareChatMember_squareChatMid = P.maybe (squareEventNotifiedUpdateSquareChatMember_squareChatMid default_SquareEventNotifiedUpdateSquareChatMember) (\(_,_val2575) -> (case _val2575 of {T.TString _val2576 -> E.decodeUtf8 _val2576; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareChatMember_squareMemberMid = P.maybe (squareEventNotifiedUpdateSquareChatMember_squareMemberMid default_SquareEventNotifiedUpdateSquareChatMember) (\(_,_val2575) -> (case _val2575 of {T.TString _val2577 -> E.decodeUtf8 _val2577; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventNotifiedUpdateSquareChatMember_squareChatMember = P.maybe (squareEventNotifiedUpdateSquareChatMember_squareChatMember default_SquareEventNotifiedUpdateSquareChatMember) (\(_,_val2575) -> (case _val2575 of {T.TStruct _val2578 -> (to_SquareChatMember (T.TStruct _val2578)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareEventNotifiedUpdateSquareChatMember _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareChatMember :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareChatMember
read_SquareEventNotifiedUpdateSquareChatMember iprot = to_SquareEventNotifiedUpdateSquareChatMember <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatMember)
decode_SquareEventNotifiedUpdateSquareChatMember :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareChatMember
decode_SquareEventNotifiedUpdateSquareChatMember iprot bs = to_SquareEventNotifiedUpdateSquareChatMember $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatMember) bs
typemap_SquareEventNotifiedUpdateSquareChatMember :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareChatMember = Map.fromList [(1,("squareChatMid",T.T_STRING)),(2,("squareMemberMid",T.T_STRING)),(3,("squareChatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_SquareEventNotifiedUpdateSquareChatMember :: SquareEventNotifiedUpdateSquareChatMember
default_SquareEventNotifiedUpdateSquareChatMember = SquareEventNotifiedUpdateSquareChatMember{
  squareEventNotifiedUpdateSquareChatMember_squareChatMid = "",
  squareEventNotifiedUpdateSquareChatMember_squareMemberMid = "",
  squareEventNotifiedUpdateSquareChatMember_squareChatMember = default_SquareChatMember}
data SquareEventNotifiedUpdateSquareAuthority = SquareEventNotifiedUpdateSquareAuthority  { squareEventNotifiedUpdateSquareAuthority_squareMid :: LT.Text
  , squareEventNotifiedUpdateSquareAuthority_squareAuthority :: SquareAuthority
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareAuthority where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareAuthority_squareMid record   `H.hashWithSalt` squareEventNotifiedUpdateSquareAuthority_squareAuthority record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareAuthority where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareAuthority (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareAuthority = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareAuthority{squareEventNotifiedUpdateSquareAuthority_squareMid = squareEventNotifiedUpdateSquareAuthority_squareMid obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareAuthority{squareEventNotifiedUpdateSquareAuthority_squareMid = squareEventNotifiedUpdateSquareAuthority_squareMid obj}
    , if obj == default_SquareEventNotifiedUpdateSquareAuthority{squareEventNotifiedUpdateSquareAuthority_squareAuthority = squareEventNotifiedUpdateSquareAuthority_squareAuthority obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareAuthority{squareEventNotifiedUpdateSquareAuthority_squareAuthority = squareEventNotifiedUpdateSquareAuthority_squareAuthority obj}
    ]
from_SquareEventNotifiedUpdateSquareAuthority :: SquareEventNotifiedUpdateSquareAuthority -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareAuthority record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2581 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2581))) $ squareEventNotifiedUpdateSquareAuthority_squareMid record
  , (\_v2581 -> P.Just (2, ("squareAuthority",from_SquareAuthority _v2581))) $ squareEventNotifiedUpdateSquareAuthority_squareAuthority record
  ]
write_SquareEventNotifiedUpdateSquareAuthority :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareAuthority -> P.IO ()
write_SquareEventNotifiedUpdateSquareAuthority oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareAuthority record
encode_SquareEventNotifiedUpdateSquareAuthority :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareAuthority -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareAuthority oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareAuthority record
to_SquareEventNotifiedUpdateSquareAuthority :: T.ThriftVal -> SquareEventNotifiedUpdateSquareAuthority
to_SquareEventNotifiedUpdateSquareAuthority (T.TStruct fields) = SquareEventNotifiedUpdateSquareAuthority{
  squareEventNotifiedUpdateSquareAuthority_squareMid = P.maybe (squareEventNotifiedUpdateSquareAuthority_squareMid default_SquareEventNotifiedUpdateSquareAuthority) (\(_,_val2583) -> (case _val2583 of {T.TString _val2584 -> E.decodeUtf8 _val2584; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventNotifiedUpdateSquareAuthority_squareAuthority = P.maybe (squareEventNotifiedUpdateSquareAuthority_squareAuthority default_SquareEventNotifiedUpdateSquareAuthority) (\(_,_val2583) -> (case _val2583 of {T.TStruct _val2585 -> (to_SquareAuthority (T.TStruct _val2585)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SquareEventNotifiedUpdateSquareAuthority _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareAuthority :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareAuthority
read_SquareEventNotifiedUpdateSquareAuthority iprot = to_SquareEventNotifiedUpdateSquareAuthority <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareAuthority)
decode_SquareEventNotifiedUpdateSquareAuthority :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareAuthority
decode_SquareEventNotifiedUpdateSquareAuthority iprot bs = to_SquareEventNotifiedUpdateSquareAuthority $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareAuthority) bs
typemap_SquareEventNotifiedUpdateSquareAuthority :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareAuthority = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("squareAuthority",(T.T_STRUCT typemap_SquareAuthority)))]
default_SquareEventNotifiedUpdateSquareAuthority :: SquareEventNotifiedUpdateSquareAuthority
default_SquareEventNotifiedUpdateSquareAuthority = SquareEventNotifiedUpdateSquareAuthority{
  squareEventNotifiedUpdateSquareAuthority_squareMid = "",
  squareEventNotifiedUpdateSquareAuthority_squareAuthority = default_SquareAuthority}
data SquareEventNotifiedUpdateSquareFeatureSet = SquareEventNotifiedUpdateSquareFeatureSet  { squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet :: SquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventNotifiedUpdateSquareFeatureSet where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet record  
instance QC.Arbitrary SquareEventNotifiedUpdateSquareFeatureSet where 
  arbitrary = M.liftM SquareEventNotifiedUpdateSquareFeatureSet (QC.arbitrary)
  shrink obj | obj == default_SquareEventNotifiedUpdateSquareFeatureSet = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventNotifiedUpdateSquareFeatureSet{squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet = squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet obj} then P.Nothing else P.Just $ default_SquareEventNotifiedUpdateSquareFeatureSet{squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet = squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet obj}
    ]
from_SquareEventNotifiedUpdateSquareFeatureSet :: SquareEventNotifiedUpdateSquareFeatureSet -> T.ThriftVal
from_SquareEventNotifiedUpdateSquareFeatureSet record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2588 -> P.Just (1, ("squareFeatureSet",from_SquareFeatureSet _v2588))) $ squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet record
  ]
write_SquareEventNotifiedUpdateSquareFeatureSet :: T.Protocol p => p -> SquareEventNotifiedUpdateSquareFeatureSet -> P.IO ()
write_SquareEventNotifiedUpdateSquareFeatureSet oprot record = T.writeVal oprot $ from_SquareEventNotifiedUpdateSquareFeatureSet record
encode_SquareEventNotifiedUpdateSquareFeatureSet :: T.StatelessProtocol p => p -> SquareEventNotifiedUpdateSquareFeatureSet -> LBS.ByteString
encode_SquareEventNotifiedUpdateSquareFeatureSet oprot record = T.serializeVal oprot $ from_SquareEventNotifiedUpdateSquareFeatureSet record
to_SquareEventNotifiedUpdateSquareFeatureSet :: T.ThriftVal -> SquareEventNotifiedUpdateSquareFeatureSet
to_SquareEventNotifiedUpdateSquareFeatureSet (T.TStruct fields) = SquareEventNotifiedUpdateSquareFeatureSet{
  squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet = P.maybe (squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet default_SquareEventNotifiedUpdateSquareFeatureSet) (\(_,_val2590) -> (case _val2590 of {T.TStruct _val2591 -> (to_SquareFeatureSet (T.TStruct _val2591)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SquareEventNotifiedUpdateSquareFeatureSet _ = P.error "not a struct"
read_SquareEventNotifiedUpdateSquareFeatureSet :: T.Protocol p => p -> P.IO SquareEventNotifiedUpdateSquareFeatureSet
read_SquareEventNotifiedUpdateSquareFeatureSet iprot = to_SquareEventNotifiedUpdateSquareFeatureSet <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareFeatureSet)
decode_SquareEventNotifiedUpdateSquareFeatureSet :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventNotifiedUpdateSquareFeatureSet
decode_SquareEventNotifiedUpdateSquareFeatureSet iprot bs = to_SquareEventNotifiedUpdateSquareFeatureSet $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareFeatureSet) bs
typemap_SquareEventNotifiedUpdateSquareFeatureSet :: T.TypeMap
typemap_SquareEventNotifiedUpdateSquareFeatureSet = Map.fromList [(1,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet)))]
default_SquareEventNotifiedUpdateSquareFeatureSet :: SquareEventNotifiedUpdateSquareFeatureSet
default_SquareEventNotifiedUpdateSquareFeatureSet = SquareEventNotifiedUpdateSquareFeatureSet{
  squareEventNotifiedUpdateSquareFeatureSet_squareFeatureSet = default_SquareFeatureSet}
data SquareEventPayload = SquareEventPayload  { squareEventPayload_receiveMessage :: SquareEventReceiveMessage
  , squareEventPayload_sendMessage :: SquareEventSendMessage
  , squareEventPayload_notifiedJoinSquareChat :: SquareEventNotifiedJoinSquareChat
  , squareEventPayload_notifiedInviteIntoSquareChat :: SquareEventNotifiedInviteIntoSquareChat
  , squareEventPayload_notifiedLeaveSquareChat :: SquareEventNotifiedLeaveSquareChat
  , squareEventPayload_notifiedDestroyMessage :: SquareEventNotifiedDestroyMessage
  , squareEventPayload_notifiedMarkAsRead :: SquareEventNotifiedMarkAsRead
  , squareEventPayload_notifiedUpdateSquareMemberProfile :: SquareEventNotifiedUpdateSquareMemberProfile
  , squareEventPayload_notifiedKickoutFromSquare :: SquareEventNotifiedKickoutFromSquare
  , squareEventPayload_notifiedShutdownSquare :: SquareEventNotifiedShutdownSquare
  , squareEventPayload_notifiedDeleteSquareChat :: SquareEventNotifiedDeleteSquareChat
  , squareEventPayload_notifiedUpdateSquareChatProfileName :: SquareEventNotifiedUpdateSquareChatProfileName
  , squareEventPayload_notifiedUpdateSquareChatProfileImage :: SquareEventNotifiedUpdateSquareChatProfileImage
  , squareEventPayload_notifiedUpdateSquareStatus :: SquareEventNotifiedUpdateSquareStatus
  , squareEventPayload_notifiedUpdateSquareChatStatus :: SquareEventNotifiedUpdateSquareChatStatus
  , squareEventPayload_notifiedCreateSquareMember :: SquareEventNotifiedCreateSquareMember
  , squareEventPayload_notifiedCreateSquareChatMember :: SquareEventNotifiedCreateSquareChatMember
  , squareEventPayload_notifiedUpdateSquareMemberRelation :: SquareEventNotifiedUpdateSquareMemberRelation
  , squareEventPayload_notifiedUpdateSquare :: SquareEventNotifiedUpdateSquare
  , squareEventPayload_notifiedUpdateSquareMember :: SquareEventNotifiedUpdateSquareMember
  , squareEventPayload_notifiedUpdateSquareChat :: SquareEventNotifiedUpdateSquareChat
  , squareEventPayload_notificationJoinRequest :: SquareEventNotificationJoinRequest
  , squareEventPayload_notificationJoined :: SquareEventNotificationMemberUpdate
  , squareEventPayload_notificationPromoteCoadmin :: SquareEventNotificationMemberUpdate
  , squareEventPayload_notificationPromoteAdmin :: SquareEventNotificationMemberUpdate
  , squareEventPayload_notificationDemoteMember :: SquareEventNotificationMemberUpdate
  , squareEventPayload_notificationKickedOut :: SquareEventNotificationMemberUpdate
  , squareEventPayload_notificationSquareDelete :: SquareEventNotificationSquareDelete
  , squareEventPayload_notificationSquareChatDelete :: SquareEventNotificationSquareChatDelete
  , squareEventPayload_notificationMessage :: SquareEventNotificationMessage
  , squareEventPayload_notifiedUpdateSquareChatMember :: SquareEventNotifiedUpdateSquareChatMember
  , squareEventPayload_notifiedUpdateSquareAuthority :: SquareEventNotifiedUpdateSquareAuthority
  , squareEventPayload_notifiedUpdateSquareFeatureSet :: SquareEventNotifiedUpdateSquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEventPayload where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEventPayload_receiveMessage record   `H.hashWithSalt` squareEventPayload_sendMessage record   `H.hashWithSalt` squareEventPayload_notifiedJoinSquareChat record   `H.hashWithSalt` squareEventPayload_notifiedInviteIntoSquareChat record   `H.hashWithSalt` squareEventPayload_notifiedLeaveSquareChat record   `H.hashWithSalt` squareEventPayload_notifiedDestroyMessage record   `H.hashWithSalt` squareEventPayload_notifiedMarkAsRead record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareMemberProfile record   `H.hashWithSalt` squareEventPayload_notifiedKickoutFromSquare record   `H.hashWithSalt` squareEventPayload_notifiedShutdownSquare record   `H.hashWithSalt` squareEventPayload_notifiedDeleteSquareChat record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareChatProfileName record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareChatProfileImage record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareStatus record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareChatStatus record   `H.hashWithSalt` squareEventPayload_notifiedCreateSquareMember record   `H.hashWithSalt` squareEventPayload_notifiedCreateSquareChatMember record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareMemberRelation record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquare record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareMember record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareChat record   `H.hashWithSalt` squareEventPayload_notificationJoinRequest record   `H.hashWithSalt` squareEventPayload_notificationJoined record   `H.hashWithSalt` squareEventPayload_notificationPromoteCoadmin record   `H.hashWithSalt` squareEventPayload_notificationPromoteAdmin record   `H.hashWithSalt` squareEventPayload_notificationDemoteMember record   `H.hashWithSalt` squareEventPayload_notificationKickedOut record   `H.hashWithSalt` squareEventPayload_notificationSquareDelete record   `H.hashWithSalt` squareEventPayload_notificationSquareChatDelete record   `H.hashWithSalt` squareEventPayload_notificationMessage record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareChatMember record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareAuthority record   `H.hashWithSalt` squareEventPayload_notifiedUpdateSquareFeatureSet record  
instance QC.Arbitrary SquareEventPayload where 
  arbitrary = M.liftM SquareEventPayload (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEventPayload = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEventPayload{squareEventPayload_receiveMessage = squareEventPayload_receiveMessage obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_receiveMessage = squareEventPayload_receiveMessage obj}
    , if obj == default_SquareEventPayload{squareEventPayload_sendMessage = squareEventPayload_sendMessage obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_sendMessage = squareEventPayload_sendMessage obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedJoinSquareChat = squareEventPayload_notifiedJoinSquareChat obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedJoinSquareChat = squareEventPayload_notifiedJoinSquareChat obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedInviteIntoSquareChat = squareEventPayload_notifiedInviteIntoSquareChat obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedInviteIntoSquareChat = squareEventPayload_notifiedInviteIntoSquareChat obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedLeaveSquareChat = squareEventPayload_notifiedLeaveSquareChat obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedLeaveSquareChat = squareEventPayload_notifiedLeaveSquareChat obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedDestroyMessage = squareEventPayload_notifiedDestroyMessage obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedDestroyMessage = squareEventPayload_notifiedDestroyMessage obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedMarkAsRead = squareEventPayload_notifiedMarkAsRead obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedMarkAsRead = squareEventPayload_notifiedMarkAsRead obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMemberProfile = squareEventPayload_notifiedUpdateSquareMemberProfile obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMemberProfile = squareEventPayload_notifiedUpdateSquareMemberProfile obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedKickoutFromSquare = squareEventPayload_notifiedKickoutFromSquare obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedKickoutFromSquare = squareEventPayload_notifiedKickoutFromSquare obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedShutdownSquare = squareEventPayload_notifiedShutdownSquare obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedShutdownSquare = squareEventPayload_notifiedShutdownSquare obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedDeleteSquareChat = squareEventPayload_notifiedDeleteSquareChat obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedDeleteSquareChat = squareEventPayload_notifiedDeleteSquareChat obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatProfileName = squareEventPayload_notifiedUpdateSquareChatProfileName obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatProfileName = squareEventPayload_notifiedUpdateSquareChatProfileName obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatProfileImage = squareEventPayload_notifiedUpdateSquareChatProfileImage obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatProfileImage = squareEventPayload_notifiedUpdateSquareChatProfileImage obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareStatus = squareEventPayload_notifiedUpdateSquareStatus obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareStatus = squareEventPayload_notifiedUpdateSquareStatus obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatStatus = squareEventPayload_notifiedUpdateSquareChatStatus obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatStatus = squareEventPayload_notifiedUpdateSquareChatStatus obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedCreateSquareMember = squareEventPayload_notifiedCreateSquareMember obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedCreateSquareMember = squareEventPayload_notifiedCreateSquareMember obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedCreateSquareChatMember = squareEventPayload_notifiedCreateSquareChatMember obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedCreateSquareChatMember = squareEventPayload_notifiedCreateSquareChatMember obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMemberRelation = squareEventPayload_notifiedUpdateSquareMemberRelation obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMemberRelation = squareEventPayload_notifiedUpdateSquareMemberRelation obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquare = squareEventPayload_notifiedUpdateSquare obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquare = squareEventPayload_notifiedUpdateSquare obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMember = squareEventPayload_notifiedUpdateSquareMember obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareMember = squareEventPayload_notifiedUpdateSquareMember obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChat = squareEventPayload_notifiedUpdateSquareChat obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChat = squareEventPayload_notifiedUpdateSquareChat obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationJoinRequest = squareEventPayload_notificationJoinRequest obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationJoinRequest = squareEventPayload_notificationJoinRequest obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationJoined = squareEventPayload_notificationJoined obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationJoined = squareEventPayload_notificationJoined obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationPromoteCoadmin = squareEventPayload_notificationPromoteCoadmin obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationPromoteCoadmin = squareEventPayload_notificationPromoteCoadmin obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationPromoteAdmin = squareEventPayload_notificationPromoteAdmin obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationPromoteAdmin = squareEventPayload_notificationPromoteAdmin obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationDemoteMember = squareEventPayload_notificationDemoteMember obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationDemoteMember = squareEventPayload_notificationDemoteMember obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationKickedOut = squareEventPayload_notificationKickedOut obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationKickedOut = squareEventPayload_notificationKickedOut obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationSquareDelete = squareEventPayload_notificationSquareDelete obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationSquareDelete = squareEventPayload_notificationSquareDelete obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationSquareChatDelete = squareEventPayload_notificationSquareChatDelete obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationSquareChatDelete = squareEventPayload_notificationSquareChatDelete obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notificationMessage = squareEventPayload_notificationMessage obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notificationMessage = squareEventPayload_notificationMessage obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatMember = squareEventPayload_notifiedUpdateSquareChatMember obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareChatMember = squareEventPayload_notifiedUpdateSquareChatMember obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareAuthority = squareEventPayload_notifiedUpdateSquareAuthority obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareAuthority = squareEventPayload_notifiedUpdateSquareAuthority obj}
    , if obj == default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareFeatureSet = squareEventPayload_notifiedUpdateSquareFeatureSet obj} then P.Nothing else P.Just $ default_SquareEventPayload{squareEventPayload_notifiedUpdateSquareFeatureSet = squareEventPayload_notifiedUpdateSquareFeatureSet obj}
    ]
from_SquareEventPayload :: SquareEventPayload -> T.ThriftVal
from_SquareEventPayload record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2594 -> P.Just (1, ("receiveMessage",from_SquareEventReceiveMessage _v2594))) $ squareEventPayload_receiveMessage record
  , (\_v2594 -> P.Just (2, ("sendMessage",from_SquareEventSendMessage _v2594))) $ squareEventPayload_sendMessage record
  , (\_v2594 -> P.Just (3, ("notifiedJoinSquareChat",from_SquareEventNotifiedJoinSquareChat _v2594))) $ squareEventPayload_notifiedJoinSquareChat record
  , (\_v2594 -> P.Just (4, ("notifiedInviteIntoSquareChat",from_SquareEventNotifiedInviteIntoSquareChat _v2594))) $ squareEventPayload_notifiedInviteIntoSquareChat record
  , (\_v2594 -> P.Just (5, ("notifiedLeaveSquareChat",from_SquareEventNotifiedLeaveSquareChat _v2594))) $ squareEventPayload_notifiedLeaveSquareChat record
  , (\_v2594 -> P.Just (6, ("notifiedDestroyMessage",from_SquareEventNotifiedDestroyMessage _v2594))) $ squareEventPayload_notifiedDestroyMessage record
  , (\_v2594 -> P.Just (7, ("notifiedMarkAsRead",from_SquareEventNotifiedMarkAsRead _v2594))) $ squareEventPayload_notifiedMarkAsRead record
  , (\_v2594 -> P.Just (8, ("notifiedUpdateSquareMemberProfile",from_SquareEventNotifiedUpdateSquareMemberProfile _v2594))) $ squareEventPayload_notifiedUpdateSquareMemberProfile record
  , (\_v2594 -> P.Just (9, ("notifiedUpdateSquare",from_SquareEventNotifiedUpdateSquare _v2594))) $ squareEventPayload_notifiedUpdateSquare record
  , (\_v2594 -> P.Just (10, ("notifiedUpdateSquareMember",from_SquareEventNotifiedUpdateSquareMember _v2594))) $ squareEventPayload_notifiedUpdateSquareMember record
  , (\_v2594 -> P.Just (11, ("notifiedUpdateSquareChat",from_SquareEventNotifiedUpdateSquareChat _v2594))) $ squareEventPayload_notifiedUpdateSquareChat record
  , (\_v2594 -> P.Just (12, ("notifiedUpdateSquareChatMember",from_SquareEventNotifiedUpdateSquareChatMember _v2594))) $ squareEventPayload_notifiedUpdateSquareChatMember record
  , (\_v2594 -> P.Just (13, ("notifiedUpdateSquareAuthority",from_SquareEventNotifiedUpdateSquareAuthority _v2594))) $ squareEventPayload_notifiedUpdateSquareAuthority record
  , (\_v2594 -> P.Just (14, ("notifiedUpdateSquareStatus",from_SquareEventNotifiedUpdateSquareStatus _v2594))) $ squareEventPayload_notifiedUpdateSquareStatus record
  , (\_v2594 -> P.Just (15, ("notifiedUpdateSquareChatStatus",from_SquareEventNotifiedUpdateSquareChatStatus _v2594))) $ squareEventPayload_notifiedUpdateSquareChatStatus record
  , (\_v2594 -> P.Just (16, ("notifiedCreateSquareMember",from_SquareEventNotifiedCreateSquareMember _v2594))) $ squareEventPayload_notifiedCreateSquareMember record
  , (\_v2594 -> P.Just (17, ("notifiedCreateSquareChatMember",from_SquareEventNotifiedCreateSquareChatMember _v2594))) $ squareEventPayload_notifiedCreateSquareChatMember record
  , (\_v2594 -> P.Just (18, ("notifiedUpdateSquareMemberRelation",from_SquareEventNotifiedUpdateSquareMemberRelation _v2594))) $ squareEventPayload_notifiedUpdateSquareMemberRelation record
  , (\_v2594 -> P.Just (19, ("notifiedShutdownSquare",from_SquareEventNotifiedShutdownSquare _v2594))) $ squareEventPayload_notifiedShutdownSquare record
  , (\_v2594 -> P.Just (20, ("notifiedKickoutFromSquare",from_SquareEventNotifiedKickoutFromSquare _v2594))) $ squareEventPayload_notifiedKickoutFromSquare record
  , (\_v2594 -> P.Just (21, ("notifiedDeleteSquareChat",from_SquareEventNotifiedDeleteSquareChat _v2594))) $ squareEventPayload_notifiedDeleteSquareChat record
  , (\_v2594 -> P.Just (22, ("notificationJoinRequest",from_SquareEventNotificationJoinRequest _v2594))) $ squareEventPayload_notificationJoinRequest record
  , (\_v2594 -> P.Just (23, ("notificationJoined",from_SquareEventNotificationMemberUpdate _v2594))) $ squareEventPayload_notificationJoined record
  , (\_v2594 -> P.Just (24, ("notificationPromoteCoadmin",from_SquareEventNotificationMemberUpdate _v2594))) $ squareEventPayload_notificationPromoteCoadmin record
  , (\_v2594 -> P.Just (25, ("notificationPromoteAdmin",from_SquareEventNotificationMemberUpdate _v2594))) $ squareEventPayload_notificationPromoteAdmin record
  , (\_v2594 -> P.Just (26, ("notificationDemoteMember",from_SquareEventNotificationMemberUpdate _v2594))) $ squareEventPayload_notificationDemoteMember record
  , (\_v2594 -> P.Just (27, ("notificationKickedOut",from_SquareEventNotificationMemberUpdate _v2594))) $ squareEventPayload_notificationKickedOut record
  , (\_v2594 -> P.Just (28, ("notificationSquareDelete",from_SquareEventNotificationSquareDelete _v2594))) $ squareEventPayload_notificationSquareDelete record
  , (\_v2594 -> P.Just (29, ("notificationSquareChatDelete",from_SquareEventNotificationSquareChatDelete _v2594))) $ squareEventPayload_notificationSquareChatDelete record
  , (\_v2594 -> P.Just (30, ("notificationMessage",from_SquareEventNotificationMessage _v2594))) $ squareEventPayload_notificationMessage record
  , (\_v2594 -> P.Just (31, ("notifiedUpdateSquareChatProfileName",from_SquareEventNotifiedUpdateSquareChatProfileName _v2594))) $ squareEventPayload_notifiedUpdateSquareChatProfileName record
  , (\_v2594 -> P.Just (32, ("notifiedUpdateSquareChatProfileImage",from_SquareEventNotifiedUpdateSquareChatProfileImage _v2594))) $ squareEventPayload_notifiedUpdateSquareChatProfileImage record
  , (\_v2594 -> P.Just (33, ("notifiedUpdateSquareFeatureSet",from_SquareEventNotifiedUpdateSquareFeatureSet _v2594))) $ squareEventPayload_notifiedUpdateSquareFeatureSet record
  ]
write_SquareEventPayload :: T.Protocol p => p -> SquareEventPayload -> P.IO ()
write_SquareEventPayload oprot record = T.writeVal oprot $ from_SquareEventPayload record
encode_SquareEventPayload :: T.StatelessProtocol p => p -> SquareEventPayload -> LBS.ByteString
encode_SquareEventPayload oprot record = T.serializeVal oprot $ from_SquareEventPayload record
to_SquareEventPayload :: T.ThriftVal -> SquareEventPayload
to_SquareEventPayload (T.TStruct fields) = SquareEventPayload{
  squareEventPayload_receiveMessage = P.maybe (squareEventPayload_receiveMessage default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2597 -> (to_SquareEventReceiveMessage (T.TStruct _val2597)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareEventPayload_sendMessage = P.maybe (squareEventPayload_sendMessage default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2598 -> (to_SquareEventSendMessage (T.TStruct _val2598)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEventPayload_notifiedJoinSquareChat = P.maybe (squareEventPayload_notifiedJoinSquareChat default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2599 -> (to_SquareEventNotifiedJoinSquareChat (T.TStruct _val2599)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEventPayload_notifiedInviteIntoSquareChat = P.maybe (squareEventPayload_notifiedInviteIntoSquareChat default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2600 -> (to_SquareEventNotifiedInviteIntoSquareChat (T.TStruct _val2600)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareEventPayload_notifiedLeaveSquareChat = P.maybe (squareEventPayload_notifiedLeaveSquareChat default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2601 -> (to_SquareEventNotifiedLeaveSquareChat (T.TStruct _val2601)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareEventPayload_notifiedDestroyMessage = P.maybe (squareEventPayload_notifiedDestroyMessage default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2602 -> (to_SquareEventNotifiedDestroyMessage (T.TStruct _val2602)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  squareEventPayload_notifiedMarkAsRead = P.maybe (squareEventPayload_notifiedMarkAsRead default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2603 -> (to_SquareEventNotifiedMarkAsRead (T.TStruct _val2603)); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  squareEventPayload_notifiedUpdateSquareMemberProfile = P.maybe (squareEventPayload_notifiedUpdateSquareMemberProfile default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2604 -> (to_SquareEventNotifiedUpdateSquareMemberProfile (T.TStruct _val2604)); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  squareEventPayload_notifiedKickoutFromSquare = P.maybe (squareEventPayload_notifiedKickoutFromSquare default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2605 -> (to_SquareEventNotifiedKickoutFromSquare (T.TStruct _val2605)); _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  squareEventPayload_notifiedShutdownSquare = P.maybe (squareEventPayload_notifiedShutdownSquare default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2606 -> (to_SquareEventNotifiedShutdownSquare (T.TStruct _val2606)); _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  squareEventPayload_notifiedDeleteSquareChat = P.maybe (squareEventPayload_notifiedDeleteSquareChat default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2607 -> (to_SquareEventNotifiedDeleteSquareChat (T.TStruct _val2607)); _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  squareEventPayload_notifiedUpdateSquareChatProfileName = P.maybe (squareEventPayload_notifiedUpdateSquareChatProfileName default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2608 -> (to_SquareEventNotifiedUpdateSquareChatProfileName (T.TStruct _val2608)); _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  squareEventPayload_notifiedUpdateSquareChatProfileImage = P.maybe (squareEventPayload_notifiedUpdateSquareChatProfileImage default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2609 -> (to_SquareEventNotifiedUpdateSquareChatProfileImage (T.TStruct _val2609)); _ -> P.error "wrong type"})) (Map.lookup (32) fields),
  squareEventPayload_notifiedUpdateSquareStatus = P.maybe (squareEventPayload_notifiedUpdateSquareStatus default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2610 -> (to_SquareEventNotifiedUpdateSquareStatus (T.TStruct _val2610)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  squareEventPayload_notifiedUpdateSquareChatStatus = P.maybe (squareEventPayload_notifiedUpdateSquareChatStatus default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2611 -> (to_SquareEventNotifiedUpdateSquareChatStatus (T.TStruct _val2611)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  squareEventPayload_notifiedCreateSquareMember = P.maybe (squareEventPayload_notifiedCreateSquareMember default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2612 -> (to_SquareEventNotifiedCreateSquareMember (T.TStruct _val2612)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  squareEventPayload_notifiedCreateSquareChatMember = P.maybe (squareEventPayload_notifiedCreateSquareChatMember default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2613 -> (to_SquareEventNotifiedCreateSquareChatMember (T.TStruct _val2613)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  squareEventPayload_notifiedUpdateSquareMemberRelation = P.maybe (squareEventPayload_notifiedUpdateSquareMemberRelation default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2614 -> (to_SquareEventNotifiedUpdateSquareMemberRelation (T.TStruct _val2614)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  squareEventPayload_notifiedUpdateSquare = P.maybe (squareEventPayload_notifiedUpdateSquare default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2615 -> (to_SquareEventNotifiedUpdateSquare (T.TStruct _val2615)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  squareEventPayload_notifiedUpdateSquareMember = P.maybe (squareEventPayload_notifiedUpdateSquareMember default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2616 -> (to_SquareEventNotifiedUpdateSquareMember (T.TStruct _val2616)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  squareEventPayload_notifiedUpdateSquareChat = P.maybe (squareEventPayload_notifiedUpdateSquareChat default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2617 -> (to_SquareEventNotifiedUpdateSquareChat (T.TStruct _val2617)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  squareEventPayload_notificationJoinRequest = P.maybe (squareEventPayload_notificationJoinRequest default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2618 -> (to_SquareEventNotificationJoinRequest (T.TStruct _val2618)); _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  squareEventPayload_notificationJoined = P.maybe (squareEventPayload_notificationJoined default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2619 -> (to_SquareEventNotificationMemberUpdate (T.TStruct _val2619)); _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  squareEventPayload_notificationPromoteCoadmin = P.maybe (squareEventPayload_notificationPromoteCoadmin default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2620 -> (to_SquareEventNotificationMemberUpdate (T.TStruct _val2620)); _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  squareEventPayload_notificationPromoteAdmin = P.maybe (squareEventPayload_notificationPromoteAdmin default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2621 -> (to_SquareEventNotificationMemberUpdate (T.TStruct _val2621)); _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  squareEventPayload_notificationDemoteMember = P.maybe (squareEventPayload_notificationDemoteMember default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2622 -> (to_SquareEventNotificationMemberUpdate (T.TStruct _val2622)); _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  squareEventPayload_notificationKickedOut = P.maybe (squareEventPayload_notificationKickedOut default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2623 -> (to_SquareEventNotificationMemberUpdate (T.TStruct _val2623)); _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  squareEventPayload_notificationSquareDelete = P.maybe (squareEventPayload_notificationSquareDelete default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2624 -> (to_SquareEventNotificationSquareDelete (T.TStruct _val2624)); _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  squareEventPayload_notificationSquareChatDelete = P.maybe (squareEventPayload_notificationSquareChatDelete default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2625 -> (to_SquareEventNotificationSquareChatDelete (T.TStruct _val2625)); _ -> P.error "wrong type"})) (Map.lookup (29) fields),
  squareEventPayload_notificationMessage = P.maybe (squareEventPayload_notificationMessage default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2626 -> (to_SquareEventNotificationMessage (T.TStruct _val2626)); _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  squareEventPayload_notifiedUpdateSquareChatMember = P.maybe (squareEventPayload_notifiedUpdateSquareChatMember default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2627 -> (to_SquareEventNotifiedUpdateSquareChatMember (T.TStruct _val2627)); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  squareEventPayload_notifiedUpdateSquareAuthority = P.maybe (squareEventPayload_notifiedUpdateSquareAuthority default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2628 -> (to_SquareEventNotifiedUpdateSquareAuthority (T.TStruct _val2628)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  squareEventPayload_notifiedUpdateSquareFeatureSet = P.maybe (squareEventPayload_notifiedUpdateSquareFeatureSet default_SquareEventPayload) (\(_,_val2596) -> (case _val2596 of {T.TStruct _val2629 -> (to_SquareEventNotifiedUpdateSquareFeatureSet (T.TStruct _val2629)); _ -> P.error "wrong type"})) (Map.lookup (33) fields)
  }
to_SquareEventPayload _ = P.error "not a struct"
read_SquareEventPayload :: T.Protocol p => p -> P.IO SquareEventPayload
read_SquareEventPayload iprot = to_SquareEventPayload <$> T.readVal iprot (T.T_STRUCT typemap_SquareEventPayload)
decode_SquareEventPayload :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEventPayload
decode_SquareEventPayload iprot bs = to_SquareEventPayload $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEventPayload) bs
typemap_SquareEventPayload :: T.TypeMap
typemap_SquareEventPayload = Map.fromList [(1,("receiveMessage",(T.T_STRUCT typemap_SquareEventReceiveMessage))),(2,("sendMessage",(T.T_STRUCT typemap_SquareEventSendMessage))),(3,("notifiedJoinSquareChat",(T.T_STRUCT typemap_SquareEventNotifiedJoinSquareChat))),(4,("notifiedInviteIntoSquareChat",(T.T_STRUCT typemap_SquareEventNotifiedInviteIntoSquareChat))),(5,("notifiedLeaveSquareChat",(T.T_STRUCT typemap_SquareEventNotifiedLeaveSquareChat))),(6,("notifiedDestroyMessage",(T.T_STRUCT typemap_SquareEventNotifiedDestroyMessage))),(7,("notifiedMarkAsRead",(T.T_STRUCT typemap_SquareEventNotifiedMarkAsRead))),(8,("notifiedUpdateSquareMemberProfile",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberProfile))),(9,("notifiedUpdateSquare",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquare))),(10,("notifiedUpdateSquareMember",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMember))),(11,("notifiedUpdateSquareChat",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChat))),(12,("notifiedUpdateSquareChatMember",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatMember))),(13,("notifiedUpdateSquareAuthority",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareAuthority))),(14,("notifiedUpdateSquareStatus",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareStatus))),(15,("notifiedUpdateSquareChatStatus",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatStatus))),(16,("notifiedCreateSquareMember",(T.T_STRUCT typemap_SquareEventNotifiedCreateSquareMember))),(17,("notifiedCreateSquareChatMember",(T.T_STRUCT typemap_SquareEventNotifiedCreateSquareChatMember))),(18,("notifiedUpdateSquareMemberRelation",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareMemberRelation))),(19,("notifiedShutdownSquare",(T.T_STRUCT typemap_SquareEventNotifiedShutdownSquare))),(20,("notifiedKickoutFromSquare",(T.T_STRUCT typemap_SquareEventNotifiedKickoutFromSquare))),(21,("notifiedDeleteSquareChat",(T.T_STRUCT typemap_SquareEventNotifiedDeleteSquareChat))),(22,("notificationJoinRequest",(T.T_STRUCT typemap_SquareEventNotificationJoinRequest))),(23,("notificationJoined",(T.T_STRUCT typemap_SquareEventNotificationMemberUpdate))),(24,("notificationPromoteCoadmin",(T.T_STRUCT typemap_SquareEventNotificationMemberUpdate))),(25,("notificationPromoteAdmin",(T.T_STRUCT typemap_SquareEventNotificationMemberUpdate))),(26,("notificationDemoteMember",(T.T_STRUCT typemap_SquareEventNotificationMemberUpdate))),(27,("notificationKickedOut",(T.T_STRUCT typemap_SquareEventNotificationMemberUpdate))),(28,("notificationSquareDelete",(T.T_STRUCT typemap_SquareEventNotificationSquareDelete))),(29,("notificationSquareChatDelete",(T.T_STRUCT typemap_SquareEventNotificationSquareChatDelete))),(30,("notificationMessage",(T.T_STRUCT typemap_SquareEventNotificationMessage))),(31,("notifiedUpdateSquareChatProfileName",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileName))),(32,("notifiedUpdateSquareChatProfileImage",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareChatProfileImage))),(33,("notifiedUpdateSquareFeatureSet",(T.T_STRUCT typemap_SquareEventNotifiedUpdateSquareFeatureSet)))]
default_SquareEventPayload :: SquareEventPayload
default_SquareEventPayload = SquareEventPayload{
  squareEventPayload_receiveMessage = default_SquareEventReceiveMessage,
  squareEventPayload_sendMessage = default_SquareEventSendMessage,
  squareEventPayload_notifiedJoinSquareChat = default_SquareEventNotifiedJoinSquareChat,
  squareEventPayload_notifiedInviteIntoSquareChat = default_SquareEventNotifiedInviteIntoSquareChat,
  squareEventPayload_notifiedLeaveSquareChat = default_SquareEventNotifiedLeaveSquareChat,
  squareEventPayload_notifiedDestroyMessage = default_SquareEventNotifiedDestroyMessage,
  squareEventPayload_notifiedMarkAsRead = default_SquareEventNotifiedMarkAsRead,
  squareEventPayload_notifiedUpdateSquareMemberProfile = default_SquareEventNotifiedUpdateSquareMemberProfile,
  squareEventPayload_notifiedUpdateSquare = default_SquareEventNotifiedUpdateSquare,
  squareEventPayload_notifiedUpdateSquareMember = default_SquareEventNotifiedUpdateSquareMember,
  squareEventPayload_notifiedUpdateSquareChat = default_SquareEventNotifiedUpdateSquareChat,
  squareEventPayload_notifiedUpdateSquareChatMember = default_SquareEventNotifiedUpdateSquareChatMember,
  squareEventPayload_notifiedUpdateSquareAuthority = default_SquareEventNotifiedUpdateSquareAuthority,
  squareEventPayload_notifiedUpdateSquareStatus = default_SquareEventNotifiedUpdateSquareStatus,
  squareEventPayload_notifiedUpdateSquareChatStatus = default_SquareEventNotifiedUpdateSquareChatStatus,
  squareEventPayload_notifiedCreateSquareMember = default_SquareEventNotifiedCreateSquareMember,
  squareEventPayload_notifiedCreateSquareChatMember = default_SquareEventNotifiedCreateSquareChatMember,
  squareEventPayload_notifiedUpdateSquareMemberRelation = default_SquareEventNotifiedUpdateSquareMemberRelation,
  squareEventPayload_notifiedShutdownSquare = default_SquareEventNotifiedShutdownSquare,
  squareEventPayload_notifiedKickoutFromSquare = default_SquareEventNotifiedKickoutFromSquare,
  squareEventPayload_notifiedDeleteSquareChat = default_SquareEventNotifiedDeleteSquareChat,
  squareEventPayload_notificationJoinRequest = default_SquareEventNotificationJoinRequest,
  squareEventPayload_notificationJoined = default_SquareEventNotificationMemberUpdate,
  squareEventPayload_notificationPromoteCoadmin = default_SquareEventNotificationMemberUpdate,
  squareEventPayload_notificationPromoteAdmin = default_SquareEventNotificationMemberUpdate,
  squareEventPayload_notificationDemoteMember = default_SquareEventNotificationMemberUpdate,
  squareEventPayload_notificationKickedOut = default_SquareEventNotificationMemberUpdate,
  squareEventPayload_notificationSquareDelete = default_SquareEventNotificationSquareDelete,
  squareEventPayload_notificationSquareChatDelete = default_SquareEventNotificationSquareChatDelete,
  squareEventPayload_notificationMessage = default_SquareEventNotificationMessage,
  squareEventPayload_notifiedUpdateSquareChatProfileName = default_SquareEventNotifiedUpdateSquareChatProfileName,
  squareEventPayload_notifiedUpdateSquareChatProfileImage = default_SquareEventNotifiedUpdateSquareChatProfileImage,
  squareEventPayload_notifiedUpdateSquareFeatureSet = default_SquareEventNotifiedUpdateSquareFeatureSet}
data SquareEvent = SquareEvent  { squareEvent_createdTime :: I.Int64
  , squareEvent_type :: SquareEventType
  , squareEvent_payload :: SquareEventPayload
  , squareEvent_syncToken :: LT.Text
  , squareEvent_eventStatus :: SquareEventStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SquareEvent where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareEvent_createdTime record   `H.hashWithSalt` squareEvent_type record   `H.hashWithSalt` squareEvent_payload record   `H.hashWithSalt` squareEvent_syncToken record   `H.hashWithSalt` squareEvent_eventStatus record  
instance QC.Arbitrary SquareEvent where 
  arbitrary = M.liftM SquareEvent (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareEvent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareEvent{squareEvent_createdTime = squareEvent_createdTime obj} then P.Nothing else P.Just $ default_SquareEvent{squareEvent_createdTime = squareEvent_createdTime obj}
    , if obj == default_SquareEvent{squareEvent_type = squareEvent_type obj} then P.Nothing else P.Just $ default_SquareEvent{squareEvent_type = squareEvent_type obj}
    , if obj == default_SquareEvent{squareEvent_payload = squareEvent_payload obj} then P.Nothing else P.Just $ default_SquareEvent{squareEvent_payload = squareEvent_payload obj}
    , if obj == default_SquareEvent{squareEvent_syncToken = squareEvent_syncToken obj} then P.Nothing else P.Just $ default_SquareEvent{squareEvent_syncToken = squareEvent_syncToken obj}
    , if obj == default_SquareEvent{squareEvent_eventStatus = squareEvent_eventStatus obj} then P.Nothing else P.Just $ default_SquareEvent{squareEvent_eventStatus = squareEvent_eventStatus obj}
    ]
from_SquareEvent :: SquareEvent -> T.ThriftVal
from_SquareEvent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2632 -> P.Just (2, ("createdTime",T.TI64 _v2632))) $ squareEvent_createdTime record
  , (\_v2632 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v2632))) $ squareEvent_type record
  , (\_v2632 -> P.Just (4, ("payload",from_SquareEventPayload _v2632))) $ squareEvent_payload record
  , (\_v2632 -> P.Just (5, ("syncToken",T.TString $ E.encodeUtf8 _v2632))) $ squareEvent_syncToken record
  , (\_v2632 -> P.Just (6, ("eventStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v2632))) $ squareEvent_eventStatus record
  ]
write_SquareEvent :: T.Protocol p => p -> SquareEvent -> P.IO ()
write_SquareEvent oprot record = T.writeVal oprot $ from_SquareEvent record
encode_SquareEvent :: T.StatelessProtocol p => p -> SquareEvent -> LBS.ByteString
encode_SquareEvent oprot record = T.serializeVal oprot $ from_SquareEvent record
to_SquareEvent :: T.ThriftVal -> SquareEvent
to_SquareEvent (T.TStruct fields) = SquareEvent{
  squareEvent_createdTime = P.maybe (squareEvent_createdTime default_SquareEvent) (\(_,_val2634) -> (case _val2634 of {T.TI64 _val2635 -> _val2635; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareEvent_type = P.maybe (squareEvent_type default_SquareEvent) (\(_,_val2634) -> (case _val2634 of {T.TI32 _val2636 -> P.toEnum $ P.fromIntegral _val2636; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  squareEvent_payload = P.maybe (squareEvent_payload default_SquareEvent) (\(_,_val2634) -> (case _val2634 of {T.TStruct _val2637 -> (to_SquareEventPayload (T.TStruct _val2637)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  squareEvent_syncToken = P.maybe (squareEvent_syncToken default_SquareEvent) (\(_,_val2634) -> (case _val2634 of {T.TString _val2638 -> E.decodeUtf8 _val2638; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  squareEvent_eventStatus = P.maybe (squareEvent_eventStatus default_SquareEvent) (\(_,_val2634) -> (case _val2634 of {T.TI32 _val2639 -> P.toEnum $ P.fromIntegral _val2639; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_SquareEvent _ = P.error "not a struct"
read_SquareEvent :: T.Protocol p => p -> P.IO SquareEvent
read_SquareEvent iprot = to_SquareEvent <$> T.readVal iprot (T.T_STRUCT typemap_SquareEvent)
decode_SquareEvent :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareEvent
decode_SquareEvent iprot bs = to_SquareEvent $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareEvent) bs
typemap_SquareEvent :: T.TypeMap
typemap_SquareEvent = Map.fromList [(2,("createdTime",T.T_I64)),(3,("type",T.T_I32)),(4,("payload",(T.T_STRUCT typemap_SquareEventPayload))),(5,("syncToken",T.T_STRING)),(6,("eventStatus",T.T_I32))]
default_SquareEvent :: SquareEvent
default_SquareEvent = SquareEvent{
  squareEvent_createdTime = 0,
  squareEvent_type = (P.toEnum 0),
  squareEvent_payload = default_SquareEventPayload,
  squareEvent_syncToken = "",
  squareEvent_eventStatus = (P.toEnum 0)}
data FetchMyEventsRequest = FetchMyEventsRequest  { fetchMyEventsRequest_subscriptionId :: I.Int64
  , fetchMyEventsRequest_syncToken :: LT.Text
  , fetchMyEventsRequest_limit :: I.Int32
  , fetchMyEventsRequest_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMyEventsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMyEventsRequest_subscriptionId record   `H.hashWithSalt` fetchMyEventsRequest_syncToken record   `H.hashWithSalt` fetchMyEventsRequest_limit record   `H.hashWithSalt` fetchMyEventsRequest_continuationToken record  
instance QC.Arbitrary FetchMyEventsRequest where 
  arbitrary = M.liftM FetchMyEventsRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchMyEventsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMyEventsRequest{fetchMyEventsRequest_subscriptionId = fetchMyEventsRequest_subscriptionId obj} then P.Nothing else P.Just $ default_FetchMyEventsRequest{fetchMyEventsRequest_subscriptionId = fetchMyEventsRequest_subscriptionId obj}
    , if obj == default_FetchMyEventsRequest{fetchMyEventsRequest_syncToken = fetchMyEventsRequest_syncToken obj} then P.Nothing else P.Just $ default_FetchMyEventsRequest{fetchMyEventsRequest_syncToken = fetchMyEventsRequest_syncToken obj}
    , if obj == default_FetchMyEventsRequest{fetchMyEventsRequest_limit = fetchMyEventsRequest_limit obj} then P.Nothing else P.Just $ default_FetchMyEventsRequest{fetchMyEventsRequest_limit = fetchMyEventsRequest_limit obj}
    , if obj == default_FetchMyEventsRequest{fetchMyEventsRequest_continuationToken = fetchMyEventsRequest_continuationToken obj} then P.Nothing else P.Just $ default_FetchMyEventsRequest{fetchMyEventsRequest_continuationToken = fetchMyEventsRequest_continuationToken obj}
    ]
from_FetchMyEventsRequest :: FetchMyEventsRequest -> T.ThriftVal
from_FetchMyEventsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2642 -> P.Just (1, ("subscriptionId",T.TI64 _v2642))) $ fetchMyEventsRequest_subscriptionId record
  , (\_v2642 -> P.Just (2, ("syncToken",T.TString $ E.encodeUtf8 _v2642))) $ fetchMyEventsRequest_syncToken record
  , (\_v2642 -> P.Just (3, ("limit",T.TI32 _v2642))) $ fetchMyEventsRequest_limit record
  , (\_v2642 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v2642))) $ fetchMyEventsRequest_continuationToken record
  ]
write_FetchMyEventsRequest :: T.Protocol p => p -> FetchMyEventsRequest -> P.IO ()
write_FetchMyEventsRequest oprot record = T.writeVal oprot $ from_FetchMyEventsRequest record
encode_FetchMyEventsRequest :: T.StatelessProtocol p => p -> FetchMyEventsRequest -> LBS.ByteString
encode_FetchMyEventsRequest oprot record = T.serializeVal oprot $ from_FetchMyEventsRequest record
to_FetchMyEventsRequest :: T.ThriftVal -> FetchMyEventsRequest
to_FetchMyEventsRequest (T.TStruct fields) = FetchMyEventsRequest{
  fetchMyEventsRequest_subscriptionId = P.maybe (fetchMyEventsRequest_subscriptionId default_FetchMyEventsRequest) (\(_,_val2644) -> (case _val2644 of {T.TI64 _val2645 -> _val2645; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  fetchMyEventsRequest_syncToken = P.maybe (fetchMyEventsRequest_syncToken default_FetchMyEventsRequest) (\(_,_val2644) -> (case _val2644 of {T.TString _val2646 -> E.decodeUtf8 _val2646; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchMyEventsRequest_limit = P.maybe (fetchMyEventsRequest_limit default_FetchMyEventsRequest) (\(_,_val2644) -> (case _val2644 of {T.TI32 _val2647 -> _val2647; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchMyEventsRequest_continuationToken = P.maybe (fetchMyEventsRequest_continuationToken default_FetchMyEventsRequest) (\(_,_val2644) -> (case _val2644 of {T.TString _val2648 -> E.decodeUtf8 _val2648; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FetchMyEventsRequest _ = P.error "not a struct"
read_FetchMyEventsRequest :: T.Protocol p => p -> P.IO FetchMyEventsRequest
read_FetchMyEventsRequest iprot = to_FetchMyEventsRequest <$> T.readVal iprot (T.T_STRUCT typemap_FetchMyEventsRequest)
decode_FetchMyEventsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMyEventsRequest
decode_FetchMyEventsRequest iprot bs = to_FetchMyEventsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMyEventsRequest) bs
typemap_FetchMyEventsRequest :: T.TypeMap
typemap_FetchMyEventsRequest = Map.fromList [(1,("subscriptionId",T.T_I64)),(2,("syncToken",T.T_STRING)),(3,("limit",T.T_I32)),(4,("continuationToken",T.T_STRING))]
default_FetchMyEventsRequest :: FetchMyEventsRequest
default_FetchMyEventsRequest = FetchMyEventsRequest{
  fetchMyEventsRequest_subscriptionId = 0,
  fetchMyEventsRequest_syncToken = "",
  fetchMyEventsRequest_limit = 0,
  fetchMyEventsRequest_continuationToken = ""}
data FetchMyEventsResponse = FetchMyEventsResponse  { fetchMyEventsResponse_subscription :: SubscriptionState
  , fetchMyEventsResponse_events :: (Vector.Vector SquareEvent)
  , fetchMyEventsResponse_syncToken :: LT.Text
  , fetchMyEventsResponse_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMyEventsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMyEventsResponse_subscription record   `H.hashWithSalt` fetchMyEventsResponse_events record   `H.hashWithSalt` fetchMyEventsResponse_syncToken record   `H.hashWithSalt` fetchMyEventsResponse_continuationToken record  
instance QC.Arbitrary FetchMyEventsResponse where 
  arbitrary = M.liftM FetchMyEventsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchMyEventsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMyEventsResponse{fetchMyEventsResponse_subscription = fetchMyEventsResponse_subscription obj} then P.Nothing else P.Just $ default_FetchMyEventsResponse{fetchMyEventsResponse_subscription = fetchMyEventsResponse_subscription obj}
    , if obj == default_FetchMyEventsResponse{fetchMyEventsResponse_events = fetchMyEventsResponse_events obj} then P.Nothing else P.Just $ default_FetchMyEventsResponse{fetchMyEventsResponse_events = fetchMyEventsResponse_events obj}
    , if obj == default_FetchMyEventsResponse{fetchMyEventsResponse_syncToken = fetchMyEventsResponse_syncToken obj} then P.Nothing else P.Just $ default_FetchMyEventsResponse{fetchMyEventsResponse_syncToken = fetchMyEventsResponse_syncToken obj}
    , if obj == default_FetchMyEventsResponse{fetchMyEventsResponse_continuationToken = fetchMyEventsResponse_continuationToken obj} then P.Nothing else P.Just $ default_FetchMyEventsResponse{fetchMyEventsResponse_continuationToken = fetchMyEventsResponse_continuationToken obj}
    ]
from_FetchMyEventsResponse :: FetchMyEventsResponse -> T.ThriftVal
from_FetchMyEventsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2651 -> P.Just (1, ("subscription",from_SubscriptionState _v2651))) $ fetchMyEventsResponse_subscription record
  , (\_v2651 -> P.Just (2, ("events",T.TList (T.T_STRUCT typemap_SquareEvent) $ P.map (\_v2653 -> from_SquareEvent _v2653) $ Vector.toList _v2651))) $ fetchMyEventsResponse_events record
  , (\_v2651 -> P.Just (3, ("syncToken",T.TString $ E.encodeUtf8 _v2651))) $ fetchMyEventsResponse_syncToken record
  , (\_v2651 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v2651))) $ fetchMyEventsResponse_continuationToken record
  ]
write_FetchMyEventsResponse :: T.Protocol p => p -> FetchMyEventsResponse -> P.IO ()
write_FetchMyEventsResponse oprot record = T.writeVal oprot $ from_FetchMyEventsResponse record
encode_FetchMyEventsResponse :: T.StatelessProtocol p => p -> FetchMyEventsResponse -> LBS.ByteString
encode_FetchMyEventsResponse oprot record = T.serializeVal oprot $ from_FetchMyEventsResponse record
to_FetchMyEventsResponse :: T.ThriftVal -> FetchMyEventsResponse
to_FetchMyEventsResponse (T.TStruct fields) = FetchMyEventsResponse{
  fetchMyEventsResponse_subscription = P.maybe (fetchMyEventsResponse_subscription default_FetchMyEventsResponse) (\(_,_val2655) -> (case _val2655 of {T.TStruct _val2656 -> (to_SubscriptionState (T.TStruct _val2656)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  fetchMyEventsResponse_events = P.maybe (fetchMyEventsResponse_events default_FetchMyEventsResponse) (\(_,_val2655) -> (case _val2655 of {T.TList _ _val2657 -> (Vector.fromList $ P.map (\_v2658 -> (case _v2658 of {T.TStruct _val2659 -> (to_SquareEvent (T.TStruct _val2659)); _ -> P.error "wrong type"})) _val2657); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchMyEventsResponse_syncToken = P.maybe (fetchMyEventsResponse_syncToken default_FetchMyEventsResponse) (\(_,_val2655) -> (case _val2655 of {T.TString _val2660 -> E.decodeUtf8 _val2660; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchMyEventsResponse_continuationToken = P.maybe (fetchMyEventsResponse_continuationToken default_FetchMyEventsResponse) (\(_,_val2655) -> (case _val2655 of {T.TString _val2661 -> E.decodeUtf8 _val2661; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FetchMyEventsResponse _ = P.error "not a struct"
read_FetchMyEventsResponse :: T.Protocol p => p -> P.IO FetchMyEventsResponse
read_FetchMyEventsResponse iprot = to_FetchMyEventsResponse <$> T.readVal iprot (T.T_STRUCT typemap_FetchMyEventsResponse)
decode_FetchMyEventsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMyEventsResponse
decode_FetchMyEventsResponse iprot bs = to_FetchMyEventsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMyEventsResponse) bs
typemap_FetchMyEventsResponse :: T.TypeMap
typemap_FetchMyEventsResponse = Map.fromList [(1,("subscription",(T.T_STRUCT typemap_SubscriptionState))),(2,("events",(T.T_LIST (T.T_STRUCT typemap_SquareEvent)))),(3,("syncToken",T.T_STRING)),(4,("continuationToken",T.T_STRING))]
default_FetchMyEventsResponse :: FetchMyEventsResponse
default_FetchMyEventsResponse = FetchMyEventsResponse{
  fetchMyEventsResponse_subscription = default_SubscriptionState,
  fetchMyEventsResponse_events = Vector.empty,
  fetchMyEventsResponse_syncToken = "",
  fetchMyEventsResponse_continuationToken = ""}
data FetchSquareChatEventsRequest = FetchSquareChatEventsRequest  { fetchSquareChatEventsRequest_subscriptionId :: I.Int64
  , fetchSquareChatEventsRequest_squareChatMid :: LT.Text
  , fetchSquareChatEventsRequest_syncToken :: LT.Text
  , fetchSquareChatEventsRequest_limit :: I.Int32
  , fetchSquareChatEventsRequest_direction :: FetchDirection
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchSquareChatEventsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchSquareChatEventsRequest_subscriptionId record   `H.hashWithSalt` fetchSquareChatEventsRequest_squareChatMid record   `H.hashWithSalt` fetchSquareChatEventsRequest_syncToken record   `H.hashWithSalt` fetchSquareChatEventsRequest_limit record   `H.hashWithSalt` fetchSquareChatEventsRequest_direction record  
instance QC.Arbitrary FetchSquareChatEventsRequest where 
  arbitrary = M.liftM FetchSquareChatEventsRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchSquareChatEventsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_subscriptionId = fetchSquareChatEventsRequest_subscriptionId obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_subscriptionId = fetchSquareChatEventsRequest_subscriptionId obj}
    , if obj == default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_squareChatMid = fetchSquareChatEventsRequest_squareChatMid obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_squareChatMid = fetchSquareChatEventsRequest_squareChatMid obj}
    , if obj == default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_syncToken = fetchSquareChatEventsRequest_syncToken obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_syncToken = fetchSquareChatEventsRequest_syncToken obj}
    , if obj == default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_limit = fetchSquareChatEventsRequest_limit obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_limit = fetchSquareChatEventsRequest_limit obj}
    , if obj == default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_direction = fetchSquareChatEventsRequest_direction obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsRequest{fetchSquareChatEventsRequest_direction = fetchSquareChatEventsRequest_direction obj}
    ]
from_FetchSquareChatEventsRequest :: FetchSquareChatEventsRequest -> T.ThriftVal
from_FetchSquareChatEventsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2664 -> P.Just (1, ("subscriptionId",T.TI64 _v2664))) $ fetchSquareChatEventsRequest_subscriptionId record
  , (\_v2664 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2664))) $ fetchSquareChatEventsRequest_squareChatMid record
  , (\_v2664 -> P.Just (3, ("syncToken",T.TString $ E.encodeUtf8 _v2664))) $ fetchSquareChatEventsRequest_syncToken record
  , (\_v2664 -> P.Just (4, ("limit",T.TI32 _v2664))) $ fetchSquareChatEventsRequest_limit record
  , (\_v2664 -> P.Just (5, ("direction",T.TI32 $ P.fromIntegral $ P.fromEnum _v2664))) $ fetchSquareChatEventsRequest_direction record
  ]
write_FetchSquareChatEventsRequest :: T.Protocol p => p -> FetchSquareChatEventsRequest -> P.IO ()
write_FetchSquareChatEventsRequest oprot record = T.writeVal oprot $ from_FetchSquareChatEventsRequest record
encode_FetchSquareChatEventsRequest :: T.StatelessProtocol p => p -> FetchSquareChatEventsRequest -> LBS.ByteString
encode_FetchSquareChatEventsRequest oprot record = T.serializeVal oprot $ from_FetchSquareChatEventsRequest record
to_FetchSquareChatEventsRequest :: T.ThriftVal -> FetchSquareChatEventsRequest
to_FetchSquareChatEventsRequest (T.TStruct fields) = FetchSquareChatEventsRequest{
  fetchSquareChatEventsRequest_subscriptionId = P.maybe (fetchSquareChatEventsRequest_subscriptionId default_FetchSquareChatEventsRequest) (\(_,_val2666) -> (case _val2666 of {T.TI64 _val2667 -> _val2667; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  fetchSquareChatEventsRequest_squareChatMid = P.maybe (fetchSquareChatEventsRequest_squareChatMid default_FetchSquareChatEventsRequest) (\(_,_val2666) -> (case _val2666 of {T.TString _val2668 -> E.decodeUtf8 _val2668; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchSquareChatEventsRequest_syncToken = P.maybe (fetchSquareChatEventsRequest_syncToken default_FetchSquareChatEventsRequest) (\(_,_val2666) -> (case _val2666 of {T.TString _val2669 -> E.decodeUtf8 _val2669; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchSquareChatEventsRequest_limit = P.maybe (fetchSquareChatEventsRequest_limit default_FetchSquareChatEventsRequest) (\(_,_val2666) -> (case _val2666 of {T.TI32 _val2670 -> _val2670; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  fetchSquareChatEventsRequest_direction = P.maybe (fetchSquareChatEventsRequest_direction default_FetchSquareChatEventsRequest) (\(_,_val2666) -> (case _val2666 of {T.TI32 _val2671 -> P.toEnum $ P.fromIntegral _val2671; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_FetchSquareChatEventsRequest _ = P.error "not a struct"
read_FetchSquareChatEventsRequest :: T.Protocol p => p -> P.IO FetchSquareChatEventsRequest
read_FetchSquareChatEventsRequest iprot = to_FetchSquareChatEventsRequest <$> T.readVal iprot (T.T_STRUCT typemap_FetchSquareChatEventsRequest)
decode_FetchSquareChatEventsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchSquareChatEventsRequest
decode_FetchSquareChatEventsRequest iprot bs = to_FetchSquareChatEventsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchSquareChatEventsRequest) bs
typemap_FetchSquareChatEventsRequest :: T.TypeMap
typemap_FetchSquareChatEventsRequest = Map.fromList [(1,("subscriptionId",T.T_I64)),(2,("squareChatMid",T.T_STRING)),(3,("syncToken",T.T_STRING)),(4,("limit",T.T_I32)),(5,("direction",T.T_I32))]
default_FetchSquareChatEventsRequest :: FetchSquareChatEventsRequest
default_FetchSquareChatEventsRequest = FetchSquareChatEventsRequest{
  fetchSquareChatEventsRequest_subscriptionId = 0,
  fetchSquareChatEventsRequest_squareChatMid = "",
  fetchSquareChatEventsRequest_syncToken = "",
  fetchSquareChatEventsRequest_limit = 0,
  fetchSquareChatEventsRequest_direction = (P.toEnum 0)}
data FetchSquareChatEventsResponse = FetchSquareChatEventsResponse  { fetchSquareChatEventsResponse_subscription :: SubscriptionState
  , fetchSquareChatEventsResponse_events :: (Vector.Vector SquareEvent)
  , fetchSquareChatEventsResponse_syncToken :: LT.Text
  , fetchSquareChatEventsResponse_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchSquareChatEventsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchSquareChatEventsResponse_subscription record   `H.hashWithSalt` fetchSquareChatEventsResponse_events record   `H.hashWithSalt` fetchSquareChatEventsResponse_syncToken record   `H.hashWithSalt` fetchSquareChatEventsResponse_continuationToken record  
instance QC.Arbitrary FetchSquareChatEventsResponse where 
  arbitrary = M.liftM FetchSquareChatEventsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchSquareChatEventsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_subscription = fetchSquareChatEventsResponse_subscription obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_subscription = fetchSquareChatEventsResponse_subscription obj}
    , if obj == default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_events = fetchSquareChatEventsResponse_events obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_events = fetchSquareChatEventsResponse_events obj}
    , if obj == default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_syncToken = fetchSquareChatEventsResponse_syncToken obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_syncToken = fetchSquareChatEventsResponse_syncToken obj}
    , if obj == default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_continuationToken = fetchSquareChatEventsResponse_continuationToken obj} then P.Nothing else P.Just $ default_FetchSquareChatEventsResponse{fetchSquareChatEventsResponse_continuationToken = fetchSquareChatEventsResponse_continuationToken obj}
    ]
from_FetchSquareChatEventsResponse :: FetchSquareChatEventsResponse -> T.ThriftVal
from_FetchSquareChatEventsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2674 -> P.Just (1, ("subscription",from_SubscriptionState _v2674))) $ fetchSquareChatEventsResponse_subscription record
  , (\_v2674 -> P.Just (2, ("events",T.TList (T.T_STRUCT typemap_SquareEvent) $ P.map (\_v2676 -> from_SquareEvent _v2676) $ Vector.toList _v2674))) $ fetchSquareChatEventsResponse_events record
  , (\_v2674 -> P.Just (3, ("syncToken",T.TString $ E.encodeUtf8 _v2674))) $ fetchSquareChatEventsResponse_syncToken record
  , (\_v2674 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v2674))) $ fetchSquareChatEventsResponse_continuationToken record
  ]
write_FetchSquareChatEventsResponse :: T.Protocol p => p -> FetchSquareChatEventsResponse -> P.IO ()
write_FetchSquareChatEventsResponse oprot record = T.writeVal oprot $ from_FetchSquareChatEventsResponse record
encode_FetchSquareChatEventsResponse :: T.StatelessProtocol p => p -> FetchSquareChatEventsResponse -> LBS.ByteString
encode_FetchSquareChatEventsResponse oprot record = T.serializeVal oprot $ from_FetchSquareChatEventsResponse record
to_FetchSquareChatEventsResponse :: T.ThriftVal -> FetchSquareChatEventsResponse
to_FetchSquareChatEventsResponse (T.TStruct fields) = FetchSquareChatEventsResponse{
  fetchSquareChatEventsResponse_subscription = P.maybe (fetchSquareChatEventsResponse_subscription default_FetchSquareChatEventsResponse) (\(_,_val2678) -> (case _val2678 of {T.TStruct _val2679 -> (to_SubscriptionState (T.TStruct _val2679)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  fetchSquareChatEventsResponse_events = P.maybe (fetchSquareChatEventsResponse_events default_FetchSquareChatEventsResponse) (\(_,_val2678) -> (case _val2678 of {T.TList _ _val2680 -> (Vector.fromList $ P.map (\_v2681 -> (case _v2681 of {T.TStruct _val2682 -> (to_SquareEvent (T.TStruct _val2682)); _ -> P.error "wrong type"})) _val2680); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchSquareChatEventsResponse_syncToken = P.maybe (fetchSquareChatEventsResponse_syncToken default_FetchSquareChatEventsResponse) (\(_,_val2678) -> (case _val2678 of {T.TString _val2683 -> E.decodeUtf8 _val2683; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchSquareChatEventsResponse_continuationToken = P.maybe (fetchSquareChatEventsResponse_continuationToken default_FetchSquareChatEventsResponse) (\(_,_val2678) -> (case _val2678 of {T.TString _val2684 -> E.decodeUtf8 _val2684; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FetchSquareChatEventsResponse _ = P.error "not a struct"
read_FetchSquareChatEventsResponse :: T.Protocol p => p -> P.IO FetchSquareChatEventsResponse
read_FetchSquareChatEventsResponse iprot = to_FetchSquareChatEventsResponse <$> T.readVal iprot (T.T_STRUCT typemap_FetchSquareChatEventsResponse)
decode_FetchSquareChatEventsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchSquareChatEventsResponse
decode_FetchSquareChatEventsResponse iprot bs = to_FetchSquareChatEventsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchSquareChatEventsResponse) bs
typemap_FetchSquareChatEventsResponse :: T.TypeMap
typemap_FetchSquareChatEventsResponse = Map.fromList [(1,("subscription",(T.T_STRUCT typemap_SubscriptionState))),(2,("events",(T.T_LIST (T.T_STRUCT typemap_SquareEvent)))),(3,("syncToken",T.T_STRING)),(4,("continuationToken",T.T_STRING))]
default_FetchSquareChatEventsResponse :: FetchSquareChatEventsResponse
default_FetchSquareChatEventsResponse = FetchSquareChatEventsResponse{
  fetchSquareChatEventsResponse_subscription = default_SubscriptionState,
  fetchSquareChatEventsResponse_events = Vector.empty,
  fetchSquareChatEventsResponse_syncToken = "",
  fetchSquareChatEventsResponse_continuationToken = ""}
data InviteToSquareRequest = InviteToSquareRequest  { inviteToSquareRequest_squareMid :: LT.Text
  , inviteToSquareRequest_invitees :: (Vector.Vector LT.Text)
  , inviteToSquareRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquareRequest_squareMid record   `H.hashWithSalt` inviteToSquareRequest_invitees record   `H.hashWithSalt` inviteToSquareRequest_squareChatMid record  
instance QC.Arbitrary InviteToSquareRequest where 
  arbitrary = M.liftM InviteToSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteToSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquareRequest{inviteToSquareRequest_squareMid = inviteToSquareRequest_squareMid obj} then P.Nothing else P.Just $ default_InviteToSquareRequest{inviteToSquareRequest_squareMid = inviteToSquareRequest_squareMid obj}
    , if obj == default_InviteToSquareRequest{inviteToSquareRequest_invitees = inviteToSquareRequest_invitees obj} then P.Nothing else P.Just $ default_InviteToSquareRequest{inviteToSquareRequest_invitees = inviteToSquareRequest_invitees obj}
    , if obj == default_InviteToSquareRequest{inviteToSquareRequest_squareChatMid = inviteToSquareRequest_squareChatMid obj} then P.Nothing else P.Just $ default_InviteToSquareRequest{inviteToSquareRequest_squareChatMid = inviteToSquareRequest_squareChatMid obj}
    ]
from_InviteToSquareRequest :: InviteToSquareRequest -> T.ThriftVal
from_InviteToSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2687 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2687))) $ inviteToSquareRequest_squareMid record
  , (\_v2687 -> P.Just (3, ("invitees",T.TList T.T_STRING $ P.map (\_v2689 -> T.TString $ E.encodeUtf8 _v2689) $ Vector.toList _v2687))) $ inviteToSquareRequest_invitees record
  , (\_v2687 -> P.Just (4, ("squareChatMid",T.TString $ E.encodeUtf8 _v2687))) $ inviteToSquareRequest_squareChatMid record
  ]
write_InviteToSquareRequest :: T.Protocol p => p -> InviteToSquareRequest -> P.IO ()
write_InviteToSquareRequest oprot record = T.writeVal oprot $ from_InviteToSquareRequest record
encode_InviteToSquareRequest :: T.StatelessProtocol p => p -> InviteToSquareRequest -> LBS.ByteString
encode_InviteToSquareRequest oprot record = T.serializeVal oprot $ from_InviteToSquareRequest record
to_InviteToSquareRequest :: T.ThriftVal -> InviteToSquareRequest
to_InviteToSquareRequest (T.TStruct fields) = InviteToSquareRequest{
  inviteToSquareRequest_squareMid = P.maybe (inviteToSquareRequest_squareMid default_InviteToSquareRequest) (\(_,_val2691) -> (case _val2691 of {T.TString _val2692 -> E.decodeUtf8 _val2692; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteToSquareRequest_invitees = P.maybe (inviteToSquareRequest_invitees default_InviteToSquareRequest) (\(_,_val2691) -> (case _val2691 of {T.TList _ _val2693 -> (Vector.fromList $ P.map (\_v2694 -> (case _v2694 of {T.TString _val2695 -> E.decodeUtf8 _val2695; _ -> P.error "wrong type"})) _val2693); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  inviteToSquareRequest_squareChatMid = P.maybe (inviteToSquareRequest_squareChatMid default_InviteToSquareRequest) (\(_,_val2691) -> (case _val2691 of {T.TString _val2696 -> E.decodeUtf8 _val2696; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_InviteToSquareRequest _ = P.error "not a struct"
read_InviteToSquareRequest :: T.Protocol p => p -> P.IO InviteToSquareRequest
read_InviteToSquareRequest iprot = to_InviteToSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareRequest)
decode_InviteToSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareRequest
decode_InviteToSquareRequest iprot bs = to_InviteToSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareRequest) bs
typemap_InviteToSquareRequest :: T.TypeMap
typemap_InviteToSquareRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("invitees",(T.T_LIST T.T_STRING))),(4,("squareChatMid",T.T_STRING))]
default_InviteToSquareRequest :: InviteToSquareRequest
default_InviteToSquareRequest = InviteToSquareRequest{
  inviteToSquareRequest_squareMid = "",
  inviteToSquareRequest_invitees = Vector.empty,
  inviteToSquareRequest_squareChatMid = ""}
data InviteToSquareResponse = InviteToSquareResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary InviteToSquareResponse where 
  arbitrary = QC.elements [InviteToSquareResponse]
from_InviteToSquareResponse :: InviteToSquareResponse -> T.ThriftVal
from_InviteToSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_InviteToSquareResponse :: T.Protocol p => p -> InviteToSquareResponse -> P.IO ()
write_InviteToSquareResponse oprot record = T.writeVal oprot $ from_InviteToSquareResponse record
encode_InviteToSquareResponse :: T.StatelessProtocol p => p -> InviteToSquareResponse -> LBS.ByteString
encode_InviteToSquareResponse oprot record = T.serializeVal oprot $ from_InviteToSquareResponse record
to_InviteToSquareResponse :: T.ThriftVal -> InviteToSquareResponse
to_InviteToSquareResponse (T.TStruct fields) = InviteToSquareResponse{

  }
to_InviteToSquareResponse _ = P.error "not a struct"
read_InviteToSquareResponse :: T.Protocol p => p -> P.IO InviteToSquareResponse
read_InviteToSquareResponse iprot = to_InviteToSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareResponse)
decode_InviteToSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareResponse
decode_InviteToSquareResponse iprot bs = to_InviteToSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareResponse) bs
typemap_InviteToSquareResponse :: T.TypeMap
typemap_InviteToSquareResponse = Map.fromList []
default_InviteToSquareResponse :: InviteToSquareResponse
default_InviteToSquareResponse = InviteToSquareResponse{
}
data InviteToSquareChatRequest = InviteToSquareChatRequest  { inviteToSquareChatRequest_inviteeMids :: (Vector.Vector LT.Text)
  , inviteToSquareChatRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquareChatRequest_inviteeMids record   `H.hashWithSalt` inviteToSquareChatRequest_squareChatMid record  
instance QC.Arbitrary InviteToSquareChatRequest where 
  arbitrary = M.liftM InviteToSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteToSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquareChatRequest{inviteToSquareChatRequest_inviteeMids = inviteToSquareChatRequest_inviteeMids obj} then P.Nothing else P.Just $ default_InviteToSquareChatRequest{inviteToSquareChatRequest_inviteeMids = inviteToSquareChatRequest_inviteeMids obj}
    , if obj == default_InviteToSquareChatRequest{inviteToSquareChatRequest_squareChatMid = inviteToSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_InviteToSquareChatRequest{inviteToSquareChatRequest_squareChatMid = inviteToSquareChatRequest_squareChatMid obj}
    ]
from_InviteToSquareChatRequest :: InviteToSquareChatRequest -> T.ThriftVal
from_InviteToSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2704 -> P.Just (1, ("inviteeMids",T.TList T.T_STRING $ P.map (\_v2706 -> T.TString $ E.encodeUtf8 _v2706) $ Vector.toList _v2704))) $ inviteToSquareChatRequest_inviteeMids record
  , (\_v2704 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v2704))) $ inviteToSquareChatRequest_squareChatMid record
  ]
write_InviteToSquareChatRequest :: T.Protocol p => p -> InviteToSquareChatRequest -> P.IO ()
write_InviteToSquareChatRequest oprot record = T.writeVal oprot $ from_InviteToSquareChatRequest record
encode_InviteToSquareChatRequest :: T.StatelessProtocol p => p -> InviteToSquareChatRequest -> LBS.ByteString
encode_InviteToSquareChatRequest oprot record = T.serializeVal oprot $ from_InviteToSquareChatRequest record
to_InviteToSquareChatRequest :: T.ThriftVal -> InviteToSquareChatRequest
to_InviteToSquareChatRequest (T.TStruct fields) = InviteToSquareChatRequest{
  inviteToSquareChatRequest_inviteeMids = P.maybe (inviteToSquareChatRequest_inviteeMids default_InviteToSquareChatRequest) (\(_,_val2708) -> (case _val2708 of {T.TList _ _val2709 -> (Vector.fromList $ P.map (\_v2710 -> (case _v2710 of {T.TString _val2711 -> E.decodeUtf8 _val2711; _ -> P.error "wrong type"})) _val2709); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteToSquareChatRequest_squareChatMid = P.maybe (inviteToSquareChatRequest_squareChatMid default_InviteToSquareChatRequest) (\(_,_val2708) -> (case _val2708 of {T.TString _val2712 -> E.decodeUtf8 _val2712; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InviteToSquareChatRequest _ = P.error "not a struct"
read_InviteToSquareChatRequest :: T.Protocol p => p -> P.IO InviteToSquareChatRequest
read_InviteToSquareChatRequest iprot = to_InviteToSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareChatRequest)
decode_InviteToSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareChatRequest
decode_InviteToSquareChatRequest iprot bs = to_InviteToSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareChatRequest) bs
typemap_InviteToSquareChatRequest :: T.TypeMap
typemap_InviteToSquareChatRequest = Map.fromList [(1,("inviteeMids",(T.T_LIST T.T_STRING))),(2,("squareChatMid",T.T_STRING))]
default_InviteToSquareChatRequest :: InviteToSquareChatRequest
default_InviteToSquareChatRequest = InviteToSquareChatRequest{
  inviteToSquareChatRequest_inviteeMids = Vector.empty,
  inviteToSquareChatRequest_squareChatMid = ""}
data InviteToSquareChatResponse = InviteToSquareChatResponse  { inviteToSquareChatResponse_inviteeMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareChatResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquareChatResponse_inviteeMids record  
instance QC.Arbitrary InviteToSquareChatResponse where 
  arbitrary = M.liftM InviteToSquareChatResponse (QC.arbitrary)
  shrink obj | obj == default_InviteToSquareChatResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquareChatResponse{inviteToSquareChatResponse_inviteeMids = inviteToSquareChatResponse_inviteeMids obj} then P.Nothing else P.Just $ default_InviteToSquareChatResponse{inviteToSquareChatResponse_inviteeMids = inviteToSquareChatResponse_inviteeMids obj}
    ]
from_InviteToSquareChatResponse :: InviteToSquareChatResponse -> T.ThriftVal
from_InviteToSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2715 -> P.Just (1, ("inviteeMids",T.TList T.T_STRING $ P.map (\_v2717 -> T.TString $ E.encodeUtf8 _v2717) $ Vector.toList _v2715))) $ inviteToSquareChatResponse_inviteeMids record
  ]
write_InviteToSquareChatResponse :: T.Protocol p => p -> InviteToSquareChatResponse -> P.IO ()
write_InviteToSquareChatResponse oprot record = T.writeVal oprot $ from_InviteToSquareChatResponse record
encode_InviteToSquareChatResponse :: T.StatelessProtocol p => p -> InviteToSquareChatResponse -> LBS.ByteString
encode_InviteToSquareChatResponse oprot record = T.serializeVal oprot $ from_InviteToSquareChatResponse record
to_InviteToSquareChatResponse :: T.ThriftVal -> InviteToSquareChatResponse
to_InviteToSquareChatResponse (T.TStruct fields) = InviteToSquareChatResponse{
  inviteToSquareChatResponse_inviteeMids = P.maybe (inviteToSquareChatResponse_inviteeMids default_InviteToSquareChatResponse) (\(_,_val2719) -> (case _val2719 of {T.TList _ _val2720 -> (Vector.fromList $ P.map (\_v2721 -> (case _v2721 of {T.TString _val2722 -> E.decodeUtf8 _val2722; _ -> P.error "wrong type"})) _val2720); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteToSquareChatResponse _ = P.error "not a struct"
read_InviteToSquareChatResponse :: T.Protocol p => p -> P.IO InviteToSquareChatResponse
read_InviteToSquareChatResponse iprot = to_InviteToSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareChatResponse)
decode_InviteToSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareChatResponse
decode_InviteToSquareChatResponse iprot bs = to_InviteToSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareChatResponse) bs
typemap_InviteToSquareChatResponse :: T.TypeMap
typemap_InviteToSquareChatResponse = Map.fromList [(1,("inviteeMids",(T.T_LIST T.T_STRING)))]
default_InviteToSquareChatResponse :: InviteToSquareChatResponse
default_InviteToSquareChatResponse = InviteToSquareChatResponse{
  inviteToSquareChatResponse_inviteeMids = Vector.empty}
data GetSquareMemberRequest = GetSquareMemberRequest  { getSquareMemberRequest_squareMemberMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRequest_squareMemberMid record  
instance QC.Arbitrary GetSquareMemberRequest where 
  arbitrary = M.liftM GetSquareMemberRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRequest{getSquareMemberRequest_squareMemberMid = getSquareMemberRequest_squareMemberMid obj} then P.Nothing else P.Just $ default_GetSquareMemberRequest{getSquareMemberRequest_squareMemberMid = getSquareMemberRequest_squareMemberMid obj}
    ]
from_GetSquareMemberRequest :: GetSquareMemberRequest -> T.ThriftVal
from_GetSquareMemberRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2725 -> P.Just (1, ("squareMemberMid",T.TString $ E.encodeUtf8 _v2725))) $ getSquareMemberRequest_squareMemberMid record
  ]
write_GetSquareMemberRequest :: T.Protocol p => p -> GetSquareMemberRequest -> P.IO ()
write_GetSquareMemberRequest oprot record = T.writeVal oprot $ from_GetSquareMemberRequest record
encode_GetSquareMemberRequest :: T.StatelessProtocol p => p -> GetSquareMemberRequest -> LBS.ByteString
encode_GetSquareMemberRequest oprot record = T.serializeVal oprot $ from_GetSquareMemberRequest record
to_GetSquareMemberRequest :: T.ThriftVal -> GetSquareMemberRequest
to_GetSquareMemberRequest (T.TStruct fields) = GetSquareMemberRequest{
  getSquareMemberRequest_squareMemberMid = P.maybe (getSquareMemberRequest_squareMemberMid default_GetSquareMemberRequest) (\(_,_val2727) -> (case _val2727 of {T.TString _val2728 -> E.decodeUtf8 _val2728; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMemberRequest _ = P.error "not a struct"
read_GetSquareMemberRequest :: T.Protocol p => p -> P.IO GetSquareMemberRequest
read_GetSquareMemberRequest iprot = to_GetSquareMemberRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRequest)
decode_GetSquareMemberRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRequest
decode_GetSquareMemberRequest iprot bs = to_GetSquareMemberRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRequest) bs
typemap_GetSquareMemberRequest :: T.TypeMap
typemap_GetSquareMemberRequest = Map.fromList [(1,("squareMemberMid",T.T_STRING))]
default_GetSquareMemberRequest :: GetSquareMemberRequest
default_GetSquareMemberRequest = GetSquareMemberRequest{
  getSquareMemberRequest_squareMemberMid = ""}
data GetSquareMemberResponse = GetSquareMemberResponse  { getSquareMemberResponse_squareMember :: SquareMember
  , getSquareMemberResponse_relation :: SquareMemberRelation
  , getSquareMemberResponse_oneOnOneChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberResponse_squareMember record   `H.hashWithSalt` getSquareMemberResponse_relation record   `H.hashWithSalt` getSquareMemberResponse_oneOnOneChatMid record  
instance QC.Arbitrary GetSquareMemberResponse where 
  arbitrary = M.liftM GetSquareMemberResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberResponse{getSquareMemberResponse_squareMember = getSquareMemberResponse_squareMember obj} then P.Nothing else P.Just $ default_GetSquareMemberResponse{getSquareMemberResponse_squareMember = getSquareMemberResponse_squareMember obj}
    , if obj == default_GetSquareMemberResponse{getSquareMemberResponse_relation = getSquareMemberResponse_relation obj} then P.Nothing else P.Just $ default_GetSquareMemberResponse{getSquareMemberResponse_relation = getSquareMemberResponse_relation obj}
    , if obj == default_GetSquareMemberResponse{getSquareMemberResponse_oneOnOneChatMid = getSquareMemberResponse_oneOnOneChatMid obj} then P.Nothing else P.Just $ default_GetSquareMemberResponse{getSquareMemberResponse_oneOnOneChatMid = getSquareMemberResponse_oneOnOneChatMid obj}
    ]
from_GetSquareMemberResponse :: GetSquareMemberResponse -> T.ThriftVal
from_GetSquareMemberResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2731 -> P.Just (1, ("squareMember",from_SquareMember _v2731))) $ getSquareMemberResponse_squareMember record
  , (\_v2731 -> P.Just (2, ("relation",from_SquareMemberRelation _v2731))) $ getSquareMemberResponse_relation record
  , (\_v2731 -> P.Just (3, ("oneOnOneChatMid",T.TString $ E.encodeUtf8 _v2731))) $ getSquareMemberResponse_oneOnOneChatMid record
  ]
write_GetSquareMemberResponse :: T.Protocol p => p -> GetSquareMemberResponse -> P.IO ()
write_GetSquareMemberResponse oprot record = T.writeVal oprot $ from_GetSquareMemberResponse record
encode_GetSquareMemberResponse :: T.StatelessProtocol p => p -> GetSquareMemberResponse -> LBS.ByteString
encode_GetSquareMemberResponse oprot record = T.serializeVal oprot $ from_GetSquareMemberResponse record
to_GetSquareMemberResponse :: T.ThriftVal -> GetSquareMemberResponse
to_GetSquareMemberResponse (T.TStruct fields) = GetSquareMemberResponse{
  getSquareMemberResponse_squareMember = P.maybe (getSquareMemberResponse_squareMember default_GetSquareMemberResponse) (\(_,_val2733) -> (case _val2733 of {T.TStruct _val2734 -> (to_SquareMember (T.TStruct _val2734)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareMemberResponse_relation = P.maybe (getSquareMemberResponse_relation default_GetSquareMemberResponse) (\(_,_val2733) -> (case _val2733 of {T.TStruct _val2735 -> (to_SquareMemberRelation (T.TStruct _val2735)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareMemberResponse_oneOnOneChatMid = P.maybe (getSquareMemberResponse_oneOnOneChatMid default_GetSquareMemberResponse) (\(_,_val2733) -> (case _val2733 of {T.TString _val2736 -> E.decodeUtf8 _val2736; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareMemberResponse _ = P.error "not a struct"
read_GetSquareMemberResponse :: T.Protocol p => p -> P.IO GetSquareMemberResponse
read_GetSquareMemberResponse iprot = to_GetSquareMemberResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberResponse)
decode_GetSquareMemberResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberResponse
decode_GetSquareMemberResponse iprot bs = to_GetSquareMemberResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberResponse) bs
typemap_GetSquareMemberResponse :: T.TypeMap
typemap_GetSquareMemberResponse = Map.fromList [(1,("squareMember",(T.T_STRUCT typemap_SquareMember))),(2,("relation",(T.T_STRUCT typemap_SquareMemberRelation))),(3,("oneOnOneChatMid",T.T_STRING))]
default_GetSquareMemberResponse :: GetSquareMemberResponse
default_GetSquareMemberResponse = GetSquareMemberResponse{
  getSquareMemberResponse_squareMember = default_SquareMember,
  getSquareMemberResponse_relation = default_SquareMemberRelation,
  getSquareMemberResponse_oneOnOneChatMid = ""}
data GetSquareMembersRequest = GetSquareMembersRequest  { getSquareMembersRequest_mids :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMembersRequest_mids record  
instance QC.Arbitrary GetSquareMembersRequest where 
  arbitrary = M.liftM GetSquareMembersRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMembersRequest{getSquareMembersRequest_mids = getSquareMembersRequest_mids obj} then P.Nothing else P.Just $ default_GetSquareMembersRequest{getSquareMembersRequest_mids = getSquareMembersRequest_mids obj}
    ]
from_GetSquareMembersRequest :: GetSquareMembersRequest -> T.ThriftVal
from_GetSquareMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2739 -> P.Just (2, ("mids",T.TSet T.T_STRING $ P.map (\_v2741 -> T.TString $ E.encodeUtf8 _v2741) $ Set.toList _v2739))) $ getSquareMembersRequest_mids record
  ]
write_GetSquareMembersRequest :: T.Protocol p => p -> GetSquareMembersRequest -> P.IO ()
write_GetSquareMembersRequest oprot record = T.writeVal oprot $ from_GetSquareMembersRequest record
encode_GetSquareMembersRequest :: T.StatelessProtocol p => p -> GetSquareMembersRequest -> LBS.ByteString
encode_GetSquareMembersRequest oprot record = T.serializeVal oprot $ from_GetSquareMembersRequest record
to_GetSquareMembersRequest :: T.ThriftVal -> GetSquareMembersRequest
to_GetSquareMembersRequest (T.TStruct fields) = GetSquareMembersRequest{
  getSquareMembersRequest_mids = P.maybe (getSquareMembersRequest_mids default_GetSquareMembersRequest) (\(_,_val2743) -> (case _val2743 of {T.TSet _ _val2744 -> (Set.fromList $ P.map (\_v2745 -> (case _v2745 of {T.TString _val2746 -> E.decodeUtf8 _val2746; _ -> P.error "wrong type"})) _val2744); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareMembersRequest _ = P.error "not a struct"
read_GetSquareMembersRequest :: T.Protocol p => p -> P.IO GetSquareMembersRequest
read_GetSquareMembersRequest iprot = to_GetSquareMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMembersRequest)
decode_GetSquareMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMembersRequest
decode_GetSquareMembersRequest iprot bs = to_GetSquareMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMembersRequest) bs
typemap_GetSquareMembersRequest :: T.TypeMap
typemap_GetSquareMembersRequest = Map.fromList [(2,("mids",(T.T_SET T.T_STRING)))]
default_GetSquareMembersRequest :: GetSquareMembersRequest
default_GetSquareMembersRequest = GetSquareMembersRequest{
  getSquareMembersRequest_mids = Set.empty}
data GetSquareMembersResponse = GetSquareMembersResponse  { getSquareMembersResponse_members :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMembersResponse_members record  
instance QC.Arbitrary GetSquareMembersResponse where 
  arbitrary = M.liftM GetSquareMembersResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMembersResponse{getSquareMembersResponse_members = getSquareMembersResponse_members obj} then P.Nothing else P.Just $ default_GetSquareMembersResponse{getSquareMembersResponse_members = getSquareMembersResponse_members obj}
    ]
from_GetSquareMembersResponse :: GetSquareMembersResponse -> T.ThriftVal
from_GetSquareMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2749 -> P.Just (1, ("members",from_SquareMember _v2749))) $ getSquareMembersResponse_members record
  ]
write_GetSquareMembersResponse :: T.Protocol p => p -> GetSquareMembersResponse -> P.IO ()
write_GetSquareMembersResponse oprot record = T.writeVal oprot $ from_GetSquareMembersResponse record
encode_GetSquareMembersResponse :: T.StatelessProtocol p => p -> GetSquareMembersResponse -> LBS.ByteString
encode_GetSquareMembersResponse oprot record = T.serializeVal oprot $ from_GetSquareMembersResponse record
to_GetSquareMembersResponse :: T.ThriftVal -> GetSquareMembersResponse
to_GetSquareMembersResponse (T.TStruct fields) = GetSquareMembersResponse{
  getSquareMembersResponse_members = P.maybe (getSquareMembersResponse_members default_GetSquareMembersResponse) (\(_,_val2751) -> (case _val2751 of {T.TStruct _val2752 -> (to_SquareMember (T.TStruct _val2752)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMembersResponse _ = P.error "not a struct"
read_GetSquareMembersResponse :: T.Protocol p => p -> P.IO GetSquareMembersResponse
read_GetSquareMembersResponse iprot = to_GetSquareMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMembersResponse)
decode_GetSquareMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMembersResponse
decode_GetSquareMembersResponse iprot bs = to_GetSquareMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMembersResponse) bs
typemap_GetSquareMembersResponse :: T.TypeMap
typemap_GetSquareMembersResponse = Map.fromList [(1,("members",(T.T_STRUCT typemap_SquareMember)))]
default_GetSquareMembersResponse :: GetSquareMembersResponse
default_GetSquareMembersResponse = GetSquareMembersResponse{
  getSquareMembersResponse_members = default_SquareMember}
data GetSquareMemberRelationsRequest = GetSquareMemberRelationsRequest  { getSquareMemberRelationsRequest_state :: SquareMemberRelationState
  , getSquareMemberRelationsRequest_continuationToken :: LT.Text
  , getSquareMemberRelationsRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelationsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelationsRequest_state record   `H.hashWithSalt` getSquareMemberRelationsRequest_continuationToken record   `H.hashWithSalt` getSquareMemberRelationsRequest_limit record  
instance QC.Arbitrary GetSquareMemberRelationsRequest where 
  arbitrary = M.liftM GetSquareMemberRelationsRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelationsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_state = getSquareMemberRelationsRequest_state obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_state = getSquareMemberRelationsRequest_state obj}
    , if obj == default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_continuationToken = getSquareMemberRelationsRequest_continuationToken obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_continuationToken = getSquareMemberRelationsRequest_continuationToken obj}
    , if obj == default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_limit = getSquareMemberRelationsRequest_limit obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsRequest{getSquareMemberRelationsRequest_limit = getSquareMemberRelationsRequest_limit obj}
    ]
from_GetSquareMemberRelationsRequest :: GetSquareMemberRelationsRequest -> T.ThriftVal
from_GetSquareMemberRelationsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2755 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v2755))) $ getSquareMemberRelationsRequest_state record
  , (\_v2755 -> P.Just (3, ("continuationToken",T.TString $ E.encodeUtf8 _v2755))) $ getSquareMemberRelationsRequest_continuationToken record
  , (\_v2755 -> P.Just (4, ("limit",T.TI32 _v2755))) $ getSquareMemberRelationsRequest_limit record
  ]
write_GetSquareMemberRelationsRequest :: T.Protocol p => p -> GetSquareMemberRelationsRequest -> P.IO ()
write_GetSquareMemberRelationsRequest oprot record = T.writeVal oprot $ from_GetSquareMemberRelationsRequest record
encode_GetSquareMemberRelationsRequest :: T.StatelessProtocol p => p -> GetSquareMemberRelationsRequest -> LBS.ByteString
encode_GetSquareMemberRelationsRequest oprot record = T.serializeVal oprot $ from_GetSquareMemberRelationsRequest record
to_GetSquareMemberRelationsRequest :: T.ThriftVal -> GetSquareMemberRelationsRequest
to_GetSquareMemberRelationsRequest (T.TStruct fields) = GetSquareMemberRelationsRequest{
  getSquareMemberRelationsRequest_state = P.maybe (getSquareMemberRelationsRequest_state default_GetSquareMemberRelationsRequest) (\(_,_val2757) -> (case _val2757 of {T.TI32 _val2758 -> P.toEnum $ P.fromIntegral _val2758; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareMemberRelationsRequest_continuationToken = P.maybe (getSquareMemberRelationsRequest_continuationToken default_GetSquareMemberRelationsRequest) (\(_,_val2757) -> (case _val2757 of {T.TString _val2759 -> E.decodeUtf8 _val2759; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getSquareMemberRelationsRequest_limit = P.maybe (getSquareMemberRelationsRequest_limit default_GetSquareMemberRelationsRequest) (\(_,_val2757) -> (case _val2757 of {T.TI32 _val2760 -> _val2760; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetSquareMemberRelationsRequest _ = P.error "not a struct"
read_GetSquareMemberRelationsRequest :: T.Protocol p => p -> P.IO GetSquareMemberRelationsRequest
read_GetSquareMemberRelationsRequest iprot = to_GetSquareMemberRelationsRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationsRequest)
decode_GetSquareMemberRelationsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelationsRequest
decode_GetSquareMemberRelationsRequest iprot bs = to_GetSquareMemberRelationsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationsRequest) bs
typemap_GetSquareMemberRelationsRequest :: T.TypeMap
typemap_GetSquareMemberRelationsRequest = Map.fromList [(2,("state",T.T_I32)),(3,("continuationToken",T.T_STRING)),(4,("limit",T.T_I32))]
default_GetSquareMemberRelationsRequest :: GetSquareMemberRelationsRequest
default_GetSquareMemberRelationsRequest = GetSquareMemberRelationsRequest{
  getSquareMemberRelationsRequest_state = (P.toEnum 0),
  getSquareMemberRelationsRequest_continuationToken = "",
  getSquareMemberRelationsRequest_limit = 0}
data GetSquareMemberRelationsResponse = GetSquareMemberRelationsResponse  { getSquareMemberRelationsResponse_squareMembers :: (Vector.Vector SquareMember)
  , getSquareMemberRelationsResponse_relations :: (Map.HashMap LT.Text SquareMemberRelation)
  , getSquareMemberRelationsResponse_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelationsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelationsResponse_squareMembers record   `H.hashWithSalt` getSquareMemberRelationsResponse_relations record   `H.hashWithSalt` getSquareMemberRelationsResponse_continuationToken record  
instance QC.Arbitrary GetSquareMemberRelationsResponse where 
  arbitrary = M.liftM GetSquareMemberRelationsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelationsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_squareMembers = getSquareMemberRelationsResponse_squareMembers obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_squareMembers = getSquareMemberRelationsResponse_squareMembers obj}
    , if obj == default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_relations = getSquareMemberRelationsResponse_relations obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_relations = getSquareMemberRelationsResponse_relations obj}
    , if obj == default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_continuationToken = getSquareMemberRelationsResponse_continuationToken obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationsResponse{getSquareMemberRelationsResponse_continuationToken = getSquareMemberRelationsResponse_continuationToken obj}
    ]
from_GetSquareMemberRelationsResponse :: GetSquareMemberRelationsResponse -> T.ThriftVal
from_GetSquareMemberRelationsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2763 -> P.Just (1, ("squareMembers",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2765 -> from_SquareMember _v2765) $ Vector.toList _v2763))) $ getSquareMemberRelationsResponse_squareMembers record
  , (\_v2763 -> P.Just (2, ("relations",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareMemberRelation) $ P.map (\(_k2766,_v2767) -> (T.TString $ E.encodeUtf8 _k2766, from_SquareMemberRelation _v2767)) $ Map.toList _v2763))) $ getSquareMemberRelationsResponse_relations record
  , (\_v2763 -> P.Just (3, ("continuationToken",T.TString $ E.encodeUtf8 _v2763))) $ getSquareMemberRelationsResponse_continuationToken record
  ]
write_GetSquareMemberRelationsResponse :: T.Protocol p => p -> GetSquareMemberRelationsResponse -> P.IO ()
write_GetSquareMemberRelationsResponse oprot record = T.writeVal oprot $ from_GetSquareMemberRelationsResponse record
encode_GetSquareMemberRelationsResponse :: T.StatelessProtocol p => p -> GetSquareMemberRelationsResponse -> LBS.ByteString
encode_GetSquareMemberRelationsResponse oprot record = T.serializeVal oprot $ from_GetSquareMemberRelationsResponse record
to_GetSquareMemberRelationsResponse :: T.ThriftVal -> GetSquareMemberRelationsResponse
to_GetSquareMemberRelationsResponse (T.TStruct fields) = GetSquareMemberRelationsResponse{
  getSquareMemberRelationsResponse_squareMembers = P.maybe (getSquareMemberRelationsResponse_squareMembers default_GetSquareMemberRelationsResponse) (\(_,_val2769) -> (case _val2769 of {T.TList _ _val2770 -> (Vector.fromList $ P.map (\_v2771 -> (case _v2771 of {T.TStruct _val2772 -> (to_SquareMember (T.TStruct _val2772)); _ -> P.error "wrong type"})) _val2770); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareMemberRelationsResponse_relations = P.maybe (getSquareMemberRelationsResponse_relations default_GetSquareMemberRelationsResponse) (\(_,_val2769) -> (case _val2769 of {T.TMap _ _ _val2773 -> (Map.fromList $ P.map (\(_k2775,_v2774) -> ((case _k2775 of {T.TString _val2776 -> E.decodeUtf8 _val2776; _ -> P.error "wrong type"}),(case _v2774 of {T.TStruct _val2777 -> (to_SquareMemberRelation (T.TStruct _val2777)); _ -> P.error "wrong type"}))) _val2773); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareMemberRelationsResponse_continuationToken = P.maybe (getSquareMemberRelationsResponse_continuationToken default_GetSquareMemberRelationsResponse) (\(_,_val2769) -> (case _val2769 of {T.TString _val2778 -> E.decodeUtf8 _val2778; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareMemberRelationsResponse _ = P.error "not a struct"
read_GetSquareMemberRelationsResponse :: T.Protocol p => p -> P.IO GetSquareMemberRelationsResponse
read_GetSquareMemberRelationsResponse iprot = to_GetSquareMemberRelationsResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationsResponse)
decode_GetSquareMemberRelationsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelationsResponse
decode_GetSquareMemberRelationsResponse iprot bs = to_GetSquareMemberRelationsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationsResponse) bs
typemap_GetSquareMemberRelationsResponse :: T.TypeMap
typemap_GetSquareMemberRelationsResponse = Map.fromList [(1,("squareMembers",(T.T_LIST (T.T_STRUCT typemap_SquareMember)))),(2,("relations",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareMemberRelation)))),(3,("continuationToken",T.T_STRING))]
default_GetSquareMemberRelationsResponse :: GetSquareMemberRelationsResponse
default_GetSquareMemberRelationsResponse = GetSquareMemberRelationsResponse{
  getSquareMemberRelationsResponse_squareMembers = Vector.empty,
  getSquareMemberRelationsResponse_relations = Map.empty,
  getSquareMemberRelationsResponse_continuationToken = ""}
data GetSquareMemberRelationRequest = GetSquareMemberRelationRequest  { getSquareMemberRelationRequest_squareMid :: LT.Text
  , getSquareMemberRelationRequest_targetSquareMemberMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelationRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelationRequest_squareMid record   `H.hashWithSalt` getSquareMemberRelationRequest_targetSquareMemberMid record  
instance QC.Arbitrary GetSquareMemberRelationRequest where 
  arbitrary = M.liftM GetSquareMemberRelationRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelationRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelationRequest{getSquareMemberRelationRequest_squareMid = getSquareMemberRelationRequest_squareMid obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationRequest{getSquareMemberRelationRequest_squareMid = getSquareMemberRelationRequest_squareMid obj}
    , if obj == default_GetSquareMemberRelationRequest{getSquareMemberRelationRequest_targetSquareMemberMid = getSquareMemberRelationRequest_targetSquareMemberMid obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationRequest{getSquareMemberRelationRequest_targetSquareMemberMid = getSquareMemberRelationRequest_targetSquareMemberMid obj}
    ]
from_GetSquareMemberRelationRequest :: GetSquareMemberRelationRequest -> T.ThriftVal
from_GetSquareMemberRelationRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2781 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2781))) $ getSquareMemberRelationRequest_squareMid record
  , (\_v2781 -> P.Just (3, ("targetSquareMemberMid",T.TString $ E.encodeUtf8 _v2781))) $ getSquareMemberRelationRequest_targetSquareMemberMid record
  ]
write_GetSquareMemberRelationRequest :: T.Protocol p => p -> GetSquareMemberRelationRequest -> P.IO ()
write_GetSquareMemberRelationRequest oprot record = T.writeVal oprot $ from_GetSquareMemberRelationRequest record
encode_GetSquareMemberRelationRequest :: T.StatelessProtocol p => p -> GetSquareMemberRelationRequest -> LBS.ByteString
encode_GetSquareMemberRelationRequest oprot record = T.serializeVal oprot $ from_GetSquareMemberRelationRequest record
to_GetSquareMemberRelationRequest :: T.ThriftVal -> GetSquareMemberRelationRequest
to_GetSquareMemberRelationRequest (T.TStruct fields) = GetSquareMemberRelationRequest{
  getSquareMemberRelationRequest_squareMid = P.maybe (getSquareMemberRelationRequest_squareMid default_GetSquareMemberRelationRequest) (\(_,_val2783) -> (case _val2783 of {T.TString _val2784 -> E.decodeUtf8 _val2784; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareMemberRelationRequest_targetSquareMemberMid = P.maybe (getSquareMemberRelationRequest_targetSquareMemberMid default_GetSquareMemberRelationRequest) (\(_,_val2783) -> (case _val2783 of {T.TString _val2785 -> E.decodeUtf8 _val2785; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareMemberRelationRequest _ = P.error "not a struct"
read_GetSquareMemberRelationRequest :: T.Protocol p => p -> P.IO GetSquareMemberRelationRequest
read_GetSquareMemberRelationRequest iprot = to_GetSquareMemberRelationRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationRequest)
decode_GetSquareMemberRelationRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelationRequest
decode_GetSquareMemberRelationRequest iprot bs = to_GetSquareMemberRelationRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationRequest) bs
typemap_GetSquareMemberRelationRequest :: T.TypeMap
typemap_GetSquareMemberRelationRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("targetSquareMemberMid",T.T_STRING))]
default_GetSquareMemberRelationRequest :: GetSquareMemberRelationRequest
default_GetSquareMemberRelationRequest = GetSquareMemberRelationRequest{
  getSquareMemberRelationRequest_squareMid = "",
  getSquareMemberRelationRequest_targetSquareMemberMid = ""}
data GetSquareMemberRelationResponse = GetSquareMemberRelationResponse  { getSquareMemberRelationResponse_squareMid :: LT.Text
  , getSquareMemberRelationResponse_targetSquareMemberMid :: LT.Text
  , getSquareMemberRelationResponse_relation :: SquareMemberRelation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelationResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelationResponse_squareMid record   `H.hashWithSalt` getSquareMemberRelationResponse_targetSquareMemberMid record   `H.hashWithSalt` getSquareMemberRelationResponse_relation record  
instance QC.Arbitrary GetSquareMemberRelationResponse where 
  arbitrary = M.liftM GetSquareMemberRelationResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelationResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_squareMid = getSquareMemberRelationResponse_squareMid obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_squareMid = getSquareMemberRelationResponse_squareMid obj}
    , if obj == default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_targetSquareMemberMid = getSquareMemberRelationResponse_targetSquareMemberMid obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_targetSquareMemberMid = getSquareMemberRelationResponse_targetSquareMemberMid obj}
    , if obj == default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_relation = getSquareMemberRelationResponse_relation obj} then P.Nothing else P.Just $ default_GetSquareMemberRelationResponse{getSquareMemberRelationResponse_relation = getSquareMemberRelationResponse_relation obj}
    ]
from_GetSquareMemberRelationResponse :: GetSquareMemberRelationResponse -> T.ThriftVal
from_GetSquareMemberRelationResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2788 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v2788))) $ getSquareMemberRelationResponse_squareMid record
  , (\_v2788 -> P.Just (2, ("targetSquareMemberMid",T.TString $ E.encodeUtf8 _v2788))) $ getSquareMemberRelationResponse_targetSquareMemberMid record
  , (\_v2788 -> P.Just (3, ("relation",from_SquareMemberRelation _v2788))) $ getSquareMemberRelationResponse_relation record
  ]
write_GetSquareMemberRelationResponse :: T.Protocol p => p -> GetSquareMemberRelationResponse -> P.IO ()
write_GetSquareMemberRelationResponse oprot record = T.writeVal oprot $ from_GetSquareMemberRelationResponse record
encode_GetSquareMemberRelationResponse :: T.StatelessProtocol p => p -> GetSquareMemberRelationResponse -> LBS.ByteString
encode_GetSquareMemberRelationResponse oprot record = T.serializeVal oprot $ from_GetSquareMemberRelationResponse record
to_GetSquareMemberRelationResponse :: T.ThriftVal -> GetSquareMemberRelationResponse
to_GetSquareMemberRelationResponse (T.TStruct fields) = GetSquareMemberRelationResponse{
  getSquareMemberRelationResponse_squareMid = P.maybe (getSquareMemberRelationResponse_squareMid default_GetSquareMemberRelationResponse) (\(_,_val2790) -> (case _val2790 of {T.TString _val2791 -> E.decodeUtf8 _val2791; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareMemberRelationResponse_targetSquareMemberMid = P.maybe (getSquareMemberRelationResponse_targetSquareMemberMid default_GetSquareMemberRelationResponse) (\(_,_val2790) -> (case _val2790 of {T.TString _val2792 -> E.decodeUtf8 _val2792; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareMemberRelationResponse_relation = P.maybe (getSquareMemberRelationResponse_relation default_GetSquareMemberRelationResponse) (\(_,_val2790) -> (case _val2790 of {T.TStruct _val2793 -> (to_SquareMemberRelation (T.TStruct _val2793)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSquareMemberRelationResponse _ = P.error "not a struct"
read_GetSquareMemberRelationResponse :: T.Protocol p => p -> P.IO GetSquareMemberRelationResponse
read_GetSquareMemberRelationResponse iprot = to_GetSquareMemberRelationResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationResponse)
decode_GetSquareMemberRelationResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelationResponse
decode_GetSquareMemberRelationResponse iprot bs = to_GetSquareMemberRelationResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelationResponse) bs
typemap_GetSquareMemberRelationResponse :: T.TypeMap
typemap_GetSquareMemberRelationResponse = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("targetSquareMemberMid",T.T_STRING)),(3,("relation",(T.T_STRUCT typemap_SquareMemberRelation)))]
default_GetSquareMemberRelationResponse :: GetSquareMemberRelationResponse
default_GetSquareMemberRelationResponse = GetSquareMemberRelationResponse{
  getSquareMemberRelationResponse_squareMid = "",
  getSquareMemberRelationResponse_targetSquareMemberMid = "",
  getSquareMemberRelationResponse_relation = default_SquareMemberRelation}
data Category = Category  { category_id :: I.Int32
  , category_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Category where
  hashWithSalt salt record = salt   `H.hashWithSalt` category_id record   `H.hashWithSalt` category_name record  
instance QC.Arbitrary Category where 
  arbitrary = M.liftM Category (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Category = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Category{category_id = category_id obj} then P.Nothing else P.Just $ default_Category{category_id = category_id obj}
    , if obj == default_Category{category_name = category_name obj} then P.Nothing else P.Just $ default_Category{category_name = category_name obj}
    ]
from_Category :: Category -> T.ThriftVal
from_Category record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2796 -> P.Just (1, ("id",T.TI32 _v2796))) $ category_id record
  , (\_v2796 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v2796))) $ category_name record
  ]
write_Category :: T.Protocol p => p -> Category -> P.IO ()
write_Category oprot record = T.writeVal oprot $ from_Category record
encode_Category :: T.StatelessProtocol p => p -> Category -> LBS.ByteString
encode_Category oprot record = T.serializeVal oprot $ from_Category record
to_Category :: T.ThriftVal -> Category
to_Category (T.TStruct fields) = Category{
  category_id = P.maybe (category_id default_Category) (\(_,_val2798) -> (case _val2798 of {T.TI32 _val2799 -> _val2799; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  category_name = P.maybe (category_name default_Category) (\(_,_val2798) -> (case _val2798 of {T.TString _val2800 -> E.decodeUtf8 _val2800; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_Category _ = P.error "not a struct"
read_Category :: T.Protocol p => p -> P.IO Category
read_Category iprot = to_Category <$> T.readVal iprot (T.T_STRUCT typemap_Category)
decode_Category :: T.StatelessProtocol p => p -> LBS.ByteString -> Category
decode_Category iprot bs = to_Category $ T.deserializeVal iprot (T.T_STRUCT typemap_Category) bs
typemap_Category :: T.TypeMap
typemap_Category = Map.fromList [(1,("id",T.T_I32)),(2,("name",T.T_STRING))]
default_Category :: Category
default_Category = Category{
  category_id = 0,
  category_name = ""}
data GetSquareCategoriesRequest = GetSquareCategoriesRequest deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareCategoriesRequest where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSquareCategoriesRequest where 
  arbitrary = QC.elements [GetSquareCategoriesRequest]
from_GetSquareCategoriesRequest :: GetSquareCategoriesRequest -> T.ThriftVal
from_GetSquareCategoriesRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSquareCategoriesRequest :: T.Protocol p => p -> GetSquareCategoriesRequest -> P.IO ()
write_GetSquareCategoriesRequest oprot record = T.writeVal oprot $ from_GetSquareCategoriesRequest record
encode_GetSquareCategoriesRequest :: T.StatelessProtocol p => p -> GetSquareCategoriesRequest -> LBS.ByteString
encode_GetSquareCategoriesRequest oprot record = T.serializeVal oprot $ from_GetSquareCategoriesRequest record
to_GetSquareCategoriesRequest :: T.ThriftVal -> GetSquareCategoriesRequest
to_GetSquareCategoriesRequest (T.TStruct fields) = GetSquareCategoriesRequest{

  }
to_GetSquareCategoriesRequest _ = P.error "not a struct"
read_GetSquareCategoriesRequest :: T.Protocol p => p -> P.IO GetSquareCategoriesRequest
read_GetSquareCategoriesRequest iprot = to_GetSquareCategoriesRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareCategoriesRequest)
decode_GetSquareCategoriesRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareCategoriesRequest
decode_GetSquareCategoriesRequest iprot bs = to_GetSquareCategoriesRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareCategoriesRequest) bs
typemap_GetSquareCategoriesRequest :: T.TypeMap
typemap_GetSquareCategoriesRequest = Map.fromList []
default_GetSquareCategoriesRequest :: GetSquareCategoriesRequest
default_GetSquareCategoriesRequest = GetSquareCategoriesRequest{
}
data GetSquareCategoriesResponse = GetSquareCategoriesResponse  { getSquareCategoriesResponse_categoryList :: (Vector.Vector Category)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareCategoriesResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareCategoriesResponse_categoryList record  
instance QC.Arbitrary GetSquareCategoriesResponse where 
  arbitrary = M.liftM GetSquareCategoriesResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareCategoriesResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareCategoriesResponse{getSquareCategoriesResponse_categoryList = getSquareCategoriesResponse_categoryList obj} then P.Nothing else P.Just $ default_GetSquareCategoriesResponse{getSquareCategoriesResponse_categoryList = getSquareCategoriesResponse_categoryList obj}
    ]
from_GetSquareCategoriesResponse :: GetSquareCategoriesResponse -> T.ThriftVal
from_GetSquareCategoriesResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2808 -> P.Just (1, ("categoryList",T.TList (T.T_STRUCT typemap_Category) $ P.map (\_v2810 -> from_Category _v2810) $ Vector.toList _v2808))) $ getSquareCategoriesResponse_categoryList record
  ]
write_GetSquareCategoriesResponse :: T.Protocol p => p -> GetSquareCategoriesResponse -> P.IO ()
write_GetSquareCategoriesResponse oprot record = T.writeVal oprot $ from_GetSquareCategoriesResponse record
encode_GetSquareCategoriesResponse :: T.StatelessProtocol p => p -> GetSquareCategoriesResponse -> LBS.ByteString
encode_GetSquareCategoriesResponse oprot record = T.serializeVal oprot $ from_GetSquareCategoriesResponse record
to_GetSquareCategoriesResponse :: T.ThriftVal -> GetSquareCategoriesResponse
to_GetSquareCategoriesResponse (T.TStruct fields) = GetSquareCategoriesResponse{
  getSquareCategoriesResponse_categoryList = P.maybe (getSquareCategoriesResponse_categoryList default_GetSquareCategoriesResponse) (\(_,_val2812) -> (case _val2812 of {T.TList _ _val2813 -> (Vector.fromList $ P.map (\_v2814 -> (case _v2814 of {T.TStruct _val2815 -> (to_Category (T.TStruct _val2815)); _ -> P.error "wrong type"})) _val2813); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareCategoriesResponse _ = P.error "not a struct"
read_GetSquareCategoriesResponse :: T.Protocol p => p -> P.IO GetSquareCategoriesResponse
read_GetSquareCategoriesResponse iprot = to_GetSquareCategoriesResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareCategoriesResponse)
decode_GetSquareCategoriesResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareCategoriesResponse
decode_GetSquareCategoriesResponse iprot bs = to_GetSquareCategoriesResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareCategoriesResponse) bs
typemap_GetSquareCategoriesResponse :: T.TypeMap
typemap_GetSquareCategoriesResponse = Map.fromList [(1,("categoryList",(T.T_LIST (T.T_STRUCT typemap_Category))))]
default_GetSquareCategoriesResponse :: GetSquareCategoriesResponse
default_GetSquareCategoriesResponse = GetSquareCategoriesResponse{
  getSquareCategoriesResponse_categoryList = Vector.empty}
data UpdateSquareRequest = UpdateSquareRequest  { updateSquareRequest_updatedAttrs :: (Set.HashSet SquareAttribute)
  , updateSquareRequest_square :: Square
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareRequest_updatedAttrs record   `H.hashWithSalt` updateSquareRequest_square record  
instance QC.Arbitrary UpdateSquareRequest where 
  arbitrary = M.liftM UpdateSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareRequest{updateSquareRequest_updatedAttrs = updateSquareRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareRequest{updateSquareRequest_updatedAttrs = updateSquareRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareRequest{updateSquareRequest_square = updateSquareRequest_square obj} then P.Nothing else P.Just $ default_UpdateSquareRequest{updateSquareRequest_square = updateSquareRequest_square obj}
    ]
from_UpdateSquareRequest :: UpdateSquareRequest -> T.ThriftVal
from_UpdateSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2818 -> P.Just (2, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2820 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2820) $ Set.toList _v2818))) $ updateSquareRequest_updatedAttrs record
  , (\_v2818 -> P.Just (3, ("square",from_Square _v2818))) $ updateSquareRequest_square record
  ]
write_UpdateSquareRequest :: T.Protocol p => p -> UpdateSquareRequest -> P.IO ()
write_UpdateSquareRequest oprot record = T.writeVal oprot $ from_UpdateSquareRequest record
encode_UpdateSquareRequest :: T.StatelessProtocol p => p -> UpdateSquareRequest -> LBS.ByteString
encode_UpdateSquareRequest oprot record = T.serializeVal oprot $ from_UpdateSquareRequest record
to_UpdateSquareRequest :: T.ThriftVal -> UpdateSquareRequest
to_UpdateSquareRequest (T.TStruct fields) = UpdateSquareRequest{
  updateSquareRequest_updatedAttrs = P.maybe (updateSquareRequest_updatedAttrs default_UpdateSquareRequest) (\(_,_val2822) -> (case _val2822 of {T.TSet _ _val2823 -> (Set.fromList $ P.map (\_v2824 -> (case _v2824 of {T.TI32 _val2825 -> P.toEnum $ P.fromIntegral _val2825; _ -> P.error "wrong type"})) _val2823); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareRequest_square = P.maybe (updateSquareRequest_square default_UpdateSquareRequest) (\(_,_val2822) -> (case _val2822 of {T.TStruct _val2826 -> (to_Square (T.TStruct _val2826)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareRequest _ = P.error "not a struct"
read_UpdateSquareRequest :: T.Protocol p => p -> P.IO UpdateSquareRequest
read_UpdateSquareRequest iprot = to_UpdateSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareRequest)
decode_UpdateSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareRequest
decode_UpdateSquareRequest iprot bs = to_UpdateSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareRequest) bs
typemap_UpdateSquareRequest :: T.TypeMap
typemap_UpdateSquareRequest = Map.fromList [(2,("updatedAttrs",(T.T_SET T.T_I32))),(3,("square",(T.T_STRUCT typemap_Square)))]
default_UpdateSquareRequest :: UpdateSquareRequest
default_UpdateSquareRequest = UpdateSquareRequest{
  updateSquareRequest_updatedAttrs = Set.empty,
  updateSquareRequest_square = default_Square}
data UpdateSquareResponse = UpdateSquareResponse  { updateSquareResponse_updatedAttrs :: (Set.HashSet SquareAttribute)
  , updateSquareResponse_square :: Square
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareResponse_updatedAttrs record   `H.hashWithSalt` updateSquareResponse_square record  
instance QC.Arbitrary UpdateSquareResponse where 
  arbitrary = M.liftM UpdateSquareResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareResponse{updateSquareResponse_updatedAttrs = updateSquareResponse_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareResponse{updateSquareResponse_updatedAttrs = updateSquareResponse_updatedAttrs obj}
    , if obj == default_UpdateSquareResponse{updateSquareResponse_square = updateSquareResponse_square obj} then P.Nothing else P.Just $ default_UpdateSquareResponse{updateSquareResponse_square = updateSquareResponse_square obj}
    ]
from_UpdateSquareResponse :: UpdateSquareResponse -> T.ThriftVal
from_UpdateSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2829 -> P.Just (1, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2831 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2831) $ Set.toList _v2829))) $ updateSquareResponse_updatedAttrs record
  , (\_v2829 -> P.Just (2, ("square",from_Square _v2829))) $ updateSquareResponse_square record
  ]
write_UpdateSquareResponse :: T.Protocol p => p -> UpdateSquareResponse -> P.IO ()
write_UpdateSquareResponse oprot record = T.writeVal oprot $ from_UpdateSquareResponse record
encode_UpdateSquareResponse :: T.StatelessProtocol p => p -> UpdateSquareResponse -> LBS.ByteString
encode_UpdateSquareResponse oprot record = T.serializeVal oprot $ from_UpdateSquareResponse record
to_UpdateSquareResponse :: T.ThriftVal -> UpdateSquareResponse
to_UpdateSquareResponse (T.TStruct fields) = UpdateSquareResponse{
  updateSquareResponse_updatedAttrs = P.maybe (updateSquareResponse_updatedAttrs default_UpdateSquareResponse) (\(_,_val2833) -> (case _val2833 of {T.TSet _ _val2834 -> (Set.fromList $ P.map (\_v2835 -> (case _v2835 of {T.TI32 _val2836 -> P.toEnum $ P.fromIntegral _val2836; _ -> P.error "wrong type"})) _val2834); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareResponse_square = P.maybe (updateSquareResponse_square default_UpdateSquareResponse) (\(_,_val2833) -> (case _val2833 of {T.TStruct _val2837 -> (to_Square (T.TStruct _val2837)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSquareResponse _ = P.error "not a struct"
read_UpdateSquareResponse :: T.Protocol p => p -> P.IO UpdateSquareResponse
read_UpdateSquareResponse iprot = to_UpdateSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareResponse)
decode_UpdateSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareResponse
decode_UpdateSquareResponse iprot bs = to_UpdateSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareResponse) bs
typemap_UpdateSquareResponse :: T.TypeMap
typemap_UpdateSquareResponse = Map.fromList [(1,("updatedAttrs",(T.T_SET T.T_I32))),(2,("square",(T.T_STRUCT typemap_Square)))]
default_UpdateSquareResponse :: UpdateSquareResponse
default_UpdateSquareResponse = UpdateSquareResponse{
  updateSquareResponse_updatedAttrs = Set.empty,
  updateSquareResponse_square = default_Square}
data SearchSquaresRequest = SearchSquaresRequest  { searchSquaresRequest_query :: LT.Text
  , searchSquaresRequest_continuationToken :: LT.Text
  , searchSquaresRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquaresRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquaresRequest_query record   `H.hashWithSalt` searchSquaresRequest_continuationToken record   `H.hashWithSalt` searchSquaresRequest_limit record  
instance QC.Arbitrary SearchSquaresRequest where 
  arbitrary = M.liftM SearchSquaresRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchSquaresRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquaresRequest{searchSquaresRequest_query = searchSquaresRequest_query obj} then P.Nothing else P.Just $ default_SearchSquaresRequest{searchSquaresRequest_query = searchSquaresRequest_query obj}
    , if obj == default_SearchSquaresRequest{searchSquaresRequest_continuationToken = searchSquaresRequest_continuationToken obj} then P.Nothing else P.Just $ default_SearchSquaresRequest{searchSquaresRequest_continuationToken = searchSquaresRequest_continuationToken obj}
    , if obj == default_SearchSquaresRequest{searchSquaresRequest_limit = searchSquaresRequest_limit obj} then P.Nothing else P.Just $ default_SearchSquaresRequest{searchSquaresRequest_limit = searchSquaresRequest_limit obj}
    ]
from_SearchSquaresRequest :: SearchSquaresRequest -> T.ThriftVal
from_SearchSquaresRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2840 -> P.Just (2, ("query",T.TString $ E.encodeUtf8 _v2840))) $ searchSquaresRequest_query record
  , (\_v2840 -> P.Just (3, ("continuationToken",T.TString $ E.encodeUtf8 _v2840))) $ searchSquaresRequest_continuationToken record
  , (\_v2840 -> P.Just (4, ("limit",T.TI32 _v2840))) $ searchSquaresRequest_limit record
  ]
write_SearchSquaresRequest :: T.Protocol p => p -> SearchSquaresRequest -> P.IO ()
write_SearchSquaresRequest oprot record = T.writeVal oprot $ from_SearchSquaresRequest record
encode_SearchSquaresRequest :: T.StatelessProtocol p => p -> SearchSquaresRequest -> LBS.ByteString
encode_SearchSquaresRequest oprot record = T.serializeVal oprot $ from_SearchSquaresRequest record
to_SearchSquaresRequest :: T.ThriftVal -> SearchSquaresRequest
to_SearchSquaresRequest (T.TStruct fields) = SearchSquaresRequest{
  searchSquaresRequest_query = P.maybe (searchSquaresRequest_query default_SearchSquaresRequest) (\(_,_val2842) -> (case _val2842 of {T.TString _val2843 -> E.decodeUtf8 _val2843; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchSquaresRequest_continuationToken = P.maybe (searchSquaresRequest_continuationToken default_SearchSquaresRequest) (\(_,_val2842) -> (case _val2842 of {T.TString _val2844 -> E.decodeUtf8 _val2844; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchSquaresRequest_limit = P.maybe (searchSquaresRequest_limit default_SearchSquaresRequest) (\(_,_val2842) -> (case _val2842 of {T.TI32 _val2845 -> _val2845; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SearchSquaresRequest _ = P.error "not a struct"
read_SearchSquaresRequest :: T.Protocol p => p -> P.IO SearchSquaresRequest
read_SearchSquaresRequest iprot = to_SearchSquaresRequest <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquaresRequest)
decode_SearchSquaresRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquaresRequest
decode_SearchSquaresRequest iprot bs = to_SearchSquaresRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquaresRequest) bs
typemap_SearchSquaresRequest :: T.TypeMap
typemap_SearchSquaresRequest = Map.fromList [(2,("query",T.T_STRING)),(3,("continuationToken",T.T_STRING)),(4,("limit",T.T_I32))]
default_SearchSquaresRequest :: SearchSquaresRequest
default_SearchSquaresRequest = SearchSquaresRequest{
  searchSquaresRequest_query = "",
  searchSquaresRequest_continuationToken = "",
  searchSquaresRequest_limit = 0}
data SearchSquaresResponse = SearchSquaresResponse  { searchSquaresResponse_squares :: (Vector.Vector Square)
  , searchSquaresResponse_squareStatuses :: (Map.HashMap LT.Text SquareStatus)
  , searchSquaresResponse_myMemberships :: (Map.HashMap LT.Text SquareMember)
  , searchSquaresResponse_continuationToken :: LT.Text
  , searchSquaresResponse_noteStatuses :: (Map.HashMap LT.Text NoteStatus)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquaresResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquaresResponse_squares record   `H.hashWithSalt` searchSquaresResponse_squareStatuses record   `H.hashWithSalt` searchSquaresResponse_myMemberships record   `H.hashWithSalt` searchSquaresResponse_continuationToken record   `H.hashWithSalt` searchSquaresResponse_noteStatuses record  
instance QC.Arbitrary SearchSquaresResponse where 
  arbitrary = M.liftM SearchSquaresResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchSquaresResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquaresResponse{searchSquaresResponse_squares = searchSquaresResponse_squares obj} then P.Nothing else P.Just $ default_SearchSquaresResponse{searchSquaresResponse_squares = searchSquaresResponse_squares obj}
    , if obj == default_SearchSquaresResponse{searchSquaresResponse_squareStatuses = searchSquaresResponse_squareStatuses obj} then P.Nothing else P.Just $ default_SearchSquaresResponse{searchSquaresResponse_squareStatuses = searchSquaresResponse_squareStatuses obj}
    , if obj == default_SearchSquaresResponse{searchSquaresResponse_myMemberships = searchSquaresResponse_myMemberships obj} then P.Nothing else P.Just $ default_SearchSquaresResponse{searchSquaresResponse_myMemberships = searchSquaresResponse_myMemberships obj}
    , if obj == default_SearchSquaresResponse{searchSquaresResponse_continuationToken = searchSquaresResponse_continuationToken obj} then P.Nothing else P.Just $ default_SearchSquaresResponse{searchSquaresResponse_continuationToken = searchSquaresResponse_continuationToken obj}
    , if obj == default_SearchSquaresResponse{searchSquaresResponse_noteStatuses = searchSquaresResponse_noteStatuses obj} then P.Nothing else P.Just $ default_SearchSquaresResponse{searchSquaresResponse_noteStatuses = searchSquaresResponse_noteStatuses obj}
    ]
from_SearchSquaresResponse :: SearchSquaresResponse -> T.ThriftVal
from_SearchSquaresResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2848 -> P.Just (1, ("squares",T.TList (T.T_STRUCT typemap_Square) $ P.map (\_v2850 -> from_Square _v2850) $ Vector.toList _v2848))) $ searchSquaresResponse_squares record
  , (\_v2848 -> P.Just (2, ("squareStatuses",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareStatus) $ P.map (\(_k2851,_v2852) -> (T.TString $ E.encodeUtf8 _k2851, from_SquareStatus _v2852)) $ Map.toList _v2848))) $ searchSquaresResponse_squareStatuses record
  , (\_v2848 -> P.Just (3, ("myMemberships",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareMember) $ P.map (\(_k2853,_v2854) -> (T.TString $ E.encodeUtf8 _k2853, from_SquareMember _v2854)) $ Map.toList _v2848))) $ searchSquaresResponse_myMemberships record
  , (\_v2848 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v2848))) $ searchSquaresResponse_continuationToken record
  , (\_v2848 -> P.Just (5, ("noteStatuses",T.TMap T.T_STRING (T.T_STRUCT typemap_NoteStatus) $ P.map (\(_k2855,_v2856) -> (T.TString $ E.encodeUtf8 _k2855, from_NoteStatus _v2856)) $ Map.toList _v2848))) $ searchSquaresResponse_noteStatuses record
  ]
write_SearchSquaresResponse :: T.Protocol p => p -> SearchSquaresResponse -> P.IO ()
write_SearchSquaresResponse oprot record = T.writeVal oprot $ from_SearchSquaresResponse record
encode_SearchSquaresResponse :: T.StatelessProtocol p => p -> SearchSquaresResponse -> LBS.ByteString
encode_SearchSquaresResponse oprot record = T.serializeVal oprot $ from_SearchSquaresResponse record
to_SearchSquaresResponse :: T.ThriftVal -> SearchSquaresResponse
to_SearchSquaresResponse (T.TStruct fields) = SearchSquaresResponse{
  searchSquaresResponse_squares = P.maybe (searchSquaresResponse_squares default_SearchSquaresResponse) (\(_,_val2858) -> (case _val2858 of {T.TList _ _val2859 -> (Vector.fromList $ P.map (\_v2860 -> (case _v2860 of {T.TStruct _val2861 -> (to_Square (T.TStruct _val2861)); _ -> P.error "wrong type"})) _val2859); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  searchSquaresResponse_squareStatuses = P.maybe (searchSquaresResponse_squareStatuses default_SearchSquaresResponse) (\(_,_val2858) -> (case _val2858 of {T.TMap _ _ _val2862 -> (Map.fromList $ P.map (\(_k2864,_v2863) -> ((case _k2864 of {T.TString _val2865 -> E.decodeUtf8 _val2865; _ -> P.error "wrong type"}),(case _v2863 of {T.TStruct _val2866 -> (to_SquareStatus (T.TStruct _val2866)); _ -> P.error "wrong type"}))) _val2862); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchSquaresResponse_myMemberships = P.maybe (searchSquaresResponse_myMemberships default_SearchSquaresResponse) (\(_,_val2858) -> (case _val2858 of {T.TMap _ _ _val2867 -> (Map.fromList $ P.map (\(_k2869,_v2868) -> ((case _k2869 of {T.TString _val2870 -> E.decodeUtf8 _val2870; _ -> P.error "wrong type"}),(case _v2868 of {T.TStruct _val2871 -> (to_SquareMember (T.TStruct _val2871)); _ -> P.error "wrong type"}))) _val2867); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  searchSquaresResponse_continuationToken = P.maybe (searchSquaresResponse_continuationToken default_SearchSquaresResponse) (\(_,_val2858) -> (case _val2858 of {T.TString _val2872 -> E.decodeUtf8 _val2872; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  searchSquaresResponse_noteStatuses = P.maybe (searchSquaresResponse_noteStatuses default_SearchSquaresResponse) (\(_,_val2858) -> (case _val2858 of {T.TMap _ _ _val2873 -> (Map.fromList $ P.map (\(_k2875,_v2874) -> ((case _k2875 of {T.TString _val2876 -> E.decodeUtf8 _val2876; _ -> P.error "wrong type"}),(case _v2874 of {T.TStruct _val2877 -> (to_NoteStatus (T.TStruct _val2877)); _ -> P.error "wrong type"}))) _val2873); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_SearchSquaresResponse _ = P.error "not a struct"
read_SearchSquaresResponse :: T.Protocol p => p -> P.IO SearchSquaresResponse
read_SearchSquaresResponse iprot = to_SearchSquaresResponse <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquaresResponse)
decode_SearchSquaresResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquaresResponse
decode_SearchSquaresResponse iprot bs = to_SearchSquaresResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquaresResponse) bs
typemap_SearchSquaresResponse :: T.TypeMap
typemap_SearchSquaresResponse = Map.fromList [(1,("squares",(T.T_LIST (T.T_STRUCT typemap_Square)))),(2,("squareStatuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareStatus)))),(3,("myMemberships",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareMember)))),(4,("continuationToken",T.T_STRING)),(5,("noteStatuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_NoteStatus))))]
default_SearchSquaresResponse :: SearchSquaresResponse
default_SearchSquaresResponse = SearchSquaresResponse{
  searchSquaresResponse_squares = Vector.empty,
  searchSquaresResponse_squareStatuses = Map.empty,
  searchSquaresResponse_myMemberships = Map.empty,
  searchSquaresResponse_continuationToken = "",
  searchSquaresResponse_noteStatuses = Map.empty}
data GetSquareFeatureSetRequest = GetSquareFeatureSetRequest  { getSquareFeatureSetRequest_squareMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareFeatureSetRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareFeatureSetRequest_squareMid record  
instance QC.Arbitrary GetSquareFeatureSetRequest where 
  arbitrary = M.liftM GetSquareFeatureSetRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareFeatureSetRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareFeatureSetRequest{getSquareFeatureSetRequest_squareMid = getSquareFeatureSetRequest_squareMid obj} then P.Nothing else P.Just $ default_GetSquareFeatureSetRequest{getSquareFeatureSetRequest_squareMid = getSquareFeatureSetRequest_squareMid obj}
    ]
from_GetSquareFeatureSetRequest :: GetSquareFeatureSetRequest -> T.ThriftVal
from_GetSquareFeatureSetRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2880 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2880))) $ getSquareFeatureSetRequest_squareMid record
  ]
write_GetSquareFeatureSetRequest :: T.Protocol p => p -> GetSquareFeatureSetRequest -> P.IO ()
write_GetSquareFeatureSetRequest oprot record = T.writeVal oprot $ from_GetSquareFeatureSetRequest record
encode_GetSquareFeatureSetRequest :: T.StatelessProtocol p => p -> GetSquareFeatureSetRequest -> LBS.ByteString
encode_GetSquareFeatureSetRequest oprot record = T.serializeVal oprot $ from_GetSquareFeatureSetRequest record
to_GetSquareFeatureSetRequest :: T.ThriftVal -> GetSquareFeatureSetRequest
to_GetSquareFeatureSetRequest (T.TStruct fields) = GetSquareFeatureSetRequest{
  getSquareFeatureSetRequest_squareMid = P.maybe (getSquareFeatureSetRequest_squareMid default_GetSquareFeatureSetRequest) (\(_,_val2882) -> (case _val2882 of {T.TString _val2883 -> E.decodeUtf8 _val2883; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareFeatureSetRequest _ = P.error "not a struct"
read_GetSquareFeatureSetRequest :: T.Protocol p => p -> P.IO GetSquareFeatureSetRequest
read_GetSquareFeatureSetRequest iprot = to_GetSquareFeatureSetRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareFeatureSetRequest)
decode_GetSquareFeatureSetRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareFeatureSetRequest
decode_GetSquareFeatureSetRequest iprot bs = to_GetSquareFeatureSetRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareFeatureSetRequest) bs
typemap_GetSquareFeatureSetRequest :: T.TypeMap
typemap_GetSquareFeatureSetRequest = Map.fromList [(2,("squareMid",T.T_STRING))]
default_GetSquareFeatureSetRequest :: GetSquareFeatureSetRequest
default_GetSquareFeatureSetRequest = GetSquareFeatureSetRequest{
  getSquareFeatureSetRequest_squareMid = ""}
data GetSquareFeatureSetResponse = GetSquareFeatureSetResponse  { getSquareFeatureSetResponse_squareFeatureSet :: SquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareFeatureSetResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareFeatureSetResponse_squareFeatureSet record  
instance QC.Arbitrary GetSquareFeatureSetResponse where 
  arbitrary = M.liftM GetSquareFeatureSetResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareFeatureSetResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareFeatureSetResponse{getSquareFeatureSetResponse_squareFeatureSet = getSquareFeatureSetResponse_squareFeatureSet obj} then P.Nothing else P.Just $ default_GetSquareFeatureSetResponse{getSquareFeatureSetResponse_squareFeatureSet = getSquareFeatureSetResponse_squareFeatureSet obj}
    ]
from_GetSquareFeatureSetResponse :: GetSquareFeatureSetResponse -> T.ThriftVal
from_GetSquareFeatureSetResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2886 -> P.Just (1, ("squareFeatureSet",from_SquareFeatureSet _v2886))) $ getSquareFeatureSetResponse_squareFeatureSet record
  ]
write_GetSquareFeatureSetResponse :: T.Protocol p => p -> GetSquareFeatureSetResponse -> P.IO ()
write_GetSquareFeatureSetResponse oprot record = T.writeVal oprot $ from_GetSquareFeatureSetResponse record
encode_GetSquareFeatureSetResponse :: T.StatelessProtocol p => p -> GetSquareFeatureSetResponse -> LBS.ByteString
encode_GetSquareFeatureSetResponse oprot record = T.serializeVal oprot $ from_GetSquareFeatureSetResponse record
to_GetSquareFeatureSetResponse :: T.ThriftVal -> GetSquareFeatureSetResponse
to_GetSquareFeatureSetResponse (T.TStruct fields) = GetSquareFeatureSetResponse{
  getSquareFeatureSetResponse_squareFeatureSet = P.maybe (getSquareFeatureSetResponse_squareFeatureSet default_GetSquareFeatureSetResponse) (\(_,_val2888) -> (case _val2888 of {T.TStruct _val2889 -> (to_SquareFeatureSet (T.TStruct _val2889)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareFeatureSetResponse _ = P.error "not a struct"
read_GetSquareFeatureSetResponse :: T.Protocol p => p -> P.IO GetSquareFeatureSetResponse
read_GetSquareFeatureSetResponse iprot = to_GetSquareFeatureSetResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareFeatureSetResponse)
decode_GetSquareFeatureSetResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareFeatureSetResponse
decode_GetSquareFeatureSetResponse iprot bs = to_GetSquareFeatureSetResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareFeatureSetResponse) bs
typemap_GetSquareFeatureSetResponse :: T.TypeMap
typemap_GetSquareFeatureSetResponse = Map.fromList [(1,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet)))]
default_GetSquareFeatureSetResponse :: GetSquareFeatureSetResponse
default_GetSquareFeatureSetResponse = GetSquareFeatureSetResponse{
  getSquareFeatureSetResponse_squareFeatureSet = default_SquareFeatureSet}
data UpdateSquareFeatureSetRequest = UpdateSquareFeatureSetRequest  { updateSquareFeatureSetRequest_updateAttributes :: (Set.HashSet SquareFeatureSetAttribute)
  , updateSquareFeatureSetRequest_squareFeatureSet :: SquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareFeatureSetRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareFeatureSetRequest_updateAttributes record   `H.hashWithSalt` updateSquareFeatureSetRequest_squareFeatureSet record  
instance QC.Arbitrary UpdateSquareFeatureSetRequest where 
  arbitrary = M.liftM UpdateSquareFeatureSetRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareFeatureSetRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareFeatureSetRequest{updateSquareFeatureSetRequest_updateAttributes = updateSquareFeatureSetRequest_updateAttributes obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSetRequest{updateSquareFeatureSetRequest_updateAttributes = updateSquareFeatureSetRequest_updateAttributes obj}
    , if obj == default_UpdateSquareFeatureSetRequest{updateSquareFeatureSetRequest_squareFeatureSet = updateSquareFeatureSetRequest_squareFeatureSet obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSetRequest{updateSquareFeatureSetRequest_squareFeatureSet = updateSquareFeatureSetRequest_squareFeatureSet obj}
    ]
from_UpdateSquareFeatureSetRequest :: UpdateSquareFeatureSetRequest -> T.ThriftVal
from_UpdateSquareFeatureSetRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2892 -> P.Just (2, ("updateAttributes",T.TSet T.T_I32 $ P.map (\_v2894 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2894) $ Set.toList _v2892))) $ updateSquareFeatureSetRequest_updateAttributes record
  , (\_v2892 -> P.Just (3, ("squareFeatureSet",from_SquareFeatureSet _v2892))) $ updateSquareFeatureSetRequest_squareFeatureSet record
  ]
write_UpdateSquareFeatureSetRequest :: T.Protocol p => p -> UpdateSquareFeatureSetRequest -> P.IO ()
write_UpdateSquareFeatureSetRequest oprot record = T.writeVal oprot $ from_UpdateSquareFeatureSetRequest record
encode_UpdateSquareFeatureSetRequest :: T.StatelessProtocol p => p -> UpdateSquareFeatureSetRequest -> LBS.ByteString
encode_UpdateSquareFeatureSetRequest oprot record = T.serializeVal oprot $ from_UpdateSquareFeatureSetRequest record
to_UpdateSquareFeatureSetRequest :: T.ThriftVal -> UpdateSquareFeatureSetRequest
to_UpdateSquareFeatureSetRequest (T.TStruct fields) = UpdateSquareFeatureSetRequest{
  updateSquareFeatureSetRequest_updateAttributes = P.maybe (updateSquareFeatureSetRequest_updateAttributes default_UpdateSquareFeatureSetRequest) (\(_,_val2896) -> (case _val2896 of {T.TSet _ _val2897 -> (Set.fromList $ P.map (\_v2898 -> (case _v2898 of {T.TI32 _val2899 -> P.toEnum $ P.fromIntegral _val2899; _ -> P.error "wrong type"})) _val2897); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareFeatureSetRequest_squareFeatureSet = P.maybe (updateSquareFeatureSetRequest_squareFeatureSet default_UpdateSquareFeatureSetRequest) (\(_,_val2896) -> (case _val2896 of {T.TStruct _val2900 -> (to_SquareFeatureSet (T.TStruct _val2900)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareFeatureSetRequest _ = P.error "not a struct"
read_UpdateSquareFeatureSetRequest :: T.Protocol p => p -> P.IO UpdateSquareFeatureSetRequest
read_UpdateSquareFeatureSetRequest iprot = to_UpdateSquareFeatureSetRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSetRequest)
decode_UpdateSquareFeatureSetRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareFeatureSetRequest
decode_UpdateSquareFeatureSetRequest iprot bs = to_UpdateSquareFeatureSetRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSetRequest) bs
typemap_UpdateSquareFeatureSetRequest :: T.TypeMap
typemap_UpdateSquareFeatureSetRequest = Map.fromList [(2,("updateAttributes",(T.T_SET T.T_I32))),(3,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet)))]
default_UpdateSquareFeatureSetRequest :: UpdateSquareFeatureSetRequest
default_UpdateSquareFeatureSetRequest = UpdateSquareFeatureSetRequest{
  updateSquareFeatureSetRequest_updateAttributes = Set.empty,
  updateSquareFeatureSetRequest_squareFeatureSet = default_SquareFeatureSet}
data UpdateSquareFeatureSetResponse = UpdateSquareFeatureSetResponse  { updateSquareFeatureSetResponse_updateAttributes :: (Set.HashSet SquareFeatureSetAttribute)
  , updateSquareFeatureSetResponse_squareFeatureSet :: SquareFeatureSet
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareFeatureSetResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareFeatureSetResponse_updateAttributes record   `H.hashWithSalt` updateSquareFeatureSetResponse_squareFeatureSet record  
instance QC.Arbitrary UpdateSquareFeatureSetResponse where 
  arbitrary = M.liftM UpdateSquareFeatureSetResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareFeatureSetResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareFeatureSetResponse{updateSquareFeatureSetResponse_updateAttributes = updateSquareFeatureSetResponse_updateAttributes obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSetResponse{updateSquareFeatureSetResponse_updateAttributes = updateSquareFeatureSetResponse_updateAttributes obj}
    , if obj == default_UpdateSquareFeatureSetResponse{updateSquareFeatureSetResponse_squareFeatureSet = updateSquareFeatureSetResponse_squareFeatureSet obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSetResponse{updateSquareFeatureSetResponse_squareFeatureSet = updateSquareFeatureSetResponse_squareFeatureSet obj}
    ]
from_UpdateSquareFeatureSetResponse :: UpdateSquareFeatureSetResponse -> T.ThriftVal
from_UpdateSquareFeatureSetResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2903 -> P.Just (1, ("updateAttributes",T.TSet T.T_I32 $ P.map (\_v2905 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2905) $ Set.toList _v2903))) $ updateSquareFeatureSetResponse_updateAttributes record
  , (\_v2903 -> P.Just (2, ("squareFeatureSet",from_SquareFeatureSet _v2903))) $ updateSquareFeatureSetResponse_squareFeatureSet record
  ]
write_UpdateSquareFeatureSetResponse :: T.Protocol p => p -> UpdateSquareFeatureSetResponse -> P.IO ()
write_UpdateSquareFeatureSetResponse oprot record = T.writeVal oprot $ from_UpdateSquareFeatureSetResponse record
encode_UpdateSquareFeatureSetResponse :: T.StatelessProtocol p => p -> UpdateSquareFeatureSetResponse -> LBS.ByteString
encode_UpdateSquareFeatureSetResponse oprot record = T.serializeVal oprot $ from_UpdateSquareFeatureSetResponse record
to_UpdateSquareFeatureSetResponse :: T.ThriftVal -> UpdateSquareFeatureSetResponse
to_UpdateSquareFeatureSetResponse (T.TStruct fields) = UpdateSquareFeatureSetResponse{
  updateSquareFeatureSetResponse_updateAttributes = P.maybe (updateSquareFeatureSetResponse_updateAttributes default_UpdateSquareFeatureSetResponse) (\(_,_val2907) -> (case _val2907 of {T.TSet _ _val2908 -> (Set.fromList $ P.map (\_v2909 -> (case _v2909 of {T.TI32 _val2910 -> P.toEnum $ P.fromIntegral _val2910; _ -> P.error "wrong type"})) _val2908); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareFeatureSetResponse_squareFeatureSet = P.maybe (updateSquareFeatureSetResponse_squareFeatureSet default_UpdateSquareFeatureSetResponse) (\(_,_val2907) -> (case _val2907 of {T.TStruct _val2911 -> (to_SquareFeatureSet (T.TStruct _val2911)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSquareFeatureSetResponse _ = P.error "not a struct"
read_UpdateSquareFeatureSetResponse :: T.Protocol p => p -> P.IO UpdateSquareFeatureSetResponse
read_UpdateSquareFeatureSetResponse iprot = to_UpdateSquareFeatureSetResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSetResponse)
decode_UpdateSquareFeatureSetResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareFeatureSetResponse
decode_UpdateSquareFeatureSetResponse iprot bs = to_UpdateSquareFeatureSetResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSetResponse) bs
typemap_UpdateSquareFeatureSetResponse :: T.TypeMap
typemap_UpdateSquareFeatureSetResponse = Map.fromList [(1,("updateAttributes",(T.T_SET T.T_I32))),(2,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet)))]
default_UpdateSquareFeatureSetResponse :: UpdateSquareFeatureSetResponse
default_UpdateSquareFeatureSetResponse = UpdateSquareFeatureSetResponse{
  updateSquareFeatureSetResponse_updateAttributes = Set.empty,
  updateSquareFeatureSetResponse_squareFeatureSet = default_SquareFeatureSet}
data UpdateSquareMemberRequest = UpdateSquareMemberRequest  { updateSquareMemberRequest_updatedAttrs :: (Set.HashSet SquareMemberAttribute)
  , updateSquareMemberRequest_updatedPreferenceAttrs :: (Set.HashSet SquarePreferenceAttribute)
  , updateSquareMemberRequest_squareMember :: SquareMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberRequest_updatedAttrs record   `H.hashWithSalt` updateSquareMemberRequest_updatedPreferenceAttrs record   `H.hashWithSalt` updateSquareMemberRequest_squareMember record  
instance QC.Arbitrary UpdateSquareMemberRequest where 
  arbitrary = M.liftM UpdateSquareMemberRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberRequest{updateSquareMemberRequest_updatedAttrs = updateSquareMemberRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRequest{updateSquareMemberRequest_updatedAttrs = updateSquareMemberRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareMemberRequest{updateSquareMemberRequest_updatedPreferenceAttrs = updateSquareMemberRequest_updatedPreferenceAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRequest{updateSquareMemberRequest_updatedPreferenceAttrs = updateSquareMemberRequest_updatedPreferenceAttrs obj}
    , if obj == default_UpdateSquareMemberRequest{updateSquareMemberRequest_squareMember = updateSquareMemberRequest_squareMember obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRequest{updateSquareMemberRequest_squareMember = updateSquareMemberRequest_squareMember obj}
    ]
from_UpdateSquareMemberRequest :: UpdateSquareMemberRequest -> T.ThriftVal
from_UpdateSquareMemberRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2914 -> P.Just (2, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2916 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2916) $ Set.toList _v2914))) $ updateSquareMemberRequest_updatedAttrs record
  , (\_v2914 -> P.Just (3, ("updatedPreferenceAttrs",T.TSet T.T_I32 $ P.map (\_v2918 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2918) $ Set.toList _v2914))) $ updateSquareMemberRequest_updatedPreferenceAttrs record
  , (\_v2914 -> P.Just (4, ("squareMember",from_SquareMember _v2914))) $ updateSquareMemberRequest_squareMember record
  ]
write_UpdateSquareMemberRequest :: T.Protocol p => p -> UpdateSquareMemberRequest -> P.IO ()
write_UpdateSquareMemberRequest oprot record = T.writeVal oprot $ from_UpdateSquareMemberRequest record
encode_UpdateSquareMemberRequest :: T.StatelessProtocol p => p -> UpdateSquareMemberRequest -> LBS.ByteString
encode_UpdateSquareMemberRequest oprot record = T.serializeVal oprot $ from_UpdateSquareMemberRequest record
to_UpdateSquareMemberRequest :: T.ThriftVal -> UpdateSquareMemberRequest
to_UpdateSquareMemberRequest (T.TStruct fields) = UpdateSquareMemberRequest{
  updateSquareMemberRequest_updatedAttrs = P.maybe (updateSquareMemberRequest_updatedAttrs default_UpdateSquareMemberRequest) (\(_,_val2920) -> (case _val2920 of {T.TSet _ _val2921 -> (Set.fromList $ P.map (\_v2922 -> (case _v2922 of {T.TI32 _val2923 -> P.toEnum $ P.fromIntegral _val2923; _ -> P.error "wrong type"})) _val2921); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMemberRequest_updatedPreferenceAttrs = P.maybe (updateSquareMemberRequest_updatedPreferenceAttrs default_UpdateSquareMemberRequest) (\(_,_val2920) -> (case _val2920 of {T.TSet _ _val2924 -> (Set.fromList $ P.map (\_v2925 -> (case _v2925 of {T.TI32 _val2926 -> P.toEnum $ P.fromIntegral _val2926; _ -> P.error "wrong type"})) _val2924); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateSquareMemberRequest_squareMember = P.maybe (updateSquareMemberRequest_squareMember default_UpdateSquareMemberRequest) (\(_,_val2920) -> (case _val2920 of {T.TStruct _val2927 -> (to_SquareMember (T.TStruct _val2927)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_UpdateSquareMemberRequest _ = P.error "not a struct"
read_UpdateSquareMemberRequest :: T.Protocol p => p -> P.IO UpdateSquareMemberRequest
read_UpdateSquareMemberRequest iprot = to_UpdateSquareMemberRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRequest)
decode_UpdateSquareMemberRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberRequest
decode_UpdateSquareMemberRequest iprot bs = to_UpdateSquareMemberRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRequest) bs
typemap_UpdateSquareMemberRequest :: T.TypeMap
typemap_UpdateSquareMemberRequest = Map.fromList [(2,("updatedAttrs",(T.T_SET T.T_I32))),(3,("updatedPreferenceAttrs",(T.T_SET T.T_I32))),(4,("squareMember",(T.T_STRUCT typemap_SquareMember)))]
default_UpdateSquareMemberRequest :: UpdateSquareMemberRequest
default_UpdateSquareMemberRequest = UpdateSquareMemberRequest{
  updateSquareMemberRequest_updatedAttrs = Set.empty,
  updateSquareMemberRequest_updatedPreferenceAttrs = Set.empty,
  updateSquareMemberRequest_squareMember = default_SquareMember}
data UpdateSquareMemberResponse = UpdateSquareMemberResponse  { updateSquareMemberResponse_updatedAttrs :: (Set.HashSet SquareMemberAttribute)
  , updateSquareMemberResponse_squareMember :: SquareMember
  , updateSquareMemberResponse_updatedPreferenceAttrs :: (Set.HashSet SquarePreferenceAttribute)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberResponse_updatedAttrs record   `H.hashWithSalt` updateSquareMemberResponse_squareMember record   `H.hashWithSalt` updateSquareMemberResponse_updatedPreferenceAttrs record  
instance QC.Arbitrary UpdateSquareMemberResponse where 
  arbitrary = M.liftM UpdateSquareMemberResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberResponse{updateSquareMemberResponse_updatedAttrs = updateSquareMemberResponse_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberResponse{updateSquareMemberResponse_updatedAttrs = updateSquareMemberResponse_updatedAttrs obj}
    , if obj == default_UpdateSquareMemberResponse{updateSquareMemberResponse_squareMember = updateSquareMemberResponse_squareMember obj} then P.Nothing else P.Just $ default_UpdateSquareMemberResponse{updateSquareMemberResponse_squareMember = updateSquareMemberResponse_squareMember obj}
    , if obj == default_UpdateSquareMemberResponse{updateSquareMemberResponse_updatedPreferenceAttrs = updateSquareMemberResponse_updatedPreferenceAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberResponse{updateSquareMemberResponse_updatedPreferenceAttrs = updateSquareMemberResponse_updatedPreferenceAttrs obj}
    ]
from_UpdateSquareMemberResponse :: UpdateSquareMemberResponse -> T.ThriftVal
from_UpdateSquareMemberResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2930 -> P.Just (1, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2932 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2932) $ Set.toList _v2930))) $ updateSquareMemberResponse_updatedAttrs record
  , (\_v2930 -> P.Just (2, ("squareMember",from_SquareMember _v2930))) $ updateSquareMemberResponse_squareMember record
  , (\_v2930 -> P.Just (3, ("updatedPreferenceAttrs",T.TSet T.T_I32 $ P.map (\_v2934 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2934) $ Set.toList _v2930))) $ updateSquareMemberResponse_updatedPreferenceAttrs record
  ]
write_UpdateSquareMemberResponse :: T.Protocol p => p -> UpdateSquareMemberResponse -> P.IO ()
write_UpdateSquareMemberResponse oprot record = T.writeVal oprot $ from_UpdateSquareMemberResponse record
encode_UpdateSquareMemberResponse :: T.StatelessProtocol p => p -> UpdateSquareMemberResponse -> LBS.ByteString
encode_UpdateSquareMemberResponse oprot record = T.serializeVal oprot $ from_UpdateSquareMemberResponse record
to_UpdateSquareMemberResponse :: T.ThriftVal -> UpdateSquareMemberResponse
to_UpdateSquareMemberResponse (T.TStruct fields) = UpdateSquareMemberResponse{
  updateSquareMemberResponse_updatedAttrs = P.maybe (updateSquareMemberResponse_updatedAttrs default_UpdateSquareMemberResponse) (\(_,_val2936) -> (case _val2936 of {T.TSet _ _val2937 -> (Set.fromList $ P.map (\_v2938 -> (case _v2938 of {T.TI32 _val2939 -> P.toEnum $ P.fromIntegral _val2939; _ -> P.error "wrong type"})) _val2937); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareMemberResponse_squareMember = P.maybe (updateSquareMemberResponse_squareMember default_UpdateSquareMemberResponse) (\(_,_val2936) -> (case _val2936 of {T.TStruct _val2940 -> (to_SquareMember (T.TStruct _val2940)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMemberResponse_updatedPreferenceAttrs = P.maybe (updateSquareMemberResponse_updatedPreferenceAttrs default_UpdateSquareMemberResponse) (\(_,_val2936) -> (case _val2936 of {T.TSet _ _val2941 -> (Set.fromList $ P.map (\_v2942 -> (case _v2942 of {T.TI32 _val2943 -> P.toEnum $ P.fromIntegral _val2943; _ -> P.error "wrong type"})) _val2941); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareMemberResponse _ = P.error "not a struct"
read_UpdateSquareMemberResponse :: T.Protocol p => p -> P.IO UpdateSquareMemberResponse
read_UpdateSquareMemberResponse iprot = to_UpdateSquareMemberResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberResponse)
decode_UpdateSquareMemberResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberResponse
decode_UpdateSquareMemberResponse iprot bs = to_UpdateSquareMemberResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberResponse) bs
typemap_UpdateSquareMemberResponse :: T.TypeMap
typemap_UpdateSquareMemberResponse = Map.fromList [(1,("updatedAttrs",(T.T_SET T.T_I32))),(2,("squareMember",(T.T_STRUCT typemap_SquareMember))),(3,("updatedPreferenceAttrs",(T.T_SET T.T_I32)))]
default_UpdateSquareMemberResponse :: UpdateSquareMemberResponse
default_UpdateSquareMemberResponse = UpdateSquareMemberResponse{
  updateSquareMemberResponse_updatedAttrs = Set.empty,
  updateSquareMemberResponse_squareMember = default_SquareMember,
  updateSquareMemberResponse_updatedPreferenceAttrs = Set.empty}
data UpdateSquareMembersRequest = UpdateSquareMembersRequest  { updateSquareMembersRequest_updatedAttrs :: (Set.HashSet SquareMemberAttribute)
  , updateSquareMembersRequest_members :: (Vector.Vector SquareMember)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMembersRequest_updatedAttrs record   `H.hashWithSalt` updateSquareMembersRequest_members record  
instance QC.Arbitrary UpdateSquareMembersRequest where 
  arbitrary = M.liftM UpdateSquareMembersRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMembersRequest{updateSquareMembersRequest_updatedAttrs = updateSquareMembersRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMembersRequest{updateSquareMembersRequest_updatedAttrs = updateSquareMembersRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareMembersRequest{updateSquareMembersRequest_members = updateSquareMembersRequest_members obj} then P.Nothing else P.Just $ default_UpdateSquareMembersRequest{updateSquareMembersRequest_members = updateSquareMembersRequest_members obj}
    ]
from_UpdateSquareMembersRequest :: UpdateSquareMembersRequest -> T.ThriftVal
from_UpdateSquareMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2946 -> P.Just (2, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2948 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2948) $ Set.toList _v2946))) $ updateSquareMembersRequest_updatedAttrs record
  , (\_v2946 -> P.Just (3, ("members",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2950 -> from_SquareMember _v2950) $ Vector.toList _v2946))) $ updateSquareMembersRequest_members record
  ]
write_UpdateSquareMembersRequest :: T.Protocol p => p -> UpdateSquareMembersRequest -> P.IO ()
write_UpdateSquareMembersRequest oprot record = T.writeVal oprot $ from_UpdateSquareMembersRequest record
encode_UpdateSquareMembersRequest :: T.StatelessProtocol p => p -> UpdateSquareMembersRequest -> LBS.ByteString
encode_UpdateSquareMembersRequest oprot record = T.serializeVal oprot $ from_UpdateSquareMembersRequest record
to_UpdateSquareMembersRequest :: T.ThriftVal -> UpdateSquareMembersRequest
to_UpdateSquareMembersRequest (T.TStruct fields) = UpdateSquareMembersRequest{
  updateSquareMembersRequest_updatedAttrs = P.maybe (updateSquareMembersRequest_updatedAttrs default_UpdateSquareMembersRequest) (\(_,_val2952) -> (case _val2952 of {T.TSet _ _val2953 -> (Set.fromList $ P.map (\_v2954 -> (case _v2954 of {T.TI32 _val2955 -> P.toEnum $ P.fromIntegral _val2955; _ -> P.error "wrong type"})) _val2953); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMembersRequest_members = P.maybe (updateSquareMembersRequest_members default_UpdateSquareMembersRequest) (\(_,_val2952) -> (case _val2952 of {T.TList _ _val2956 -> (Vector.fromList $ P.map (\_v2957 -> (case _v2957 of {T.TStruct _val2958 -> (to_SquareMember (T.TStruct _val2958)); _ -> P.error "wrong type"})) _val2956); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareMembersRequest _ = P.error "not a struct"
read_UpdateSquareMembersRequest :: T.Protocol p => p -> P.IO UpdateSquareMembersRequest
read_UpdateSquareMembersRequest iprot = to_UpdateSquareMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMembersRequest)
decode_UpdateSquareMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMembersRequest
decode_UpdateSquareMembersRequest iprot bs = to_UpdateSquareMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMembersRequest) bs
typemap_UpdateSquareMembersRequest :: T.TypeMap
typemap_UpdateSquareMembersRequest = Map.fromList [(2,("updatedAttrs",(T.T_SET T.T_I32))),(3,("members",(T.T_LIST (T.T_STRUCT typemap_SquareMember))))]
default_UpdateSquareMembersRequest :: UpdateSquareMembersRequest
default_UpdateSquareMembersRequest = UpdateSquareMembersRequest{
  updateSquareMembersRequest_updatedAttrs = Set.empty,
  updateSquareMembersRequest_members = Vector.empty}
data UpdateSquareMembersResponse = UpdateSquareMembersResponse  { updateSquareMembersResponse_updatedAttrs :: (Set.HashSet SquareMemberAttribute)
  , updateSquareMembersResponse_editor :: SquareMember
  , updateSquareMembersResponse_members :: (Map.HashMap LT.Text SquareMember)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMembersResponse_updatedAttrs record   `H.hashWithSalt` updateSquareMembersResponse_editor record   `H.hashWithSalt` updateSquareMembersResponse_members record  
instance QC.Arbitrary UpdateSquareMembersResponse where 
  arbitrary = M.liftM UpdateSquareMembersResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMembersResponse{updateSquareMembersResponse_updatedAttrs = updateSquareMembersResponse_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMembersResponse{updateSquareMembersResponse_updatedAttrs = updateSquareMembersResponse_updatedAttrs obj}
    , if obj == default_UpdateSquareMembersResponse{updateSquareMembersResponse_editor = updateSquareMembersResponse_editor obj} then P.Nothing else P.Just $ default_UpdateSquareMembersResponse{updateSquareMembersResponse_editor = updateSquareMembersResponse_editor obj}
    , if obj == default_UpdateSquareMembersResponse{updateSquareMembersResponse_members = updateSquareMembersResponse_members obj} then P.Nothing else P.Just $ default_UpdateSquareMembersResponse{updateSquareMembersResponse_members = updateSquareMembersResponse_members obj}
    ]
from_UpdateSquareMembersResponse :: UpdateSquareMembersResponse -> T.ThriftVal
from_UpdateSquareMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2961 -> P.Just (1, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v2963 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v2963) $ Set.toList _v2961))) $ updateSquareMembersResponse_updatedAttrs record
  , (\_v2961 -> P.Just (2, ("editor",from_SquareMember _v2961))) $ updateSquareMembersResponse_editor record
  , (\_v2961 -> P.Just (3, ("members",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareMember) $ P.map (\(_k2964,_v2965) -> (T.TString $ E.encodeUtf8 _k2964, from_SquareMember _v2965)) $ Map.toList _v2961))) $ updateSquareMembersResponse_members record
  ]
write_UpdateSquareMembersResponse :: T.Protocol p => p -> UpdateSquareMembersResponse -> P.IO ()
write_UpdateSquareMembersResponse oprot record = T.writeVal oprot $ from_UpdateSquareMembersResponse record
encode_UpdateSquareMembersResponse :: T.StatelessProtocol p => p -> UpdateSquareMembersResponse -> LBS.ByteString
encode_UpdateSquareMembersResponse oprot record = T.serializeVal oprot $ from_UpdateSquareMembersResponse record
to_UpdateSquareMembersResponse :: T.ThriftVal -> UpdateSquareMembersResponse
to_UpdateSquareMembersResponse (T.TStruct fields) = UpdateSquareMembersResponse{
  updateSquareMembersResponse_updatedAttrs = P.maybe (updateSquareMembersResponse_updatedAttrs default_UpdateSquareMembersResponse) (\(_,_val2967) -> (case _val2967 of {T.TSet _ _val2968 -> (Set.fromList $ P.map (\_v2969 -> (case _v2969 of {T.TI32 _val2970 -> P.toEnum $ P.fromIntegral _val2970; _ -> P.error "wrong type"})) _val2968); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareMembersResponse_editor = P.maybe (updateSquareMembersResponse_editor default_UpdateSquareMembersResponse) (\(_,_val2967) -> (case _val2967 of {T.TStruct _val2971 -> (to_SquareMember (T.TStruct _val2971)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMembersResponse_members = P.maybe (updateSquareMembersResponse_members default_UpdateSquareMembersResponse) (\(_,_val2967) -> (case _val2967 of {T.TMap _ _ _val2972 -> (Map.fromList $ P.map (\(_k2974,_v2973) -> ((case _k2974 of {T.TString _val2975 -> E.decodeUtf8 _val2975; _ -> P.error "wrong type"}),(case _v2973 of {T.TStruct _val2976 -> (to_SquareMember (T.TStruct _val2976)); _ -> P.error "wrong type"}))) _val2972); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareMembersResponse _ = P.error "not a struct"
read_UpdateSquareMembersResponse :: T.Protocol p => p -> P.IO UpdateSquareMembersResponse
read_UpdateSquareMembersResponse iprot = to_UpdateSquareMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMembersResponse)
decode_UpdateSquareMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMembersResponse
decode_UpdateSquareMembersResponse iprot bs = to_UpdateSquareMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMembersResponse) bs
typemap_UpdateSquareMembersResponse :: T.TypeMap
typemap_UpdateSquareMembersResponse = Map.fromList [(1,("updatedAttrs",(T.T_SET T.T_I32))),(2,("editor",(T.T_STRUCT typemap_SquareMember))),(3,("members",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareMember))))]
default_UpdateSquareMembersResponse :: UpdateSquareMembersResponse
default_UpdateSquareMembersResponse = UpdateSquareMembersResponse{
  updateSquareMembersResponse_updatedAttrs = Set.empty,
  updateSquareMembersResponse_editor = default_SquareMember,
  updateSquareMembersResponse_members = Map.empty}
data RejectSquareMembersRequest = RejectSquareMembersRequest  { rejectSquareMembersRequest_squareMid :: LT.Text
  , rejectSquareMembersRequest_requestedMemberMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectSquareMembersRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectSquareMembersRequest_squareMid record   `H.hashWithSalt` rejectSquareMembersRequest_requestedMemberMids record  
instance QC.Arbitrary RejectSquareMembersRequest where 
  arbitrary = M.liftM RejectSquareMembersRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RejectSquareMembersRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectSquareMembersRequest{rejectSquareMembersRequest_squareMid = rejectSquareMembersRequest_squareMid obj} then P.Nothing else P.Just $ default_RejectSquareMembersRequest{rejectSquareMembersRequest_squareMid = rejectSquareMembersRequest_squareMid obj}
    , if obj == default_RejectSquareMembersRequest{rejectSquareMembersRequest_requestedMemberMids = rejectSquareMembersRequest_requestedMemberMids obj} then P.Nothing else P.Just $ default_RejectSquareMembersRequest{rejectSquareMembersRequest_requestedMemberMids = rejectSquareMembersRequest_requestedMemberMids obj}
    ]
from_RejectSquareMembersRequest :: RejectSquareMembersRequest -> T.ThriftVal
from_RejectSquareMembersRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2979 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v2979))) $ rejectSquareMembersRequest_squareMid record
  , (\_v2979 -> P.Just (3, ("requestedMemberMids",T.TList T.T_STRING $ P.map (\_v2981 -> T.TString $ E.encodeUtf8 _v2981) $ Vector.toList _v2979))) $ rejectSquareMembersRequest_requestedMemberMids record
  ]
write_RejectSquareMembersRequest :: T.Protocol p => p -> RejectSquareMembersRequest -> P.IO ()
write_RejectSquareMembersRequest oprot record = T.writeVal oprot $ from_RejectSquareMembersRequest record
encode_RejectSquareMembersRequest :: T.StatelessProtocol p => p -> RejectSquareMembersRequest -> LBS.ByteString
encode_RejectSquareMembersRequest oprot record = T.serializeVal oprot $ from_RejectSquareMembersRequest record
to_RejectSquareMembersRequest :: T.ThriftVal -> RejectSquareMembersRequest
to_RejectSquareMembersRequest (T.TStruct fields) = RejectSquareMembersRequest{
  rejectSquareMembersRequest_squareMid = P.maybe (rejectSquareMembersRequest_squareMid default_RejectSquareMembersRequest) (\(_,_val2983) -> (case _val2983 of {T.TString _val2984 -> E.decodeUtf8 _val2984; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  rejectSquareMembersRequest_requestedMemberMids = P.maybe (rejectSquareMembersRequest_requestedMemberMids default_RejectSquareMembersRequest) (\(_,_val2983) -> (case _val2983 of {T.TList _ _val2985 -> (Vector.fromList $ P.map (\_v2986 -> (case _v2986 of {T.TString _val2987 -> E.decodeUtf8 _val2987; _ -> P.error "wrong type"})) _val2985); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RejectSquareMembersRequest _ = P.error "not a struct"
read_RejectSquareMembersRequest :: T.Protocol p => p -> P.IO RejectSquareMembersRequest
read_RejectSquareMembersRequest iprot = to_RejectSquareMembersRequest <$> T.readVal iprot (T.T_STRUCT typemap_RejectSquareMembersRequest)
decode_RejectSquareMembersRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectSquareMembersRequest
decode_RejectSquareMembersRequest iprot bs = to_RejectSquareMembersRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectSquareMembersRequest) bs
typemap_RejectSquareMembersRequest :: T.TypeMap
typemap_RejectSquareMembersRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("requestedMemberMids",(T.T_LIST T.T_STRING)))]
default_RejectSquareMembersRequest :: RejectSquareMembersRequest
default_RejectSquareMembersRequest = RejectSquareMembersRequest{
  rejectSquareMembersRequest_squareMid = "",
  rejectSquareMembersRequest_requestedMemberMids = Vector.empty}
data RejectSquareMembersResponse = RejectSquareMembersResponse  { rejectSquareMembersResponse_rejectedMembers :: (Vector.Vector SquareMember)
  , rejectSquareMembersResponse_status :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectSquareMembersResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectSquareMembersResponse_rejectedMembers record   `H.hashWithSalt` rejectSquareMembersResponse_status record  
instance QC.Arbitrary RejectSquareMembersResponse where 
  arbitrary = M.liftM RejectSquareMembersResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RejectSquareMembersResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectSquareMembersResponse{rejectSquareMembersResponse_rejectedMembers = rejectSquareMembersResponse_rejectedMembers obj} then P.Nothing else P.Just $ default_RejectSquareMembersResponse{rejectSquareMembersResponse_rejectedMembers = rejectSquareMembersResponse_rejectedMembers obj}
    , if obj == default_RejectSquareMembersResponse{rejectSquareMembersResponse_status = rejectSquareMembersResponse_status obj} then P.Nothing else P.Just $ default_RejectSquareMembersResponse{rejectSquareMembersResponse_status = rejectSquareMembersResponse_status obj}
    ]
from_RejectSquareMembersResponse :: RejectSquareMembersResponse -> T.ThriftVal
from_RejectSquareMembersResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2990 -> P.Just (1, ("rejectedMembers",T.TList (T.T_STRUCT typemap_SquareMember) $ P.map (\_v2992 -> from_SquareMember _v2992) $ Vector.toList _v2990))) $ rejectSquareMembersResponse_rejectedMembers record
  , (\_v2990 -> P.Just (2, ("status",from_SquareStatus _v2990))) $ rejectSquareMembersResponse_status record
  ]
write_RejectSquareMembersResponse :: T.Protocol p => p -> RejectSquareMembersResponse -> P.IO ()
write_RejectSquareMembersResponse oprot record = T.writeVal oprot $ from_RejectSquareMembersResponse record
encode_RejectSquareMembersResponse :: T.StatelessProtocol p => p -> RejectSquareMembersResponse -> LBS.ByteString
encode_RejectSquareMembersResponse oprot record = T.serializeVal oprot $ from_RejectSquareMembersResponse record
to_RejectSquareMembersResponse :: T.ThriftVal -> RejectSquareMembersResponse
to_RejectSquareMembersResponse (T.TStruct fields) = RejectSquareMembersResponse{
  rejectSquareMembersResponse_rejectedMembers = P.maybe (rejectSquareMembersResponse_rejectedMembers default_RejectSquareMembersResponse) (\(_,_val2994) -> (case _val2994 of {T.TList _ _val2995 -> (Vector.fromList $ P.map (\_v2996 -> (case _v2996 of {T.TStruct _val2997 -> (to_SquareMember (T.TStruct _val2997)); _ -> P.error "wrong type"})) _val2995); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rejectSquareMembersResponse_status = P.maybe (rejectSquareMembersResponse_status default_RejectSquareMembersResponse) (\(_,_val2994) -> (case _val2994 of {T.TStruct _val2998 -> (to_SquareStatus (T.TStruct _val2998)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RejectSquareMembersResponse _ = P.error "not a struct"
read_RejectSquareMembersResponse :: T.Protocol p => p -> P.IO RejectSquareMembersResponse
read_RejectSquareMembersResponse iprot = to_RejectSquareMembersResponse <$> T.readVal iprot (T.T_STRUCT typemap_RejectSquareMembersResponse)
decode_RejectSquareMembersResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectSquareMembersResponse
decode_RejectSquareMembersResponse iprot bs = to_RejectSquareMembersResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectSquareMembersResponse) bs
typemap_RejectSquareMembersResponse :: T.TypeMap
typemap_RejectSquareMembersResponse = Map.fromList [(1,("rejectedMembers",(T.T_LIST (T.T_STRUCT typemap_SquareMember)))),(2,("status",(T.T_STRUCT typemap_SquareStatus)))]
default_RejectSquareMembersResponse :: RejectSquareMembersResponse
default_RejectSquareMembersResponse = RejectSquareMembersResponse{
  rejectSquareMembersResponse_rejectedMembers = Vector.empty,
  rejectSquareMembersResponse_status = default_SquareStatus}
data RemoveSubscriptionsRequest = RemoveSubscriptionsRequest  { removeSubscriptionsRequest_unsubscriptions :: (Vector.Vector I.Int64)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSubscriptionsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSubscriptionsRequest_unsubscriptions record  
instance QC.Arbitrary RemoveSubscriptionsRequest where 
  arbitrary = M.liftM RemoveSubscriptionsRequest (QC.arbitrary)
  shrink obj | obj == default_RemoveSubscriptionsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSubscriptionsRequest{removeSubscriptionsRequest_unsubscriptions = removeSubscriptionsRequest_unsubscriptions obj} then P.Nothing else P.Just $ default_RemoveSubscriptionsRequest{removeSubscriptionsRequest_unsubscriptions = removeSubscriptionsRequest_unsubscriptions obj}
    ]
from_RemoveSubscriptionsRequest :: RemoveSubscriptionsRequest -> T.ThriftVal
from_RemoveSubscriptionsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3001 -> P.Just (2, ("unsubscriptions",T.TList T.T_I64 $ P.map (\_v3003 -> T.TI64 _v3003) $ Vector.toList _v3001))) $ removeSubscriptionsRequest_unsubscriptions record
  ]
write_RemoveSubscriptionsRequest :: T.Protocol p => p -> RemoveSubscriptionsRequest -> P.IO ()
write_RemoveSubscriptionsRequest oprot record = T.writeVal oprot $ from_RemoveSubscriptionsRequest record
encode_RemoveSubscriptionsRequest :: T.StatelessProtocol p => p -> RemoveSubscriptionsRequest -> LBS.ByteString
encode_RemoveSubscriptionsRequest oprot record = T.serializeVal oprot $ from_RemoveSubscriptionsRequest record
to_RemoveSubscriptionsRequest :: T.ThriftVal -> RemoveSubscriptionsRequest
to_RemoveSubscriptionsRequest (T.TStruct fields) = RemoveSubscriptionsRequest{
  removeSubscriptionsRequest_unsubscriptions = P.maybe (removeSubscriptionsRequest_unsubscriptions default_RemoveSubscriptionsRequest) (\(_,_val3005) -> (case _val3005 of {T.TList _ _val3006 -> (Vector.fromList $ P.map (\_v3007 -> (case _v3007 of {T.TI64 _val3008 -> _val3008; _ -> P.error "wrong type"})) _val3006); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveSubscriptionsRequest _ = P.error "not a struct"
read_RemoveSubscriptionsRequest :: T.Protocol p => p -> P.IO RemoveSubscriptionsRequest
read_RemoveSubscriptionsRequest iprot = to_RemoveSubscriptionsRequest <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSubscriptionsRequest)
decode_RemoveSubscriptionsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSubscriptionsRequest
decode_RemoveSubscriptionsRequest iprot bs = to_RemoveSubscriptionsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSubscriptionsRequest) bs
typemap_RemoveSubscriptionsRequest :: T.TypeMap
typemap_RemoveSubscriptionsRequest = Map.fromList [(2,("unsubscriptions",(T.T_LIST T.T_I64)))]
default_RemoveSubscriptionsRequest :: RemoveSubscriptionsRequest
default_RemoveSubscriptionsRequest = RemoveSubscriptionsRequest{
  removeSubscriptionsRequest_unsubscriptions = Vector.empty}
data RemoveSubscriptionsResponse = RemoveSubscriptionsResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSubscriptionsResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary RemoveSubscriptionsResponse where 
  arbitrary = QC.elements [RemoveSubscriptionsResponse]
from_RemoveSubscriptionsResponse :: RemoveSubscriptionsResponse -> T.ThriftVal
from_RemoveSubscriptionsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_RemoveSubscriptionsResponse :: T.Protocol p => p -> RemoveSubscriptionsResponse -> P.IO ()
write_RemoveSubscriptionsResponse oprot record = T.writeVal oprot $ from_RemoveSubscriptionsResponse record
encode_RemoveSubscriptionsResponse :: T.StatelessProtocol p => p -> RemoveSubscriptionsResponse -> LBS.ByteString
encode_RemoveSubscriptionsResponse oprot record = T.serializeVal oprot $ from_RemoveSubscriptionsResponse record
to_RemoveSubscriptionsResponse :: T.ThriftVal -> RemoveSubscriptionsResponse
to_RemoveSubscriptionsResponse (T.TStruct fields) = RemoveSubscriptionsResponse{

  }
to_RemoveSubscriptionsResponse _ = P.error "not a struct"
read_RemoveSubscriptionsResponse :: T.Protocol p => p -> P.IO RemoveSubscriptionsResponse
read_RemoveSubscriptionsResponse iprot = to_RemoveSubscriptionsResponse <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSubscriptionsResponse)
decode_RemoveSubscriptionsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSubscriptionsResponse
decode_RemoveSubscriptionsResponse iprot bs = to_RemoveSubscriptionsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSubscriptionsResponse) bs
typemap_RemoveSubscriptionsResponse :: T.TypeMap
typemap_RemoveSubscriptionsResponse = Map.fromList []
default_RemoveSubscriptionsResponse :: RemoveSubscriptionsResponse
default_RemoveSubscriptionsResponse = RemoveSubscriptionsResponse{
}
data RefreshSubscriptionsRequest = RefreshSubscriptionsRequest  { refreshSubscriptionsRequest_subscriptions :: (Vector.Vector I.Int64)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RefreshSubscriptionsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` refreshSubscriptionsRequest_subscriptions record  
instance QC.Arbitrary RefreshSubscriptionsRequest where 
  arbitrary = M.liftM RefreshSubscriptionsRequest (QC.arbitrary)
  shrink obj | obj == default_RefreshSubscriptionsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RefreshSubscriptionsRequest{refreshSubscriptionsRequest_subscriptions = refreshSubscriptionsRequest_subscriptions obj} then P.Nothing else P.Just $ default_RefreshSubscriptionsRequest{refreshSubscriptionsRequest_subscriptions = refreshSubscriptionsRequest_subscriptions obj}
    ]
from_RefreshSubscriptionsRequest :: RefreshSubscriptionsRequest -> T.ThriftVal
from_RefreshSubscriptionsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3016 -> P.Just (2, ("subscriptions",T.TList T.T_I64 $ P.map (\_v3018 -> T.TI64 _v3018) $ Vector.toList _v3016))) $ refreshSubscriptionsRequest_subscriptions record
  ]
write_RefreshSubscriptionsRequest :: T.Protocol p => p -> RefreshSubscriptionsRequest -> P.IO ()
write_RefreshSubscriptionsRequest oprot record = T.writeVal oprot $ from_RefreshSubscriptionsRequest record
encode_RefreshSubscriptionsRequest :: T.StatelessProtocol p => p -> RefreshSubscriptionsRequest -> LBS.ByteString
encode_RefreshSubscriptionsRequest oprot record = T.serializeVal oprot $ from_RefreshSubscriptionsRequest record
to_RefreshSubscriptionsRequest :: T.ThriftVal -> RefreshSubscriptionsRequest
to_RefreshSubscriptionsRequest (T.TStruct fields) = RefreshSubscriptionsRequest{
  refreshSubscriptionsRequest_subscriptions = P.maybe (refreshSubscriptionsRequest_subscriptions default_RefreshSubscriptionsRequest) (\(_,_val3020) -> (case _val3020 of {T.TList _ _val3021 -> (Vector.fromList $ P.map (\_v3022 -> (case _v3022 of {T.TI64 _val3023 -> _val3023; _ -> P.error "wrong type"})) _val3021); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RefreshSubscriptionsRequest _ = P.error "not a struct"
read_RefreshSubscriptionsRequest :: T.Protocol p => p -> P.IO RefreshSubscriptionsRequest
read_RefreshSubscriptionsRequest iprot = to_RefreshSubscriptionsRequest <$> T.readVal iprot (T.T_STRUCT typemap_RefreshSubscriptionsRequest)
decode_RefreshSubscriptionsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> RefreshSubscriptionsRequest
decode_RefreshSubscriptionsRequest iprot bs = to_RefreshSubscriptionsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_RefreshSubscriptionsRequest) bs
typemap_RefreshSubscriptionsRequest :: T.TypeMap
typemap_RefreshSubscriptionsRequest = Map.fromList [(2,("subscriptions",(T.T_LIST T.T_I64)))]
default_RefreshSubscriptionsRequest :: RefreshSubscriptionsRequest
default_RefreshSubscriptionsRequest = RefreshSubscriptionsRequest{
  refreshSubscriptionsRequest_subscriptions = Vector.empty}
data RefreshSubscriptionsResponse = RefreshSubscriptionsResponse  { refreshSubscriptionsResponse_ttlMillis :: I.Int64
  , refreshSubscriptionsResponse_subscriptionStates :: (Map.HashMap I.Int64 SubscriptionState)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RefreshSubscriptionsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` refreshSubscriptionsResponse_ttlMillis record   `H.hashWithSalt` refreshSubscriptionsResponse_subscriptionStates record  
instance QC.Arbitrary RefreshSubscriptionsResponse where 
  arbitrary = M.liftM RefreshSubscriptionsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RefreshSubscriptionsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RefreshSubscriptionsResponse{refreshSubscriptionsResponse_ttlMillis = refreshSubscriptionsResponse_ttlMillis obj} then P.Nothing else P.Just $ default_RefreshSubscriptionsResponse{refreshSubscriptionsResponse_ttlMillis = refreshSubscriptionsResponse_ttlMillis obj}
    , if obj == default_RefreshSubscriptionsResponse{refreshSubscriptionsResponse_subscriptionStates = refreshSubscriptionsResponse_subscriptionStates obj} then P.Nothing else P.Just $ default_RefreshSubscriptionsResponse{refreshSubscriptionsResponse_subscriptionStates = refreshSubscriptionsResponse_subscriptionStates obj}
    ]
from_RefreshSubscriptionsResponse :: RefreshSubscriptionsResponse -> T.ThriftVal
from_RefreshSubscriptionsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3026 -> P.Just (1, ("ttlMillis",T.TI64 _v3026))) $ refreshSubscriptionsResponse_ttlMillis record
  , (\_v3026 -> P.Just (2, ("subscriptionStates",T.TMap T.T_I64 (T.T_STRUCT typemap_SubscriptionState) $ P.map (\(_k3027,_v3028) -> (T.TI64 _k3027, from_SubscriptionState _v3028)) $ Map.toList _v3026))) $ refreshSubscriptionsResponse_subscriptionStates record
  ]
write_RefreshSubscriptionsResponse :: T.Protocol p => p -> RefreshSubscriptionsResponse -> P.IO ()
write_RefreshSubscriptionsResponse oprot record = T.writeVal oprot $ from_RefreshSubscriptionsResponse record
encode_RefreshSubscriptionsResponse :: T.StatelessProtocol p => p -> RefreshSubscriptionsResponse -> LBS.ByteString
encode_RefreshSubscriptionsResponse oprot record = T.serializeVal oprot $ from_RefreshSubscriptionsResponse record
to_RefreshSubscriptionsResponse :: T.ThriftVal -> RefreshSubscriptionsResponse
to_RefreshSubscriptionsResponse (T.TStruct fields) = RefreshSubscriptionsResponse{
  refreshSubscriptionsResponse_ttlMillis = P.maybe (refreshSubscriptionsResponse_ttlMillis default_RefreshSubscriptionsResponse) (\(_,_val3030) -> (case _val3030 of {T.TI64 _val3031 -> _val3031; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  refreshSubscriptionsResponse_subscriptionStates = P.maybe (refreshSubscriptionsResponse_subscriptionStates default_RefreshSubscriptionsResponse) (\(_,_val3030) -> (case _val3030 of {T.TMap _ _ _val3032 -> (Map.fromList $ P.map (\(_k3034,_v3033) -> ((case _k3034 of {T.TI64 _val3035 -> _val3035; _ -> P.error "wrong type"}),(case _v3033 of {T.TStruct _val3036 -> (to_SubscriptionState (T.TStruct _val3036)); _ -> P.error "wrong type"}))) _val3032); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RefreshSubscriptionsResponse _ = P.error "not a struct"
read_RefreshSubscriptionsResponse :: T.Protocol p => p -> P.IO RefreshSubscriptionsResponse
read_RefreshSubscriptionsResponse iprot = to_RefreshSubscriptionsResponse <$> T.readVal iprot (T.T_STRUCT typemap_RefreshSubscriptionsResponse)
decode_RefreshSubscriptionsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> RefreshSubscriptionsResponse
decode_RefreshSubscriptionsResponse iprot bs = to_RefreshSubscriptionsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_RefreshSubscriptionsResponse) bs
typemap_RefreshSubscriptionsResponse :: T.TypeMap
typemap_RefreshSubscriptionsResponse = Map.fromList [(1,("ttlMillis",T.T_I64)),(2,("subscriptionStates",(T.T_MAP T.T_I64 (T.T_STRUCT typemap_SubscriptionState))))]
default_RefreshSubscriptionsResponse :: RefreshSubscriptionsResponse
default_RefreshSubscriptionsResponse = RefreshSubscriptionsResponse{
  refreshSubscriptionsResponse_ttlMillis = 0,
  refreshSubscriptionsResponse_subscriptionStates = Map.empty}
data UpdateSquareChatRequest = UpdateSquareChatRequest  { updateSquareChatRequest_updatedAttrs :: (Set.HashSet SquareChatAttribute)
  , updateSquareChatRequest_squareChat :: SquareChat
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatRequest_updatedAttrs record   `H.hashWithSalt` updateSquareChatRequest_squareChat record  
instance QC.Arbitrary UpdateSquareChatRequest where 
  arbitrary = M.liftM UpdateSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatRequest{updateSquareChatRequest_updatedAttrs = updateSquareChatRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareChatRequest{updateSquareChatRequest_updatedAttrs = updateSquareChatRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareChatRequest{updateSquareChatRequest_squareChat = updateSquareChatRequest_squareChat obj} then P.Nothing else P.Just $ default_UpdateSquareChatRequest{updateSquareChatRequest_squareChat = updateSquareChatRequest_squareChat obj}
    ]
from_UpdateSquareChatRequest :: UpdateSquareChatRequest -> T.ThriftVal
from_UpdateSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3039 -> P.Just (2, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v3041 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3041) $ Set.toList _v3039))) $ updateSquareChatRequest_updatedAttrs record
  , (\_v3039 -> P.Just (3, ("squareChat",from_SquareChat _v3039))) $ updateSquareChatRequest_squareChat record
  ]
write_UpdateSquareChatRequest :: T.Protocol p => p -> UpdateSquareChatRequest -> P.IO ()
write_UpdateSquareChatRequest oprot record = T.writeVal oprot $ from_UpdateSquareChatRequest record
encode_UpdateSquareChatRequest :: T.StatelessProtocol p => p -> UpdateSquareChatRequest -> LBS.ByteString
encode_UpdateSquareChatRequest oprot record = T.serializeVal oprot $ from_UpdateSquareChatRequest record
to_UpdateSquareChatRequest :: T.ThriftVal -> UpdateSquareChatRequest
to_UpdateSquareChatRequest (T.TStruct fields) = UpdateSquareChatRequest{
  updateSquareChatRequest_updatedAttrs = P.maybe (updateSquareChatRequest_updatedAttrs default_UpdateSquareChatRequest) (\(_,_val3043) -> (case _val3043 of {T.TSet _ _val3044 -> (Set.fromList $ P.map (\_v3045 -> (case _v3045 of {T.TI32 _val3046 -> P.toEnum $ P.fromIntegral _val3046; _ -> P.error "wrong type"})) _val3044); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareChatRequest_squareChat = P.maybe (updateSquareChatRequest_squareChat default_UpdateSquareChatRequest) (\(_,_val3043) -> (case _val3043 of {T.TStruct _val3047 -> (to_SquareChat (T.TStruct _val3047)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareChatRequest _ = P.error "not a struct"
read_UpdateSquareChatRequest :: T.Protocol p => p -> P.IO UpdateSquareChatRequest
read_UpdateSquareChatRequest iprot = to_UpdateSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatRequest)
decode_UpdateSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatRequest
decode_UpdateSquareChatRequest iprot bs = to_UpdateSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatRequest) bs
typemap_UpdateSquareChatRequest :: T.TypeMap
typemap_UpdateSquareChatRequest = Map.fromList [(2,("updatedAttrs",(T.T_SET T.T_I32))),(3,("squareChat",(T.T_STRUCT typemap_SquareChat)))]
default_UpdateSquareChatRequest :: UpdateSquareChatRequest
default_UpdateSquareChatRequest = UpdateSquareChatRequest{
  updateSquareChatRequest_updatedAttrs = Set.empty,
  updateSquareChatRequest_squareChat = default_SquareChat}
data UpdateSquareChatResponse = UpdateSquareChatResponse  { updateSquareChatResponse_updatedAttrs :: (Set.HashSet SquareChatAttribute)
  , updateSquareChatResponse_squareChat :: SquareChat
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatResponse_updatedAttrs record   `H.hashWithSalt` updateSquareChatResponse_squareChat record  
instance QC.Arbitrary UpdateSquareChatResponse where 
  arbitrary = M.liftM UpdateSquareChatResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatResponse{updateSquareChatResponse_updatedAttrs = updateSquareChatResponse_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareChatResponse{updateSquareChatResponse_updatedAttrs = updateSquareChatResponse_updatedAttrs obj}
    , if obj == default_UpdateSquareChatResponse{updateSquareChatResponse_squareChat = updateSquareChatResponse_squareChat obj} then P.Nothing else P.Just $ default_UpdateSquareChatResponse{updateSquareChatResponse_squareChat = updateSquareChatResponse_squareChat obj}
    ]
from_UpdateSquareChatResponse :: UpdateSquareChatResponse -> T.ThriftVal
from_UpdateSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3050 -> P.Just (1, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v3052 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3052) $ Set.toList _v3050))) $ updateSquareChatResponse_updatedAttrs record
  , (\_v3050 -> P.Just (2, ("squareChat",from_SquareChat _v3050))) $ updateSquareChatResponse_squareChat record
  ]
write_UpdateSquareChatResponse :: T.Protocol p => p -> UpdateSquareChatResponse -> P.IO ()
write_UpdateSquareChatResponse oprot record = T.writeVal oprot $ from_UpdateSquareChatResponse record
encode_UpdateSquareChatResponse :: T.StatelessProtocol p => p -> UpdateSquareChatResponse -> LBS.ByteString
encode_UpdateSquareChatResponse oprot record = T.serializeVal oprot $ from_UpdateSquareChatResponse record
to_UpdateSquareChatResponse :: T.ThriftVal -> UpdateSquareChatResponse
to_UpdateSquareChatResponse (T.TStruct fields) = UpdateSquareChatResponse{
  updateSquareChatResponse_updatedAttrs = P.maybe (updateSquareChatResponse_updatedAttrs default_UpdateSquareChatResponse) (\(_,_val3054) -> (case _val3054 of {T.TSet _ _val3055 -> (Set.fromList $ P.map (\_v3056 -> (case _v3056 of {T.TI32 _val3057 -> P.toEnum $ P.fromIntegral _val3057; _ -> P.error "wrong type"})) _val3055); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareChatResponse_squareChat = P.maybe (updateSquareChatResponse_squareChat default_UpdateSquareChatResponse) (\(_,_val3054) -> (case _val3054 of {T.TStruct _val3058 -> (to_SquareChat (T.TStruct _val3058)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSquareChatResponse _ = P.error "not a struct"
read_UpdateSquareChatResponse :: T.Protocol p => p -> P.IO UpdateSquareChatResponse
read_UpdateSquareChatResponse iprot = to_UpdateSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatResponse)
decode_UpdateSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatResponse
decode_UpdateSquareChatResponse iprot bs = to_UpdateSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatResponse) bs
typemap_UpdateSquareChatResponse :: T.TypeMap
typemap_UpdateSquareChatResponse = Map.fromList [(1,("updatedAttrs",(T.T_SET T.T_I32))),(2,("squareChat",(T.T_STRUCT typemap_SquareChat)))]
default_UpdateSquareChatResponse :: UpdateSquareChatResponse
default_UpdateSquareChatResponse = UpdateSquareChatResponse{
  updateSquareChatResponse_updatedAttrs = Set.empty,
  updateSquareChatResponse_squareChat = default_SquareChat}
data DeleteSquareChatRequest = DeleteSquareChatRequest  { deleteSquareChatRequest_squareChatMid :: LT.Text
  , deleteSquareChatRequest_revision :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChatRequest_squareChatMid record   `H.hashWithSalt` deleteSquareChatRequest_revision record  
instance QC.Arbitrary DeleteSquareChatRequest where 
  arbitrary = M.liftM DeleteSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChatRequest{deleteSquareChatRequest_squareChatMid = deleteSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_DeleteSquareChatRequest{deleteSquareChatRequest_squareChatMid = deleteSquareChatRequest_squareChatMid obj}
    , if obj == default_DeleteSquareChatRequest{deleteSquareChatRequest_revision = deleteSquareChatRequest_revision obj} then P.Nothing else P.Just $ default_DeleteSquareChatRequest{deleteSquareChatRequest_revision = deleteSquareChatRequest_revision obj}
    ]
from_DeleteSquareChatRequest :: DeleteSquareChatRequest -> T.ThriftVal
from_DeleteSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3061 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v3061))) $ deleteSquareChatRequest_squareChatMid record
  , (\_v3061 -> P.Just (3, ("revision",T.TI64 _v3061))) $ deleteSquareChatRequest_revision record
  ]
write_DeleteSquareChatRequest :: T.Protocol p => p -> DeleteSquareChatRequest -> P.IO ()
write_DeleteSquareChatRequest oprot record = T.writeVal oprot $ from_DeleteSquareChatRequest record
encode_DeleteSquareChatRequest :: T.StatelessProtocol p => p -> DeleteSquareChatRequest -> LBS.ByteString
encode_DeleteSquareChatRequest oprot record = T.serializeVal oprot $ from_DeleteSquareChatRequest record
to_DeleteSquareChatRequest :: T.ThriftVal -> DeleteSquareChatRequest
to_DeleteSquareChatRequest (T.TStruct fields) = DeleteSquareChatRequest{
  deleteSquareChatRequest_squareChatMid = P.maybe (deleteSquareChatRequest_squareChatMid default_DeleteSquareChatRequest) (\(_,_val3063) -> (case _val3063 of {T.TString _val3064 -> E.decodeUtf8 _val3064; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deleteSquareChatRequest_revision = P.maybe (deleteSquareChatRequest_revision default_DeleteSquareChatRequest) (\(_,_val3063) -> (case _val3063 of {T.TI64 _val3065 -> _val3065; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_DeleteSquareChatRequest _ = P.error "not a struct"
read_DeleteSquareChatRequest :: T.Protocol p => p -> P.IO DeleteSquareChatRequest
read_DeleteSquareChatRequest iprot = to_DeleteSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatRequest)
decode_DeleteSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatRequest
decode_DeleteSquareChatRequest iprot bs = to_DeleteSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatRequest) bs
typemap_DeleteSquareChatRequest :: T.TypeMap
typemap_DeleteSquareChatRequest = Map.fromList [(2,("squareChatMid",T.T_STRING)),(3,("revision",T.T_I64))]
default_DeleteSquareChatRequest :: DeleteSquareChatRequest
default_DeleteSquareChatRequest = DeleteSquareChatRequest{
  deleteSquareChatRequest_squareChatMid = "",
  deleteSquareChatRequest_revision = 0}
data DeleteSquareChatResponse = DeleteSquareChatResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DeleteSquareChatResponse where 
  arbitrary = QC.elements [DeleteSquareChatResponse]
from_DeleteSquareChatResponse :: DeleteSquareChatResponse -> T.ThriftVal
from_DeleteSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DeleteSquareChatResponse :: T.Protocol p => p -> DeleteSquareChatResponse -> P.IO ()
write_DeleteSquareChatResponse oprot record = T.writeVal oprot $ from_DeleteSquareChatResponse record
encode_DeleteSquareChatResponse :: T.StatelessProtocol p => p -> DeleteSquareChatResponse -> LBS.ByteString
encode_DeleteSquareChatResponse oprot record = T.serializeVal oprot $ from_DeleteSquareChatResponse record
to_DeleteSquareChatResponse :: T.ThriftVal -> DeleteSquareChatResponse
to_DeleteSquareChatResponse (T.TStruct fields) = DeleteSquareChatResponse{

  }
to_DeleteSquareChatResponse _ = P.error "not a struct"
read_DeleteSquareChatResponse :: T.Protocol p => p -> P.IO DeleteSquareChatResponse
read_DeleteSquareChatResponse iprot = to_DeleteSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatResponse)
decode_DeleteSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatResponse
decode_DeleteSquareChatResponse iprot bs = to_DeleteSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatResponse) bs
typemap_DeleteSquareChatResponse :: T.TypeMap
typemap_DeleteSquareChatResponse = Map.fromList []
default_DeleteSquareChatResponse :: DeleteSquareChatResponse
default_DeleteSquareChatResponse = DeleteSquareChatResponse{
}
data UpdateSquareChatMemberRequest = UpdateSquareChatMemberRequest  { updateSquareChatMemberRequest_updatedAttrs :: (Set.HashSet SquareChatMemberAttribute)
  , updateSquareChatMemberRequest_chatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatMemberRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatMemberRequest_updatedAttrs record   `H.hashWithSalt` updateSquareChatMemberRequest_chatMember record  
instance QC.Arbitrary UpdateSquareChatMemberRequest where 
  arbitrary = M.liftM UpdateSquareChatMemberRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatMemberRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatMemberRequest{updateSquareChatMemberRequest_updatedAttrs = updateSquareChatMemberRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareChatMemberRequest{updateSquareChatMemberRequest_updatedAttrs = updateSquareChatMemberRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareChatMemberRequest{updateSquareChatMemberRequest_chatMember = updateSquareChatMemberRequest_chatMember obj} then P.Nothing else P.Just $ default_UpdateSquareChatMemberRequest{updateSquareChatMemberRequest_chatMember = updateSquareChatMemberRequest_chatMember obj}
    ]
from_UpdateSquareChatMemberRequest :: UpdateSquareChatMemberRequest -> T.ThriftVal
from_UpdateSquareChatMemberRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3073 -> P.Just (2, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v3075 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3075) $ Set.toList _v3073))) $ updateSquareChatMemberRequest_updatedAttrs record
  , (\_v3073 -> P.Just (3, ("chatMember",from_SquareChatMember _v3073))) $ updateSquareChatMemberRequest_chatMember record
  ]
write_UpdateSquareChatMemberRequest :: T.Protocol p => p -> UpdateSquareChatMemberRequest -> P.IO ()
write_UpdateSquareChatMemberRequest oprot record = T.writeVal oprot $ from_UpdateSquareChatMemberRequest record
encode_UpdateSquareChatMemberRequest :: T.StatelessProtocol p => p -> UpdateSquareChatMemberRequest -> LBS.ByteString
encode_UpdateSquareChatMemberRequest oprot record = T.serializeVal oprot $ from_UpdateSquareChatMemberRequest record
to_UpdateSquareChatMemberRequest :: T.ThriftVal -> UpdateSquareChatMemberRequest
to_UpdateSquareChatMemberRequest (T.TStruct fields) = UpdateSquareChatMemberRequest{
  updateSquareChatMemberRequest_updatedAttrs = P.maybe (updateSquareChatMemberRequest_updatedAttrs default_UpdateSquareChatMemberRequest) (\(_,_val3077) -> (case _val3077 of {T.TSet _ _val3078 -> (Set.fromList $ P.map (\_v3079 -> (case _v3079 of {T.TI32 _val3080 -> P.toEnum $ P.fromIntegral _val3080; _ -> P.error "wrong type"})) _val3078); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareChatMemberRequest_chatMember = P.maybe (updateSquareChatMemberRequest_chatMember default_UpdateSquareChatMemberRequest) (\(_,_val3077) -> (case _val3077 of {T.TStruct _val3081 -> (to_SquareChatMember (T.TStruct _val3081)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareChatMemberRequest _ = P.error "not a struct"
read_UpdateSquareChatMemberRequest :: T.Protocol p => p -> P.IO UpdateSquareChatMemberRequest
read_UpdateSquareChatMemberRequest iprot = to_UpdateSquareChatMemberRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatMemberRequest)
decode_UpdateSquareChatMemberRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatMemberRequest
decode_UpdateSquareChatMemberRequest iprot bs = to_UpdateSquareChatMemberRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatMemberRequest) bs
typemap_UpdateSquareChatMemberRequest :: T.TypeMap
typemap_UpdateSquareChatMemberRequest = Map.fromList [(2,("updatedAttrs",(T.T_SET T.T_I32))),(3,("chatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_UpdateSquareChatMemberRequest :: UpdateSquareChatMemberRequest
default_UpdateSquareChatMemberRequest = UpdateSquareChatMemberRequest{
  updateSquareChatMemberRequest_updatedAttrs = Set.empty,
  updateSquareChatMemberRequest_chatMember = default_SquareChatMember}
data UpdateSquareChatMemberResponse = UpdateSquareChatMemberResponse  { updateSquareChatMemberResponse_updatedChatMember :: SquareChatMember
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatMemberResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatMemberResponse_updatedChatMember record  
instance QC.Arbitrary UpdateSquareChatMemberResponse where 
  arbitrary = M.liftM UpdateSquareChatMemberResponse (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatMemberResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatMemberResponse{updateSquareChatMemberResponse_updatedChatMember = updateSquareChatMemberResponse_updatedChatMember obj} then P.Nothing else P.Just $ default_UpdateSquareChatMemberResponse{updateSquareChatMemberResponse_updatedChatMember = updateSquareChatMemberResponse_updatedChatMember obj}
    ]
from_UpdateSquareChatMemberResponse :: UpdateSquareChatMemberResponse -> T.ThriftVal
from_UpdateSquareChatMemberResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3084 -> P.Just (1, ("updatedChatMember",from_SquareChatMember _v3084))) $ updateSquareChatMemberResponse_updatedChatMember record
  ]
write_UpdateSquareChatMemberResponse :: T.Protocol p => p -> UpdateSquareChatMemberResponse -> P.IO ()
write_UpdateSquareChatMemberResponse oprot record = T.writeVal oprot $ from_UpdateSquareChatMemberResponse record
encode_UpdateSquareChatMemberResponse :: T.StatelessProtocol p => p -> UpdateSquareChatMemberResponse -> LBS.ByteString
encode_UpdateSquareChatMemberResponse oprot record = T.serializeVal oprot $ from_UpdateSquareChatMemberResponse record
to_UpdateSquareChatMemberResponse :: T.ThriftVal -> UpdateSquareChatMemberResponse
to_UpdateSquareChatMemberResponse (T.TStruct fields) = UpdateSquareChatMemberResponse{
  updateSquareChatMemberResponse_updatedChatMember = P.maybe (updateSquareChatMemberResponse_updatedChatMember default_UpdateSquareChatMemberResponse) (\(_,_val3086) -> (case _val3086 of {T.TStruct _val3087 -> (to_SquareChatMember (T.TStruct _val3087)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareChatMemberResponse _ = P.error "not a struct"
read_UpdateSquareChatMemberResponse :: T.Protocol p => p -> P.IO UpdateSquareChatMemberResponse
read_UpdateSquareChatMemberResponse iprot = to_UpdateSquareChatMemberResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatMemberResponse)
decode_UpdateSquareChatMemberResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatMemberResponse
decode_UpdateSquareChatMemberResponse iprot bs = to_UpdateSquareChatMemberResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatMemberResponse) bs
typemap_UpdateSquareChatMemberResponse :: T.TypeMap
typemap_UpdateSquareChatMemberResponse = Map.fromList [(1,("updatedChatMember",(T.T_STRUCT typemap_SquareChatMember)))]
default_UpdateSquareChatMemberResponse :: UpdateSquareChatMemberResponse
default_UpdateSquareChatMemberResponse = UpdateSquareChatMemberResponse{
  updateSquareChatMemberResponse_updatedChatMember = default_SquareChatMember}
data UpdateSquareAuthorityRequest = UpdateSquareAuthorityRequest  { updateSquareAuthorityRequest_updateAttributes :: (Set.HashSet SquareAuthorityAttribute)
  , updateSquareAuthorityRequest_authority :: SquareAuthority
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareAuthorityRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareAuthorityRequest_updateAttributes record   `H.hashWithSalt` updateSquareAuthorityRequest_authority record  
instance QC.Arbitrary UpdateSquareAuthorityRequest where 
  arbitrary = M.liftM UpdateSquareAuthorityRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareAuthorityRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareAuthorityRequest{updateSquareAuthorityRequest_updateAttributes = updateSquareAuthorityRequest_updateAttributes obj} then P.Nothing else P.Just $ default_UpdateSquareAuthorityRequest{updateSquareAuthorityRequest_updateAttributes = updateSquareAuthorityRequest_updateAttributes obj}
    , if obj == default_UpdateSquareAuthorityRequest{updateSquareAuthorityRequest_authority = updateSquareAuthorityRequest_authority obj} then P.Nothing else P.Just $ default_UpdateSquareAuthorityRequest{updateSquareAuthorityRequest_authority = updateSquareAuthorityRequest_authority obj}
    ]
from_UpdateSquareAuthorityRequest :: UpdateSquareAuthorityRequest -> T.ThriftVal
from_UpdateSquareAuthorityRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3090 -> P.Just (2, ("updateAttributes",T.TSet T.T_I32 $ P.map (\_v3092 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3092) $ Set.toList _v3090))) $ updateSquareAuthorityRequest_updateAttributes record
  , (\_v3090 -> P.Just (3, ("authority",from_SquareAuthority _v3090))) $ updateSquareAuthorityRequest_authority record
  ]
write_UpdateSquareAuthorityRequest :: T.Protocol p => p -> UpdateSquareAuthorityRequest -> P.IO ()
write_UpdateSquareAuthorityRequest oprot record = T.writeVal oprot $ from_UpdateSquareAuthorityRequest record
encode_UpdateSquareAuthorityRequest :: T.StatelessProtocol p => p -> UpdateSquareAuthorityRequest -> LBS.ByteString
encode_UpdateSquareAuthorityRequest oprot record = T.serializeVal oprot $ from_UpdateSquareAuthorityRequest record
to_UpdateSquareAuthorityRequest :: T.ThriftVal -> UpdateSquareAuthorityRequest
to_UpdateSquareAuthorityRequest (T.TStruct fields) = UpdateSquareAuthorityRequest{
  updateSquareAuthorityRequest_updateAttributes = P.maybe (updateSquareAuthorityRequest_updateAttributes default_UpdateSquareAuthorityRequest) (\(_,_val3094) -> (case _val3094 of {T.TSet _ _val3095 -> (Set.fromList $ P.map (\_v3096 -> (case _v3096 of {T.TI32 _val3097 -> P.toEnum $ P.fromIntegral _val3097; _ -> P.error "wrong type"})) _val3095); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareAuthorityRequest_authority = P.maybe (updateSquareAuthorityRequest_authority default_UpdateSquareAuthorityRequest) (\(_,_val3094) -> (case _val3094 of {T.TStruct _val3098 -> (to_SquareAuthority (T.TStruct _val3098)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSquareAuthorityRequest _ = P.error "not a struct"
read_UpdateSquareAuthorityRequest :: T.Protocol p => p -> P.IO UpdateSquareAuthorityRequest
read_UpdateSquareAuthorityRequest iprot = to_UpdateSquareAuthorityRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareAuthorityRequest)
decode_UpdateSquareAuthorityRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareAuthorityRequest
decode_UpdateSquareAuthorityRequest iprot bs = to_UpdateSquareAuthorityRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareAuthorityRequest) bs
typemap_UpdateSquareAuthorityRequest :: T.TypeMap
typemap_UpdateSquareAuthorityRequest = Map.fromList [(2,("updateAttributes",(T.T_SET T.T_I32))),(3,("authority",(T.T_STRUCT typemap_SquareAuthority)))]
default_UpdateSquareAuthorityRequest :: UpdateSquareAuthorityRequest
default_UpdateSquareAuthorityRequest = UpdateSquareAuthorityRequest{
  updateSquareAuthorityRequest_updateAttributes = Set.empty,
  updateSquareAuthorityRequest_authority = default_SquareAuthority}
data UpdateSquareAuthorityResponse = UpdateSquareAuthorityResponse  { updateSquareAuthorityResponse_updatdAttributes :: (Set.HashSet SquareAuthorityAttribute)
  , updateSquareAuthorityResponse_authority :: SquareAuthority
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareAuthorityResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareAuthorityResponse_updatdAttributes record   `H.hashWithSalt` updateSquareAuthorityResponse_authority record  
instance QC.Arbitrary UpdateSquareAuthorityResponse where 
  arbitrary = M.liftM UpdateSquareAuthorityResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareAuthorityResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareAuthorityResponse{updateSquareAuthorityResponse_updatdAttributes = updateSquareAuthorityResponse_updatdAttributes obj} then P.Nothing else P.Just $ default_UpdateSquareAuthorityResponse{updateSquareAuthorityResponse_updatdAttributes = updateSquareAuthorityResponse_updatdAttributes obj}
    , if obj == default_UpdateSquareAuthorityResponse{updateSquareAuthorityResponse_authority = updateSquareAuthorityResponse_authority obj} then P.Nothing else P.Just $ default_UpdateSquareAuthorityResponse{updateSquareAuthorityResponse_authority = updateSquareAuthorityResponse_authority obj}
    ]
from_UpdateSquareAuthorityResponse :: UpdateSquareAuthorityResponse -> T.ThriftVal
from_UpdateSquareAuthorityResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3101 -> P.Just (1, ("updatdAttributes",T.TSet T.T_I32 $ P.map (\_v3103 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3103) $ Set.toList _v3101))) $ updateSquareAuthorityResponse_updatdAttributes record
  , (\_v3101 -> P.Just (2, ("authority",from_SquareAuthority _v3101))) $ updateSquareAuthorityResponse_authority record
  ]
write_UpdateSquareAuthorityResponse :: T.Protocol p => p -> UpdateSquareAuthorityResponse -> P.IO ()
write_UpdateSquareAuthorityResponse oprot record = T.writeVal oprot $ from_UpdateSquareAuthorityResponse record
encode_UpdateSquareAuthorityResponse :: T.StatelessProtocol p => p -> UpdateSquareAuthorityResponse -> LBS.ByteString
encode_UpdateSquareAuthorityResponse oprot record = T.serializeVal oprot $ from_UpdateSquareAuthorityResponse record
to_UpdateSquareAuthorityResponse :: T.ThriftVal -> UpdateSquareAuthorityResponse
to_UpdateSquareAuthorityResponse (T.TStruct fields) = UpdateSquareAuthorityResponse{
  updateSquareAuthorityResponse_updatdAttributes = P.maybe (updateSquareAuthorityResponse_updatdAttributes default_UpdateSquareAuthorityResponse) (\(_,_val3105) -> (case _val3105 of {T.TSet _ _val3106 -> (Set.fromList $ P.map (\_v3107 -> (case _v3107 of {T.TI32 _val3108 -> P.toEnum $ P.fromIntegral _val3108; _ -> P.error "wrong type"})) _val3106); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareAuthorityResponse_authority = P.maybe (updateSquareAuthorityResponse_authority default_UpdateSquareAuthorityResponse) (\(_,_val3105) -> (case _val3105 of {T.TStruct _val3109 -> (to_SquareAuthority (T.TStruct _val3109)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSquareAuthorityResponse _ = P.error "not a struct"
read_UpdateSquareAuthorityResponse :: T.Protocol p => p -> P.IO UpdateSquareAuthorityResponse
read_UpdateSquareAuthorityResponse iprot = to_UpdateSquareAuthorityResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareAuthorityResponse)
decode_UpdateSquareAuthorityResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareAuthorityResponse
decode_UpdateSquareAuthorityResponse iprot bs = to_UpdateSquareAuthorityResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareAuthorityResponse) bs
typemap_UpdateSquareAuthorityResponse :: T.TypeMap
typemap_UpdateSquareAuthorityResponse = Map.fromList [(1,("updatdAttributes",(T.T_SET T.T_I32))),(2,("authority",(T.T_STRUCT typemap_SquareAuthority)))]
default_UpdateSquareAuthorityResponse :: UpdateSquareAuthorityResponse
default_UpdateSquareAuthorityResponse = UpdateSquareAuthorityResponse{
  updateSquareAuthorityResponse_updatdAttributes = Set.empty,
  updateSquareAuthorityResponse_authority = default_SquareAuthority}
data UpdateSquareMemberRelationRequest = UpdateSquareMemberRelationRequest  { updateSquareMemberRelationRequest_squareMid :: LT.Text
  , updateSquareMemberRelationRequest_targetSquareMemberMid :: LT.Text
  , updateSquareMemberRelationRequest_updatedAttrs :: (Set.HashSet SquareMemberRelationAttribute)
  , updateSquareMemberRelationRequest_relation :: SquareMemberRelation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberRelationRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberRelationRequest_squareMid record   `H.hashWithSalt` updateSquareMemberRelationRequest_targetSquareMemberMid record   `H.hashWithSalt` updateSquareMemberRelationRequest_updatedAttrs record   `H.hashWithSalt` updateSquareMemberRelationRequest_relation record  
instance QC.Arbitrary UpdateSquareMemberRelationRequest where 
  arbitrary = M.liftM UpdateSquareMemberRelationRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberRelationRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_squareMid = updateSquareMemberRelationRequest_squareMid obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_squareMid = updateSquareMemberRelationRequest_squareMid obj}
    , if obj == default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_targetSquareMemberMid = updateSquareMemberRelationRequest_targetSquareMemberMid obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_targetSquareMemberMid = updateSquareMemberRelationRequest_targetSquareMemberMid obj}
    , if obj == default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_updatedAttrs = updateSquareMemberRelationRequest_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_updatedAttrs = updateSquareMemberRelationRequest_updatedAttrs obj}
    , if obj == default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_relation = updateSquareMemberRelationRequest_relation obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationRequest{updateSquareMemberRelationRequest_relation = updateSquareMemberRelationRequest_relation obj}
    ]
from_UpdateSquareMemberRelationRequest :: UpdateSquareMemberRelationRequest -> T.ThriftVal
from_UpdateSquareMemberRelationRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3112 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3112))) $ updateSquareMemberRelationRequest_squareMid record
  , (\_v3112 -> P.Just (3, ("targetSquareMemberMid",T.TString $ E.encodeUtf8 _v3112))) $ updateSquareMemberRelationRequest_targetSquareMemberMid record
  , (\_v3112 -> P.Just (4, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v3114 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3114) $ Set.toList _v3112))) $ updateSquareMemberRelationRequest_updatedAttrs record
  , (\_v3112 -> P.Just (5, ("relation",from_SquareMemberRelation _v3112))) $ updateSquareMemberRelationRequest_relation record
  ]
write_UpdateSquareMemberRelationRequest :: T.Protocol p => p -> UpdateSquareMemberRelationRequest -> P.IO ()
write_UpdateSquareMemberRelationRequest oprot record = T.writeVal oprot $ from_UpdateSquareMemberRelationRequest record
encode_UpdateSquareMemberRelationRequest :: T.StatelessProtocol p => p -> UpdateSquareMemberRelationRequest -> LBS.ByteString
encode_UpdateSquareMemberRelationRequest oprot record = T.serializeVal oprot $ from_UpdateSquareMemberRelationRequest record
to_UpdateSquareMemberRelationRequest :: T.ThriftVal -> UpdateSquareMemberRelationRequest
to_UpdateSquareMemberRelationRequest (T.TStruct fields) = UpdateSquareMemberRelationRequest{
  updateSquareMemberRelationRequest_squareMid = P.maybe (updateSquareMemberRelationRequest_squareMid default_UpdateSquareMemberRelationRequest) (\(_,_val3116) -> (case _val3116 of {T.TString _val3117 -> E.decodeUtf8 _val3117; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMemberRelationRequest_targetSquareMemberMid = P.maybe (updateSquareMemberRelationRequest_targetSquareMemberMid default_UpdateSquareMemberRelationRequest) (\(_,_val3116) -> (case _val3116 of {T.TString _val3118 -> E.decodeUtf8 _val3118; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateSquareMemberRelationRequest_updatedAttrs = P.maybe (updateSquareMemberRelationRequest_updatedAttrs default_UpdateSquareMemberRelationRequest) (\(_,_val3116) -> (case _val3116 of {T.TSet _ _val3119 -> (Set.fromList $ P.map (\_v3120 -> (case _v3120 of {T.TI32 _val3121 -> P.toEnum $ P.fromIntegral _val3121; _ -> P.error "wrong type"})) _val3119); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  updateSquareMemberRelationRequest_relation = P.maybe (updateSquareMemberRelationRequest_relation default_UpdateSquareMemberRelationRequest) (\(_,_val3116) -> (case _val3116 of {T.TStruct _val3122 -> (to_SquareMemberRelation (T.TStruct _val3122)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_UpdateSquareMemberRelationRequest _ = P.error "not a struct"
read_UpdateSquareMemberRelationRequest :: T.Protocol p => p -> P.IO UpdateSquareMemberRelationRequest
read_UpdateSquareMemberRelationRequest iprot = to_UpdateSquareMemberRelationRequest <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelationRequest)
decode_UpdateSquareMemberRelationRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberRelationRequest
decode_UpdateSquareMemberRelationRequest iprot bs = to_UpdateSquareMemberRelationRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelationRequest) bs
typemap_UpdateSquareMemberRelationRequest :: T.TypeMap
typemap_UpdateSquareMemberRelationRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("targetSquareMemberMid",T.T_STRING)),(4,("updatedAttrs",(T.T_SET T.T_I32))),(5,("relation",(T.T_STRUCT typemap_SquareMemberRelation)))]
default_UpdateSquareMemberRelationRequest :: UpdateSquareMemberRelationRequest
default_UpdateSquareMemberRelationRequest = UpdateSquareMemberRelationRequest{
  updateSquareMemberRelationRequest_squareMid = "",
  updateSquareMemberRelationRequest_targetSquareMemberMid = "",
  updateSquareMemberRelationRequest_updatedAttrs = Set.empty,
  updateSquareMemberRelationRequest_relation = default_SquareMemberRelation}
data UpdateSquareMemberRelationResponse = UpdateSquareMemberRelationResponse  { updateSquareMemberRelationResponse_squareMid :: LT.Text
  , updateSquareMemberRelationResponse_targetSquareMemberMid :: LT.Text
  , updateSquareMemberRelationResponse_updatedAttrs :: (Set.HashSet SquareMemberRelationAttribute)
  , updateSquareMemberRelationResponse_relation :: SquareMemberRelation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberRelationResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberRelationResponse_squareMid record   `H.hashWithSalt` updateSquareMemberRelationResponse_targetSquareMemberMid record   `H.hashWithSalt` updateSquareMemberRelationResponse_updatedAttrs record   `H.hashWithSalt` updateSquareMemberRelationResponse_relation record  
instance QC.Arbitrary UpdateSquareMemberRelationResponse where 
  arbitrary = M.liftM UpdateSquareMemberRelationResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberRelationResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_squareMid = updateSquareMemberRelationResponse_squareMid obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_squareMid = updateSquareMemberRelationResponse_squareMid obj}
    , if obj == default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_targetSquareMemberMid = updateSquareMemberRelationResponse_targetSquareMemberMid obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_targetSquareMemberMid = updateSquareMemberRelationResponse_targetSquareMemberMid obj}
    , if obj == default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_updatedAttrs = updateSquareMemberRelationResponse_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_updatedAttrs = updateSquareMemberRelationResponse_updatedAttrs obj}
    , if obj == default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_relation = updateSquareMemberRelationResponse_relation obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelationResponse{updateSquareMemberRelationResponse_relation = updateSquareMemberRelationResponse_relation obj}
    ]
from_UpdateSquareMemberRelationResponse :: UpdateSquareMemberRelationResponse -> T.ThriftVal
from_UpdateSquareMemberRelationResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3125 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v3125))) $ updateSquareMemberRelationResponse_squareMid record
  , (\_v3125 -> P.Just (2, ("targetSquareMemberMid",T.TString $ E.encodeUtf8 _v3125))) $ updateSquareMemberRelationResponse_targetSquareMemberMid record
  , (\_v3125 -> P.Just (3, ("updatedAttrs",T.TSet T.T_I32 $ P.map (\_v3127 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3127) $ Set.toList _v3125))) $ updateSquareMemberRelationResponse_updatedAttrs record
  , (\_v3125 -> P.Just (4, ("relation",from_SquareMemberRelation _v3125))) $ updateSquareMemberRelationResponse_relation record
  ]
write_UpdateSquareMemberRelationResponse :: T.Protocol p => p -> UpdateSquareMemberRelationResponse -> P.IO ()
write_UpdateSquareMemberRelationResponse oprot record = T.writeVal oprot $ from_UpdateSquareMemberRelationResponse record
encode_UpdateSquareMemberRelationResponse :: T.StatelessProtocol p => p -> UpdateSquareMemberRelationResponse -> LBS.ByteString
encode_UpdateSquareMemberRelationResponse oprot record = T.serializeVal oprot $ from_UpdateSquareMemberRelationResponse record
to_UpdateSquareMemberRelationResponse :: T.ThriftVal -> UpdateSquareMemberRelationResponse
to_UpdateSquareMemberRelationResponse (T.TStruct fields) = UpdateSquareMemberRelationResponse{
  updateSquareMemberRelationResponse_squareMid = P.maybe (updateSquareMemberRelationResponse_squareMid default_UpdateSquareMemberRelationResponse) (\(_,_val3129) -> (case _val3129 of {T.TString _val3130 -> E.decodeUtf8 _val3130; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSquareMemberRelationResponse_targetSquareMemberMid = P.maybe (updateSquareMemberRelationResponse_targetSquareMemberMid default_UpdateSquareMemberRelationResponse) (\(_,_val3129) -> (case _val3129 of {T.TString _val3131 -> E.decodeUtf8 _val3131; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSquareMemberRelationResponse_updatedAttrs = P.maybe (updateSquareMemberRelationResponse_updatedAttrs default_UpdateSquareMemberRelationResponse) (\(_,_val3129) -> (case _val3129 of {T.TSet _ _val3132 -> (Set.fromList $ P.map (\_v3133 -> (case _v3133 of {T.TI32 _val3134 -> P.toEnum $ P.fromIntegral _val3134; _ -> P.error "wrong type"})) _val3132); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateSquareMemberRelationResponse_relation = P.maybe (updateSquareMemberRelationResponse_relation default_UpdateSquareMemberRelationResponse) (\(_,_val3129) -> (case _val3129 of {T.TStruct _val3135 -> (to_SquareMemberRelation (T.TStruct _val3135)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_UpdateSquareMemberRelationResponse _ = P.error "not a struct"
read_UpdateSquareMemberRelationResponse :: T.Protocol p => p -> P.IO UpdateSquareMemberRelationResponse
read_UpdateSquareMemberRelationResponse iprot = to_UpdateSquareMemberRelationResponse <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelationResponse)
decode_UpdateSquareMemberRelationResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberRelationResponse
decode_UpdateSquareMemberRelationResponse iprot bs = to_UpdateSquareMemberRelationResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelationResponse) bs
typemap_UpdateSquareMemberRelationResponse :: T.TypeMap
typemap_UpdateSquareMemberRelationResponse = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("targetSquareMemberMid",T.T_STRING)),(3,("updatedAttrs",(T.T_SET T.T_I32))),(4,("relation",(T.T_STRUCT typemap_SquareMemberRelation)))]
default_UpdateSquareMemberRelationResponse :: UpdateSquareMemberRelationResponse
default_UpdateSquareMemberRelationResponse = UpdateSquareMemberRelationResponse{
  updateSquareMemberRelationResponse_squareMid = "",
  updateSquareMemberRelationResponse_targetSquareMemberMid = "",
  updateSquareMemberRelationResponse_updatedAttrs = Set.empty,
  updateSquareMemberRelationResponse_relation = default_SquareMemberRelation}
data ReportSquareRequest = ReportSquareRequest  { reportSquareRequest_squareMid :: LT.Text
  , reportSquareRequest_reportType :: ReportType
  , reportSquareRequest_otherReason :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareRequest_squareMid record   `H.hashWithSalt` reportSquareRequest_reportType record   `H.hashWithSalt` reportSquareRequest_otherReason record  
instance QC.Arbitrary ReportSquareRequest where 
  arbitrary = M.liftM ReportSquareRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareRequest{reportSquareRequest_squareMid = reportSquareRequest_squareMid obj} then P.Nothing else P.Just $ default_ReportSquareRequest{reportSquareRequest_squareMid = reportSquareRequest_squareMid obj}
    , if obj == default_ReportSquareRequest{reportSquareRequest_reportType = reportSquareRequest_reportType obj} then P.Nothing else P.Just $ default_ReportSquareRequest{reportSquareRequest_reportType = reportSquareRequest_reportType obj}
    , if obj == default_ReportSquareRequest{reportSquareRequest_otherReason = reportSquareRequest_otherReason obj} then P.Nothing else P.Just $ default_ReportSquareRequest{reportSquareRequest_otherReason = reportSquareRequest_otherReason obj}
    ]
from_ReportSquareRequest :: ReportSquareRequest -> T.ThriftVal
from_ReportSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3138 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3138))) $ reportSquareRequest_squareMid record
  , (\_v3138 -> P.Just (3, ("reportType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3138))) $ reportSquareRequest_reportType record
  , (\_v3138 -> P.Just (4, ("otherReason",T.TString $ E.encodeUtf8 _v3138))) $ reportSquareRequest_otherReason record
  ]
write_ReportSquareRequest :: T.Protocol p => p -> ReportSquareRequest -> P.IO ()
write_ReportSquareRequest oprot record = T.writeVal oprot $ from_ReportSquareRequest record
encode_ReportSquareRequest :: T.StatelessProtocol p => p -> ReportSquareRequest -> LBS.ByteString
encode_ReportSquareRequest oprot record = T.serializeVal oprot $ from_ReportSquareRequest record
to_ReportSquareRequest :: T.ThriftVal -> ReportSquareRequest
to_ReportSquareRequest (T.TStruct fields) = ReportSquareRequest{
  reportSquareRequest_squareMid = P.maybe (reportSquareRequest_squareMid default_ReportSquareRequest) (\(_,_val3140) -> (case _val3140 of {T.TString _val3141 -> E.decodeUtf8 _val3141; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSquareRequest_reportType = P.maybe (reportSquareRequest_reportType default_ReportSquareRequest) (\(_,_val3140) -> (case _val3140 of {T.TI32 _val3142 -> P.toEnum $ P.fromIntegral _val3142; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSquareRequest_otherReason = P.maybe (reportSquareRequest_otherReason default_ReportSquareRequest) (\(_,_val3140) -> (case _val3140 of {T.TString _val3143 -> E.decodeUtf8 _val3143; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ReportSquareRequest _ = P.error "not a struct"
read_ReportSquareRequest :: T.Protocol p => p -> P.IO ReportSquareRequest
read_ReportSquareRequest iprot = to_ReportSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareRequest)
decode_ReportSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareRequest
decode_ReportSquareRequest iprot bs = to_ReportSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareRequest) bs
typemap_ReportSquareRequest :: T.TypeMap
typemap_ReportSquareRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("reportType",T.T_I32)),(4,("otherReason",T.T_STRING))]
default_ReportSquareRequest :: ReportSquareRequest
default_ReportSquareRequest = ReportSquareRequest{
  reportSquareRequest_squareMid = "",
  reportSquareRequest_reportType = (P.toEnum 0),
  reportSquareRequest_otherReason = ""}
data ReportSquareResponse = ReportSquareResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReportSquareResponse where 
  arbitrary = QC.elements [ReportSquareResponse]
from_ReportSquareResponse :: ReportSquareResponse -> T.ThriftVal
from_ReportSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReportSquareResponse :: T.Protocol p => p -> ReportSquareResponse -> P.IO ()
write_ReportSquareResponse oprot record = T.writeVal oprot $ from_ReportSquareResponse record
encode_ReportSquareResponse :: T.StatelessProtocol p => p -> ReportSquareResponse -> LBS.ByteString
encode_ReportSquareResponse oprot record = T.serializeVal oprot $ from_ReportSquareResponse record
to_ReportSquareResponse :: T.ThriftVal -> ReportSquareResponse
to_ReportSquareResponse (T.TStruct fields) = ReportSquareResponse{

  }
to_ReportSquareResponse _ = P.error "not a struct"
read_ReportSquareResponse :: T.Protocol p => p -> P.IO ReportSquareResponse
read_ReportSquareResponse iprot = to_ReportSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareResponse)
decode_ReportSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareResponse
decode_ReportSquareResponse iprot bs = to_ReportSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareResponse) bs
typemap_ReportSquareResponse :: T.TypeMap
typemap_ReportSquareResponse = Map.fromList []
default_ReportSquareResponse :: ReportSquareResponse
default_ReportSquareResponse = ReportSquareResponse{
}
data ReportSquareChatRequest = ReportSquareChatRequest  { reportSquareChatRequest_squareMid :: LT.Text
  , reportSquareChatRequest_squareChatMid :: LT.Text
  , reportSquareChatRequest_reportType :: ReportType
  , reportSquareChatRequest_otherReason :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareChatRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareChatRequest_squareMid record   `H.hashWithSalt` reportSquareChatRequest_squareChatMid record   `H.hashWithSalt` reportSquareChatRequest_reportType record   `H.hashWithSalt` reportSquareChatRequest_otherReason record  
instance QC.Arbitrary ReportSquareChatRequest where 
  arbitrary = M.liftM ReportSquareChatRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSquareChatRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareChatRequest{reportSquareChatRequest_squareMid = reportSquareChatRequest_squareMid obj} then P.Nothing else P.Just $ default_ReportSquareChatRequest{reportSquareChatRequest_squareMid = reportSquareChatRequest_squareMid obj}
    , if obj == default_ReportSquareChatRequest{reportSquareChatRequest_squareChatMid = reportSquareChatRequest_squareChatMid obj} then P.Nothing else P.Just $ default_ReportSquareChatRequest{reportSquareChatRequest_squareChatMid = reportSquareChatRequest_squareChatMid obj}
    , if obj == default_ReportSquareChatRequest{reportSquareChatRequest_reportType = reportSquareChatRequest_reportType obj} then P.Nothing else P.Just $ default_ReportSquareChatRequest{reportSquareChatRequest_reportType = reportSquareChatRequest_reportType obj}
    , if obj == default_ReportSquareChatRequest{reportSquareChatRequest_otherReason = reportSquareChatRequest_otherReason obj} then P.Nothing else P.Just $ default_ReportSquareChatRequest{reportSquareChatRequest_otherReason = reportSquareChatRequest_otherReason obj}
    ]
from_ReportSquareChatRequest :: ReportSquareChatRequest -> T.ThriftVal
from_ReportSquareChatRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3151 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3151))) $ reportSquareChatRequest_squareMid record
  , (\_v3151 -> P.Just (3, ("squareChatMid",T.TString $ E.encodeUtf8 _v3151))) $ reportSquareChatRequest_squareChatMid record
  , (\_v3151 -> P.Just (5, ("reportType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3151))) $ reportSquareChatRequest_reportType record
  , (\_v3151 -> P.Just (6, ("otherReason",T.TString $ E.encodeUtf8 _v3151))) $ reportSquareChatRequest_otherReason record
  ]
write_ReportSquareChatRequest :: T.Protocol p => p -> ReportSquareChatRequest -> P.IO ()
write_ReportSquareChatRequest oprot record = T.writeVal oprot $ from_ReportSquareChatRequest record
encode_ReportSquareChatRequest :: T.StatelessProtocol p => p -> ReportSquareChatRequest -> LBS.ByteString
encode_ReportSquareChatRequest oprot record = T.serializeVal oprot $ from_ReportSquareChatRequest record
to_ReportSquareChatRequest :: T.ThriftVal -> ReportSquareChatRequest
to_ReportSquareChatRequest (T.TStruct fields) = ReportSquareChatRequest{
  reportSquareChatRequest_squareMid = P.maybe (reportSquareChatRequest_squareMid default_ReportSquareChatRequest) (\(_,_val3153) -> (case _val3153 of {T.TString _val3154 -> E.decodeUtf8 _val3154; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSquareChatRequest_squareChatMid = P.maybe (reportSquareChatRequest_squareChatMid default_ReportSquareChatRequest) (\(_,_val3153) -> (case _val3153 of {T.TString _val3155 -> E.decodeUtf8 _val3155; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSquareChatRequest_reportType = P.maybe (reportSquareChatRequest_reportType default_ReportSquareChatRequest) (\(_,_val3153) -> (case _val3153 of {T.TI32 _val3156 -> P.toEnum $ P.fromIntegral _val3156; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  reportSquareChatRequest_otherReason = P.maybe (reportSquareChatRequest_otherReason default_ReportSquareChatRequest) (\(_,_val3153) -> (case _val3153 of {T.TString _val3157 -> E.decodeUtf8 _val3157; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_ReportSquareChatRequest _ = P.error "not a struct"
read_ReportSquareChatRequest :: T.Protocol p => p -> P.IO ReportSquareChatRequest
read_ReportSquareChatRequest iprot = to_ReportSquareChatRequest <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareChatRequest)
decode_ReportSquareChatRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareChatRequest
decode_ReportSquareChatRequest iprot bs = to_ReportSquareChatRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareChatRequest) bs
typemap_ReportSquareChatRequest :: T.TypeMap
typemap_ReportSquareChatRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("squareChatMid",T.T_STRING)),(5,("reportType",T.T_I32)),(6,("otherReason",T.T_STRING))]
default_ReportSquareChatRequest :: ReportSquareChatRequest
default_ReportSquareChatRequest = ReportSquareChatRequest{
  reportSquareChatRequest_squareMid = "",
  reportSquareChatRequest_squareChatMid = "",
  reportSquareChatRequest_reportType = (P.toEnum 0),
  reportSquareChatRequest_otherReason = ""}
data ReportSquareChatResponse = ReportSquareChatResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareChatResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReportSquareChatResponse where 
  arbitrary = QC.elements [ReportSquareChatResponse]
from_ReportSquareChatResponse :: ReportSquareChatResponse -> T.ThriftVal
from_ReportSquareChatResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReportSquareChatResponse :: T.Protocol p => p -> ReportSquareChatResponse -> P.IO ()
write_ReportSquareChatResponse oprot record = T.writeVal oprot $ from_ReportSquareChatResponse record
encode_ReportSquareChatResponse :: T.StatelessProtocol p => p -> ReportSquareChatResponse -> LBS.ByteString
encode_ReportSquareChatResponse oprot record = T.serializeVal oprot $ from_ReportSquareChatResponse record
to_ReportSquareChatResponse :: T.ThriftVal -> ReportSquareChatResponse
to_ReportSquareChatResponse (T.TStruct fields) = ReportSquareChatResponse{

  }
to_ReportSquareChatResponse _ = P.error "not a struct"
read_ReportSquareChatResponse :: T.Protocol p => p -> P.IO ReportSquareChatResponse
read_ReportSquareChatResponse iprot = to_ReportSquareChatResponse <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareChatResponse)
decode_ReportSquareChatResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareChatResponse
decode_ReportSquareChatResponse iprot bs = to_ReportSquareChatResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareChatResponse) bs
typemap_ReportSquareChatResponse :: T.TypeMap
typemap_ReportSquareChatResponse = Map.fromList []
default_ReportSquareChatResponse :: ReportSquareChatResponse
default_ReportSquareChatResponse = ReportSquareChatResponse{
}
data ReportSquareMessageRequest = ReportSquareMessageRequest  { reportSquareMessageRequest_squareMid :: LT.Text
  , reportSquareMessageRequest_squareChatMid :: LT.Text
  , reportSquareMessageRequest_squareMessageId :: LT.Text
  , reportSquareMessageRequest_reportType :: ReportType
  , reportSquareMessageRequest_otherReason :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMessageRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMessageRequest_squareMid record   `H.hashWithSalt` reportSquareMessageRequest_squareChatMid record   `H.hashWithSalt` reportSquareMessageRequest_squareMessageId record   `H.hashWithSalt` reportSquareMessageRequest_reportType record   `H.hashWithSalt` reportSquareMessageRequest_otherReason record  
instance QC.Arbitrary ReportSquareMessageRequest where 
  arbitrary = M.liftM ReportSquareMessageRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSquareMessageRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMessageRequest{reportSquareMessageRequest_squareMid = reportSquareMessageRequest_squareMid obj} then P.Nothing else P.Just $ default_ReportSquareMessageRequest{reportSquareMessageRequest_squareMid = reportSquareMessageRequest_squareMid obj}
    , if obj == default_ReportSquareMessageRequest{reportSquareMessageRequest_squareChatMid = reportSquareMessageRequest_squareChatMid obj} then P.Nothing else P.Just $ default_ReportSquareMessageRequest{reportSquareMessageRequest_squareChatMid = reportSquareMessageRequest_squareChatMid obj}
    , if obj == default_ReportSquareMessageRequest{reportSquareMessageRequest_squareMessageId = reportSquareMessageRequest_squareMessageId obj} then P.Nothing else P.Just $ default_ReportSquareMessageRequest{reportSquareMessageRequest_squareMessageId = reportSquareMessageRequest_squareMessageId obj}
    , if obj == default_ReportSquareMessageRequest{reportSquareMessageRequest_reportType = reportSquareMessageRequest_reportType obj} then P.Nothing else P.Just $ default_ReportSquareMessageRequest{reportSquareMessageRequest_reportType = reportSquareMessageRequest_reportType obj}
    , if obj == default_ReportSquareMessageRequest{reportSquareMessageRequest_otherReason = reportSquareMessageRequest_otherReason obj} then P.Nothing else P.Just $ default_ReportSquareMessageRequest{reportSquareMessageRequest_otherReason = reportSquareMessageRequest_otherReason obj}
    ]
from_ReportSquareMessageRequest :: ReportSquareMessageRequest -> T.ThriftVal
from_ReportSquareMessageRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3165 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3165))) $ reportSquareMessageRequest_squareMid record
  , (\_v3165 -> P.Just (3, ("squareChatMid",T.TString $ E.encodeUtf8 _v3165))) $ reportSquareMessageRequest_squareChatMid record
  , (\_v3165 -> P.Just (4, ("squareMessageId",T.TString $ E.encodeUtf8 _v3165))) $ reportSquareMessageRequest_squareMessageId record
  , (\_v3165 -> P.Just (5, ("reportType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3165))) $ reportSquareMessageRequest_reportType record
  , (\_v3165 -> P.Just (6, ("otherReason",T.TString $ E.encodeUtf8 _v3165))) $ reportSquareMessageRequest_otherReason record
  ]
write_ReportSquareMessageRequest :: T.Protocol p => p -> ReportSquareMessageRequest -> P.IO ()
write_ReportSquareMessageRequest oprot record = T.writeVal oprot $ from_ReportSquareMessageRequest record
encode_ReportSquareMessageRequest :: T.StatelessProtocol p => p -> ReportSquareMessageRequest -> LBS.ByteString
encode_ReportSquareMessageRequest oprot record = T.serializeVal oprot $ from_ReportSquareMessageRequest record
to_ReportSquareMessageRequest :: T.ThriftVal -> ReportSquareMessageRequest
to_ReportSquareMessageRequest (T.TStruct fields) = ReportSquareMessageRequest{
  reportSquareMessageRequest_squareMid = P.maybe (reportSquareMessageRequest_squareMid default_ReportSquareMessageRequest) (\(_,_val3167) -> (case _val3167 of {T.TString _val3168 -> E.decodeUtf8 _val3168; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSquareMessageRequest_squareChatMid = P.maybe (reportSquareMessageRequest_squareChatMid default_ReportSquareMessageRequest) (\(_,_val3167) -> (case _val3167 of {T.TString _val3169 -> E.decodeUtf8 _val3169; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSquareMessageRequest_squareMessageId = P.maybe (reportSquareMessageRequest_squareMessageId default_ReportSquareMessageRequest) (\(_,_val3167) -> (case _val3167 of {T.TString _val3170 -> E.decodeUtf8 _val3170; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  reportSquareMessageRequest_reportType = P.maybe (reportSquareMessageRequest_reportType default_ReportSquareMessageRequest) (\(_,_val3167) -> (case _val3167 of {T.TI32 _val3171 -> P.toEnum $ P.fromIntegral _val3171; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  reportSquareMessageRequest_otherReason = P.maybe (reportSquareMessageRequest_otherReason default_ReportSquareMessageRequest) (\(_,_val3167) -> (case _val3167 of {T.TString _val3172 -> E.decodeUtf8 _val3172; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_ReportSquareMessageRequest _ = P.error "not a struct"
read_ReportSquareMessageRequest :: T.Protocol p => p -> P.IO ReportSquareMessageRequest
read_ReportSquareMessageRequest iprot = to_ReportSquareMessageRequest <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMessageRequest)
decode_ReportSquareMessageRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMessageRequest
decode_ReportSquareMessageRequest iprot bs = to_ReportSquareMessageRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMessageRequest) bs
typemap_ReportSquareMessageRequest :: T.TypeMap
typemap_ReportSquareMessageRequest = Map.fromList [(2,("squareMid",T.T_STRING)),(3,("squareChatMid",T.T_STRING)),(4,("squareMessageId",T.T_STRING)),(5,("reportType",T.T_I32)),(6,("otherReason",T.T_STRING))]
default_ReportSquareMessageRequest :: ReportSquareMessageRequest
default_ReportSquareMessageRequest = ReportSquareMessageRequest{
  reportSquareMessageRequest_squareMid = "",
  reportSquareMessageRequest_squareChatMid = "",
  reportSquareMessageRequest_squareMessageId = "",
  reportSquareMessageRequest_reportType = (P.toEnum 0),
  reportSquareMessageRequest_otherReason = ""}
data ReportSquareMessageResponse = ReportSquareMessageResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMessageResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReportSquareMessageResponse where 
  arbitrary = QC.elements [ReportSquareMessageResponse]
from_ReportSquareMessageResponse :: ReportSquareMessageResponse -> T.ThriftVal
from_ReportSquareMessageResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReportSquareMessageResponse :: T.Protocol p => p -> ReportSquareMessageResponse -> P.IO ()
write_ReportSquareMessageResponse oprot record = T.writeVal oprot $ from_ReportSquareMessageResponse record
encode_ReportSquareMessageResponse :: T.StatelessProtocol p => p -> ReportSquareMessageResponse -> LBS.ByteString
encode_ReportSquareMessageResponse oprot record = T.serializeVal oprot $ from_ReportSquareMessageResponse record
to_ReportSquareMessageResponse :: T.ThriftVal -> ReportSquareMessageResponse
to_ReportSquareMessageResponse (T.TStruct fields) = ReportSquareMessageResponse{

  }
to_ReportSquareMessageResponse _ = P.error "not a struct"
read_ReportSquareMessageResponse :: T.Protocol p => p -> P.IO ReportSquareMessageResponse
read_ReportSquareMessageResponse iprot = to_ReportSquareMessageResponse <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMessageResponse)
decode_ReportSquareMessageResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMessageResponse
decode_ReportSquareMessageResponse iprot bs = to_ReportSquareMessageResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMessageResponse) bs
typemap_ReportSquareMessageResponse :: T.TypeMap
typemap_ReportSquareMessageResponse = Map.fromList []
default_ReportSquareMessageResponse :: ReportSquareMessageResponse
default_ReportSquareMessageResponse = ReportSquareMessageResponse{
}
data ReportSquareMemberRequest = ReportSquareMemberRequest  { reportSquareMemberRequest_squareMemberMid :: LT.Text
  , reportSquareMemberRequest_reportType :: ReportType
  , reportSquareMemberRequest_otherReason :: LT.Text
  , reportSquareMemberRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMemberRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMemberRequest_squareMemberMid record   `H.hashWithSalt` reportSquareMemberRequest_reportType record   `H.hashWithSalt` reportSquareMemberRequest_otherReason record   `H.hashWithSalt` reportSquareMemberRequest_squareChatMid record  
instance QC.Arbitrary ReportSquareMemberRequest where 
  arbitrary = M.liftM ReportSquareMemberRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSquareMemberRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMemberRequest{reportSquareMemberRequest_squareMemberMid = reportSquareMemberRequest_squareMemberMid obj} then P.Nothing else P.Just $ default_ReportSquareMemberRequest{reportSquareMemberRequest_squareMemberMid = reportSquareMemberRequest_squareMemberMid obj}
    , if obj == default_ReportSquareMemberRequest{reportSquareMemberRequest_reportType = reportSquareMemberRequest_reportType obj} then P.Nothing else P.Just $ default_ReportSquareMemberRequest{reportSquareMemberRequest_reportType = reportSquareMemberRequest_reportType obj}
    , if obj == default_ReportSquareMemberRequest{reportSquareMemberRequest_otherReason = reportSquareMemberRequest_otherReason obj} then P.Nothing else P.Just $ default_ReportSquareMemberRequest{reportSquareMemberRequest_otherReason = reportSquareMemberRequest_otherReason obj}
    , if obj == default_ReportSquareMemberRequest{reportSquareMemberRequest_squareChatMid = reportSquareMemberRequest_squareChatMid obj} then P.Nothing else P.Just $ default_ReportSquareMemberRequest{reportSquareMemberRequest_squareChatMid = reportSquareMemberRequest_squareChatMid obj}
    ]
from_ReportSquareMemberRequest :: ReportSquareMemberRequest -> T.ThriftVal
from_ReportSquareMemberRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3180 -> P.Just (2, ("squareMemberMid",T.TString $ E.encodeUtf8 _v3180))) $ reportSquareMemberRequest_squareMemberMid record
  , (\_v3180 -> P.Just (3, ("reportType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3180))) $ reportSquareMemberRequest_reportType record
  , (\_v3180 -> P.Just (4, ("otherReason",T.TString $ E.encodeUtf8 _v3180))) $ reportSquareMemberRequest_otherReason record
  , (\_v3180 -> P.Just (5, ("squareChatMid",T.TString $ E.encodeUtf8 _v3180))) $ reportSquareMemberRequest_squareChatMid record
  ]
write_ReportSquareMemberRequest :: T.Protocol p => p -> ReportSquareMemberRequest -> P.IO ()
write_ReportSquareMemberRequest oprot record = T.writeVal oprot $ from_ReportSquareMemberRequest record
encode_ReportSquareMemberRequest :: T.StatelessProtocol p => p -> ReportSquareMemberRequest -> LBS.ByteString
encode_ReportSquareMemberRequest oprot record = T.serializeVal oprot $ from_ReportSquareMemberRequest record
to_ReportSquareMemberRequest :: T.ThriftVal -> ReportSquareMemberRequest
to_ReportSquareMemberRequest (T.TStruct fields) = ReportSquareMemberRequest{
  reportSquareMemberRequest_squareMemberMid = P.maybe (reportSquareMemberRequest_squareMemberMid default_ReportSquareMemberRequest) (\(_,_val3182) -> (case _val3182 of {T.TString _val3183 -> E.decodeUtf8 _val3183; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSquareMemberRequest_reportType = P.maybe (reportSquareMemberRequest_reportType default_ReportSquareMemberRequest) (\(_,_val3182) -> (case _val3182 of {T.TI32 _val3184 -> P.toEnum $ P.fromIntegral _val3184; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSquareMemberRequest_otherReason = P.maybe (reportSquareMemberRequest_otherReason default_ReportSquareMemberRequest) (\(_,_val3182) -> (case _val3182 of {T.TString _val3185 -> E.decodeUtf8 _val3185; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  reportSquareMemberRequest_squareChatMid = P.maybe (reportSquareMemberRequest_squareChatMid default_ReportSquareMemberRequest) (\(_,_val3182) -> (case _val3182 of {T.TString _val3186 -> E.decodeUtf8 _val3186; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ReportSquareMemberRequest _ = P.error "not a struct"
read_ReportSquareMemberRequest :: T.Protocol p => p -> P.IO ReportSquareMemberRequest
read_ReportSquareMemberRequest iprot = to_ReportSquareMemberRequest <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMemberRequest)
decode_ReportSquareMemberRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMemberRequest
decode_ReportSquareMemberRequest iprot bs = to_ReportSquareMemberRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMemberRequest) bs
typemap_ReportSquareMemberRequest :: T.TypeMap
typemap_ReportSquareMemberRequest = Map.fromList [(2,("squareMemberMid",T.T_STRING)),(3,("reportType",T.T_I32)),(4,("otherReason",T.T_STRING)),(5,("squareChatMid",T.T_STRING))]
default_ReportSquareMemberRequest :: ReportSquareMemberRequest
default_ReportSquareMemberRequest = ReportSquareMemberRequest{
  reportSquareMemberRequest_squareMemberMid = "",
  reportSquareMemberRequest_reportType = (P.toEnum 0),
  reportSquareMemberRequest_otherReason = "",
  reportSquareMemberRequest_squareChatMid = ""}
data ReportSquareMemberResponse = ReportSquareMemberResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMemberResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReportSquareMemberResponse where 
  arbitrary = QC.elements [ReportSquareMemberResponse]
from_ReportSquareMemberResponse :: ReportSquareMemberResponse -> T.ThriftVal
from_ReportSquareMemberResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReportSquareMemberResponse :: T.Protocol p => p -> ReportSquareMemberResponse -> P.IO ()
write_ReportSquareMemberResponse oprot record = T.writeVal oprot $ from_ReportSquareMemberResponse record
encode_ReportSquareMemberResponse :: T.StatelessProtocol p => p -> ReportSquareMemberResponse -> LBS.ByteString
encode_ReportSquareMemberResponse oprot record = T.serializeVal oprot $ from_ReportSquareMemberResponse record
to_ReportSquareMemberResponse :: T.ThriftVal -> ReportSquareMemberResponse
to_ReportSquareMemberResponse (T.TStruct fields) = ReportSquareMemberResponse{

  }
to_ReportSquareMemberResponse _ = P.error "not a struct"
read_ReportSquareMemberResponse :: T.Protocol p => p -> P.IO ReportSquareMemberResponse
read_ReportSquareMemberResponse iprot = to_ReportSquareMemberResponse <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMemberResponse)
decode_ReportSquareMemberResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMemberResponse
decode_ReportSquareMemberResponse iprot bs = to_ReportSquareMemberResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMemberResponse) bs
typemap_ReportSquareMemberResponse :: T.TypeMap
typemap_ReportSquareMemberResponse = Map.fromList []
default_ReportSquareMemberResponse :: ReportSquareMemberResponse
default_ReportSquareMemberResponse = ReportSquareMemberResponse{
}
data GetSquareRequest = GetSquareRequest  { getSquareRequest_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareRequest_mid record  
instance QC.Arbitrary GetSquareRequest where 
  arbitrary = M.liftM GetSquareRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareRequest{getSquareRequest_mid = getSquareRequest_mid obj} then P.Nothing else P.Just $ default_GetSquareRequest{getSquareRequest_mid = getSquareRequest_mid obj}
    ]
from_GetSquareRequest :: GetSquareRequest -> T.ThriftVal
from_GetSquareRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3194 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v3194))) $ getSquareRequest_mid record
  ]
write_GetSquareRequest :: T.Protocol p => p -> GetSquareRequest -> P.IO ()
write_GetSquareRequest oprot record = T.writeVal oprot $ from_GetSquareRequest record
encode_GetSquareRequest :: T.StatelessProtocol p => p -> GetSquareRequest -> LBS.ByteString
encode_GetSquareRequest oprot record = T.serializeVal oprot $ from_GetSquareRequest record
to_GetSquareRequest :: T.ThriftVal -> GetSquareRequest
to_GetSquareRequest (T.TStruct fields) = GetSquareRequest{
  getSquareRequest_mid = P.maybe (getSquareRequest_mid default_GetSquareRequest) (\(_,_val3196) -> (case _val3196 of {T.TString _val3197 -> E.decodeUtf8 _val3197; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareRequest _ = P.error "not a struct"
read_GetSquareRequest :: T.Protocol p => p -> P.IO GetSquareRequest
read_GetSquareRequest iprot = to_GetSquareRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareRequest)
decode_GetSquareRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareRequest
decode_GetSquareRequest iprot bs = to_GetSquareRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareRequest) bs
typemap_GetSquareRequest :: T.TypeMap
typemap_GetSquareRequest = Map.fromList [(2,("mid",T.T_STRING))]
default_GetSquareRequest :: GetSquareRequest
default_GetSquareRequest = GetSquareRequest{
  getSquareRequest_mid = ""}
data GetSquareResponse = GetSquareResponse  { getSquareResponse_square :: Square
  , getSquareResponse_myMembership :: SquareMember
  , getSquareResponse_squareAuthority :: SquareAuthority
  , getSquareResponse_squareStatus :: SquareStatus
  , getSquareResponse_squareFeatureSet :: SquareFeatureSet
  , getSquareResponse_noteStatus :: NoteStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareResponse_square record   `H.hashWithSalt` getSquareResponse_myMembership record   `H.hashWithSalt` getSquareResponse_squareAuthority record   `H.hashWithSalt` getSquareResponse_squareStatus record   `H.hashWithSalt` getSquareResponse_squareFeatureSet record   `H.hashWithSalt` getSquareResponse_noteStatus record  
instance QC.Arbitrary GetSquareResponse where 
  arbitrary = M.liftM GetSquareResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSquareResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareResponse{getSquareResponse_square = getSquareResponse_square obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_square = getSquareResponse_square obj}
    , if obj == default_GetSquareResponse{getSquareResponse_myMembership = getSquareResponse_myMembership obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_myMembership = getSquareResponse_myMembership obj}
    , if obj == default_GetSquareResponse{getSquareResponse_squareAuthority = getSquareResponse_squareAuthority obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_squareAuthority = getSquareResponse_squareAuthority obj}
    , if obj == default_GetSquareResponse{getSquareResponse_squareStatus = getSquareResponse_squareStatus obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_squareStatus = getSquareResponse_squareStatus obj}
    , if obj == default_GetSquareResponse{getSquareResponse_squareFeatureSet = getSquareResponse_squareFeatureSet obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_squareFeatureSet = getSquareResponse_squareFeatureSet obj}
    , if obj == default_GetSquareResponse{getSquareResponse_noteStatus = getSquareResponse_noteStatus obj} then P.Nothing else P.Just $ default_GetSquareResponse{getSquareResponse_noteStatus = getSquareResponse_noteStatus obj}
    ]
from_GetSquareResponse :: GetSquareResponse -> T.ThriftVal
from_GetSquareResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3200 -> P.Just (1, ("square",from_Square _v3200))) $ getSquareResponse_square record
  , (\_v3200 -> P.Just (2, ("myMembership",from_SquareMember _v3200))) $ getSquareResponse_myMembership record
  , (\_v3200 -> P.Just (3, ("squareAuthority",from_SquareAuthority _v3200))) $ getSquareResponse_squareAuthority record
  , (\_v3200 -> P.Just (4, ("squareStatus",from_SquareStatus _v3200))) $ getSquareResponse_squareStatus record
  , (\_v3200 -> P.Just (5, ("squareFeatureSet",from_SquareFeatureSet _v3200))) $ getSquareResponse_squareFeatureSet record
  , (\_v3200 -> P.Just (6, ("noteStatus",from_NoteStatus _v3200))) $ getSquareResponse_noteStatus record
  ]
write_GetSquareResponse :: T.Protocol p => p -> GetSquareResponse -> P.IO ()
write_GetSquareResponse oprot record = T.writeVal oprot $ from_GetSquareResponse record
encode_GetSquareResponse :: T.StatelessProtocol p => p -> GetSquareResponse -> LBS.ByteString
encode_GetSquareResponse oprot record = T.serializeVal oprot $ from_GetSquareResponse record
to_GetSquareResponse :: T.ThriftVal -> GetSquareResponse
to_GetSquareResponse (T.TStruct fields) = GetSquareResponse{
  getSquareResponse_square = P.maybe (getSquareResponse_square default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3203 -> (to_Square (T.TStruct _val3203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSquareResponse_myMembership = P.maybe (getSquareResponse_myMembership default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3204 -> (to_SquareMember (T.TStruct _val3204)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSquareResponse_squareAuthority = P.maybe (getSquareResponse_squareAuthority default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3205 -> (to_SquareAuthority (T.TStruct _val3205)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getSquareResponse_squareStatus = P.maybe (getSquareResponse_squareStatus default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3206 -> (to_SquareStatus (T.TStruct _val3206)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getSquareResponse_squareFeatureSet = P.maybe (getSquareResponse_squareFeatureSet default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3207 -> (to_SquareFeatureSet (T.TStruct _val3207)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getSquareResponse_noteStatus = P.maybe (getSquareResponse_noteStatus default_GetSquareResponse) (\(_,_val3202) -> (case _val3202 of {T.TStruct _val3208 -> (to_NoteStatus (T.TStruct _val3208)); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetSquareResponse _ = P.error "not a struct"
read_GetSquareResponse :: T.Protocol p => p -> P.IO GetSquareResponse
read_GetSquareResponse iprot = to_GetSquareResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareResponse)
decode_GetSquareResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareResponse
decode_GetSquareResponse iprot bs = to_GetSquareResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareResponse) bs
typemap_GetSquareResponse :: T.TypeMap
typemap_GetSquareResponse = Map.fromList [(1,("square",(T.T_STRUCT typemap_Square))),(2,("myMembership",(T.T_STRUCT typemap_SquareMember))),(3,("squareAuthority",(T.T_STRUCT typemap_SquareAuthority))),(4,("squareStatus",(T.T_STRUCT typemap_SquareStatus))),(5,("squareFeatureSet",(T.T_STRUCT typemap_SquareFeatureSet))),(6,("noteStatus",(T.T_STRUCT typemap_NoteStatus)))]
default_GetSquareResponse :: GetSquareResponse
default_GetSquareResponse = GetSquareResponse{
  getSquareResponse_square = default_Square,
  getSquareResponse_myMembership = default_SquareMember,
  getSquareResponse_squareAuthority = default_SquareAuthority,
  getSquareResponse_squareStatus = default_SquareStatus,
  getSquareResponse_squareFeatureSet = default_SquareFeatureSet,
  getSquareResponse_noteStatus = default_NoteStatus}
data GetSquareStatusRequest = GetSquareStatusRequest  { getSquareStatusRequest_squareMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareStatusRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareStatusRequest_squareMid record  
instance QC.Arbitrary GetSquareStatusRequest where 
  arbitrary = M.liftM GetSquareStatusRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareStatusRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareStatusRequest{getSquareStatusRequest_squareMid = getSquareStatusRequest_squareMid obj} then P.Nothing else P.Just $ default_GetSquareStatusRequest{getSquareStatusRequest_squareMid = getSquareStatusRequest_squareMid obj}
    ]
from_GetSquareStatusRequest :: GetSquareStatusRequest -> T.ThriftVal
from_GetSquareStatusRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3211 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3211))) $ getSquareStatusRequest_squareMid record
  ]
write_GetSquareStatusRequest :: T.Protocol p => p -> GetSquareStatusRequest -> P.IO ()
write_GetSquareStatusRequest oprot record = T.writeVal oprot $ from_GetSquareStatusRequest record
encode_GetSquareStatusRequest :: T.StatelessProtocol p => p -> GetSquareStatusRequest -> LBS.ByteString
encode_GetSquareStatusRequest oprot record = T.serializeVal oprot $ from_GetSquareStatusRequest record
to_GetSquareStatusRequest :: T.ThriftVal -> GetSquareStatusRequest
to_GetSquareStatusRequest (T.TStruct fields) = GetSquareStatusRequest{
  getSquareStatusRequest_squareMid = P.maybe (getSquareStatusRequest_squareMid default_GetSquareStatusRequest) (\(_,_val3213) -> (case _val3213 of {T.TString _val3214 -> E.decodeUtf8 _val3214; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareStatusRequest _ = P.error "not a struct"
read_GetSquareStatusRequest :: T.Protocol p => p -> P.IO GetSquareStatusRequest
read_GetSquareStatusRequest iprot = to_GetSquareStatusRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareStatusRequest)
decode_GetSquareStatusRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareStatusRequest
decode_GetSquareStatusRequest iprot bs = to_GetSquareStatusRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareStatusRequest) bs
typemap_GetSquareStatusRequest :: T.TypeMap
typemap_GetSquareStatusRequest = Map.fromList [(2,("squareMid",T.T_STRING))]
default_GetSquareStatusRequest :: GetSquareStatusRequest
default_GetSquareStatusRequest = GetSquareStatusRequest{
  getSquareStatusRequest_squareMid = ""}
data GetSquareStatusResponse = GetSquareStatusResponse  { getSquareStatusResponse_squareStatus :: SquareStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareStatusResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareStatusResponse_squareStatus record  
instance QC.Arbitrary GetSquareStatusResponse where 
  arbitrary = M.liftM GetSquareStatusResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareStatusResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareStatusResponse{getSquareStatusResponse_squareStatus = getSquareStatusResponse_squareStatus obj} then P.Nothing else P.Just $ default_GetSquareStatusResponse{getSquareStatusResponse_squareStatus = getSquareStatusResponse_squareStatus obj}
    ]
from_GetSquareStatusResponse :: GetSquareStatusResponse -> T.ThriftVal
from_GetSquareStatusResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3217 -> P.Just (1, ("squareStatus",from_SquareStatus _v3217))) $ getSquareStatusResponse_squareStatus record
  ]
write_GetSquareStatusResponse :: T.Protocol p => p -> GetSquareStatusResponse -> P.IO ()
write_GetSquareStatusResponse oprot record = T.writeVal oprot $ from_GetSquareStatusResponse record
encode_GetSquareStatusResponse :: T.StatelessProtocol p => p -> GetSquareStatusResponse -> LBS.ByteString
encode_GetSquareStatusResponse oprot record = T.serializeVal oprot $ from_GetSquareStatusResponse record
to_GetSquareStatusResponse :: T.ThriftVal -> GetSquareStatusResponse
to_GetSquareStatusResponse (T.TStruct fields) = GetSquareStatusResponse{
  getSquareStatusResponse_squareStatus = P.maybe (getSquareStatusResponse_squareStatus default_GetSquareStatusResponse) (\(_,_val3219) -> (case _val3219 of {T.TStruct _val3220 -> (to_SquareStatus (T.TStruct _val3220)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareStatusResponse _ = P.error "not a struct"
read_GetSquareStatusResponse :: T.Protocol p => p -> P.IO GetSquareStatusResponse
read_GetSquareStatusResponse iprot = to_GetSquareStatusResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareStatusResponse)
decode_GetSquareStatusResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareStatusResponse
decode_GetSquareStatusResponse iprot bs = to_GetSquareStatusResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareStatusResponse) bs
typemap_GetSquareStatusResponse :: T.TypeMap
typemap_GetSquareStatusResponse = Map.fromList [(1,("squareStatus",(T.T_STRUCT typemap_SquareStatus)))]
default_GetSquareStatusResponse :: GetSquareStatusResponse
default_GetSquareStatusResponse = GetSquareStatusResponse{
  getSquareStatusResponse_squareStatus = default_SquareStatus}
data GetNoteStatusRequest = GetNoteStatusRequest  { getNoteStatusRequest_squareMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteStatusRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteStatusRequest_squareMid record  
instance QC.Arbitrary GetNoteStatusRequest where 
  arbitrary = M.liftM GetNoteStatusRequest (QC.arbitrary)
  shrink obj | obj == default_GetNoteStatusRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteStatusRequest{getNoteStatusRequest_squareMid = getNoteStatusRequest_squareMid obj} then P.Nothing else P.Just $ default_GetNoteStatusRequest{getNoteStatusRequest_squareMid = getNoteStatusRequest_squareMid obj}
    ]
from_GetNoteStatusRequest :: GetNoteStatusRequest -> T.ThriftVal
from_GetNoteStatusRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3223 -> P.Just (2, ("squareMid",T.TString $ E.encodeUtf8 _v3223))) $ getNoteStatusRequest_squareMid record
  ]
write_GetNoteStatusRequest :: T.Protocol p => p -> GetNoteStatusRequest -> P.IO ()
write_GetNoteStatusRequest oprot record = T.writeVal oprot $ from_GetNoteStatusRequest record
encode_GetNoteStatusRequest :: T.StatelessProtocol p => p -> GetNoteStatusRequest -> LBS.ByteString
encode_GetNoteStatusRequest oprot record = T.serializeVal oprot $ from_GetNoteStatusRequest record
to_GetNoteStatusRequest :: T.ThriftVal -> GetNoteStatusRequest
to_GetNoteStatusRequest (T.TStruct fields) = GetNoteStatusRequest{
  getNoteStatusRequest_squareMid = P.maybe (getNoteStatusRequest_squareMid default_GetNoteStatusRequest) (\(_,_val3225) -> (case _val3225 of {T.TString _val3226 -> E.decodeUtf8 _val3226; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNoteStatusRequest _ = P.error "not a struct"
read_GetNoteStatusRequest :: T.Protocol p => p -> P.IO GetNoteStatusRequest
read_GetNoteStatusRequest iprot = to_GetNoteStatusRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteStatusRequest)
decode_GetNoteStatusRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteStatusRequest
decode_GetNoteStatusRequest iprot bs = to_GetNoteStatusRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteStatusRequest) bs
typemap_GetNoteStatusRequest :: T.TypeMap
typemap_GetNoteStatusRequest = Map.fromList [(2,("squareMid",T.T_STRING))]
default_GetNoteStatusRequest :: GetNoteStatusRequest
default_GetNoteStatusRequest = GetNoteStatusRequest{
  getNoteStatusRequest_squareMid = ""}
data GetNoteStatusResponse = GetNoteStatusResponse  { getNoteStatusResponse_squareMid :: LT.Text
  , getNoteStatusResponse_status :: NoteStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteStatusResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteStatusResponse_squareMid record   `H.hashWithSalt` getNoteStatusResponse_status record  
instance QC.Arbitrary GetNoteStatusResponse where 
  arbitrary = M.liftM GetNoteStatusResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteStatusResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteStatusResponse{getNoteStatusResponse_squareMid = getNoteStatusResponse_squareMid obj} then P.Nothing else P.Just $ default_GetNoteStatusResponse{getNoteStatusResponse_squareMid = getNoteStatusResponse_squareMid obj}
    , if obj == default_GetNoteStatusResponse{getNoteStatusResponse_status = getNoteStatusResponse_status obj} then P.Nothing else P.Just $ default_GetNoteStatusResponse{getNoteStatusResponse_status = getNoteStatusResponse_status obj}
    ]
from_GetNoteStatusResponse :: GetNoteStatusResponse -> T.ThriftVal
from_GetNoteStatusResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3229 -> P.Just (1, ("squareMid",T.TString $ E.encodeUtf8 _v3229))) $ getNoteStatusResponse_squareMid record
  , (\_v3229 -> P.Just (2, ("status",from_NoteStatus _v3229))) $ getNoteStatusResponse_status record
  ]
write_GetNoteStatusResponse :: T.Protocol p => p -> GetNoteStatusResponse -> P.IO ()
write_GetNoteStatusResponse oprot record = T.writeVal oprot $ from_GetNoteStatusResponse record
encode_GetNoteStatusResponse :: T.StatelessProtocol p => p -> GetNoteStatusResponse -> LBS.ByteString
encode_GetNoteStatusResponse oprot record = T.serializeVal oprot $ from_GetNoteStatusResponse record
to_GetNoteStatusResponse :: T.ThriftVal -> GetNoteStatusResponse
to_GetNoteStatusResponse (T.TStruct fields) = GetNoteStatusResponse{
  getNoteStatusResponse_squareMid = P.maybe (getNoteStatusResponse_squareMid default_GetNoteStatusResponse) (\(_,_val3231) -> (case _val3231 of {T.TString _val3232 -> E.decodeUtf8 _val3232; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteStatusResponse_status = P.maybe (getNoteStatusResponse_status default_GetNoteStatusResponse) (\(_,_val3231) -> (case _val3231 of {T.TStruct _val3233 -> (to_NoteStatus (T.TStruct _val3233)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNoteStatusResponse _ = P.error "not a struct"
read_GetNoteStatusResponse :: T.Protocol p => p -> P.IO GetNoteStatusResponse
read_GetNoteStatusResponse iprot = to_GetNoteStatusResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteStatusResponse)
decode_GetNoteStatusResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteStatusResponse
decode_GetNoteStatusResponse iprot bs = to_GetNoteStatusResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteStatusResponse) bs
typemap_GetNoteStatusResponse :: T.TypeMap
typemap_GetNoteStatusResponse = Map.fromList [(1,("squareMid",T.T_STRING)),(2,("status",(T.T_STRUCT typemap_NoteStatus)))]
default_GetNoteStatusResponse :: GetNoteStatusResponse
default_GetNoteStatusResponse = GetNoteStatusResponse{
  getNoteStatusResponse_squareMid = "",
  getNoteStatusResponse_status = default_NoteStatus}
data CreateSquareChatAnnouncementRequest = CreateSquareChatAnnouncementRequest  { createSquareChatAnnouncementRequest_reqSeq :: I.Int32
  , createSquareChatAnnouncementRequest_squareChatMid :: LT.Text
  , createSquareChatAnnouncementRequest_squareChatAnnouncement :: SquareChatAnnouncement
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatAnnouncementRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatAnnouncementRequest_reqSeq record   `H.hashWithSalt` createSquareChatAnnouncementRequest_squareChatMid record   `H.hashWithSalt` createSquareChatAnnouncementRequest_squareChatAnnouncement record  
instance QC.Arbitrary CreateSquareChatAnnouncementRequest where 
  arbitrary = M.liftM CreateSquareChatAnnouncementRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatAnnouncementRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_reqSeq = createSquareChatAnnouncementRequest_reqSeq obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_reqSeq = createSquareChatAnnouncementRequest_reqSeq obj}
    , if obj == default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_squareChatMid = createSquareChatAnnouncementRequest_squareChatMid obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_squareChatMid = createSquareChatAnnouncementRequest_squareChatMid obj}
    , if obj == default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_squareChatAnnouncement = createSquareChatAnnouncementRequest_squareChatAnnouncement obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncementRequest{createSquareChatAnnouncementRequest_squareChatAnnouncement = createSquareChatAnnouncementRequest_squareChatAnnouncement obj}
    ]
from_CreateSquareChatAnnouncementRequest :: CreateSquareChatAnnouncementRequest -> T.ThriftVal
from_CreateSquareChatAnnouncementRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3236 -> P.Just (1, ("reqSeq",T.TI32 _v3236))) $ createSquareChatAnnouncementRequest_reqSeq record
  , (\_v3236 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v3236))) $ createSquareChatAnnouncementRequest_squareChatMid record
  , (\_v3236 -> P.Just (3, ("squareChatAnnouncement",from_SquareChatAnnouncement _v3236))) $ createSquareChatAnnouncementRequest_squareChatAnnouncement record
  ]
write_CreateSquareChatAnnouncementRequest :: T.Protocol p => p -> CreateSquareChatAnnouncementRequest -> P.IO ()
write_CreateSquareChatAnnouncementRequest oprot record = T.writeVal oprot $ from_CreateSquareChatAnnouncementRequest record
encode_CreateSquareChatAnnouncementRequest :: T.StatelessProtocol p => p -> CreateSquareChatAnnouncementRequest -> LBS.ByteString
encode_CreateSquareChatAnnouncementRequest oprot record = T.serializeVal oprot $ from_CreateSquareChatAnnouncementRequest record
to_CreateSquareChatAnnouncementRequest :: T.ThriftVal -> CreateSquareChatAnnouncementRequest
to_CreateSquareChatAnnouncementRequest (T.TStruct fields) = CreateSquareChatAnnouncementRequest{
  createSquareChatAnnouncementRequest_reqSeq = P.maybe (createSquareChatAnnouncementRequest_reqSeq default_CreateSquareChatAnnouncementRequest) (\(_,_val3238) -> (case _val3238 of {T.TI32 _val3239 -> _val3239; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSquareChatAnnouncementRequest_squareChatMid = P.maybe (createSquareChatAnnouncementRequest_squareChatMid default_CreateSquareChatAnnouncementRequest) (\(_,_val3238) -> (case _val3238 of {T.TString _val3240 -> E.decodeUtf8 _val3240; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createSquareChatAnnouncementRequest_squareChatAnnouncement = P.maybe (createSquareChatAnnouncementRequest_squareChatAnnouncement default_CreateSquareChatAnnouncementRequest) (\(_,_val3238) -> (case _val3238 of {T.TStruct _val3241 -> (to_SquareChatAnnouncement (T.TStruct _val3241)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateSquareChatAnnouncementRequest _ = P.error "not a struct"
read_CreateSquareChatAnnouncementRequest :: T.Protocol p => p -> P.IO CreateSquareChatAnnouncementRequest
read_CreateSquareChatAnnouncementRequest iprot = to_CreateSquareChatAnnouncementRequest <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncementRequest)
decode_CreateSquareChatAnnouncementRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatAnnouncementRequest
decode_CreateSquareChatAnnouncementRequest iprot bs = to_CreateSquareChatAnnouncementRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncementRequest) bs
typemap_CreateSquareChatAnnouncementRequest :: T.TypeMap
typemap_CreateSquareChatAnnouncementRequest = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("squareChatMid",T.T_STRING)),(3,("squareChatAnnouncement",(T.T_STRUCT typemap_SquareChatAnnouncement)))]
default_CreateSquareChatAnnouncementRequest :: CreateSquareChatAnnouncementRequest
default_CreateSquareChatAnnouncementRequest = CreateSquareChatAnnouncementRequest{
  createSquareChatAnnouncementRequest_reqSeq = 0,
  createSquareChatAnnouncementRequest_squareChatMid = "",
  createSquareChatAnnouncementRequest_squareChatAnnouncement = default_SquareChatAnnouncement}
data CreateSquareChatAnnouncementResponse = CreateSquareChatAnnouncementResponse  { createSquareChatAnnouncementResponse_announcement :: SquareChatAnnouncement
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatAnnouncementResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatAnnouncementResponse_announcement record  
instance QC.Arbitrary CreateSquareChatAnnouncementResponse where 
  arbitrary = M.liftM CreateSquareChatAnnouncementResponse (QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatAnnouncementResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatAnnouncementResponse{createSquareChatAnnouncementResponse_announcement = createSquareChatAnnouncementResponse_announcement obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncementResponse{createSquareChatAnnouncementResponse_announcement = createSquareChatAnnouncementResponse_announcement obj}
    ]
from_CreateSquareChatAnnouncementResponse :: CreateSquareChatAnnouncementResponse -> T.ThriftVal
from_CreateSquareChatAnnouncementResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3244 -> P.Just (1, ("announcement",from_SquareChatAnnouncement _v3244))) $ createSquareChatAnnouncementResponse_announcement record
  ]
write_CreateSquareChatAnnouncementResponse :: T.Protocol p => p -> CreateSquareChatAnnouncementResponse -> P.IO ()
write_CreateSquareChatAnnouncementResponse oprot record = T.writeVal oprot $ from_CreateSquareChatAnnouncementResponse record
encode_CreateSquareChatAnnouncementResponse :: T.StatelessProtocol p => p -> CreateSquareChatAnnouncementResponse -> LBS.ByteString
encode_CreateSquareChatAnnouncementResponse oprot record = T.serializeVal oprot $ from_CreateSquareChatAnnouncementResponse record
to_CreateSquareChatAnnouncementResponse :: T.ThriftVal -> CreateSquareChatAnnouncementResponse
to_CreateSquareChatAnnouncementResponse (T.TStruct fields) = CreateSquareChatAnnouncementResponse{
  createSquareChatAnnouncementResponse_announcement = P.maybe (createSquareChatAnnouncementResponse_announcement default_CreateSquareChatAnnouncementResponse) (\(_,_val3246) -> (case _val3246 of {T.TStruct _val3247 -> (to_SquareChatAnnouncement (T.TStruct _val3247)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquareChatAnnouncementResponse _ = P.error "not a struct"
read_CreateSquareChatAnnouncementResponse :: T.Protocol p => p -> P.IO CreateSquareChatAnnouncementResponse
read_CreateSquareChatAnnouncementResponse iprot = to_CreateSquareChatAnnouncementResponse <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncementResponse)
decode_CreateSquareChatAnnouncementResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatAnnouncementResponse
decode_CreateSquareChatAnnouncementResponse iprot bs = to_CreateSquareChatAnnouncementResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncementResponse) bs
typemap_CreateSquareChatAnnouncementResponse :: T.TypeMap
typemap_CreateSquareChatAnnouncementResponse = Map.fromList [(1,("announcement",(T.T_STRUCT typemap_SquareChatAnnouncement)))]
default_CreateSquareChatAnnouncementResponse :: CreateSquareChatAnnouncementResponse
default_CreateSquareChatAnnouncementResponse = CreateSquareChatAnnouncementResponse{
  createSquareChatAnnouncementResponse_announcement = default_SquareChatAnnouncement}
data DeleteSquareChatAnnouncementRequest = DeleteSquareChatAnnouncementRequest  { deleteSquareChatAnnouncementRequest_squareChatMid :: LT.Text
  , deleteSquareChatAnnouncementRequest_announcementSeq :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatAnnouncementRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChatAnnouncementRequest_squareChatMid record   `H.hashWithSalt` deleteSquareChatAnnouncementRequest_announcementSeq record  
instance QC.Arbitrary DeleteSquareChatAnnouncementRequest where 
  arbitrary = M.liftM DeleteSquareChatAnnouncementRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChatAnnouncementRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChatAnnouncementRequest{deleteSquareChatAnnouncementRequest_squareChatMid = deleteSquareChatAnnouncementRequest_squareChatMid obj} then P.Nothing else P.Just $ default_DeleteSquareChatAnnouncementRequest{deleteSquareChatAnnouncementRequest_squareChatMid = deleteSquareChatAnnouncementRequest_squareChatMid obj}
    , if obj == default_DeleteSquareChatAnnouncementRequest{deleteSquareChatAnnouncementRequest_announcementSeq = deleteSquareChatAnnouncementRequest_announcementSeq obj} then P.Nothing else P.Just $ default_DeleteSquareChatAnnouncementRequest{deleteSquareChatAnnouncementRequest_announcementSeq = deleteSquareChatAnnouncementRequest_announcementSeq obj}
    ]
from_DeleteSquareChatAnnouncementRequest :: DeleteSquareChatAnnouncementRequest -> T.ThriftVal
from_DeleteSquareChatAnnouncementRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3250 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v3250))) $ deleteSquareChatAnnouncementRequest_squareChatMid record
  , (\_v3250 -> P.Just (3, ("announcementSeq",T.TI64 _v3250))) $ deleteSquareChatAnnouncementRequest_announcementSeq record
  ]
write_DeleteSquareChatAnnouncementRequest :: T.Protocol p => p -> DeleteSquareChatAnnouncementRequest -> P.IO ()
write_DeleteSquareChatAnnouncementRequest oprot record = T.writeVal oprot $ from_DeleteSquareChatAnnouncementRequest record
encode_DeleteSquareChatAnnouncementRequest :: T.StatelessProtocol p => p -> DeleteSquareChatAnnouncementRequest -> LBS.ByteString
encode_DeleteSquareChatAnnouncementRequest oprot record = T.serializeVal oprot $ from_DeleteSquareChatAnnouncementRequest record
to_DeleteSquareChatAnnouncementRequest :: T.ThriftVal -> DeleteSquareChatAnnouncementRequest
to_DeleteSquareChatAnnouncementRequest (T.TStruct fields) = DeleteSquareChatAnnouncementRequest{
  deleteSquareChatAnnouncementRequest_squareChatMid = P.maybe (deleteSquareChatAnnouncementRequest_squareChatMid default_DeleteSquareChatAnnouncementRequest) (\(_,_val3252) -> (case _val3252 of {T.TString _val3253 -> E.decodeUtf8 _val3253; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deleteSquareChatAnnouncementRequest_announcementSeq = P.maybe (deleteSquareChatAnnouncementRequest_announcementSeq default_DeleteSquareChatAnnouncementRequest) (\(_,_val3252) -> (case _val3252 of {T.TI64 _val3254 -> _val3254; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_DeleteSquareChatAnnouncementRequest _ = P.error "not a struct"
read_DeleteSquareChatAnnouncementRequest :: T.Protocol p => p -> P.IO DeleteSquareChatAnnouncementRequest
read_DeleteSquareChatAnnouncementRequest iprot = to_DeleteSquareChatAnnouncementRequest <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncementRequest)
decode_DeleteSquareChatAnnouncementRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatAnnouncementRequest
decode_DeleteSquareChatAnnouncementRequest iprot bs = to_DeleteSquareChatAnnouncementRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncementRequest) bs
typemap_DeleteSquareChatAnnouncementRequest :: T.TypeMap
typemap_DeleteSquareChatAnnouncementRequest = Map.fromList [(2,("squareChatMid",T.T_STRING)),(3,("announcementSeq",T.T_I64))]
default_DeleteSquareChatAnnouncementRequest :: DeleteSquareChatAnnouncementRequest
default_DeleteSquareChatAnnouncementRequest = DeleteSquareChatAnnouncementRequest{
  deleteSquareChatAnnouncementRequest_squareChatMid = "",
  deleteSquareChatAnnouncementRequest_announcementSeq = 0}
data DeleteSquareChatAnnouncementResponse = DeleteSquareChatAnnouncementResponse deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatAnnouncementResponse where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DeleteSquareChatAnnouncementResponse where 
  arbitrary = QC.elements [DeleteSquareChatAnnouncementResponse]
from_DeleteSquareChatAnnouncementResponse :: DeleteSquareChatAnnouncementResponse -> T.ThriftVal
from_DeleteSquareChatAnnouncementResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DeleteSquareChatAnnouncementResponse :: T.Protocol p => p -> DeleteSquareChatAnnouncementResponse -> P.IO ()
write_DeleteSquareChatAnnouncementResponse oprot record = T.writeVal oprot $ from_DeleteSquareChatAnnouncementResponse record
encode_DeleteSquareChatAnnouncementResponse :: T.StatelessProtocol p => p -> DeleteSquareChatAnnouncementResponse -> LBS.ByteString
encode_DeleteSquareChatAnnouncementResponse oprot record = T.serializeVal oprot $ from_DeleteSquareChatAnnouncementResponse record
to_DeleteSquareChatAnnouncementResponse :: T.ThriftVal -> DeleteSquareChatAnnouncementResponse
to_DeleteSquareChatAnnouncementResponse (T.TStruct fields) = DeleteSquareChatAnnouncementResponse{

  }
to_DeleteSquareChatAnnouncementResponse _ = P.error "not a struct"
read_DeleteSquareChatAnnouncementResponse :: T.Protocol p => p -> P.IO DeleteSquareChatAnnouncementResponse
read_DeleteSquareChatAnnouncementResponse iprot = to_DeleteSquareChatAnnouncementResponse <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncementResponse)
decode_DeleteSquareChatAnnouncementResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatAnnouncementResponse
decode_DeleteSquareChatAnnouncementResponse iprot bs = to_DeleteSquareChatAnnouncementResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncementResponse) bs
typemap_DeleteSquareChatAnnouncementResponse :: T.TypeMap
typemap_DeleteSquareChatAnnouncementResponse = Map.fromList []
default_DeleteSquareChatAnnouncementResponse :: DeleteSquareChatAnnouncementResponse
default_DeleteSquareChatAnnouncementResponse = DeleteSquareChatAnnouncementResponse{
}
data GetSquareChatAnnouncementsRequest = GetSquareChatAnnouncementsRequest  { getSquareChatAnnouncementsRequest_squareChatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatAnnouncementsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatAnnouncementsRequest_squareChatMid record  
instance QC.Arbitrary GetSquareChatAnnouncementsRequest where 
  arbitrary = M.liftM GetSquareChatAnnouncementsRequest (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatAnnouncementsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatAnnouncementsRequest{getSquareChatAnnouncementsRequest_squareChatMid = getSquareChatAnnouncementsRequest_squareChatMid obj} then P.Nothing else P.Just $ default_GetSquareChatAnnouncementsRequest{getSquareChatAnnouncementsRequest_squareChatMid = getSquareChatAnnouncementsRequest_squareChatMid obj}
    ]
from_GetSquareChatAnnouncementsRequest :: GetSquareChatAnnouncementsRequest -> T.ThriftVal
from_GetSquareChatAnnouncementsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3262 -> P.Just (2, ("squareChatMid",T.TString $ E.encodeUtf8 _v3262))) $ getSquareChatAnnouncementsRequest_squareChatMid record
  ]
write_GetSquareChatAnnouncementsRequest :: T.Protocol p => p -> GetSquareChatAnnouncementsRequest -> P.IO ()
write_GetSquareChatAnnouncementsRequest oprot record = T.writeVal oprot $ from_GetSquareChatAnnouncementsRequest record
encode_GetSquareChatAnnouncementsRequest :: T.StatelessProtocol p => p -> GetSquareChatAnnouncementsRequest -> LBS.ByteString
encode_GetSquareChatAnnouncementsRequest oprot record = T.serializeVal oprot $ from_GetSquareChatAnnouncementsRequest record
to_GetSquareChatAnnouncementsRequest :: T.ThriftVal -> GetSquareChatAnnouncementsRequest
to_GetSquareChatAnnouncementsRequest (T.TStruct fields) = GetSquareChatAnnouncementsRequest{
  getSquareChatAnnouncementsRequest_squareChatMid = P.maybe (getSquareChatAnnouncementsRequest_squareChatMid default_GetSquareChatAnnouncementsRequest) (\(_,_val3264) -> (case _val3264 of {T.TString _val3265 -> E.decodeUtf8 _val3265; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSquareChatAnnouncementsRequest _ = P.error "not a struct"
read_GetSquareChatAnnouncementsRequest :: T.Protocol p => p -> P.IO GetSquareChatAnnouncementsRequest
read_GetSquareChatAnnouncementsRequest iprot = to_GetSquareChatAnnouncementsRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncementsRequest)
decode_GetSquareChatAnnouncementsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatAnnouncementsRequest
decode_GetSquareChatAnnouncementsRequest iprot bs = to_GetSquareChatAnnouncementsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncementsRequest) bs
typemap_GetSquareChatAnnouncementsRequest :: T.TypeMap
typemap_GetSquareChatAnnouncementsRequest = Map.fromList [(2,("squareChatMid",T.T_STRING))]
default_GetSquareChatAnnouncementsRequest :: GetSquareChatAnnouncementsRequest
default_GetSquareChatAnnouncementsRequest = GetSquareChatAnnouncementsRequest{
  getSquareChatAnnouncementsRequest_squareChatMid = ""}
data GetSquareChatAnnouncementsResponse = GetSquareChatAnnouncementsResponse  { getSquareChatAnnouncementsResponse_announcements :: (Vector.Vector SquareChatAnnouncement)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatAnnouncementsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatAnnouncementsResponse_announcements record  
instance QC.Arbitrary GetSquareChatAnnouncementsResponse where 
  arbitrary = M.liftM GetSquareChatAnnouncementsResponse (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatAnnouncementsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatAnnouncementsResponse{getSquareChatAnnouncementsResponse_announcements = getSquareChatAnnouncementsResponse_announcements obj} then P.Nothing else P.Just $ default_GetSquareChatAnnouncementsResponse{getSquareChatAnnouncementsResponse_announcements = getSquareChatAnnouncementsResponse_announcements obj}
    ]
from_GetSquareChatAnnouncementsResponse :: GetSquareChatAnnouncementsResponse -> T.ThriftVal
from_GetSquareChatAnnouncementsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3268 -> P.Just (1, ("announcements",T.TList (T.T_STRUCT typemap_SquareChatAnnouncement) $ P.map (\_v3270 -> from_SquareChatAnnouncement _v3270) $ Vector.toList _v3268))) $ getSquareChatAnnouncementsResponse_announcements record
  ]
write_GetSquareChatAnnouncementsResponse :: T.Protocol p => p -> GetSquareChatAnnouncementsResponse -> P.IO ()
write_GetSquareChatAnnouncementsResponse oprot record = T.writeVal oprot $ from_GetSquareChatAnnouncementsResponse record
encode_GetSquareChatAnnouncementsResponse :: T.StatelessProtocol p => p -> GetSquareChatAnnouncementsResponse -> LBS.ByteString
encode_GetSquareChatAnnouncementsResponse oprot record = T.serializeVal oprot $ from_GetSquareChatAnnouncementsResponse record
to_GetSquareChatAnnouncementsResponse :: T.ThriftVal -> GetSquareChatAnnouncementsResponse
to_GetSquareChatAnnouncementsResponse (T.TStruct fields) = GetSquareChatAnnouncementsResponse{
  getSquareChatAnnouncementsResponse_announcements = P.maybe (getSquareChatAnnouncementsResponse_announcements default_GetSquareChatAnnouncementsResponse) (\(_,_val3272) -> (case _val3272 of {T.TList _ _val3273 -> (Vector.fromList $ P.map (\_v3274 -> (case _v3274 of {T.TStruct _val3275 -> (to_SquareChatAnnouncement (T.TStruct _val3275)); _ -> P.error "wrong type"})) _val3273); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatAnnouncementsResponse _ = P.error "not a struct"
read_GetSquareChatAnnouncementsResponse :: T.Protocol p => p -> P.IO GetSquareChatAnnouncementsResponse
read_GetSquareChatAnnouncementsResponse iprot = to_GetSquareChatAnnouncementsResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncementsResponse)
decode_GetSquareChatAnnouncementsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatAnnouncementsResponse
decode_GetSquareChatAnnouncementsResponse iprot bs = to_GetSquareChatAnnouncementsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncementsResponse) bs
typemap_GetSquareChatAnnouncementsResponse :: T.TypeMap
typemap_GetSquareChatAnnouncementsResponse = Map.fromList [(1,("announcements",(T.T_LIST (T.T_STRUCT typemap_SquareChatAnnouncement))))]
default_GetSquareChatAnnouncementsResponse :: GetSquareChatAnnouncementsResponse
default_GetSquareChatAnnouncementsResponse = GetSquareChatAnnouncementsResponse{
  getSquareChatAnnouncementsResponse_announcements = Vector.empty}
data GetJoinedSquareChatsRequest = GetJoinedSquareChatsRequest  { getJoinedSquareChatsRequest_continuationToken :: LT.Text
  , getJoinedSquareChatsRequest_limit :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquareChatsRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquareChatsRequest_continuationToken record   `H.hashWithSalt` getJoinedSquareChatsRequest_limit record  
instance QC.Arbitrary GetJoinedSquareChatsRequest where 
  arbitrary = M.liftM GetJoinedSquareChatsRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquareChatsRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquareChatsRequest{getJoinedSquareChatsRequest_continuationToken = getJoinedSquareChatsRequest_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsRequest{getJoinedSquareChatsRequest_continuationToken = getJoinedSquareChatsRequest_continuationToken obj}
    , if obj == default_GetJoinedSquareChatsRequest{getJoinedSquareChatsRequest_limit = getJoinedSquareChatsRequest_limit obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsRequest{getJoinedSquareChatsRequest_limit = getJoinedSquareChatsRequest_limit obj}
    ]
from_GetJoinedSquareChatsRequest :: GetJoinedSquareChatsRequest -> T.ThriftVal
from_GetJoinedSquareChatsRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3278 -> P.Just (2, ("continuationToken",T.TString $ E.encodeUtf8 _v3278))) $ getJoinedSquareChatsRequest_continuationToken record
  , (\_v3278 -> P.Just (3, ("limit",T.TI32 _v3278))) $ getJoinedSquareChatsRequest_limit record
  ]
write_GetJoinedSquareChatsRequest :: T.Protocol p => p -> GetJoinedSquareChatsRequest -> P.IO ()
write_GetJoinedSquareChatsRequest oprot record = T.writeVal oprot $ from_GetJoinedSquareChatsRequest record
encode_GetJoinedSquareChatsRequest :: T.StatelessProtocol p => p -> GetJoinedSquareChatsRequest -> LBS.ByteString
encode_GetJoinedSquareChatsRequest oprot record = T.serializeVal oprot $ from_GetJoinedSquareChatsRequest record
to_GetJoinedSquareChatsRequest :: T.ThriftVal -> GetJoinedSquareChatsRequest
to_GetJoinedSquareChatsRequest (T.TStruct fields) = GetJoinedSquareChatsRequest{
  getJoinedSquareChatsRequest_continuationToken = P.maybe (getJoinedSquareChatsRequest_continuationToken default_GetJoinedSquareChatsRequest) (\(_,_val3280) -> (case _val3280 of {T.TString _val3281 -> E.decodeUtf8 _val3281; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getJoinedSquareChatsRequest_limit = P.maybe (getJoinedSquareChatsRequest_limit default_GetJoinedSquareChatsRequest) (\(_,_val3280) -> (case _val3280 of {T.TI32 _val3282 -> _val3282; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetJoinedSquareChatsRequest _ = P.error "not a struct"
read_GetJoinedSquareChatsRequest :: T.Protocol p => p -> P.IO GetJoinedSquareChatsRequest
read_GetJoinedSquareChatsRequest iprot = to_GetJoinedSquareChatsRequest <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquareChatsRequest)
decode_GetJoinedSquareChatsRequest :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquareChatsRequest
decode_GetJoinedSquareChatsRequest iprot bs = to_GetJoinedSquareChatsRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquareChatsRequest) bs
typemap_GetJoinedSquareChatsRequest :: T.TypeMap
typemap_GetJoinedSquareChatsRequest = Map.fromList [(2,("continuationToken",T.T_STRING)),(3,("limit",T.T_I32))]
default_GetJoinedSquareChatsRequest :: GetJoinedSquareChatsRequest
default_GetJoinedSquareChatsRequest = GetJoinedSquareChatsRequest{
  getJoinedSquareChatsRequest_continuationToken = "",
  getJoinedSquareChatsRequest_limit = 0}
data GetJoinedSquareChatsResponse = GetJoinedSquareChatsResponse  { getJoinedSquareChatsResponse_chats :: (Vector.Vector SquareChat)
  , getJoinedSquareChatsResponse_chatMembers :: (Map.HashMap LT.Text SquareChatMember)
  , getJoinedSquareChatsResponse_statuses :: (Map.HashMap LT.Text SquareChatStatus)
  , getJoinedSquareChatsResponse_continuationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquareChatsResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquareChatsResponse_chats record   `H.hashWithSalt` getJoinedSquareChatsResponse_chatMembers record   `H.hashWithSalt` getJoinedSquareChatsResponse_statuses record   `H.hashWithSalt` getJoinedSquareChatsResponse_continuationToken record  
instance QC.Arbitrary GetJoinedSquareChatsResponse where 
  arbitrary = M.liftM GetJoinedSquareChatsResponse (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquareChatsResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_chats = getJoinedSquareChatsResponse_chats obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_chats = getJoinedSquareChatsResponse_chats obj}
    , if obj == default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_chatMembers = getJoinedSquareChatsResponse_chatMembers obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_chatMembers = getJoinedSquareChatsResponse_chatMembers obj}
    , if obj == default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_statuses = getJoinedSquareChatsResponse_statuses obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_statuses = getJoinedSquareChatsResponse_statuses obj}
    , if obj == default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_continuationToken = getJoinedSquareChatsResponse_continuationToken obj} then P.Nothing else P.Just $ default_GetJoinedSquareChatsResponse{getJoinedSquareChatsResponse_continuationToken = getJoinedSquareChatsResponse_continuationToken obj}
    ]
from_GetJoinedSquareChatsResponse :: GetJoinedSquareChatsResponse -> T.ThriftVal
from_GetJoinedSquareChatsResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3285 -> P.Just (1, ("chats",T.TList (T.T_STRUCT typemap_SquareChat) $ P.map (\_v3287 -> from_SquareChat _v3287) $ Vector.toList _v3285))) $ getJoinedSquareChatsResponse_chats record
  , (\_v3285 -> P.Just (2, ("chatMembers",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareChatMember) $ P.map (\(_k3288,_v3289) -> (T.TString $ E.encodeUtf8 _k3288, from_SquareChatMember _v3289)) $ Map.toList _v3285))) $ getJoinedSquareChatsResponse_chatMembers record
  , (\_v3285 -> P.Just (3, ("statuses",T.TMap T.T_STRING (T.T_STRUCT typemap_SquareChatStatus) $ P.map (\(_k3290,_v3291) -> (T.TString $ E.encodeUtf8 _k3290, from_SquareChatStatus _v3291)) $ Map.toList _v3285))) $ getJoinedSquareChatsResponse_statuses record
  , (\_v3285 -> P.Just (4, ("continuationToken",T.TString $ E.encodeUtf8 _v3285))) $ getJoinedSquareChatsResponse_continuationToken record
  ]
write_GetJoinedSquareChatsResponse :: T.Protocol p => p -> GetJoinedSquareChatsResponse -> P.IO ()
write_GetJoinedSquareChatsResponse oprot record = T.writeVal oprot $ from_GetJoinedSquareChatsResponse record
encode_GetJoinedSquareChatsResponse :: T.StatelessProtocol p => p -> GetJoinedSquareChatsResponse -> LBS.ByteString
encode_GetJoinedSquareChatsResponse oprot record = T.serializeVal oprot $ from_GetJoinedSquareChatsResponse record
to_GetJoinedSquareChatsResponse :: T.ThriftVal -> GetJoinedSquareChatsResponse
to_GetJoinedSquareChatsResponse (T.TStruct fields) = GetJoinedSquareChatsResponse{
  getJoinedSquareChatsResponse_chats = P.maybe (getJoinedSquareChatsResponse_chats default_GetJoinedSquareChatsResponse) (\(_,_val3293) -> (case _val3293 of {T.TList _ _val3294 -> (Vector.fromList $ P.map (\_v3295 -> (case _v3295 of {T.TStruct _val3296 -> (to_SquareChat (T.TStruct _val3296)); _ -> P.error "wrong type"})) _val3294); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getJoinedSquareChatsResponse_chatMembers = P.maybe (getJoinedSquareChatsResponse_chatMembers default_GetJoinedSquareChatsResponse) (\(_,_val3293) -> (case _val3293 of {T.TMap _ _ _val3297 -> (Map.fromList $ P.map (\(_k3299,_v3298) -> ((case _k3299 of {T.TString _val3300 -> E.decodeUtf8 _val3300; _ -> P.error "wrong type"}),(case _v3298 of {T.TStruct _val3301 -> (to_SquareChatMember (T.TStruct _val3301)); _ -> P.error "wrong type"}))) _val3297); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getJoinedSquareChatsResponse_statuses = P.maybe (getJoinedSquareChatsResponse_statuses default_GetJoinedSquareChatsResponse) (\(_,_val3293) -> (case _val3293 of {T.TMap _ _ _val3302 -> (Map.fromList $ P.map (\(_k3304,_v3303) -> ((case _k3304 of {T.TString _val3305 -> E.decodeUtf8 _val3305; _ -> P.error "wrong type"}),(case _v3303 of {T.TStruct _val3306 -> (to_SquareChatStatus (T.TStruct _val3306)); _ -> P.error "wrong type"}))) _val3302); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getJoinedSquareChatsResponse_continuationToken = P.maybe (getJoinedSquareChatsResponse_continuationToken default_GetJoinedSquareChatsResponse) (\(_,_val3293) -> (case _val3293 of {T.TString _val3307 -> E.decodeUtf8 _val3307; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetJoinedSquareChatsResponse _ = P.error "not a struct"
read_GetJoinedSquareChatsResponse :: T.Protocol p => p -> P.IO GetJoinedSquareChatsResponse
read_GetJoinedSquareChatsResponse iprot = to_GetJoinedSquareChatsResponse <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquareChatsResponse)
decode_GetJoinedSquareChatsResponse :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquareChatsResponse
decode_GetJoinedSquareChatsResponse iprot bs = to_GetJoinedSquareChatsResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquareChatsResponse) bs
typemap_GetJoinedSquareChatsResponse :: T.TypeMap
typemap_GetJoinedSquareChatsResponse = Map.fromList [(1,("chats",(T.T_LIST (T.T_STRUCT typemap_SquareChat)))),(2,("chatMembers",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareChatMember)))),(3,("statuses",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_SquareChatStatus)))),(4,("continuationToken",T.T_STRING))]
default_GetJoinedSquareChatsResponse :: GetJoinedSquareChatsResponse
default_GetJoinedSquareChatsResponse = GetJoinedSquareChatsResponse{
  getJoinedSquareChatsResponse_chats = Vector.empty,
  getJoinedSquareChatsResponse_chatMembers = Map.empty,
  getJoinedSquareChatsResponse_statuses = Map.empty,
  getJoinedSquareChatsResponse_continuationToken = ""}
data TalkException = TalkException  { talkException_code :: ErrorCode
  , talkException_reason :: LT.Text
  , talkException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception TalkException
instance H.Hashable TalkException where
  hashWithSalt salt record = salt   `H.hashWithSalt` talkException_code record   `H.hashWithSalt` talkException_reason record   `H.hashWithSalt` talkException_parameterMap record  
instance QC.Arbitrary TalkException where 
  arbitrary = M.liftM TalkException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TalkException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TalkException{talkException_code = talkException_code obj} then P.Nothing else P.Just $ default_TalkException{talkException_code = talkException_code obj}
    , if obj == default_TalkException{talkException_reason = talkException_reason obj} then P.Nothing else P.Just $ default_TalkException{talkException_reason = talkException_reason obj}
    , if obj == default_TalkException{talkException_parameterMap = talkException_parameterMap obj} then P.Nothing else P.Just $ default_TalkException{talkException_parameterMap = talkException_parameterMap obj}
    ]
from_TalkException :: TalkException -> T.ThriftVal
from_TalkException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3310 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v3310))) $ talkException_code record
  , (\_v3310 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v3310))) $ talkException_reason record
  , (\_v3310 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3311,_v3312) -> (T.TString $ E.encodeUtf8 _k3311, T.TString $ E.encodeUtf8 _v3312)) $ Map.toList _v3310))) $ talkException_parameterMap record
  ]
write_TalkException :: T.Protocol p => p -> TalkException -> P.IO ()
write_TalkException oprot record = T.writeVal oprot $ from_TalkException record
encode_TalkException :: T.StatelessProtocol p => p -> TalkException -> LBS.ByteString
encode_TalkException oprot record = T.serializeVal oprot $ from_TalkException record
to_TalkException :: T.ThriftVal -> TalkException
to_TalkException (T.TStruct fields) = TalkException{
  talkException_code = P.maybe (talkException_code default_TalkException) (\(_,_val3314) -> (case _val3314 of {T.TI32 _val3315 -> P.toEnum $ P.fromIntegral _val3315; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  talkException_reason = P.maybe (talkException_reason default_TalkException) (\(_,_val3314) -> (case _val3314 of {T.TString _val3316 -> E.decodeUtf8 _val3316; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  talkException_parameterMap = P.maybe (talkException_parameterMap default_TalkException) (\(_,_val3314) -> (case _val3314 of {T.TMap _ _ _val3317 -> (Map.fromList $ P.map (\(_k3319,_v3318) -> ((case _k3319 of {T.TString _val3320 -> E.decodeUtf8 _val3320; _ -> P.error "wrong type"}),(case _v3318 of {T.TString _val3321 -> E.decodeUtf8 _val3321; _ -> P.error "wrong type"}))) _val3317); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TalkException _ = P.error "not a struct"
read_TalkException :: T.Protocol p => p -> P.IO TalkException
read_TalkException iprot = to_TalkException <$> T.readVal iprot (T.T_STRUCT typemap_TalkException)
decode_TalkException :: T.StatelessProtocol p => p -> LBS.ByteString -> TalkException
decode_TalkException iprot bs = to_TalkException $ T.deserializeVal iprot (T.T_STRUCT typemap_TalkException) bs
typemap_TalkException :: T.TypeMap
typemap_TalkException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_TalkException :: TalkException
default_TalkException = TalkException{
  talkException_code = (P.toEnum 0),
  talkException_reason = "",
  talkException_parameterMap = Map.empty}
data ShouldSyncException = ShouldSyncException  { shouldSyncException_syncOpRevision :: I.Int64
  , shouldSyncException_syncScope :: SyncScope
  , shouldSyncException_syncReason :: SyncTriggerReason
  , shouldSyncException_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception ShouldSyncException
instance H.Hashable ShouldSyncException where
  hashWithSalt salt record = salt   `H.hashWithSalt` shouldSyncException_syncOpRevision record   `H.hashWithSalt` shouldSyncException_syncScope record   `H.hashWithSalt` shouldSyncException_syncReason record   `H.hashWithSalt` shouldSyncException_message record  
instance QC.Arbitrary ShouldSyncException where 
  arbitrary = M.liftM ShouldSyncException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ShouldSyncException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShouldSyncException{shouldSyncException_syncOpRevision = shouldSyncException_syncOpRevision obj} then P.Nothing else P.Just $ default_ShouldSyncException{shouldSyncException_syncOpRevision = shouldSyncException_syncOpRevision obj}
    , if obj == default_ShouldSyncException{shouldSyncException_syncScope = shouldSyncException_syncScope obj} then P.Nothing else P.Just $ default_ShouldSyncException{shouldSyncException_syncScope = shouldSyncException_syncScope obj}
    , if obj == default_ShouldSyncException{shouldSyncException_syncReason = shouldSyncException_syncReason obj} then P.Nothing else P.Just $ default_ShouldSyncException{shouldSyncException_syncReason = shouldSyncException_syncReason obj}
    , if obj == default_ShouldSyncException{shouldSyncException_message = shouldSyncException_message obj} then P.Nothing else P.Just $ default_ShouldSyncException{shouldSyncException_message = shouldSyncException_message obj}
    ]
from_ShouldSyncException :: ShouldSyncException -> T.ThriftVal
from_ShouldSyncException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3324 -> P.Just (1, ("syncOpRevision",T.TI64 _v3324))) $ shouldSyncException_syncOpRevision record
  , (\_v3324 -> P.Just (2, ("syncScope",from_SyncScope _v3324))) $ shouldSyncException_syncScope record
  , (\_v3324 -> P.Just (3, ("syncReason",T.TI32 $ P.fromIntegral $ P.fromEnum _v3324))) $ shouldSyncException_syncReason record
  , (\_v3324 -> P.Just (4, ("message",T.TString $ E.encodeUtf8 _v3324))) $ shouldSyncException_message record
  ]
write_ShouldSyncException :: T.Protocol p => p -> ShouldSyncException -> P.IO ()
write_ShouldSyncException oprot record = T.writeVal oprot $ from_ShouldSyncException record
encode_ShouldSyncException :: T.StatelessProtocol p => p -> ShouldSyncException -> LBS.ByteString
encode_ShouldSyncException oprot record = T.serializeVal oprot $ from_ShouldSyncException record
to_ShouldSyncException :: T.ThriftVal -> ShouldSyncException
to_ShouldSyncException (T.TStruct fields) = ShouldSyncException{
  shouldSyncException_syncOpRevision = P.maybe (shouldSyncException_syncOpRevision default_ShouldSyncException) (\(_,_val3326) -> (case _val3326 of {T.TI64 _val3327 -> _val3327; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shouldSyncException_syncScope = P.maybe (shouldSyncException_syncScope default_ShouldSyncException) (\(_,_val3326) -> (case _val3326 of {T.TStruct _val3328 -> (to_SyncScope (T.TStruct _val3328)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shouldSyncException_syncReason = P.maybe (shouldSyncException_syncReason default_ShouldSyncException) (\(_,_val3326) -> (case _val3326 of {T.TI32 _val3329 -> P.toEnum $ P.fromIntegral _val3329; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  shouldSyncException_message = P.maybe (shouldSyncException_message default_ShouldSyncException) (\(_,_val3326) -> (case _val3326 of {T.TString _val3330 -> E.decodeUtf8 _val3330; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ShouldSyncException _ = P.error "not a struct"
read_ShouldSyncException :: T.Protocol p => p -> P.IO ShouldSyncException
read_ShouldSyncException iprot = to_ShouldSyncException <$> T.readVal iprot (T.T_STRUCT typemap_ShouldSyncException)
decode_ShouldSyncException :: T.StatelessProtocol p => p -> LBS.ByteString -> ShouldSyncException
decode_ShouldSyncException iprot bs = to_ShouldSyncException $ T.deserializeVal iprot (T.T_STRUCT typemap_ShouldSyncException) bs
typemap_ShouldSyncException :: T.TypeMap
typemap_ShouldSyncException = Map.fromList [(1,("syncOpRevision",T.T_I64)),(2,("syncScope",(T.T_STRUCT typemap_SyncScope))),(3,("syncReason",T.T_I32)),(4,("message",T.T_STRING))]
default_ShouldSyncException :: ShouldSyncException
default_ShouldSyncException = ShouldSyncException{
  shouldSyncException_syncOpRevision = 0,
  shouldSyncException_syncScope = default_SyncScope,
  shouldSyncException_syncReason = (P.toEnum 0),
  shouldSyncException_message = ""}
data PointException = PointException  { pointException_code :: PointErrorCode
  , pointException_reason :: LT.Text
  , pointException_extra :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception PointException
instance H.Hashable PointException where
  hashWithSalt salt record = salt   `H.hashWithSalt` pointException_code record   `H.hashWithSalt` pointException_reason record   `H.hashWithSalt` pointException_extra record  
instance QC.Arbitrary PointException where 
  arbitrary = M.liftM PointException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_PointException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PointException{pointException_code = pointException_code obj} then P.Nothing else P.Just $ default_PointException{pointException_code = pointException_code obj}
    , if obj == default_PointException{pointException_reason = pointException_reason obj} then P.Nothing else P.Just $ default_PointException{pointException_reason = pointException_reason obj}
    , if obj == default_PointException{pointException_extra = pointException_extra obj} then P.Nothing else P.Just $ default_PointException{pointException_extra = pointException_extra obj}
    ]
from_PointException :: PointException -> T.ThriftVal
from_PointException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3333 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v3333))) $ pointException_code record
  , (\_v3333 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v3333))) $ pointException_reason record
  , (\_v3333 -> P.Just (3, ("extra",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3334,_v3335) -> (T.TString $ E.encodeUtf8 _k3334, T.TString $ E.encodeUtf8 _v3335)) $ Map.toList _v3333))) $ pointException_extra record
  ]
write_PointException :: T.Protocol p => p -> PointException -> P.IO ()
write_PointException oprot record = T.writeVal oprot $ from_PointException record
encode_PointException :: T.StatelessProtocol p => p -> PointException -> LBS.ByteString
encode_PointException oprot record = T.serializeVal oprot $ from_PointException record
to_PointException :: T.ThriftVal -> PointException
to_PointException (T.TStruct fields) = PointException{
  pointException_code = P.maybe (pointException_code default_PointException) (\(_,_val3337) -> (case _val3337 of {T.TI32 _val3338 -> P.toEnum $ P.fromIntegral _val3338; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  pointException_reason = P.maybe (pointException_reason default_PointException) (\(_,_val3337) -> (case _val3337 of {T.TString _val3339 -> E.decodeUtf8 _val3339; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  pointException_extra = P.maybe (pointException_extra default_PointException) (\(_,_val3337) -> (case _val3337 of {T.TMap _ _ _val3340 -> (Map.fromList $ P.map (\(_k3342,_v3341) -> ((case _k3342 of {T.TString _val3343 -> E.decodeUtf8 _val3343; _ -> P.error "wrong type"}),(case _v3341 of {T.TString _val3344 -> E.decodeUtf8 _val3344; _ -> P.error "wrong type"}))) _val3340); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_PointException _ = P.error "not a struct"
read_PointException :: T.Protocol p => p -> P.IO PointException
read_PointException iprot = to_PointException <$> T.readVal iprot (T.T_STRUCT typemap_PointException)
decode_PointException :: T.StatelessProtocol p => p -> LBS.ByteString -> PointException
decode_PointException iprot bs = to_PointException $ T.deserializeVal iprot (T.T_STRUCT typemap_PointException) bs
typemap_PointException :: T.TypeMap
typemap_PointException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("extra",(T.T_MAP T.T_STRING T.T_STRING)))]
default_PointException :: PointException
default_PointException = PointException{
  pointException_code = (P.toEnum 0),
  pointException_reason = "",
  pointException_extra = Map.empty}
data ChannelException = ChannelException  { channelException_code :: ChannelErrorCode
  , channelException_reason :: LT.Text
  , channelException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception ChannelException
instance H.Hashable ChannelException where
  hashWithSalt salt record = salt   `H.hashWithSalt` channelException_code record   `H.hashWithSalt` channelException_reason record   `H.hashWithSalt` channelException_parameterMap record  
instance QC.Arbitrary ChannelException where 
  arbitrary = M.liftM ChannelException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChannelException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChannelException{channelException_code = channelException_code obj} then P.Nothing else P.Just $ default_ChannelException{channelException_code = channelException_code obj}
    , if obj == default_ChannelException{channelException_reason = channelException_reason obj} then P.Nothing else P.Just $ default_ChannelException{channelException_reason = channelException_reason obj}
    , if obj == default_ChannelException{channelException_parameterMap = channelException_parameterMap obj} then P.Nothing else P.Just $ default_ChannelException{channelException_parameterMap = channelException_parameterMap obj}
    ]
from_ChannelException :: ChannelException -> T.ThriftVal
from_ChannelException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3347 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v3347))) $ channelException_code record
  , (\_v3347 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v3347))) $ channelException_reason record
  , (\_v3347 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3348,_v3349) -> (T.TString $ E.encodeUtf8 _k3348, T.TString $ E.encodeUtf8 _v3349)) $ Map.toList _v3347))) $ channelException_parameterMap record
  ]
write_ChannelException :: T.Protocol p => p -> ChannelException -> P.IO ()
write_ChannelException oprot record = T.writeVal oprot $ from_ChannelException record
encode_ChannelException :: T.StatelessProtocol p => p -> ChannelException -> LBS.ByteString
encode_ChannelException oprot record = T.serializeVal oprot $ from_ChannelException record
to_ChannelException :: T.ThriftVal -> ChannelException
to_ChannelException (T.TStruct fields) = ChannelException{
  channelException_code = P.maybe (channelException_code default_ChannelException) (\(_,_val3351) -> (case _val3351 of {T.TI32 _val3352 -> P.toEnum $ P.fromIntegral _val3352; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  channelException_reason = P.maybe (channelException_reason default_ChannelException) (\(_,_val3351) -> (case _val3351 of {T.TString _val3353 -> E.decodeUtf8 _val3353; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  channelException_parameterMap = P.maybe (channelException_parameterMap default_ChannelException) (\(_,_val3351) -> (case _val3351 of {T.TMap _ _ _val3354 -> (Map.fromList $ P.map (\(_k3356,_v3355) -> ((case _k3356 of {T.TString _val3357 -> E.decodeUtf8 _val3357; _ -> P.error "wrong type"}),(case _v3355 of {T.TString _val3358 -> E.decodeUtf8 _val3358; _ -> P.error "wrong type"}))) _val3354); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ChannelException _ = P.error "not a struct"
read_ChannelException :: T.Protocol p => p -> P.IO ChannelException
read_ChannelException iprot = to_ChannelException <$> T.readVal iprot (T.T_STRUCT typemap_ChannelException)
decode_ChannelException :: T.StatelessProtocol p => p -> LBS.ByteString -> ChannelException
decode_ChannelException iprot bs = to_ChannelException $ T.deserializeVal iprot (T.T_STRUCT typemap_ChannelException) bs
typemap_ChannelException :: T.TypeMap
typemap_ChannelException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_ChannelException :: ChannelException
default_ChannelException = ChannelException{
  channelException_code = (P.toEnum 0),
  channelException_reason = "",
  channelException_parameterMap = Map.empty}
data SquareException = SquareException  { squareException_errorCode :: SQErrorCode
  , squareException_errorExtraInfo :: ErrorExtraInfo
  , squareException_reason :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception SquareException
instance H.Hashable SquareException where
  hashWithSalt salt record = salt   `H.hashWithSalt` squareException_errorCode record   `H.hashWithSalt` squareException_errorExtraInfo record   `H.hashWithSalt` squareException_reason record  
instance QC.Arbitrary SquareException where 
  arbitrary = M.liftM SquareException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SquareException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SquareException{squareException_errorCode = squareException_errorCode obj} then P.Nothing else P.Just $ default_SquareException{squareException_errorCode = squareException_errorCode obj}
    , if obj == default_SquareException{squareException_errorExtraInfo = squareException_errorExtraInfo obj} then P.Nothing else P.Just $ default_SquareException{squareException_errorExtraInfo = squareException_errorExtraInfo obj}
    , if obj == default_SquareException{squareException_reason = squareException_reason obj} then P.Nothing else P.Just $ default_SquareException{squareException_reason = squareException_reason obj}
    ]
from_SquareException :: SquareException -> T.ThriftVal
from_SquareException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3361 -> P.Just (1, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v3361))) $ squareException_errorCode record
  , (\_v3361 -> P.Just (2, ("errorExtraInfo",from_ErrorExtraInfo _v3361))) $ squareException_errorExtraInfo record
  , (\_v3361 -> P.Just (3, ("reason",T.TString $ E.encodeUtf8 _v3361))) $ squareException_reason record
  ]
write_SquareException :: T.Protocol p => p -> SquareException -> P.IO ()
write_SquareException oprot record = T.writeVal oprot $ from_SquareException record
encode_SquareException :: T.StatelessProtocol p => p -> SquareException -> LBS.ByteString
encode_SquareException oprot record = T.serializeVal oprot $ from_SquareException record
to_SquareException :: T.ThriftVal -> SquareException
to_SquareException (T.TStruct fields) = SquareException{
  squareException_errorCode = P.maybe (squareException_errorCode default_SquareException) (\(_,_val3363) -> (case _val3363 of {T.TI32 _val3364 -> P.toEnum $ P.fromIntegral _val3364; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  squareException_errorExtraInfo = P.maybe (squareException_errorExtraInfo default_SquareException) (\(_,_val3363) -> (case _val3363 of {T.TStruct _val3365 -> (to_ErrorExtraInfo (T.TStruct _val3365)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  squareException_reason = P.maybe (squareException_reason default_SquareException) (\(_,_val3363) -> (case _val3363 of {T.TString _val3366 -> E.decodeUtf8 _val3366; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SquareException _ = P.error "not a struct"
read_SquareException :: T.Protocol p => p -> P.IO SquareException
read_SquareException iprot = to_SquareException <$> T.readVal iprot (T.T_STRUCT typemap_SquareException)
decode_SquareException :: T.StatelessProtocol p => p -> LBS.ByteString -> SquareException
decode_SquareException iprot bs = to_SquareException $ T.deserializeVal iprot (T.T_STRUCT typemap_SquareException) bs
typemap_SquareException :: T.TypeMap
typemap_SquareException = Map.fromList [(1,("errorCode",T.T_I32)),(2,("errorExtraInfo",(T.T_STRUCT typemap_ErrorExtraInfo))),(3,("reason",T.T_STRING))]
default_SquareException :: SquareException
default_SquareException = SquareException{
  squareException_errorCode = (P.toEnum 0),
  squareException_errorExtraInfo = default_ErrorExtraInfo,
  squareException_reason = ""}
data UniversalNotificationServiceException = UniversalNotificationServiceException  { universalNotificationServiceException_code :: UniversalNotificationServiceErrorCode
  , universalNotificationServiceException_reason :: LT.Text
  , universalNotificationServiceException_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance X.Exception UniversalNotificationServiceException
instance H.Hashable UniversalNotificationServiceException where
  hashWithSalt salt record = salt   `H.hashWithSalt` universalNotificationServiceException_code record   `H.hashWithSalt` universalNotificationServiceException_reason record   `H.hashWithSalt` universalNotificationServiceException_parameterMap record  
instance QC.Arbitrary UniversalNotificationServiceException where 
  arbitrary = M.liftM UniversalNotificationServiceException (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UniversalNotificationServiceException = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_code = universalNotificationServiceException_code obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_code = universalNotificationServiceException_code obj}
    , if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_reason = universalNotificationServiceException_reason obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_reason = universalNotificationServiceException_reason obj}
    , if obj == default_UniversalNotificationServiceException{universalNotificationServiceException_parameterMap = universalNotificationServiceException_parameterMap obj} then P.Nothing else P.Just $ default_UniversalNotificationServiceException{universalNotificationServiceException_parameterMap = universalNotificationServiceException_parameterMap obj}
    ]
from_UniversalNotificationServiceException :: UniversalNotificationServiceException -> T.ThriftVal
from_UniversalNotificationServiceException record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3369 -> P.Just (1, ("code",T.TI32 $ P.fromIntegral $ P.fromEnum _v3369))) $ universalNotificationServiceException_code record
  , (\_v3369 -> P.Just (2, ("reason",T.TString $ E.encodeUtf8 _v3369))) $ universalNotificationServiceException_reason record
  , (\_v3369 -> P.Just (3, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3370,_v3371) -> (T.TString $ E.encodeUtf8 _k3370, T.TString $ E.encodeUtf8 _v3371)) $ Map.toList _v3369))) $ universalNotificationServiceException_parameterMap record
  ]
write_UniversalNotificationServiceException :: T.Protocol p => p -> UniversalNotificationServiceException -> P.IO ()
write_UniversalNotificationServiceException oprot record = T.writeVal oprot $ from_UniversalNotificationServiceException record
encode_UniversalNotificationServiceException :: T.StatelessProtocol p => p -> UniversalNotificationServiceException -> LBS.ByteString
encode_UniversalNotificationServiceException oprot record = T.serializeVal oprot $ from_UniversalNotificationServiceException record
to_UniversalNotificationServiceException :: T.ThriftVal -> UniversalNotificationServiceException
to_UniversalNotificationServiceException (T.TStruct fields) = UniversalNotificationServiceException{
  universalNotificationServiceException_code = P.maybe (universalNotificationServiceException_code default_UniversalNotificationServiceException) (\(_,_val3373) -> (case _val3373 of {T.TI32 _val3374 -> P.toEnum $ P.fromIntegral _val3374; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  universalNotificationServiceException_reason = P.maybe (universalNotificationServiceException_reason default_UniversalNotificationServiceException) (\(_,_val3373) -> (case _val3373 of {T.TString _val3375 -> E.decodeUtf8 _val3375; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  universalNotificationServiceException_parameterMap = P.maybe (universalNotificationServiceException_parameterMap default_UniversalNotificationServiceException) (\(_,_val3373) -> (case _val3373 of {T.TMap _ _ _val3376 -> (Map.fromList $ P.map (\(_k3378,_v3377) -> ((case _k3378 of {T.TString _val3379 -> E.decodeUtf8 _val3379; _ -> P.error "wrong type"}),(case _v3377 of {T.TString _val3380 -> E.decodeUtf8 _val3380; _ -> P.error "wrong type"}))) _val3376); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UniversalNotificationServiceException _ = P.error "not a struct"
read_UniversalNotificationServiceException :: T.Protocol p => p -> P.IO UniversalNotificationServiceException
read_UniversalNotificationServiceException iprot = to_UniversalNotificationServiceException <$> T.readVal iprot (T.T_STRUCT typemap_UniversalNotificationServiceException)
decode_UniversalNotificationServiceException :: T.StatelessProtocol p => p -> LBS.ByteString -> UniversalNotificationServiceException
decode_UniversalNotificationServiceException iprot bs = to_UniversalNotificationServiceException $ T.deserializeVal iprot (T.T_STRUCT typemap_UniversalNotificationServiceException) bs
typemap_UniversalNotificationServiceException :: T.TypeMap
typemap_UniversalNotificationServiceException = Map.fromList [(1,("code",T.T_I32)),(2,("reason",T.T_STRING)),(3,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_UniversalNotificationServiceException :: UniversalNotificationServiceException
default_UniversalNotificationServiceException = UniversalNotificationServiceException{
  universalNotificationServiceException_code = (P.toEnum 0),
  universalNotificationServiceException_reason = "",
  universalNotificationServiceException_parameterMap = Map.empty}
data UpdateBuddyProfileResult = UpdateBuddyProfileResult  { updateBuddyProfileResult_requestId :: LT.Text
  , updateBuddyProfileResult_state :: BuddyResultState
  , updateBuddyProfileResult_eventNo :: I.Int32
  , updateBuddyProfileResult_receiverCount :: I.Int64
  , updateBuddyProfileResult_successCount :: I.Int64
  , updateBuddyProfileResult_failCount :: I.Int64
  , updateBuddyProfileResult_cancelCount :: I.Int64
  , updateBuddyProfileResult_unregisterCount :: I.Int64
  , updateBuddyProfileResult_timestamp :: I.Int64
  , updateBuddyProfileResult_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddyProfileResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddyProfileResult_requestId record   `H.hashWithSalt` updateBuddyProfileResult_state record   `H.hashWithSalt` updateBuddyProfileResult_eventNo record   `H.hashWithSalt` updateBuddyProfileResult_receiverCount record   `H.hashWithSalt` updateBuddyProfileResult_successCount record   `H.hashWithSalt` updateBuddyProfileResult_failCount record   `H.hashWithSalt` updateBuddyProfileResult_cancelCount record   `H.hashWithSalt` updateBuddyProfileResult_unregisterCount record   `H.hashWithSalt` updateBuddyProfileResult_timestamp record   `H.hashWithSalt` updateBuddyProfileResult_message record  
instance QC.Arbitrary UpdateBuddyProfileResult where 
  arbitrary = M.liftM UpdateBuddyProfileResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateBuddyProfileResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_requestId = updateBuddyProfileResult_requestId obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_requestId = updateBuddyProfileResult_requestId obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_state = updateBuddyProfileResult_state obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_state = updateBuddyProfileResult_state obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_eventNo = updateBuddyProfileResult_eventNo obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_eventNo = updateBuddyProfileResult_eventNo obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_receiverCount = updateBuddyProfileResult_receiverCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_receiverCount = updateBuddyProfileResult_receiverCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_successCount = updateBuddyProfileResult_successCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_successCount = updateBuddyProfileResult_successCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_failCount = updateBuddyProfileResult_failCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_failCount = updateBuddyProfileResult_failCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_cancelCount = updateBuddyProfileResult_cancelCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_cancelCount = updateBuddyProfileResult_cancelCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_unregisterCount = updateBuddyProfileResult_unregisterCount obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_unregisterCount = updateBuddyProfileResult_unregisterCount obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_timestamp = updateBuddyProfileResult_timestamp obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_timestamp = updateBuddyProfileResult_timestamp obj}
    , if obj == default_UpdateBuddyProfileResult{updateBuddyProfileResult_message = updateBuddyProfileResult_message obj} then P.Nothing else P.Just $ default_UpdateBuddyProfileResult{updateBuddyProfileResult_message = updateBuddyProfileResult_message obj}
    ]
from_UpdateBuddyProfileResult :: UpdateBuddyProfileResult -> T.ThriftVal
from_UpdateBuddyProfileResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3383 -> P.Just (1, ("requestId",T.TString $ E.encodeUtf8 _v3383))) $ updateBuddyProfileResult_requestId record
  , (\_v3383 -> P.Just (2, ("state",T.TI32 $ P.fromIntegral $ P.fromEnum _v3383))) $ updateBuddyProfileResult_state record
  , (\_v3383 -> P.Just (3, ("eventNo",T.TI32 _v3383))) $ updateBuddyProfileResult_eventNo record
  , (\_v3383 -> P.Just (11, ("receiverCount",T.TI64 _v3383))) $ updateBuddyProfileResult_receiverCount record
  , (\_v3383 -> P.Just (12, ("successCount",T.TI64 _v3383))) $ updateBuddyProfileResult_successCount record
  , (\_v3383 -> P.Just (13, ("failCount",T.TI64 _v3383))) $ updateBuddyProfileResult_failCount record
  , (\_v3383 -> P.Just (14, ("cancelCount",T.TI64 _v3383))) $ updateBuddyProfileResult_cancelCount record
  , (\_v3383 -> P.Just (15, ("unregisterCount",T.TI64 _v3383))) $ updateBuddyProfileResult_unregisterCount record
  , (\_v3383 -> P.Just (21, ("timestamp",T.TI64 _v3383))) $ updateBuddyProfileResult_timestamp record
  , (\_v3383 -> P.Just (22, ("message",T.TString $ E.encodeUtf8 _v3383))) $ updateBuddyProfileResult_message record
  ]
write_UpdateBuddyProfileResult :: T.Protocol p => p -> UpdateBuddyProfileResult -> P.IO ()
write_UpdateBuddyProfileResult oprot record = T.writeVal oprot $ from_UpdateBuddyProfileResult record
encode_UpdateBuddyProfileResult :: T.StatelessProtocol p => p -> UpdateBuddyProfileResult -> LBS.ByteString
encode_UpdateBuddyProfileResult oprot record = T.serializeVal oprot $ from_UpdateBuddyProfileResult record
to_UpdateBuddyProfileResult :: T.ThriftVal -> UpdateBuddyProfileResult
to_UpdateBuddyProfileResult (T.TStruct fields) = UpdateBuddyProfileResult{
  updateBuddyProfileResult_requestId = P.maybe (updateBuddyProfileResult_requestId default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TString _val3386 -> E.decodeUtf8 _val3386; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateBuddyProfileResult_state = P.maybe (updateBuddyProfileResult_state default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI32 _val3387 -> P.toEnum $ P.fromIntegral _val3387; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBuddyProfileResult_eventNo = P.maybe (updateBuddyProfileResult_eventNo default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI32 _val3388 -> _val3388; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateBuddyProfileResult_receiverCount = P.maybe (updateBuddyProfileResult_receiverCount default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3389 -> _val3389; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  updateBuddyProfileResult_successCount = P.maybe (updateBuddyProfileResult_successCount default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3390 -> _val3390; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  updateBuddyProfileResult_failCount = P.maybe (updateBuddyProfileResult_failCount default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3391 -> _val3391; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  updateBuddyProfileResult_cancelCount = P.maybe (updateBuddyProfileResult_cancelCount default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3392 -> _val3392; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  updateBuddyProfileResult_unregisterCount = P.maybe (updateBuddyProfileResult_unregisterCount default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3393 -> _val3393; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  updateBuddyProfileResult_timestamp = P.maybe (updateBuddyProfileResult_timestamp default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TI64 _val3394 -> _val3394; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  updateBuddyProfileResult_message = P.maybe (updateBuddyProfileResult_message default_UpdateBuddyProfileResult) (\(_,_val3385) -> (case _val3385 of {T.TString _val3395 -> E.decodeUtf8 _val3395; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_UpdateBuddyProfileResult _ = P.error "not a struct"
read_UpdateBuddyProfileResult :: T.Protocol p => p -> P.IO UpdateBuddyProfileResult
read_UpdateBuddyProfileResult iprot = to_UpdateBuddyProfileResult <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddyProfileResult)
decode_UpdateBuddyProfileResult :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddyProfileResult
decode_UpdateBuddyProfileResult iprot bs = to_UpdateBuddyProfileResult $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddyProfileResult) bs
typemap_UpdateBuddyProfileResult :: T.TypeMap
typemap_UpdateBuddyProfileResult = Map.fromList [(1,("requestId",T.T_STRING)),(2,("state",T.T_I32)),(3,("eventNo",T.T_I32)),(11,("receiverCount",T.T_I64)),(12,("successCount",T.T_I64)),(13,("failCount",T.T_I64)),(14,("cancelCount",T.T_I64)),(15,("unregisterCount",T.T_I64)),(21,("timestamp",T.T_I64)),(22,("message",T.T_STRING))]
default_UpdateBuddyProfileResult :: UpdateBuddyProfileResult
default_UpdateBuddyProfileResult = UpdateBuddyProfileResult{
  updateBuddyProfileResult_requestId = "",
  updateBuddyProfileResult_state = (P.toEnum 0),
  updateBuddyProfileResult_eventNo = 0,
  updateBuddyProfileResult_receiverCount = 0,
  updateBuddyProfileResult_successCount = 0,
  updateBuddyProfileResult_failCount = 0,
  updateBuddyProfileResult_cancelCount = 0,
  updateBuddyProfileResult_unregisterCount = 0,
  updateBuddyProfileResult_timestamp = 0,
  updateBuddyProfileResult_message = ""}
data UserAuthStatus = UserAuthStatus  { userAuthStatus_phoneNumberRegistered :: P.Bool
  , userAuthStatus_registeredSnsIdTypes :: (Vector.Vector SnsIdType)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserAuthStatus where
  hashWithSalt salt record = salt   `H.hashWithSalt` userAuthStatus_phoneNumberRegistered record   `H.hashWithSalt` userAuthStatus_registeredSnsIdTypes record  
instance QC.Arbitrary UserAuthStatus where 
  arbitrary = M.liftM UserAuthStatus (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UserAuthStatus = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserAuthStatus{userAuthStatus_phoneNumberRegistered = userAuthStatus_phoneNumberRegistered obj} then P.Nothing else P.Just $ default_UserAuthStatus{userAuthStatus_phoneNumberRegistered = userAuthStatus_phoneNumberRegistered obj}
    , if obj == default_UserAuthStatus{userAuthStatus_registeredSnsIdTypes = userAuthStatus_registeredSnsIdTypes obj} then P.Nothing else P.Just $ default_UserAuthStatus{userAuthStatus_registeredSnsIdTypes = userAuthStatus_registeredSnsIdTypes obj}
    ]
from_UserAuthStatus :: UserAuthStatus -> T.ThriftVal
from_UserAuthStatus record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3398 -> P.Just (1, ("phoneNumberRegistered",T.TBool _v3398))) $ userAuthStatus_phoneNumberRegistered record
  , (\_v3398 -> P.Just (2, ("registeredSnsIdTypes",T.TList T.T_I32 $ P.map (\_v3400 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v3400) $ Vector.toList _v3398))) $ userAuthStatus_registeredSnsIdTypes record
  ]
write_UserAuthStatus :: T.Protocol p => p -> UserAuthStatus -> P.IO ()
write_UserAuthStatus oprot record = T.writeVal oprot $ from_UserAuthStatus record
encode_UserAuthStatus :: T.StatelessProtocol p => p -> UserAuthStatus -> LBS.ByteString
encode_UserAuthStatus oprot record = T.serializeVal oprot $ from_UserAuthStatus record
to_UserAuthStatus :: T.ThriftVal -> UserAuthStatus
to_UserAuthStatus (T.TStruct fields) = UserAuthStatus{
  userAuthStatus_phoneNumberRegistered = P.maybe (userAuthStatus_phoneNumberRegistered default_UserAuthStatus) (\(_,_val3402) -> (case _val3402 of {T.TBool _val3403 -> _val3403; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userAuthStatus_registeredSnsIdTypes = P.maybe (userAuthStatus_registeredSnsIdTypes default_UserAuthStatus) (\(_,_val3402) -> (case _val3402 of {T.TList _ _val3404 -> (Vector.fromList $ P.map (\_v3405 -> (case _v3405 of {T.TI32 _val3406 -> P.toEnum $ P.fromIntegral _val3406; _ -> P.error "wrong type"})) _val3404); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UserAuthStatus _ = P.error "not a struct"
read_UserAuthStatus :: T.Protocol p => p -> P.IO UserAuthStatus
read_UserAuthStatus iprot = to_UserAuthStatus <$> T.readVal iprot (T.T_STRUCT typemap_UserAuthStatus)
decode_UserAuthStatus :: T.StatelessProtocol p => p -> LBS.ByteString -> UserAuthStatus
decode_UserAuthStatus iprot bs = to_UserAuthStatus $ T.deserializeVal iprot (T.T_STRUCT typemap_UserAuthStatus) bs
typemap_UserAuthStatus :: T.TypeMap
typemap_UserAuthStatus = Map.fromList [(1,("phoneNumberRegistered",T.T_BOOL)),(2,("registeredSnsIdTypes",(T.T_LIST T.T_I32)))]
default_UserAuthStatus :: UserAuthStatus
default_UserAuthStatus = UserAuthStatus{
  userAuthStatus_phoneNumberRegistered = P.False,
  userAuthStatus_registeredSnsIdTypes = Vector.empty}
data WapInvitation = WapInvitation  { wapInvitation_type :: WapInvitationType
  , wapInvitation_inviteeEmail :: LT.Text
  , wapInvitation_inviterMid :: LT.Text
  , wapInvitation_roomMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable WapInvitation where
  hashWithSalt salt record = salt   `H.hashWithSalt` wapInvitation_type record   `H.hashWithSalt` wapInvitation_inviteeEmail record   `H.hashWithSalt` wapInvitation_inviterMid record   `H.hashWithSalt` wapInvitation_roomMid record  
instance QC.Arbitrary WapInvitation where 
  arbitrary = M.liftM WapInvitation (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_WapInvitation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_WapInvitation{wapInvitation_type = wapInvitation_type obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_type = wapInvitation_type obj}
    , if obj == default_WapInvitation{wapInvitation_inviteeEmail = wapInvitation_inviteeEmail obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_inviteeEmail = wapInvitation_inviteeEmail obj}
    , if obj == default_WapInvitation{wapInvitation_inviterMid = wapInvitation_inviterMid obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_inviterMid = wapInvitation_inviterMid obj}
    , if obj == default_WapInvitation{wapInvitation_roomMid = wapInvitation_roomMid obj} then P.Nothing else P.Just $ default_WapInvitation{wapInvitation_roomMid = wapInvitation_roomMid obj}
    ]
from_WapInvitation :: WapInvitation -> T.ThriftVal
from_WapInvitation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3409 -> P.Just (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v3409))) $ wapInvitation_type record
  , (\_v3409 -> P.Just (10, ("inviteeEmail",T.TString $ E.encodeUtf8 _v3409))) $ wapInvitation_inviteeEmail record
  , (\_v3409 -> P.Just (11, ("inviterMid",T.TString $ E.encodeUtf8 _v3409))) $ wapInvitation_inviterMid record
  , (\_v3409 -> P.Just (12, ("roomMid",T.TString $ E.encodeUtf8 _v3409))) $ wapInvitation_roomMid record
  ]
write_WapInvitation :: T.Protocol p => p -> WapInvitation -> P.IO ()
write_WapInvitation oprot record = T.writeVal oprot $ from_WapInvitation record
encode_WapInvitation :: T.StatelessProtocol p => p -> WapInvitation -> LBS.ByteString
encode_WapInvitation oprot record = T.serializeVal oprot $ from_WapInvitation record
to_WapInvitation :: T.ThriftVal -> WapInvitation
to_WapInvitation (T.TStruct fields) = WapInvitation{
  wapInvitation_type = P.maybe (wapInvitation_type default_WapInvitation) (\(_,_val3411) -> (case _val3411 of {T.TI32 _val3412 -> P.toEnum $ P.fromIntegral _val3412; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  wapInvitation_inviteeEmail = P.maybe (wapInvitation_inviteeEmail default_WapInvitation) (\(_,_val3411) -> (case _val3411 of {T.TString _val3413 -> E.decodeUtf8 _val3413; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  wapInvitation_inviterMid = P.maybe (wapInvitation_inviterMid default_WapInvitation) (\(_,_val3411) -> (case _val3411 of {T.TString _val3414 -> E.decodeUtf8 _val3414; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  wapInvitation_roomMid = P.maybe (wapInvitation_roomMid default_WapInvitation) (\(_,_val3411) -> (case _val3411 of {T.TString _val3415 -> E.decodeUtf8 _val3415; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_WapInvitation _ = P.error "not a struct"
read_WapInvitation :: T.Protocol p => p -> P.IO WapInvitation
read_WapInvitation iprot = to_WapInvitation <$> T.readVal iprot (T.T_STRUCT typemap_WapInvitation)
decode_WapInvitation :: T.StatelessProtocol p => p -> LBS.ByteString -> WapInvitation
decode_WapInvitation iprot bs = to_WapInvitation $ T.deserializeVal iprot (T.T_STRUCT typemap_WapInvitation) bs
typemap_WapInvitation :: T.TypeMap
typemap_WapInvitation = Map.fromList [(1,("type",T.T_I32)),(10,("inviteeEmail",T.T_STRING)),(11,("inviterMid",T.T_STRING)),(12,("roomMid",T.T_STRING))]
default_WapInvitation :: WapInvitation
default_WapInvitation = WapInvitation{
  wapInvitation_type = (P.toEnum 0),
  wapInvitation_inviteeEmail = "",
  wapInvitation_inviterMid = "",
  wapInvitation_roomMid = ""}
data GroupCall = GroupCall  { groupCall_online :: P.Bool
  , groupCall_chatMid :: LT.Text
  , groupCall_hostMids :: LT.Text
  , groupCall_memberMids :: (Vector.Vector LT.Text)
  , groupCall_started :: I.Int64
  , groupCall_mediaType :: GroupCallMediaType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GroupCall where
  hashWithSalt salt record = salt   `H.hashWithSalt` groupCall_online record   `H.hashWithSalt` groupCall_chatMid record   `H.hashWithSalt` groupCall_hostMids record   `H.hashWithSalt` groupCall_memberMids record   `H.hashWithSalt` groupCall_started record   `H.hashWithSalt` groupCall_mediaType record  
instance QC.Arbitrary GroupCall where 
  arbitrary = M.liftM GroupCall (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GroupCall = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GroupCall{groupCall_online = groupCall_online obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_online = groupCall_online obj}
    , if obj == default_GroupCall{groupCall_chatMid = groupCall_chatMid obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_chatMid = groupCall_chatMid obj}
    , if obj == default_GroupCall{groupCall_hostMids = groupCall_hostMids obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_hostMids = groupCall_hostMids obj}
    , if obj == default_GroupCall{groupCall_memberMids = groupCall_memberMids obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_memberMids = groupCall_memberMids obj}
    , if obj == default_GroupCall{groupCall_started = groupCall_started obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_started = groupCall_started obj}
    , if obj == default_GroupCall{groupCall_mediaType = groupCall_mediaType obj} then P.Nothing else P.Just $ default_GroupCall{groupCall_mediaType = groupCall_mediaType obj}
    ]
from_GroupCall :: GroupCall -> T.ThriftVal
from_GroupCall record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3418 -> P.Just (1, ("online",T.TBool _v3418))) $ groupCall_online record
  , (\_v3418 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v3418))) $ groupCall_chatMid record
  , (\_v3418 -> P.Just (3, ("hostMids",T.TString $ E.encodeUtf8 _v3418))) $ groupCall_hostMids record
  , (\_v3418 -> P.Just (4, ("memberMids",T.TList T.T_STRING $ P.map (\_v3420 -> T.TString $ E.encodeUtf8 _v3420) $ Vector.toList _v3418))) $ groupCall_memberMids record
  , (\_v3418 -> P.Just (5, ("started",T.TI64 _v3418))) $ groupCall_started record
  , (\_v3418 -> P.Just (6, ("mediaType",T.TI32 $ P.fromIntegral $ P.fromEnum _v3418))) $ groupCall_mediaType record
  ]
write_GroupCall :: T.Protocol p => p -> GroupCall -> P.IO ()
write_GroupCall oprot record = T.writeVal oprot $ from_GroupCall record
encode_GroupCall :: T.StatelessProtocol p => p -> GroupCall -> LBS.ByteString
encode_GroupCall oprot record = T.serializeVal oprot $ from_GroupCall record
to_GroupCall :: T.ThriftVal -> GroupCall
to_GroupCall (T.TStruct fields) = GroupCall{
  groupCall_online = P.maybe (groupCall_online default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TBool _val3423 -> _val3423; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  groupCall_chatMid = P.maybe (groupCall_chatMid default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TString _val3424 -> E.decodeUtf8 _val3424; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  groupCall_hostMids = P.maybe (groupCall_hostMids default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TString _val3425 -> E.decodeUtf8 _val3425; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  groupCall_memberMids = P.maybe (groupCall_memberMids default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TList _ _val3426 -> (Vector.fromList $ P.map (\_v3427 -> (case _v3427 of {T.TString _val3428 -> E.decodeUtf8 _val3428; _ -> P.error "wrong type"})) _val3426); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  groupCall_started = P.maybe (groupCall_started default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TI64 _val3429 -> _val3429; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  groupCall_mediaType = P.maybe (groupCall_mediaType default_GroupCall) (\(_,_val3422) -> (case _val3422 of {T.TI32 _val3430 -> P.toEnum $ P.fromIntegral _val3430; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GroupCall _ = P.error "not a struct"
read_GroupCall :: T.Protocol p => p -> P.IO GroupCall
read_GroupCall iprot = to_GroupCall <$> T.readVal iprot (T.T_STRUCT typemap_GroupCall)
decode_GroupCall :: T.StatelessProtocol p => p -> LBS.ByteString -> GroupCall
decode_GroupCall iprot bs = to_GroupCall $ T.deserializeVal iprot (T.T_STRUCT typemap_GroupCall) bs
typemap_GroupCall :: T.TypeMap
typemap_GroupCall = Map.fromList [(1,("online",T.T_BOOL)),(2,("chatMid",T.T_STRING)),(3,("hostMids",T.T_STRING)),(4,("memberMids",(T.T_LIST T.T_STRING))),(5,("started",T.T_I64)),(6,("mediaType",T.T_I32))]
default_GroupCall :: GroupCall
default_GroupCall = GroupCall{
  groupCall_online = P.False,
  groupCall_chatMid = "",
  groupCall_hostMids = "",
  groupCall_memberMids = Vector.empty,
  groupCall_started = 0,
  groupCall_mediaType = (P.toEnum 0)}
data GroupCallRoute = GroupCallRoute  { groupCallRoute_token :: LT.Text
  , groupCallRoute_cscf :: CallHost
  , groupCallRoute_mix :: CallHost
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GroupCallRoute where
  hashWithSalt salt record = salt   `H.hashWithSalt` groupCallRoute_token record   `H.hashWithSalt` groupCallRoute_cscf record   `H.hashWithSalt` groupCallRoute_mix record  
instance QC.Arbitrary GroupCallRoute where 
  arbitrary = M.liftM GroupCallRoute (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GroupCallRoute = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GroupCallRoute{groupCallRoute_token = groupCallRoute_token obj} then P.Nothing else P.Just $ default_GroupCallRoute{groupCallRoute_token = groupCallRoute_token obj}
    , if obj == default_GroupCallRoute{groupCallRoute_cscf = groupCallRoute_cscf obj} then P.Nothing else P.Just $ default_GroupCallRoute{groupCallRoute_cscf = groupCallRoute_cscf obj}
    , if obj == default_GroupCallRoute{groupCallRoute_mix = groupCallRoute_mix obj} then P.Nothing else P.Just $ default_GroupCallRoute{groupCallRoute_mix = groupCallRoute_mix obj}
    ]
from_GroupCallRoute :: GroupCallRoute -> T.ThriftVal
from_GroupCallRoute record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3433 -> P.Just (1, ("token",T.TString $ E.encodeUtf8 _v3433))) $ groupCallRoute_token record
  , (\_v3433 -> P.Just (2, ("cscf",from_CallHost _v3433))) $ groupCallRoute_cscf record
  , (\_v3433 -> P.Just (3, ("mix",from_CallHost _v3433))) $ groupCallRoute_mix record
  ]
write_GroupCallRoute :: T.Protocol p => p -> GroupCallRoute -> P.IO ()
write_GroupCallRoute oprot record = T.writeVal oprot $ from_GroupCallRoute record
encode_GroupCallRoute :: T.StatelessProtocol p => p -> GroupCallRoute -> LBS.ByteString
encode_GroupCallRoute oprot record = T.serializeVal oprot $ from_GroupCallRoute record
to_GroupCallRoute :: T.ThriftVal -> GroupCallRoute
to_GroupCallRoute (T.TStruct fields) = GroupCallRoute{
  groupCallRoute_token = P.maybe (groupCallRoute_token default_GroupCallRoute) (\(_,_val3435) -> (case _val3435 of {T.TString _val3436 -> E.decodeUtf8 _val3436; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  groupCallRoute_cscf = P.maybe (groupCallRoute_cscf default_GroupCallRoute) (\(_,_val3435) -> (case _val3435 of {T.TStruct _val3437 -> (to_CallHost (T.TStruct _val3437)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  groupCallRoute_mix = P.maybe (groupCallRoute_mix default_GroupCallRoute) (\(_,_val3435) -> (case _val3435 of {T.TStruct _val3438 -> (to_CallHost (T.TStruct _val3438)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GroupCallRoute _ = P.error "not a struct"
read_GroupCallRoute :: T.Protocol p => p -> P.IO GroupCallRoute
read_GroupCallRoute iprot = to_GroupCallRoute <$> T.readVal iprot (T.T_STRUCT typemap_GroupCallRoute)
decode_GroupCallRoute :: T.StatelessProtocol p => p -> LBS.ByteString -> GroupCallRoute
decode_GroupCallRoute iprot bs = to_GroupCallRoute $ T.deserializeVal iprot (T.T_STRUCT typemap_GroupCallRoute) bs
typemap_GroupCallRoute :: T.TypeMap
typemap_GroupCallRoute = Map.fromList [(1,("token",T.T_STRING)),(2,("cscf",(T.T_STRUCT typemap_CallHost))),(3,("mix",(T.T_STRUCT typemap_CallHost)))]
default_GroupCallRoute :: GroupCallRoute
default_GroupCallRoute = GroupCallRoute{
  groupCallRoute_token = "",
  groupCallRoute_cscf = default_CallHost,
  groupCallRoute_mix = default_CallHost}
