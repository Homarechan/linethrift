{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module AccountSupervisorService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified AccountSupervisorService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetRSAKey_args = GetRSAKey_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKey_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetRSAKey_args where 
  arbitrary = QC.elements [GetRSAKey_args]
from_GetRSAKey_args :: GetRSAKey_args -> T.ThriftVal
from_GetRSAKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetRSAKey_args :: T.Protocol p => p -> GetRSAKey_args -> P.IO ()
write_GetRSAKey_args oprot record = T.writeVal oprot $ from_GetRSAKey_args record
encode_GetRSAKey_args :: T.StatelessProtocol p => p -> GetRSAKey_args -> LBS.ByteString
encode_GetRSAKey_args oprot record = T.serializeVal oprot $ from_GetRSAKey_args record
to_GetRSAKey_args :: T.ThriftVal -> GetRSAKey_args
to_GetRSAKey_args (T.TStruct fields) = GetRSAKey_args{

  }
to_GetRSAKey_args _ = P.error "not a struct"
read_GetRSAKey_args :: T.Protocol p => p -> P.IO GetRSAKey_args
read_GetRSAKey_args iprot = to_GetRSAKey_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKey_args)
decode_GetRSAKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKey_args
decode_GetRSAKey_args iprot bs = to_GetRSAKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKey_args) bs
typemap_GetRSAKey_args :: T.TypeMap
typemap_GetRSAKey_args = Map.fromList []
default_GetRSAKey_args :: GetRSAKey_args
default_GetRSAKey_args = GetRSAKey_args{
}
data GetRSAKey_result = GetRSAKey_result  { getRSAKey_result_success :: RSAKey
  , getRSAKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRSAKey_result_success record   `H.hashWithSalt` getRSAKey_result_e record  
instance QC.Arbitrary GetRSAKey_result where 
  arbitrary = M.liftM GetRSAKey_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRSAKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRSAKey_result{getRSAKey_result_success = getRSAKey_result_success obj} then P.Nothing else P.Just $ default_GetRSAKey_result{getRSAKey_result_success = getRSAKey_result_success obj}
    , if obj == default_GetRSAKey_result{getRSAKey_result_e = getRSAKey_result_e obj} then P.Nothing else P.Just $ default_GetRSAKey_result{getRSAKey_result_e = getRSAKey_result_e obj}
    ]
from_GetRSAKey_result :: GetRSAKey_result -> T.ThriftVal
from_GetRSAKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3969 -> (1, ("e",from_TalkException _v3969))) <$> getRSAKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3969 -> P.Just (0, ("success",from_RSAKey _v3969))) $ getRSAKey_result_success record
    , (\_v3969 -> (1, ("e",from_TalkException _v3969))) <$> getRSAKey_result_e record
    ]
    )
write_GetRSAKey_result :: T.Protocol p => p -> GetRSAKey_result -> P.IO ()
write_GetRSAKey_result oprot record = T.writeVal oprot $ from_GetRSAKey_result record
encode_GetRSAKey_result :: T.StatelessProtocol p => p -> GetRSAKey_result -> LBS.ByteString
encode_GetRSAKey_result oprot record = T.serializeVal oprot $ from_GetRSAKey_result record
to_GetRSAKey_result :: T.ThriftVal -> GetRSAKey_result
to_GetRSAKey_result (T.TStruct fields) = GetRSAKey_result{
  getRSAKey_result_success = P.maybe (getRSAKey_result_success default_GetRSAKey_result) (\(_,_val3971) -> (case _val3971 of {T.TStruct _val3972 -> (to_RSAKey (T.TStruct _val3972)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRSAKey_result_e = P.maybe (P.Nothing) (\(_,_val3971) -> P.Just (case _val3971 of {T.TStruct _val3973 -> (to_TalkException (T.TStruct _val3973)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRSAKey_result _ = P.error "not a struct"
read_GetRSAKey_result :: T.Protocol p => p -> P.IO GetRSAKey_result
read_GetRSAKey_result iprot = to_GetRSAKey_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKey_result)
decode_GetRSAKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKey_result
decode_GetRSAKey_result iprot bs = to_GetRSAKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKey_result) bs
typemap_GetRSAKey_result :: T.TypeMap
typemap_GetRSAKey_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RSAKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRSAKey_result :: GetRSAKey_result
default_GetRSAKey_result = GetRSAKey_result{
  getRSAKey_result_success = default_RSAKey,
  getRSAKey_result_e = P.Nothing}
data NotifyEmailConfirmationResult_args = NotifyEmailConfirmationResult_args  { notifyEmailConfirmationResult_args_parameterMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyEmailConfirmationResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyEmailConfirmationResult_args_parameterMap record  
instance QC.Arbitrary NotifyEmailConfirmationResult_args where 
  arbitrary = M.liftM NotifyEmailConfirmationResult_args (QC.arbitrary)
  shrink obj | obj == default_NotifyEmailConfirmationResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyEmailConfirmationResult_args{notifyEmailConfirmationResult_args_parameterMap = notifyEmailConfirmationResult_args_parameterMap obj} then P.Nothing else P.Just $ default_NotifyEmailConfirmationResult_args{notifyEmailConfirmationResult_args_parameterMap = notifyEmailConfirmationResult_args_parameterMap obj}
    ]
from_NotifyEmailConfirmationResult_args :: NotifyEmailConfirmationResult_args -> T.ThriftVal
from_NotifyEmailConfirmationResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3976 -> P.Just (2, ("parameterMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k3977,_v3978) -> (T.TString $ E.encodeUtf8 _k3977, T.TString $ E.encodeUtf8 _v3978)) $ Map.toList _v3976))) $ notifyEmailConfirmationResult_args_parameterMap record
  ]
write_NotifyEmailConfirmationResult_args :: T.Protocol p => p -> NotifyEmailConfirmationResult_args -> P.IO ()
write_NotifyEmailConfirmationResult_args oprot record = T.writeVal oprot $ from_NotifyEmailConfirmationResult_args record
encode_NotifyEmailConfirmationResult_args :: T.StatelessProtocol p => p -> NotifyEmailConfirmationResult_args -> LBS.ByteString
encode_NotifyEmailConfirmationResult_args oprot record = T.serializeVal oprot $ from_NotifyEmailConfirmationResult_args record
to_NotifyEmailConfirmationResult_args :: T.ThriftVal -> NotifyEmailConfirmationResult_args
to_NotifyEmailConfirmationResult_args (T.TStruct fields) = NotifyEmailConfirmationResult_args{
  notifyEmailConfirmationResult_args_parameterMap = P.maybe (notifyEmailConfirmationResult_args_parameterMap default_NotifyEmailConfirmationResult_args) (\(_,_val3980) -> (case _val3980 of {T.TMap _ _ _val3981 -> (Map.fromList $ P.map (\(_k3983,_v3982) -> ((case _k3983 of {T.TString _val3984 -> E.decodeUtf8 _val3984; _ -> P.error "wrong type"}),(case _v3982 of {T.TString _val3985 -> E.decodeUtf8 _val3985; _ -> P.error "wrong type"}))) _val3981); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotifyEmailConfirmationResult_args _ = P.error "not a struct"
read_NotifyEmailConfirmationResult_args :: T.Protocol p => p -> P.IO NotifyEmailConfirmationResult_args
read_NotifyEmailConfirmationResult_args iprot = to_NotifyEmailConfirmationResult_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyEmailConfirmationResult_args)
decode_NotifyEmailConfirmationResult_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyEmailConfirmationResult_args
decode_NotifyEmailConfirmationResult_args iprot bs = to_NotifyEmailConfirmationResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyEmailConfirmationResult_args) bs
typemap_NotifyEmailConfirmationResult_args :: T.TypeMap
typemap_NotifyEmailConfirmationResult_args = Map.fromList [(2,("parameterMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotifyEmailConfirmationResult_args :: NotifyEmailConfirmationResult_args
default_NotifyEmailConfirmationResult_args = NotifyEmailConfirmationResult_args{
  notifyEmailConfirmationResult_args_parameterMap = Map.empty}
data NotifyEmailConfirmationResult_result = NotifyEmailConfirmationResult_result  { notifyEmailConfirmationResult_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyEmailConfirmationResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyEmailConfirmationResult_result_e record  
instance QC.Arbitrary NotifyEmailConfirmationResult_result where 
  arbitrary = M.liftM NotifyEmailConfirmationResult_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyEmailConfirmationResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyEmailConfirmationResult_result{notifyEmailConfirmationResult_result_e = notifyEmailConfirmationResult_result_e obj} then P.Nothing else P.Just $ default_NotifyEmailConfirmationResult_result{notifyEmailConfirmationResult_result_e = notifyEmailConfirmationResult_result_e obj}
    ]
from_NotifyEmailConfirmationResult_result :: NotifyEmailConfirmationResult_result -> T.ThriftVal
from_NotifyEmailConfirmationResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v3988 -> (1, ("e",from_TalkException _v3988))) <$> notifyEmailConfirmationResult_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v3988 -> (1, ("e",from_TalkException _v3988))) <$> notifyEmailConfirmationResult_result_e record
    ]
    )
write_NotifyEmailConfirmationResult_result :: T.Protocol p => p -> NotifyEmailConfirmationResult_result -> P.IO ()
write_NotifyEmailConfirmationResult_result oprot record = T.writeVal oprot $ from_NotifyEmailConfirmationResult_result record
encode_NotifyEmailConfirmationResult_result :: T.StatelessProtocol p => p -> NotifyEmailConfirmationResult_result -> LBS.ByteString
encode_NotifyEmailConfirmationResult_result oprot record = T.serializeVal oprot $ from_NotifyEmailConfirmationResult_result record
to_NotifyEmailConfirmationResult_result :: T.ThriftVal -> NotifyEmailConfirmationResult_result
to_NotifyEmailConfirmationResult_result (T.TStruct fields) = NotifyEmailConfirmationResult_result{
  notifyEmailConfirmationResult_result_e = P.maybe (P.Nothing) (\(_,_val3990) -> P.Just (case _val3990 of {T.TStruct _val3991 -> (to_TalkException (T.TStruct _val3991)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyEmailConfirmationResult_result _ = P.error "not a struct"
read_NotifyEmailConfirmationResult_result :: T.Protocol p => p -> P.IO NotifyEmailConfirmationResult_result
read_NotifyEmailConfirmationResult_result iprot = to_NotifyEmailConfirmationResult_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyEmailConfirmationResult_result)
decode_NotifyEmailConfirmationResult_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyEmailConfirmationResult_result
decode_NotifyEmailConfirmationResult_result iprot bs = to_NotifyEmailConfirmationResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyEmailConfirmationResult_result) bs
typemap_NotifyEmailConfirmationResult_result :: T.TypeMap
typemap_NotifyEmailConfirmationResult_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyEmailConfirmationResult_result :: NotifyEmailConfirmationResult_result
default_NotifyEmailConfirmationResult_result = NotifyEmailConfirmationResult_result{
  notifyEmailConfirmationResult_result_e = P.Nothing}
data RegisterVirtualAccount_args = RegisterVirtualAccount_args  { registerVirtualAccount_args_locale :: LT.Text
  , registerVirtualAccount_args_encryptedVirtualUserId :: LT.Text
  , registerVirtualAccount_args_encryptedPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterVirtualAccount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerVirtualAccount_args_locale record   `H.hashWithSalt` registerVirtualAccount_args_encryptedVirtualUserId record   `H.hashWithSalt` registerVirtualAccount_args_encryptedPassword record  
instance QC.Arbitrary RegisterVirtualAccount_args where 
  arbitrary = M.liftM RegisterVirtualAccount_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterVirtualAccount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterVirtualAccount_args{registerVirtualAccount_args_locale = registerVirtualAccount_args_locale obj} then P.Nothing else P.Just $ default_RegisterVirtualAccount_args{registerVirtualAccount_args_locale = registerVirtualAccount_args_locale obj}
    , if obj == default_RegisterVirtualAccount_args{registerVirtualAccount_args_encryptedVirtualUserId = registerVirtualAccount_args_encryptedVirtualUserId obj} then P.Nothing else P.Just $ default_RegisterVirtualAccount_args{registerVirtualAccount_args_encryptedVirtualUserId = registerVirtualAccount_args_encryptedVirtualUserId obj}
    , if obj == default_RegisterVirtualAccount_args{registerVirtualAccount_args_encryptedPassword = registerVirtualAccount_args_encryptedPassword obj} then P.Nothing else P.Just $ default_RegisterVirtualAccount_args{registerVirtualAccount_args_encryptedPassword = registerVirtualAccount_args_encryptedPassword obj}
    ]
from_RegisterVirtualAccount_args :: RegisterVirtualAccount_args -> T.ThriftVal
from_RegisterVirtualAccount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v3994 -> P.Just (2, ("locale",T.TString $ E.encodeUtf8 _v3994))) $ registerVirtualAccount_args_locale record
  , (\_v3994 -> P.Just (3, ("encryptedVirtualUserId",T.TString $ E.encodeUtf8 _v3994))) $ registerVirtualAccount_args_encryptedVirtualUserId record
  , (\_v3994 -> P.Just (4, ("encryptedPassword",T.TString $ E.encodeUtf8 _v3994))) $ registerVirtualAccount_args_encryptedPassword record
  ]
write_RegisterVirtualAccount_args :: T.Protocol p => p -> RegisterVirtualAccount_args -> P.IO ()
write_RegisterVirtualAccount_args oprot record = T.writeVal oprot $ from_RegisterVirtualAccount_args record
encode_RegisterVirtualAccount_args :: T.StatelessProtocol p => p -> RegisterVirtualAccount_args -> LBS.ByteString
encode_RegisterVirtualAccount_args oprot record = T.serializeVal oprot $ from_RegisterVirtualAccount_args record
to_RegisterVirtualAccount_args :: T.ThriftVal -> RegisterVirtualAccount_args
to_RegisterVirtualAccount_args (T.TStruct fields) = RegisterVirtualAccount_args{
  registerVirtualAccount_args_locale = P.maybe (registerVirtualAccount_args_locale default_RegisterVirtualAccount_args) (\(_,_val3996) -> (case _val3996 of {T.TString _val3997 -> E.decodeUtf8 _val3997; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerVirtualAccount_args_encryptedVirtualUserId = P.maybe (registerVirtualAccount_args_encryptedVirtualUserId default_RegisterVirtualAccount_args) (\(_,_val3996) -> (case _val3996 of {T.TString _val3998 -> E.decodeUtf8 _val3998; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerVirtualAccount_args_encryptedPassword = P.maybe (registerVirtualAccount_args_encryptedPassword default_RegisterVirtualAccount_args) (\(_,_val3996) -> (case _val3996 of {T.TString _val3999 -> E.decodeUtf8 _val3999; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterVirtualAccount_args _ = P.error "not a struct"
read_RegisterVirtualAccount_args :: T.Protocol p => p -> P.IO RegisterVirtualAccount_args
read_RegisterVirtualAccount_args iprot = to_RegisterVirtualAccount_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterVirtualAccount_args)
decode_RegisterVirtualAccount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterVirtualAccount_args
decode_RegisterVirtualAccount_args iprot bs = to_RegisterVirtualAccount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterVirtualAccount_args) bs
typemap_RegisterVirtualAccount_args :: T.TypeMap
typemap_RegisterVirtualAccount_args = Map.fromList [(2,("locale",T.T_STRING)),(3,("encryptedVirtualUserId",T.T_STRING)),(4,("encryptedPassword",T.T_STRING))]
default_RegisterVirtualAccount_args :: RegisterVirtualAccount_args
default_RegisterVirtualAccount_args = RegisterVirtualAccount_args{
  registerVirtualAccount_args_locale = "",
  registerVirtualAccount_args_encryptedVirtualUserId = "",
  registerVirtualAccount_args_encryptedPassword = ""}
data RegisterVirtualAccount_result = RegisterVirtualAccount_result  { registerVirtualAccount_result_success :: LT.Text
  , registerVirtualAccount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterVirtualAccount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerVirtualAccount_result_success record   `H.hashWithSalt` registerVirtualAccount_result_e record  
instance QC.Arbitrary RegisterVirtualAccount_result where 
  arbitrary = M.liftM RegisterVirtualAccount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterVirtualAccount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterVirtualAccount_result{registerVirtualAccount_result_success = registerVirtualAccount_result_success obj} then P.Nothing else P.Just $ default_RegisterVirtualAccount_result{registerVirtualAccount_result_success = registerVirtualAccount_result_success obj}
    , if obj == default_RegisterVirtualAccount_result{registerVirtualAccount_result_e = registerVirtualAccount_result_e obj} then P.Nothing else P.Just $ default_RegisterVirtualAccount_result{registerVirtualAccount_result_e = registerVirtualAccount_result_e obj}
    ]
from_RegisterVirtualAccount_result :: RegisterVirtualAccount_result -> T.ThriftVal
from_RegisterVirtualAccount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4002 -> (1, ("e",from_TalkException _v4002))) <$> registerVirtualAccount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4002 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4002))) $ registerVirtualAccount_result_success record
    , (\_v4002 -> (1, ("e",from_TalkException _v4002))) <$> registerVirtualAccount_result_e record
    ]
    )
write_RegisterVirtualAccount_result :: T.Protocol p => p -> RegisterVirtualAccount_result -> P.IO ()
write_RegisterVirtualAccount_result oprot record = T.writeVal oprot $ from_RegisterVirtualAccount_result record
encode_RegisterVirtualAccount_result :: T.StatelessProtocol p => p -> RegisterVirtualAccount_result -> LBS.ByteString
encode_RegisterVirtualAccount_result oprot record = T.serializeVal oprot $ from_RegisterVirtualAccount_result record
to_RegisterVirtualAccount_result :: T.ThriftVal -> RegisterVirtualAccount_result
to_RegisterVirtualAccount_result (T.TStruct fields) = RegisterVirtualAccount_result{
  registerVirtualAccount_result_success = P.maybe (registerVirtualAccount_result_success default_RegisterVirtualAccount_result) (\(_,_val4004) -> (case _val4004 of {T.TString _val4005 -> E.decodeUtf8 _val4005; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerVirtualAccount_result_e = P.maybe (P.Nothing) (\(_,_val4004) -> P.Just (case _val4004 of {T.TStruct _val4006 -> (to_TalkException (T.TStruct _val4006)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterVirtualAccount_result _ = P.error "not a struct"
read_RegisterVirtualAccount_result :: T.Protocol p => p -> P.IO RegisterVirtualAccount_result
read_RegisterVirtualAccount_result iprot = to_RegisterVirtualAccount_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterVirtualAccount_result)
decode_RegisterVirtualAccount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterVirtualAccount_result
decode_RegisterVirtualAccount_result iprot bs = to_RegisterVirtualAccount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterVirtualAccount_result) bs
typemap_RegisterVirtualAccount_result :: T.TypeMap
typemap_RegisterVirtualAccount_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterVirtualAccount_result :: RegisterVirtualAccount_result
default_RegisterVirtualAccount_result = RegisterVirtualAccount_result{
  registerVirtualAccount_result_success = "",
  registerVirtualAccount_result_e = P.Nothing}
data RequestVirtualAccountPasswordChange_args = RequestVirtualAccountPasswordChange_args  { requestVirtualAccountPasswordChange_args_virtualMid :: LT.Text
  , requestVirtualAccountPasswordChange_args_encryptedVirtualUserId :: LT.Text
  , requestVirtualAccountPasswordChange_args_encryptedOldPassword :: LT.Text
  , requestVirtualAccountPasswordChange_args_encryptedNewPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVirtualAccountPasswordChange_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVirtualAccountPasswordChange_args_virtualMid record   `H.hashWithSalt` requestVirtualAccountPasswordChange_args_encryptedVirtualUserId record   `H.hashWithSalt` requestVirtualAccountPasswordChange_args_encryptedOldPassword record   `H.hashWithSalt` requestVirtualAccountPasswordChange_args_encryptedNewPassword record  
instance QC.Arbitrary RequestVirtualAccountPasswordChange_args where 
  arbitrary = M.liftM RequestVirtualAccountPasswordChange_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestVirtualAccountPasswordChange_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_virtualMid = requestVirtualAccountPasswordChange_args_virtualMid obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_virtualMid = requestVirtualAccountPasswordChange_args_virtualMid obj}
    , if obj == default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedVirtualUserId = requestVirtualAccountPasswordChange_args_encryptedVirtualUserId obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedVirtualUserId = requestVirtualAccountPasswordChange_args_encryptedVirtualUserId obj}
    , if obj == default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedOldPassword = requestVirtualAccountPasswordChange_args_encryptedOldPassword obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedOldPassword = requestVirtualAccountPasswordChange_args_encryptedOldPassword obj}
    , if obj == default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedNewPassword = requestVirtualAccountPasswordChange_args_encryptedNewPassword obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordChange_args{requestVirtualAccountPasswordChange_args_encryptedNewPassword = requestVirtualAccountPasswordChange_args_encryptedNewPassword obj}
    ]
from_RequestVirtualAccountPasswordChange_args :: RequestVirtualAccountPasswordChange_args -> T.ThriftVal
from_RequestVirtualAccountPasswordChange_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4009 -> P.Just (2, ("virtualMid",T.TString $ E.encodeUtf8 _v4009))) $ requestVirtualAccountPasswordChange_args_virtualMid record
  , (\_v4009 -> P.Just (3, ("encryptedVirtualUserId",T.TString $ E.encodeUtf8 _v4009))) $ requestVirtualAccountPasswordChange_args_encryptedVirtualUserId record
  , (\_v4009 -> P.Just (4, ("encryptedOldPassword",T.TString $ E.encodeUtf8 _v4009))) $ requestVirtualAccountPasswordChange_args_encryptedOldPassword record
  , (\_v4009 -> P.Just (5, ("encryptedNewPassword",T.TString $ E.encodeUtf8 _v4009))) $ requestVirtualAccountPasswordChange_args_encryptedNewPassword record
  ]
write_RequestVirtualAccountPasswordChange_args :: T.Protocol p => p -> RequestVirtualAccountPasswordChange_args -> P.IO ()
write_RequestVirtualAccountPasswordChange_args oprot record = T.writeVal oprot $ from_RequestVirtualAccountPasswordChange_args record
encode_RequestVirtualAccountPasswordChange_args :: T.StatelessProtocol p => p -> RequestVirtualAccountPasswordChange_args -> LBS.ByteString
encode_RequestVirtualAccountPasswordChange_args oprot record = T.serializeVal oprot $ from_RequestVirtualAccountPasswordChange_args record
to_RequestVirtualAccountPasswordChange_args :: T.ThriftVal -> RequestVirtualAccountPasswordChange_args
to_RequestVirtualAccountPasswordChange_args (T.TStruct fields) = RequestVirtualAccountPasswordChange_args{
  requestVirtualAccountPasswordChange_args_virtualMid = P.maybe (requestVirtualAccountPasswordChange_args_virtualMid default_RequestVirtualAccountPasswordChange_args) (\(_,_val4011) -> (case _val4011 of {T.TString _val4012 -> E.decodeUtf8 _val4012; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestVirtualAccountPasswordChange_args_encryptedVirtualUserId = P.maybe (requestVirtualAccountPasswordChange_args_encryptedVirtualUserId default_RequestVirtualAccountPasswordChange_args) (\(_,_val4011) -> (case _val4011 of {T.TString _val4013 -> E.decodeUtf8 _val4013; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  requestVirtualAccountPasswordChange_args_encryptedOldPassword = P.maybe (requestVirtualAccountPasswordChange_args_encryptedOldPassword default_RequestVirtualAccountPasswordChange_args) (\(_,_val4011) -> (case _val4011 of {T.TString _val4014 -> E.decodeUtf8 _val4014; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  requestVirtualAccountPasswordChange_args_encryptedNewPassword = P.maybe (requestVirtualAccountPasswordChange_args_encryptedNewPassword default_RequestVirtualAccountPasswordChange_args) (\(_,_val4011) -> (case _val4011 of {T.TString _val4015 -> E.decodeUtf8 _val4015; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RequestVirtualAccountPasswordChange_args _ = P.error "not a struct"
read_RequestVirtualAccountPasswordChange_args :: T.Protocol p => p -> P.IO RequestVirtualAccountPasswordChange_args
read_RequestVirtualAccountPasswordChange_args iprot = to_RequestVirtualAccountPasswordChange_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordChange_args)
decode_RequestVirtualAccountPasswordChange_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVirtualAccountPasswordChange_args
decode_RequestVirtualAccountPasswordChange_args iprot bs = to_RequestVirtualAccountPasswordChange_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordChange_args) bs
typemap_RequestVirtualAccountPasswordChange_args :: T.TypeMap
typemap_RequestVirtualAccountPasswordChange_args = Map.fromList [(2,("virtualMid",T.T_STRING)),(3,("encryptedVirtualUserId",T.T_STRING)),(4,("encryptedOldPassword",T.T_STRING)),(5,("encryptedNewPassword",T.T_STRING))]
default_RequestVirtualAccountPasswordChange_args :: RequestVirtualAccountPasswordChange_args
default_RequestVirtualAccountPasswordChange_args = RequestVirtualAccountPasswordChange_args{
  requestVirtualAccountPasswordChange_args_virtualMid = "",
  requestVirtualAccountPasswordChange_args_encryptedVirtualUserId = "",
  requestVirtualAccountPasswordChange_args_encryptedOldPassword = "",
  requestVirtualAccountPasswordChange_args_encryptedNewPassword = ""}
data RequestVirtualAccountPasswordChange_result = RequestVirtualAccountPasswordChange_result  { requestVirtualAccountPasswordChange_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVirtualAccountPasswordChange_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVirtualAccountPasswordChange_result_e record  
instance QC.Arbitrary RequestVirtualAccountPasswordChange_result where 
  arbitrary = M.liftM RequestVirtualAccountPasswordChange_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestVirtualAccountPasswordChange_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVirtualAccountPasswordChange_result{requestVirtualAccountPasswordChange_result_e = requestVirtualAccountPasswordChange_result_e obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordChange_result{requestVirtualAccountPasswordChange_result_e = requestVirtualAccountPasswordChange_result_e obj}
    ]
from_RequestVirtualAccountPasswordChange_result :: RequestVirtualAccountPasswordChange_result -> T.ThriftVal
from_RequestVirtualAccountPasswordChange_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4018 -> (1, ("e",from_TalkException _v4018))) <$> requestVirtualAccountPasswordChange_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4018 -> (1, ("e",from_TalkException _v4018))) <$> requestVirtualAccountPasswordChange_result_e record
    ]
    )
write_RequestVirtualAccountPasswordChange_result :: T.Protocol p => p -> RequestVirtualAccountPasswordChange_result -> P.IO ()
write_RequestVirtualAccountPasswordChange_result oprot record = T.writeVal oprot $ from_RequestVirtualAccountPasswordChange_result record
encode_RequestVirtualAccountPasswordChange_result :: T.StatelessProtocol p => p -> RequestVirtualAccountPasswordChange_result -> LBS.ByteString
encode_RequestVirtualAccountPasswordChange_result oprot record = T.serializeVal oprot $ from_RequestVirtualAccountPasswordChange_result record
to_RequestVirtualAccountPasswordChange_result :: T.ThriftVal -> RequestVirtualAccountPasswordChange_result
to_RequestVirtualAccountPasswordChange_result (T.TStruct fields) = RequestVirtualAccountPasswordChange_result{
  requestVirtualAccountPasswordChange_result_e = P.maybe (P.Nothing) (\(_,_val4020) -> P.Just (case _val4020 of {T.TStruct _val4021 -> (to_TalkException (T.TStruct _val4021)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestVirtualAccountPasswordChange_result _ = P.error "not a struct"
read_RequestVirtualAccountPasswordChange_result :: T.Protocol p => p -> P.IO RequestVirtualAccountPasswordChange_result
read_RequestVirtualAccountPasswordChange_result iprot = to_RequestVirtualAccountPasswordChange_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordChange_result)
decode_RequestVirtualAccountPasswordChange_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVirtualAccountPasswordChange_result
decode_RequestVirtualAccountPasswordChange_result iprot bs = to_RequestVirtualAccountPasswordChange_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordChange_result) bs
typemap_RequestVirtualAccountPasswordChange_result :: T.TypeMap
typemap_RequestVirtualAccountPasswordChange_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestVirtualAccountPasswordChange_result :: RequestVirtualAccountPasswordChange_result
default_RequestVirtualAccountPasswordChange_result = RequestVirtualAccountPasswordChange_result{
  requestVirtualAccountPasswordChange_result_e = P.Nothing}
data RequestVirtualAccountPasswordSet_args = RequestVirtualAccountPasswordSet_args  { requestVirtualAccountPasswordSet_args_virtualMid :: LT.Text
  , requestVirtualAccountPasswordSet_args_encryptedVirtualUserId :: LT.Text
  , requestVirtualAccountPasswordSet_args_encryptedNewPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVirtualAccountPasswordSet_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVirtualAccountPasswordSet_args_virtualMid record   `H.hashWithSalt` requestVirtualAccountPasswordSet_args_encryptedVirtualUserId record   `H.hashWithSalt` requestVirtualAccountPasswordSet_args_encryptedNewPassword record  
instance QC.Arbitrary RequestVirtualAccountPasswordSet_args where 
  arbitrary = M.liftM RequestVirtualAccountPasswordSet_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestVirtualAccountPasswordSet_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_virtualMid = requestVirtualAccountPasswordSet_args_virtualMid obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_virtualMid = requestVirtualAccountPasswordSet_args_virtualMid obj}
    , if obj == default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_encryptedVirtualUserId = requestVirtualAccountPasswordSet_args_encryptedVirtualUserId obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_encryptedVirtualUserId = requestVirtualAccountPasswordSet_args_encryptedVirtualUserId obj}
    , if obj == default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_encryptedNewPassword = requestVirtualAccountPasswordSet_args_encryptedNewPassword obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordSet_args{requestVirtualAccountPasswordSet_args_encryptedNewPassword = requestVirtualAccountPasswordSet_args_encryptedNewPassword obj}
    ]
from_RequestVirtualAccountPasswordSet_args :: RequestVirtualAccountPasswordSet_args -> T.ThriftVal
from_RequestVirtualAccountPasswordSet_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4024 -> P.Just (2, ("virtualMid",T.TString $ E.encodeUtf8 _v4024))) $ requestVirtualAccountPasswordSet_args_virtualMid record
  , (\_v4024 -> P.Just (3, ("encryptedVirtualUserId",T.TString $ E.encodeUtf8 _v4024))) $ requestVirtualAccountPasswordSet_args_encryptedVirtualUserId record
  , (\_v4024 -> P.Just (4, ("encryptedNewPassword",T.TString $ E.encodeUtf8 _v4024))) $ requestVirtualAccountPasswordSet_args_encryptedNewPassword record
  ]
write_RequestVirtualAccountPasswordSet_args :: T.Protocol p => p -> RequestVirtualAccountPasswordSet_args -> P.IO ()
write_RequestVirtualAccountPasswordSet_args oprot record = T.writeVal oprot $ from_RequestVirtualAccountPasswordSet_args record
encode_RequestVirtualAccountPasswordSet_args :: T.StatelessProtocol p => p -> RequestVirtualAccountPasswordSet_args -> LBS.ByteString
encode_RequestVirtualAccountPasswordSet_args oprot record = T.serializeVal oprot $ from_RequestVirtualAccountPasswordSet_args record
to_RequestVirtualAccountPasswordSet_args :: T.ThriftVal -> RequestVirtualAccountPasswordSet_args
to_RequestVirtualAccountPasswordSet_args (T.TStruct fields) = RequestVirtualAccountPasswordSet_args{
  requestVirtualAccountPasswordSet_args_virtualMid = P.maybe (requestVirtualAccountPasswordSet_args_virtualMid default_RequestVirtualAccountPasswordSet_args) (\(_,_val4026) -> (case _val4026 of {T.TString _val4027 -> E.decodeUtf8 _val4027; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestVirtualAccountPasswordSet_args_encryptedVirtualUserId = P.maybe (requestVirtualAccountPasswordSet_args_encryptedVirtualUserId default_RequestVirtualAccountPasswordSet_args) (\(_,_val4026) -> (case _val4026 of {T.TString _val4028 -> E.decodeUtf8 _val4028; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  requestVirtualAccountPasswordSet_args_encryptedNewPassword = P.maybe (requestVirtualAccountPasswordSet_args_encryptedNewPassword default_RequestVirtualAccountPasswordSet_args) (\(_,_val4026) -> (case _val4026 of {T.TString _val4029 -> E.decodeUtf8 _val4029; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RequestVirtualAccountPasswordSet_args _ = P.error "not a struct"
read_RequestVirtualAccountPasswordSet_args :: T.Protocol p => p -> P.IO RequestVirtualAccountPasswordSet_args
read_RequestVirtualAccountPasswordSet_args iprot = to_RequestVirtualAccountPasswordSet_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordSet_args)
decode_RequestVirtualAccountPasswordSet_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVirtualAccountPasswordSet_args
decode_RequestVirtualAccountPasswordSet_args iprot bs = to_RequestVirtualAccountPasswordSet_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordSet_args) bs
typemap_RequestVirtualAccountPasswordSet_args :: T.TypeMap
typemap_RequestVirtualAccountPasswordSet_args = Map.fromList [(2,("virtualMid",T.T_STRING)),(3,("encryptedVirtualUserId",T.T_STRING)),(4,("encryptedNewPassword",T.T_STRING))]
default_RequestVirtualAccountPasswordSet_args :: RequestVirtualAccountPasswordSet_args
default_RequestVirtualAccountPasswordSet_args = RequestVirtualAccountPasswordSet_args{
  requestVirtualAccountPasswordSet_args_virtualMid = "",
  requestVirtualAccountPasswordSet_args_encryptedVirtualUserId = "",
  requestVirtualAccountPasswordSet_args_encryptedNewPassword = ""}
data RequestVirtualAccountPasswordSet_result = RequestVirtualAccountPasswordSet_result  { requestVirtualAccountPasswordSet_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestVirtualAccountPasswordSet_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestVirtualAccountPasswordSet_result_e record  
instance QC.Arbitrary RequestVirtualAccountPasswordSet_result where 
  arbitrary = M.liftM RequestVirtualAccountPasswordSet_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestVirtualAccountPasswordSet_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestVirtualAccountPasswordSet_result{requestVirtualAccountPasswordSet_result_e = requestVirtualAccountPasswordSet_result_e obj} then P.Nothing else P.Just $ default_RequestVirtualAccountPasswordSet_result{requestVirtualAccountPasswordSet_result_e = requestVirtualAccountPasswordSet_result_e obj}
    ]
from_RequestVirtualAccountPasswordSet_result :: RequestVirtualAccountPasswordSet_result -> T.ThriftVal
from_RequestVirtualAccountPasswordSet_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4032 -> (1, ("e",from_TalkException _v4032))) <$> requestVirtualAccountPasswordSet_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4032 -> (1, ("e",from_TalkException _v4032))) <$> requestVirtualAccountPasswordSet_result_e record
    ]
    )
write_RequestVirtualAccountPasswordSet_result :: T.Protocol p => p -> RequestVirtualAccountPasswordSet_result -> P.IO ()
write_RequestVirtualAccountPasswordSet_result oprot record = T.writeVal oprot $ from_RequestVirtualAccountPasswordSet_result record
encode_RequestVirtualAccountPasswordSet_result :: T.StatelessProtocol p => p -> RequestVirtualAccountPasswordSet_result -> LBS.ByteString
encode_RequestVirtualAccountPasswordSet_result oprot record = T.serializeVal oprot $ from_RequestVirtualAccountPasswordSet_result record
to_RequestVirtualAccountPasswordSet_result :: T.ThriftVal -> RequestVirtualAccountPasswordSet_result
to_RequestVirtualAccountPasswordSet_result (T.TStruct fields) = RequestVirtualAccountPasswordSet_result{
  requestVirtualAccountPasswordSet_result_e = P.maybe (P.Nothing) (\(_,_val4034) -> P.Just (case _val4034 of {T.TStruct _val4035 -> (to_TalkException (T.TStruct _val4035)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestVirtualAccountPasswordSet_result _ = P.error "not a struct"
read_RequestVirtualAccountPasswordSet_result :: T.Protocol p => p -> P.IO RequestVirtualAccountPasswordSet_result
read_RequestVirtualAccountPasswordSet_result iprot = to_RequestVirtualAccountPasswordSet_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordSet_result)
decode_RequestVirtualAccountPasswordSet_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestVirtualAccountPasswordSet_result
decode_RequestVirtualAccountPasswordSet_result iprot bs = to_RequestVirtualAccountPasswordSet_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestVirtualAccountPasswordSet_result) bs
typemap_RequestVirtualAccountPasswordSet_result :: T.TypeMap
typemap_RequestVirtualAccountPasswordSet_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestVirtualAccountPasswordSet_result :: RequestVirtualAccountPasswordSet_result
default_RequestVirtualAccountPasswordSet_result = RequestVirtualAccountPasswordSet_result{
  requestVirtualAccountPasswordSet_result_e = P.Nothing}
data UnregisterVirtualAccount_args = UnregisterVirtualAccount_args  { unregisterVirtualAccount_args_virtualMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterVirtualAccount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unregisterVirtualAccount_args_virtualMid record  
instance QC.Arbitrary UnregisterVirtualAccount_args where 
  arbitrary = M.liftM UnregisterVirtualAccount_args (QC.arbitrary)
  shrink obj | obj == default_UnregisterVirtualAccount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnregisterVirtualAccount_args{unregisterVirtualAccount_args_virtualMid = unregisterVirtualAccount_args_virtualMid obj} then P.Nothing else P.Just $ default_UnregisterVirtualAccount_args{unregisterVirtualAccount_args_virtualMid = unregisterVirtualAccount_args_virtualMid obj}
    ]
from_UnregisterVirtualAccount_args :: UnregisterVirtualAccount_args -> T.ThriftVal
from_UnregisterVirtualAccount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4038 -> P.Just (2, ("virtualMid",T.TString $ E.encodeUtf8 _v4038))) $ unregisterVirtualAccount_args_virtualMid record
  ]
write_UnregisterVirtualAccount_args :: T.Protocol p => p -> UnregisterVirtualAccount_args -> P.IO ()
write_UnregisterVirtualAccount_args oprot record = T.writeVal oprot $ from_UnregisterVirtualAccount_args record
encode_UnregisterVirtualAccount_args :: T.StatelessProtocol p => p -> UnregisterVirtualAccount_args -> LBS.ByteString
encode_UnregisterVirtualAccount_args oprot record = T.serializeVal oprot $ from_UnregisterVirtualAccount_args record
to_UnregisterVirtualAccount_args :: T.ThriftVal -> UnregisterVirtualAccount_args
to_UnregisterVirtualAccount_args (T.TStruct fields) = UnregisterVirtualAccount_args{
  unregisterVirtualAccount_args_virtualMid = P.maybe (unregisterVirtualAccount_args_virtualMid default_UnregisterVirtualAccount_args) (\(_,_val4040) -> (case _val4040 of {T.TString _val4041 -> E.decodeUtf8 _val4041; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnregisterVirtualAccount_args _ = P.error "not a struct"
read_UnregisterVirtualAccount_args :: T.Protocol p => p -> P.IO UnregisterVirtualAccount_args
read_UnregisterVirtualAccount_args iprot = to_UnregisterVirtualAccount_args <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterVirtualAccount_args)
decode_UnregisterVirtualAccount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterVirtualAccount_args
decode_UnregisterVirtualAccount_args iprot bs = to_UnregisterVirtualAccount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterVirtualAccount_args) bs
typemap_UnregisterVirtualAccount_args :: T.TypeMap
typemap_UnregisterVirtualAccount_args = Map.fromList [(2,("virtualMid",T.T_STRING))]
default_UnregisterVirtualAccount_args :: UnregisterVirtualAccount_args
default_UnregisterVirtualAccount_args = UnregisterVirtualAccount_args{
  unregisterVirtualAccount_args_virtualMid = ""}
data UnregisterVirtualAccount_result = UnregisterVirtualAccount_result  { unregisterVirtualAccount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterVirtualAccount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unregisterVirtualAccount_result_e record  
instance QC.Arbitrary UnregisterVirtualAccount_result where 
  arbitrary = M.liftM UnregisterVirtualAccount_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnregisterVirtualAccount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnregisterVirtualAccount_result{unregisterVirtualAccount_result_e = unregisterVirtualAccount_result_e obj} then P.Nothing else P.Just $ default_UnregisterVirtualAccount_result{unregisterVirtualAccount_result_e = unregisterVirtualAccount_result_e obj}
    ]
from_UnregisterVirtualAccount_result :: UnregisterVirtualAccount_result -> T.ThriftVal
from_UnregisterVirtualAccount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4044 -> (1, ("e",from_TalkException _v4044))) <$> unregisterVirtualAccount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4044 -> (1, ("e",from_TalkException _v4044))) <$> unregisterVirtualAccount_result_e record
    ]
    )
write_UnregisterVirtualAccount_result :: T.Protocol p => p -> UnregisterVirtualAccount_result -> P.IO ()
write_UnregisterVirtualAccount_result oprot record = T.writeVal oprot $ from_UnregisterVirtualAccount_result record
encode_UnregisterVirtualAccount_result :: T.StatelessProtocol p => p -> UnregisterVirtualAccount_result -> LBS.ByteString
encode_UnregisterVirtualAccount_result oprot record = T.serializeVal oprot $ from_UnregisterVirtualAccount_result record
to_UnregisterVirtualAccount_result :: T.ThriftVal -> UnregisterVirtualAccount_result
to_UnregisterVirtualAccount_result (T.TStruct fields) = UnregisterVirtualAccount_result{
  unregisterVirtualAccount_result_e = P.maybe (P.Nothing) (\(_,_val4046) -> P.Just (case _val4046 of {T.TStruct _val4047 -> (to_TalkException (T.TStruct _val4047)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnregisterVirtualAccount_result _ = P.error "not a struct"
read_UnregisterVirtualAccount_result :: T.Protocol p => p -> P.IO UnregisterVirtualAccount_result
read_UnregisterVirtualAccount_result iprot = to_UnregisterVirtualAccount_result <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterVirtualAccount_result)
decode_UnregisterVirtualAccount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterVirtualAccount_result
decode_UnregisterVirtualAccount_result iprot bs = to_UnregisterVirtualAccount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterVirtualAccount_result) bs
typemap_UnregisterVirtualAccount_result :: T.TypeMap
typemap_UnregisterVirtualAccount_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnregisterVirtualAccount_result :: UnregisterVirtualAccount_result
default_UnregisterVirtualAccount_result = UnregisterVirtualAccount_result{
  unregisterVirtualAccount_result_e = P.Nothing}
process_getRSAKey (seqid, iprot, oprot, handler) = do
  args <- read_GetRSAKey_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRSAKey handler
        let res = default_GetRSAKey_result{getRSAKey_result_success = val}
        T.writeMessage oprot ("getRSAKey", T.M_REPLY, seqid) $
          write_GetRSAKey_result oprot res)
      (\e  -> do
        let res = default_GetRSAKey_result{getRSAKey_result_e = P.Just e}
        T.writeMessage oprot ("getRSAKey", T.M_REPLY, seqid) $
          write_GetRSAKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRSAKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyEmailConfirmationResult (seqid, iprot, oprot, handler) = do
  args <- read_NotifyEmailConfirmationResult_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyEmailConfirmationResult handler (notifyEmailConfirmationResult_args_parameterMap args)
        let res = default_NotifyEmailConfirmationResult_result
        T.writeMessage oprot ("notifyEmailConfirmationResult", T.M_REPLY, seqid) $
          write_NotifyEmailConfirmationResult_result oprot res)
      (\e  -> do
        let res = default_NotifyEmailConfirmationResult_result{notifyEmailConfirmationResult_result_e = P.Just e}
        T.writeMessage oprot ("notifyEmailConfirmationResult", T.M_REPLY, seqid) $
          write_NotifyEmailConfirmationResult_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyEmailConfirmationResult", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerVirtualAccount (seqid, iprot, oprot, handler) = do
  args <- read_RegisterVirtualAccount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerVirtualAccount handler (registerVirtualAccount_args_locale args) (registerVirtualAccount_args_encryptedVirtualUserId args) (registerVirtualAccount_args_encryptedPassword args)
        let res = default_RegisterVirtualAccount_result{registerVirtualAccount_result_success = val}
        T.writeMessage oprot ("registerVirtualAccount", T.M_REPLY, seqid) $
          write_RegisterVirtualAccount_result oprot res)
      (\e  -> do
        let res = default_RegisterVirtualAccount_result{registerVirtualAccount_result_e = P.Just e}
        T.writeMessage oprot ("registerVirtualAccount", T.M_REPLY, seqid) $
          write_RegisterVirtualAccount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerVirtualAccount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestVirtualAccountPasswordChange (seqid, iprot, oprot, handler) = do
  args <- read_RequestVirtualAccountPasswordChange_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestVirtualAccountPasswordChange handler (requestVirtualAccountPasswordChange_args_virtualMid args) (requestVirtualAccountPasswordChange_args_encryptedVirtualUserId args) (requestVirtualAccountPasswordChange_args_encryptedOldPassword args) (requestVirtualAccountPasswordChange_args_encryptedNewPassword args)
        let res = default_RequestVirtualAccountPasswordChange_result
        T.writeMessage oprot ("requestVirtualAccountPasswordChange", T.M_REPLY, seqid) $
          write_RequestVirtualAccountPasswordChange_result oprot res)
      (\e  -> do
        let res = default_RequestVirtualAccountPasswordChange_result{requestVirtualAccountPasswordChange_result_e = P.Just e}
        T.writeMessage oprot ("requestVirtualAccountPasswordChange", T.M_REPLY, seqid) $
          write_RequestVirtualAccountPasswordChange_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestVirtualAccountPasswordChange", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestVirtualAccountPasswordSet (seqid, iprot, oprot, handler) = do
  args <- read_RequestVirtualAccountPasswordSet_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestVirtualAccountPasswordSet handler (requestVirtualAccountPasswordSet_args_virtualMid args) (requestVirtualAccountPasswordSet_args_encryptedVirtualUserId args) (requestVirtualAccountPasswordSet_args_encryptedNewPassword args)
        let res = default_RequestVirtualAccountPasswordSet_result
        T.writeMessage oprot ("requestVirtualAccountPasswordSet", T.M_REPLY, seqid) $
          write_RequestVirtualAccountPasswordSet_result oprot res)
      (\e  -> do
        let res = default_RequestVirtualAccountPasswordSet_result{requestVirtualAccountPasswordSet_result_e = P.Just e}
        T.writeMessage oprot ("requestVirtualAccountPasswordSet", T.M_REPLY, seqid) $
          write_RequestVirtualAccountPasswordSet_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestVirtualAccountPasswordSet", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unregisterVirtualAccount (seqid, iprot, oprot, handler) = do
  args <- read_UnregisterVirtualAccount_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unregisterVirtualAccount handler (unregisterVirtualAccount_args_virtualMid args)
        let res = default_UnregisterVirtualAccount_result
        T.writeMessage oprot ("unregisterVirtualAccount", T.M_REPLY, seqid) $
          write_UnregisterVirtualAccount_result oprot res)
      (\e  -> do
        let res = default_UnregisterVirtualAccount_result{unregisterVirtualAccount_result_e = P.Just e}
        T.writeMessage oprot ("unregisterVirtualAccount", T.M_REPLY, seqid) $
          write_UnregisterVirtualAccount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unregisterVirtualAccount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getRSAKey" -> process_getRSAKey (seqid,iprot,oprot,handler)
  "notifyEmailConfirmationResult" -> process_notifyEmailConfirmationResult (seqid,iprot,oprot,handler)
  "registerVirtualAccount" -> process_registerVirtualAccount (seqid,iprot,oprot,handler)
  "requestVirtualAccountPasswordChange" -> process_requestVirtualAccountPasswordChange (seqid,iprot,oprot,handler)
  "requestVirtualAccountPasswordSet" -> process_requestVirtualAccountPasswordSet (seqid,iprot,oprot,handler)
  "unregisterVirtualAccount" -> process_unregisterVirtualAccount (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
