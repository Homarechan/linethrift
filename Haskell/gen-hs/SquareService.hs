{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module SquareService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified SquareService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetSquareChatAnnouncements_args = GetSquareChatAnnouncements_args  { getSquareChatAnnouncements_args_request :: GetSquareChatAnnouncementsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatAnnouncements_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatAnnouncements_args_request record  
instance QC.Arbitrary GetSquareChatAnnouncements_args where 
  arbitrary = M.liftM GetSquareChatAnnouncements_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatAnnouncements_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatAnnouncements_args{getSquareChatAnnouncements_args_request = getSquareChatAnnouncements_args_request obj} then P.Nothing else P.Just $ default_GetSquareChatAnnouncements_args{getSquareChatAnnouncements_args_request = getSquareChatAnnouncements_args_request obj}
    ]
from_GetSquareChatAnnouncements_args :: GetSquareChatAnnouncements_args -> T.ThriftVal
from_GetSquareChatAnnouncements_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10803 -> P.Just (1, ("request",from_GetSquareChatAnnouncementsRequest _v10803))) $ getSquareChatAnnouncements_args_request record
  ]
write_GetSquareChatAnnouncements_args :: T.Protocol p => p -> GetSquareChatAnnouncements_args -> P.IO ()
write_GetSquareChatAnnouncements_args oprot record = T.writeVal oprot $ from_GetSquareChatAnnouncements_args record
encode_GetSquareChatAnnouncements_args :: T.StatelessProtocol p => p -> GetSquareChatAnnouncements_args -> LBS.ByteString
encode_GetSquareChatAnnouncements_args oprot record = T.serializeVal oprot $ from_GetSquareChatAnnouncements_args record
to_GetSquareChatAnnouncements_args :: T.ThriftVal -> GetSquareChatAnnouncements_args
to_GetSquareChatAnnouncements_args (T.TStruct fields) = GetSquareChatAnnouncements_args{
  getSquareChatAnnouncements_args_request = P.maybe (getSquareChatAnnouncements_args_request default_GetSquareChatAnnouncements_args) (\(_,_val10805) -> (case _val10805 of {T.TStruct _val10806 -> (to_GetSquareChatAnnouncementsRequest (T.TStruct _val10806)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatAnnouncements_args _ = P.error "not a struct"
read_GetSquareChatAnnouncements_args :: T.Protocol p => p -> P.IO GetSquareChatAnnouncements_args
read_GetSquareChatAnnouncements_args iprot = to_GetSquareChatAnnouncements_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncements_args)
decode_GetSquareChatAnnouncements_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatAnnouncements_args
decode_GetSquareChatAnnouncements_args iprot bs = to_GetSquareChatAnnouncements_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncements_args) bs
typemap_GetSquareChatAnnouncements_args :: T.TypeMap
typemap_GetSquareChatAnnouncements_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareChatAnnouncementsRequest)))]
default_GetSquareChatAnnouncements_args :: GetSquareChatAnnouncements_args
default_GetSquareChatAnnouncements_args = GetSquareChatAnnouncements_args{
  getSquareChatAnnouncements_args_request = default_GetSquareChatAnnouncementsRequest}
data GetSquareChatAnnouncements_result = GetSquareChatAnnouncements_result  { getSquareChatAnnouncements_result_success :: GetSquareChatAnnouncementsResponse
  , getSquareChatAnnouncements_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatAnnouncements_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatAnnouncements_result_success record   `H.hashWithSalt` getSquareChatAnnouncements_result_e record  
instance QC.Arbitrary GetSquareChatAnnouncements_result where 
  arbitrary = M.liftM GetSquareChatAnnouncements_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareChatAnnouncements_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_success = getSquareChatAnnouncements_result_success obj} then P.Nothing else P.Just $ default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_success = getSquareChatAnnouncements_result_success obj}
    , if obj == default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_e = getSquareChatAnnouncements_result_e obj} then P.Nothing else P.Just $ default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_e = getSquareChatAnnouncements_result_e obj}
    ]
from_GetSquareChatAnnouncements_result :: GetSquareChatAnnouncements_result -> T.ThriftVal
from_GetSquareChatAnnouncements_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10809 -> (1, ("e",from_SquareException _v10809))) <$> getSquareChatAnnouncements_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10809 -> P.Just (0, ("success",from_GetSquareChatAnnouncementsResponse _v10809))) $ getSquareChatAnnouncements_result_success record
    , (\_v10809 -> (1, ("e",from_SquareException _v10809))) <$> getSquareChatAnnouncements_result_e record
    ]
    )
write_GetSquareChatAnnouncements_result :: T.Protocol p => p -> GetSquareChatAnnouncements_result -> P.IO ()
write_GetSquareChatAnnouncements_result oprot record = T.writeVal oprot $ from_GetSquareChatAnnouncements_result record
encode_GetSquareChatAnnouncements_result :: T.StatelessProtocol p => p -> GetSquareChatAnnouncements_result -> LBS.ByteString
encode_GetSquareChatAnnouncements_result oprot record = T.serializeVal oprot $ from_GetSquareChatAnnouncements_result record
to_GetSquareChatAnnouncements_result :: T.ThriftVal -> GetSquareChatAnnouncements_result
to_GetSquareChatAnnouncements_result (T.TStruct fields) = GetSquareChatAnnouncements_result{
  getSquareChatAnnouncements_result_success = P.maybe (getSquareChatAnnouncements_result_success default_GetSquareChatAnnouncements_result) (\(_,_val10811) -> (case _val10811 of {T.TStruct _val10812 -> (to_GetSquareChatAnnouncementsResponse (T.TStruct _val10812)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareChatAnnouncements_result_e = P.maybe (P.Nothing) (\(_,_val10811) -> P.Just (case _val10811 of {T.TStruct _val10813 -> (to_SquareException (T.TStruct _val10813)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatAnnouncements_result _ = P.error "not a struct"
read_GetSquareChatAnnouncements_result :: T.Protocol p => p -> P.IO GetSquareChatAnnouncements_result
read_GetSquareChatAnnouncements_result iprot = to_GetSquareChatAnnouncements_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncements_result)
decode_GetSquareChatAnnouncements_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatAnnouncements_result
decode_GetSquareChatAnnouncements_result iprot bs = to_GetSquareChatAnnouncements_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatAnnouncements_result) bs
typemap_GetSquareChatAnnouncements_result :: T.TypeMap
typemap_GetSquareChatAnnouncements_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareChatAnnouncementsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareChatAnnouncements_result :: GetSquareChatAnnouncements_result
default_GetSquareChatAnnouncements_result = GetSquareChatAnnouncements_result{
  getSquareChatAnnouncements_result_success = default_GetSquareChatAnnouncementsResponse,
  getSquareChatAnnouncements_result_e = P.Nothing}
data DeleteSquareChatAnnouncement_args = DeleteSquareChatAnnouncement_args  { deleteSquareChatAnnouncement_args_request :: DeleteSquareChatAnnouncementRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatAnnouncement_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChatAnnouncement_args_request record  
instance QC.Arbitrary DeleteSquareChatAnnouncement_args where 
  arbitrary = M.liftM DeleteSquareChatAnnouncement_args (QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChatAnnouncement_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChatAnnouncement_args{deleteSquareChatAnnouncement_args_request = deleteSquareChatAnnouncement_args_request obj} then P.Nothing else P.Just $ default_DeleteSquareChatAnnouncement_args{deleteSquareChatAnnouncement_args_request = deleteSquareChatAnnouncement_args_request obj}
    ]
from_DeleteSquareChatAnnouncement_args :: DeleteSquareChatAnnouncement_args -> T.ThriftVal
from_DeleteSquareChatAnnouncement_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10816 -> P.Just (1, ("request",from_DeleteSquareChatAnnouncementRequest _v10816))) $ deleteSquareChatAnnouncement_args_request record
  ]
write_DeleteSquareChatAnnouncement_args :: T.Protocol p => p -> DeleteSquareChatAnnouncement_args -> P.IO ()
write_DeleteSquareChatAnnouncement_args oprot record = T.writeVal oprot $ from_DeleteSquareChatAnnouncement_args record
encode_DeleteSquareChatAnnouncement_args :: T.StatelessProtocol p => p -> DeleteSquareChatAnnouncement_args -> LBS.ByteString
encode_DeleteSquareChatAnnouncement_args oprot record = T.serializeVal oprot $ from_DeleteSquareChatAnnouncement_args record
to_DeleteSquareChatAnnouncement_args :: T.ThriftVal -> DeleteSquareChatAnnouncement_args
to_DeleteSquareChatAnnouncement_args (T.TStruct fields) = DeleteSquareChatAnnouncement_args{
  deleteSquareChatAnnouncement_args_request = P.maybe (deleteSquareChatAnnouncement_args_request default_DeleteSquareChatAnnouncement_args) (\(_,_val10818) -> (case _val10818 of {T.TStruct _val10819 -> (to_DeleteSquareChatAnnouncementRequest (T.TStruct _val10819)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquareChatAnnouncement_args _ = P.error "not a struct"
read_DeleteSquareChatAnnouncement_args :: T.Protocol p => p -> P.IO DeleteSquareChatAnnouncement_args
read_DeleteSquareChatAnnouncement_args iprot = to_DeleteSquareChatAnnouncement_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncement_args)
decode_DeleteSquareChatAnnouncement_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatAnnouncement_args
decode_DeleteSquareChatAnnouncement_args iprot bs = to_DeleteSquareChatAnnouncement_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncement_args) bs
typemap_DeleteSquareChatAnnouncement_args :: T.TypeMap
typemap_DeleteSquareChatAnnouncement_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_DeleteSquareChatAnnouncementRequest)))]
default_DeleteSquareChatAnnouncement_args :: DeleteSquareChatAnnouncement_args
default_DeleteSquareChatAnnouncement_args = DeleteSquareChatAnnouncement_args{
  deleteSquareChatAnnouncement_args_request = default_DeleteSquareChatAnnouncementRequest}
data DeleteSquareChatAnnouncement_result = DeleteSquareChatAnnouncement_result  { deleteSquareChatAnnouncement_result_success :: DeleteSquareChatAnnouncementResponse
  , deleteSquareChatAnnouncement_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChatAnnouncement_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChatAnnouncement_result_success record   `H.hashWithSalt` deleteSquareChatAnnouncement_result_e record  
instance QC.Arbitrary DeleteSquareChatAnnouncement_result where 
  arbitrary = M.liftM DeleteSquareChatAnnouncement_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChatAnnouncement_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_success = deleteSquareChatAnnouncement_result_success obj} then P.Nothing else P.Just $ default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_success = deleteSquareChatAnnouncement_result_success obj}
    , if obj == default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_e = deleteSquareChatAnnouncement_result_e obj} then P.Nothing else P.Just $ default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_e = deleteSquareChatAnnouncement_result_e obj}
    ]
from_DeleteSquareChatAnnouncement_result :: DeleteSquareChatAnnouncement_result -> T.ThriftVal
from_DeleteSquareChatAnnouncement_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10822 -> (1, ("e",from_SquareException _v10822))) <$> deleteSquareChatAnnouncement_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10822 -> P.Just (0, ("success",from_DeleteSquareChatAnnouncementResponse _v10822))) $ deleteSquareChatAnnouncement_result_success record
    , (\_v10822 -> (1, ("e",from_SquareException _v10822))) <$> deleteSquareChatAnnouncement_result_e record
    ]
    )
write_DeleteSquareChatAnnouncement_result :: T.Protocol p => p -> DeleteSquareChatAnnouncement_result -> P.IO ()
write_DeleteSquareChatAnnouncement_result oprot record = T.writeVal oprot $ from_DeleteSquareChatAnnouncement_result record
encode_DeleteSquareChatAnnouncement_result :: T.StatelessProtocol p => p -> DeleteSquareChatAnnouncement_result -> LBS.ByteString
encode_DeleteSquareChatAnnouncement_result oprot record = T.serializeVal oprot $ from_DeleteSquareChatAnnouncement_result record
to_DeleteSquareChatAnnouncement_result :: T.ThriftVal -> DeleteSquareChatAnnouncement_result
to_DeleteSquareChatAnnouncement_result (T.TStruct fields) = DeleteSquareChatAnnouncement_result{
  deleteSquareChatAnnouncement_result_success = P.maybe (deleteSquareChatAnnouncement_result_success default_DeleteSquareChatAnnouncement_result) (\(_,_val10824) -> (case _val10824 of {T.TStruct _val10825 -> (to_DeleteSquareChatAnnouncementResponse (T.TStruct _val10825)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  deleteSquareChatAnnouncement_result_e = P.maybe (P.Nothing) (\(_,_val10824) -> P.Just (case _val10824 of {T.TStruct _val10826 -> (to_SquareException (T.TStruct _val10826)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquareChatAnnouncement_result _ = P.error "not a struct"
read_DeleteSquareChatAnnouncement_result :: T.Protocol p => p -> P.IO DeleteSquareChatAnnouncement_result
read_DeleteSquareChatAnnouncement_result iprot = to_DeleteSquareChatAnnouncement_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncement_result)
decode_DeleteSquareChatAnnouncement_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChatAnnouncement_result
decode_DeleteSquareChatAnnouncement_result iprot bs = to_DeleteSquareChatAnnouncement_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChatAnnouncement_result) bs
typemap_DeleteSquareChatAnnouncement_result :: T.TypeMap
typemap_DeleteSquareChatAnnouncement_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_DeleteSquareChatAnnouncementResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_DeleteSquareChatAnnouncement_result :: DeleteSquareChatAnnouncement_result
default_DeleteSquareChatAnnouncement_result = DeleteSquareChatAnnouncement_result{
  deleteSquareChatAnnouncement_result_success = default_DeleteSquareChatAnnouncementResponse,
  deleteSquareChatAnnouncement_result_e = P.Nothing}
data CreateSquareChatAnnouncement_args = CreateSquareChatAnnouncement_args  { createSquareChatAnnouncement_args_request :: CreateSquareChatAnnouncementRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatAnnouncement_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatAnnouncement_args_request record  
instance QC.Arbitrary CreateSquareChatAnnouncement_args where 
  arbitrary = M.liftM CreateSquareChatAnnouncement_args (QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatAnnouncement_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatAnnouncement_args{createSquareChatAnnouncement_args_request = createSquareChatAnnouncement_args_request obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncement_args{createSquareChatAnnouncement_args_request = createSquareChatAnnouncement_args_request obj}
    ]
from_CreateSquareChatAnnouncement_args :: CreateSquareChatAnnouncement_args -> T.ThriftVal
from_CreateSquareChatAnnouncement_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10829 -> P.Just (1, ("request",from_CreateSquareChatAnnouncementRequest _v10829))) $ createSquareChatAnnouncement_args_request record
  ]
write_CreateSquareChatAnnouncement_args :: T.Protocol p => p -> CreateSquareChatAnnouncement_args -> P.IO ()
write_CreateSquareChatAnnouncement_args oprot record = T.writeVal oprot $ from_CreateSquareChatAnnouncement_args record
encode_CreateSquareChatAnnouncement_args :: T.StatelessProtocol p => p -> CreateSquareChatAnnouncement_args -> LBS.ByteString
encode_CreateSquareChatAnnouncement_args oprot record = T.serializeVal oprot $ from_CreateSquareChatAnnouncement_args record
to_CreateSquareChatAnnouncement_args :: T.ThriftVal -> CreateSquareChatAnnouncement_args
to_CreateSquareChatAnnouncement_args (T.TStruct fields) = CreateSquareChatAnnouncement_args{
  createSquareChatAnnouncement_args_request = P.maybe (createSquareChatAnnouncement_args_request default_CreateSquareChatAnnouncement_args) (\(_,_val10831) -> (case _val10831 of {T.TStruct _val10832 -> (to_CreateSquareChatAnnouncementRequest (T.TStruct _val10832)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquareChatAnnouncement_args _ = P.error "not a struct"
read_CreateSquareChatAnnouncement_args :: T.Protocol p => p -> P.IO CreateSquareChatAnnouncement_args
read_CreateSquareChatAnnouncement_args iprot = to_CreateSquareChatAnnouncement_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncement_args)
decode_CreateSquareChatAnnouncement_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatAnnouncement_args
decode_CreateSquareChatAnnouncement_args iprot bs = to_CreateSquareChatAnnouncement_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncement_args) bs
typemap_CreateSquareChatAnnouncement_args :: T.TypeMap
typemap_CreateSquareChatAnnouncement_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_CreateSquareChatAnnouncementRequest)))]
default_CreateSquareChatAnnouncement_args :: CreateSquareChatAnnouncement_args
default_CreateSquareChatAnnouncement_args = CreateSquareChatAnnouncement_args{
  createSquareChatAnnouncement_args_request = default_CreateSquareChatAnnouncementRequest}
data CreateSquareChatAnnouncement_result = CreateSquareChatAnnouncement_result  { createSquareChatAnnouncement_result_success :: CreateSquareChatAnnouncementResponse
  , createSquareChatAnnouncement_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChatAnnouncement_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChatAnnouncement_result_success record   `H.hashWithSalt` createSquareChatAnnouncement_result_e record  
instance QC.Arbitrary CreateSquareChatAnnouncement_result where 
  arbitrary = M.liftM CreateSquareChatAnnouncement_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSquareChatAnnouncement_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_success = createSquareChatAnnouncement_result_success obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_success = createSquareChatAnnouncement_result_success obj}
    , if obj == default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_e = createSquareChatAnnouncement_result_e obj} then P.Nothing else P.Just $ default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_e = createSquareChatAnnouncement_result_e obj}
    ]
from_CreateSquareChatAnnouncement_result :: CreateSquareChatAnnouncement_result -> T.ThriftVal
from_CreateSquareChatAnnouncement_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10835 -> (1, ("e",from_SquareException _v10835))) <$> createSquareChatAnnouncement_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10835 -> P.Just (0, ("success",from_CreateSquareChatAnnouncementResponse _v10835))) $ createSquareChatAnnouncement_result_success record
    , (\_v10835 -> (1, ("e",from_SquareException _v10835))) <$> createSquareChatAnnouncement_result_e record
    ]
    )
write_CreateSquareChatAnnouncement_result :: T.Protocol p => p -> CreateSquareChatAnnouncement_result -> P.IO ()
write_CreateSquareChatAnnouncement_result oprot record = T.writeVal oprot $ from_CreateSquareChatAnnouncement_result record
encode_CreateSquareChatAnnouncement_result :: T.StatelessProtocol p => p -> CreateSquareChatAnnouncement_result -> LBS.ByteString
encode_CreateSquareChatAnnouncement_result oprot record = T.serializeVal oprot $ from_CreateSquareChatAnnouncement_result record
to_CreateSquareChatAnnouncement_result :: T.ThriftVal -> CreateSquareChatAnnouncement_result
to_CreateSquareChatAnnouncement_result (T.TStruct fields) = CreateSquareChatAnnouncement_result{
  createSquareChatAnnouncement_result_success = P.maybe (createSquareChatAnnouncement_result_success default_CreateSquareChatAnnouncement_result) (\(_,_val10837) -> (case _val10837 of {T.TStruct _val10838 -> (to_CreateSquareChatAnnouncementResponse (T.TStruct _val10838)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSquareChatAnnouncement_result_e = P.maybe (P.Nothing) (\(_,_val10837) -> P.Just (case _val10837 of {T.TStruct _val10839 -> (to_SquareException (T.TStruct _val10839)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquareChatAnnouncement_result _ = P.error "not a struct"
read_CreateSquareChatAnnouncement_result :: T.Protocol p => p -> P.IO CreateSquareChatAnnouncement_result
read_CreateSquareChatAnnouncement_result iprot = to_CreateSquareChatAnnouncement_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncement_result)
decode_CreateSquareChatAnnouncement_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChatAnnouncement_result
decode_CreateSquareChatAnnouncement_result iprot bs = to_CreateSquareChatAnnouncement_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChatAnnouncement_result) bs
typemap_CreateSquareChatAnnouncement_result :: T.TypeMap
typemap_CreateSquareChatAnnouncement_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CreateSquareChatAnnouncementResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_CreateSquareChatAnnouncement_result :: CreateSquareChatAnnouncement_result
default_CreateSquareChatAnnouncement_result = CreateSquareChatAnnouncement_result{
  createSquareChatAnnouncement_result_success = default_CreateSquareChatAnnouncementResponse,
  createSquareChatAnnouncement_result_e = P.Nothing}
data GetNoteStatus_args = GetNoteStatus_args  { getNoteStatus_args_request :: GetNoteStatusRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteStatus_args_request record  
instance QC.Arbitrary GetNoteStatus_args where 
  arbitrary = M.liftM GetNoteStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetNoteStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteStatus_args{getNoteStatus_args_request = getNoteStatus_args_request obj} then P.Nothing else P.Just $ default_GetNoteStatus_args{getNoteStatus_args_request = getNoteStatus_args_request obj}
    ]
from_GetNoteStatus_args :: GetNoteStatus_args -> T.ThriftVal
from_GetNoteStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10842 -> P.Just (1, ("request",from_GetNoteStatusRequest _v10842))) $ getNoteStatus_args_request record
  ]
write_GetNoteStatus_args :: T.Protocol p => p -> GetNoteStatus_args -> P.IO ()
write_GetNoteStatus_args oprot record = T.writeVal oprot $ from_GetNoteStatus_args record
encode_GetNoteStatus_args :: T.StatelessProtocol p => p -> GetNoteStatus_args -> LBS.ByteString
encode_GetNoteStatus_args oprot record = T.serializeVal oprot $ from_GetNoteStatus_args record
to_GetNoteStatus_args :: T.ThriftVal -> GetNoteStatus_args
to_GetNoteStatus_args (T.TStruct fields) = GetNoteStatus_args{
  getNoteStatus_args_request = P.maybe (getNoteStatus_args_request default_GetNoteStatus_args) (\(_,_val10844) -> (case _val10844 of {T.TStruct _val10845 -> (to_GetNoteStatusRequest (T.TStruct _val10845)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNoteStatus_args _ = P.error "not a struct"
read_GetNoteStatus_args :: T.Protocol p => p -> P.IO GetNoteStatus_args
read_GetNoteStatus_args iprot = to_GetNoteStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteStatus_args)
decode_GetNoteStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteStatus_args
decode_GetNoteStatus_args iprot bs = to_GetNoteStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteStatus_args) bs
typemap_GetNoteStatus_args :: T.TypeMap
typemap_GetNoteStatus_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetNoteStatusRequest)))]
default_GetNoteStatus_args :: GetNoteStatus_args
default_GetNoteStatus_args = GetNoteStatus_args{
  getNoteStatus_args_request = default_GetNoteStatusRequest}
data GetNoteStatus_result = GetNoteStatus_result  { getNoteStatus_result_success :: GetNoteStatusResponse
  , getNoteStatus_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteStatus_result_success record   `H.hashWithSalt` getNoteStatus_result_e record  
instance QC.Arbitrary GetNoteStatus_result where 
  arbitrary = M.liftM GetNoteStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteStatus_result{getNoteStatus_result_success = getNoteStatus_result_success obj} then P.Nothing else P.Just $ default_GetNoteStatus_result{getNoteStatus_result_success = getNoteStatus_result_success obj}
    , if obj == default_GetNoteStatus_result{getNoteStatus_result_e = getNoteStatus_result_e obj} then P.Nothing else P.Just $ default_GetNoteStatus_result{getNoteStatus_result_e = getNoteStatus_result_e obj}
    ]
from_GetNoteStatus_result :: GetNoteStatus_result -> T.ThriftVal
from_GetNoteStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10848 -> (1, ("e",from_SquareException _v10848))) <$> getNoteStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10848 -> P.Just (0, ("success",from_GetNoteStatusResponse _v10848))) $ getNoteStatus_result_success record
    , (\_v10848 -> (1, ("e",from_SquareException _v10848))) <$> getNoteStatus_result_e record
    ]
    )
write_GetNoteStatus_result :: T.Protocol p => p -> GetNoteStatus_result -> P.IO ()
write_GetNoteStatus_result oprot record = T.writeVal oprot $ from_GetNoteStatus_result record
encode_GetNoteStatus_result :: T.StatelessProtocol p => p -> GetNoteStatus_result -> LBS.ByteString
encode_GetNoteStatus_result oprot record = T.serializeVal oprot $ from_GetNoteStatus_result record
to_GetNoteStatus_result :: T.ThriftVal -> GetNoteStatus_result
to_GetNoteStatus_result (T.TStruct fields) = GetNoteStatus_result{
  getNoteStatus_result_success = P.maybe (getNoteStatus_result_success default_GetNoteStatus_result) (\(_,_val10850) -> (case _val10850 of {T.TStruct _val10851 -> (to_GetNoteStatusResponse (T.TStruct _val10851)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteStatus_result_e = P.maybe (P.Nothing) (\(_,_val10850) -> P.Just (case _val10850 of {T.TStruct _val10852 -> (to_SquareException (T.TStruct _val10852)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNoteStatus_result _ = P.error "not a struct"
read_GetNoteStatus_result :: T.Protocol p => p -> P.IO GetNoteStatus_result
read_GetNoteStatus_result iprot = to_GetNoteStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteStatus_result)
decode_GetNoteStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteStatus_result
decode_GetNoteStatus_result iprot bs = to_GetNoteStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteStatus_result) bs
typemap_GetNoteStatus_result :: T.TypeMap
typemap_GetNoteStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetNoteStatusResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetNoteStatus_result :: GetNoteStatus_result
default_GetNoteStatus_result = GetNoteStatus_result{
  getNoteStatus_result_success = default_GetNoteStatusResponse,
  getNoteStatus_result_e = P.Nothing}
data GetSquareStatus_args = GetSquareStatus_args  { getSquareStatus_args_request :: GetSquareStatusRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareStatus_args_request record  
instance QC.Arbitrary GetSquareStatus_args where 
  arbitrary = M.liftM GetSquareStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareStatus_args{getSquareStatus_args_request = getSquareStatus_args_request obj} then P.Nothing else P.Just $ default_GetSquareStatus_args{getSquareStatus_args_request = getSquareStatus_args_request obj}
    ]
from_GetSquareStatus_args :: GetSquareStatus_args -> T.ThriftVal
from_GetSquareStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10855 -> P.Just (1, ("request",from_GetSquareStatusRequest _v10855))) $ getSquareStatus_args_request record
  ]
write_GetSquareStatus_args :: T.Protocol p => p -> GetSquareStatus_args -> P.IO ()
write_GetSquareStatus_args oprot record = T.writeVal oprot $ from_GetSquareStatus_args record
encode_GetSquareStatus_args :: T.StatelessProtocol p => p -> GetSquareStatus_args -> LBS.ByteString
encode_GetSquareStatus_args oprot record = T.serializeVal oprot $ from_GetSquareStatus_args record
to_GetSquareStatus_args :: T.ThriftVal -> GetSquareStatus_args
to_GetSquareStatus_args (T.TStruct fields) = GetSquareStatus_args{
  getSquareStatus_args_request = P.maybe (getSquareStatus_args_request default_GetSquareStatus_args) (\(_,_val10857) -> (case _val10857 of {T.TStruct _val10858 -> (to_GetSquareStatusRequest (T.TStruct _val10858)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareStatus_args _ = P.error "not a struct"
read_GetSquareStatus_args :: T.Protocol p => p -> P.IO GetSquareStatus_args
read_GetSquareStatus_args iprot = to_GetSquareStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareStatus_args)
decode_GetSquareStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareStatus_args
decode_GetSquareStatus_args iprot bs = to_GetSquareStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareStatus_args) bs
typemap_GetSquareStatus_args :: T.TypeMap
typemap_GetSquareStatus_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareStatusRequest)))]
default_GetSquareStatus_args :: GetSquareStatus_args
default_GetSquareStatus_args = GetSquareStatus_args{
  getSquareStatus_args_request = default_GetSquareStatusRequest}
data GetSquareStatus_result = GetSquareStatus_result  { getSquareStatus_result_success :: GetSquareStatusResponse
  , getSquareStatus_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareStatus_result_success record   `H.hashWithSalt` getSquareStatus_result_e record  
instance QC.Arbitrary GetSquareStatus_result where 
  arbitrary = M.liftM GetSquareStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareStatus_result{getSquareStatus_result_success = getSquareStatus_result_success obj} then P.Nothing else P.Just $ default_GetSquareStatus_result{getSquareStatus_result_success = getSquareStatus_result_success obj}
    , if obj == default_GetSquareStatus_result{getSquareStatus_result_e = getSquareStatus_result_e obj} then P.Nothing else P.Just $ default_GetSquareStatus_result{getSquareStatus_result_e = getSquareStatus_result_e obj}
    ]
from_GetSquareStatus_result :: GetSquareStatus_result -> T.ThriftVal
from_GetSquareStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10861 -> (1, ("e",from_SquareException _v10861))) <$> getSquareStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10861 -> P.Just (0, ("success",from_GetSquareStatusResponse _v10861))) $ getSquareStatus_result_success record
    , (\_v10861 -> (1, ("e",from_SquareException _v10861))) <$> getSquareStatus_result_e record
    ]
    )
write_GetSquareStatus_result :: T.Protocol p => p -> GetSquareStatus_result -> P.IO ()
write_GetSquareStatus_result oprot record = T.writeVal oprot $ from_GetSquareStatus_result record
encode_GetSquareStatus_result :: T.StatelessProtocol p => p -> GetSquareStatus_result -> LBS.ByteString
encode_GetSquareStatus_result oprot record = T.serializeVal oprot $ from_GetSquareStatus_result record
to_GetSquareStatus_result :: T.ThriftVal -> GetSquareStatus_result
to_GetSquareStatus_result (T.TStruct fields) = GetSquareStatus_result{
  getSquareStatus_result_success = P.maybe (getSquareStatus_result_success default_GetSquareStatus_result) (\(_,_val10863) -> (case _val10863 of {T.TStruct _val10864 -> (to_GetSquareStatusResponse (T.TStruct _val10864)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareStatus_result_e = P.maybe (P.Nothing) (\(_,_val10863) -> P.Just (case _val10863 of {T.TStruct _val10865 -> (to_SquareException (T.TStruct _val10865)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareStatus_result _ = P.error "not a struct"
read_GetSquareStatus_result :: T.Protocol p => p -> P.IO GetSquareStatus_result
read_GetSquareStatus_result iprot = to_GetSquareStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareStatus_result)
decode_GetSquareStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareStatus_result
decode_GetSquareStatus_result iprot bs = to_GetSquareStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareStatus_result) bs
typemap_GetSquareStatus_result :: T.TypeMap
typemap_GetSquareStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareStatusResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareStatus_result :: GetSquareStatus_result
default_GetSquareStatus_result = GetSquareStatus_result{
  getSquareStatus_result_success = default_GetSquareStatusResponse,
  getSquareStatus_result_e = P.Nothing}
data ReportSquareMember_args = ReportSquareMember_args  { reportSquareMember_args_request :: ReportSquareMemberRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMember_args_request record  
instance QC.Arbitrary ReportSquareMember_args where 
  arbitrary = M.liftM ReportSquareMember_args (QC.arbitrary)
  shrink obj | obj == default_ReportSquareMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMember_args{reportSquareMember_args_request = reportSquareMember_args_request obj} then P.Nothing else P.Just $ default_ReportSquareMember_args{reportSquareMember_args_request = reportSquareMember_args_request obj}
    ]
from_ReportSquareMember_args :: ReportSquareMember_args -> T.ThriftVal
from_ReportSquareMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10868 -> P.Just (1, ("request",from_ReportSquareMemberRequest _v10868))) $ reportSquareMember_args_request record
  ]
write_ReportSquareMember_args :: T.Protocol p => p -> ReportSquareMember_args -> P.IO ()
write_ReportSquareMember_args oprot record = T.writeVal oprot $ from_ReportSquareMember_args record
encode_ReportSquareMember_args :: T.StatelessProtocol p => p -> ReportSquareMember_args -> LBS.ByteString
encode_ReportSquareMember_args oprot record = T.serializeVal oprot $ from_ReportSquareMember_args record
to_ReportSquareMember_args :: T.ThriftVal -> ReportSquareMember_args
to_ReportSquareMember_args (T.TStruct fields) = ReportSquareMember_args{
  reportSquareMember_args_request = P.maybe (reportSquareMember_args_request default_ReportSquareMember_args) (\(_,_val10870) -> (case _val10870 of {T.TStruct _val10871 -> (to_ReportSquareMemberRequest (T.TStruct _val10871)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareMember_args _ = P.error "not a struct"
read_ReportSquareMember_args :: T.Protocol p => p -> P.IO ReportSquareMember_args
read_ReportSquareMember_args iprot = to_ReportSquareMember_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMember_args)
decode_ReportSquareMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMember_args
decode_ReportSquareMember_args iprot bs = to_ReportSquareMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMember_args) bs
typemap_ReportSquareMember_args :: T.TypeMap
typemap_ReportSquareMember_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_ReportSquareMemberRequest)))]
default_ReportSquareMember_args :: ReportSquareMember_args
default_ReportSquareMember_args = ReportSquareMember_args{
  reportSquareMember_args_request = default_ReportSquareMemberRequest}
data ReportSquareMember_result = ReportSquareMember_result  { reportSquareMember_result_success :: ReportSquareMemberResponse
  , reportSquareMember_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMember_result_success record   `H.hashWithSalt` reportSquareMember_result_e record  
instance QC.Arbitrary ReportSquareMember_result where 
  arbitrary = M.liftM ReportSquareMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSquareMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMember_result{reportSquareMember_result_success = reportSquareMember_result_success obj} then P.Nothing else P.Just $ default_ReportSquareMember_result{reportSquareMember_result_success = reportSquareMember_result_success obj}
    , if obj == default_ReportSquareMember_result{reportSquareMember_result_e = reportSquareMember_result_e obj} then P.Nothing else P.Just $ default_ReportSquareMember_result{reportSquareMember_result_e = reportSquareMember_result_e obj}
    ]
from_ReportSquareMember_result :: ReportSquareMember_result -> T.ThriftVal
from_ReportSquareMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10874 -> (1, ("e",from_SquareException _v10874))) <$> reportSquareMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10874 -> P.Just (0, ("success",from_ReportSquareMemberResponse _v10874))) $ reportSquareMember_result_success record
    , (\_v10874 -> (1, ("e",from_SquareException _v10874))) <$> reportSquareMember_result_e record
    ]
    )
write_ReportSquareMember_result :: T.Protocol p => p -> ReportSquareMember_result -> P.IO ()
write_ReportSquareMember_result oprot record = T.writeVal oprot $ from_ReportSquareMember_result record
encode_ReportSquareMember_result :: T.StatelessProtocol p => p -> ReportSquareMember_result -> LBS.ByteString
encode_ReportSquareMember_result oprot record = T.serializeVal oprot $ from_ReportSquareMember_result record
to_ReportSquareMember_result :: T.ThriftVal -> ReportSquareMember_result
to_ReportSquareMember_result (T.TStruct fields) = ReportSquareMember_result{
  reportSquareMember_result_success = P.maybe (reportSquareMember_result_success default_ReportSquareMember_result) (\(_,_val10876) -> (case _val10876 of {T.TStruct _val10877 -> (to_ReportSquareMemberResponse (T.TStruct _val10877)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportSquareMember_result_e = P.maybe (P.Nothing) (\(_,_val10876) -> P.Just (case _val10876 of {T.TStruct _val10878 -> (to_SquareException (T.TStruct _val10878)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareMember_result _ = P.error "not a struct"
read_ReportSquareMember_result :: T.Protocol p => p -> P.IO ReportSquareMember_result
read_ReportSquareMember_result iprot = to_ReportSquareMember_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMember_result)
decode_ReportSquareMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMember_result
decode_ReportSquareMember_result iprot bs = to_ReportSquareMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMember_result) bs
typemap_ReportSquareMember_result :: T.TypeMap
typemap_ReportSquareMember_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ReportSquareMemberResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_ReportSquareMember_result :: ReportSquareMember_result
default_ReportSquareMember_result = ReportSquareMember_result{
  reportSquareMember_result_success = default_ReportSquareMemberResponse,
  reportSquareMember_result_e = P.Nothing}
data ReportSquareMessage_args = ReportSquareMessage_args  { reportSquareMessage_args_request :: ReportSquareMessageRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMessage_args_request record  
instance QC.Arbitrary ReportSquareMessage_args where 
  arbitrary = M.liftM ReportSquareMessage_args (QC.arbitrary)
  shrink obj | obj == default_ReportSquareMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMessage_args{reportSquareMessage_args_request = reportSquareMessage_args_request obj} then P.Nothing else P.Just $ default_ReportSquareMessage_args{reportSquareMessage_args_request = reportSquareMessage_args_request obj}
    ]
from_ReportSquareMessage_args :: ReportSquareMessage_args -> T.ThriftVal
from_ReportSquareMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10881 -> P.Just (1, ("request",from_ReportSquareMessageRequest _v10881))) $ reportSquareMessage_args_request record
  ]
write_ReportSquareMessage_args :: T.Protocol p => p -> ReportSquareMessage_args -> P.IO ()
write_ReportSquareMessage_args oprot record = T.writeVal oprot $ from_ReportSquareMessage_args record
encode_ReportSquareMessage_args :: T.StatelessProtocol p => p -> ReportSquareMessage_args -> LBS.ByteString
encode_ReportSquareMessage_args oprot record = T.serializeVal oprot $ from_ReportSquareMessage_args record
to_ReportSquareMessage_args :: T.ThriftVal -> ReportSquareMessage_args
to_ReportSquareMessage_args (T.TStruct fields) = ReportSquareMessage_args{
  reportSquareMessage_args_request = P.maybe (reportSquareMessage_args_request default_ReportSquareMessage_args) (\(_,_val10883) -> (case _val10883 of {T.TStruct _val10884 -> (to_ReportSquareMessageRequest (T.TStruct _val10884)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareMessage_args _ = P.error "not a struct"
read_ReportSquareMessage_args :: T.Protocol p => p -> P.IO ReportSquareMessage_args
read_ReportSquareMessage_args iprot = to_ReportSquareMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMessage_args)
decode_ReportSquareMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMessage_args
decode_ReportSquareMessage_args iprot bs = to_ReportSquareMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMessage_args) bs
typemap_ReportSquareMessage_args :: T.TypeMap
typemap_ReportSquareMessage_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_ReportSquareMessageRequest)))]
default_ReportSquareMessage_args :: ReportSquareMessage_args
default_ReportSquareMessage_args = ReportSquareMessage_args{
  reportSquareMessage_args_request = default_ReportSquareMessageRequest}
data ReportSquareMessage_result = ReportSquareMessage_result  { reportSquareMessage_result_success :: ReportSquareMessageResponse
  , reportSquareMessage_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareMessage_result_success record   `H.hashWithSalt` reportSquareMessage_result_e record  
instance QC.Arbitrary ReportSquareMessage_result where 
  arbitrary = M.liftM ReportSquareMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSquareMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareMessage_result{reportSquareMessage_result_success = reportSquareMessage_result_success obj} then P.Nothing else P.Just $ default_ReportSquareMessage_result{reportSquareMessage_result_success = reportSquareMessage_result_success obj}
    , if obj == default_ReportSquareMessage_result{reportSquareMessage_result_e = reportSquareMessage_result_e obj} then P.Nothing else P.Just $ default_ReportSquareMessage_result{reportSquareMessage_result_e = reportSquareMessage_result_e obj}
    ]
from_ReportSquareMessage_result :: ReportSquareMessage_result -> T.ThriftVal
from_ReportSquareMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10887 -> (1, ("e",from_SquareException _v10887))) <$> reportSquareMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10887 -> P.Just (0, ("success",from_ReportSquareMessageResponse _v10887))) $ reportSquareMessage_result_success record
    , (\_v10887 -> (1, ("e",from_SquareException _v10887))) <$> reportSquareMessage_result_e record
    ]
    )
write_ReportSquareMessage_result :: T.Protocol p => p -> ReportSquareMessage_result -> P.IO ()
write_ReportSquareMessage_result oprot record = T.writeVal oprot $ from_ReportSquareMessage_result record
encode_ReportSquareMessage_result :: T.StatelessProtocol p => p -> ReportSquareMessage_result -> LBS.ByteString
encode_ReportSquareMessage_result oprot record = T.serializeVal oprot $ from_ReportSquareMessage_result record
to_ReportSquareMessage_result :: T.ThriftVal -> ReportSquareMessage_result
to_ReportSquareMessage_result (T.TStruct fields) = ReportSquareMessage_result{
  reportSquareMessage_result_success = P.maybe (reportSquareMessage_result_success default_ReportSquareMessage_result) (\(_,_val10889) -> (case _val10889 of {T.TStruct _val10890 -> (to_ReportSquareMessageResponse (T.TStruct _val10890)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportSquareMessage_result_e = P.maybe (P.Nothing) (\(_,_val10889) -> P.Just (case _val10889 of {T.TStruct _val10891 -> (to_SquareException (T.TStruct _val10891)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareMessage_result _ = P.error "not a struct"
read_ReportSquareMessage_result :: T.Protocol p => p -> P.IO ReportSquareMessage_result
read_ReportSquareMessage_result iprot = to_ReportSquareMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareMessage_result)
decode_ReportSquareMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareMessage_result
decode_ReportSquareMessage_result iprot bs = to_ReportSquareMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareMessage_result) bs
typemap_ReportSquareMessage_result :: T.TypeMap
typemap_ReportSquareMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ReportSquareMessageResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_ReportSquareMessage_result :: ReportSquareMessage_result
default_ReportSquareMessage_result = ReportSquareMessage_result{
  reportSquareMessage_result_success = default_ReportSquareMessageResponse,
  reportSquareMessage_result_e = P.Nothing}
data ReportSquareChat_args = ReportSquareChat_args  { reportSquareChat_args_request :: ReportSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareChat_args_request record  
instance QC.Arbitrary ReportSquareChat_args where 
  arbitrary = M.liftM ReportSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_ReportSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareChat_args{reportSquareChat_args_request = reportSquareChat_args_request obj} then P.Nothing else P.Just $ default_ReportSquareChat_args{reportSquareChat_args_request = reportSquareChat_args_request obj}
    ]
from_ReportSquareChat_args :: ReportSquareChat_args -> T.ThriftVal
from_ReportSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10894 -> P.Just (1, ("request",from_ReportSquareChatRequest _v10894))) $ reportSquareChat_args_request record
  ]
write_ReportSquareChat_args :: T.Protocol p => p -> ReportSquareChat_args -> P.IO ()
write_ReportSquareChat_args oprot record = T.writeVal oprot $ from_ReportSquareChat_args record
encode_ReportSquareChat_args :: T.StatelessProtocol p => p -> ReportSquareChat_args -> LBS.ByteString
encode_ReportSquareChat_args oprot record = T.serializeVal oprot $ from_ReportSquareChat_args record
to_ReportSquareChat_args :: T.ThriftVal -> ReportSquareChat_args
to_ReportSquareChat_args (T.TStruct fields) = ReportSquareChat_args{
  reportSquareChat_args_request = P.maybe (reportSquareChat_args_request default_ReportSquareChat_args) (\(_,_val10896) -> (case _val10896 of {T.TStruct _val10897 -> (to_ReportSquareChatRequest (T.TStruct _val10897)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareChat_args _ = P.error "not a struct"
read_ReportSquareChat_args :: T.Protocol p => p -> P.IO ReportSquareChat_args
read_ReportSquareChat_args iprot = to_ReportSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareChat_args)
decode_ReportSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareChat_args
decode_ReportSquareChat_args iprot bs = to_ReportSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareChat_args) bs
typemap_ReportSquareChat_args :: T.TypeMap
typemap_ReportSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_ReportSquareChatRequest)))]
default_ReportSquareChat_args :: ReportSquareChat_args
default_ReportSquareChat_args = ReportSquareChat_args{
  reportSquareChat_args_request = default_ReportSquareChatRequest}
data ReportSquareChat_result = ReportSquareChat_result  { reportSquareChat_result_success :: ReportSquareChatResponse
  , reportSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquareChat_result_success record   `H.hashWithSalt` reportSquareChat_result_e record  
instance QC.Arbitrary ReportSquareChat_result where 
  arbitrary = M.liftM ReportSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquareChat_result{reportSquareChat_result_success = reportSquareChat_result_success obj} then P.Nothing else P.Just $ default_ReportSquareChat_result{reportSquareChat_result_success = reportSquareChat_result_success obj}
    , if obj == default_ReportSquareChat_result{reportSquareChat_result_e = reportSquareChat_result_e obj} then P.Nothing else P.Just $ default_ReportSquareChat_result{reportSquareChat_result_e = reportSquareChat_result_e obj}
    ]
from_ReportSquareChat_result :: ReportSquareChat_result -> T.ThriftVal
from_ReportSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10900 -> (1, ("e",from_SquareException _v10900))) <$> reportSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10900 -> P.Just (0, ("success",from_ReportSquareChatResponse _v10900))) $ reportSquareChat_result_success record
    , (\_v10900 -> (1, ("e",from_SquareException _v10900))) <$> reportSquareChat_result_e record
    ]
    )
write_ReportSquareChat_result :: T.Protocol p => p -> ReportSquareChat_result -> P.IO ()
write_ReportSquareChat_result oprot record = T.writeVal oprot $ from_ReportSquareChat_result record
encode_ReportSquareChat_result :: T.StatelessProtocol p => p -> ReportSquareChat_result -> LBS.ByteString
encode_ReportSquareChat_result oprot record = T.serializeVal oprot $ from_ReportSquareChat_result record
to_ReportSquareChat_result :: T.ThriftVal -> ReportSquareChat_result
to_ReportSquareChat_result (T.TStruct fields) = ReportSquareChat_result{
  reportSquareChat_result_success = P.maybe (reportSquareChat_result_success default_ReportSquareChat_result) (\(_,_val10902) -> (case _val10902 of {T.TStruct _val10903 -> (to_ReportSquareChatResponse (T.TStruct _val10903)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val10902) -> P.Just (case _val10902 of {T.TStruct _val10904 -> (to_SquareException (T.TStruct _val10904)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquareChat_result _ = P.error "not a struct"
read_ReportSquareChat_result :: T.Protocol p => p -> P.IO ReportSquareChat_result
read_ReportSquareChat_result iprot = to_ReportSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquareChat_result)
decode_ReportSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquareChat_result
decode_ReportSquareChat_result iprot bs = to_ReportSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquareChat_result) bs
typemap_ReportSquareChat_result :: T.TypeMap
typemap_ReportSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ReportSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_ReportSquareChat_result :: ReportSquareChat_result
default_ReportSquareChat_result = ReportSquareChat_result{
  reportSquareChat_result_success = default_ReportSquareChatResponse,
  reportSquareChat_result_e = P.Nothing}
data ReportSquare_args = ReportSquare_args  { reportSquare_args_request :: ReportSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquare_args_request record  
instance QC.Arbitrary ReportSquare_args where 
  arbitrary = M.liftM ReportSquare_args (QC.arbitrary)
  shrink obj | obj == default_ReportSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquare_args{reportSquare_args_request = reportSquare_args_request obj} then P.Nothing else P.Just $ default_ReportSquare_args{reportSquare_args_request = reportSquare_args_request obj}
    ]
from_ReportSquare_args :: ReportSquare_args -> T.ThriftVal
from_ReportSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10907 -> P.Just (1, ("request",from_ReportSquareRequest _v10907))) $ reportSquare_args_request record
  ]
write_ReportSquare_args :: T.Protocol p => p -> ReportSquare_args -> P.IO ()
write_ReportSquare_args oprot record = T.writeVal oprot $ from_ReportSquare_args record
encode_ReportSquare_args :: T.StatelessProtocol p => p -> ReportSquare_args -> LBS.ByteString
encode_ReportSquare_args oprot record = T.serializeVal oprot $ from_ReportSquare_args record
to_ReportSquare_args :: T.ThriftVal -> ReportSquare_args
to_ReportSquare_args (T.TStruct fields) = ReportSquare_args{
  reportSquare_args_request = P.maybe (reportSquare_args_request default_ReportSquare_args) (\(_,_val10909) -> (case _val10909 of {T.TStruct _val10910 -> (to_ReportSquareRequest (T.TStruct _val10910)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquare_args _ = P.error "not a struct"
read_ReportSquare_args :: T.Protocol p => p -> P.IO ReportSquare_args
read_ReportSquare_args iprot = to_ReportSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquare_args)
decode_ReportSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquare_args
decode_ReportSquare_args iprot bs = to_ReportSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquare_args) bs
typemap_ReportSquare_args :: T.TypeMap
typemap_ReportSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_ReportSquareRequest)))]
default_ReportSquare_args :: ReportSquare_args
default_ReportSquare_args = ReportSquare_args{
  reportSquare_args_request = default_ReportSquareRequest}
data ReportSquare_result = ReportSquare_result  { reportSquare_result_success :: ReportSquareResponse
  , reportSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSquare_result_success record   `H.hashWithSalt` reportSquare_result_e record  
instance QC.Arbitrary ReportSquare_result where 
  arbitrary = M.liftM ReportSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSquare_result{reportSquare_result_success = reportSquare_result_success obj} then P.Nothing else P.Just $ default_ReportSquare_result{reportSquare_result_success = reportSquare_result_success obj}
    , if obj == default_ReportSquare_result{reportSquare_result_e = reportSquare_result_e obj} then P.Nothing else P.Just $ default_ReportSquare_result{reportSquare_result_e = reportSquare_result_e obj}
    ]
from_ReportSquare_result :: ReportSquare_result -> T.ThriftVal
from_ReportSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10913 -> (1, ("e",from_SquareException _v10913))) <$> reportSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10913 -> P.Just (0, ("success",from_ReportSquareResponse _v10913))) $ reportSquare_result_success record
    , (\_v10913 -> (1, ("e",from_SquareException _v10913))) <$> reportSquare_result_e record
    ]
    )
write_ReportSquare_result :: T.Protocol p => p -> ReportSquare_result -> P.IO ()
write_ReportSquare_result oprot record = T.writeVal oprot $ from_ReportSquare_result record
encode_ReportSquare_result :: T.StatelessProtocol p => p -> ReportSquare_result -> LBS.ByteString
encode_ReportSquare_result oprot record = T.serializeVal oprot $ from_ReportSquare_result record
to_ReportSquare_result :: T.ThriftVal -> ReportSquare_result
to_ReportSquare_result (T.TStruct fields) = ReportSquare_result{
  reportSquare_result_success = P.maybe (reportSquare_result_success default_ReportSquare_result) (\(_,_val10915) -> (case _val10915 of {T.TStruct _val10916 -> (to_ReportSquareResponse (T.TStruct _val10916)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportSquare_result_e = P.maybe (P.Nothing) (\(_,_val10915) -> P.Just (case _val10915 of {T.TStruct _val10917 -> (to_SquareException (T.TStruct _val10917)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSquare_result _ = P.error "not a struct"
read_ReportSquare_result :: T.Protocol p => p -> P.IO ReportSquare_result
read_ReportSquare_result iprot = to_ReportSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSquare_result)
decode_ReportSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSquare_result
decode_ReportSquare_result iprot bs = to_ReportSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSquare_result) bs
typemap_ReportSquare_result :: T.TypeMap
typemap_ReportSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ReportSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_ReportSquare_result :: ReportSquare_result
default_ReportSquare_result = ReportSquare_result{
  reportSquare_result_success = default_ReportSquareResponse,
  reportSquare_result_e = P.Nothing}
data UpdateSquareMemberRelation_args = UpdateSquareMemberRelation_args  { updateSquareMemberRelation_args_request :: UpdateSquareMemberRelationRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberRelation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberRelation_args_request record  
instance QC.Arbitrary UpdateSquareMemberRelation_args where 
  arbitrary = M.liftM UpdateSquareMemberRelation_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberRelation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberRelation_args{updateSquareMemberRelation_args_request = updateSquareMemberRelation_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelation_args{updateSquareMemberRelation_args_request = updateSquareMemberRelation_args_request obj}
    ]
from_UpdateSquareMemberRelation_args :: UpdateSquareMemberRelation_args -> T.ThriftVal
from_UpdateSquareMemberRelation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10920 -> P.Just (1, ("request",from_UpdateSquareMemberRelationRequest _v10920))) $ updateSquareMemberRelation_args_request record
  ]
write_UpdateSquareMemberRelation_args :: T.Protocol p => p -> UpdateSquareMemberRelation_args -> P.IO ()
write_UpdateSquareMemberRelation_args oprot record = T.writeVal oprot $ from_UpdateSquareMemberRelation_args record
encode_UpdateSquareMemberRelation_args :: T.StatelessProtocol p => p -> UpdateSquareMemberRelation_args -> LBS.ByteString
encode_UpdateSquareMemberRelation_args oprot record = T.serializeVal oprot $ from_UpdateSquareMemberRelation_args record
to_UpdateSquareMemberRelation_args :: T.ThriftVal -> UpdateSquareMemberRelation_args
to_UpdateSquareMemberRelation_args (T.TStruct fields) = UpdateSquareMemberRelation_args{
  updateSquareMemberRelation_args_request = P.maybe (updateSquareMemberRelation_args_request default_UpdateSquareMemberRelation_args) (\(_,_val10922) -> (case _val10922 of {T.TStruct _val10923 -> (to_UpdateSquareMemberRelationRequest (T.TStruct _val10923)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMemberRelation_args _ = P.error "not a struct"
read_UpdateSquareMemberRelation_args :: T.Protocol p => p -> P.IO UpdateSquareMemberRelation_args
read_UpdateSquareMemberRelation_args iprot = to_UpdateSquareMemberRelation_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelation_args)
decode_UpdateSquareMemberRelation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberRelation_args
decode_UpdateSquareMemberRelation_args iprot bs = to_UpdateSquareMemberRelation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelation_args) bs
typemap_UpdateSquareMemberRelation_args :: T.TypeMap
typemap_UpdateSquareMemberRelation_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareMemberRelationRequest)))]
default_UpdateSquareMemberRelation_args :: UpdateSquareMemberRelation_args
default_UpdateSquareMemberRelation_args = UpdateSquareMemberRelation_args{
  updateSquareMemberRelation_args_request = default_UpdateSquareMemberRelationRequest}
data UpdateSquareMemberRelation_result = UpdateSquareMemberRelation_result  { updateSquareMemberRelation_result_success :: UpdateSquareMemberRelationResponse
  , updateSquareMemberRelation_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMemberRelation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMemberRelation_result_success record   `H.hashWithSalt` updateSquareMemberRelation_result_e record  
instance QC.Arbitrary UpdateSquareMemberRelation_result where 
  arbitrary = M.liftM UpdateSquareMemberRelation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMemberRelation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_success = updateSquareMemberRelation_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_success = updateSquareMemberRelation_result_success obj}
    , if obj == default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_e = updateSquareMemberRelation_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_e = updateSquareMemberRelation_result_e obj}
    ]
from_UpdateSquareMemberRelation_result :: UpdateSquareMemberRelation_result -> T.ThriftVal
from_UpdateSquareMemberRelation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10926 -> (1, ("e",from_SquareException _v10926))) <$> updateSquareMemberRelation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10926 -> P.Just (0, ("success",from_UpdateSquareMemberRelationResponse _v10926))) $ updateSquareMemberRelation_result_success record
    , (\_v10926 -> (1, ("e",from_SquareException _v10926))) <$> updateSquareMemberRelation_result_e record
    ]
    )
write_UpdateSquareMemberRelation_result :: T.Protocol p => p -> UpdateSquareMemberRelation_result -> P.IO ()
write_UpdateSquareMemberRelation_result oprot record = T.writeVal oprot $ from_UpdateSquareMemberRelation_result record
encode_UpdateSquareMemberRelation_result :: T.StatelessProtocol p => p -> UpdateSquareMemberRelation_result -> LBS.ByteString
encode_UpdateSquareMemberRelation_result oprot record = T.serializeVal oprot $ from_UpdateSquareMemberRelation_result record
to_UpdateSquareMemberRelation_result :: T.ThriftVal -> UpdateSquareMemberRelation_result
to_UpdateSquareMemberRelation_result (T.TStruct fields) = UpdateSquareMemberRelation_result{
  updateSquareMemberRelation_result_success = P.maybe (updateSquareMemberRelation_result_success default_UpdateSquareMemberRelation_result) (\(_,_val10928) -> (case _val10928 of {T.TStruct _val10929 -> (to_UpdateSquareMemberRelationResponse (T.TStruct _val10929)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareMemberRelation_result_e = P.maybe (P.Nothing) (\(_,_val10928) -> P.Just (case _val10928 of {T.TStruct _val10930 -> (to_SquareException (T.TStruct _val10930)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMemberRelation_result _ = P.error "not a struct"
read_UpdateSquareMemberRelation_result :: T.Protocol p => p -> P.IO UpdateSquareMemberRelation_result
read_UpdateSquareMemberRelation_result iprot = to_UpdateSquareMemberRelation_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelation_result)
decode_UpdateSquareMemberRelation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMemberRelation_result
decode_UpdateSquareMemberRelation_result iprot bs = to_UpdateSquareMemberRelation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMemberRelation_result) bs
typemap_UpdateSquareMemberRelation_result :: T.TypeMap
typemap_UpdateSquareMemberRelation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareMemberRelationResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareMemberRelation_result :: UpdateSquareMemberRelation_result
default_UpdateSquareMemberRelation_result = UpdateSquareMemberRelation_result{
  updateSquareMemberRelation_result_success = default_UpdateSquareMemberRelationResponse,
  updateSquareMemberRelation_result_e = P.Nothing}
data UpdateSquareAuthority_args = UpdateSquareAuthority_args  { updateSquareAuthority_args_request :: UpdateSquareAuthorityRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareAuthority_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareAuthority_args_request record  
instance QC.Arbitrary UpdateSquareAuthority_args where 
  arbitrary = M.liftM UpdateSquareAuthority_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareAuthority_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareAuthority_args{updateSquareAuthority_args_request = updateSquareAuthority_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareAuthority_args{updateSquareAuthority_args_request = updateSquareAuthority_args_request obj}
    ]
from_UpdateSquareAuthority_args :: UpdateSquareAuthority_args -> T.ThriftVal
from_UpdateSquareAuthority_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10933 -> P.Just (1, ("request",from_UpdateSquareAuthorityRequest _v10933))) $ updateSquareAuthority_args_request record
  ]
write_UpdateSquareAuthority_args :: T.Protocol p => p -> UpdateSquareAuthority_args -> P.IO ()
write_UpdateSquareAuthority_args oprot record = T.writeVal oprot $ from_UpdateSquareAuthority_args record
encode_UpdateSquareAuthority_args :: T.StatelessProtocol p => p -> UpdateSquareAuthority_args -> LBS.ByteString
encode_UpdateSquareAuthority_args oprot record = T.serializeVal oprot $ from_UpdateSquareAuthority_args record
to_UpdateSquareAuthority_args :: T.ThriftVal -> UpdateSquareAuthority_args
to_UpdateSquareAuthority_args (T.TStruct fields) = UpdateSquareAuthority_args{
  updateSquareAuthority_args_request = P.maybe (updateSquareAuthority_args_request default_UpdateSquareAuthority_args) (\(_,_val10935) -> (case _val10935 of {T.TStruct _val10936 -> (to_UpdateSquareAuthorityRequest (T.TStruct _val10936)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareAuthority_args _ = P.error "not a struct"
read_UpdateSquareAuthority_args :: T.Protocol p => p -> P.IO UpdateSquareAuthority_args
read_UpdateSquareAuthority_args iprot = to_UpdateSquareAuthority_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareAuthority_args)
decode_UpdateSquareAuthority_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareAuthority_args
decode_UpdateSquareAuthority_args iprot bs = to_UpdateSquareAuthority_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareAuthority_args) bs
typemap_UpdateSquareAuthority_args :: T.TypeMap
typemap_UpdateSquareAuthority_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareAuthorityRequest)))]
default_UpdateSquareAuthority_args :: UpdateSquareAuthority_args
default_UpdateSquareAuthority_args = UpdateSquareAuthority_args{
  updateSquareAuthority_args_request = default_UpdateSquareAuthorityRequest}
data UpdateSquareAuthority_result = UpdateSquareAuthority_result  { updateSquareAuthority_result_success :: UpdateSquareAuthorityResponse
  , updateSquareAuthority_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareAuthority_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareAuthority_result_success record   `H.hashWithSalt` updateSquareAuthority_result_e record  
instance QC.Arbitrary UpdateSquareAuthority_result where 
  arbitrary = M.liftM UpdateSquareAuthority_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareAuthority_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareAuthority_result{updateSquareAuthority_result_success = updateSquareAuthority_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareAuthority_result{updateSquareAuthority_result_success = updateSquareAuthority_result_success obj}
    , if obj == default_UpdateSquareAuthority_result{updateSquareAuthority_result_e = updateSquareAuthority_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareAuthority_result{updateSquareAuthority_result_e = updateSquareAuthority_result_e obj}
    ]
from_UpdateSquareAuthority_result :: UpdateSquareAuthority_result -> T.ThriftVal
from_UpdateSquareAuthority_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10939 -> (1, ("e",from_SquareException _v10939))) <$> updateSquareAuthority_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10939 -> P.Just (0, ("success",from_UpdateSquareAuthorityResponse _v10939))) $ updateSquareAuthority_result_success record
    , (\_v10939 -> (1, ("e",from_SquareException _v10939))) <$> updateSquareAuthority_result_e record
    ]
    )
write_UpdateSquareAuthority_result :: T.Protocol p => p -> UpdateSquareAuthority_result -> P.IO ()
write_UpdateSquareAuthority_result oprot record = T.writeVal oprot $ from_UpdateSquareAuthority_result record
encode_UpdateSquareAuthority_result :: T.StatelessProtocol p => p -> UpdateSquareAuthority_result -> LBS.ByteString
encode_UpdateSquareAuthority_result oprot record = T.serializeVal oprot $ from_UpdateSquareAuthority_result record
to_UpdateSquareAuthority_result :: T.ThriftVal -> UpdateSquareAuthority_result
to_UpdateSquareAuthority_result (T.TStruct fields) = UpdateSquareAuthority_result{
  updateSquareAuthority_result_success = P.maybe (updateSquareAuthority_result_success default_UpdateSquareAuthority_result) (\(_,_val10941) -> (case _val10941 of {T.TStruct _val10942 -> (to_UpdateSquareAuthorityResponse (T.TStruct _val10942)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareAuthority_result_e = P.maybe (P.Nothing) (\(_,_val10941) -> P.Just (case _val10941 of {T.TStruct _val10943 -> (to_SquareException (T.TStruct _val10943)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareAuthority_result _ = P.error "not a struct"
read_UpdateSquareAuthority_result :: T.Protocol p => p -> P.IO UpdateSquareAuthority_result
read_UpdateSquareAuthority_result iprot = to_UpdateSquareAuthority_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareAuthority_result)
decode_UpdateSquareAuthority_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareAuthority_result
decode_UpdateSquareAuthority_result iprot bs = to_UpdateSquareAuthority_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareAuthority_result) bs
typemap_UpdateSquareAuthority_result :: T.TypeMap
typemap_UpdateSquareAuthority_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareAuthorityResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareAuthority_result :: UpdateSquareAuthority_result
default_UpdateSquareAuthority_result = UpdateSquareAuthority_result{
  updateSquareAuthority_result_success = default_UpdateSquareAuthorityResponse,
  updateSquareAuthority_result_e = P.Nothing}
data UpdateSquareChatMember_args = UpdateSquareChatMember_args  { updateSquareChatMember_args_request :: UpdateSquareChatMemberRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatMember_args_request record  
instance QC.Arbitrary UpdateSquareChatMember_args where 
  arbitrary = M.liftM UpdateSquareChatMember_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatMember_args{updateSquareChatMember_args_request = updateSquareChatMember_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareChatMember_args{updateSquareChatMember_args_request = updateSquareChatMember_args_request obj}
    ]
from_UpdateSquareChatMember_args :: UpdateSquareChatMember_args -> T.ThriftVal
from_UpdateSquareChatMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10946 -> P.Just (1, ("request",from_UpdateSquareChatMemberRequest _v10946))) $ updateSquareChatMember_args_request record
  ]
write_UpdateSquareChatMember_args :: T.Protocol p => p -> UpdateSquareChatMember_args -> P.IO ()
write_UpdateSquareChatMember_args oprot record = T.writeVal oprot $ from_UpdateSquareChatMember_args record
encode_UpdateSquareChatMember_args :: T.StatelessProtocol p => p -> UpdateSquareChatMember_args -> LBS.ByteString
encode_UpdateSquareChatMember_args oprot record = T.serializeVal oprot $ from_UpdateSquareChatMember_args record
to_UpdateSquareChatMember_args :: T.ThriftVal -> UpdateSquareChatMember_args
to_UpdateSquareChatMember_args (T.TStruct fields) = UpdateSquareChatMember_args{
  updateSquareChatMember_args_request = P.maybe (updateSquareChatMember_args_request default_UpdateSquareChatMember_args) (\(_,_val10948) -> (case _val10948 of {T.TStruct _val10949 -> (to_UpdateSquareChatMemberRequest (T.TStruct _val10949)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareChatMember_args _ = P.error "not a struct"
read_UpdateSquareChatMember_args :: T.Protocol p => p -> P.IO UpdateSquareChatMember_args
read_UpdateSquareChatMember_args iprot = to_UpdateSquareChatMember_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatMember_args)
decode_UpdateSquareChatMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatMember_args
decode_UpdateSquareChatMember_args iprot bs = to_UpdateSquareChatMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatMember_args) bs
typemap_UpdateSquareChatMember_args :: T.TypeMap
typemap_UpdateSquareChatMember_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareChatMemberRequest)))]
default_UpdateSquareChatMember_args :: UpdateSquareChatMember_args
default_UpdateSquareChatMember_args = UpdateSquareChatMember_args{
  updateSquareChatMember_args_request = default_UpdateSquareChatMemberRequest}
data UpdateSquareChatMember_result = UpdateSquareChatMember_result  { updateSquareChatMember_result_success :: UpdateSquareChatMemberResponse
  , updateSquareChatMember_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChatMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChatMember_result_success record   `H.hashWithSalt` updateSquareChatMember_result_e record  
instance QC.Arbitrary UpdateSquareChatMember_result where 
  arbitrary = M.liftM UpdateSquareChatMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChatMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChatMember_result{updateSquareChatMember_result_success = updateSquareChatMember_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareChatMember_result{updateSquareChatMember_result_success = updateSquareChatMember_result_success obj}
    , if obj == default_UpdateSquareChatMember_result{updateSquareChatMember_result_e = updateSquareChatMember_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareChatMember_result{updateSquareChatMember_result_e = updateSquareChatMember_result_e obj}
    ]
from_UpdateSquareChatMember_result :: UpdateSquareChatMember_result -> T.ThriftVal
from_UpdateSquareChatMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10952 -> (1, ("e",from_SquareException _v10952))) <$> updateSquareChatMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10952 -> P.Just (0, ("success",from_UpdateSquareChatMemberResponse _v10952))) $ updateSquareChatMember_result_success record
    , (\_v10952 -> (1, ("e",from_SquareException _v10952))) <$> updateSquareChatMember_result_e record
    ]
    )
write_UpdateSquareChatMember_result :: T.Protocol p => p -> UpdateSquareChatMember_result -> P.IO ()
write_UpdateSquareChatMember_result oprot record = T.writeVal oprot $ from_UpdateSquareChatMember_result record
encode_UpdateSquareChatMember_result :: T.StatelessProtocol p => p -> UpdateSquareChatMember_result -> LBS.ByteString
encode_UpdateSquareChatMember_result oprot record = T.serializeVal oprot $ from_UpdateSquareChatMember_result record
to_UpdateSquareChatMember_result :: T.ThriftVal -> UpdateSquareChatMember_result
to_UpdateSquareChatMember_result (T.TStruct fields) = UpdateSquareChatMember_result{
  updateSquareChatMember_result_success = P.maybe (updateSquareChatMember_result_success default_UpdateSquareChatMember_result) (\(_,_val10954) -> (case _val10954 of {T.TStruct _val10955 -> (to_UpdateSquareChatMemberResponse (T.TStruct _val10955)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareChatMember_result_e = P.maybe (P.Nothing) (\(_,_val10954) -> P.Just (case _val10954 of {T.TStruct _val10956 -> (to_SquareException (T.TStruct _val10956)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareChatMember_result _ = P.error "not a struct"
read_UpdateSquareChatMember_result :: T.Protocol p => p -> P.IO UpdateSquareChatMember_result
read_UpdateSquareChatMember_result iprot = to_UpdateSquareChatMember_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChatMember_result)
decode_UpdateSquareChatMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChatMember_result
decode_UpdateSquareChatMember_result iprot bs = to_UpdateSquareChatMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChatMember_result) bs
typemap_UpdateSquareChatMember_result :: T.TypeMap
typemap_UpdateSquareChatMember_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareChatMemberResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareChatMember_result :: UpdateSquareChatMember_result
default_UpdateSquareChatMember_result = UpdateSquareChatMember_result{
  updateSquareChatMember_result_success = default_UpdateSquareChatMemberResponse,
  updateSquareChatMember_result_e = P.Nothing}
data UpdateSquareChat_args = UpdateSquareChat_args  { updateSquareChat_args_request :: UpdateSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChat_args_request record  
instance QC.Arbitrary UpdateSquareChat_args where 
  arbitrary = M.liftM UpdateSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChat_args{updateSquareChat_args_request = updateSquareChat_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareChat_args{updateSquareChat_args_request = updateSquareChat_args_request obj}
    ]
from_UpdateSquareChat_args :: UpdateSquareChat_args -> T.ThriftVal
from_UpdateSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10959 -> P.Just (1, ("request",from_UpdateSquareChatRequest _v10959))) $ updateSquareChat_args_request record
  ]
write_UpdateSquareChat_args :: T.Protocol p => p -> UpdateSquareChat_args -> P.IO ()
write_UpdateSquareChat_args oprot record = T.writeVal oprot $ from_UpdateSquareChat_args record
encode_UpdateSquareChat_args :: T.StatelessProtocol p => p -> UpdateSquareChat_args -> LBS.ByteString
encode_UpdateSquareChat_args oprot record = T.serializeVal oprot $ from_UpdateSquareChat_args record
to_UpdateSquareChat_args :: T.ThriftVal -> UpdateSquareChat_args
to_UpdateSquareChat_args (T.TStruct fields) = UpdateSquareChat_args{
  updateSquareChat_args_request = P.maybe (updateSquareChat_args_request default_UpdateSquareChat_args) (\(_,_val10961) -> (case _val10961 of {T.TStruct _val10962 -> (to_UpdateSquareChatRequest (T.TStruct _val10962)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareChat_args _ = P.error "not a struct"
read_UpdateSquareChat_args :: T.Protocol p => p -> P.IO UpdateSquareChat_args
read_UpdateSquareChat_args iprot = to_UpdateSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChat_args)
decode_UpdateSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChat_args
decode_UpdateSquareChat_args iprot bs = to_UpdateSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChat_args) bs
typemap_UpdateSquareChat_args :: T.TypeMap
typemap_UpdateSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareChatRequest)))]
default_UpdateSquareChat_args :: UpdateSquareChat_args
default_UpdateSquareChat_args = UpdateSquareChat_args{
  updateSquareChat_args_request = default_UpdateSquareChatRequest}
data UpdateSquareChat_result = UpdateSquareChat_result  { updateSquareChat_result_success :: UpdateSquareChatResponse
  , updateSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareChat_result_success record   `H.hashWithSalt` updateSquareChat_result_e record  
instance QC.Arbitrary UpdateSquareChat_result where 
  arbitrary = M.liftM UpdateSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareChat_result{updateSquareChat_result_success = updateSquareChat_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareChat_result{updateSquareChat_result_success = updateSquareChat_result_success obj}
    , if obj == default_UpdateSquareChat_result{updateSquareChat_result_e = updateSquareChat_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareChat_result{updateSquareChat_result_e = updateSquareChat_result_e obj}
    ]
from_UpdateSquareChat_result :: UpdateSquareChat_result -> T.ThriftVal
from_UpdateSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10965 -> (1, ("e",from_SquareException _v10965))) <$> updateSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10965 -> P.Just (0, ("success",from_UpdateSquareChatResponse _v10965))) $ updateSquareChat_result_success record
    , (\_v10965 -> (1, ("e",from_SquareException _v10965))) <$> updateSquareChat_result_e record
    ]
    )
write_UpdateSquareChat_result :: T.Protocol p => p -> UpdateSquareChat_result -> P.IO ()
write_UpdateSquareChat_result oprot record = T.writeVal oprot $ from_UpdateSquareChat_result record
encode_UpdateSquareChat_result :: T.StatelessProtocol p => p -> UpdateSquareChat_result -> LBS.ByteString
encode_UpdateSquareChat_result oprot record = T.serializeVal oprot $ from_UpdateSquareChat_result record
to_UpdateSquareChat_result :: T.ThriftVal -> UpdateSquareChat_result
to_UpdateSquareChat_result (T.TStruct fields) = UpdateSquareChat_result{
  updateSquareChat_result_success = P.maybe (updateSquareChat_result_success default_UpdateSquareChat_result) (\(_,_val10967) -> (case _val10967 of {T.TStruct _val10968 -> (to_UpdateSquareChatResponse (T.TStruct _val10968)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val10967) -> P.Just (case _val10967 of {T.TStruct _val10969 -> (to_SquareException (T.TStruct _val10969)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareChat_result _ = P.error "not a struct"
read_UpdateSquareChat_result :: T.Protocol p => p -> P.IO UpdateSquareChat_result
read_UpdateSquareChat_result iprot = to_UpdateSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareChat_result)
decode_UpdateSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareChat_result
decode_UpdateSquareChat_result iprot bs = to_UpdateSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareChat_result) bs
typemap_UpdateSquareChat_result :: T.TypeMap
typemap_UpdateSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareChat_result :: UpdateSquareChat_result
default_UpdateSquareChat_result = UpdateSquareChat_result{
  updateSquareChat_result_success = default_UpdateSquareChatResponse,
  updateSquareChat_result_e = P.Nothing}
data RefreshSubscriptions_args = RefreshSubscriptions_args  { refreshSubscriptions_args_request :: RefreshSubscriptionsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RefreshSubscriptions_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` refreshSubscriptions_args_request record  
instance QC.Arbitrary RefreshSubscriptions_args where 
  arbitrary = M.liftM RefreshSubscriptions_args (QC.arbitrary)
  shrink obj | obj == default_RefreshSubscriptions_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RefreshSubscriptions_args{refreshSubscriptions_args_request = refreshSubscriptions_args_request obj} then P.Nothing else P.Just $ default_RefreshSubscriptions_args{refreshSubscriptions_args_request = refreshSubscriptions_args_request obj}
    ]
from_RefreshSubscriptions_args :: RefreshSubscriptions_args -> T.ThriftVal
from_RefreshSubscriptions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10972 -> P.Just (1, ("request",from_RefreshSubscriptionsRequest _v10972))) $ refreshSubscriptions_args_request record
  ]
write_RefreshSubscriptions_args :: T.Protocol p => p -> RefreshSubscriptions_args -> P.IO ()
write_RefreshSubscriptions_args oprot record = T.writeVal oprot $ from_RefreshSubscriptions_args record
encode_RefreshSubscriptions_args :: T.StatelessProtocol p => p -> RefreshSubscriptions_args -> LBS.ByteString
encode_RefreshSubscriptions_args oprot record = T.serializeVal oprot $ from_RefreshSubscriptions_args record
to_RefreshSubscriptions_args :: T.ThriftVal -> RefreshSubscriptions_args
to_RefreshSubscriptions_args (T.TStruct fields) = RefreshSubscriptions_args{
  refreshSubscriptions_args_request = P.maybe (refreshSubscriptions_args_request default_RefreshSubscriptions_args) (\(_,_val10974) -> (case _val10974 of {T.TStruct _val10975 -> (to_RefreshSubscriptionsRequest (T.TStruct _val10975)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RefreshSubscriptions_args _ = P.error "not a struct"
read_RefreshSubscriptions_args :: T.Protocol p => p -> P.IO RefreshSubscriptions_args
read_RefreshSubscriptions_args iprot = to_RefreshSubscriptions_args <$> T.readVal iprot (T.T_STRUCT typemap_RefreshSubscriptions_args)
decode_RefreshSubscriptions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RefreshSubscriptions_args
decode_RefreshSubscriptions_args iprot bs = to_RefreshSubscriptions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RefreshSubscriptions_args) bs
typemap_RefreshSubscriptions_args :: T.TypeMap
typemap_RefreshSubscriptions_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_RefreshSubscriptionsRequest)))]
default_RefreshSubscriptions_args :: RefreshSubscriptions_args
default_RefreshSubscriptions_args = RefreshSubscriptions_args{
  refreshSubscriptions_args_request = default_RefreshSubscriptionsRequest}
data RefreshSubscriptions_result = RefreshSubscriptions_result  { refreshSubscriptions_result_success :: RefreshSubscriptionsResponse
  , refreshSubscriptions_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RefreshSubscriptions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` refreshSubscriptions_result_success record   `H.hashWithSalt` refreshSubscriptions_result_e record  
instance QC.Arbitrary RefreshSubscriptions_result where 
  arbitrary = M.liftM RefreshSubscriptions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RefreshSubscriptions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RefreshSubscriptions_result{refreshSubscriptions_result_success = refreshSubscriptions_result_success obj} then P.Nothing else P.Just $ default_RefreshSubscriptions_result{refreshSubscriptions_result_success = refreshSubscriptions_result_success obj}
    , if obj == default_RefreshSubscriptions_result{refreshSubscriptions_result_e = refreshSubscriptions_result_e obj} then P.Nothing else P.Just $ default_RefreshSubscriptions_result{refreshSubscriptions_result_e = refreshSubscriptions_result_e obj}
    ]
from_RefreshSubscriptions_result :: RefreshSubscriptions_result -> T.ThriftVal
from_RefreshSubscriptions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10978 -> (1, ("e",from_SquareException _v10978))) <$> refreshSubscriptions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10978 -> P.Just (0, ("success",from_RefreshSubscriptionsResponse _v10978))) $ refreshSubscriptions_result_success record
    , (\_v10978 -> (1, ("e",from_SquareException _v10978))) <$> refreshSubscriptions_result_e record
    ]
    )
write_RefreshSubscriptions_result :: T.Protocol p => p -> RefreshSubscriptions_result -> P.IO ()
write_RefreshSubscriptions_result oprot record = T.writeVal oprot $ from_RefreshSubscriptions_result record
encode_RefreshSubscriptions_result :: T.StatelessProtocol p => p -> RefreshSubscriptions_result -> LBS.ByteString
encode_RefreshSubscriptions_result oprot record = T.serializeVal oprot $ from_RefreshSubscriptions_result record
to_RefreshSubscriptions_result :: T.ThriftVal -> RefreshSubscriptions_result
to_RefreshSubscriptions_result (T.TStruct fields) = RefreshSubscriptions_result{
  refreshSubscriptions_result_success = P.maybe (refreshSubscriptions_result_success default_RefreshSubscriptions_result) (\(_,_val10980) -> (case _val10980 of {T.TStruct _val10981 -> (to_RefreshSubscriptionsResponse (T.TStruct _val10981)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  refreshSubscriptions_result_e = P.maybe (P.Nothing) (\(_,_val10980) -> P.Just (case _val10980 of {T.TStruct _val10982 -> (to_SquareException (T.TStruct _val10982)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RefreshSubscriptions_result _ = P.error "not a struct"
read_RefreshSubscriptions_result :: T.Protocol p => p -> P.IO RefreshSubscriptions_result
read_RefreshSubscriptions_result iprot = to_RefreshSubscriptions_result <$> T.readVal iprot (T.T_STRUCT typemap_RefreshSubscriptions_result)
decode_RefreshSubscriptions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RefreshSubscriptions_result
decode_RefreshSubscriptions_result iprot bs = to_RefreshSubscriptions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RefreshSubscriptions_result) bs
typemap_RefreshSubscriptions_result :: T.TypeMap
typemap_RefreshSubscriptions_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RefreshSubscriptionsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_RefreshSubscriptions_result :: RefreshSubscriptions_result
default_RefreshSubscriptions_result = RefreshSubscriptions_result{
  refreshSubscriptions_result_success = default_RefreshSubscriptionsResponse,
  refreshSubscriptions_result_e = P.Nothing}
data RemoveSubscriptions_args = RemoveSubscriptions_args  { removeSubscriptions_args_request :: RemoveSubscriptionsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSubscriptions_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSubscriptions_args_request record  
instance QC.Arbitrary RemoveSubscriptions_args where 
  arbitrary = M.liftM RemoveSubscriptions_args (QC.arbitrary)
  shrink obj | obj == default_RemoveSubscriptions_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSubscriptions_args{removeSubscriptions_args_request = removeSubscriptions_args_request obj} then P.Nothing else P.Just $ default_RemoveSubscriptions_args{removeSubscriptions_args_request = removeSubscriptions_args_request obj}
    ]
from_RemoveSubscriptions_args :: RemoveSubscriptions_args -> T.ThriftVal
from_RemoveSubscriptions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10985 -> P.Just (1, ("request",from_RemoveSubscriptionsRequest _v10985))) $ removeSubscriptions_args_request record
  ]
write_RemoveSubscriptions_args :: T.Protocol p => p -> RemoveSubscriptions_args -> P.IO ()
write_RemoveSubscriptions_args oprot record = T.writeVal oprot $ from_RemoveSubscriptions_args record
encode_RemoveSubscriptions_args :: T.StatelessProtocol p => p -> RemoveSubscriptions_args -> LBS.ByteString
encode_RemoveSubscriptions_args oprot record = T.serializeVal oprot $ from_RemoveSubscriptions_args record
to_RemoveSubscriptions_args :: T.ThriftVal -> RemoveSubscriptions_args
to_RemoveSubscriptions_args (T.TStruct fields) = RemoveSubscriptions_args{
  removeSubscriptions_args_request = P.maybe (removeSubscriptions_args_request default_RemoveSubscriptions_args) (\(_,_val10987) -> (case _val10987 of {T.TStruct _val10988 -> (to_RemoveSubscriptionsRequest (T.TStruct _val10988)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSubscriptions_args _ = P.error "not a struct"
read_RemoveSubscriptions_args :: T.Protocol p => p -> P.IO RemoveSubscriptions_args
read_RemoveSubscriptions_args iprot = to_RemoveSubscriptions_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSubscriptions_args)
decode_RemoveSubscriptions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSubscriptions_args
decode_RemoveSubscriptions_args iprot bs = to_RemoveSubscriptions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSubscriptions_args) bs
typemap_RemoveSubscriptions_args :: T.TypeMap
typemap_RemoveSubscriptions_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_RemoveSubscriptionsRequest)))]
default_RemoveSubscriptions_args :: RemoveSubscriptions_args
default_RemoveSubscriptions_args = RemoveSubscriptions_args{
  removeSubscriptions_args_request = default_RemoveSubscriptionsRequest}
data RemoveSubscriptions_result = RemoveSubscriptions_result  { removeSubscriptions_result_success :: RemoveSubscriptionsResponse
  , removeSubscriptions_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSubscriptions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSubscriptions_result_success record   `H.hashWithSalt` removeSubscriptions_result_e record  
instance QC.Arbitrary RemoveSubscriptions_result where 
  arbitrary = M.liftM RemoveSubscriptions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveSubscriptions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSubscriptions_result{removeSubscriptions_result_success = removeSubscriptions_result_success obj} then P.Nothing else P.Just $ default_RemoveSubscriptions_result{removeSubscriptions_result_success = removeSubscriptions_result_success obj}
    , if obj == default_RemoveSubscriptions_result{removeSubscriptions_result_e = removeSubscriptions_result_e obj} then P.Nothing else P.Just $ default_RemoveSubscriptions_result{removeSubscriptions_result_e = removeSubscriptions_result_e obj}
    ]
from_RemoveSubscriptions_result :: RemoveSubscriptions_result -> T.ThriftVal
from_RemoveSubscriptions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10991 -> (1, ("e",from_SquareException _v10991))) <$> removeSubscriptions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10991 -> P.Just (0, ("success",from_RemoveSubscriptionsResponse _v10991))) $ removeSubscriptions_result_success record
    , (\_v10991 -> (1, ("e",from_SquareException _v10991))) <$> removeSubscriptions_result_e record
    ]
    )
write_RemoveSubscriptions_result :: T.Protocol p => p -> RemoveSubscriptions_result -> P.IO ()
write_RemoveSubscriptions_result oprot record = T.writeVal oprot $ from_RemoveSubscriptions_result record
encode_RemoveSubscriptions_result :: T.StatelessProtocol p => p -> RemoveSubscriptions_result -> LBS.ByteString
encode_RemoveSubscriptions_result oprot record = T.serializeVal oprot $ from_RemoveSubscriptions_result record
to_RemoveSubscriptions_result :: T.ThriftVal -> RemoveSubscriptions_result
to_RemoveSubscriptions_result (T.TStruct fields) = RemoveSubscriptions_result{
  removeSubscriptions_result_success = P.maybe (removeSubscriptions_result_success default_RemoveSubscriptions_result) (\(_,_val10993) -> (case _val10993 of {T.TStruct _val10994 -> (to_RemoveSubscriptionsResponse (T.TStruct _val10994)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeSubscriptions_result_e = P.maybe (P.Nothing) (\(_,_val10993) -> P.Just (case _val10993 of {T.TStruct _val10995 -> (to_SquareException (T.TStruct _val10995)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSubscriptions_result _ = P.error "not a struct"
read_RemoveSubscriptions_result :: T.Protocol p => p -> P.IO RemoveSubscriptions_result
read_RemoveSubscriptions_result iprot = to_RemoveSubscriptions_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSubscriptions_result)
decode_RemoveSubscriptions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSubscriptions_result
decode_RemoveSubscriptions_result iprot bs = to_RemoveSubscriptions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSubscriptions_result) bs
typemap_RemoveSubscriptions_result :: T.TypeMap
typemap_RemoveSubscriptions_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RemoveSubscriptionsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_RemoveSubscriptions_result :: RemoveSubscriptions_result
default_RemoveSubscriptions_result = RemoveSubscriptions_result{
  removeSubscriptions_result_success = default_RemoveSubscriptionsResponse,
  removeSubscriptions_result_e = P.Nothing}
data RejectSquareMembers_args = RejectSquareMembers_args  { rejectSquareMembers_args_request :: RejectSquareMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectSquareMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectSquareMembers_args_request record  
instance QC.Arbitrary RejectSquareMembers_args where 
  arbitrary = M.liftM RejectSquareMembers_args (QC.arbitrary)
  shrink obj | obj == default_RejectSquareMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectSquareMembers_args{rejectSquareMembers_args_request = rejectSquareMembers_args_request obj} then P.Nothing else P.Just $ default_RejectSquareMembers_args{rejectSquareMembers_args_request = rejectSquareMembers_args_request obj}
    ]
from_RejectSquareMembers_args :: RejectSquareMembers_args -> T.ThriftVal
from_RejectSquareMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10998 -> P.Just (1, ("request",from_RejectSquareMembersRequest _v10998))) $ rejectSquareMembers_args_request record
  ]
write_RejectSquareMembers_args :: T.Protocol p => p -> RejectSquareMembers_args -> P.IO ()
write_RejectSquareMembers_args oprot record = T.writeVal oprot $ from_RejectSquareMembers_args record
encode_RejectSquareMembers_args :: T.StatelessProtocol p => p -> RejectSquareMembers_args -> LBS.ByteString
encode_RejectSquareMembers_args oprot record = T.serializeVal oprot $ from_RejectSquareMembers_args record
to_RejectSquareMembers_args :: T.ThriftVal -> RejectSquareMembers_args
to_RejectSquareMembers_args (T.TStruct fields) = RejectSquareMembers_args{
  rejectSquareMembers_args_request = P.maybe (rejectSquareMembers_args_request default_RejectSquareMembers_args) (\(_,_val11000) -> (case _val11000 of {T.TStruct _val11001 -> (to_RejectSquareMembersRequest (T.TStruct _val11001)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RejectSquareMembers_args _ = P.error "not a struct"
read_RejectSquareMembers_args :: T.Protocol p => p -> P.IO RejectSquareMembers_args
read_RejectSquareMembers_args iprot = to_RejectSquareMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_RejectSquareMembers_args)
decode_RejectSquareMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectSquareMembers_args
decode_RejectSquareMembers_args iprot bs = to_RejectSquareMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectSquareMembers_args) bs
typemap_RejectSquareMembers_args :: T.TypeMap
typemap_RejectSquareMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_RejectSquareMembersRequest)))]
default_RejectSquareMembers_args :: RejectSquareMembers_args
default_RejectSquareMembers_args = RejectSquareMembers_args{
  rejectSquareMembers_args_request = default_RejectSquareMembersRequest}
data RejectSquareMembers_result = RejectSquareMembers_result  { rejectSquareMembers_result_success :: RejectSquareMembersResponse
  , rejectSquareMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectSquareMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectSquareMembers_result_success record   `H.hashWithSalt` rejectSquareMembers_result_e record  
instance QC.Arbitrary RejectSquareMembers_result where 
  arbitrary = M.liftM RejectSquareMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RejectSquareMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectSquareMembers_result{rejectSquareMembers_result_success = rejectSquareMembers_result_success obj} then P.Nothing else P.Just $ default_RejectSquareMembers_result{rejectSquareMembers_result_success = rejectSquareMembers_result_success obj}
    , if obj == default_RejectSquareMembers_result{rejectSquareMembers_result_e = rejectSquareMembers_result_e obj} then P.Nothing else P.Just $ default_RejectSquareMembers_result{rejectSquareMembers_result_e = rejectSquareMembers_result_e obj}
    ]
from_RejectSquareMembers_result :: RejectSquareMembers_result -> T.ThriftVal
from_RejectSquareMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11004 -> (1, ("e",from_SquareException _v11004))) <$> rejectSquareMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11004 -> P.Just (0, ("success",from_RejectSquareMembersResponse _v11004))) $ rejectSquareMembers_result_success record
    , (\_v11004 -> (1, ("e",from_SquareException _v11004))) <$> rejectSquareMembers_result_e record
    ]
    )
write_RejectSquareMembers_result :: T.Protocol p => p -> RejectSquareMembers_result -> P.IO ()
write_RejectSquareMembers_result oprot record = T.writeVal oprot $ from_RejectSquareMembers_result record
encode_RejectSquareMembers_result :: T.StatelessProtocol p => p -> RejectSquareMembers_result -> LBS.ByteString
encode_RejectSquareMembers_result oprot record = T.serializeVal oprot $ from_RejectSquareMembers_result record
to_RejectSquareMembers_result :: T.ThriftVal -> RejectSquareMembers_result
to_RejectSquareMembers_result (T.TStruct fields) = RejectSquareMembers_result{
  rejectSquareMembers_result_success = P.maybe (rejectSquareMembers_result_success default_RejectSquareMembers_result) (\(_,_val11006) -> (case _val11006 of {T.TStruct _val11007 -> (to_RejectSquareMembersResponse (T.TStruct _val11007)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  rejectSquareMembers_result_e = P.maybe (P.Nothing) (\(_,_val11006) -> P.Just (case _val11006 of {T.TStruct _val11008 -> (to_SquareException (T.TStruct _val11008)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RejectSquareMembers_result _ = P.error "not a struct"
read_RejectSquareMembers_result :: T.Protocol p => p -> P.IO RejectSquareMembers_result
read_RejectSquareMembers_result iprot = to_RejectSquareMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_RejectSquareMembers_result)
decode_RejectSquareMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectSquareMembers_result
decode_RejectSquareMembers_result iprot bs = to_RejectSquareMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectSquareMembers_result) bs
typemap_RejectSquareMembers_result :: T.TypeMap
typemap_RejectSquareMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RejectSquareMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_RejectSquareMembers_result :: RejectSquareMembers_result
default_RejectSquareMembers_result = RejectSquareMembers_result{
  rejectSquareMembers_result_success = default_RejectSquareMembersResponse,
  rejectSquareMembers_result_e = P.Nothing}
data UpdateSquareMembers_args = UpdateSquareMembers_args  { updateSquareMembers_args_request :: UpdateSquareMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMembers_args_request record  
instance QC.Arbitrary UpdateSquareMembers_args where 
  arbitrary = M.liftM UpdateSquareMembers_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMembers_args{updateSquareMembers_args_request = updateSquareMembers_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareMembers_args{updateSquareMembers_args_request = updateSquareMembers_args_request obj}
    ]
from_UpdateSquareMembers_args :: UpdateSquareMembers_args -> T.ThriftVal
from_UpdateSquareMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11011 -> P.Just (1, ("request",from_UpdateSquareMembersRequest _v11011))) $ updateSquareMembers_args_request record
  ]
write_UpdateSquareMembers_args :: T.Protocol p => p -> UpdateSquareMembers_args -> P.IO ()
write_UpdateSquareMembers_args oprot record = T.writeVal oprot $ from_UpdateSquareMembers_args record
encode_UpdateSquareMembers_args :: T.StatelessProtocol p => p -> UpdateSquareMembers_args -> LBS.ByteString
encode_UpdateSquareMembers_args oprot record = T.serializeVal oprot $ from_UpdateSquareMembers_args record
to_UpdateSquareMembers_args :: T.ThriftVal -> UpdateSquareMembers_args
to_UpdateSquareMembers_args (T.TStruct fields) = UpdateSquareMembers_args{
  updateSquareMembers_args_request = P.maybe (updateSquareMembers_args_request default_UpdateSquareMembers_args) (\(_,_val11013) -> (case _val11013 of {T.TStruct _val11014 -> (to_UpdateSquareMembersRequest (T.TStruct _val11014)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMembers_args _ = P.error "not a struct"
read_UpdateSquareMembers_args :: T.Protocol p => p -> P.IO UpdateSquareMembers_args
read_UpdateSquareMembers_args iprot = to_UpdateSquareMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMembers_args)
decode_UpdateSquareMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMembers_args
decode_UpdateSquareMembers_args iprot bs = to_UpdateSquareMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMembers_args) bs
typemap_UpdateSquareMembers_args :: T.TypeMap
typemap_UpdateSquareMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareMembersRequest)))]
default_UpdateSquareMembers_args :: UpdateSquareMembers_args
default_UpdateSquareMembers_args = UpdateSquareMembers_args{
  updateSquareMembers_args_request = default_UpdateSquareMembersRequest}
data UpdateSquareMembers_result = UpdateSquareMembers_result  { updateSquareMembers_result_success :: UpdateSquareMembersResponse
  , updateSquareMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMembers_result_success record   `H.hashWithSalt` updateSquareMembers_result_e record  
instance QC.Arbitrary UpdateSquareMembers_result where 
  arbitrary = M.liftM UpdateSquareMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMembers_result{updateSquareMembers_result_success = updateSquareMembers_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareMembers_result{updateSquareMembers_result_success = updateSquareMembers_result_success obj}
    , if obj == default_UpdateSquareMembers_result{updateSquareMembers_result_e = updateSquareMembers_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareMembers_result{updateSquareMembers_result_e = updateSquareMembers_result_e obj}
    ]
from_UpdateSquareMembers_result :: UpdateSquareMembers_result -> T.ThriftVal
from_UpdateSquareMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11017 -> (1, ("e",from_SquareException _v11017))) <$> updateSquareMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11017 -> P.Just (0, ("success",from_UpdateSquareMembersResponse _v11017))) $ updateSquareMembers_result_success record
    , (\_v11017 -> (1, ("e",from_SquareException _v11017))) <$> updateSquareMembers_result_e record
    ]
    )
write_UpdateSquareMembers_result :: T.Protocol p => p -> UpdateSquareMembers_result -> P.IO ()
write_UpdateSquareMembers_result oprot record = T.writeVal oprot $ from_UpdateSquareMembers_result record
encode_UpdateSquareMembers_result :: T.StatelessProtocol p => p -> UpdateSquareMembers_result -> LBS.ByteString
encode_UpdateSquareMembers_result oprot record = T.serializeVal oprot $ from_UpdateSquareMembers_result record
to_UpdateSquareMembers_result :: T.ThriftVal -> UpdateSquareMembers_result
to_UpdateSquareMembers_result (T.TStruct fields) = UpdateSquareMembers_result{
  updateSquareMembers_result_success = P.maybe (updateSquareMembers_result_success default_UpdateSquareMembers_result) (\(_,_val11019) -> (case _val11019 of {T.TStruct _val11020 -> (to_UpdateSquareMembersResponse (T.TStruct _val11020)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareMembers_result_e = P.maybe (P.Nothing) (\(_,_val11019) -> P.Just (case _val11019 of {T.TStruct _val11021 -> (to_SquareException (T.TStruct _val11021)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMembers_result _ = P.error "not a struct"
read_UpdateSquareMembers_result :: T.Protocol p => p -> P.IO UpdateSquareMembers_result
read_UpdateSquareMembers_result iprot = to_UpdateSquareMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMembers_result)
decode_UpdateSquareMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMembers_result
decode_UpdateSquareMembers_result iprot bs = to_UpdateSquareMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMembers_result) bs
typemap_UpdateSquareMembers_result :: T.TypeMap
typemap_UpdateSquareMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareMembers_result :: UpdateSquareMembers_result
default_UpdateSquareMembers_result = UpdateSquareMembers_result{
  updateSquareMembers_result_success = default_UpdateSquareMembersResponse,
  updateSquareMembers_result_e = P.Nothing}
data UpdateSquareMember_args = UpdateSquareMember_args  { updateSquareMember_args_request :: UpdateSquareMemberRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMember_args_request record  
instance QC.Arbitrary UpdateSquareMember_args where 
  arbitrary = M.liftM UpdateSquareMember_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMember_args{updateSquareMember_args_request = updateSquareMember_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareMember_args{updateSquareMember_args_request = updateSquareMember_args_request obj}
    ]
from_UpdateSquareMember_args :: UpdateSquareMember_args -> T.ThriftVal
from_UpdateSquareMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11024 -> P.Just (1, ("request",from_UpdateSquareMemberRequest _v11024))) $ updateSquareMember_args_request record
  ]
write_UpdateSquareMember_args :: T.Protocol p => p -> UpdateSquareMember_args -> P.IO ()
write_UpdateSquareMember_args oprot record = T.writeVal oprot $ from_UpdateSquareMember_args record
encode_UpdateSquareMember_args :: T.StatelessProtocol p => p -> UpdateSquareMember_args -> LBS.ByteString
encode_UpdateSquareMember_args oprot record = T.serializeVal oprot $ from_UpdateSquareMember_args record
to_UpdateSquareMember_args :: T.ThriftVal -> UpdateSquareMember_args
to_UpdateSquareMember_args (T.TStruct fields) = UpdateSquareMember_args{
  updateSquareMember_args_request = P.maybe (updateSquareMember_args_request default_UpdateSquareMember_args) (\(_,_val11026) -> (case _val11026 of {T.TStruct _val11027 -> (to_UpdateSquareMemberRequest (T.TStruct _val11027)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMember_args _ = P.error "not a struct"
read_UpdateSquareMember_args :: T.Protocol p => p -> P.IO UpdateSquareMember_args
read_UpdateSquareMember_args iprot = to_UpdateSquareMember_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMember_args)
decode_UpdateSquareMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMember_args
decode_UpdateSquareMember_args iprot bs = to_UpdateSquareMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMember_args) bs
typemap_UpdateSquareMember_args :: T.TypeMap
typemap_UpdateSquareMember_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareMemberRequest)))]
default_UpdateSquareMember_args :: UpdateSquareMember_args
default_UpdateSquareMember_args = UpdateSquareMember_args{
  updateSquareMember_args_request = default_UpdateSquareMemberRequest}
data UpdateSquareMember_result = UpdateSquareMember_result  { updateSquareMember_result_success :: UpdateSquareMemberResponse
  , updateSquareMember_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareMember_result_success record   `H.hashWithSalt` updateSquareMember_result_e record  
instance QC.Arbitrary UpdateSquareMember_result where 
  arbitrary = M.liftM UpdateSquareMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareMember_result{updateSquareMember_result_success = updateSquareMember_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareMember_result{updateSquareMember_result_success = updateSquareMember_result_success obj}
    , if obj == default_UpdateSquareMember_result{updateSquareMember_result_e = updateSquareMember_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareMember_result{updateSquareMember_result_e = updateSquareMember_result_e obj}
    ]
from_UpdateSquareMember_result :: UpdateSquareMember_result -> T.ThriftVal
from_UpdateSquareMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11030 -> (1, ("e",from_SquareException _v11030))) <$> updateSquareMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11030 -> P.Just (0, ("success",from_UpdateSquareMemberResponse _v11030))) $ updateSquareMember_result_success record
    , (\_v11030 -> (1, ("e",from_SquareException _v11030))) <$> updateSquareMember_result_e record
    ]
    )
write_UpdateSquareMember_result :: T.Protocol p => p -> UpdateSquareMember_result -> P.IO ()
write_UpdateSquareMember_result oprot record = T.writeVal oprot $ from_UpdateSquareMember_result record
encode_UpdateSquareMember_result :: T.StatelessProtocol p => p -> UpdateSquareMember_result -> LBS.ByteString
encode_UpdateSquareMember_result oprot record = T.serializeVal oprot $ from_UpdateSquareMember_result record
to_UpdateSquareMember_result :: T.ThriftVal -> UpdateSquareMember_result
to_UpdateSquareMember_result (T.TStruct fields) = UpdateSquareMember_result{
  updateSquareMember_result_success = P.maybe (updateSquareMember_result_success default_UpdateSquareMember_result) (\(_,_val11032) -> (case _val11032 of {T.TStruct _val11033 -> (to_UpdateSquareMemberResponse (T.TStruct _val11033)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareMember_result_e = P.maybe (P.Nothing) (\(_,_val11032) -> P.Just (case _val11032 of {T.TStruct _val11034 -> (to_SquareException (T.TStruct _val11034)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareMember_result _ = P.error "not a struct"
read_UpdateSquareMember_result :: T.Protocol p => p -> P.IO UpdateSquareMember_result
read_UpdateSquareMember_result iprot = to_UpdateSquareMember_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareMember_result)
decode_UpdateSquareMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareMember_result
decode_UpdateSquareMember_result iprot bs = to_UpdateSquareMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareMember_result) bs
typemap_UpdateSquareMember_result :: T.TypeMap
typemap_UpdateSquareMember_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareMemberResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareMember_result :: UpdateSquareMember_result
default_UpdateSquareMember_result = UpdateSquareMember_result{
  updateSquareMember_result_success = default_UpdateSquareMemberResponse,
  updateSquareMember_result_e = P.Nothing}
data UpdateSquareFeatureSet_args = UpdateSquareFeatureSet_args  { updateSquareFeatureSet_args_request :: UpdateSquareFeatureSetRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareFeatureSet_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareFeatureSet_args_request record  
instance QC.Arbitrary UpdateSquareFeatureSet_args where 
  arbitrary = M.liftM UpdateSquareFeatureSet_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquareFeatureSet_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareFeatureSet_args{updateSquareFeatureSet_args_request = updateSquareFeatureSet_args_request obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSet_args{updateSquareFeatureSet_args_request = updateSquareFeatureSet_args_request obj}
    ]
from_UpdateSquareFeatureSet_args :: UpdateSquareFeatureSet_args -> T.ThriftVal
from_UpdateSquareFeatureSet_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11037 -> P.Just (1, ("request",from_UpdateSquareFeatureSetRequest _v11037))) $ updateSquareFeatureSet_args_request record
  ]
write_UpdateSquareFeatureSet_args :: T.Protocol p => p -> UpdateSquareFeatureSet_args -> P.IO ()
write_UpdateSquareFeatureSet_args oprot record = T.writeVal oprot $ from_UpdateSquareFeatureSet_args record
encode_UpdateSquareFeatureSet_args :: T.StatelessProtocol p => p -> UpdateSquareFeatureSet_args -> LBS.ByteString
encode_UpdateSquareFeatureSet_args oprot record = T.serializeVal oprot $ from_UpdateSquareFeatureSet_args record
to_UpdateSquareFeatureSet_args :: T.ThriftVal -> UpdateSquareFeatureSet_args
to_UpdateSquareFeatureSet_args (T.TStruct fields) = UpdateSquareFeatureSet_args{
  updateSquareFeatureSet_args_request = P.maybe (updateSquareFeatureSet_args_request default_UpdateSquareFeatureSet_args) (\(_,_val11039) -> (case _val11039 of {T.TStruct _val11040 -> (to_UpdateSquareFeatureSetRequest (T.TStruct _val11040)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareFeatureSet_args _ = P.error "not a struct"
read_UpdateSquareFeatureSet_args :: T.Protocol p => p -> P.IO UpdateSquareFeatureSet_args
read_UpdateSquareFeatureSet_args iprot = to_UpdateSquareFeatureSet_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSet_args)
decode_UpdateSquareFeatureSet_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareFeatureSet_args
decode_UpdateSquareFeatureSet_args iprot bs = to_UpdateSquareFeatureSet_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSet_args) bs
typemap_UpdateSquareFeatureSet_args :: T.TypeMap
typemap_UpdateSquareFeatureSet_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareFeatureSetRequest)))]
default_UpdateSquareFeatureSet_args :: UpdateSquareFeatureSet_args
default_UpdateSquareFeatureSet_args = UpdateSquareFeatureSet_args{
  updateSquareFeatureSet_args_request = default_UpdateSquareFeatureSetRequest}
data UpdateSquareFeatureSet_result = UpdateSquareFeatureSet_result  { updateSquareFeatureSet_result_success :: UpdateSquareFeatureSetResponse
  , updateSquareFeatureSet_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquareFeatureSet_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquareFeatureSet_result_success record   `H.hashWithSalt` updateSquareFeatureSet_result_e record  
instance QC.Arbitrary UpdateSquareFeatureSet_result where 
  arbitrary = M.liftM UpdateSquareFeatureSet_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquareFeatureSet_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_success = updateSquareFeatureSet_result_success obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_success = updateSquareFeatureSet_result_success obj}
    , if obj == default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_e = updateSquareFeatureSet_result_e obj} then P.Nothing else P.Just $ default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_e = updateSquareFeatureSet_result_e obj}
    ]
from_UpdateSquareFeatureSet_result :: UpdateSquareFeatureSet_result -> T.ThriftVal
from_UpdateSquareFeatureSet_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11043 -> (1, ("e",from_SquareException _v11043))) <$> updateSquareFeatureSet_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11043 -> P.Just (0, ("success",from_UpdateSquareFeatureSetResponse _v11043))) $ updateSquareFeatureSet_result_success record
    , (\_v11043 -> (1, ("e",from_SquareException _v11043))) <$> updateSquareFeatureSet_result_e record
    ]
    )
write_UpdateSquareFeatureSet_result :: T.Protocol p => p -> UpdateSquareFeatureSet_result -> P.IO ()
write_UpdateSquareFeatureSet_result oprot record = T.writeVal oprot $ from_UpdateSquareFeatureSet_result record
encode_UpdateSquareFeatureSet_result :: T.StatelessProtocol p => p -> UpdateSquareFeatureSet_result -> LBS.ByteString
encode_UpdateSquareFeatureSet_result oprot record = T.serializeVal oprot $ from_UpdateSquareFeatureSet_result record
to_UpdateSquareFeatureSet_result :: T.ThriftVal -> UpdateSquareFeatureSet_result
to_UpdateSquareFeatureSet_result (T.TStruct fields) = UpdateSquareFeatureSet_result{
  updateSquareFeatureSet_result_success = P.maybe (updateSquareFeatureSet_result_success default_UpdateSquareFeatureSet_result) (\(_,_val11045) -> (case _val11045 of {T.TStruct _val11046 -> (to_UpdateSquareFeatureSetResponse (T.TStruct _val11046)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquareFeatureSet_result_e = P.maybe (P.Nothing) (\(_,_val11045) -> P.Just (case _val11045 of {T.TStruct _val11047 -> (to_SquareException (T.TStruct _val11047)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquareFeatureSet_result _ = P.error "not a struct"
read_UpdateSquareFeatureSet_result :: T.Protocol p => p -> P.IO UpdateSquareFeatureSet_result
read_UpdateSquareFeatureSet_result iprot = to_UpdateSquareFeatureSet_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSet_result)
decode_UpdateSquareFeatureSet_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquareFeatureSet_result
decode_UpdateSquareFeatureSet_result iprot bs = to_UpdateSquareFeatureSet_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquareFeatureSet_result) bs
typemap_UpdateSquareFeatureSet_result :: T.TypeMap
typemap_UpdateSquareFeatureSet_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareFeatureSetResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquareFeatureSet_result :: UpdateSquareFeatureSet_result
default_UpdateSquareFeatureSet_result = UpdateSquareFeatureSet_result{
  updateSquareFeatureSet_result_success = default_UpdateSquareFeatureSetResponse,
  updateSquareFeatureSet_result_e = P.Nothing}
data GetSquareFeatureSet_args = GetSquareFeatureSet_args  { getSquareFeatureSet_args_request :: GetSquareFeatureSetRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareFeatureSet_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareFeatureSet_args_request record  
instance QC.Arbitrary GetSquareFeatureSet_args where 
  arbitrary = M.liftM GetSquareFeatureSet_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareFeatureSet_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareFeatureSet_args{getSquareFeatureSet_args_request = getSquareFeatureSet_args_request obj} then P.Nothing else P.Just $ default_GetSquareFeatureSet_args{getSquareFeatureSet_args_request = getSquareFeatureSet_args_request obj}
    ]
from_GetSquareFeatureSet_args :: GetSquareFeatureSet_args -> T.ThriftVal
from_GetSquareFeatureSet_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11050 -> P.Just (1, ("request",from_GetSquareFeatureSetRequest _v11050))) $ getSquareFeatureSet_args_request record
  ]
write_GetSquareFeatureSet_args :: T.Protocol p => p -> GetSquareFeatureSet_args -> P.IO ()
write_GetSquareFeatureSet_args oprot record = T.writeVal oprot $ from_GetSquareFeatureSet_args record
encode_GetSquareFeatureSet_args :: T.StatelessProtocol p => p -> GetSquareFeatureSet_args -> LBS.ByteString
encode_GetSquareFeatureSet_args oprot record = T.serializeVal oprot $ from_GetSquareFeatureSet_args record
to_GetSquareFeatureSet_args :: T.ThriftVal -> GetSquareFeatureSet_args
to_GetSquareFeatureSet_args (T.TStruct fields) = GetSquareFeatureSet_args{
  getSquareFeatureSet_args_request = P.maybe (getSquareFeatureSet_args_request default_GetSquareFeatureSet_args) (\(_,_val11052) -> (case _val11052 of {T.TStruct _val11053 -> (to_GetSquareFeatureSetRequest (T.TStruct _val11053)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareFeatureSet_args _ = P.error "not a struct"
read_GetSquareFeatureSet_args :: T.Protocol p => p -> P.IO GetSquareFeatureSet_args
read_GetSquareFeatureSet_args iprot = to_GetSquareFeatureSet_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareFeatureSet_args)
decode_GetSquareFeatureSet_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareFeatureSet_args
decode_GetSquareFeatureSet_args iprot bs = to_GetSquareFeatureSet_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareFeatureSet_args) bs
typemap_GetSquareFeatureSet_args :: T.TypeMap
typemap_GetSquareFeatureSet_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareFeatureSetRequest)))]
default_GetSquareFeatureSet_args :: GetSquareFeatureSet_args
default_GetSquareFeatureSet_args = GetSquareFeatureSet_args{
  getSquareFeatureSet_args_request = default_GetSquareFeatureSetRequest}
data GetSquareFeatureSet_result = GetSquareFeatureSet_result  { getSquareFeatureSet_result_success :: GetSquareFeatureSetResponse
  , getSquareFeatureSet_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareFeatureSet_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareFeatureSet_result_success record   `H.hashWithSalt` getSquareFeatureSet_result_e record  
instance QC.Arbitrary GetSquareFeatureSet_result where 
  arbitrary = M.liftM GetSquareFeatureSet_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareFeatureSet_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareFeatureSet_result{getSquareFeatureSet_result_success = getSquareFeatureSet_result_success obj} then P.Nothing else P.Just $ default_GetSquareFeatureSet_result{getSquareFeatureSet_result_success = getSquareFeatureSet_result_success obj}
    , if obj == default_GetSquareFeatureSet_result{getSquareFeatureSet_result_e = getSquareFeatureSet_result_e obj} then P.Nothing else P.Just $ default_GetSquareFeatureSet_result{getSquareFeatureSet_result_e = getSquareFeatureSet_result_e obj}
    ]
from_GetSquareFeatureSet_result :: GetSquareFeatureSet_result -> T.ThriftVal
from_GetSquareFeatureSet_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11056 -> (1, ("e",from_SquareException _v11056))) <$> getSquareFeatureSet_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11056 -> P.Just (0, ("success",from_GetSquareFeatureSetResponse _v11056))) $ getSquareFeatureSet_result_success record
    , (\_v11056 -> (1, ("e",from_SquareException _v11056))) <$> getSquareFeatureSet_result_e record
    ]
    )
write_GetSquareFeatureSet_result :: T.Protocol p => p -> GetSquareFeatureSet_result -> P.IO ()
write_GetSquareFeatureSet_result oprot record = T.writeVal oprot $ from_GetSquareFeatureSet_result record
encode_GetSquareFeatureSet_result :: T.StatelessProtocol p => p -> GetSquareFeatureSet_result -> LBS.ByteString
encode_GetSquareFeatureSet_result oprot record = T.serializeVal oprot $ from_GetSquareFeatureSet_result record
to_GetSquareFeatureSet_result :: T.ThriftVal -> GetSquareFeatureSet_result
to_GetSquareFeatureSet_result (T.TStruct fields) = GetSquareFeatureSet_result{
  getSquareFeatureSet_result_success = P.maybe (getSquareFeatureSet_result_success default_GetSquareFeatureSet_result) (\(_,_val11058) -> (case _val11058 of {T.TStruct _val11059 -> (to_GetSquareFeatureSetResponse (T.TStruct _val11059)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareFeatureSet_result_e = P.maybe (P.Nothing) (\(_,_val11058) -> P.Just (case _val11058 of {T.TStruct _val11060 -> (to_SquareException (T.TStruct _val11060)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareFeatureSet_result _ = P.error "not a struct"
read_GetSquareFeatureSet_result :: T.Protocol p => p -> P.IO GetSquareFeatureSet_result
read_GetSquareFeatureSet_result iprot = to_GetSquareFeatureSet_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareFeatureSet_result)
decode_GetSquareFeatureSet_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareFeatureSet_result
decode_GetSquareFeatureSet_result iprot bs = to_GetSquareFeatureSet_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareFeatureSet_result) bs
typemap_GetSquareFeatureSet_result :: T.TypeMap
typemap_GetSquareFeatureSet_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareFeatureSetResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareFeatureSet_result :: GetSquareFeatureSet_result
default_GetSquareFeatureSet_result = GetSquareFeatureSet_result{
  getSquareFeatureSet_result_success = default_GetSquareFeatureSetResponse,
  getSquareFeatureSet_result_e = P.Nothing}
data SearchSquares_args = SearchSquares_args  { searchSquares_args_request :: SearchSquaresRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquares_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquares_args_request record  
instance QC.Arbitrary SearchSquares_args where 
  arbitrary = M.liftM SearchSquares_args (QC.arbitrary)
  shrink obj | obj == default_SearchSquares_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquares_args{searchSquares_args_request = searchSquares_args_request obj} then P.Nothing else P.Just $ default_SearchSquares_args{searchSquares_args_request = searchSquares_args_request obj}
    ]
from_SearchSquares_args :: SearchSquares_args -> T.ThriftVal
from_SearchSquares_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11063 -> P.Just (1, ("request",from_SearchSquaresRequest _v11063))) $ searchSquares_args_request record
  ]
write_SearchSquares_args :: T.Protocol p => p -> SearchSquares_args -> P.IO ()
write_SearchSquares_args oprot record = T.writeVal oprot $ from_SearchSquares_args record
encode_SearchSquares_args :: T.StatelessProtocol p => p -> SearchSquares_args -> LBS.ByteString
encode_SearchSquares_args oprot record = T.serializeVal oprot $ from_SearchSquares_args record
to_SearchSquares_args :: T.ThriftVal -> SearchSquares_args
to_SearchSquares_args (T.TStruct fields) = SearchSquares_args{
  searchSquares_args_request = P.maybe (searchSquares_args_request default_SearchSquares_args) (\(_,_val11065) -> (case _val11065 of {T.TStruct _val11066 -> (to_SearchSquaresRequest (T.TStruct _val11066)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchSquares_args _ = P.error "not a struct"
read_SearchSquares_args :: T.Protocol p => p -> P.IO SearchSquares_args
read_SearchSquares_args iprot = to_SearchSquares_args <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquares_args)
decode_SearchSquares_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquares_args
decode_SearchSquares_args iprot bs = to_SearchSquares_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquares_args) bs
typemap_SearchSquares_args :: T.TypeMap
typemap_SearchSquares_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_SearchSquaresRequest)))]
default_SearchSquares_args :: SearchSquares_args
default_SearchSquares_args = SearchSquares_args{
  searchSquares_args_request = default_SearchSquaresRequest}
data SearchSquares_result = SearchSquares_result  { searchSquares_result_success :: SearchSquaresResponse
  , searchSquares_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquares_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquares_result_success record   `H.hashWithSalt` searchSquares_result_e record  
instance QC.Arbitrary SearchSquares_result where 
  arbitrary = M.liftM SearchSquares_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchSquares_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquares_result{searchSquares_result_success = searchSquares_result_success obj} then P.Nothing else P.Just $ default_SearchSquares_result{searchSquares_result_success = searchSquares_result_success obj}
    , if obj == default_SearchSquares_result{searchSquares_result_e = searchSquares_result_e obj} then P.Nothing else P.Just $ default_SearchSquares_result{searchSquares_result_e = searchSquares_result_e obj}
    ]
from_SearchSquares_result :: SearchSquares_result -> T.ThriftVal
from_SearchSquares_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11069 -> (1, ("e",from_SquareException _v11069))) <$> searchSquares_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11069 -> P.Just (0, ("success",from_SearchSquaresResponse _v11069))) $ searchSquares_result_success record
    , (\_v11069 -> (1, ("e",from_SquareException _v11069))) <$> searchSquares_result_e record
    ]
    )
write_SearchSquares_result :: T.Protocol p => p -> SearchSquares_result -> P.IO ()
write_SearchSquares_result oprot record = T.writeVal oprot $ from_SearchSquares_result record
encode_SearchSquares_result :: T.StatelessProtocol p => p -> SearchSquares_result -> LBS.ByteString
encode_SearchSquares_result oprot record = T.serializeVal oprot $ from_SearchSquares_result record
to_SearchSquares_result :: T.ThriftVal -> SearchSquares_result
to_SearchSquares_result (T.TStruct fields) = SearchSquares_result{
  searchSquares_result_success = P.maybe (searchSquares_result_success default_SearchSquares_result) (\(_,_val11071) -> (case _val11071 of {T.TStruct _val11072 -> (to_SearchSquaresResponse (T.TStruct _val11072)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  searchSquares_result_e = P.maybe (P.Nothing) (\(_,_val11071) -> P.Just (case _val11071 of {T.TStruct _val11073 -> (to_SquareException (T.TStruct _val11073)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchSquares_result _ = P.error "not a struct"
read_SearchSquares_result :: T.Protocol p => p -> P.IO SearchSquares_result
read_SearchSquares_result iprot = to_SearchSquares_result <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquares_result)
decode_SearchSquares_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquares_result
decode_SearchSquares_result iprot bs = to_SearchSquares_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquares_result) bs
typemap_SearchSquares_result :: T.TypeMap
typemap_SearchSquares_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SearchSquaresResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_SearchSquares_result :: SearchSquares_result
default_SearchSquares_result = SearchSquares_result{
  searchSquares_result_success = default_SearchSquaresResponse,
  searchSquares_result_e = P.Nothing}
data UpdateSquare_args = UpdateSquare_args  { updateSquare_args_request :: UpdateSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquare_args_request record  
instance QC.Arbitrary UpdateSquare_args where 
  arbitrary = M.liftM UpdateSquare_args (QC.arbitrary)
  shrink obj | obj == default_UpdateSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquare_args{updateSquare_args_request = updateSquare_args_request obj} then P.Nothing else P.Just $ default_UpdateSquare_args{updateSquare_args_request = updateSquare_args_request obj}
    ]
from_UpdateSquare_args :: UpdateSquare_args -> T.ThriftVal
from_UpdateSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11076 -> P.Just (1, ("request",from_UpdateSquareRequest _v11076))) $ updateSquare_args_request record
  ]
write_UpdateSquare_args :: T.Protocol p => p -> UpdateSquare_args -> P.IO ()
write_UpdateSquare_args oprot record = T.writeVal oprot $ from_UpdateSquare_args record
encode_UpdateSquare_args :: T.StatelessProtocol p => p -> UpdateSquare_args -> LBS.ByteString
encode_UpdateSquare_args oprot record = T.serializeVal oprot $ from_UpdateSquare_args record
to_UpdateSquare_args :: T.ThriftVal -> UpdateSquare_args
to_UpdateSquare_args (T.TStruct fields) = UpdateSquare_args{
  updateSquare_args_request = P.maybe (updateSquare_args_request default_UpdateSquare_args) (\(_,_val11078) -> (case _val11078 of {T.TStruct _val11079 -> (to_UpdateSquareRequest (T.TStruct _val11079)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquare_args _ = P.error "not a struct"
read_UpdateSquare_args :: T.Protocol p => p -> P.IO UpdateSquare_args
read_UpdateSquare_args iprot = to_UpdateSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquare_args)
decode_UpdateSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquare_args
decode_UpdateSquare_args iprot bs = to_UpdateSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquare_args) bs
typemap_UpdateSquare_args :: T.TypeMap
typemap_UpdateSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_UpdateSquareRequest)))]
default_UpdateSquare_args :: UpdateSquare_args
default_UpdateSquare_args = UpdateSquare_args{
  updateSquare_args_request = default_UpdateSquareRequest}
data UpdateSquare_result = UpdateSquare_result  { updateSquare_result_success :: UpdateSquareResponse
  , updateSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSquare_result_success record   `H.hashWithSalt` updateSquare_result_e record  
instance QC.Arbitrary UpdateSquare_result where 
  arbitrary = M.liftM UpdateSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSquare_result{updateSquare_result_success = updateSquare_result_success obj} then P.Nothing else P.Just $ default_UpdateSquare_result{updateSquare_result_success = updateSquare_result_success obj}
    , if obj == default_UpdateSquare_result{updateSquare_result_e = updateSquare_result_e obj} then P.Nothing else P.Just $ default_UpdateSquare_result{updateSquare_result_e = updateSquare_result_e obj}
    ]
from_UpdateSquare_result :: UpdateSquare_result -> T.ThriftVal
from_UpdateSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11082 -> (1, ("e",from_SquareException _v11082))) <$> updateSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11082 -> P.Just (0, ("success",from_UpdateSquareResponse _v11082))) $ updateSquare_result_success record
    , (\_v11082 -> (1, ("e",from_SquareException _v11082))) <$> updateSquare_result_e record
    ]
    )
write_UpdateSquare_result :: T.Protocol p => p -> UpdateSquare_result -> P.IO ()
write_UpdateSquare_result oprot record = T.writeVal oprot $ from_UpdateSquare_result record
encode_UpdateSquare_result :: T.StatelessProtocol p => p -> UpdateSquare_result -> LBS.ByteString
encode_UpdateSquare_result oprot record = T.serializeVal oprot $ from_UpdateSquare_result record
to_UpdateSquare_result :: T.ThriftVal -> UpdateSquare_result
to_UpdateSquare_result (T.TStruct fields) = UpdateSquare_result{
  updateSquare_result_success = P.maybe (updateSquare_result_success default_UpdateSquare_result) (\(_,_val11084) -> (case _val11084 of {T.TStruct _val11085 -> (to_UpdateSquareResponse (T.TStruct _val11085)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSquare_result_e = P.maybe (P.Nothing) (\(_,_val11084) -> P.Just (case _val11084 of {T.TStruct _val11086 -> (to_SquareException (T.TStruct _val11086)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSquare_result _ = P.error "not a struct"
read_UpdateSquare_result :: T.Protocol p => p -> P.IO UpdateSquare_result
read_UpdateSquare_result iprot = to_UpdateSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSquare_result)
decode_UpdateSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSquare_result
decode_UpdateSquare_result iprot bs = to_UpdateSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSquare_result) bs
typemap_UpdateSquare_result :: T.TypeMap
typemap_UpdateSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_UpdateSquare_result :: UpdateSquare_result
default_UpdateSquare_result = UpdateSquare_result{
  updateSquare_result_success = default_UpdateSquareResponse,
  updateSquare_result_e = P.Nothing}
data GetCategories_args = GetCategories_args  { getCategories_args_request :: GetSquareCategoriesRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCategories_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCategories_args_request record  
instance QC.Arbitrary GetCategories_args where 
  arbitrary = M.liftM GetCategories_args (QC.arbitrary)
  shrink obj | obj == default_GetCategories_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCategories_args{getCategories_args_request = getCategories_args_request obj} then P.Nothing else P.Just $ default_GetCategories_args{getCategories_args_request = getCategories_args_request obj}
    ]
from_GetCategories_args :: GetCategories_args -> T.ThriftVal
from_GetCategories_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11089 -> P.Just (1, ("request",from_GetSquareCategoriesRequest _v11089))) $ getCategories_args_request record
  ]
write_GetCategories_args :: T.Protocol p => p -> GetCategories_args -> P.IO ()
write_GetCategories_args oprot record = T.writeVal oprot $ from_GetCategories_args record
encode_GetCategories_args :: T.StatelessProtocol p => p -> GetCategories_args -> LBS.ByteString
encode_GetCategories_args oprot record = T.serializeVal oprot $ from_GetCategories_args record
to_GetCategories_args :: T.ThriftVal -> GetCategories_args
to_GetCategories_args (T.TStruct fields) = GetCategories_args{
  getCategories_args_request = P.maybe (getCategories_args_request default_GetCategories_args) (\(_,_val11091) -> (case _val11091 of {T.TStruct _val11092 -> (to_GetSquareCategoriesRequest (T.TStruct _val11092)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCategories_args _ = P.error "not a struct"
read_GetCategories_args :: T.Protocol p => p -> P.IO GetCategories_args
read_GetCategories_args iprot = to_GetCategories_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCategories_args)
decode_GetCategories_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCategories_args
decode_GetCategories_args iprot bs = to_GetCategories_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCategories_args) bs
typemap_GetCategories_args :: T.TypeMap
typemap_GetCategories_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareCategoriesRequest)))]
default_GetCategories_args :: GetCategories_args
default_GetCategories_args = GetCategories_args{
  getCategories_args_request = default_GetSquareCategoriesRequest}
data GetCategories_result = GetCategories_result  { getCategories_result_success :: GetSquareCategoriesResponse
  , getCategories_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCategories_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCategories_result_success record   `H.hashWithSalt` getCategories_result_e record  
instance QC.Arbitrary GetCategories_result where 
  arbitrary = M.liftM GetCategories_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCategories_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCategories_result{getCategories_result_success = getCategories_result_success obj} then P.Nothing else P.Just $ default_GetCategories_result{getCategories_result_success = getCategories_result_success obj}
    , if obj == default_GetCategories_result{getCategories_result_e = getCategories_result_e obj} then P.Nothing else P.Just $ default_GetCategories_result{getCategories_result_e = getCategories_result_e obj}
    ]
from_GetCategories_result :: GetCategories_result -> T.ThriftVal
from_GetCategories_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11095 -> (1, ("e",from_SquareException _v11095))) <$> getCategories_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11095 -> P.Just (0, ("success",from_GetSquareCategoriesResponse _v11095))) $ getCategories_result_success record
    , (\_v11095 -> (1, ("e",from_SquareException _v11095))) <$> getCategories_result_e record
    ]
    )
write_GetCategories_result :: T.Protocol p => p -> GetCategories_result -> P.IO ()
write_GetCategories_result oprot record = T.writeVal oprot $ from_GetCategories_result record
encode_GetCategories_result :: T.StatelessProtocol p => p -> GetCategories_result -> LBS.ByteString
encode_GetCategories_result oprot record = T.serializeVal oprot $ from_GetCategories_result record
to_GetCategories_result :: T.ThriftVal -> GetCategories_result
to_GetCategories_result (T.TStruct fields) = GetCategories_result{
  getCategories_result_success = P.maybe (getCategories_result_success default_GetCategories_result) (\(_,_val11097) -> (case _val11097 of {T.TStruct _val11098 -> (to_GetSquareCategoriesResponse (T.TStruct _val11098)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCategories_result_e = P.maybe (P.Nothing) (\(_,_val11097) -> P.Just (case _val11097 of {T.TStruct _val11099 -> (to_SquareException (T.TStruct _val11099)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCategories_result _ = P.error "not a struct"
read_GetCategories_result :: T.Protocol p => p -> P.IO GetCategories_result
read_GetCategories_result iprot = to_GetCategories_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCategories_result)
decode_GetCategories_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCategories_result
decode_GetCategories_result iprot bs = to_GetCategories_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCategories_result) bs
typemap_GetCategories_result :: T.TypeMap
typemap_GetCategories_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareCategoriesResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetCategories_result :: GetCategories_result
default_GetCategories_result = GetCategories_result{
  getCategories_result_success = default_GetSquareCategoriesResponse,
  getCategories_result_e = P.Nothing}
data SearchSquareMembers_args = SearchSquareMembers_args  { searchSquareMembers_args_request :: SearchSquareMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquareMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquareMembers_args_request record  
instance QC.Arbitrary SearchSquareMembers_args where 
  arbitrary = M.liftM SearchSquareMembers_args (QC.arbitrary)
  shrink obj | obj == default_SearchSquareMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquareMembers_args{searchSquareMembers_args_request = searchSquareMembers_args_request obj} then P.Nothing else P.Just $ default_SearchSquareMembers_args{searchSquareMembers_args_request = searchSquareMembers_args_request obj}
    ]
from_SearchSquareMembers_args :: SearchSquareMembers_args -> T.ThriftVal
from_SearchSquareMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11102 -> P.Just (1, ("request",from_SearchSquareMembersRequest _v11102))) $ searchSquareMembers_args_request record
  ]
write_SearchSquareMembers_args :: T.Protocol p => p -> SearchSquareMembers_args -> P.IO ()
write_SearchSquareMembers_args oprot record = T.writeVal oprot $ from_SearchSquareMembers_args record
encode_SearchSquareMembers_args :: T.StatelessProtocol p => p -> SearchSquareMembers_args -> LBS.ByteString
encode_SearchSquareMembers_args oprot record = T.serializeVal oprot $ from_SearchSquareMembers_args record
to_SearchSquareMembers_args :: T.ThriftVal -> SearchSquareMembers_args
to_SearchSquareMembers_args (T.TStruct fields) = SearchSquareMembers_args{
  searchSquareMembers_args_request = P.maybe (searchSquareMembers_args_request default_SearchSquareMembers_args) (\(_,_val11104) -> (case _val11104 of {T.TStruct _val11105 -> (to_SearchSquareMembersRequest (T.TStruct _val11105)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchSquareMembers_args _ = P.error "not a struct"
read_SearchSquareMembers_args :: T.Protocol p => p -> P.IO SearchSquareMembers_args
read_SearchSquareMembers_args iprot = to_SearchSquareMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquareMembers_args)
decode_SearchSquareMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquareMembers_args
decode_SearchSquareMembers_args iprot bs = to_SearchSquareMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquareMembers_args) bs
typemap_SearchSquareMembers_args :: T.TypeMap
typemap_SearchSquareMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_SearchSquareMembersRequest)))]
default_SearchSquareMembers_args :: SearchSquareMembers_args
default_SearchSquareMembers_args = SearchSquareMembers_args{
  searchSquareMembers_args_request = default_SearchSquareMembersRequest}
data SearchSquareMembers_result = SearchSquareMembers_result  { searchSquareMembers_result_success :: SearchSquareMembersResponse
  , searchSquareMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchSquareMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchSquareMembers_result_success record   `H.hashWithSalt` searchSquareMembers_result_e record  
instance QC.Arbitrary SearchSquareMembers_result where 
  arbitrary = M.liftM SearchSquareMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchSquareMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchSquareMembers_result{searchSquareMembers_result_success = searchSquareMembers_result_success obj} then P.Nothing else P.Just $ default_SearchSquareMembers_result{searchSquareMembers_result_success = searchSquareMembers_result_success obj}
    , if obj == default_SearchSquareMembers_result{searchSquareMembers_result_e = searchSquareMembers_result_e obj} then P.Nothing else P.Just $ default_SearchSquareMembers_result{searchSquareMembers_result_e = searchSquareMembers_result_e obj}
    ]
from_SearchSquareMembers_result :: SearchSquareMembers_result -> T.ThriftVal
from_SearchSquareMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11108 -> (1, ("e",from_SquareException _v11108))) <$> searchSquareMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11108 -> P.Just (0, ("success",from_SearchSquareMembersResponse _v11108))) $ searchSquareMembers_result_success record
    , (\_v11108 -> (1, ("e",from_SquareException _v11108))) <$> searchSquareMembers_result_e record
    ]
    )
write_SearchSquareMembers_result :: T.Protocol p => p -> SearchSquareMembers_result -> P.IO ()
write_SearchSquareMembers_result oprot record = T.writeVal oprot $ from_SearchSquareMembers_result record
encode_SearchSquareMembers_result :: T.StatelessProtocol p => p -> SearchSquareMembers_result -> LBS.ByteString
encode_SearchSquareMembers_result oprot record = T.serializeVal oprot $ from_SearchSquareMembers_result record
to_SearchSquareMembers_result :: T.ThriftVal -> SearchSquareMembers_result
to_SearchSquareMembers_result (T.TStruct fields) = SearchSquareMembers_result{
  searchSquareMembers_result_success = P.maybe (searchSquareMembers_result_success default_SearchSquareMembers_result) (\(_,_val11110) -> (case _val11110 of {T.TStruct _val11111 -> (to_SearchSquareMembersResponse (T.TStruct _val11111)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  searchSquareMembers_result_e = P.maybe (P.Nothing) (\(_,_val11110) -> P.Just (case _val11110 of {T.TStruct _val11112 -> (to_SquareException (T.TStruct _val11112)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchSquareMembers_result _ = P.error "not a struct"
read_SearchSquareMembers_result :: T.Protocol p => p -> P.IO SearchSquareMembers_result
read_SearchSquareMembers_result iprot = to_SearchSquareMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_SearchSquareMembers_result)
decode_SearchSquareMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchSquareMembers_result
decode_SearchSquareMembers_result iprot bs = to_SearchSquareMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchSquareMembers_result) bs
typemap_SearchSquareMembers_result :: T.TypeMap
typemap_SearchSquareMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SearchSquareMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_SearchSquareMembers_result :: SearchSquareMembers_result
default_SearchSquareMembers_result = SearchSquareMembers_result{
  searchSquareMembers_result_success = default_SearchSquareMembersResponse,
  searchSquareMembers_result_e = P.Nothing}
data FetchSquareChatEvents_args = FetchSquareChatEvents_args  { fetchSquareChatEvents_args_request :: FetchSquareChatEventsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchSquareChatEvents_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchSquareChatEvents_args_request record  
instance QC.Arbitrary FetchSquareChatEvents_args where 
  arbitrary = M.liftM FetchSquareChatEvents_args (QC.arbitrary)
  shrink obj | obj == default_FetchSquareChatEvents_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchSquareChatEvents_args{fetchSquareChatEvents_args_request = fetchSquareChatEvents_args_request obj} then P.Nothing else P.Just $ default_FetchSquareChatEvents_args{fetchSquareChatEvents_args_request = fetchSquareChatEvents_args_request obj}
    ]
from_FetchSquareChatEvents_args :: FetchSquareChatEvents_args -> T.ThriftVal
from_FetchSquareChatEvents_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11115 -> P.Just (1, ("request",from_FetchSquareChatEventsRequest _v11115))) $ fetchSquareChatEvents_args_request record
  ]
write_FetchSquareChatEvents_args :: T.Protocol p => p -> FetchSquareChatEvents_args -> P.IO ()
write_FetchSquareChatEvents_args oprot record = T.writeVal oprot $ from_FetchSquareChatEvents_args record
encode_FetchSquareChatEvents_args :: T.StatelessProtocol p => p -> FetchSquareChatEvents_args -> LBS.ByteString
encode_FetchSquareChatEvents_args oprot record = T.serializeVal oprot $ from_FetchSquareChatEvents_args record
to_FetchSquareChatEvents_args :: T.ThriftVal -> FetchSquareChatEvents_args
to_FetchSquareChatEvents_args (T.TStruct fields) = FetchSquareChatEvents_args{
  fetchSquareChatEvents_args_request = P.maybe (fetchSquareChatEvents_args_request default_FetchSquareChatEvents_args) (\(_,_val11117) -> (case _val11117 of {T.TStruct _val11118 -> (to_FetchSquareChatEventsRequest (T.TStruct _val11118)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchSquareChatEvents_args _ = P.error "not a struct"
read_FetchSquareChatEvents_args :: T.Protocol p => p -> P.IO FetchSquareChatEvents_args
read_FetchSquareChatEvents_args iprot = to_FetchSquareChatEvents_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchSquareChatEvents_args)
decode_FetchSquareChatEvents_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchSquareChatEvents_args
decode_FetchSquareChatEvents_args iprot bs = to_FetchSquareChatEvents_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchSquareChatEvents_args) bs
typemap_FetchSquareChatEvents_args :: T.TypeMap
typemap_FetchSquareChatEvents_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_FetchSquareChatEventsRequest)))]
default_FetchSquareChatEvents_args :: FetchSquareChatEvents_args
default_FetchSquareChatEvents_args = FetchSquareChatEvents_args{
  fetchSquareChatEvents_args_request = default_FetchSquareChatEventsRequest}
data FetchSquareChatEvents_result = FetchSquareChatEvents_result  { fetchSquareChatEvents_result_success :: FetchSquareChatEventsResponse
  , fetchSquareChatEvents_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchSquareChatEvents_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchSquareChatEvents_result_success record   `H.hashWithSalt` fetchSquareChatEvents_result_e record  
instance QC.Arbitrary FetchSquareChatEvents_result where 
  arbitrary = M.liftM FetchSquareChatEvents_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchSquareChatEvents_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_success = fetchSquareChatEvents_result_success obj} then P.Nothing else P.Just $ default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_success = fetchSquareChatEvents_result_success obj}
    , if obj == default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_e = fetchSquareChatEvents_result_e obj} then P.Nothing else P.Just $ default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_e = fetchSquareChatEvents_result_e obj}
    ]
from_FetchSquareChatEvents_result :: FetchSquareChatEvents_result -> T.ThriftVal
from_FetchSquareChatEvents_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11121 -> (1, ("e",from_SquareException _v11121))) <$> fetchSquareChatEvents_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11121 -> P.Just (0, ("success",from_FetchSquareChatEventsResponse _v11121))) $ fetchSquareChatEvents_result_success record
    , (\_v11121 -> (1, ("e",from_SquareException _v11121))) <$> fetchSquareChatEvents_result_e record
    ]
    )
write_FetchSquareChatEvents_result :: T.Protocol p => p -> FetchSquareChatEvents_result -> P.IO ()
write_FetchSquareChatEvents_result oprot record = T.writeVal oprot $ from_FetchSquareChatEvents_result record
encode_FetchSquareChatEvents_result :: T.StatelessProtocol p => p -> FetchSquareChatEvents_result -> LBS.ByteString
encode_FetchSquareChatEvents_result oprot record = T.serializeVal oprot $ from_FetchSquareChatEvents_result record
to_FetchSquareChatEvents_result :: T.ThriftVal -> FetchSquareChatEvents_result
to_FetchSquareChatEvents_result (T.TStruct fields) = FetchSquareChatEvents_result{
  fetchSquareChatEvents_result_success = P.maybe (fetchSquareChatEvents_result_success default_FetchSquareChatEvents_result) (\(_,_val11123) -> (case _val11123 of {T.TStruct _val11124 -> (to_FetchSquareChatEventsResponse (T.TStruct _val11124)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchSquareChatEvents_result_e = P.maybe (P.Nothing) (\(_,_val11123) -> P.Just (case _val11123 of {T.TStruct _val11125 -> (to_SquareException (T.TStruct _val11125)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchSquareChatEvents_result _ = P.error "not a struct"
read_FetchSquareChatEvents_result :: T.Protocol p => p -> P.IO FetchSquareChatEvents_result
read_FetchSquareChatEvents_result iprot = to_FetchSquareChatEvents_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchSquareChatEvents_result)
decode_FetchSquareChatEvents_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchSquareChatEvents_result
decode_FetchSquareChatEvents_result iprot bs = to_FetchSquareChatEvents_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchSquareChatEvents_result) bs
typemap_FetchSquareChatEvents_result :: T.TypeMap
typemap_FetchSquareChatEvents_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FetchSquareChatEventsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_FetchSquareChatEvents_result :: FetchSquareChatEvents_result
default_FetchSquareChatEvents_result = FetchSquareChatEvents_result{
  fetchSquareChatEvents_result_success = default_FetchSquareChatEventsResponse,
  fetchSquareChatEvents_result_e = P.Nothing}
data FetchMyEvents_args = FetchMyEvents_args  { fetchMyEvents_args_request :: FetchMyEventsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMyEvents_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMyEvents_args_request record  
instance QC.Arbitrary FetchMyEvents_args where 
  arbitrary = M.liftM FetchMyEvents_args (QC.arbitrary)
  shrink obj | obj == default_FetchMyEvents_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMyEvents_args{fetchMyEvents_args_request = fetchMyEvents_args_request obj} then P.Nothing else P.Just $ default_FetchMyEvents_args{fetchMyEvents_args_request = fetchMyEvents_args_request obj}
    ]
from_FetchMyEvents_args :: FetchMyEvents_args -> T.ThriftVal
from_FetchMyEvents_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11128 -> P.Just (1, ("request",from_FetchMyEventsRequest _v11128))) $ fetchMyEvents_args_request record
  ]
write_FetchMyEvents_args :: T.Protocol p => p -> FetchMyEvents_args -> P.IO ()
write_FetchMyEvents_args oprot record = T.writeVal oprot $ from_FetchMyEvents_args record
encode_FetchMyEvents_args :: T.StatelessProtocol p => p -> FetchMyEvents_args -> LBS.ByteString
encode_FetchMyEvents_args oprot record = T.serializeVal oprot $ from_FetchMyEvents_args record
to_FetchMyEvents_args :: T.ThriftVal -> FetchMyEvents_args
to_FetchMyEvents_args (T.TStruct fields) = FetchMyEvents_args{
  fetchMyEvents_args_request = P.maybe (fetchMyEvents_args_request default_FetchMyEvents_args) (\(_,_val11130) -> (case _val11130 of {T.TStruct _val11131 -> (to_FetchMyEventsRequest (T.TStruct _val11131)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchMyEvents_args _ = P.error "not a struct"
read_FetchMyEvents_args :: T.Protocol p => p -> P.IO FetchMyEvents_args
read_FetchMyEvents_args iprot = to_FetchMyEvents_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchMyEvents_args)
decode_FetchMyEvents_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMyEvents_args
decode_FetchMyEvents_args iprot bs = to_FetchMyEvents_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMyEvents_args) bs
typemap_FetchMyEvents_args :: T.TypeMap
typemap_FetchMyEvents_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_FetchMyEventsRequest)))]
default_FetchMyEvents_args :: FetchMyEvents_args
default_FetchMyEvents_args = FetchMyEvents_args{
  fetchMyEvents_args_request = default_FetchMyEventsRequest}
data FetchMyEvents_result = FetchMyEvents_result  { fetchMyEvents_result_success :: FetchMyEventsResponse
  , fetchMyEvents_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMyEvents_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMyEvents_result_success record   `H.hashWithSalt` fetchMyEvents_result_e record  
instance QC.Arbitrary FetchMyEvents_result where 
  arbitrary = M.liftM FetchMyEvents_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchMyEvents_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMyEvents_result{fetchMyEvents_result_success = fetchMyEvents_result_success obj} then P.Nothing else P.Just $ default_FetchMyEvents_result{fetchMyEvents_result_success = fetchMyEvents_result_success obj}
    , if obj == default_FetchMyEvents_result{fetchMyEvents_result_e = fetchMyEvents_result_e obj} then P.Nothing else P.Just $ default_FetchMyEvents_result{fetchMyEvents_result_e = fetchMyEvents_result_e obj}
    ]
from_FetchMyEvents_result :: FetchMyEvents_result -> T.ThriftVal
from_FetchMyEvents_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11134 -> (1, ("e",from_SquareException _v11134))) <$> fetchMyEvents_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11134 -> P.Just (0, ("success",from_FetchMyEventsResponse _v11134))) $ fetchMyEvents_result_success record
    , (\_v11134 -> (1, ("e",from_SquareException _v11134))) <$> fetchMyEvents_result_e record
    ]
    )
write_FetchMyEvents_result :: T.Protocol p => p -> FetchMyEvents_result -> P.IO ()
write_FetchMyEvents_result oprot record = T.writeVal oprot $ from_FetchMyEvents_result record
encode_FetchMyEvents_result :: T.StatelessProtocol p => p -> FetchMyEvents_result -> LBS.ByteString
encode_FetchMyEvents_result oprot record = T.serializeVal oprot $ from_FetchMyEvents_result record
to_FetchMyEvents_result :: T.ThriftVal -> FetchMyEvents_result
to_FetchMyEvents_result (T.TStruct fields) = FetchMyEvents_result{
  fetchMyEvents_result_success = P.maybe (fetchMyEvents_result_success default_FetchMyEvents_result) (\(_,_val11136) -> (case _val11136 of {T.TStruct _val11137 -> (to_FetchMyEventsResponse (T.TStruct _val11137)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchMyEvents_result_e = P.maybe (P.Nothing) (\(_,_val11136) -> P.Just (case _val11136 of {T.TStruct _val11138 -> (to_SquareException (T.TStruct _val11138)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchMyEvents_result _ = P.error "not a struct"
read_FetchMyEvents_result :: T.Protocol p => p -> P.IO FetchMyEvents_result
read_FetchMyEvents_result iprot = to_FetchMyEvents_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchMyEvents_result)
decode_FetchMyEvents_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMyEvents_result
decode_FetchMyEvents_result iprot bs = to_FetchMyEvents_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMyEvents_result) bs
typemap_FetchMyEvents_result :: T.TypeMap
typemap_FetchMyEvents_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FetchMyEventsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_FetchMyEvents_result :: FetchMyEvents_result
default_FetchMyEvents_result = FetchMyEvents_result{
  fetchMyEvents_result_success = default_FetchMyEventsResponse,
  fetchMyEvents_result_e = P.Nothing}
data MarkAsRead_args = MarkAsRead_args  { markAsRead_args_request :: MarkAsReadRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkAsRead_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` markAsRead_args_request record  
instance QC.Arbitrary MarkAsRead_args where 
  arbitrary = M.liftM MarkAsRead_args (QC.arbitrary)
  shrink obj | obj == default_MarkAsRead_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkAsRead_args{markAsRead_args_request = markAsRead_args_request obj} then P.Nothing else P.Just $ default_MarkAsRead_args{markAsRead_args_request = markAsRead_args_request obj}
    ]
from_MarkAsRead_args :: MarkAsRead_args -> T.ThriftVal
from_MarkAsRead_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11141 -> P.Just (1, ("request",from_MarkAsReadRequest _v11141))) $ markAsRead_args_request record
  ]
write_MarkAsRead_args :: T.Protocol p => p -> MarkAsRead_args -> P.IO ()
write_MarkAsRead_args oprot record = T.writeVal oprot $ from_MarkAsRead_args record
encode_MarkAsRead_args :: T.StatelessProtocol p => p -> MarkAsRead_args -> LBS.ByteString
encode_MarkAsRead_args oprot record = T.serializeVal oprot $ from_MarkAsRead_args record
to_MarkAsRead_args :: T.ThriftVal -> MarkAsRead_args
to_MarkAsRead_args (T.TStruct fields) = MarkAsRead_args{
  markAsRead_args_request = P.maybe (markAsRead_args_request default_MarkAsRead_args) (\(_,_val11143) -> (case _val11143 of {T.TStruct _val11144 -> (to_MarkAsReadRequest (T.TStruct _val11144)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkAsRead_args _ = P.error "not a struct"
read_MarkAsRead_args :: T.Protocol p => p -> P.IO MarkAsRead_args
read_MarkAsRead_args iprot = to_MarkAsRead_args <$> T.readVal iprot (T.T_STRUCT typemap_MarkAsRead_args)
decode_MarkAsRead_args :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkAsRead_args
decode_MarkAsRead_args iprot bs = to_MarkAsRead_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkAsRead_args) bs
typemap_MarkAsRead_args :: T.TypeMap
typemap_MarkAsRead_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_MarkAsReadRequest)))]
default_MarkAsRead_args :: MarkAsRead_args
default_MarkAsRead_args = MarkAsRead_args{
  markAsRead_args_request = default_MarkAsReadRequest}
data MarkAsRead_result = MarkAsRead_result  { markAsRead_result_success :: MarkAsReadResponse
  , markAsRead_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkAsRead_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` markAsRead_result_success record   `H.hashWithSalt` markAsRead_result_e record  
instance QC.Arbitrary MarkAsRead_result where 
  arbitrary = M.liftM MarkAsRead_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MarkAsRead_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkAsRead_result{markAsRead_result_success = markAsRead_result_success obj} then P.Nothing else P.Just $ default_MarkAsRead_result{markAsRead_result_success = markAsRead_result_success obj}
    , if obj == default_MarkAsRead_result{markAsRead_result_e = markAsRead_result_e obj} then P.Nothing else P.Just $ default_MarkAsRead_result{markAsRead_result_e = markAsRead_result_e obj}
    ]
from_MarkAsRead_result :: MarkAsRead_result -> T.ThriftVal
from_MarkAsRead_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11147 -> (1, ("e",from_SquareException _v11147))) <$> markAsRead_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11147 -> P.Just (0, ("success",from_MarkAsReadResponse _v11147))) $ markAsRead_result_success record
    , (\_v11147 -> (1, ("e",from_SquareException _v11147))) <$> markAsRead_result_e record
    ]
    )
write_MarkAsRead_result :: T.Protocol p => p -> MarkAsRead_result -> P.IO ()
write_MarkAsRead_result oprot record = T.writeVal oprot $ from_MarkAsRead_result record
encode_MarkAsRead_result :: T.StatelessProtocol p => p -> MarkAsRead_result -> LBS.ByteString
encode_MarkAsRead_result oprot record = T.serializeVal oprot $ from_MarkAsRead_result record
to_MarkAsRead_result :: T.ThriftVal -> MarkAsRead_result
to_MarkAsRead_result (T.TStruct fields) = MarkAsRead_result{
  markAsRead_result_success = P.maybe (markAsRead_result_success default_MarkAsRead_result) (\(_,_val11149) -> (case _val11149 of {T.TStruct _val11150 -> (to_MarkAsReadResponse (T.TStruct _val11150)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  markAsRead_result_e = P.maybe (P.Nothing) (\(_,_val11149) -> P.Just (case _val11149 of {T.TStruct _val11151 -> (to_SquareException (T.TStruct _val11151)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkAsRead_result _ = P.error "not a struct"
read_MarkAsRead_result :: T.Protocol p => p -> P.IO MarkAsRead_result
read_MarkAsRead_result iprot = to_MarkAsRead_result <$> T.readVal iprot (T.T_STRUCT typemap_MarkAsRead_result)
decode_MarkAsRead_result :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkAsRead_result
decode_MarkAsRead_result iprot bs = to_MarkAsRead_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkAsRead_result) bs
typemap_MarkAsRead_result :: T.TypeMap
typemap_MarkAsRead_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MarkAsReadResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_MarkAsRead_result :: MarkAsRead_result
default_MarkAsRead_result = MarkAsRead_result{
  markAsRead_result_success = default_MarkAsReadResponse,
  markAsRead_result_e = P.Nothing}
data GetSquareAuthority_args = GetSquareAuthority_args  { getSquareAuthority_args_request :: GetSquareAuthorityRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareAuthority_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareAuthority_args_request record  
instance QC.Arbitrary GetSquareAuthority_args where 
  arbitrary = M.liftM GetSquareAuthority_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareAuthority_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareAuthority_args{getSquareAuthority_args_request = getSquareAuthority_args_request obj} then P.Nothing else P.Just $ default_GetSquareAuthority_args{getSquareAuthority_args_request = getSquareAuthority_args_request obj}
    ]
from_GetSquareAuthority_args :: GetSquareAuthority_args -> T.ThriftVal
from_GetSquareAuthority_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11154 -> P.Just (1, ("request",from_GetSquareAuthorityRequest _v11154))) $ getSquareAuthority_args_request record
  ]
write_GetSquareAuthority_args :: T.Protocol p => p -> GetSquareAuthority_args -> P.IO ()
write_GetSquareAuthority_args oprot record = T.writeVal oprot $ from_GetSquareAuthority_args record
encode_GetSquareAuthority_args :: T.StatelessProtocol p => p -> GetSquareAuthority_args -> LBS.ByteString
encode_GetSquareAuthority_args oprot record = T.serializeVal oprot $ from_GetSquareAuthority_args record
to_GetSquareAuthority_args :: T.ThriftVal -> GetSquareAuthority_args
to_GetSquareAuthority_args (T.TStruct fields) = GetSquareAuthority_args{
  getSquareAuthority_args_request = P.maybe (getSquareAuthority_args_request default_GetSquareAuthority_args) (\(_,_val11156) -> (case _val11156 of {T.TStruct _val11157 -> (to_GetSquareAuthorityRequest (T.TStruct _val11157)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareAuthority_args _ = P.error "not a struct"
read_GetSquareAuthority_args :: T.Protocol p => p -> P.IO GetSquareAuthority_args
read_GetSquareAuthority_args iprot = to_GetSquareAuthority_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareAuthority_args)
decode_GetSquareAuthority_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareAuthority_args
decode_GetSquareAuthority_args iprot bs = to_GetSquareAuthority_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareAuthority_args) bs
typemap_GetSquareAuthority_args :: T.TypeMap
typemap_GetSquareAuthority_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareAuthorityRequest)))]
default_GetSquareAuthority_args :: GetSquareAuthority_args
default_GetSquareAuthority_args = GetSquareAuthority_args{
  getSquareAuthority_args_request = default_GetSquareAuthorityRequest}
data GetSquareAuthority_result = GetSquareAuthority_result  { getSquareAuthority_result_success :: GetSquareAuthorityResponse
  , getSquareAuthority_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareAuthority_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareAuthority_result_success record   `H.hashWithSalt` getSquareAuthority_result_e record  
instance QC.Arbitrary GetSquareAuthority_result where 
  arbitrary = M.liftM GetSquareAuthority_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareAuthority_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareAuthority_result{getSquareAuthority_result_success = getSquareAuthority_result_success obj} then P.Nothing else P.Just $ default_GetSquareAuthority_result{getSquareAuthority_result_success = getSquareAuthority_result_success obj}
    , if obj == default_GetSquareAuthority_result{getSquareAuthority_result_e = getSquareAuthority_result_e obj} then P.Nothing else P.Just $ default_GetSquareAuthority_result{getSquareAuthority_result_e = getSquareAuthority_result_e obj}
    ]
from_GetSquareAuthority_result :: GetSquareAuthority_result -> T.ThriftVal
from_GetSquareAuthority_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11160 -> (1, ("e",from_SquareException _v11160))) <$> getSquareAuthority_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11160 -> P.Just (0, ("success",from_GetSquareAuthorityResponse _v11160))) $ getSquareAuthority_result_success record
    , (\_v11160 -> (1, ("e",from_SquareException _v11160))) <$> getSquareAuthority_result_e record
    ]
    )
write_GetSquareAuthority_result :: T.Protocol p => p -> GetSquareAuthority_result -> P.IO ()
write_GetSquareAuthority_result oprot record = T.writeVal oprot $ from_GetSquareAuthority_result record
encode_GetSquareAuthority_result :: T.StatelessProtocol p => p -> GetSquareAuthority_result -> LBS.ByteString
encode_GetSquareAuthority_result oprot record = T.serializeVal oprot $ from_GetSquareAuthority_result record
to_GetSquareAuthority_result :: T.ThriftVal -> GetSquareAuthority_result
to_GetSquareAuthority_result (T.TStruct fields) = GetSquareAuthority_result{
  getSquareAuthority_result_success = P.maybe (getSquareAuthority_result_success default_GetSquareAuthority_result) (\(_,_val11162) -> (case _val11162 of {T.TStruct _val11163 -> (to_GetSquareAuthorityResponse (T.TStruct _val11163)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareAuthority_result_e = P.maybe (P.Nothing) (\(_,_val11162) -> P.Just (case _val11162 of {T.TStruct _val11164 -> (to_SquareException (T.TStruct _val11164)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareAuthority_result _ = P.error "not a struct"
read_GetSquareAuthority_result :: T.Protocol p => p -> P.IO GetSquareAuthority_result
read_GetSquareAuthority_result iprot = to_GetSquareAuthority_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareAuthority_result)
decode_GetSquareAuthority_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareAuthority_result
decode_GetSquareAuthority_result iprot bs = to_GetSquareAuthority_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareAuthority_result) bs
typemap_GetSquareAuthority_result :: T.TypeMap
typemap_GetSquareAuthority_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareAuthorityResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareAuthority_result :: GetSquareAuthority_result
default_GetSquareAuthority_result = GetSquareAuthority_result{
  getSquareAuthority_result_success = default_GetSquareAuthorityResponse,
  getSquareAuthority_result_e = P.Nothing}
data SendMessage_args = SendMessage_args  { sendMessage_args_request :: SendMessageRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_args_request record  
instance QC.Arbitrary SendMessage_args where 
  arbitrary = M.liftM SendMessage_args (QC.arbitrary)
  shrink obj | obj == default_SendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_args{sendMessage_args_request = sendMessage_args_request obj} then P.Nothing else P.Just $ default_SendMessage_args{sendMessage_args_request = sendMessage_args_request obj}
    ]
from_SendMessage_args :: SendMessage_args -> T.ThriftVal
from_SendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11167 -> P.Just (1, ("request",from_SendMessageRequest _v11167))) $ sendMessage_args_request record
  ]
write_SendMessage_args :: T.Protocol p => p -> SendMessage_args -> P.IO ()
write_SendMessage_args oprot record = T.writeVal oprot $ from_SendMessage_args record
encode_SendMessage_args :: T.StatelessProtocol p => p -> SendMessage_args -> LBS.ByteString
encode_SendMessage_args oprot record = T.serializeVal oprot $ from_SendMessage_args record
to_SendMessage_args :: T.ThriftVal -> SendMessage_args
to_SendMessage_args (T.TStruct fields) = SendMessage_args{
  sendMessage_args_request = P.maybe (sendMessage_args_request default_SendMessage_args) (\(_,_val11169) -> (case _val11169 of {T.TStruct _val11170 -> (to_SendMessageRequest (T.TStruct _val11170)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessage_args _ = P.error "not a struct"
read_SendMessage_args :: T.Protocol p => p -> P.IO SendMessage_args
read_SendMessage_args iprot = to_SendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_args)
decode_SendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_args
decode_SendMessage_args iprot bs = to_SendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_args) bs
typemap_SendMessage_args :: T.TypeMap
typemap_SendMessage_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_SendMessageRequest)))]
default_SendMessage_args :: SendMessage_args
default_SendMessage_args = SendMessage_args{
  sendMessage_args_request = default_SendMessageRequest}
data SendMessage_result = SendMessage_result  { sendMessage_result_success :: SendMessageResponse
  , sendMessage_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_result_success record   `H.hashWithSalt` sendMessage_result_e record  
instance QC.Arbitrary SendMessage_result where 
  arbitrary = M.liftM SendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj}
    , if obj == default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj}
    ]
from_SendMessage_result :: SendMessage_result -> T.ThriftVal
from_SendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11173 -> (1, ("e",from_SquareException _v11173))) <$> sendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11173 -> P.Just (0, ("success",from_SendMessageResponse _v11173))) $ sendMessage_result_success record
    , (\_v11173 -> (1, ("e",from_SquareException _v11173))) <$> sendMessage_result_e record
    ]
    )
write_SendMessage_result :: T.Protocol p => p -> SendMessage_result -> P.IO ()
write_SendMessage_result oprot record = T.writeVal oprot $ from_SendMessage_result record
encode_SendMessage_result :: T.StatelessProtocol p => p -> SendMessage_result -> LBS.ByteString
encode_SendMessage_result oprot record = T.serializeVal oprot $ from_SendMessage_result record
to_SendMessage_result :: T.ThriftVal -> SendMessage_result
to_SendMessage_result (T.TStruct fields) = SendMessage_result{
  sendMessage_result_success = P.maybe (sendMessage_result_success default_SendMessage_result) (\(_,_val11175) -> (case _val11175 of {T.TStruct _val11176 -> (to_SendMessageResponse (T.TStruct _val11176)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessage_result_e = P.maybe (P.Nothing) (\(_,_val11175) -> P.Just (case _val11175 of {T.TStruct _val11177 -> (to_SquareException (T.TStruct _val11177)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessage_result _ = P.error "not a struct"
read_SendMessage_result :: T.Protocol p => p -> P.IO SendMessage_result
read_SendMessage_result iprot = to_SendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_result)
decode_SendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_result
decode_SendMessage_result iprot bs = to_SendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_result) bs
typemap_SendMessage_result :: T.TypeMap
typemap_SendMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SendMessageResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_SendMessage_result :: SendMessage_result
default_SendMessage_result = SendMessage_result{
  sendMessage_result_success = default_SendMessageResponse,
  sendMessage_result_e = P.Nothing}
data LeaveSquare_args = LeaveSquare_args  { leaveSquare_args_request :: LeaveSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquare_args_request record  
instance QC.Arbitrary LeaveSquare_args where 
  arbitrary = M.liftM LeaveSquare_args (QC.arbitrary)
  shrink obj | obj == default_LeaveSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquare_args{leaveSquare_args_request = leaveSquare_args_request obj} then P.Nothing else P.Just $ default_LeaveSquare_args{leaveSquare_args_request = leaveSquare_args_request obj}
    ]
from_LeaveSquare_args :: LeaveSquare_args -> T.ThriftVal
from_LeaveSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11180 -> P.Just (1, ("request",from_LeaveSquareRequest _v11180))) $ leaveSquare_args_request record
  ]
write_LeaveSquare_args :: T.Protocol p => p -> LeaveSquare_args -> P.IO ()
write_LeaveSquare_args oprot record = T.writeVal oprot $ from_LeaveSquare_args record
encode_LeaveSquare_args :: T.StatelessProtocol p => p -> LeaveSquare_args -> LBS.ByteString
encode_LeaveSquare_args oprot record = T.serializeVal oprot $ from_LeaveSquare_args record
to_LeaveSquare_args :: T.ThriftVal -> LeaveSquare_args
to_LeaveSquare_args (T.TStruct fields) = LeaveSquare_args{
  leaveSquare_args_request = P.maybe (leaveSquare_args_request default_LeaveSquare_args) (\(_,_val11182) -> (case _val11182 of {T.TStruct _val11183 -> (to_LeaveSquareRequest (T.TStruct _val11183)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveSquare_args _ = P.error "not a struct"
read_LeaveSquare_args :: T.Protocol p => p -> P.IO LeaveSquare_args
read_LeaveSquare_args iprot = to_LeaveSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquare_args)
decode_LeaveSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquare_args
decode_LeaveSquare_args iprot bs = to_LeaveSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquare_args) bs
typemap_LeaveSquare_args :: T.TypeMap
typemap_LeaveSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_LeaveSquareRequest)))]
default_LeaveSquare_args :: LeaveSquare_args
default_LeaveSquare_args = LeaveSquare_args{
  leaveSquare_args_request = default_LeaveSquareRequest}
data LeaveSquare_result = LeaveSquare_result  { leaveSquare_result_success :: LeaveSquareResponse
  , leaveSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquare_result_success record   `H.hashWithSalt` leaveSquare_result_e record  
instance QC.Arbitrary LeaveSquare_result where 
  arbitrary = M.liftM LeaveSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquare_result{leaveSquare_result_success = leaveSquare_result_success obj} then P.Nothing else P.Just $ default_LeaveSquare_result{leaveSquare_result_success = leaveSquare_result_success obj}
    , if obj == default_LeaveSquare_result{leaveSquare_result_e = leaveSquare_result_e obj} then P.Nothing else P.Just $ default_LeaveSquare_result{leaveSquare_result_e = leaveSquare_result_e obj}
    ]
from_LeaveSquare_result :: LeaveSquare_result -> T.ThriftVal
from_LeaveSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11186 -> (1, ("e",from_SquareException _v11186))) <$> leaveSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11186 -> P.Just (0, ("success",from_LeaveSquareResponse _v11186))) $ leaveSquare_result_success record
    , (\_v11186 -> (1, ("e",from_SquareException _v11186))) <$> leaveSquare_result_e record
    ]
    )
write_LeaveSquare_result :: T.Protocol p => p -> LeaveSquare_result -> P.IO ()
write_LeaveSquare_result oprot record = T.writeVal oprot $ from_LeaveSquare_result record
encode_LeaveSquare_result :: T.StatelessProtocol p => p -> LeaveSquare_result -> LBS.ByteString
encode_LeaveSquare_result oprot record = T.serializeVal oprot $ from_LeaveSquare_result record
to_LeaveSquare_result :: T.ThriftVal -> LeaveSquare_result
to_LeaveSquare_result (T.TStruct fields) = LeaveSquare_result{
  leaveSquare_result_success = P.maybe (leaveSquare_result_success default_LeaveSquare_result) (\(_,_val11188) -> (case _val11188 of {T.TStruct _val11189 -> (to_LeaveSquareResponse (T.TStruct _val11189)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  leaveSquare_result_e = P.maybe (P.Nothing) (\(_,_val11188) -> P.Just (case _val11188 of {T.TStruct _val11190 -> (to_SquareException (T.TStruct _val11190)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveSquare_result _ = P.error "not a struct"
read_LeaveSquare_result :: T.Protocol p => p -> P.IO LeaveSquare_result
read_LeaveSquare_result iprot = to_LeaveSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquare_result)
decode_LeaveSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquare_result
decode_LeaveSquare_result iprot bs = to_LeaveSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquare_result) bs
typemap_LeaveSquare_result :: T.TypeMap
typemap_LeaveSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LeaveSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_LeaveSquare_result :: LeaveSquare_result
default_LeaveSquare_result = LeaveSquare_result{
  leaveSquare_result_success = default_LeaveSquareResponse,
  leaveSquare_result_e = P.Nothing}
data LeaveSquareChat_args = LeaveSquareChat_args  { leaveSquareChat_args_request :: LeaveSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquareChat_args_request record  
instance QC.Arbitrary LeaveSquareChat_args where 
  arbitrary = M.liftM LeaveSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_LeaveSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquareChat_args{leaveSquareChat_args_request = leaveSquareChat_args_request obj} then P.Nothing else P.Just $ default_LeaveSquareChat_args{leaveSquareChat_args_request = leaveSquareChat_args_request obj}
    ]
from_LeaveSquareChat_args :: LeaveSquareChat_args -> T.ThriftVal
from_LeaveSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11193 -> P.Just (1, ("request",from_LeaveSquareChatRequest _v11193))) $ leaveSquareChat_args_request record
  ]
write_LeaveSquareChat_args :: T.Protocol p => p -> LeaveSquareChat_args -> P.IO ()
write_LeaveSquareChat_args oprot record = T.writeVal oprot $ from_LeaveSquareChat_args record
encode_LeaveSquareChat_args :: T.StatelessProtocol p => p -> LeaveSquareChat_args -> LBS.ByteString
encode_LeaveSquareChat_args oprot record = T.serializeVal oprot $ from_LeaveSquareChat_args record
to_LeaveSquareChat_args :: T.ThriftVal -> LeaveSquareChat_args
to_LeaveSquareChat_args (T.TStruct fields) = LeaveSquareChat_args{
  leaveSquareChat_args_request = P.maybe (leaveSquareChat_args_request default_LeaveSquareChat_args) (\(_,_val11195) -> (case _val11195 of {T.TStruct _val11196 -> (to_LeaveSquareChatRequest (T.TStruct _val11196)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveSquareChat_args _ = P.error "not a struct"
read_LeaveSquareChat_args :: T.Protocol p => p -> P.IO LeaveSquareChat_args
read_LeaveSquareChat_args iprot = to_LeaveSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareChat_args)
decode_LeaveSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareChat_args
decode_LeaveSquareChat_args iprot bs = to_LeaveSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareChat_args) bs
typemap_LeaveSquareChat_args :: T.TypeMap
typemap_LeaveSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_LeaveSquareChatRequest)))]
default_LeaveSquareChat_args :: LeaveSquareChat_args
default_LeaveSquareChat_args = LeaveSquareChat_args{
  leaveSquareChat_args_request = default_LeaveSquareChatRequest}
data LeaveSquareChat_result = LeaveSquareChat_result  { leaveSquareChat_result_success :: LeaveSquareChatResponse
  , leaveSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveSquareChat_result_success record   `H.hashWithSalt` leaveSquareChat_result_e record  
instance QC.Arbitrary LeaveSquareChat_result where 
  arbitrary = M.liftM LeaveSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveSquareChat_result{leaveSquareChat_result_success = leaveSquareChat_result_success obj} then P.Nothing else P.Just $ default_LeaveSquareChat_result{leaveSquareChat_result_success = leaveSquareChat_result_success obj}
    , if obj == default_LeaveSquareChat_result{leaveSquareChat_result_e = leaveSquareChat_result_e obj} then P.Nothing else P.Just $ default_LeaveSquareChat_result{leaveSquareChat_result_e = leaveSquareChat_result_e obj}
    ]
from_LeaveSquareChat_result :: LeaveSquareChat_result -> T.ThriftVal
from_LeaveSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11199 -> (1, ("e",from_SquareException _v11199))) <$> leaveSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11199 -> P.Just (0, ("success",from_LeaveSquareChatResponse _v11199))) $ leaveSquareChat_result_success record
    , (\_v11199 -> (1, ("e",from_SquareException _v11199))) <$> leaveSquareChat_result_e record
    ]
    )
write_LeaveSquareChat_result :: T.Protocol p => p -> LeaveSquareChat_result -> P.IO ()
write_LeaveSquareChat_result oprot record = T.writeVal oprot $ from_LeaveSquareChat_result record
encode_LeaveSquareChat_result :: T.StatelessProtocol p => p -> LeaveSquareChat_result -> LBS.ByteString
encode_LeaveSquareChat_result oprot record = T.serializeVal oprot $ from_LeaveSquareChat_result record
to_LeaveSquareChat_result :: T.ThriftVal -> LeaveSquareChat_result
to_LeaveSquareChat_result (T.TStruct fields) = LeaveSquareChat_result{
  leaveSquareChat_result_success = P.maybe (leaveSquareChat_result_success default_LeaveSquareChat_result) (\(_,_val11201) -> (case _val11201 of {T.TStruct _val11202 -> (to_LeaveSquareChatResponse (T.TStruct _val11202)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  leaveSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11201) -> P.Just (case _val11201 of {T.TStruct _val11203 -> (to_SquareException (T.TStruct _val11203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveSquareChat_result _ = P.error "not a struct"
read_LeaveSquareChat_result :: T.Protocol p => p -> P.IO LeaveSquareChat_result
read_LeaveSquareChat_result iprot = to_LeaveSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveSquareChat_result)
decode_LeaveSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveSquareChat_result
decode_LeaveSquareChat_result iprot bs = to_LeaveSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveSquareChat_result) bs
typemap_LeaveSquareChat_result :: T.TypeMap
typemap_LeaveSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LeaveSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_LeaveSquareChat_result :: LeaveSquareChat_result
default_LeaveSquareChat_result = LeaveSquareChat_result{
  leaveSquareChat_result_success = default_LeaveSquareChatResponse,
  leaveSquareChat_result_e = P.Nothing}
data JoinSquareChat_args = JoinSquareChat_args  { joinSquareChat_args_request :: JoinSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareChat_args_request record  
instance QC.Arbitrary JoinSquareChat_args where 
  arbitrary = M.liftM JoinSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_JoinSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareChat_args{joinSquareChat_args_request = joinSquareChat_args_request obj} then P.Nothing else P.Just $ default_JoinSquareChat_args{joinSquareChat_args_request = joinSquareChat_args_request obj}
    ]
from_JoinSquareChat_args :: JoinSquareChat_args -> T.ThriftVal
from_JoinSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11206 -> P.Just (1, ("request",from_JoinSquareChatRequest _v11206))) $ joinSquareChat_args_request record
  ]
write_JoinSquareChat_args :: T.Protocol p => p -> JoinSquareChat_args -> P.IO ()
write_JoinSquareChat_args oprot record = T.writeVal oprot $ from_JoinSquareChat_args record
encode_JoinSquareChat_args :: T.StatelessProtocol p => p -> JoinSquareChat_args -> LBS.ByteString
encode_JoinSquareChat_args oprot record = T.serializeVal oprot $ from_JoinSquareChat_args record
to_JoinSquareChat_args :: T.ThriftVal -> JoinSquareChat_args
to_JoinSquareChat_args (T.TStruct fields) = JoinSquareChat_args{
  joinSquareChat_args_request = P.maybe (joinSquareChat_args_request default_JoinSquareChat_args) (\(_,_val11208) -> (case _val11208 of {T.TStruct _val11209 -> (to_JoinSquareChatRequest (T.TStruct _val11209)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinSquareChat_args _ = P.error "not a struct"
read_JoinSquareChat_args :: T.Protocol p => p -> P.IO JoinSquareChat_args
read_JoinSquareChat_args iprot = to_JoinSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareChat_args)
decode_JoinSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareChat_args
decode_JoinSquareChat_args iprot bs = to_JoinSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareChat_args) bs
typemap_JoinSquareChat_args :: T.TypeMap
typemap_JoinSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_JoinSquareChatRequest)))]
default_JoinSquareChat_args :: JoinSquareChat_args
default_JoinSquareChat_args = JoinSquareChat_args{
  joinSquareChat_args_request = default_JoinSquareChatRequest}
data JoinSquareChat_result = JoinSquareChat_result  { joinSquareChat_result_success :: JoinSquareChatResponse
  , joinSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquareChat_result_success record   `H.hashWithSalt` joinSquareChat_result_e record  
instance QC.Arbitrary JoinSquareChat_result where 
  arbitrary = M.liftM JoinSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_JoinSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquareChat_result{joinSquareChat_result_success = joinSquareChat_result_success obj} then P.Nothing else P.Just $ default_JoinSquareChat_result{joinSquareChat_result_success = joinSquareChat_result_success obj}
    , if obj == default_JoinSquareChat_result{joinSquareChat_result_e = joinSquareChat_result_e obj} then P.Nothing else P.Just $ default_JoinSquareChat_result{joinSquareChat_result_e = joinSquareChat_result_e obj}
    ]
from_JoinSquareChat_result :: JoinSquareChat_result -> T.ThriftVal
from_JoinSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11212 -> (1, ("e",from_SquareException _v11212))) <$> joinSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11212 -> P.Just (0, ("success",from_JoinSquareChatResponse _v11212))) $ joinSquareChat_result_success record
    , (\_v11212 -> (1, ("e",from_SquareException _v11212))) <$> joinSquareChat_result_e record
    ]
    )
write_JoinSquareChat_result :: T.Protocol p => p -> JoinSquareChat_result -> P.IO ()
write_JoinSquareChat_result oprot record = T.writeVal oprot $ from_JoinSquareChat_result record
encode_JoinSquareChat_result :: T.StatelessProtocol p => p -> JoinSquareChat_result -> LBS.ByteString
encode_JoinSquareChat_result oprot record = T.serializeVal oprot $ from_JoinSquareChat_result record
to_JoinSquareChat_result :: T.ThriftVal -> JoinSquareChat_result
to_JoinSquareChat_result (T.TStruct fields) = JoinSquareChat_result{
  joinSquareChat_result_success = P.maybe (joinSquareChat_result_success default_JoinSquareChat_result) (\(_,_val11214) -> (case _val11214 of {T.TStruct _val11215 -> (to_JoinSquareChatResponse (T.TStruct _val11215)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  joinSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11214) -> P.Just (case _val11214 of {T.TStruct _val11216 -> (to_SquareException (T.TStruct _val11216)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinSquareChat_result _ = P.error "not a struct"
read_JoinSquareChat_result :: T.Protocol p => p -> P.IO JoinSquareChat_result
read_JoinSquareChat_result iprot = to_JoinSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquareChat_result)
decode_JoinSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquareChat_result
decode_JoinSquareChat_result iprot bs = to_JoinSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquareChat_result) bs
typemap_JoinSquareChat_result :: T.TypeMap
typemap_JoinSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_JoinSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_JoinSquareChat_result :: JoinSquareChat_result
default_JoinSquareChat_result = JoinSquareChat_result{
  joinSquareChat_result_success = default_JoinSquareChatResponse,
  joinSquareChat_result_e = P.Nothing}
data JoinSquare_args = JoinSquare_args  { joinSquare_args_request :: JoinSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquare_args_request record  
instance QC.Arbitrary JoinSquare_args where 
  arbitrary = M.liftM JoinSquare_args (QC.arbitrary)
  shrink obj | obj == default_JoinSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquare_args{joinSquare_args_request = joinSquare_args_request obj} then P.Nothing else P.Just $ default_JoinSquare_args{joinSquare_args_request = joinSquare_args_request obj}
    ]
from_JoinSquare_args :: JoinSquare_args -> T.ThriftVal
from_JoinSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11219 -> P.Just (1, ("request",from_JoinSquareRequest _v11219))) $ joinSquare_args_request record
  ]
write_JoinSquare_args :: T.Protocol p => p -> JoinSquare_args -> P.IO ()
write_JoinSquare_args oprot record = T.writeVal oprot $ from_JoinSquare_args record
encode_JoinSquare_args :: T.StatelessProtocol p => p -> JoinSquare_args -> LBS.ByteString
encode_JoinSquare_args oprot record = T.serializeVal oprot $ from_JoinSquare_args record
to_JoinSquare_args :: T.ThriftVal -> JoinSquare_args
to_JoinSquare_args (T.TStruct fields) = JoinSquare_args{
  joinSquare_args_request = P.maybe (joinSquare_args_request default_JoinSquare_args) (\(_,_val11221) -> (case _val11221 of {T.TStruct _val11222 -> (to_JoinSquareRequest (T.TStruct _val11222)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinSquare_args _ = P.error "not a struct"
read_JoinSquare_args :: T.Protocol p => p -> P.IO JoinSquare_args
read_JoinSquare_args iprot = to_JoinSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquare_args)
decode_JoinSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquare_args
decode_JoinSquare_args iprot bs = to_JoinSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquare_args) bs
typemap_JoinSquare_args :: T.TypeMap
typemap_JoinSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_JoinSquareRequest)))]
default_JoinSquare_args :: JoinSquare_args
default_JoinSquare_args = JoinSquare_args{
  joinSquare_args_request = default_JoinSquareRequest}
data JoinSquare_result = JoinSquare_result  { joinSquare_result_success :: JoinSquareResponse
  , joinSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable JoinSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` joinSquare_result_success record   `H.hashWithSalt` joinSquare_result_e record  
instance QC.Arbitrary JoinSquare_result where 
  arbitrary = M.liftM JoinSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_JoinSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_JoinSquare_result{joinSquare_result_success = joinSquare_result_success obj} then P.Nothing else P.Just $ default_JoinSquare_result{joinSquare_result_success = joinSquare_result_success obj}
    , if obj == default_JoinSquare_result{joinSquare_result_e = joinSquare_result_e obj} then P.Nothing else P.Just $ default_JoinSquare_result{joinSquare_result_e = joinSquare_result_e obj}
    ]
from_JoinSquare_result :: JoinSquare_result -> T.ThriftVal
from_JoinSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11225 -> (1, ("e",from_SquareException _v11225))) <$> joinSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11225 -> P.Just (0, ("success",from_JoinSquareResponse _v11225))) $ joinSquare_result_success record
    , (\_v11225 -> (1, ("e",from_SquareException _v11225))) <$> joinSquare_result_e record
    ]
    )
write_JoinSquare_result :: T.Protocol p => p -> JoinSquare_result -> P.IO ()
write_JoinSquare_result oprot record = T.writeVal oprot $ from_JoinSquare_result record
encode_JoinSquare_result :: T.StatelessProtocol p => p -> JoinSquare_result -> LBS.ByteString
encode_JoinSquare_result oprot record = T.serializeVal oprot $ from_JoinSquare_result record
to_JoinSquare_result :: T.ThriftVal -> JoinSquare_result
to_JoinSquare_result (T.TStruct fields) = JoinSquare_result{
  joinSquare_result_success = P.maybe (joinSquare_result_success default_JoinSquare_result) (\(_,_val11227) -> (case _val11227 of {T.TStruct _val11228 -> (to_JoinSquareResponse (T.TStruct _val11228)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  joinSquare_result_e = P.maybe (P.Nothing) (\(_,_val11227) -> P.Just (case _val11227 of {T.TStruct _val11229 -> (to_SquareException (T.TStruct _val11229)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_JoinSquare_result _ = P.error "not a struct"
read_JoinSquare_result :: T.Protocol p => p -> P.IO JoinSquare_result
read_JoinSquare_result iprot = to_JoinSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_JoinSquare_result)
decode_JoinSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> JoinSquare_result
decode_JoinSquare_result iprot bs = to_JoinSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_JoinSquare_result) bs
typemap_JoinSquare_result :: T.TypeMap
typemap_JoinSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_JoinSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_JoinSquare_result :: JoinSquare_result
default_JoinSquare_result = JoinSquare_result{
  joinSquare_result_success = default_JoinSquareResponse,
  joinSquare_result_e = P.Nothing}
data InviteToSquare_args = InviteToSquare_args  { inviteToSquare_args_request :: InviteToSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquare_args_request record  
instance QC.Arbitrary InviteToSquare_args where 
  arbitrary = M.liftM InviteToSquare_args (QC.arbitrary)
  shrink obj | obj == default_InviteToSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquare_args{inviteToSquare_args_request = inviteToSquare_args_request obj} then P.Nothing else P.Just $ default_InviteToSquare_args{inviteToSquare_args_request = inviteToSquare_args_request obj}
    ]
from_InviteToSquare_args :: InviteToSquare_args -> T.ThriftVal
from_InviteToSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11232 -> P.Just (1, ("request",from_InviteToSquareRequest _v11232))) $ inviteToSquare_args_request record
  ]
write_InviteToSquare_args :: T.Protocol p => p -> InviteToSquare_args -> P.IO ()
write_InviteToSquare_args oprot record = T.writeVal oprot $ from_InviteToSquare_args record
encode_InviteToSquare_args :: T.StatelessProtocol p => p -> InviteToSquare_args -> LBS.ByteString
encode_InviteToSquare_args oprot record = T.serializeVal oprot $ from_InviteToSquare_args record
to_InviteToSquare_args :: T.ThriftVal -> InviteToSquare_args
to_InviteToSquare_args (T.TStruct fields) = InviteToSquare_args{
  inviteToSquare_args_request = P.maybe (inviteToSquare_args_request default_InviteToSquare_args) (\(_,_val11234) -> (case _val11234 of {T.TStruct _val11235 -> (to_InviteToSquareRequest (T.TStruct _val11235)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteToSquare_args _ = P.error "not a struct"
read_InviteToSquare_args :: T.Protocol p => p -> P.IO InviteToSquare_args
read_InviteToSquare_args iprot = to_InviteToSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquare_args)
decode_InviteToSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquare_args
decode_InviteToSquare_args iprot bs = to_InviteToSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquare_args) bs
typemap_InviteToSquare_args :: T.TypeMap
typemap_InviteToSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_InviteToSquareRequest)))]
default_InviteToSquare_args :: InviteToSquare_args
default_InviteToSquare_args = InviteToSquare_args{
  inviteToSquare_args_request = default_InviteToSquareRequest}
data InviteToSquare_result = InviteToSquare_result  { inviteToSquare_result_success :: InviteToSquareResponse
  , inviteToSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquare_result_success record   `H.hashWithSalt` inviteToSquare_result_e record  
instance QC.Arbitrary InviteToSquare_result where 
  arbitrary = M.liftM InviteToSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteToSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquare_result{inviteToSquare_result_success = inviteToSquare_result_success obj} then P.Nothing else P.Just $ default_InviteToSquare_result{inviteToSquare_result_success = inviteToSquare_result_success obj}
    , if obj == default_InviteToSquare_result{inviteToSquare_result_e = inviteToSquare_result_e obj} then P.Nothing else P.Just $ default_InviteToSquare_result{inviteToSquare_result_e = inviteToSquare_result_e obj}
    ]
from_InviteToSquare_result :: InviteToSquare_result -> T.ThriftVal
from_InviteToSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11238 -> (1, ("e",from_SquareException _v11238))) <$> inviteToSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11238 -> P.Just (0, ("success",from_InviteToSquareResponse _v11238))) $ inviteToSquare_result_success record
    , (\_v11238 -> (1, ("e",from_SquareException _v11238))) <$> inviteToSquare_result_e record
    ]
    )
write_InviteToSquare_result :: T.Protocol p => p -> InviteToSquare_result -> P.IO ()
write_InviteToSquare_result oprot record = T.writeVal oprot $ from_InviteToSquare_result record
encode_InviteToSquare_result :: T.StatelessProtocol p => p -> InviteToSquare_result -> LBS.ByteString
encode_InviteToSquare_result oprot record = T.serializeVal oprot $ from_InviteToSquare_result record
to_InviteToSquare_result :: T.ThriftVal -> InviteToSquare_result
to_InviteToSquare_result (T.TStruct fields) = InviteToSquare_result{
  inviteToSquare_result_success = P.maybe (inviteToSquare_result_success default_InviteToSquare_result) (\(_,_val11240) -> (case _val11240 of {T.TStruct _val11241 -> (to_InviteToSquareResponse (T.TStruct _val11241)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  inviteToSquare_result_e = P.maybe (P.Nothing) (\(_,_val11240) -> P.Just (case _val11240 of {T.TStruct _val11242 -> (to_SquareException (T.TStruct _val11242)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteToSquare_result _ = P.error "not a struct"
read_InviteToSquare_result :: T.Protocol p => p -> P.IO InviteToSquare_result
read_InviteToSquare_result iprot = to_InviteToSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquare_result)
decode_InviteToSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquare_result
decode_InviteToSquare_result iprot bs = to_InviteToSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquare_result) bs
typemap_InviteToSquare_result :: T.TypeMap
typemap_InviteToSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_InviteToSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_InviteToSquare_result :: InviteToSquare_result
default_InviteToSquare_result = InviteToSquare_result{
  inviteToSquare_result_success = default_InviteToSquareResponse,
  inviteToSquare_result_e = P.Nothing}
data InviteToSquareChat_args = InviteToSquareChat_args  { inviteToSquareChat_args_request :: InviteToSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquareChat_args_request record  
instance QC.Arbitrary InviteToSquareChat_args where 
  arbitrary = M.liftM InviteToSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_InviteToSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquareChat_args{inviteToSquareChat_args_request = inviteToSquareChat_args_request obj} then P.Nothing else P.Just $ default_InviteToSquareChat_args{inviteToSquareChat_args_request = inviteToSquareChat_args_request obj}
    ]
from_InviteToSquareChat_args :: InviteToSquareChat_args -> T.ThriftVal
from_InviteToSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11245 -> P.Just (1, ("request",from_InviteToSquareChatRequest _v11245))) $ inviteToSquareChat_args_request record
  ]
write_InviteToSquareChat_args :: T.Protocol p => p -> InviteToSquareChat_args -> P.IO ()
write_InviteToSquareChat_args oprot record = T.writeVal oprot $ from_InviteToSquareChat_args record
encode_InviteToSquareChat_args :: T.StatelessProtocol p => p -> InviteToSquareChat_args -> LBS.ByteString
encode_InviteToSquareChat_args oprot record = T.serializeVal oprot $ from_InviteToSquareChat_args record
to_InviteToSquareChat_args :: T.ThriftVal -> InviteToSquareChat_args
to_InviteToSquareChat_args (T.TStruct fields) = InviteToSquareChat_args{
  inviteToSquareChat_args_request = P.maybe (inviteToSquareChat_args_request default_InviteToSquareChat_args) (\(_,_val11247) -> (case _val11247 of {T.TStruct _val11248 -> (to_InviteToSquareChatRequest (T.TStruct _val11248)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteToSquareChat_args _ = P.error "not a struct"
read_InviteToSquareChat_args :: T.Protocol p => p -> P.IO InviteToSquareChat_args
read_InviteToSquareChat_args iprot = to_InviteToSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareChat_args)
decode_InviteToSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareChat_args
decode_InviteToSquareChat_args iprot bs = to_InviteToSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareChat_args) bs
typemap_InviteToSquareChat_args :: T.TypeMap
typemap_InviteToSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_InviteToSquareChatRequest)))]
default_InviteToSquareChat_args :: InviteToSquareChat_args
default_InviteToSquareChat_args = InviteToSquareChat_args{
  inviteToSquareChat_args_request = default_InviteToSquareChatRequest}
data InviteToSquareChat_result = InviteToSquareChat_result  { inviteToSquareChat_result_success :: InviteToSquareChatResponse
  , inviteToSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToSquareChat_result_success record   `H.hashWithSalt` inviteToSquareChat_result_e record  
instance QC.Arbitrary InviteToSquareChat_result where 
  arbitrary = M.liftM InviteToSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteToSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToSquareChat_result{inviteToSquareChat_result_success = inviteToSquareChat_result_success obj} then P.Nothing else P.Just $ default_InviteToSquareChat_result{inviteToSquareChat_result_success = inviteToSquareChat_result_success obj}
    , if obj == default_InviteToSquareChat_result{inviteToSquareChat_result_e = inviteToSquareChat_result_e obj} then P.Nothing else P.Just $ default_InviteToSquareChat_result{inviteToSquareChat_result_e = inviteToSquareChat_result_e obj}
    ]
from_InviteToSquareChat_result :: InviteToSquareChat_result -> T.ThriftVal
from_InviteToSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11251 -> (1, ("e",from_SquareException _v11251))) <$> inviteToSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11251 -> P.Just (0, ("success",from_InviteToSquareChatResponse _v11251))) $ inviteToSquareChat_result_success record
    , (\_v11251 -> (1, ("e",from_SquareException _v11251))) <$> inviteToSquareChat_result_e record
    ]
    )
write_InviteToSquareChat_result :: T.Protocol p => p -> InviteToSquareChat_result -> P.IO ()
write_InviteToSquareChat_result oprot record = T.writeVal oprot $ from_InviteToSquareChat_result record
encode_InviteToSquareChat_result :: T.StatelessProtocol p => p -> InviteToSquareChat_result -> LBS.ByteString
encode_InviteToSquareChat_result oprot record = T.serializeVal oprot $ from_InviteToSquareChat_result record
to_InviteToSquareChat_result :: T.ThriftVal -> InviteToSquareChat_result
to_InviteToSquareChat_result (T.TStruct fields) = InviteToSquareChat_result{
  inviteToSquareChat_result_success = P.maybe (inviteToSquareChat_result_success default_InviteToSquareChat_result) (\(_,_val11253) -> (case _val11253 of {T.TStruct _val11254 -> (to_InviteToSquareChatResponse (T.TStruct _val11254)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  inviteToSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11253) -> P.Just (case _val11253 of {T.TStruct _val11255 -> (to_SquareException (T.TStruct _val11255)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteToSquareChat_result _ = P.error "not a struct"
read_InviteToSquareChat_result :: T.Protocol p => p -> P.IO InviteToSquareChat_result
read_InviteToSquareChat_result iprot = to_InviteToSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteToSquareChat_result)
decode_InviteToSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToSquareChat_result
decode_InviteToSquareChat_result iprot bs = to_InviteToSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToSquareChat_result) bs
typemap_InviteToSquareChat_result :: T.TypeMap
typemap_InviteToSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_InviteToSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_InviteToSquareChat_result :: InviteToSquareChat_result
default_InviteToSquareChat_result = InviteToSquareChat_result{
  inviteToSquareChat_result_success = default_InviteToSquareChatResponse,
  inviteToSquareChat_result_e = P.Nothing}
data GetSquareMember_args = GetSquareMember_args  { getSquareMember_args_request :: GetSquareMemberRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMember_args_request record  
instance QC.Arbitrary GetSquareMember_args where 
  arbitrary = M.liftM GetSquareMember_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMember_args{getSquareMember_args_request = getSquareMember_args_request obj} then P.Nothing else P.Just $ default_GetSquareMember_args{getSquareMember_args_request = getSquareMember_args_request obj}
    ]
from_GetSquareMember_args :: GetSquareMember_args -> T.ThriftVal
from_GetSquareMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11258 -> P.Just (1, ("request",from_GetSquareMemberRequest _v11258))) $ getSquareMember_args_request record
  ]
write_GetSquareMember_args :: T.Protocol p => p -> GetSquareMember_args -> P.IO ()
write_GetSquareMember_args oprot record = T.writeVal oprot $ from_GetSquareMember_args record
encode_GetSquareMember_args :: T.StatelessProtocol p => p -> GetSquareMember_args -> LBS.ByteString
encode_GetSquareMember_args oprot record = T.serializeVal oprot $ from_GetSquareMember_args record
to_GetSquareMember_args :: T.ThriftVal -> GetSquareMember_args
to_GetSquareMember_args (T.TStruct fields) = GetSquareMember_args{
  getSquareMember_args_request = P.maybe (getSquareMember_args_request default_GetSquareMember_args) (\(_,_val11260) -> (case _val11260 of {T.TStruct _val11261 -> (to_GetSquareMemberRequest (T.TStruct _val11261)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMember_args _ = P.error "not a struct"
read_GetSquareMember_args :: T.Protocol p => p -> P.IO GetSquareMember_args
read_GetSquareMember_args iprot = to_GetSquareMember_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMember_args)
decode_GetSquareMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMember_args
decode_GetSquareMember_args iprot bs = to_GetSquareMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMember_args) bs
typemap_GetSquareMember_args :: T.TypeMap
typemap_GetSquareMember_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareMemberRequest)))]
default_GetSquareMember_args :: GetSquareMember_args
default_GetSquareMember_args = GetSquareMember_args{
  getSquareMember_args_request = default_GetSquareMemberRequest}
data GetSquareMember_result = GetSquareMember_result  { getSquareMember_result_success :: GetSquareMemberResponse
  , getSquareMember_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMember_result_success record   `H.hashWithSalt` getSquareMember_result_e record  
instance QC.Arbitrary GetSquareMember_result where 
  arbitrary = M.liftM GetSquareMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMember_result{getSquareMember_result_success = getSquareMember_result_success obj} then P.Nothing else P.Just $ default_GetSquareMember_result{getSquareMember_result_success = getSquareMember_result_success obj}
    , if obj == default_GetSquareMember_result{getSquareMember_result_e = getSquareMember_result_e obj} then P.Nothing else P.Just $ default_GetSquareMember_result{getSquareMember_result_e = getSquareMember_result_e obj}
    ]
from_GetSquareMember_result :: GetSquareMember_result -> T.ThriftVal
from_GetSquareMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11264 -> (1, ("e",from_SquareException _v11264))) <$> getSquareMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11264 -> P.Just (0, ("success",from_GetSquareMemberResponse _v11264))) $ getSquareMember_result_success record
    , (\_v11264 -> (1, ("e",from_SquareException _v11264))) <$> getSquareMember_result_e record
    ]
    )
write_GetSquareMember_result :: T.Protocol p => p -> GetSquareMember_result -> P.IO ()
write_GetSquareMember_result oprot record = T.writeVal oprot $ from_GetSquareMember_result record
encode_GetSquareMember_result :: T.StatelessProtocol p => p -> GetSquareMember_result -> LBS.ByteString
encode_GetSquareMember_result oprot record = T.serializeVal oprot $ from_GetSquareMember_result record
to_GetSquareMember_result :: T.ThriftVal -> GetSquareMember_result
to_GetSquareMember_result (T.TStruct fields) = GetSquareMember_result{
  getSquareMember_result_success = P.maybe (getSquareMember_result_success default_GetSquareMember_result) (\(_,_val11266) -> (case _val11266 of {T.TStruct _val11267 -> (to_GetSquareMemberResponse (T.TStruct _val11267)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareMember_result_e = P.maybe (P.Nothing) (\(_,_val11266) -> P.Just (case _val11266 of {T.TStruct _val11268 -> (to_SquareException (T.TStruct _val11268)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMember_result _ = P.error "not a struct"
read_GetSquareMember_result :: T.Protocol p => p -> P.IO GetSquareMember_result
read_GetSquareMember_result iprot = to_GetSquareMember_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMember_result)
decode_GetSquareMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMember_result
decode_GetSquareMember_result iprot bs = to_GetSquareMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMember_result) bs
typemap_GetSquareMember_result :: T.TypeMap
typemap_GetSquareMember_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareMemberResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareMember_result :: GetSquareMember_result
default_GetSquareMember_result = GetSquareMember_result{
  getSquareMember_result_success = default_GetSquareMemberResponse,
  getSquareMember_result_e = P.Nothing}
data GetSquareMembers_args = GetSquareMembers_args  { getSquareMembers_args_request :: GetSquareMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMembers_args_request record  
instance QC.Arbitrary GetSquareMembers_args where 
  arbitrary = M.liftM GetSquareMembers_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMembers_args{getSquareMembers_args_request = getSquareMembers_args_request obj} then P.Nothing else P.Just $ default_GetSquareMembers_args{getSquareMembers_args_request = getSquareMembers_args_request obj}
    ]
from_GetSquareMembers_args :: GetSquareMembers_args -> T.ThriftVal
from_GetSquareMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11271 -> P.Just (1, ("request",from_GetSquareMembersRequest _v11271))) $ getSquareMembers_args_request record
  ]
write_GetSquareMembers_args :: T.Protocol p => p -> GetSquareMembers_args -> P.IO ()
write_GetSquareMembers_args oprot record = T.writeVal oprot $ from_GetSquareMembers_args record
encode_GetSquareMembers_args :: T.StatelessProtocol p => p -> GetSquareMembers_args -> LBS.ByteString
encode_GetSquareMembers_args oprot record = T.serializeVal oprot $ from_GetSquareMembers_args record
to_GetSquareMembers_args :: T.ThriftVal -> GetSquareMembers_args
to_GetSquareMembers_args (T.TStruct fields) = GetSquareMembers_args{
  getSquareMembers_args_request = P.maybe (getSquareMembers_args_request default_GetSquareMembers_args) (\(_,_val11273) -> (case _val11273 of {T.TStruct _val11274 -> (to_GetSquareMembersRequest (T.TStruct _val11274)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMembers_args _ = P.error "not a struct"
read_GetSquareMembers_args :: T.Protocol p => p -> P.IO GetSquareMembers_args
read_GetSquareMembers_args iprot = to_GetSquareMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMembers_args)
decode_GetSquareMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMembers_args
decode_GetSquareMembers_args iprot bs = to_GetSquareMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMembers_args) bs
typemap_GetSquareMembers_args :: T.TypeMap
typemap_GetSquareMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareMembersRequest)))]
default_GetSquareMembers_args :: GetSquareMembers_args
default_GetSquareMembers_args = GetSquareMembers_args{
  getSquareMembers_args_request = default_GetSquareMembersRequest}
data GetSquareMembers_result = GetSquareMembers_result  { getSquareMembers_result_success :: GetSquareMembersResponse
  , getSquareMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMembers_result_success record   `H.hashWithSalt` getSquareMembers_result_e record  
instance QC.Arbitrary GetSquareMembers_result where 
  arbitrary = M.liftM GetSquareMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMembers_result{getSquareMembers_result_success = getSquareMembers_result_success obj} then P.Nothing else P.Just $ default_GetSquareMembers_result{getSquareMembers_result_success = getSquareMembers_result_success obj}
    , if obj == default_GetSquareMembers_result{getSquareMembers_result_e = getSquareMembers_result_e obj} then P.Nothing else P.Just $ default_GetSquareMembers_result{getSquareMembers_result_e = getSquareMembers_result_e obj}
    ]
from_GetSquareMembers_result :: GetSquareMembers_result -> T.ThriftVal
from_GetSquareMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11277 -> (1, ("e",from_SquareException _v11277))) <$> getSquareMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11277 -> P.Just (0, ("success",from_GetSquareMembersResponse _v11277))) $ getSquareMembers_result_success record
    , (\_v11277 -> (1, ("e",from_SquareException _v11277))) <$> getSquareMembers_result_e record
    ]
    )
write_GetSquareMembers_result :: T.Protocol p => p -> GetSquareMembers_result -> P.IO ()
write_GetSquareMembers_result oprot record = T.writeVal oprot $ from_GetSquareMembers_result record
encode_GetSquareMembers_result :: T.StatelessProtocol p => p -> GetSquareMembers_result -> LBS.ByteString
encode_GetSquareMembers_result oprot record = T.serializeVal oprot $ from_GetSquareMembers_result record
to_GetSquareMembers_result :: T.ThriftVal -> GetSquareMembers_result
to_GetSquareMembers_result (T.TStruct fields) = GetSquareMembers_result{
  getSquareMembers_result_success = P.maybe (getSquareMembers_result_success default_GetSquareMembers_result) (\(_,_val11279) -> (case _val11279 of {T.TStruct _val11280 -> (to_GetSquareMembersResponse (T.TStruct _val11280)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareMembers_result_e = P.maybe (P.Nothing) (\(_,_val11279) -> P.Just (case _val11279 of {T.TStruct _val11281 -> (to_SquareException (T.TStruct _val11281)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMembers_result _ = P.error "not a struct"
read_GetSquareMembers_result :: T.Protocol p => p -> P.IO GetSquareMembers_result
read_GetSquareMembers_result iprot = to_GetSquareMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMembers_result)
decode_GetSquareMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMembers_result
decode_GetSquareMembers_result iprot bs = to_GetSquareMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMembers_result) bs
typemap_GetSquareMembers_result :: T.TypeMap
typemap_GetSquareMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareMembers_result :: GetSquareMembers_result
default_GetSquareMembers_result = GetSquareMembers_result{
  getSquareMembers_result_success = default_GetSquareMembersResponse,
  getSquareMembers_result_e = P.Nothing}
data GetSquareMemberRelation_args = GetSquareMemberRelation_args  { getSquareMemberRelation_args_request :: GetSquareMemberRelationRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelation_args_request record  
instance QC.Arbitrary GetSquareMemberRelation_args where 
  arbitrary = M.liftM GetSquareMemberRelation_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelation_args{getSquareMemberRelation_args_request = getSquareMemberRelation_args_request obj} then P.Nothing else P.Just $ default_GetSquareMemberRelation_args{getSquareMemberRelation_args_request = getSquareMemberRelation_args_request obj}
    ]
from_GetSquareMemberRelation_args :: GetSquareMemberRelation_args -> T.ThriftVal
from_GetSquareMemberRelation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11284 -> P.Just (1, ("request",from_GetSquareMemberRelationRequest _v11284))) $ getSquareMemberRelation_args_request record
  ]
write_GetSquareMemberRelation_args :: T.Protocol p => p -> GetSquareMemberRelation_args -> P.IO ()
write_GetSquareMemberRelation_args oprot record = T.writeVal oprot $ from_GetSquareMemberRelation_args record
encode_GetSquareMemberRelation_args :: T.StatelessProtocol p => p -> GetSquareMemberRelation_args -> LBS.ByteString
encode_GetSquareMemberRelation_args oprot record = T.serializeVal oprot $ from_GetSquareMemberRelation_args record
to_GetSquareMemberRelation_args :: T.ThriftVal -> GetSquareMemberRelation_args
to_GetSquareMemberRelation_args (T.TStruct fields) = GetSquareMemberRelation_args{
  getSquareMemberRelation_args_request = P.maybe (getSquareMemberRelation_args_request default_GetSquareMemberRelation_args) (\(_,_val11286) -> (case _val11286 of {T.TStruct _val11287 -> (to_GetSquareMemberRelationRequest (T.TStruct _val11287)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMemberRelation_args _ = P.error "not a struct"
read_GetSquareMemberRelation_args :: T.Protocol p => p -> P.IO GetSquareMemberRelation_args
read_GetSquareMemberRelation_args iprot = to_GetSquareMemberRelation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelation_args)
decode_GetSquareMemberRelation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelation_args
decode_GetSquareMemberRelation_args iprot bs = to_GetSquareMemberRelation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelation_args) bs
typemap_GetSquareMemberRelation_args :: T.TypeMap
typemap_GetSquareMemberRelation_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareMemberRelationRequest)))]
default_GetSquareMemberRelation_args :: GetSquareMemberRelation_args
default_GetSquareMemberRelation_args = GetSquareMemberRelation_args{
  getSquareMemberRelation_args_request = default_GetSquareMemberRelationRequest}
data GetSquareMemberRelation_result = GetSquareMemberRelation_result  { getSquareMemberRelation_result_success :: GetSquareMemberRelationResponse
  , getSquareMemberRelation_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelation_result_success record   `H.hashWithSalt` getSquareMemberRelation_result_e record  
instance QC.Arbitrary GetSquareMemberRelation_result where 
  arbitrary = M.liftM GetSquareMemberRelation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelation_result{getSquareMemberRelation_result_success = getSquareMemberRelation_result_success obj} then P.Nothing else P.Just $ default_GetSquareMemberRelation_result{getSquareMemberRelation_result_success = getSquareMemberRelation_result_success obj}
    , if obj == default_GetSquareMemberRelation_result{getSquareMemberRelation_result_e = getSquareMemberRelation_result_e obj} then P.Nothing else P.Just $ default_GetSquareMemberRelation_result{getSquareMemberRelation_result_e = getSquareMemberRelation_result_e obj}
    ]
from_GetSquareMemberRelation_result :: GetSquareMemberRelation_result -> T.ThriftVal
from_GetSquareMemberRelation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11290 -> (1, ("e",from_SquareException _v11290))) <$> getSquareMemberRelation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11290 -> P.Just (0, ("success",from_GetSquareMemberRelationResponse _v11290))) $ getSquareMemberRelation_result_success record
    , (\_v11290 -> (1, ("e",from_SquareException _v11290))) <$> getSquareMemberRelation_result_e record
    ]
    )
write_GetSquareMemberRelation_result :: T.Protocol p => p -> GetSquareMemberRelation_result -> P.IO ()
write_GetSquareMemberRelation_result oprot record = T.writeVal oprot $ from_GetSquareMemberRelation_result record
encode_GetSquareMemberRelation_result :: T.StatelessProtocol p => p -> GetSquareMemberRelation_result -> LBS.ByteString
encode_GetSquareMemberRelation_result oprot record = T.serializeVal oprot $ from_GetSquareMemberRelation_result record
to_GetSquareMemberRelation_result :: T.ThriftVal -> GetSquareMemberRelation_result
to_GetSquareMemberRelation_result (T.TStruct fields) = GetSquareMemberRelation_result{
  getSquareMemberRelation_result_success = P.maybe (getSquareMemberRelation_result_success default_GetSquareMemberRelation_result) (\(_,_val11292) -> (case _val11292 of {T.TStruct _val11293 -> (to_GetSquareMemberRelationResponse (T.TStruct _val11293)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareMemberRelation_result_e = P.maybe (P.Nothing) (\(_,_val11292) -> P.Just (case _val11292 of {T.TStruct _val11294 -> (to_SquareException (T.TStruct _val11294)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMemberRelation_result _ = P.error "not a struct"
read_GetSquareMemberRelation_result :: T.Protocol p => p -> P.IO GetSquareMemberRelation_result
read_GetSquareMemberRelation_result iprot = to_GetSquareMemberRelation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelation_result)
decode_GetSquareMemberRelation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelation_result
decode_GetSquareMemberRelation_result iprot bs = to_GetSquareMemberRelation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelation_result) bs
typemap_GetSquareMemberRelation_result :: T.TypeMap
typemap_GetSquareMemberRelation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareMemberRelationResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareMemberRelation_result :: GetSquareMemberRelation_result
default_GetSquareMemberRelation_result = GetSquareMemberRelation_result{
  getSquareMemberRelation_result_success = default_GetSquareMemberRelationResponse,
  getSquareMemberRelation_result_e = P.Nothing}
data GetSquareMemberRelations_args = GetSquareMemberRelations_args  { getSquareMemberRelations_args_request :: GetSquareMemberRelationsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelations_args_request record  
instance QC.Arbitrary GetSquareMemberRelations_args where 
  arbitrary = M.liftM GetSquareMemberRelations_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelations_args{getSquareMemberRelations_args_request = getSquareMemberRelations_args_request obj} then P.Nothing else P.Just $ default_GetSquareMemberRelations_args{getSquareMemberRelations_args_request = getSquareMemberRelations_args_request obj}
    ]
from_GetSquareMemberRelations_args :: GetSquareMemberRelations_args -> T.ThriftVal
from_GetSquareMemberRelations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11297 -> P.Just (1, ("request",from_GetSquareMemberRelationsRequest _v11297))) $ getSquareMemberRelations_args_request record
  ]
write_GetSquareMemberRelations_args :: T.Protocol p => p -> GetSquareMemberRelations_args -> P.IO ()
write_GetSquareMemberRelations_args oprot record = T.writeVal oprot $ from_GetSquareMemberRelations_args record
encode_GetSquareMemberRelations_args :: T.StatelessProtocol p => p -> GetSquareMemberRelations_args -> LBS.ByteString
encode_GetSquareMemberRelations_args oprot record = T.serializeVal oprot $ from_GetSquareMemberRelations_args record
to_GetSquareMemberRelations_args :: T.ThriftVal -> GetSquareMemberRelations_args
to_GetSquareMemberRelations_args (T.TStruct fields) = GetSquareMemberRelations_args{
  getSquareMemberRelations_args_request = P.maybe (getSquareMemberRelations_args_request default_GetSquareMemberRelations_args) (\(_,_val11299) -> (case _val11299 of {T.TStruct _val11300 -> (to_GetSquareMemberRelationsRequest (T.TStruct _val11300)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMemberRelations_args _ = P.error "not a struct"
read_GetSquareMemberRelations_args :: T.Protocol p => p -> P.IO GetSquareMemberRelations_args
read_GetSquareMemberRelations_args iprot = to_GetSquareMemberRelations_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelations_args)
decode_GetSquareMemberRelations_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelations_args
decode_GetSquareMemberRelations_args iprot bs = to_GetSquareMemberRelations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelations_args) bs
typemap_GetSquareMemberRelations_args :: T.TypeMap
typemap_GetSquareMemberRelations_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareMemberRelationsRequest)))]
default_GetSquareMemberRelations_args :: GetSquareMemberRelations_args
default_GetSquareMemberRelations_args = GetSquareMemberRelations_args{
  getSquareMemberRelations_args_request = default_GetSquareMemberRelationsRequest}
data GetSquareMemberRelations_result = GetSquareMemberRelations_result  { getSquareMemberRelations_result_success :: GetSquareMemberRelationsResponse
  , getSquareMemberRelations_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareMemberRelations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareMemberRelations_result_success record   `H.hashWithSalt` getSquareMemberRelations_result_e record  
instance QC.Arbitrary GetSquareMemberRelations_result where 
  arbitrary = M.liftM GetSquareMemberRelations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareMemberRelations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareMemberRelations_result{getSquareMemberRelations_result_success = getSquareMemberRelations_result_success obj} then P.Nothing else P.Just $ default_GetSquareMemberRelations_result{getSquareMemberRelations_result_success = getSquareMemberRelations_result_success obj}
    , if obj == default_GetSquareMemberRelations_result{getSquareMemberRelations_result_e = getSquareMemberRelations_result_e obj} then P.Nothing else P.Just $ default_GetSquareMemberRelations_result{getSquareMemberRelations_result_e = getSquareMemberRelations_result_e obj}
    ]
from_GetSquareMemberRelations_result :: GetSquareMemberRelations_result -> T.ThriftVal
from_GetSquareMemberRelations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11303 -> (1, ("e",from_SquareException _v11303))) <$> getSquareMemberRelations_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11303 -> P.Just (0, ("success",from_GetSquareMemberRelationsResponse _v11303))) $ getSquareMemberRelations_result_success record
    , (\_v11303 -> (1, ("e",from_SquareException _v11303))) <$> getSquareMemberRelations_result_e record
    ]
    )
write_GetSquareMemberRelations_result :: T.Protocol p => p -> GetSquareMemberRelations_result -> P.IO ()
write_GetSquareMemberRelations_result oprot record = T.writeVal oprot $ from_GetSquareMemberRelations_result record
encode_GetSquareMemberRelations_result :: T.StatelessProtocol p => p -> GetSquareMemberRelations_result -> LBS.ByteString
encode_GetSquareMemberRelations_result oprot record = T.serializeVal oprot $ from_GetSquareMemberRelations_result record
to_GetSquareMemberRelations_result :: T.ThriftVal -> GetSquareMemberRelations_result
to_GetSquareMemberRelations_result (T.TStruct fields) = GetSquareMemberRelations_result{
  getSquareMemberRelations_result_success = P.maybe (getSquareMemberRelations_result_success default_GetSquareMemberRelations_result) (\(_,_val11305) -> (case _val11305 of {T.TStruct _val11306 -> (to_GetSquareMemberRelationsResponse (T.TStruct _val11306)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareMemberRelations_result_e = P.maybe (P.Nothing) (\(_,_val11305) -> P.Just (case _val11305 of {T.TStruct _val11307 -> (to_SquareException (T.TStruct _val11307)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareMemberRelations_result _ = P.error "not a struct"
read_GetSquareMemberRelations_result :: T.Protocol p => p -> P.IO GetSquareMemberRelations_result
read_GetSquareMemberRelations_result iprot = to_GetSquareMemberRelations_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareMemberRelations_result)
decode_GetSquareMemberRelations_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareMemberRelations_result
decode_GetSquareMemberRelations_result iprot bs = to_GetSquareMemberRelations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareMemberRelations_result) bs
typemap_GetSquareMemberRelations_result :: T.TypeMap
typemap_GetSquareMemberRelations_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareMemberRelationsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareMemberRelations_result :: GetSquareMemberRelations_result
default_GetSquareMemberRelations_result = GetSquareMemberRelations_result{
  getSquareMemberRelations_result_success = default_GetSquareMemberRelationsResponse,
  getSquareMemberRelations_result_e = P.Nothing}
data GetSquareChatMembers_args = GetSquareChatMembers_args  { getSquareChatMembers_args_request :: GetSquareChatMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatMembers_args_request record  
instance QC.Arbitrary GetSquareChatMembers_args where 
  arbitrary = M.liftM GetSquareChatMembers_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatMembers_args{getSquareChatMembers_args_request = getSquareChatMembers_args_request obj} then P.Nothing else P.Just $ default_GetSquareChatMembers_args{getSquareChatMembers_args_request = getSquareChatMembers_args_request obj}
    ]
from_GetSquareChatMembers_args :: GetSquareChatMembers_args -> T.ThriftVal
from_GetSquareChatMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11310 -> P.Just (1, ("request",from_GetSquareChatMembersRequest _v11310))) $ getSquareChatMembers_args_request record
  ]
write_GetSquareChatMembers_args :: T.Protocol p => p -> GetSquareChatMembers_args -> P.IO ()
write_GetSquareChatMembers_args oprot record = T.writeVal oprot $ from_GetSquareChatMembers_args record
encode_GetSquareChatMembers_args :: T.StatelessProtocol p => p -> GetSquareChatMembers_args -> LBS.ByteString
encode_GetSquareChatMembers_args oprot record = T.serializeVal oprot $ from_GetSquareChatMembers_args record
to_GetSquareChatMembers_args :: T.ThriftVal -> GetSquareChatMembers_args
to_GetSquareChatMembers_args (T.TStruct fields) = GetSquareChatMembers_args{
  getSquareChatMembers_args_request = P.maybe (getSquareChatMembers_args_request default_GetSquareChatMembers_args) (\(_,_val11312) -> (case _val11312 of {T.TStruct _val11313 -> (to_GetSquareChatMembersRequest (T.TStruct _val11313)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatMembers_args _ = P.error "not a struct"
read_GetSquareChatMembers_args :: T.Protocol p => p -> P.IO GetSquareChatMembers_args
read_GetSquareChatMembers_args iprot = to_GetSquareChatMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatMembers_args)
decode_GetSquareChatMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatMembers_args
decode_GetSquareChatMembers_args iprot bs = to_GetSquareChatMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatMembers_args) bs
typemap_GetSquareChatMembers_args :: T.TypeMap
typemap_GetSquareChatMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareChatMembersRequest)))]
default_GetSquareChatMembers_args :: GetSquareChatMembers_args
default_GetSquareChatMembers_args = GetSquareChatMembers_args{
  getSquareChatMembers_args_request = default_GetSquareChatMembersRequest}
data GetSquareChatMembers_result = GetSquareChatMembers_result  { getSquareChatMembers_result_success :: GetSquareChatMembersResponse
  , getSquareChatMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatMembers_result_success record   `H.hashWithSalt` getSquareChatMembers_result_e record  
instance QC.Arbitrary GetSquareChatMembers_result where 
  arbitrary = M.liftM GetSquareChatMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareChatMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatMembers_result{getSquareChatMembers_result_success = getSquareChatMembers_result_success obj} then P.Nothing else P.Just $ default_GetSquareChatMembers_result{getSquareChatMembers_result_success = getSquareChatMembers_result_success obj}
    , if obj == default_GetSquareChatMembers_result{getSquareChatMembers_result_e = getSquareChatMembers_result_e obj} then P.Nothing else P.Just $ default_GetSquareChatMembers_result{getSquareChatMembers_result_e = getSquareChatMembers_result_e obj}
    ]
from_GetSquareChatMembers_result :: GetSquareChatMembers_result -> T.ThriftVal
from_GetSquareChatMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11316 -> (1, ("e",from_SquareException _v11316))) <$> getSquareChatMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11316 -> P.Just (0, ("success",from_GetSquareChatMembersResponse _v11316))) $ getSquareChatMembers_result_success record
    , (\_v11316 -> (1, ("e",from_SquareException _v11316))) <$> getSquareChatMembers_result_e record
    ]
    )
write_GetSquareChatMembers_result :: T.Protocol p => p -> GetSquareChatMembers_result -> P.IO ()
write_GetSquareChatMembers_result oprot record = T.writeVal oprot $ from_GetSquareChatMembers_result record
encode_GetSquareChatMembers_result :: T.StatelessProtocol p => p -> GetSquareChatMembers_result -> LBS.ByteString
encode_GetSquareChatMembers_result oprot record = T.serializeVal oprot $ from_GetSquareChatMembers_result record
to_GetSquareChatMembers_result :: T.ThriftVal -> GetSquareChatMembers_result
to_GetSquareChatMembers_result (T.TStruct fields) = GetSquareChatMembers_result{
  getSquareChatMembers_result_success = P.maybe (getSquareChatMembers_result_success default_GetSquareChatMembers_result) (\(_,_val11318) -> (case _val11318 of {T.TStruct _val11319 -> (to_GetSquareChatMembersResponse (T.TStruct _val11319)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareChatMembers_result_e = P.maybe (P.Nothing) (\(_,_val11318) -> P.Just (case _val11318 of {T.TStruct _val11320 -> (to_SquareException (T.TStruct _val11320)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatMembers_result _ = P.error "not a struct"
read_GetSquareChatMembers_result :: T.Protocol p => p -> P.IO GetSquareChatMembers_result
read_GetSquareChatMembers_result iprot = to_GetSquareChatMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatMembers_result)
decode_GetSquareChatMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatMembers_result
decode_GetSquareChatMembers_result iprot bs = to_GetSquareChatMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatMembers_result) bs
typemap_GetSquareChatMembers_result :: T.TypeMap
typemap_GetSquareChatMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareChatMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareChatMembers_result :: GetSquareChatMembers_result
default_GetSquareChatMembers_result = GetSquareChatMembers_result{
  getSquareChatMembers_result_success = default_GetSquareChatMembersResponse,
  getSquareChatMembers_result_e = P.Nothing}
data GetSquareChatStatus_args = GetSquareChatStatus_args  { getSquareChatStatus_args_request :: GetSquareChatStatusRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatStatus_args_request record  
instance QC.Arbitrary GetSquareChatStatus_args where 
  arbitrary = M.liftM GetSquareChatStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareChatStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatStatus_args{getSquareChatStatus_args_request = getSquareChatStatus_args_request obj} then P.Nothing else P.Just $ default_GetSquareChatStatus_args{getSquareChatStatus_args_request = getSquareChatStatus_args_request obj}
    ]
from_GetSquareChatStatus_args :: GetSquareChatStatus_args -> T.ThriftVal
from_GetSquareChatStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11323 -> P.Just (1, ("request",from_GetSquareChatStatusRequest _v11323))) $ getSquareChatStatus_args_request record
  ]
write_GetSquareChatStatus_args :: T.Protocol p => p -> GetSquareChatStatus_args -> P.IO ()
write_GetSquareChatStatus_args oprot record = T.writeVal oprot $ from_GetSquareChatStatus_args record
encode_GetSquareChatStatus_args :: T.StatelessProtocol p => p -> GetSquareChatStatus_args -> LBS.ByteString
encode_GetSquareChatStatus_args oprot record = T.serializeVal oprot $ from_GetSquareChatStatus_args record
to_GetSquareChatStatus_args :: T.ThriftVal -> GetSquareChatStatus_args
to_GetSquareChatStatus_args (T.TStruct fields) = GetSquareChatStatus_args{
  getSquareChatStatus_args_request = P.maybe (getSquareChatStatus_args_request default_GetSquareChatStatus_args) (\(_,_val11325) -> (case _val11325 of {T.TStruct _val11326 -> (to_GetSquareChatStatusRequest (T.TStruct _val11326)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatStatus_args _ = P.error "not a struct"
read_GetSquareChatStatus_args :: T.Protocol p => p -> P.IO GetSquareChatStatus_args
read_GetSquareChatStatus_args iprot = to_GetSquareChatStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatStatus_args)
decode_GetSquareChatStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatStatus_args
decode_GetSquareChatStatus_args iprot bs = to_GetSquareChatStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatStatus_args) bs
typemap_GetSquareChatStatus_args :: T.TypeMap
typemap_GetSquareChatStatus_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareChatStatusRequest)))]
default_GetSquareChatStatus_args :: GetSquareChatStatus_args
default_GetSquareChatStatus_args = GetSquareChatStatus_args{
  getSquareChatStatus_args_request = default_GetSquareChatStatusRequest}
data GetSquareChatStatus_result = GetSquareChatStatus_result  { getSquareChatStatus_result_success :: GetSquareChatStatusResponse
  , getSquareChatStatus_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChatStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChatStatus_result_success record   `H.hashWithSalt` getSquareChatStatus_result_e record  
instance QC.Arbitrary GetSquareChatStatus_result where 
  arbitrary = M.liftM GetSquareChatStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareChatStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChatStatus_result{getSquareChatStatus_result_success = getSquareChatStatus_result_success obj} then P.Nothing else P.Just $ default_GetSquareChatStatus_result{getSquareChatStatus_result_success = getSquareChatStatus_result_success obj}
    , if obj == default_GetSquareChatStatus_result{getSquareChatStatus_result_e = getSquareChatStatus_result_e obj} then P.Nothing else P.Just $ default_GetSquareChatStatus_result{getSquareChatStatus_result_e = getSquareChatStatus_result_e obj}
    ]
from_GetSquareChatStatus_result :: GetSquareChatStatus_result -> T.ThriftVal
from_GetSquareChatStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11329 -> (1, ("e",from_SquareException _v11329))) <$> getSquareChatStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11329 -> P.Just (0, ("success",from_GetSquareChatStatusResponse _v11329))) $ getSquareChatStatus_result_success record
    , (\_v11329 -> (1, ("e",from_SquareException _v11329))) <$> getSquareChatStatus_result_e record
    ]
    )
write_GetSquareChatStatus_result :: T.Protocol p => p -> GetSquareChatStatus_result -> P.IO ()
write_GetSquareChatStatus_result oprot record = T.writeVal oprot $ from_GetSquareChatStatus_result record
encode_GetSquareChatStatus_result :: T.StatelessProtocol p => p -> GetSquareChatStatus_result -> LBS.ByteString
encode_GetSquareChatStatus_result oprot record = T.serializeVal oprot $ from_GetSquareChatStatus_result record
to_GetSquareChatStatus_result :: T.ThriftVal -> GetSquareChatStatus_result
to_GetSquareChatStatus_result (T.TStruct fields) = GetSquareChatStatus_result{
  getSquareChatStatus_result_success = P.maybe (getSquareChatStatus_result_success default_GetSquareChatStatus_result) (\(_,_val11331) -> (case _val11331 of {T.TStruct _val11332 -> (to_GetSquareChatStatusResponse (T.TStruct _val11332)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareChatStatus_result_e = P.maybe (P.Nothing) (\(_,_val11331) -> P.Just (case _val11331 of {T.TStruct _val11333 -> (to_SquareException (T.TStruct _val11333)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChatStatus_result _ = P.error "not a struct"
read_GetSquareChatStatus_result :: T.Protocol p => p -> P.IO GetSquareChatStatus_result
read_GetSquareChatStatus_result iprot = to_GetSquareChatStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChatStatus_result)
decode_GetSquareChatStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChatStatus_result
decode_GetSquareChatStatus_result iprot bs = to_GetSquareChatStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChatStatus_result) bs
typemap_GetSquareChatStatus_result :: T.TypeMap
typemap_GetSquareChatStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareChatStatusResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareChatStatus_result :: GetSquareChatStatus_result
default_GetSquareChatStatus_result = GetSquareChatStatus_result{
  getSquareChatStatus_result_success = default_GetSquareChatStatusResponse,
  getSquareChatStatus_result_e = P.Nothing}
data GetSquareChat_args = GetSquareChat_args  { getSquareChat_args_request :: GetSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChat_args_request record  
instance QC.Arbitrary GetSquareChat_args where 
  arbitrary = M.liftM GetSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_GetSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChat_args{getSquareChat_args_request = getSquareChat_args_request obj} then P.Nothing else P.Just $ default_GetSquareChat_args{getSquareChat_args_request = getSquareChat_args_request obj}
    ]
from_GetSquareChat_args :: GetSquareChat_args -> T.ThriftVal
from_GetSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11336 -> P.Just (1, ("request",from_GetSquareChatRequest _v11336))) $ getSquareChat_args_request record
  ]
write_GetSquareChat_args :: T.Protocol p => p -> GetSquareChat_args -> P.IO ()
write_GetSquareChat_args oprot record = T.writeVal oprot $ from_GetSquareChat_args record
encode_GetSquareChat_args :: T.StatelessProtocol p => p -> GetSquareChat_args -> LBS.ByteString
encode_GetSquareChat_args oprot record = T.serializeVal oprot $ from_GetSquareChat_args record
to_GetSquareChat_args :: T.ThriftVal -> GetSquareChat_args
to_GetSquareChat_args (T.TStruct fields) = GetSquareChat_args{
  getSquareChat_args_request = P.maybe (getSquareChat_args_request default_GetSquareChat_args) (\(_,_val11338) -> (case _val11338 of {T.TStruct _val11339 -> (to_GetSquareChatRequest (T.TStruct _val11339)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChat_args _ = P.error "not a struct"
read_GetSquareChat_args :: T.Protocol p => p -> P.IO GetSquareChat_args
read_GetSquareChat_args iprot = to_GetSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChat_args)
decode_GetSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChat_args
decode_GetSquareChat_args iprot bs = to_GetSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChat_args) bs
typemap_GetSquareChat_args :: T.TypeMap
typemap_GetSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareChatRequest)))]
default_GetSquareChat_args :: GetSquareChat_args
default_GetSquareChat_args = GetSquareChat_args{
  getSquareChat_args_request = default_GetSquareChatRequest}
data GetSquareChat_result = GetSquareChat_result  { getSquareChat_result_success :: GetSquareChatResponse
  , getSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquareChat_result_success record   `H.hashWithSalt` getSquareChat_result_e record  
instance QC.Arbitrary GetSquareChat_result where 
  arbitrary = M.liftM GetSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquareChat_result{getSquareChat_result_success = getSquareChat_result_success obj} then P.Nothing else P.Just $ default_GetSquareChat_result{getSquareChat_result_success = getSquareChat_result_success obj}
    , if obj == default_GetSquareChat_result{getSquareChat_result_e = getSquareChat_result_e obj} then P.Nothing else P.Just $ default_GetSquareChat_result{getSquareChat_result_e = getSquareChat_result_e obj}
    ]
from_GetSquareChat_result :: GetSquareChat_result -> T.ThriftVal
from_GetSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11342 -> (1, ("e",from_SquareException _v11342))) <$> getSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11342 -> P.Just (0, ("success",from_GetSquareChatResponse _v11342))) $ getSquareChat_result_success record
    , (\_v11342 -> (1, ("e",from_SquareException _v11342))) <$> getSquareChat_result_e record
    ]
    )
write_GetSquareChat_result :: T.Protocol p => p -> GetSquareChat_result -> P.IO ()
write_GetSquareChat_result oprot record = T.writeVal oprot $ from_GetSquareChat_result record
encode_GetSquareChat_result :: T.StatelessProtocol p => p -> GetSquareChat_result -> LBS.ByteString
encode_GetSquareChat_result oprot record = T.serializeVal oprot $ from_GetSquareChat_result record
to_GetSquareChat_result :: T.ThriftVal -> GetSquareChat_result
to_GetSquareChat_result (T.TStruct fields) = GetSquareChat_result{
  getSquareChat_result_success = P.maybe (getSquareChat_result_success default_GetSquareChat_result) (\(_,_val11344) -> (case _val11344 of {T.TStruct _val11345 -> (to_GetSquareChatResponse (T.TStruct _val11345)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11344) -> P.Just (case _val11344 of {T.TStruct _val11346 -> (to_SquareException (T.TStruct _val11346)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquareChat_result _ = P.error "not a struct"
read_GetSquareChat_result :: T.Protocol p => p -> P.IO GetSquareChat_result
read_GetSquareChat_result iprot = to_GetSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquareChat_result)
decode_GetSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquareChat_result
decode_GetSquareChat_result iprot bs = to_GetSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquareChat_result) bs
typemap_GetSquareChat_result :: T.TypeMap
typemap_GetSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquareChat_result :: GetSquareChat_result
default_GetSquareChat_result = GetSquareChat_result{
  getSquareChat_result_success = default_GetSquareChatResponse,
  getSquareChat_result_e = P.Nothing}
data GetSquare_args = GetSquare_args  { getSquare_args_request :: GetSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquare_args_request record  
instance QC.Arbitrary GetSquare_args where 
  arbitrary = M.liftM GetSquare_args (QC.arbitrary)
  shrink obj | obj == default_GetSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquare_args{getSquare_args_request = getSquare_args_request obj} then P.Nothing else P.Just $ default_GetSquare_args{getSquare_args_request = getSquare_args_request obj}
    ]
from_GetSquare_args :: GetSquare_args -> T.ThriftVal
from_GetSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11349 -> P.Just (1, ("request",from_GetSquareRequest _v11349))) $ getSquare_args_request record
  ]
write_GetSquare_args :: T.Protocol p => p -> GetSquare_args -> P.IO ()
write_GetSquare_args oprot record = T.writeVal oprot $ from_GetSquare_args record
encode_GetSquare_args :: T.StatelessProtocol p => p -> GetSquare_args -> LBS.ByteString
encode_GetSquare_args oprot record = T.serializeVal oprot $ from_GetSquare_args record
to_GetSquare_args :: T.ThriftVal -> GetSquare_args
to_GetSquare_args (T.TStruct fields) = GetSquare_args{
  getSquare_args_request = P.maybe (getSquare_args_request default_GetSquare_args) (\(_,_val11351) -> (case _val11351 of {T.TStruct _val11352 -> (to_GetSquareRequest (T.TStruct _val11352)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquare_args _ = P.error "not a struct"
read_GetSquare_args :: T.Protocol p => p -> P.IO GetSquare_args
read_GetSquare_args iprot = to_GetSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSquare_args)
decode_GetSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquare_args
decode_GetSquare_args iprot bs = to_GetSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquare_args) bs
typemap_GetSquare_args :: T.TypeMap
typemap_GetSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetSquareRequest)))]
default_GetSquare_args :: GetSquare_args
default_GetSquare_args = GetSquare_args{
  getSquare_args_request = default_GetSquareRequest}
data GetSquare_result = GetSquare_result  { getSquare_result_success :: GetSquareResponse
  , getSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSquare_result_success record   `H.hashWithSalt` getSquare_result_e record  
instance QC.Arbitrary GetSquare_result where 
  arbitrary = M.liftM GetSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSquare_result{getSquare_result_success = getSquare_result_success obj} then P.Nothing else P.Just $ default_GetSquare_result{getSquare_result_success = getSquare_result_success obj}
    , if obj == default_GetSquare_result{getSquare_result_e = getSquare_result_e obj} then P.Nothing else P.Just $ default_GetSquare_result{getSquare_result_e = getSquare_result_e obj}
    ]
from_GetSquare_result :: GetSquare_result -> T.ThriftVal
from_GetSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11355 -> (1, ("e",from_SquareException _v11355))) <$> getSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11355 -> P.Just (0, ("success",from_GetSquareResponse _v11355))) $ getSquare_result_success record
    , (\_v11355 -> (1, ("e",from_SquareException _v11355))) <$> getSquare_result_e record
    ]
    )
write_GetSquare_result :: T.Protocol p => p -> GetSquare_result -> P.IO ()
write_GetSquare_result oprot record = T.writeVal oprot $ from_GetSquare_result record
encode_GetSquare_result :: T.StatelessProtocol p => p -> GetSquare_result -> LBS.ByteString
encode_GetSquare_result oprot record = T.serializeVal oprot $ from_GetSquare_result record
to_GetSquare_result :: T.ThriftVal -> GetSquare_result
to_GetSquare_result (T.TStruct fields) = GetSquare_result{
  getSquare_result_success = P.maybe (getSquare_result_success default_GetSquare_result) (\(_,_val11357) -> (case _val11357 of {T.TStruct _val11358 -> (to_GetSquareResponse (T.TStruct _val11358)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSquare_result_e = P.maybe (P.Nothing) (\(_,_val11357) -> P.Just (case _val11357 of {T.TStruct _val11359 -> (to_SquareException (T.TStruct _val11359)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSquare_result _ = P.error "not a struct"
read_GetSquare_result :: T.Protocol p => p -> P.IO GetSquare_result
read_GetSquare_result iprot = to_GetSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSquare_result)
decode_GetSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSquare_result
decode_GetSquare_result iprot bs = to_GetSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSquare_result) bs
typemap_GetSquare_result :: T.TypeMap
typemap_GetSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetSquare_result :: GetSquare_result
default_GetSquare_result = GetSquare_result{
  getSquare_result_success = default_GetSquareResponse,
  getSquare_result_e = P.Nothing}
data GetJoinedSquares_args = GetJoinedSquares_args  { getJoinedSquares_args_request :: GetJoinedSquaresRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquares_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquares_args_request record  
instance QC.Arbitrary GetJoinedSquares_args where 
  arbitrary = M.liftM GetJoinedSquares_args (QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquares_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquares_args{getJoinedSquares_args_request = getJoinedSquares_args_request obj} then P.Nothing else P.Just $ default_GetJoinedSquares_args{getJoinedSquares_args_request = getJoinedSquares_args_request obj}
    ]
from_GetJoinedSquares_args :: GetJoinedSquares_args -> T.ThriftVal
from_GetJoinedSquares_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11362 -> P.Just (1, ("request",from_GetJoinedSquaresRequest _v11362))) $ getJoinedSquares_args_request record
  ]
write_GetJoinedSquares_args :: T.Protocol p => p -> GetJoinedSquares_args -> P.IO ()
write_GetJoinedSquares_args oprot record = T.writeVal oprot $ from_GetJoinedSquares_args record
encode_GetJoinedSquares_args :: T.StatelessProtocol p => p -> GetJoinedSquares_args -> LBS.ByteString
encode_GetJoinedSquares_args oprot record = T.serializeVal oprot $ from_GetJoinedSquares_args record
to_GetJoinedSquares_args :: T.ThriftVal -> GetJoinedSquares_args
to_GetJoinedSquares_args (T.TStruct fields) = GetJoinedSquares_args{
  getJoinedSquares_args_request = P.maybe (getJoinedSquares_args_request default_GetJoinedSquares_args) (\(_,_val11364) -> (case _val11364 of {T.TStruct _val11365 -> (to_GetJoinedSquaresRequest (T.TStruct _val11365)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedSquares_args _ = P.error "not a struct"
read_GetJoinedSquares_args :: T.Protocol p => p -> P.IO GetJoinedSquares_args
read_GetJoinedSquares_args iprot = to_GetJoinedSquares_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquares_args)
decode_GetJoinedSquares_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquares_args
decode_GetJoinedSquares_args iprot bs = to_GetJoinedSquares_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquares_args) bs
typemap_GetJoinedSquares_args :: T.TypeMap
typemap_GetJoinedSquares_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetJoinedSquaresRequest)))]
default_GetJoinedSquares_args :: GetJoinedSquares_args
default_GetJoinedSquares_args = GetJoinedSquares_args{
  getJoinedSquares_args_request = default_GetJoinedSquaresRequest}
data GetJoinedSquares_result = GetJoinedSquares_result  { getJoinedSquares_result_success :: GetJoinedSquaresResponse
  , getJoinedSquares_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquares_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquares_result_success record   `H.hashWithSalt` getJoinedSquares_result_e record  
instance QC.Arbitrary GetJoinedSquares_result where 
  arbitrary = M.liftM GetJoinedSquares_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquares_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquares_result{getJoinedSquares_result_success = getJoinedSquares_result_success obj} then P.Nothing else P.Just $ default_GetJoinedSquares_result{getJoinedSquares_result_success = getJoinedSquares_result_success obj}
    , if obj == default_GetJoinedSquares_result{getJoinedSquares_result_e = getJoinedSquares_result_e obj} then P.Nothing else P.Just $ default_GetJoinedSquares_result{getJoinedSquares_result_e = getJoinedSquares_result_e obj}
    ]
from_GetJoinedSquares_result :: GetJoinedSquares_result -> T.ThriftVal
from_GetJoinedSquares_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11368 -> (1, ("e",from_SquareException _v11368))) <$> getJoinedSquares_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11368 -> P.Just (0, ("success",from_GetJoinedSquaresResponse _v11368))) $ getJoinedSquares_result_success record
    , (\_v11368 -> (1, ("e",from_SquareException _v11368))) <$> getJoinedSquares_result_e record
    ]
    )
write_GetJoinedSquares_result :: T.Protocol p => p -> GetJoinedSquares_result -> P.IO ()
write_GetJoinedSquares_result oprot record = T.writeVal oprot $ from_GetJoinedSquares_result record
encode_GetJoinedSquares_result :: T.StatelessProtocol p => p -> GetJoinedSquares_result -> LBS.ByteString
encode_GetJoinedSquares_result oprot record = T.serializeVal oprot $ from_GetJoinedSquares_result record
to_GetJoinedSquares_result :: T.ThriftVal -> GetJoinedSquares_result
to_GetJoinedSquares_result (T.TStruct fields) = GetJoinedSquares_result{
  getJoinedSquares_result_success = P.maybe (getJoinedSquares_result_success default_GetJoinedSquares_result) (\(_,_val11370) -> (case _val11370 of {T.TStruct _val11371 -> (to_GetJoinedSquaresResponse (T.TStruct _val11371)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedSquares_result_e = P.maybe (P.Nothing) (\(_,_val11370) -> P.Just (case _val11370 of {T.TStruct _val11372 -> (to_SquareException (T.TStruct _val11372)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedSquares_result _ = P.error "not a struct"
read_GetJoinedSquares_result :: T.Protocol p => p -> P.IO GetJoinedSquares_result
read_GetJoinedSquares_result iprot = to_GetJoinedSquares_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquares_result)
decode_GetJoinedSquares_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquares_result
decode_GetJoinedSquares_result iprot bs = to_GetJoinedSquares_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquares_result) bs
typemap_GetJoinedSquares_result :: T.TypeMap
typemap_GetJoinedSquares_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetJoinedSquaresResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetJoinedSquares_result :: GetJoinedSquares_result
default_GetJoinedSquares_result = GetJoinedSquares_result{
  getJoinedSquares_result_success = default_GetJoinedSquaresResponse,
  getJoinedSquares_result_e = P.Nothing}
data GetJoinedSquareChats_args = GetJoinedSquareChats_args  { getJoinedSquareChats_args_request :: GetJoinedSquareChatsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquareChats_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquareChats_args_request record  
instance QC.Arbitrary GetJoinedSquareChats_args where 
  arbitrary = M.liftM GetJoinedSquareChats_args (QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquareChats_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquareChats_args{getJoinedSquareChats_args_request = getJoinedSquareChats_args_request obj} then P.Nothing else P.Just $ default_GetJoinedSquareChats_args{getJoinedSquareChats_args_request = getJoinedSquareChats_args_request obj}
    ]
from_GetJoinedSquareChats_args :: GetJoinedSquareChats_args -> T.ThriftVal
from_GetJoinedSquareChats_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11375 -> P.Just (1, ("request",from_GetJoinedSquareChatsRequest _v11375))) $ getJoinedSquareChats_args_request record
  ]
write_GetJoinedSquareChats_args :: T.Protocol p => p -> GetJoinedSquareChats_args -> P.IO ()
write_GetJoinedSquareChats_args oprot record = T.writeVal oprot $ from_GetJoinedSquareChats_args record
encode_GetJoinedSquareChats_args :: T.StatelessProtocol p => p -> GetJoinedSquareChats_args -> LBS.ByteString
encode_GetJoinedSquareChats_args oprot record = T.serializeVal oprot $ from_GetJoinedSquareChats_args record
to_GetJoinedSquareChats_args :: T.ThriftVal -> GetJoinedSquareChats_args
to_GetJoinedSquareChats_args (T.TStruct fields) = GetJoinedSquareChats_args{
  getJoinedSquareChats_args_request = P.maybe (getJoinedSquareChats_args_request default_GetJoinedSquareChats_args) (\(_,_val11377) -> (case _val11377 of {T.TStruct _val11378 -> (to_GetJoinedSquareChatsRequest (T.TStruct _val11378)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedSquareChats_args _ = P.error "not a struct"
read_GetJoinedSquareChats_args :: T.Protocol p => p -> P.IO GetJoinedSquareChats_args
read_GetJoinedSquareChats_args iprot = to_GetJoinedSquareChats_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquareChats_args)
decode_GetJoinedSquareChats_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquareChats_args
decode_GetJoinedSquareChats_args iprot bs = to_GetJoinedSquareChats_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquareChats_args) bs
typemap_GetJoinedSquareChats_args :: T.TypeMap
typemap_GetJoinedSquareChats_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetJoinedSquareChatsRequest)))]
default_GetJoinedSquareChats_args :: GetJoinedSquareChats_args
default_GetJoinedSquareChats_args = GetJoinedSquareChats_args{
  getJoinedSquareChats_args_request = default_GetJoinedSquareChatsRequest}
data GetJoinedSquareChats_result = GetJoinedSquareChats_result  { getJoinedSquareChats_result_success :: GetJoinedSquareChatsResponse
  , getJoinedSquareChats_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedSquareChats_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedSquareChats_result_success record   `H.hashWithSalt` getJoinedSquareChats_result_e record  
instance QC.Arbitrary GetJoinedSquareChats_result where 
  arbitrary = M.liftM GetJoinedSquareChats_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedSquareChats_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedSquareChats_result{getJoinedSquareChats_result_success = getJoinedSquareChats_result_success obj} then P.Nothing else P.Just $ default_GetJoinedSquareChats_result{getJoinedSquareChats_result_success = getJoinedSquareChats_result_success obj}
    , if obj == default_GetJoinedSquareChats_result{getJoinedSquareChats_result_e = getJoinedSquareChats_result_e obj} then P.Nothing else P.Just $ default_GetJoinedSquareChats_result{getJoinedSquareChats_result_e = getJoinedSquareChats_result_e obj}
    ]
from_GetJoinedSquareChats_result :: GetJoinedSquareChats_result -> T.ThriftVal
from_GetJoinedSquareChats_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11381 -> (1, ("e",from_SquareException _v11381))) <$> getJoinedSquareChats_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11381 -> P.Just (0, ("success",from_GetJoinedSquareChatsResponse _v11381))) $ getJoinedSquareChats_result_success record
    , (\_v11381 -> (1, ("e",from_SquareException _v11381))) <$> getJoinedSquareChats_result_e record
    ]
    )
write_GetJoinedSquareChats_result :: T.Protocol p => p -> GetJoinedSquareChats_result -> P.IO ()
write_GetJoinedSquareChats_result oprot record = T.writeVal oprot $ from_GetJoinedSquareChats_result record
encode_GetJoinedSquareChats_result :: T.StatelessProtocol p => p -> GetJoinedSquareChats_result -> LBS.ByteString
encode_GetJoinedSquareChats_result oprot record = T.serializeVal oprot $ from_GetJoinedSquareChats_result record
to_GetJoinedSquareChats_result :: T.ThriftVal -> GetJoinedSquareChats_result
to_GetJoinedSquareChats_result (T.TStruct fields) = GetJoinedSquareChats_result{
  getJoinedSquareChats_result_success = P.maybe (getJoinedSquareChats_result_success default_GetJoinedSquareChats_result) (\(_,_val11383) -> (case _val11383 of {T.TStruct _val11384 -> (to_GetJoinedSquareChatsResponse (T.TStruct _val11384)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedSquareChats_result_e = P.maybe (P.Nothing) (\(_,_val11383) -> P.Just (case _val11383 of {T.TStruct _val11385 -> (to_SquareException (T.TStruct _val11385)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedSquareChats_result _ = P.error "not a struct"
read_GetJoinedSquareChats_result :: T.Protocol p => p -> P.IO GetJoinedSquareChats_result
read_GetJoinedSquareChats_result iprot = to_GetJoinedSquareChats_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedSquareChats_result)
decode_GetJoinedSquareChats_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedSquareChats_result
decode_GetJoinedSquareChats_result iprot bs = to_GetJoinedSquareChats_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedSquareChats_result) bs
typemap_GetJoinedSquareChats_result :: T.TypeMap
typemap_GetJoinedSquareChats_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetJoinedSquareChatsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetJoinedSquareChats_result :: GetJoinedSquareChats_result
default_GetJoinedSquareChats_result = GetJoinedSquareChats_result{
  getJoinedSquareChats_result_success = default_GetJoinedSquareChatsResponse,
  getJoinedSquareChats_result_e = P.Nothing}
data ApproveSquareMembers_args = ApproveSquareMembers_args  { approveSquareMembers_args_request :: ApproveSquareMembersRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveSquareMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveSquareMembers_args_request record  
instance QC.Arbitrary ApproveSquareMembers_args where 
  arbitrary = M.liftM ApproveSquareMembers_args (QC.arbitrary)
  shrink obj | obj == default_ApproveSquareMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveSquareMembers_args{approveSquareMembers_args_request = approveSquareMembers_args_request obj} then P.Nothing else P.Just $ default_ApproveSquareMembers_args{approveSquareMembers_args_request = approveSquareMembers_args_request obj}
    ]
from_ApproveSquareMembers_args :: ApproveSquareMembers_args -> T.ThriftVal
from_ApproveSquareMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11388 -> P.Just (1, ("request",from_ApproveSquareMembersRequest _v11388))) $ approveSquareMembers_args_request record
  ]
write_ApproveSquareMembers_args :: T.Protocol p => p -> ApproveSquareMembers_args -> P.IO ()
write_ApproveSquareMembers_args oprot record = T.writeVal oprot $ from_ApproveSquareMembers_args record
encode_ApproveSquareMembers_args :: T.StatelessProtocol p => p -> ApproveSquareMembers_args -> LBS.ByteString
encode_ApproveSquareMembers_args oprot record = T.serializeVal oprot $ from_ApproveSquareMembers_args record
to_ApproveSquareMembers_args :: T.ThriftVal -> ApproveSquareMembers_args
to_ApproveSquareMembers_args (T.TStruct fields) = ApproveSquareMembers_args{
  approveSquareMembers_args_request = P.maybe (approveSquareMembers_args_request default_ApproveSquareMembers_args) (\(_,_val11390) -> (case _val11390 of {T.TStruct _val11391 -> (to_ApproveSquareMembersRequest (T.TStruct _val11391)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveSquareMembers_args _ = P.error "not a struct"
read_ApproveSquareMembers_args :: T.Protocol p => p -> P.IO ApproveSquareMembers_args
read_ApproveSquareMembers_args iprot = to_ApproveSquareMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_ApproveSquareMembers_args)
decode_ApproveSquareMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveSquareMembers_args
decode_ApproveSquareMembers_args iprot bs = to_ApproveSquareMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveSquareMembers_args) bs
typemap_ApproveSquareMembers_args :: T.TypeMap
typemap_ApproveSquareMembers_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_ApproveSquareMembersRequest)))]
default_ApproveSquareMembers_args :: ApproveSquareMembers_args
default_ApproveSquareMembers_args = ApproveSquareMembers_args{
  approveSquareMembers_args_request = default_ApproveSquareMembersRequest}
data ApproveSquareMembers_result = ApproveSquareMembers_result  { approveSquareMembers_result_success :: ApproveSquareMembersResponse
  , approveSquareMembers_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ApproveSquareMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` approveSquareMembers_result_success record   `H.hashWithSalt` approveSquareMembers_result_e record  
instance QC.Arbitrary ApproveSquareMembers_result where 
  arbitrary = M.liftM ApproveSquareMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ApproveSquareMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ApproveSquareMembers_result{approveSquareMembers_result_success = approveSquareMembers_result_success obj} then P.Nothing else P.Just $ default_ApproveSquareMembers_result{approveSquareMembers_result_success = approveSquareMembers_result_success obj}
    , if obj == default_ApproveSquareMembers_result{approveSquareMembers_result_e = approveSquareMembers_result_e obj} then P.Nothing else P.Just $ default_ApproveSquareMembers_result{approveSquareMembers_result_e = approveSquareMembers_result_e obj}
    ]
from_ApproveSquareMembers_result :: ApproveSquareMembers_result -> T.ThriftVal
from_ApproveSquareMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11394 -> (1, ("e",from_SquareException _v11394))) <$> approveSquareMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11394 -> P.Just (0, ("success",from_ApproveSquareMembersResponse _v11394))) $ approveSquareMembers_result_success record
    , (\_v11394 -> (1, ("e",from_SquareException _v11394))) <$> approveSquareMembers_result_e record
    ]
    )
write_ApproveSquareMembers_result :: T.Protocol p => p -> ApproveSquareMembers_result -> P.IO ()
write_ApproveSquareMembers_result oprot record = T.writeVal oprot $ from_ApproveSquareMembers_result record
encode_ApproveSquareMembers_result :: T.StatelessProtocol p => p -> ApproveSquareMembers_result -> LBS.ByteString
encode_ApproveSquareMembers_result oprot record = T.serializeVal oprot $ from_ApproveSquareMembers_result record
to_ApproveSquareMembers_result :: T.ThriftVal -> ApproveSquareMembers_result
to_ApproveSquareMembers_result (T.TStruct fields) = ApproveSquareMembers_result{
  approveSquareMembers_result_success = P.maybe (approveSquareMembers_result_success default_ApproveSquareMembers_result) (\(_,_val11396) -> (case _val11396 of {T.TStruct _val11397 -> (to_ApproveSquareMembersResponse (T.TStruct _val11397)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  approveSquareMembers_result_e = P.maybe (P.Nothing) (\(_,_val11396) -> P.Just (case _val11396 of {T.TStruct _val11398 -> (to_SquareException (T.TStruct _val11398)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ApproveSquareMembers_result _ = P.error "not a struct"
read_ApproveSquareMembers_result :: T.Protocol p => p -> P.IO ApproveSquareMembers_result
read_ApproveSquareMembers_result iprot = to_ApproveSquareMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_ApproveSquareMembers_result)
decode_ApproveSquareMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ApproveSquareMembers_result
decode_ApproveSquareMembers_result iprot bs = to_ApproveSquareMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ApproveSquareMembers_result) bs
typemap_ApproveSquareMembers_result :: T.TypeMap
typemap_ApproveSquareMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ApproveSquareMembersResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_ApproveSquareMembers_result :: ApproveSquareMembers_result
default_ApproveSquareMembers_result = ApproveSquareMembers_result{
  approveSquareMembers_result_success = default_ApproveSquareMembersResponse,
  approveSquareMembers_result_e = P.Nothing}
data CreateSquareChat_args = CreateSquareChat_args  { createSquareChat_args_request :: CreateSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChat_args_request record  
instance QC.Arbitrary CreateSquareChat_args where 
  arbitrary = M.liftM CreateSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_CreateSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChat_args{createSquareChat_args_request = createSquareChat_args_request obj} then P.Nothing else P.Just $ default_CreateSquareChat_args{createSquareChat_args_request = createSquareChat_args_request obj}
    ]
from_CreateSquareChat_args :: CreateSquareChat_args -> T.ThriftVal
from_CreateSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11401 -> P.Just (1, ("request",from_CreateSquareChatRequest _v11401))) $ createSquareChat_args_request record
  ]
write_CreateSquareChat_args :: T.Protocol p => p -> CreateSquareChat_args -> P.IO ()
write_CreateSquareChat_args oprot record = T.writeVal oprot $ from_CreateSquareChat_args record
encode_CreateSquareChat_args :: T.StatelessProtocol p => p -> CreateSquareChat_args -> LBS.ByteString
encode_CreateSquareChat_args oprot record = T.serializeVal oprot $ from_CreateSquareChat_args record
to_CreateSquareChat_args :: T.ThriftVal -> CreateSquareChat_args
to_CreateSquareChat_args (T.TStruct fields) = CreateSquareChat_args{
  createSquareChat_args_request = P.maybe (createSquareChat_args_request default_CreateSquareChat_args) (\(_,_val11403) -> (case _val11403 of {T.TStruct _val11404 -> (to_CreateSquareChatRequest (T.TStruct _val11404)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquareChat_args _ = P.error "not a struct"
read_CreateSquareChat_args :: T.Protocol p => p -> P.IO CreateSquareChat_args
read_CreateSquareChat_args iprot = to_CreateSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChat_args)
decode_CreateSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChat_args
decode_CreateSquareChat_args iprot bs = to_CreateSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChat_args) bs
typemap_CreateSquareChat_args :: T.TypeMap
typemap_CreateSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_CreateSquareChatRequest)))]
default_CreateSquareChat_args :: CreateSquareChat_args
default_CreateSquareChat_args = CreateSquareChat_args{
  createSquareChat_args_request = default_CreateSquareChatRequest}
data CreateSquareChat_result = CreateSquareChat_result  { createSquareChat_result_success :: CreateSquareChatResponse
  , createSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquareChat_result_success record   `H.hashWithSalt` createSquareChat_result_e record  
instance QC.Arbitrary CreateSquareChat_result where 
  arbitrary = M.liftM CreateSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquareChat_result{createSquareChat_result_success = createSquareChat_result_success obj} then P.Nothing else P.Just $ default_CreateSquareChat_result{createSquareChat_result_success = createSquareChat_result_success obj}
    , if obj == default_CreateSquareChat_result{createSquareChat_result_e = createSquareChat_result_e obj} then P.Nothing else P.Just $ default_CreateSquareChat_result{createSquareChat_result_e = createSquareChat_result_e obj}
    ]
from_CreateSquareChat_result :: CreateSquareChat_result -> T.ThriftVal
from_CreateSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11407 -> (1, ("e",from_SquareException _v11407))) <$> createSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11407 -> P.Just (0, ("success",from_CreateSquareChatResponse _v11407))) $ createSquareChat_result_success record
    , (\_v11407 -> (1, ("e",from_SquareException _v11407))) <$> createSquareChat_result_e record
    ]
    )
write_CreateSquareChat_result :: T.Protocol p => p -> CreateSquareChat_result -> P.IO ()
write_CreateSquareChat_result oprot record = T.writeVal oprot $ from_CreateSquareChat_result record
encode_CreateSquareChat_result :: T.StatelessProtocol p => p -> CreateSquareChat_result -> LBS.ByteString
encode_CreateSquareChat_result oprot record = T.serializeVal oprot $ from_CreateSquareChat_result record
to_CreateSquareChat_result :: T.ThriftVal -> CreateSquareChat_result
to_CreateSquareChat_result (T.TStruct fields) = CreateSquareChat_result{
  createSquareChat_result_success = P.maybe (createSquareChat_result_success default_CreateSquareChat_result) (\(_,_val11409) -> (case _val11409 of {T.TStruct _val11410 -> (to_CreateSquareChatResponse (T.TStruct _val11410)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11409) -> P.Just (case _val11409 of {T.TStruct _val11411 -> (to_SquareException (T.TStruct _val11411)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquareChat_result _ = P.error "not a struct"
read_CreateSquareChat_result :: T.Protocol p => p -> P.IO CreateSquareChat_result
read_CreateSquareChat_result iprot = to_CreateSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquareChat_result)
decode_CreateSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquareChat_result
decode_CreateSquareChat_result iprot bs = to_CreateSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquareChat_result) bs
typemap_CreateSquareChat_result :: T.TypeMap
typemap_CreateSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CreateSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_CreateSquareChat_result :: CreateSquareChat_result
default_CreateSquareChat_result = CreateSquareChat_result{
  createSquareChat_result_success = default_CreateSquareChatResponse,
  createSquareChat_result_e = P.Nothing}
data CreateSquare_args = CreateSquare_args  { createSquare_args_request :: CreateSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquare_args_request record  
instance QC.Arbitrary CreateSquare_args where 
  arbitrary = M.liftM CreateSquare_args (QC.arbitrary)
  shrink obj | obj == default_CreateSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquare_args{createSquare_args_request = createSquare_args_request obj} then P.Nothing else P.Just $ default_CreateSquare_args{createSquare_args_request = createSquare_args_request obj}
    ]
from_CreateSquare_args :: CreateSquare_args -> T.ThriftVal
from_CreateSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11414 -> P.Just (1, ("request",from_CreateSquareRequest _v11414))) $ createSquare_args_request record
  ]
write_CreateSquare_args :: T.Protocol p => p -> CreateSquare_args -> P.IO ()
write_CreateSquare_args oprot record = T.writeVal oprot $ from_CreateSquare_args record
encode_CreateSquare_args :: T.StatelessProtocol p => p -> CreateSquare_args -> LBS.ByteString
encode_CreateSquare_args oprot record = T.serializeVal oprot $ from_CreateSquare_args record
to_CreateSquare_args :: T.ThriftVal -> CreateSquare_args
to_CreateSquare_args (T.TStruct fields) = CreateSquare_args{
  createSquare_args_request = P.maybe (createSquare_args_request default_CreateSquare_args) (\(_,_val11416) -> (case _val11416 of {T.TStruct _val11417 -> (to_CreateSquareRequest (T.TStruct _val11417)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquare_args _ = P.error "not a struct"
read_CreateSquare_args :: T.Protocol p => p -> P.IO CreateSquare_args
read_CreateSquare_args iprot = to_CreateSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquare_args)
decode_CreateSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquare_args
decode_CreateSquare_args iprot bs = to_CreateSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquare_args) bs
typemap_CreateSquare_args :: T.TypeMap
typemap_CreateSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_CreateSquareRequest)))]
default_CreateSquare_args :: CreateSquare_args
default_CreateSquare_args = CreateSquare_args{
  createSquare_args_request = default_CreateSquareRequest}
data CreateSquare_result = CreateSquare_result  { createSquare_result_success :: CreateSquareResponse
  , createSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSquare_result_success record   `H.hashWithSalt` createSquare_result_e record  
instance QC.Arbitrary CreateSquare_result where 
  arbitrary = M.liftM CreateSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSquare_result{createSquare_result_success = createSquare_result_success obj} then P.Nothing else P.Just $ default_CreateSquare_result{createSquare_result_success = createSquare_result_success obj}
    , if obj == default_CreateSquare_result{createSquare_result_e = createSquare_result_e obj} then P.Nothing else P.Just $ default_CreateSquare_result{createSquare_result_e = createSquare_result_e obj}
    ]
from_CreateSquare_result :: CreateSquare_result -> T.ThriftVal
from_CreateSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11420 -> (1, ("e",from_SquareException _v11420))) <$> createSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11420 -> P.Just (0, ("success",from_CreateSquareResponse _v11420))) $ createSquare_result_success record
    , (\_v11420 -> (1, ("e",from_SquareException _v11420))) <$> createSquare_result_e record
    ]
    )
write_CreateSquare_result :: T.Protocol p => p -> CreateSquare_result -> P.IO ()
write_CreateSquare_result oprot record = T.writeVal oprot $ from_CreateSquare_result record
encode_CreateSquare_result :: T.StatelessProtocol p => p -> CreateSquare_result -> LBS.ByteString
encode_CreateSquare_result oprot record = T.serializeVal oprot $ from_CreateSquare_result record
to_CreateSquare_result :: T.ThriftVal -> CreateSquare_result
to_CreateSquare_result (T.TStruct fields) = CreateSquare_result{
  createSquare_result_success = P.maybe (createSquare_result_success default_CreateSquare_result) (\(_,_val11422) -> (case _val11422 of {T.TStruct _val11423 -> (to_CreateSquareResponse (T.TStruct _val11423)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSquare_result_e = P.maybe (P.Nothing) (\(_,_val11422) -> P.Just (case _val11422 of {T.TStruct _val11424 -> (to_SquareException (T.TStruct _val11424)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSquare_result _ = P.error "not a struct"
read_CreateSquare_result :: T.Protocol p => p -> P.IO CreateSquare_result
read_CreateSquare_result iprot = to_CreateSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSquare_result)
decode_CreateSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSquare_result
decode_CreateSquare_result iprot bs = to_CreateSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSquare_result) bs
typemap_CreateSquare_result :: T.TypeMap
typemap_CreateSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CreateSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_CreateSquare_result :: CreateSquare_result
default_CreateSquare_result = CreateSquare_result{
  createSquare_result_success = default_CreateSquareResponse,
  createSquare_result_e = P.Nothing}
data DeleteSquareChat_args = DeleteSquareChat_args  { deleteSquareChat_args_request :: DeleteSquareChatRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChat_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChat_args_request record  
instance QC.Arbitrary DeleteSquareChat_args where 
  arbitrary = M.liftM DeleteSquareChat_args (QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChat_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChat_args{deleteSquareChat_args_request = deleteSquareChat_args_request obj} then P.Nothing else P.Just $ default_DeleteSquareChat_args{deleteSquareChat_args_request = deleteSquareChat_args_request obj}
    ]
from_DeleteSquareChat_args :: DeleteSquareChat_args -> T.ThriftVal
from_DeleteSquareChat_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11427 -> P.Just (1, ("request",from_DeleteSquareChatRequest _v11427))) $ deleteSquareChat_args_request record
  ]
write_DeleteSquareChat_args :: T.Protocol p => p -> DeleteSquareChat_args -> P.IO ()
write_DeleteSquareChat_args oprot record = T.writeVal oprot $ from_DeleteSquareChat_args record
encode_DeleteSquareChat_args :: T.StatelessProtocol p => p -> DeleteSquareChat_args -> LBS.ByteString
encode_DeleteSquareChat_args oprot record = T.serializeVal oprot $ from_DeleteSquareChat_args record
to_DeleteSquareChat_args :: T.ThriftVal -> DeleteSquareChat_args
to_DeleteSquareChat_args (T.TStruct fields) = DeleteSquareChat_args{
  deleteSquareChat_args_request = P.maybe (deleteSquareChat_args_request default_DeleteSquareChat_args) (\(_,_val11429) -> (case _val11429 of {T.TStruct _val11430 -> (to_DeleteSquareChatRequest (T.TStruct _val11430)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquareChat_args _ = P.error "not a struct"
read_DeleteSquareChat_args :: T.Protocol p => p -> P.IO DeleteSquareChat_args
read_DeleteSquareChat_args iprot = to_DeleteSquareChat_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChat_args)
decode_DeleteSquareChat_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChat_args
decode_DeleteSquareChat_args iprot bs = to_DeleteSquareChat_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChat_args) bs
typemap_DeleteSquareChat_args :: T.TypeMap
typemap_DeleteSquareChat_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_DeleteSquareChatRequest)))]
default_DeleteSquareChat_args :: DeleteSquareChat_args
default_DeleteSquareChat_args = DeleteSquareChat_args{
  deleteSquareChat_args_request = default_DeleteSquareChatRequest}
data DeleteSquareChat_result = DeleteSquareChat_result  { deleteSquareChat_result_success :: DeleteSquareChatResponse
  , deleteSquareChat_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquareChat_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquareChat_result_success record   `H.hashWithSalt` deleteSquareChat_result_e record  
instance QC.Arbitrary DeleteSquareChat_result where 
  arbitrary = M.liftM DeleteSquareChat_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DeleteSquareChat_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquareChat_result{deleteSquareChat_result_success = deleteSquareChat_result_success obj} then P.Nothing else P.Just $ default_DeleteSquareChat_result{deleteSquareChat_result_success = deleteSquareChat_result_success obj}
    , if obj == default_DeleteSquareChat_result{deleteSquareChat_result_e = deleteSquareChat_result_e obj} then P.Nothing else P.Just $ default_DeleteSquareChat_result{deleteSquareChat_result_e = deleteSquareChat_result_e obj}
    ]
from_DeleteSquareChat_result :: DeleteSquareChat_result -> T.ThriftVal
from_DeleteSquareChat_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11433 -> (1, ("e",from_SquareException _v11433))) <$> deleteSquareChat_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11433 -> P.Just (0, ("success",from_DeleteSquareChatResponse _v11433))) $ deleteSquareChat_result_success record
    , (\_v11433 -> (1, ("e",from_SquareException _v11433))) <$> deleteSquareChat_result_e record
    ]
    )
write_DeleteSquareChat_result :: T.Protocol p => p -> DeleteSquareChat_result -> P.IO ()
write_DeleteSquareChat_result oprot record = T.writeVal oprot $ from_DeleteSquareChat_result record
encode_DeleteSquareChat_result :: T.StatelessProtocol p => p -> DeleteSquareChat_result -> LBS.ByteString
encode_DeleteSquareChat_result oprot record = T.serializeVal oprot $ from_DeleteSquareChat_result record
to_DeleteSquareChat_result :: T.ThriftVal -> DeleteSquareChat_result
to_DeleteSquareChat_result (T.TStruct fields) = DeleteSquareChat_result{
  deleteSquareChat_result_success = P.maybe (deleteSquareChat_result_success default_DeleteSquareChat_result) (\(_,_val11435) -> (case _val11435 of {T.TStruct _val11436 -> (to_DeleteSquareChatResponse (T.TStruct _val11436)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  deleteSquareChat_result_e = P.maybe (P.Nothing) (\(_,_val11435) -> P.Just (case _val11435 of {T.TStruct _val11437 -> (to_SquareException (T.TStruct _val11437)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquareChat_result _ = P.error "not a struct"
read_DeleteSquareChat_result :: T.Protocol p => p -> P.IO DeleteSquareChat_result
read_DeleteSquareChat_result iprot = to_DeleteSquareChat_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquareChat_result)
decode_DeleteSquareChat_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquareChat_result
decode_DeleteSquareChat_result iprot bs = to_DeleteSquareChat_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquareChat_result) bs
typemap_DeleteSquareChat_result :: T.TypeMap
typemap_DeleteSquareChat_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_DeleteSquareChatResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_DeleteSquareChat_result :: DeleteSquareChat_result
default_DeleteSquareChat_result = DeleteSquareChat_result{
  deleteSquareChat_result_success = default_DeleteSquareChatResponse,
  deleteSquareChat_result_e = P.Nothing}
data DeleteSquare_args = DeleteSquare_args  { deleteSquare_args_request :: DeleteSquareRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquare_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquare_args_request record  
instance QC.Arbitrary DeleteSquare_args where 
  arbitrary = M.liftM DeleteSquare_args (QC.arbitrary)
  shrink obj | obj == default_DeleteSquare_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquare_args{deleteSquare_args_request = deleteSquare_args_request obj} then P.Nothing else P.Just $ default_DeleteSquare_args{deleteSquare_args_request = deleteSquare_args_request obj}
    ]
from_DeleteSquare_args :: DeleteSquare_args -> T.ThriftVal
from_DeleteSquare_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11440 -> P.Just (1, ("request",from_DeleteSquareRequest _v11440))) $ deleteSquare_args_request record
  ]
write_DeleteSquare_args :: T.Protocol p => p -> DeleteSquare_args -> P.IO ()
write_DeleteSquare_args oprot record = T.writeVal oprot $ from_DeleteSquare_args record
encode_DeleteSquare_args :: T.StatelessProtocol p => p -> DeleteSquare_args -> LBS.ByteString
encode_DeleteSquare_args oprot record = T.serializeVal oprot $ from_DeleteSquare_args record
to_DeleteSquare_args :: T.ThriftVal -> DeleteSquare_args
to_DeleteSquare_args (T.TStruct fields) = DeleteSquare_args{
  deleteSquare_args_request = P.maybe (deleteSquare_args_request default_DeleteSquare_args) (\(_,_val11442) -> (case _val11442 of {T.TStruct _val11443 -> (to_DeleteSquareRequest (T.TStruct _val11443)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquare_args _ = P.error "not a struct"
read_DeleteSquare_args :: T.Protocol p => p -> P.IO DeleteSquare_args
read_DeleteSquare_args iprot = to_DeleteSquare_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquare_args)
decode_DeleteSquare_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquare_args
decode_DeleteSquare_args iprot bs = to_DeleteSquare_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquare_args) bs
typemap_DeleteSquare_args :: T.TypeMap
typemap_DeleteSquare_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_DeleteSquareRequest)))]
default_DeleteSquare_args :: DeleteSquare_args
default_DeleteSquare_args = DeleteSquare_args{
  deleteSquare_args_request = default_DeleteSquareRequest}
data DeleteSquare_result = DeleteSquare_result  { deleteSquare_result_success :: DeleteSquareResponse
  , deleteSquare_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteSquare_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteSquare_result_success record   `H.hashWithSalt` deleteSquare_result_e record  
instance QC.Arbitrary DeleteSquare_result where 
  arbitrary = M.liftM DeleteSquare_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DeleteSquare_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteSquare_result{deleteSquare_result_success = deleteSquare_result_success obj} then P.Nothing else P.Just $ default_DeleteSquare_result{deleteSquare_result_success = deleteSquare_result_success obj}
    , if obj == default_DeleteSquare_result{deleteSquare_result_e = deleteSquare_result_e obj} then P.Nothing else P.Just $ default_DeleteSquare_result{deleteSquare_result_e = deleteSquare_result_e obj}
    ]
from_DeleteSquare_result :: DeleteSquare_result -> T.ThriftVal
from_DeleteSquare_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11446 -> (1, ("e",from_SquareException _v11446))) <$> deleteSquare_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11446 -> P.Just (0, ("success",from_DeleteSquareResponse _v11446))) $ deleteSquare_result_success record
    , (\_v11446 -> (1, ("e",from_SquareException _v11446))) <$> deleteSquare_result_e record
    ]
    )
write_DeleteSquare_result :: T.Protocol p => p -> DeleteSquare_result -> P.IO ()
write_DeleteSquare_result oprot record = T.writeVal oprot $ from_DeleteSquare_result record
encode_DeleteSquare_result :: T.StatelessProtocol p => p -> DeleteSquare_result -> LBS.ByteString
encode_DeleteSquare_result oprot record = T.serializeVal oprot $ from_DeleteSquare_result record
to_DeleteSquare_result :: T.ThriftVal -> DeleteSquare_result
to_DeleteSquare_result (T.TStruct fields) = DeleteSquare_result{
  deleteSquare_result_success = P.maybe (deleteSquare_result_success default_DeleteSquare_result) (\(_,_val11448) -> (case _val11448 of {T.TStruct _val11449 -> (to_DeleteSquareResponse (T.TStruct _val11449)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  deleteSquare_result_e = P.maybe (P.Nothing) (\(_,_val11448) -> P.Just (case _val11448 of {T.TStruct _val11450 -> (to_SquareException (T.TStruct _val11450)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DeleteSquare_result _ = P.error "not a struct"
read_DeleteSquare_result :: T.Protocol p => p -> P.IO DeleteSquare_result
read_DeleteSquare_result iprot = to_DeleteSquare_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteSquare_result)
decode_DeleteSquare_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteSquare_result
decode_DeleteSquare_result iprot bs = to_DeleteSquare_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteSquare_result) bs
typemap_DeleteSquare_result :: T.TypeMap
typemap_DeleteSquare_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_DeleteSquareResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_DeleteSquare_result :: DeleteSquare_result
default_DeleteSquare_result = DeleteSquare_result{
  deleteSquare_result_success = default_DeleteSquareResponse,
  deleteSquare_result_e = P.Nothing}
data DestroyMessage_args = DestroyMessage_args  { destroyMessage_args_request :: DestroyMessageRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` destroyMessage_args_request record  
instance QC.Arbitrary DestroyMessage_args where 
  arbitrary = M.liftM DestroyMessage_args (QC.arbitrary)
  shrink obj | obj == default_DestroyMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DestroyMessage_args{destroyMessage_args_request = destroyMessage_args_request obj} then P.Nothing else P.Just $ default_DestroyMessage_args{destroyMessage_args_request = destroyMessage_args_request obj}
    ]
from_DestroyMessage_args :: DestroyMessage_args -> T.ThriftVal
from_DestroyMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11453 -> P.Just (1, ("request",from_DestroyMessageRequest _v11453))) $ destroyMessage_args_request record
  ]
write_DestroyMessage_args :: T.Protocol p => p -> DestroyMessage_args -> P.IO ()
write_DestroyMessage_args oprot record = T.writeVal oprot $ from_DestroyMessage_args record
encode_DestroyMessage_args :: T.StatelessProtocol p => p -> DestroyMessage_args -> LBS.ByteString
encode_DestroyMessage_args oprot record = T.serializeVal oprot $ from_DestroyMessage_args record
to_DestroyMessage_args :: T.ThriftVal -> DestroyMessage_args
to_DestroyMessage_args (T.TStruct fields) = DestroyMessage_args{
  destroyMessage_args_request = P.maybe (destroyMessage_args_request default_DestroyMessage_args) (\(_,_val11455) -> (case _val11455 of {T.TStruct _val11456 -> (to_DestroyMessageRequest (T.TStruct _val11456)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DestroyMessage_args _ = P.error "not a struct"
read_DestroyMessage_args :: T.Protocol p => p -> P.IO DestroyMessage_args
read_DestroyMessage_args iprot = to_DestroyMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessage_args)
decode_DestroyMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessage_args
decode_DestroyMessage_args iprot bs = to_DestroyMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessage_args) bs
typemap_DestroyMessage_args :: T.TypeMap
typemap_DestroyMessage_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_DestroyMessageRequest)))]
default_DestroyMessage_args :: DestroyMessage_args
default_DestroyMessage_args = DestroyMessage_args{
  destroyMessage_args_request = default_DestroyMessageRequest}
data DestroyMessage_result = DestroyMessage_result  { destroyMessage_result_success :: DestroyMessageResponse
  , destroyMessage_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` destroyMessage_result_success record   `H.hashWithSalt` destroyMessage_result_e record  
instance QC.Arbitrary DestroyMessage_result where 
  arbitrary = M.liftM DestroyMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DestroyMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DestroyMessage_result{destroyMessage_result_success = destroyMessage_result_success obj} then P.Nothing else P.Just $ default_DestroyMessage_result{destroyMessage_result_success = destroyMessage_result_success obj}
    , if obj == default_DestroyMessage_result{destroyMessage_result_e = destroyMessage_result_e obj} then P.Nothing else P.Just $ default_DestroyMessage_result{destroyMessage_result_e = destroyMessage_result_e obj}
    ]
from_DestroyMessage_result :: DestroyMessage_result -> T.ThriftVal
from_DestroyMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11459 -> (1, ("e",from_SquareException _v11459))) <$> destroyMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11459 -> P.Just (0, ("success",from_DestroyMessageResponse _v11459))) $ destroyMessage_result_success record
    , (\_v11459 -> (1, ("e",from_SquareException _v11459))) <$> destroyMessage_result_e record
    ]
    )
write_DestroyMessage_result :: T.Protocol p => p -> DestroyMessage_result -> P.IO ()
write_DestroyMessage_result oprot record = T.writeVal oprot $ from_DestroyMessage_result record
encode_DestroyMessage_result :: T.StatelessProtocol p => p -> DestroyMessage_result -> LBS.ByteString
encode_DestroyMessage_result oprot record = T.serializeVal oprot $ from_DestroyMessage_result record
to_DestroyMessage_result :: T.ThriftVal -> DestroyMessage_result
to_DestroyMessage_result (T.TStruct fields) = DestroyMessage_result{
  destroyMessage_result_success = P.maybe (destroyMessage_result_success default_DestroyMessage_result) (\(_,_val11461) -> (case _val11461 of {T.TStruct _val11462 -> (to_DestroyMessageResponse (T.TStruct _val11462)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  destroyMessage_result_e = P.maybe (P.Nothing) (\(_,_val11461) -> P.Just (case _val11461 of {T.TStruct _val11463 -> (to_SquareException (T.TStruct _val11463)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DestroyMessage_result _ = P.error "not a struct"
read_DestroyMessage_result :: T.Protocol p => p -> P.IO DestroyMessage_result
read_DestroyMessage_result iprot = to_DestroyMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessage_result)
decode_DestroyMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessage_result
decode_DestroyMessage_result iprot bs = to_DestroyMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessage_result) bs
typemap_DestroyMessage_result :: T.TypeMap
typemap_DestroyMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_DestroyMessageResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_DestroyMessage_result :: DestroyMessage_result
default_DestroyMessage_result = DestroyMessage_result{
  destroyMessage_result_success = default_DestroyMessageResponse,
  destroyMessage_result_e = P.Nothing}
data GetJoinableSquareChats_args = GetJoinableSquareChats_args  { getJoinableSquareChats_args_request :: GetJoinableSquareChatsRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinableSquareChats_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinableSquareChats_args_request record  
instance QC.Arbitrary GetJoinableSquareChats_args where 
  arbitrary = M.liftM GetJoinableSquareChats_args (QC.arbitrary)
  shrink obj | obj == default_GetJoinableSquareChats_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinableSquareChats_args{getJoinableSquareChats_args_request = getJoinableSquareChats_args_request obj} then P.Nothing else P.Just $ default_GetJoinableSquareChats_args{getJoinableSquareChats_args_request = getJoinableSquareChats_args_request obj}
    ]
from_GetJoinableSquareChats_args :: GetJoinableSquareChats_args -> T.ThriftVal
from_GetJoinableSquareChats_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11466 -> P.Just (1, ("request",from_GetJoinableSquareChatsRequest _v11466))) $ getJoinableSquareChats_args_request record
  ]
write_GetJoinableSquareChats_args :: T.Protocol p => p -> GetJoinableSquareChats_args -> P.IO ()
write_GetJoinableSquareChats_args oprot record = T.writeVal oprot $ from_GetJoinableSquareChats_args record
encode_GetJoinableSquareChats_args :: T.StatelessProtocol p => p -> GetJoinableSquareChats_args -> LBS.ByteString
encode_GetJoinableSquareChats_args oprot record = T.serializeVal oprot $ from_GetJoinableSquareChats_args record
to_GetJoinableSquareChats_args :: T.ThriftVal -> GetJoinableSquareChats_args
to_GetJoinableSquareChats_args (T.TStruct fields) = GetJoinableSquareChats_args{
  getJoinableSquareChats_args_request = P.maybe (getJoinableSquareChats_args_request default_GetJoinableSquareChats_args) (\(_,_val11468) -> (case _val11468 of {T.TStruct _val11469 -> (to_GetJoinableSquareChatsRequest (T.TStruct _val11469)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinableSquareChats_args _ = P.error "not a struct"
read_GetJoinableSquareChats_args :: T.Protocol p => p -> P.IO GetJoinableSquareChats_args
read_GetJoinableSquareChats_args iprot = to_GetJoinableSquareChats_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinableSquareChats_args)
decode_GetJoinableSquareChats_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinableSquareChats_args
decode_GetJoinableSquareChats_args iprot bs = to_GetJoinableSquareChats_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinableSquareChats_args) bs
typemap_GetJoinableSquareChats_args :: T.TypeMap
typemap_GetJoinableSquareChats_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetJoinableSquareChatsRequest)))]
default_GetJoinableSquareChats_args :: GetJoinableSquareChats_args
default_GetJoinableSquareChats_args = GetJoinableSquareChats_args{
  getJoinableSquareChats_args_request = default_GetJoinableSquareChatsRequest}
data GetJoinableSquareChats_result = GetJoinableSquareChats_result  { getJoinableSquareChats_result_success :: GetJoinableSquareChatsResponse
  , getJoinableSquareChats_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinableSquareChats_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinableSquareChats_result_success record   `H.hashWithSalt` getJoinableSquareChats_result_e record  
instance QC.Arbitrary GetJoinableSquareChats_result where 
  arbitrary = M.liftM GetJoinableSquareChats_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinableSquareChats_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinableSquareChats_result{getJoinableSquareChats_result_success = getJoinableSquareChats_result_success obj} then P.Nothing else P.Just $ default_GetJoinableSquareChats_result{getJoinableSquareChats_result_success = getJoinableSquareChats_result_success obj}
    , if obj == default_GetJoinableSquareChats_result{getJoinableSquareChats_result_e = getJoinableSquareChats_result_e obj} then P.Nothing else P.Just $ default_GetJoinableSquareChats_result{getJoinableSquareChats_result_e = getJoinableSquareChats_result_e obj}
    ]
from_GetJoinableSquareChats_result :: GetJoinableSquareChats_result -> T.ThriftVal
from_GetJoinableSquareChats_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11472 -> (1, ("e",from_SquareException _v11472))) <$> getJoinableSquareChats_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11472 -> P.Just (0, ("success",from_GetJoinableSquareChatsResponse _v11472))) $ getJoinableSquareChats_result_success record
    , (\_v11472 -> (1, ("e",from_SquareException _v11472))) <$> getJoinableSquareChats_result_e record
    ]
    )
write_GetJoinableSquareChats_result :: T.Protocol p => p -> GetJoinableSquareChats_result -> P.IO ()
write_GetJoinableSquareChats_result oprot record = T.writeVal oprot $ from_GetJoinableSquareChats_result record
encode_GetJoinableSquareChats_result :: T.StatelessProtocol p => p -> GetJoinableSquareChats_result -> LBS.ByteString
encode_GetJoinableSquareChats_result oprot record = T.serializeVal oprot $ from_GetJoinableSquareChats_result record
to_GetJoinableSquareChats_result :: T.ThriftVal -> GetJoinableSquareChats_result
to_GetJoinableSquareChats_result (T.TStruct fields) = GetJoinableSquareChats_result{
  getJoinableSquareChats_result_success = P.maybe (getJoinableSquareChats_result_success default_GetJoinableSquareChats_result) (\(_,_val11474) -> (case _val11474 of {T.TStruct _val11475 -> (to_GetJoinableSquareChatsResponse (T.TStruct _val11475)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinableSquareChats_result_e = P.maybe (P.Nothing) (\(_,_val11474) -> P.Just (case _val11474 of {T.TStruct _val11476 -> (to_SquareException (T.TStruct _val11476)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinableSquareChats_result _ = P.error "not a struct"
read_GetJoinableSquareChats_result :: T.Protocol p => p -> P.IO GetJoinableSquareChats_result
read_GetJoinableSquareChats_result iprot = to_GetJoinableSquareChats_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinableSquareChats_result)
decode_GetJoinableSquareChats_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinableSquareChats_result
decode_GetJoinableSquareChats_result iprot bs = to_GetJoinableSquareChats_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinableSquareChats_result) bs
typemap_GetJoinableSquareChats_result :: T.TypeMap
typemap_GetJoinableSquareChats_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetJoinableSquareChatsResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetJoinableSquareChats_result :: GetJoinableSquareChats_result
default_GetJoinableSquareChats_result = GetJoinableSquareChats_result{
  getJoinableSquareChats_result_success = default_GetJoinableSquareChatsResponse,
  getJoinableSquareChats_result_e = P.Nothing}
data GetInvitationTicketUrl_args = GetInvitationTicketUrl_args  { getInvitationTicketUrl_args_request :: GetInvitationTicketUrlRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetInvitationTicketUrl_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getInvitationTicketUrl_args_request record  
instance QC.Arbitrary GetInvitationTicketUrl_args where 
  arbitrary = M.liftM GetInvitationTicketUrl_args (QC.arbitrary)
  shrink obj | obj == default_GetInvitationTicketUrl_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetInvitationTicketUrl_args{getInvitationTicketUrl_args_request = getInvitationTicketUrl_args_request obj} then P.Nothing else P.Just $ default_GetInvitationTicketUrl_args{getInvitationTicketUrl_args_request = getInvitationTicketUrl_args_request obj}
    ]
from_GetInvitationTicketUrl_args :: GetInvitationTicketUrl_args -> T.ThriftVal
from_GetInvitationTicketUrl_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11479 -> P.Just (1, ("request",from_GetInvitationTicketUrlRequest _v11479))) $ getInvitationTicketUrl_args_request record
  ]
write_GetInvitationTicketUrl_args :: T.Protocol p => p -> GetInvitationTicketUrl_args -> P.IO ()
write_GetInvitationTicketUrl_args oprot record = T.writeVal oprot $ from_GetInvitationTicketUrl_args record
encode_GetInvitationTicketUrl_args :: T.StatelessProtocol p => p -> GetInvitationTicketUrl_args -> LBS.ByteString
encode_GetInvitationTicketUrl_args oprot record = T.serializeVal oprot $ from_GetInvitationTicketUrl_args record
to_GetInvitationTicketUrl_args :: T.ThriftVal -> GetInvitationTicketUrl_args
to_GetInvitationTicketUrl_args (T.TStruct fields) = GetInvitationTicketUrl_args{
  getInvitationTicketUrl_args_request = P.maybe (getInvitationTicketUrl_args_request default_GetInvitationTicketUrl_args) (\(_,_val11481) -> (case _val11481 of {T.TStruct _val11482 -> (to_GetInvitationTicketUrlRequest (T.TStruct _val11482)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetInvitationTicketUrl_args _ = P.error "not a struct"
read_GetInvitationTicketUrl_args :: T.Protocol p => p -> P.IO GetInvitationTicketUrl_args
read_GetInvitationTicketUrl_args iprot = to_GetInvitationTicketUrl_args <$> T.readVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrl_args)
decode_GetInvitationTicketUrl_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetInvitationTicketUrl_args
decode_GetInvitationTicketUrl_args iprot bs = to_GetInvitationTicketUrl_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrl_args) bs
typemap_GetInvitationTicketUrl_args :: T.TypeMap
typemap_GetInvitationTicketUrl_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_GetInvitationTicketUrlRequest)))]
default_GetInvitationTicketUrl_args :: GetInvitationTicketUrl_args
default_GetInvitationTicketUrl_args = GetInvitationTicketUrl_args{
  getInvitationTicketUrl_args_request = default_GetInvitationTicketUrlRequest}
data GetInvitationTicketUrl_result = GetInvitationTicketUrl_result  { getInvitationTicketUrl_result_success :: GetInvitationTicketUrlResponse
  , getInvitationTicketUrl_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetInvitationTicketUrl_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getInvitationTicketUrl_result_success record   `H.hashWithSalt` getInvitationTicketUrl_result_e record  
instance QC.Arbitrary GetInvitationTicketUrl_result where 
  arbitrary = M.liftM GetInvitationTicketUrl_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetInvitationTicketUrl_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_success = getInvitationTicketUrl_result_success obj} then P.Nothing else P.Just $ default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_success = getInvitationTicketUrl_result_success obj}
    , if obj == default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_e = getInvitationTicketUrl_result_e obj} then P.Nothing else P.Just $ default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_e = getInvitationTicketUrl_result_e obj}
    ]
from_GetInvitationTicketUrl_result :: GetInvitationTicketUrl_result -> T.ThriftVal
from_GetInvitationTicketUrl_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11485 -> (1, ("e",from_SquareException _v11485))) <$> getInvitationTicketUrl_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11485 -> P.Just (0, ("success",from_GetInvitationTicketUrlResponse _v11485))) $ getInvitationTicketUrl_result_success record
    , (\_v11485 -> (1, ("e",from_SquareException _v11485))) <$> getInvitationTicketUrl_result_e record
    ]
    )
write_GetInvitationTicketUrl_result :: T.Protocol p => p -> GetInvitationTicketUrl_result -> P.IO ()
write_GetInvitationTicketUrl_result oprot record = T.writeVal oprot $ from_GetInvitationTicketUrl_result record
encode_GetInvitationTicketUrl_result :: T.StatelessProtocol p => p -> GetInvitationTicketUrl_result -> LBS.ByteString
encode_GetInvitationTicketUrl_result oprot record = T.serializeVal oprot $ from_GetInvitationTicketUrl_result record
to_GetInvitationTicketUrl_result :: T.ThriftVal -> GetInvitationTicketUrl_result
to_GetInvitationTicketUrl_result (T.TStruct fields) = GetInvitationTicketUrl_result{
  getInvitationTicketUrl_result_success = P.maybe (getInvitationTicketUrl_result_success default_GetInvitationTicketUrl_result) (\(_,_val11487) -> (case _val11487 of {T.TStruct _val11488 -> (to_GetInvitationTicketUrlResponse (T.TStruct _val11488)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getInvitationTicketUrl_result_e = P.maybe (P.Nothing) (\(_,_val11487) -> P.Just (case _val11487 of {T.TStruct _val11489 -> (to_SquareException (T.TStruct _val11489)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetInvitationTicketUrl_result _ = P.error "not a struct"
read_GetInvitationTicketUrl_result :: T.Protocol p => p -> P.IO GetInvitationTicketUrl_result
read_GetInvitationTicketUrl_result iprot = to_GetInvitationTicketUrl_result <$> T.readVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrl_result)
decode_GetInvitationTicketUrl_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetInvitationTicketUrl_result
decode_GetInvitationTicketUrl_result iprot bs = to_GetInvitationTicketUrl_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetInvitationTicketUrl_result) bs
typemap_GetInvitationTicketUrl_result :: T.TypeMap
typemap_GetInvitationTicketUrl_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GetInvitationTicketUrlResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_GetInvitationTicketUrl_result :: GetInvitationTicketUrl_result
default_GetInvitationTicketUrl_result = GetInvitationTicketUrl_result{
  getInvitationTicketUrl_result_success = default_GetInvitationTicketUrlResponse,
  getInvitationTicketUrl_result_e = P.Nothing}
data FindSquareByInvitationTicket_args = FindSquareByInvitationTicket_args  { findSquareByInvitationTicket_args_request :: FindSquareByInvitationTicketRequest
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSquareByInvitationTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSquareByInvitationTicket_args_request record  
instance QC.Arbitrary FindSquareByInvitationTicket_args where 
  arbitrary = M.liftM FindSquareByInvitationTicket_args (QC.arbitrary)
  shrink obj | obj == default_FindSquareByInvitationTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSquareByInvitationTicket_args{findSquareByInvitationTicket_args_request = findSquareByInvitationTicket_args_request obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicket_args{findSquareByInvitationTicket_args_request = findSquareByInvitationTicket_args_request obj}
    ]
from_FindSquareByInvitationTicket_args :: FindSquareByInvitationTicket_args -> T.ThriftVal
from_FindSquareByInvitationTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11492 -> P.Just (1, ("request",from_FindSquareByInvitationTicketRequest _v11492))) $ findSquareByInvitationTicket_args_request record
  ]
write_FindSquareByInvitationTicket_args :: T.Protocol p => p -> FindSquareByInvitationTicket_args -> P.IO ()
write_FindSquareByInvitationTicket_args oprot record = T.writeVal oprot $ from_FindSquareByInvitationTicket_args record
encode_FindSquareByInvitationTicket_args :: T.StatelessProtocol p => p -> FindSquareByInvitationTicket_args -> LBS.ByteString
encode_FindSquareByInvitationTicket_args oprot record = T.serializeVal oprot $ from_FindSquareByInvitationTicket_args record
to_FindSquareByInvitationTicket_args :: T.ThriftVal -> FindSquareByInvitationTicket_args
to_FindSquareByInvitationTicket_args (T.TStruct fields) = FindSquareByInvitationTicket_args{
  findSquareByInvitationTicket_args_request = P.maybe (findSquareByInvitationTicket_args_request default_FindSquareByInvitationTicket_args) (\(_,_val11494) -> (case _val11494 of {T.TStruct _val11495 -> (to_FindSquareByInvitationTicketRequest (T.TStruct _val11495)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindSquareByInvitationTicket_args _ = P.error "not a struct"
read_FindSquareByInvitationTicket_args :: T.Protocol p => p -> P.IO FindSquareByInvitationTicket_args
read_FindSquareByInvitationTicket_args iprot = to_FindSquareByInvitationTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicket_args)
decode_FindSquareByInvitationTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSquareByInvitationTicket_args
decode_FindSquareByInvitationTicket_args iprot bs = to_FindSquareByInvitationTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicket_args) bs
typemap_FindSquareByInvitationTicket_args :: T.TypeMap
typemap_FindSquareByInvitationTicket_args = Map.fromList [(1,("request",(T.T_STRUCT typemap_FindSquareByInvitationTicketRequest)))]
default_FindSquareByInvitationTicket_args :: FindSquareByInvitationTicket_args
default_FindSquareByInvitationTicket_args = FindSquareByInvitationTicket_args{
  findSquareByInvitationTicket_args_request = default_FindSquareByInvitationTicketRequest}
data FindSquareByInvitationTicket_result = FindSquareByInvitationTicket_result  { findSquareByInvitationTicket_result_success :: FindSquareByInvitationTicketResponse
  , findSquareByInvitationTicket_result_e :: P.Maybe SquareException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSquareByInvitationTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSquareByInvitationTicket_result_success record   `H.hashWithSalt` findSquareByInvitationTicket_result_e record  
instance QC.Arbitrary FindSquareByInvitationTicket_result where 
  arbitrary = M.liftM FindSquareByInvitationTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindSquareByInvitationTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_success = findSquareByInvitationTicket_result_success obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_success = findSquareByInvitationTicket_result_success obj}
    , if obj == default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_e = findSquareByInvitationTicket_result_e obj} then P.Nothing else P.Just $ default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_e = findSquareByInvitationTicket_result_e obj}
    ]
from_FindSquareByInvitationTicket_result :: FindSquareByInvitationTicket_result -> T.ThriftVal
from_FindSquareByInvitationTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11498 -> (1, ("e",from_SquareException _v11498))) <$> findSquareByInvitationTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11498 -> P.Just (0, ("success",from_FindSquareByInvitationTicketResponse _v11498))) $ findSquareByInvitationTicket_result_success record
    , (\_v11498 -> (1, ("e",from_SquareException _v11498))) <$> findSquareByInvitationTicket_result_e record
    ]
    )
write_FindSquareByInvitationTicket_result :: T.Protocol p => p -> FindSquareByInvitationTicket_result -> P.IO ()
write_FindSquareByInvitationTicket_result oprot record = T.writeVal oprot $ from_FindSquareByInvitationTicket_result record
encode_FindSquareByInvitationTicket_result :: T.StatelessProtocol p => p -> FindSquareByInvitationTicket_result -> LBS.ByteString
encode_FindSquareByInvitationTicket_result oprot record = T.serializeVal oprot $ from_FindSquareByInvitationTicket_result record
to_FindSquareByInvitationTicket_result :: T.ThriftVal -> FindSquareByInvitationTicket_result
to_FindSquareByInvitationTicket_result (T.TStruct fields) = FindSquareByInvitationTicket_result{
  findSquareByInvitationTicket_result_success = P.maybe (findSquareByInvitationTicket_result_success default_FindSquareByInvitationTicket_result) (\(_,_val11500) -> (case _val11500 of {T.TStruct _val11501 -> (to_FindSquareByInvitationTicketResponse (T.TStruct _val11501)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findSquareByInvitationTicket_result_e = P.maybe (P.Nothing) (\(_,_val11500) -> P.Just (case _val11500 of {T.TStruct _val11502 -> (to_SquareException (T.TStruct _val11502)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindSquareByInvitationTicket_result _ = P.error "not a struct"
read_FindSquareByInvitationTicket_result :: T.Protocol p => p -> P.IO FindSquareByInvitationTicket_result
read_FindSquareByInvitationTicket_result iprot = to_FindSquareByInvitationTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicket_result)
decode_FindSquareByInvitationTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSquareByInvitationTicket_result
decode_FindSquareByInvitationTicket_result iprot bs = to_FindSquareByInvitationTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSquareByInvitationTicket_result) bs
typemap_FindSquareByInvitationTicket_result :: T.TypeMap
typemap_FindSquareByInvitationTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_FindSquareByInvitationTicketResponse))),(1,("e",(T.T_STRUCT typemap_SquareException)))]
default_FindSquareByInvitationTicket_result :: FindSquareByInvitationTicket_result
default_FindSquareByInvitationTicket_result = FindSquareByInvitationTicket_result{
  findSquareByInvitationTicket_result_success = default_FindSquareByInvitationTicketResponse,
  findSquareByInvitationTicket_result_e = P.Nothing}
process_getSquareChatAnnouncements (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareChatAnnouncements_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareChatAnnouncements handler (getSquareChatAnnouncements_args_request args)
        let res = default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_success = val}
        T.writeMessage oprot ("getSquareChatAnnouncements", T.M_REPLY, seqid) $
          write_GetSquareChatAnnouncements_result oprot res)
      (\e  -> do
        let res = default_GetSquareChatAnnouncements_result{getSquareChatAnnouncements_result_e = P.Just e}
        T.writeMessage oprot ("getSquareChatAnnouncements", T.M_REPLY, seqid) $
          write_GetSquareChatAnnouncements_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareChatAnnouncements", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_deleteSquareChatAnnouncement (seqid, iprot, oprot, handler) = do
  args <- read_DeleteSquareChatAnnouncement_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.deleteSquareChatAnnouncement handler (deleteSquareChatAnnouncement_args_request args)
        let res = default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_success = val}
        T.writeMessage oprot ("deleteSquareChatAnnouncement", T.M_REPLY, seqid) $
          write_DeleteSquareChatAnnouncement_result oprot res)
      (\e  -> do
        let res = default_DeleteSquareChatAnnouncement_result{deleteSquareChatAnnouncement_result_e = P.Just e}
        T.writeMessage oprot ("deleteSquareChatAnnouncement", T.M_REPLY, seqid) $
          write_DeleteSquareChatAnnouncement_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("deleteSquareChatAnnouncement", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSquareChatAnnouncement (seqid, iprot, oprot, handler) = do
  args <- read_CreateSquareChatAnnouncement_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createSquareChatAnnouncement handler (createSquareChatAnnouncement_args_request args)
        let res = default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_success = val}
        T.writeMessage oprot ("createSquareChatAnnouncement", T.M_REPLY, seqid) $
          write_CreateSquareChatAnnouncement_result oprot res)
      (\e  -> do
        let res = default_CreateSquareChatAnnouncement_result{createSquareChatAnnouncement_result_e = P.Just e}
        T.writeMessage oprot ("createSquareChatAnnouncement", T.M_REPLY, seqid) $
          write_CreateSquareChatAnnouncement_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSquareChatAnnouncement", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNoteStatus handler (getNoteStatus_args_request args)
        let res = default_GetNoteStatus_result{getNoteStatus_result_success = val}
        T.writeMessage oprot ("getNoteStatus", T.M_REPLY, seqid) $
          write_GetNoteStatus_result oprot res)
      (\e  -> do
        let res = default_GetNoteStatus_result{getNoteStatus_result_e = P.Just e}
        T.writeMessage oprot ("getNoteStatus", T.M_REPLY, seqid) $
          write_GetNoteStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareStatus handler (getSquareStatus_args_request args)
        let res = default_GetSquareStatus_result{getSquareStatus_result_success = val}
        T.writeMessage oprot ("getSquareStatus", T.M_REPLY, seqid) $
          write_GetSquareStatus_result oprot res)
      (\e  -> do
        let res = default_GetSquareStatus_result{getSquareStatus_result_e = P.Just e}
        T.writeMessage oprot ("getSquareStatus", T.M_REPLY, seqid) $
          write_GetSquareStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSquareMember (seqid, iprot, oprot, handler) = do
  args <- read_ReportSquareMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportSquareMember handler (reportSquareMember_args_request args)
        let res = default_ReportSquareMember_result{reportSquareMember_result_success = val}
        T.writeMessage oprot ("reportSquareMember", T.M_REPLY, seqid) $
          write_ReportSquareMember_result oprot res)
      (\e  -> do
        let res = default_ReportSquareMember_result{reportSquareMember_result_e = P.Just e}
        T.writeMessage oprot ("reportSquareMember", T.M_REPLY, seqid) $
          write_ReportSquareMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSquareMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSquareMessage (seqid, iprot, oprot, handler) = do
  args <- read_ReportSquareMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportSquareMessage handler (reportSquareMessage_args_request args)
        let res = default_ReportSquareMessage_result{reportSquareMessage_result_success = val}
        T.writeMessage oprot ("reportSquareMessage", T.M_REPLY, seqid) $
          write_ReportSquareMessage_result oprot res)
      (\e  -> do
        let res = default_ReportSquareMessage_result{reportSquareMessage_result_e = P.Just e}
        T.writeMessage oprot ("reportSquareMessage", T.M_REPLY, seqid) $
          write_ReportSquareMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSquareMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_ReportSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportSquareChat handler (reportSquareChat_args_request args)
        let res = default_ReportSquareChat_result{reportSquareChat_result_success = val}
        T.writeMessage oprot ("reportSquareChat", T.M_REPLY, seqid) $
          write_ReportSquareChat_result oprot res)
      (\e  -> do
        let res = default_ReportSquareChat_result{reportSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("reportSquareChat", T.M_REPLY, seqid) $
          write_ReportSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSquare (seqid, iprot, oprot, handler) = do
  args <- read_ReportSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportSquare handler (reportSquare_args_request args)
        let res = default_ReportSquare_result{reportSquare_result_success = val}
        T.writeMessage oprot ("reportSquare", T.M_REPLY, seqid) $
          write_ReportSquare_result oprot res)
      (\e  -> do
        let res = default_ReportSquare_result{reportSquare_result_e = P.Just e}
        T.writeMessage oprot ("reportSquare", T.M_REPLY, seqid) $
          write_ReportSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareMemberRelation (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareMemberRelation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareMemberRelation handler (updateSquareMemberRelation_args_request args)
        let res = default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_success = val}
        T.writeMessage oprot ("updateSquareMemberRelation", T.M_REPLY, seqid) $
          write_UpdateSquareMemberRelation_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareMemberRelation_result{updateSquareMemberRelation_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareMemberRelation", T.M_REPLY, seqid) $
          write_UpdateSquareMemberRelation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareMemberRelation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareAuthority (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareAuthority_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareAuthority handler (updateSquareAuthority_args_request args)
        let res = default_UpdateSquareAuthority_result{updateSquareAuthority_result_success = val}
        T.writeMessage oprot ("updateSquareAuthority", T.M_REPLY, seqid) $
          write_UpdateSquareAuthority_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareAuthority_result{updateSquareAuthority_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareAuthority", T.M_REPLY, seqid) $
          write_UpdateSquareAuthority_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareAuthority", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareChatMember (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareChatMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareChatMember handler (updateSquareChatMember_args_request args)
        let res = default_UpdateSquareChatMember_result{updateSquareChatMember_result_success = val}
        T.writeMessage oprot ("updateSquareChatMember", T.M_REPLY, seqid) $
          write_UpdateSquareChatMember_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareChatMember_result{updateSquareChatMember_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareChatMember", T.M_REPLY, seqid) $
          write_UpdateSquareChatMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareChatMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareChat handler (updateSquareChat_args_request args)
        let res = default_UpdateSquareChat_result{updateSquareChat_result_success = val}
        T.writeMessage oprot ("updateSquareChat", T.M_REPLY, seqid) $
          write_UpdateSquareChat_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareChat_result{updateSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareChat", T.M_REPLY, seqid) $
          write_UpdateSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_refreshSubscriptions (seqid, iprot, oprot, handler) = do
  args <- read_RefreshSubscriptions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.refreshSubscriptions handler (refreshSubscriptions_args_request args)
        let res = default_RefreshSubscriptions_result{refreshSubscriptions_result_success = val}
        T.writeMessage oprot ("refreshSubscriptions", T.M_REPLY, seqid) $
          write_RefreshSubscriptions_result oprot res)
      (\e  -> do
        let res = default_RefreshSubscriptions_result{refreshSubscriptions_result_e = P.Just e}
        T.writeMessage oprot ("refreshSubscriptions", T.M_REPLY, seqid) $
          write_RefreshSubscriptions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("refreshSubscriptions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeSubscriptions (seqid, iprot, oprot, handler) = do
  args <- read_RemoveSubscriptions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeSubscriptions handler (removeSubscriptions_args_request args)
        let res = default_RemoveSubscriptions_result{removeSubscriptions_result_success = val}
        T.writeMessage oprot ("removeSubscriptions", T.M_REPLY, seqid) $
          write_RemoveSubscriptions_result oprot res)
      (\e  -> do
        let res = default_RemoveSubscriptions_result{removeSubscriptions_result_e = P.Just e}
        T.writeMessage oprot ("removeSubscriptions", T.M_REPLY, seqid) $
          write_RemoveSubscriptions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeSubscriptions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_rejectSquareMembers (seqid, iprot, oprot, handler) = do
  args <- read_RejectSquareMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.rejectSquareMembers handler (rejectSquareMembers_args_request args)
        let res = default_RejectSquareMembers_result{rejectSquareMembers_result_success = val}
        T.writeMessage oprot ("rejectSquareMembers", T.M_REPLY, seqid) $
          write_RejectSquareMembers_result oprot res)
      (\e  -> do
        let res = default_RejectSquareMembers_result{rejectSquareMembers_result_e = P.Just e}
        T.writeMessage oprot ("rejectSquareMembers", T.M_REPLY, seqid) $
          write_RejectSquareMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("rejectSquareMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareMembers (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareMembers handler (updateSquareMembers_args_request args)
        let res = default_UpdateSquareMembers_result{updateSquareMembers_result_success = val}
        T.writeMessage oprot ("updateSquareMembers", T.M_REPLY, seqid) $
          write_UpdateSquareMembers_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareMembers_result{updateSquareMembers_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareMembers", T.M_REPLY, seqid) $
          write_UpdateSquareMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareMember (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareMember handler (updateSquareMember_args_request args)
        let res = default_UpdateSquareMember_result{updateSquareMember_result_success = val}
        T.writeMessage oprot ("updateSquareMember", T.M_REPLY, seqid) $
          write_UpdateSquareMember_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareMember_result{updateSquareMember_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareMember", T.M_REPLY, seqid) $
          write_UpdateSquareMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquareFeatureSet (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquareFeatureSet_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquareFeatureSet handler (updateSquareFeatureSet_args_request args)
        let res = default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_success = val}
        T.writeMessage oprot ("updateSquareFeatureSet", T.M_REPLY, seqid) $
          write_UpdateSquareFeatureSet_result oprot res)
      (\e  -> do
        let res = default_UpdateSquareFeatureSet_result{updateSquareFeatureSet_result_e = P.Just e}
        T.writeMessage oprot ("updateSquareFeatureSet", T.M_REPLY, seqid) $
          write_UpdateSquareFeatureSet_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquareFeatureSet", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareFeatureSet (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareFeatureSet_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareFeatureSet handler (getSquareFeatureSet_args_request args)
        let res = default_GetSquareFeatureSet_result{getSquareFeatureSet_result_success = val}
        T.writeMessage oprot ("getSquareFeatureSet", T.M_REPLY, seqid) $
          write_GetSquareFeatureSet_result oprot res)
      (\e  -> do
        let res = default_GetSquareFeatureSet_result{getSquareFeatureSet_result_e = P.Just e}
        T.writeMessage oprot ("getSquareFeatureSet", T.M_REPLY, seqid) $
          write_GetSquareFeatureSet_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareFeatureSet", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_searchSquares (seqid, iprot, oprot, handler) = do
  args <- read_SearchSquares_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.searchSquares handler (searchSquares_args_request args)
        let res = default_SearchSquares_result{searchSquares_result_success = val}
        T.writeMessage oprot ("searchSquares", T.M_REPLY, seqid) $
          write_SearchSquares_result oprot res)
      (\e  -> do
        let res = default_SearchSquares_result{searchSquares_result_e = P.Just e}
        T.writeMessage oprot ("searchSquares", T.M_REPLY, seqid) $
          write_SearchSquares_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("searchSquares", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSquare (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSquare handler (updateSquare_args_request args)
        let res = default_UpdateSquare_result{updateSquare_result_success = val}
        T.writeMessage oprot ("updateSquare", T.M_REPLY, seqid) $
          write_UpdateSquare_result oprot res)
      (\e  -> do
        let res = default_UpdateSquare_result{updateSquare_result_e = P.Just e}
        T.writeMessage oprot ("updateSquare", T.M_REPLY, seqid) $
          write_UpdateSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCategories (seqid, iprot, oprot, handler) = do
  args <- read_GetCategories_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCategories handler (getCategories_args_request args)
        let res = default_GetCategories_result{getCategories_result_success = val}
        T.writeMessage oprot ("getCategories", T.M_REPLY, seqid) $
          write_GetCategories_result oprot res)
      (\e  -> do
        let res = default_GetCategories_result{getCategories_result_e = P.Just e}
        T.writeMessage oprot ("getCategories", T.M_REPLY, seqid) $
          write_GetCategories_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCategories", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_searchSquareMembers (seqid, iprot, oprot, handler) = do
  args <- read_SearchSquareMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.searchSquareMembers handler (searchSquareMembers_args_request args)
        let res = default_SearchSquareMembers_result{searchSquareMembers_result_success = val}
        T.writeMessage oprot ("searchSquareMembers", T.M_REPLY, seqid) $
          write_SearchSquareMembers_result oprot res)
      (\e  -> do
        let res = default_SearchSquareMembers_result{searchSquareMembers_result_e = P.Just e}
        T.writeMessage oprot ("searchSquareMembers", T.M_REPLY, seqid) $
          write_SearchSquareMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("searchSquareMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchSquareChatEvents (seqid, iprot, oprot, handler) = do
  args <- read_FetchSquareChatEvents_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchSquareChatEvents handler (fetchSquareChatEvents_args_request args)
        let res = default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_success = val}
        T.writeMessage oprot ("fetchSquareChatEvents", T.M_REPLY, seqid) $
          write_FetchSquareChatEvents_result oprot res)
      (\e  -> do
        let res = default_FetchSquareChatEvents_result{fetchSquareChatEvents_result_e = P.Just e}
        T.writeMessage oprot ("fetchSquareChatEvents", T.M_REPLY, seqid) $
          write_FetchSquareChatEvents_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchSquareChatEvents", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchMyEvents (seqid, iprot, oprot, handler) = do
  args <- read_FetchMyEvents_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchMyEvents handler (fetchMyEvents_args_request args)
        let res = default_FetchMyEvents_result{fetchMyEvents_result_success = val}
        T.writeMessage oprot ("fetchMyEvents", T.M_REPLY, seqid) $
          write_FetchMyEvents_result oprot res)
      (\e  -> do
        let res = default_FetchMyEvents_result{fetchMyEvents_result_e = P.Just e}
        T.writeMessage oprot ("fetchMyEvents", T.M_REPLY, seqid) $
          write_FetchMyEvents_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchMyEvents", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_markAsRead (seqid, iprot, oprot, handler) = do
  args <- read_MarkAsRead_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.markAsRead handler (markAsRead_args_request args)
        let res = default_MarkAsRead_result{markAsRead_result_success = val}
        T.writeMessage oprot ("markAsRead", T.M_REPLY, seqid) $
          write_MarkAsRead_result oprot res)
      (\e  -> do
        let res = default_MarkAsRead_result{markAsRead_result_e = P.Just e}
        T.writeMessage oprot ("markAsRead", T.M_REPLY, seqid) $
          write_MarkAsRead_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("markAsRead", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareAuthority (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareAuthority_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareAuthority handler (getSquareAuthority_args_request args)
        let res = default_GetSquareAuthority_result{getSquareAuthority_result_success = val}
        T.writeMessage oprot ("getSquareAuthority", T.M_REPLY, seqid) $
          write_GetSquareAuthority_result oprot res)
      (\e  -> do
        let res = default_GetSquareAuthority_result{getSquareAuthority_result_e = P.Just e}
        T.writeMessage oprot ("getSquareAuthority", T.M_REPLY, seqid) $
          write_GetSquareAuthority_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareAuthority", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessage (seqid, iprot, oprot, handler) = do
  args <- read_SendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessage handler (sendMessage_args_request args)
        let res = default_SendMessage_result{sendMessage_result_success = val}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res)
      (\e  -> do
        let res = default_SendMessage_result{sendMessage_result_e = P.Just e}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveSquare (seqid, iprot, oprot, handler) = do
  args <- read_LeaveSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.leaveSquare handler (leaveSquare_args_request args)
        let res = default_LeaveSquare_result{leaveSquare_result_success = val}
        T.writeMessage oprot ("leaveSquare", T.M_REPLY, seqid) $
          write_LeaveSquare_result oprot res)
      (\e  -> do
        let res = default_LeaveSquare_result{leaveSquare_result_e = P.Just e}
        T.writeMessage oprot ("leaveSquare", T.M_REPLY, seqid) $
          write_LeaveSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_LeaveSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.leaveSquareChat handler (leaveSquareChat_args_request args)
        let res = default_LeaveSquareChat_result{leaveSquareChat_result_success = val}
        T.writeMessage oprot ("leaveSquareChat", T.M_REPLY, seqid) $
          write_LeaveSquareChat_result oprot res)
      (\e  -> do
        let res = default_LeaveSquareChat_result{leaveSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("leaveSquareChat", T.M_REPLY, seqid) $
          write_LeaveSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_joinSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_JoinSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.joinSquareChat handler (joinSquareChat_args_request args)
        let res = default_JoinSquareChat_result{joinSquareChat_result_success = val}
        T.writeMessage oprot ("joinSquareChat", T.M_REPLY, seqid) $
          write_JoinSquareChat_result oprot res)
      (\e  -> do
        let res = default_JoinSquareChat_result{joinSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("joinSquareChat", T.M_REPLY, seqid) $
          write_JoinSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("joinSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_joinSquare (seqid, iprot, oprot, handler) = do
  args <- read_JoinSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.joinSquare handler (joinSquare_args_request args)
        let res = default_JoinSquare_result{joinSquare_result_success = val}
        T.writeMessage oprot ("joinSquare", T.M_REPLY, seqid) $
          write_JoinSquare_result oprot res)
      (\e  -> do
        let res = default_JoinSquare_result{joinSquare_result_e = P.Just e}
        T.writeMessage oprot ("joinSquare", T.M_REPLY, seqid) $
          write_JoinSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("joinSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteToSquare (seqid, iprot, oprot, handler) = do
  args <- read_InviteToSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.inviteToSquare handler (inviteToSquare_args_request args)
        let res = default_InviteToSquare_result{inviteToSquare_result_success = val}
        T.writeMessage oprot ("inviteToSquare", T.M_REPLY, seqid) $
          write_InviteToSquare_result oprot res)
      (\e  -> do
        let res = default_InviteToSquare_result{inviteToSquare_result_e = P.Just e}
        T.writeMessage oprot ("inviteToSquare", T.M_REPLY, seqid) $
          write_InviteToSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteToSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteToSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_InviteToSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.inviteToSquareChat handler (inviteToSquareChat_args_request args)
        let res = default_InviteToSquareChat_result{inviteToSquareChat_result_success = val}
        T.writeMessage oprot ("inviteToSquareChat", T.M_REPLY, seqid) $
          write_InviteToSquareChat_result oprot res)
      (\e  -> do
        let res = default_InviteToSquareChat_result{inviteToSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("inviteToSquareChat", T.M_REPLY, seqid) $
          write_InviteToSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteToSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareMember (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareMember handler (getSquareMember_args_request args)
        let res = default_GetSquareMember_result{getSquareMember_result_success = val}
        T.writeMessage oprot ("getSquareMember", T.M_REPLY, seqid) $
          write_GetSquareMember_result oprot res)
      (\e  -> do
        let res = default_GetSquareMember_result{getSquareMember_result_e = P.Just e}
        T.writeMessage oprot ("getSquareMember", T.M_REPLY, seqid) $
          write_GetSquareMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareMembers (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareMembers handler (getSquareMembers_args_request args)
        let res = default_GetSquareMembers_result{getSquareMembers_result_success = val}
        T.writeMessage oprot ("getSquareMembers", T.M_REPLY, seqid) $
          write_GetSquareMembers_result oprot res)
      (\e  -> do
        let res = default_GetSquareMembers_result{getSquareMembers_result_e = P.Just e}
        T.writeMessage oprot ("getSquareMembers", T.M_REPLY, seqid) $
          write_GetSquareMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareMemberRelation (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareMemberRelation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareMemberRelation handler (getSquareMemberRelation_args_request args)
        let res = default_GetSquareMemberRelation_result{getSquareMemberRelation_result_success = val}
        T.writeMessage oprot ("getSquareMemberRelation", T.M_REPLY, seqid) $
          write_GetSquareMemberRelation_result oprot res)
      (\e  -> do
        let res = default_GetSquareMemberRelation_result{getSquareMemberRelation_result_e = P.Just e}
        T.writeMessage oprot ("getSquareMemberRelation", T.M_REPLY, seqid) $
          write_GetSquareMemberRelation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareMemberRelation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareMemberRelations (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareMemberRelations_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareMemberRelations handler (getSquareMemberRelations_args_request args)
        let res = default_GetSquareMemberRelations_result{getSquareMemberRelations_result_success = val}
        T.writeMessage oprot ("getSquareMemberRelations", T.M_REPLY, seqid) $
          write_GetSquareMemberRelations_result oprot res)
      (\e  -> do
        let res = default_GetSquareMemberRelations_result{getSquareMemberRelations_result_e = P.Just e}
        T.writeMessage oprot ("getSquareMemberRelations", T.M_REPLY, seqid) $
          write_GetSquareMemberRelations_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareMemberRelations", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareChatMembers (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareChatMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareChatMembers handler (getSquareChatMembers_args_request args)
        let res = default_GetSquareChatMembers_result{getSquareChatMembers_result_success = val}
        T.writeMessage oprot ("getSquareChatMembers", T.M_REPLY, seqid) $
          write_GetSquareChatMembers_result oprot res)
      (\e  -> do
        let res = default_GetSquareChatMembers_result{getSquareChatMembers_result_e = P.Just e}
        T.writeMessage oprot ("getSquareChatMembers", T.M_REPLY, seqid) $
          write_GetSquareChatMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareChatMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareChatStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareChatStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareChatStatus handler (getSquareChatStatus_args_request args)
        let res = default_GetSquareChatStatus_result{getSquareChatStatus_result_success = val}
        T.writeMessage oprot ("getSquareChatStatus", T.M_REPLY, seqid) $
          write_GetSquareChatStatus_result oprot res)
      (\e  -> do
        let res = default_GetSquareChatStatus_result{getSquareChatStatus_result_e = P.Just e}
        T.writeMessage oprot ("getSquareChatStatus", T.M_REPLY, seqid) $
          write_GetSquareChatStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareChatStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_GetSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquareChat handler (getSquareChat_args_request args)
        let res = default_GetSquareChat_result{getSquareChat_result_success = val}
        T.writeMessage oprot ("getSquareChat", T.M_REPLY, seqid) $
          write_GetSquareChat_result oprot res)
      (\e  -> do
        let res = default_GetSquareChat_result{getSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("getSquareChat", T.M_REPLY, seqid) $
          write_GetSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSquare (seqid, iprot, oprot, handler) = do
  args <- read_GetSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSquare handler (getSquare_args_request args)
        let res = default_GetSquare_result{getSquare_result_success = val}
        T.writeMessage oprot ("getSquare", T.M_REPLY, seqid) $
          write_GetSquare_result oprot res)
      (\e  -> do
        let res = default_GetSquare_result{getSquare_result_e = P.Just e}
        T.writeMessage oprot ("getSquare", T.M_REPLY, seqid) $
          write_GetSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedSquares (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedSquares_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedSquares handler (getJoinedSquares_args_request args)
        let res = default_GetJoinedSquares_result{getJoinedSquares_result_success = val}
        T.writeMessage oprot ("getJoinedSquares", T.M_REPLY, seqid) $
          write_GetJoinedSquares_result oprot res)
      (\e  -> do
        let res = default_GetJoinedSquares_result{getJoinedSquares_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedSquares", T.M_REPLY, seqid) $
          write_GetJoinedSquares_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedSquares", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedSquareChats (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedSquareChats_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedSquareChats handler (getJoinedSquareChats_args_request args)
        let res = default_GetJoinedSquareChats_result{getJoinedSquareChats_result_success = val}
        T.writeMessage oprot ("getJoinedSquareChats", T.M_REPLY, seqid) $
          write_GetJoinedSquareChats_result oprot res)
      (\e  -> do
        let res = default_GetJoinedSquareChats_result{getJoinedSquareChats_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedSquareChats", T.M_REPLY, seqid) $
          write_GetJoinedSquareChats_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedSquareChats", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_approveSquareMembers (seqid, iprot, oprot, handler) = do
  args <- read_ApproveSquareMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.approveSquareMembers handler (approveSquareMembers_args_request args)
        let res = default_ApproveSquareMembers_result{approveSquareMembers_result_success = val}
        T.writeMessage oprot ("approveSquareMembers", T.M_REPLY, seqid) $
          write_ApproveSquareMembers_result oprot res)
      (\e  -> do
        let res = default_ApproveSquareMembers_result{approveSquareMembers_result_e = P.Just e}
        T.writeMessage oprot ("approveSquareMembers", T.M_REPLY, seqid) $
          write_ApproveSquareMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("approveSquareMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_CreateSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createSquareChat handler (createSquareChat_args_request args)
        let res = default_CreateSquareChat_result{createSquareChat_result_success = val}
        T.writeMessage oprot ("createSquareChat", T.M_REPLY, seqid) $
          write_CreateSquareChat_result oprot res)
      (\e  -> do
        let res = default_CreateSquareChat_result{createSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("createSquareChat", T.M_REPLY, seqid) $
          write_CreateSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSquare (seqid, iprot, oprot, handler) = do
  args <- read_CreateSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createSquare handler (createSquare_args_request args)
        let res = default_CreateSquare_result{createSquare_result_success = val}
        T.writeMessage oprot ("createSquare", T.M_REPLY, seqid) $
          write_CreateSquare_result oprot res)
      (\e  -> do
        let res = default_CreateSquare_result{createSquare_result_e = P.Just e}
        T.writeMessage oprot ("createSquare", T.M_REPLY, seqid) $
          write_CreateSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_deleteSquareChat (seqid, iprot, oprot, handler) = do
  args <- read_DeleteSquareChat_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.deleteSquareChat handler (deleteSquareChat_args_request args)
        let res = default_DeleteSquareChat_result{deleteSquareChat_result_success = val}
        T.writeMessage oprot ("deleteSquareChat", T.M_REPLY, seqid) $
          write_DeleteSquareChat_result oprot res)
      (\e  -> do
        let res = default_DeleteSquareChat_result{deleteSquareChat_result_e = P.Just e}
        T.writeMessage oprot ("deleteSquareChat", T.M_REPLY, seqid) $
          write_DeleteSquareChat_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("deleteSquareChat", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_deleteSquare (seqid, iprot, oprot, handler) = do
  args <- read_DeleteSquare_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.deleteSquare handler (deleteSquare_args_request args)
        let res = default_DeleteSquare_result{deleteSquare_result_success = val}
        T.writeMessage oprot ("deleteSquare", T.M_REPLY, seqid) $
          write_DeleteSquare_result oprot res)
      (\e  -> do
        let res = default_DeleteSquare_result{deleteSquare_result_e = P.Just e}
        T.writeMessage oprot ("deleteSquare", T.M_REPLY, seqid) $
          write_DeleteSquare_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("deleteSquare", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_destroyMessage (seqid, iprot, oprot, handler) = do
  args <- read_DestroyMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.destroyMessage handler (destroyMessage_args_request args)
        let res = default_DestroyMessage_result{destroyMessage_result_success = val}
        T.writeMessage oprot ("destroyMessage", T.M_REPLY, seqid) $
          write_DestroyMessage_result oprot res)
      (\e  -> do
        let res = default_DestroyMessage_result{destroyMessage_result_e = P.Just e}
        T.writeMessage oprot ("destroyMessage", T.M_REPLY, seqid) $
          write_DestroyMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("destroyMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinableSquareChats (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinableSquareChats_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinableSquareChats handler (getJoinableSquareChats_args_request args)
        let res = default_GetJoinableSquareChats_result{getJoinableSquareChats_result_success = val}
        T.writeMessage oprot ("getJoinableSquareChats", T.M_REPLY, seqid) $
          write_GetJoinableSquareChats_result oprot res)
      (\e  -> do
        let res = default_GetJoinableSquareChats_result{getJoinableSquareChats_result_e = P.Just e}
        T.writeMessage oprot ("getJoinableSquareChats", T.M_REPLY, seqid) $
          write_GetJoinableSquareChats_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinableSquareChats", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getInvitationTicketUrl (seqid, iprot, oprot, handler) = do
  args <- read_GetInvitationTicketUrl_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getInvitationTicketUrl handler (getInvitationTicketUrl_args_request args)
        let res = default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_success = val}
        T.writeMessage oprot ("getInvitationTicketUrl", T.M_REPLY, seqid) $
          write_GetInvitationTicketUrl_result oprot res)
      (\e  -> do
        let res = default_GetInvitationTicketUrl_result{getInvitationTicketUrl_result_e = P.Just e}
        T.writeMessage oprot ("getInvitationTicketUrl", T.M_REPLY, seqid) $
          write_GetInvitationTicketUrl_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getInvitationTicketUrl", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findSquareByInvitationTicket (seqid, iprot, oprot, handler) = do
  args <- read_FindSquareByInvitationTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findSquareByInvitationTicket handler (findSquareByInvitationTicket_args_request args)
        let res = default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_success = val}
        T.writeMessage oprot ("findSquareByInvitationTicket", T.M_REPLY, seqid) $
          write_FindSquareByInvitationTicket_result oprot res)
      (\e  -> do
        let res = default_FindSquareByInvitationTicket_result{findSquareByInvitationTicket_result_e = P.Just e}
        T.writeMessage oprot ("findSquareByInvitationTicket", T.M_REPLY, seqid) $
          write_FindSquareByInvitationTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findSquareByInvitationTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getSquareChatAnnouncements" -> process_getSquareChatAnnouncements (seqid,iprot,oprot,handler)
  "deleteSquareChatAnnouncement" -> process_deleteSquareChatAnnouncement (seqid,iprot,oprot,handler)
  "createSquareChatAnnouncement" -> process_createSquareChatAnnouncement (seqid,iprot,oprot,handler)
  "getNoteStatus" -> process_getNoteStatus (seqid,iprot,oprot,handler)
  "getSquareStatus" -> process_getSquareStatus (seqid,iprot,oprot,handler)
  "reportSquareMember" -> process_reportSquareMember (seqid,iprot,oprot,handler)
  "reportSquareMessage" -> process_reportSquareMessage (seqid,iprot,oprot,handler)
  "reportSquareChat" -> process_reportSquareChat (seqid,iprot,oprot,handler)
  "reportSquare" -> process_reportSquare (seqid,iprot,oprot,handler)
  "updateSquareMemberRelation" -> process_updateSquareMemberRelation (seqid,iprot,oprot,handler)
  "updateSquareAuthority" -> process_updateSquareAuthority (seqid,iprot,oprot,handler)
  "updateSquareChatMember" -> process_updateSquareChatMember (seqid,iprot,oprot,handler)
  "updateSquareChat" -> process_updateSquareChat (seqid,iprot,oprot,handler)
  "refreshSubscriptions" -> process_refreshSubscriptions (seqid,iprot,oprot,handler)
  "removeSubscriptions" -> process_removeSubscriptions (seqid,iprot,oprot,handler)
  "rejectSquareMembers" -> process_rejectSquareMembers (seqid,iprot,oprot,handler)
  "updateSquareMembers" -> process_updateSquareMembers (seqid,iprot,oprot,handler)
  "updateSquareMember" -> process_updateSquareMember (seqid,iprot,oprot,handler)
  "updateSquareFeatureSet" -> process_updateSquareFeatureSet (seqid,iprot,oprot,handler)
  "getSquareFeatureSet" -> process_getSquareFeatureSet (seqid,iprot,oprot,handler)
  "searchSquares" -> process_searchSquares (seqid,iprot,oprot,handler)
  "updateSquare" -> process_updateSquare (seqid,iprot,oprot,handler)
  "getCategories" -> process_getCategories (seqid,iprot,oprot,handler)
  "searchSquareMembers" -> process_searchSquareMembers (seqid,iprot,oprot,handler)
  "fetchSquareChatEvents" -> process_fetchSquareChatEvents (seqid,iprot,oprot,handler)
  "fetchMyEvents" -> process_fetchMyEvents (seqid,iprot,oprot,handler)
  "markAsRead" -> process_markAsRead (seqid,iprot,oprot,handler)
  "getSquareAuthority" -> process_getSquareAuthority (seqid,iprot,oprot,handler)
  "sendMessage" -> process_sendMessage (seqid,iprot,oprot,handler)
  "leaveSquare" -> process_leaveSquare (seqid,iprot,oprot,handler)
  "leaveSquareChat" -> process_leaveSquareChat (seqid,iprot,oprot,handler)
  "joinSquareChat" -> process_joinSquareChat (seqid,iprot,oprot,handler)
  "joinSquare" -> process_joinSquare (seqid,iprot,oprot,handler)
  "inviteToSquare" -> process_inviteToSquare (seqid,iprot,oprot,handler)
  "inviteToSquareChat" -> process_inviteToSquareChat (seqid,iprot,oprot,handler)
  "getSquareMember" -> process_getSquareMember (seqid,iprot,oprot,handler)
  "getSquareMembers" -> process_getSquareMembers (seqid,iprot,oprot,handler)
  "getSquareMemberRelation" -> process_getSquareMemberRelation (seqid,iprot,oprot,handler)
  "getSquareMemberRelations" -> process_getSquareMemberRelations (seqid,iprot,oprot,handler)
  "getSquareChatMembers" -> process_getSquareChatMembers (seqid,iprot,oprot,handler)
  "getSquareChatStatus" -> process_getSquareChatStatus (seqid,iprot,oprot,handler)
  "getSquareChat" -> process_getSquareChat (seqid,iprot,oprot,handler)
  "getSquare" -> process_getSquare (seqid,iprot,oprot,handler)
  "getJoinedSquares" -> process_getJoinedSquares (seqid,iprot,oprot,handler)
  "getJoinedSquareChats" -> process_getJoinedSquareChats (seqid,iprot,oprot,handler)
  "approveSquareMembers" -> process_approveSquareMembers (seqid,iprot,oprot,handler)
  "createSquareChat" -> process_createSquareChat (seqid,iprot,oprot,handler)
  "createSquare" -> process_createSquare (seqid,iprot,oprot,handler)
  "deleteSquareChat" -> process_deleteSquareChat (seqid,iprot,oprot,handler)
  "deleteSquare" -> process_deleteSquare (seqid,iprot,oprot,handler)
  "destroyMessage" -> process_destroyMessage (seqid,iprot,oprot,handler)
  "getJoinableSquareChats" -> process_getJoinableSquareChats (seqid,iprot,oprot,handler)
  "getInvitationTicketUrl" -> process_getInvitationTicketUrl (seqid,iprot,oprot,handler)
  "findSquareByInvitationTicket" -> process_findSquareByInvitationTicket (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
