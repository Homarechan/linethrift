{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module TalkService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified TalkService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetChatRoomAnnouncementsBulk_args = GetChatRoomAnnouncementsBulk_args  { getChatRoomAnnouncementsBulk_args_chatRoomMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChatRoomAnnouncementsBulk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChatRoomAnnouncementsBulk_args_chatRoomMids record  
instance QC.Arbitrary GetChatRoomAnnouncementsBulk_args where 
  arbitrary = M.liftM GetChatRoomAnnouncementsBulk_args (QC.arbitrary)
  shrink obj | obj == default_GetChatRoomAnnouncementsBulk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChatRoomAnnouncementsBulk_args{getChatRoomAnnouncementsBulk_args_chatRoomMids = getChatRoomAnnouncementsBulk_args_chatRoomMids obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncementsBulk_args{getChatRoomAnnouncementsBulk_args_chatRoomMids = getChatRoomAnnouncementsBulk_args_chatRoomMids obj}
    ]
from_GetChatRoomAnnouncementsBulk_args :: GetChatRoomAnnouncementsBulk_args -> T.ThriftVal
from_GetChatRoomAnnouncementsBulk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5945 -> P.Just (2, ("chatRoomMids",T.TList T.T_STRING $ P.map (\_v5947 -> T.TString $ E.encodeUtf8 _v5947) $ Vector.toList _v5945))) $ getChatRoomAnnouncementsBulk_args_chatRoomMids record
  ]
write_GetChatRoomAnnouncementsBulk_args :: T.Protocol p => p -> GetChatRoomAnnouncementsBulk_args -> P.IO ()
write_GetChatRoomAnnouncementsBulk_args oprot record = T.writeVal oprot $ from_GetChatRoomAnnouncementsBulk_args record
encode_GetChatRoomAnnouncementsBulk_args :: T.StatelessProtocol p => p -> GetChatRoomAnnouncementsBulk_args -> LBS.ByteString
encode_GetChatRoomAnnouncementsBulk_args oprot record = T.serializeVal oprot $ from_GetChatRoomAnnouncementsBulk_args record
to_GetChatRoomAnnouncementsBulk_args :: T.ThriftVal -> GetChatRoomAnnouncementsBulk_args
to_GetChatRoomAnnouncementsBulk_args (T.TStruct fields) = GetChatRoomAnnouncementsBulk_args{
  getChatRoomAnnouncementsBulk_args_chatRoomMids = P.maybe (getChatRoomAnnouncementsBulk_args_chatRoomMids default_GetChatRoomAnnouncementsBulk_args) (\(_,_val5949) -> (case _val5949 of {T.TList _ _val5950 -> (Vector.fromList $ P.map (\_v5951 -> (case _v5951 of {T.TString _val5952 -> E.decodeUtf8 _val5952; _ -> P.error "wrong type"})) _val5950); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetChatRoomAnnouncementsBulk_args _ = P.error "not a struct"
read_GetChatRoomAnnouncementsBulk_args :: T.Protocol p => p -> P.IO GetChatRoomAnnouncementsBulk_args
read_GetChatRoomAnnouncementsBulk_args iprot = to_GetChatRoomAnnouncementsBulk_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncementsBulk_args)
decode_GetChatRoomAnnouncementsBulk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChatRoomAnnouncementsBulk_args
decode_GetChatRoomAnnouncementsBulk_args iprot bs = to_GetChatRoomAnnouncementsBulk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncementsBulk_args) bs
typemap_GetChatRoomAnnouncementsBulk_args :: T.TypeMap
typemap_GetChatRoomAnnouncementsBulk_args = Map.fromList [(2,("chatRoomMids",(T.T_LIST T.T_STRING)))]
default_GetChatRoomAnnouncementsBulk_args :: GetChatRoomAnnouncementsBulk_args
default_GetChatRoomAnnouncementsBulk_args = GetChatRoomAnnouncementsBulk_args{
  getChatRoomAnnouncementsBulk_args_chatRoomMids = Vector.empty}
data GetChatRoomAnnouncementsBulk_result = GetChatRoomAnnouncementsBulk_result  { getChatRoomAnnouncementsBulk_result_success :: (Map.HashMap LT.Text (Vector.Vector ChatRoomAnnouncement))
  , getChatRoomAnnouncementsBulk_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChatRoomAnnouncementsBulk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChatRoomAnnouncementsBulk_result_success record   `H.hashWithSalt` getChatRoomAnnouncementsBulk_result_e record  
instance QC.Arbitrary GetChatRoomAnnouncementsBulk_result where 
  arbitrary = M.liftM GetChatRoomAnnouncementsBulk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChatRoomAnnouncementsBulk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_success = getChatRoomAnnouncementsBulk_result_success obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_success = getChatRoomAnnouncementsBulk_result_success obj}
    , if obj == default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_e = getChatRoomAnnouncementsBulk_result_e obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_e = getChatRoomAnnouncementsBulk_result_e obj}
    ]
from_GetChatRoomAnnouncementsBulk_result :: GetChatRoomAnnouncementsBulk_result -> T.ThriftVal
from_GetChatRoomAnnouncementsBulk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5955 -> (1, ("e",from_TalkException _v5955))) <$> getChatRoomAnnouncementsBulk_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5955 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_LIST (T.T_STRUCT typemap_ChatRoomAnnouncement)) $ P.map (\(_k5956,_v5957) -> (T.TString $ E.encodeUtf8 _k5956, T.TList (T.T_STRUCT typemap_ChatRoomAnnouncement) $ P.map (\_v5959 -> from_ChatRoomAnnouncement _v5959) $ Vector.toList _v5957)) $ Map.toList _v5955))) $ getChatRoomAnnouncementsBulk_result_success record
    , (\_v5955 -> (1, ("e",from_TalkException _v5955))) <$> getChatRoomAnnouncementsBulk_result_e record
    ]
    )
write_GetChatRoomAnnouncementsBulk_result :: T.Protocol p => p -> GetChatRoomAnnouncementsBulk_result -> P.IO ()
write_GetChatRoomAnnouncementsBulk_result oprot record = T.writeVal oprot $ from_GetChatRoomAnnouncementsBulk_result record
encode_GetChatRoomAnnouncementsBulk_result :: T.StatelessProtocol p => p -> GetChatRoomAnnouncementsBulk_result -> LBS.ByteString
encode_GetChatRoomAnnouncementsBulk_result oprot record = T.serializeVal oprot $ from_GetChatRoomAnnouncementsBulk_result record
to_GetChatRoomAnnouncementsBulk_result :: T.ThriftVal -> GetChatRoomAnnouncementsBulk_result
to_GetChatRoomAnnouncementsBulk_result (T.TStruct fields) = GetChatRoomAnnouncementsBulk_result{
  getChatRoomAnnouncementsBulk_result_success = P.maybe (getChatRoomAnnouncementsBulk_result_success default_GetChatRoomAnnouncementsBulk_result) (\(_,_val5961) -> (case _val5961 of {T.TMap _ _ _val5962 -> (Map.fromList $ P.map (\(_k5964,_v5963) -> ((case _k5964 of {T.TString _val5965 -> E.decodeUtf8 _val5965; _ -> P.error "wrong type"}),(case _v5963 of {T.TList _ _val5966 -> (Vector.fromList $ P.map (\_v5967 -> (case _v5967 of {T.TStruct _val5968 -> (to_ChatRoomAnnouncement (T.TStruct _val5968)); _ -> P.error "wrong type"})) _val5966); _ -> P.error "wrong type"}))) _val5962); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChatRoomAnnouncementsBulk_result_e = P.maybe (P.Nothing) (\(_,_val5961) -> P.Just (case _val5961 of {T.TStruct _val5969 -> (to_TalkException (T.TStruct _val5969)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChatRoomAnnouncementsBulk_result _ = P.error "not a struct"
read_GetChatRoomAnnouncementsBulk_result :: T.Protocol p => p -> P.IO GetChatRoomAnnouncementsBulk_result
read_GetChatRoomAnnouncementsBulk_result iprot = to_GetChatRoomAnnouncementsBulk_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncementsBulk_result)
decode_GetChatRoomAnnouncementsBulk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChatRoomAnnouncementsBulk_result
decode_GetChatRoomAnnouncementsBulk_result iprot bs = to_GetChatRoomAnnouncementsBulk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncementsBulk_result) bs
typemap_GetChatRoomAnnouncementsBulk_result :: T.TypeMap
typemap_GetChatRoomAnnouncementsBulk_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_LIST (T.T_STRUCT typemap_ChatRoomAnnouncement))))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetChatRoomAnnouncementsBulk_result :: GetChatRoomAnnouncementsBulk_result
default_GetChatRoomAnnouncementsBulk_result = GetChatRoomAnnouncementsBulk_result{
  getChatRoomAnnouncementsBulk_result_success = Map.empty,
  getChatRoomAnnouncementsBulk_result_e = P.Nothing}
data GetChatRoomAnnouncements_args = GetChatRoomAnnouncements_args  { getChatRoomAnnouncements_args_chatRoomMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChatRoomAnnouncements_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChatRoomAnnouncements_args_chatRoomMid record  
instance QC.Arbitrary GetChatRoomAnnouncements_args where 
  arbitrary = M.liftM GetChatRoomAnnouncements_args (QC.arbitrary)
  shrink obj | obj == default_GetChatRoomAnnouncements_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChatRoomAnnouncements_args{getChatRoomAnnouncements_args_chatRoomMid = getChatRoomAnnouncements_args_chatRoomMid obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncements_args{getChatRoomAnnouncements_args_chatRoomMid = getChatRoomAnnouncements_args_chatRoomMid obj}
    ]
from_GetChatRoomAnnouncements_args :: GetChatRoomAnnouncements_args -> T.ThriftVal
from_GetChatRoomAnnouncements_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5972 -> P.Just (2, ("chatRoomMid",T.TString $ E.encodeUtf8 _v5972))) $ getChatRoomAnnouncements_args_chatRoomMid record
  ]
write_GetChatRoomAnnouncements_args :: T.Protocol p => p -> GetChatRoomAnnouncements_args -> P.IO ()
write_GetChatRoomAnnouncements_args oprot record = T.writeVal oprot $ from_GetChatRoomAnnouncements_args record
encode_GetChatRoomAnnouncements_args :: T.StatelessProtocol p => p -> GetChatRoomAnnouncements_args -> LBS.ByteString
encode_GetChatRoomAnnouncements_args oprot record = T.serializeVal oprot $ from_GetChatRoomAnnouncements_args record
to_GetChatRoomAnnouncements_args :: T.ThriftVal -> GetChatRoomAnnouncements_args
to_GetChatRoomAnnouncements_args (T.TStruct fields) = GetChatRoomAnnouncements_args{
  getChatRoomAnnouncements_args_chatRoomMid = P.maybe (getChatRoomAnnouncements_args_chatRoomMid default_GetChatRoomAnnouncements_args) (\(_,_val5974) -> (case _val5974 of {T.TString _val5975 -> E.decodeUtf8 _val5975; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetChatRoomAnnouncements_args _ = P.error "not a struct"
read_GetChatRoomAnnouncements_args :: T.Protocol p => p -> P.IO GetChatRoomAnnouncements_args
read_GetChatRoomAnnouncements_args iprot = to_GetChatRoomAnnouncements_args <$> T.readVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncements_args)
decode_GetChatRoomAnnouncements_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChatRoomAnnouncements_args
decode_GetChatRoomAnnouncements_args iprot bs = to_GetChatRoomAnnouncements_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncements_args) bs
typemap_GetChatRoomAnnouncements_args :: T.TypeMap
typemap_GetChatRoomAnnouncements_args = Map.fromList [(2,("chatRoomMid",T.T_STRING))]
default_GetChatRoomAnnouncements_args :: GetChatRoomAnnouncements_args
default_GetChatRoomAnnouncements_args = GetChatRoomAnnouncements_args{
  getChatRoomAnnouncements_args_chatRoomMid = ""}
data GetChatRoomAnnouncements_result = GetChatRoomAnnouncements_result  { getChatRoomAnnouncements_result_success :: (Vector.Vector ChatRoomAnnouncement)
  , getChatRoomAnnouncements_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetChatRoomAnnouncements_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getChatRoomAnnouncements_result_success record   `H.hashWithSalt` getChatRoomAnnouncements_result_e record  
instance QC.Arbitrary GetChatRoomAnnouncements_result where 
  arbitrary = M.liftM GetChatRoomAnnouncements_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetChatRoomAnnouncements_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_success = getChatRoomAnnouncements_result_success obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_success = getChatRoomAnnouncements_result_success obj}
    , if obj == default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_e = getChatRoomAnnouncements_result_e obj} then P.Nothing else P.Just $ default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_e = getChatRoomAnnouncements_result_e obj}
    ]
from_GetChatRoomAnnouncements_result :: GetChatRoomAnnouncements_result -> T.ThriftVal
from_GetChatRoomAnnouncements_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5978 -> (1, ("e",from_TalkException _v5978))) <$> getChatRoomAnnouncements_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5978 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ChatRoomAnnouncement) $ P.map (\_v5980 -> from_ChatRoomAnnouncement _v5980) $ Vector.toList _v5978))) $ getChatRoomAnnouncements_result_success record
    , (\_v5978 -> (1, ("e",from_TalkException _v5978))) <$> getChatRoomAnnouncements_result_e record
    ]
    )
write_GetChatRoomAnnouncements_result :: T.Protocol p => p -> GetChatRoomAnnouncements_result -> P.IO ()
write_GetChatRoomAnnouncements_result oprot record = T.writeVal oprot $ from_GetChatRoomAnnouncements_result record
encode_GetChatRoomAnnouncements_result :: T.StatelessProtocol p => p -> GetChatRoomAnnouncements_result -> LBS.ByteString
encode_GetChatRoomAnnouncements_result oprot record = T.serializeVal oprot $ from_GetChatRoomAnnouncements_result record
to_GetChatRoomAnnouncements_result :: T.ThriftVal -> GetChatRoomAnnouncements_result
to_GetChatRoomAnnouncements_result (T.TStruct fields) = GetChatRoomAnnouncements_result{
  getChatRoomAnnouncements_result_success = P.maybe (getChatRoomAnnouncements_result_success default_GetChatRoomAnnouncements_result) (\(_,_val5982) -> (case _val5982 of {T.TList _ _val5983 -> (Vector.fromList $ P.map (\_v5984 -> (case _v5984 of {T.TStruct _val5985 -> (to_ChatRoomAnnouncement (T.TStruct _val5985)); _ -> P.error "wrong type"})) _val5983); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getChatRoomAnnouncements_result_e = P.maybe (P.Nothing) (\(_,_val5982) -> P.Just (case _val5982 of {T.TStruct _val5986 -> (to_TalkException (T.TStruct _val5986)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetChatRoomAnnouncements_result _ = P.error "not a struct"
read_GetChatRoomAnnouncements_result :: T.Protocol p => p -> P.IO GetChatRoomAnnouncements_result
read_GetChatRoomAnnouncements_result iprot = to_GetChatRoomAnnouncements_result <$> T.readVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncements_result)
decode_GetChatRoomAnnouncements_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetChatRoomAnnouncements_result
decode_GetChatRoomAnnouncements_result iprot bs = to_GetChatRoomAnnouncements_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetChatRoomAnnouncements_result) bs
typemap_GetChatRoomAnnouncements_result :: T.TypeMap
typemap_GetChatRoomAnnouncements_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ChatRoomAnnouncement)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetChatRoomAnnouncements_result :: GetChatRoomAnnouncements_result
default_GetChatRoomAnnouncements_result = GetChatRoomAnnouncements_result{
  getChatRoomAnnouncements_result_success = Vector.empty,
  getChatRoomAnnouncements_result_e = P.Nothing}
data CreateChatRoomAnnouncement_args = CreateChatRoomAnnouncement_args  { createChatRoomAnnouncement_args_reqSeq :: I.Int32
  , createChatRoomAnnouncement_args_chatRoomMid :: LT.Text
  , createChatRoomAnnouncement_args_type :: ChatRoomAnnouncementType
  , createChatRoomAnnouncement_args_contents :: ChatRoomAnnouncementContents
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateChatRoomAnnouncement_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createChatRoomAnnouncement_args_reqSeq record   `H.hashWithSalt` createChatRoomAnnouncement_args_chatRoomMid record   `H.hashWithSalt` createChatRoomAnnouncement_args_type record   `H.hashWithSalt` createChatRoomAnnouncement_args_contents record  
instance QC.Arbitrary CreateChatRoomAnnouncement_args where 
  arbitrary = M.liftM CreateChatRoomAnnouncement_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateChatRoomAnnouncement_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_reqSeq = createChatRoomAnnouncement_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_reqSeq = createChatRoomAnnouncement_args_reqSeq obj}
    , if obj == default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_chatRoomMid = createChatRoomAnnouncement_args_chatRoomMid obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_chatRoomMid = createChatRoomAnnouncement_args_chatRoomMid obj}
    , if obj == default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_type = createChatRoomAnnouncement_args_type obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_type = createChatRoomAnnouncement_args_type obj}
    , if obj == default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_contents = createChatRoomAnnouncement_args_contents obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_args{createChatRoomAnnouncement_args_contents = createChatRoomAnnouncement_args_contents obj}
    ]
from_CreateChatRoomAnnouncement_args :: CreateChatRoomAnnouncement_args -> T.ThriftVal
from_CreateChatRoomAnnouncement_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5989 -> P.Just (1, ("reqSeq",T.TI32 _v5989))) $ createChatRoomAnnouncement_args_reqSeq record
  , (\_v5989 -> P.Just (2, ("chatRoomMid",T.TString $ E.encodeUtf8 _v5989))) $ createChatRoomAnnouncement_args_chatRoomMid record
  , (\_v5989 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v5989))) $ createChatRoomAnnouncement_args_type record
  , (\_v5989 -> P.Just (4, ("contents",from_ChatRoomAnnouncementContents _v5989))) $ createChatRoomAnnouncement_args_contents record
  ]
write_CreateChatRoomAnnouncement_args :: T.Protocol p => p -> CreateChatRoomAnnouncement_args -> P.IO ()
write_CreateChatRoomAnnouncement_args oprot record = T.writeVal oprot $ from_CreateChatRoomAnnouncement_args record
encode_CreateChatRoomAnnouncement_args :: T.StatelessProtocol p => p -> CreateChatRoomAnnouncement_args -> LBS.ByteString
encode_CreateChatRoomAnnouncement_args oprot record = T.serializeVal oprot $ from_CreateChatRoomAnnouncement_args record
to_CreateChatRoomAnnouncement_args :: T.ThriftVal -> CreateChatRoomAnnouncement_args
to_CreateChatRoomAnnouncement_args (T.TStruct fields) = CreateChatRoomAnnouncement_args{
  createChatRoomAnnouncement_args_reqSeq = P.maybe (createChatRoomAnnouncement_args_reqSeq default_CreateChatRoomAnnouncement_args) (\(_,_val5991) -> (case _val5991 of {T.TI32 _val5992 -> _val5992; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createChatRoomAnnouncement_args_chatRoomMid = P.maybe (createChatRoomAnnouncement_args_chatRoomMid default_CreateChatRoomAnnouncement_args) (\(_,_val5991) -> (case _val5991 of {T.TString _val5993 -> E.decodeUtf8 _val5993; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createChatRoomAnnouncement_args_type = P.maybe (createChatRoomAnnouncement_args_type default_CreateChatRoomAnnouncement_args) (\(_,_val5991) -> (case _val5991 of {T.TI32 _val5994 -> P.toEnum $ P.fromIntegral _val5994; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createChatRoomAnnouncement_args_contents = P.maybe (createChatRoomAnnouncement_args_contents default_CreateChatRoomAnnouncement_args) (\(_,_val5991) -> (case _val5991 of {T.TStruct _val5995 -> (to_ChatRoomAnnouncementContents (T.TStruct _val5995)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CreateChatRoomAnnouncement_args _ = P.error "not a struct"
read_CreateChatRoomAnnouncement_args :: T.Protocol p => p -> P.IO CreateChatRoomAnnouncement_args
read_CreateChatRoomAnnouncement_args iprot = to_CreateChatRoomAnnouncement_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateChatRoomAnnouncement_args)
decode_CreateChatRoomAnnouncement_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateChatRoomAnnouncement_args
decode_CreateChatRoomAnnouncement_args iprot bs = to_CreateChatRoomAnnouncement_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateChatRoomAnnouncement_args) bs
typemap_CreateChatRoomAnnouncement_args :: T.TypeMap
typemap_CreateChatRoomAnnouncement_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("chatRoomMid",T.T_STRING)),(3,("type",T.T_I32)),(4,("contents",(T.T_STRUCT typemap_ChatRoomAnnouncementContents)))]
default_CreateChatRoomAnnouncement_args :: CreateChatRoomAnnouncement_args
default_CreateChatRoomAnnouncement_args = CreateChatRoomAnnouncement_args{
  createChatRoomAnnouncement_args_reqSeq = 0,
  createChatRoomAnnouncement_args_chatRoomMid = "",
  createChatRoomAnnouncement_args_type = (P.toEnum 0),
  createChatRoomAnnouncement_args_contents = default_ChatRoomAnnouncementContents}
data CreateChatRoomAnnouncement_result = CreateChatRoomAnnouncement_result  { createChatRoomAnnouncement_result_success :: ChatRoomAnnouncement
  , createChatRoomAnnouncement_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateChatRoomAnnouncement_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createChatRoomAnnouncement_result_success record   `H.hashWithSalt` createChatRoomAnnouncement_result_e record  
instance QC.Arbitrary CreateChatRoomAnnouncement_result where 
  arbitrary = M.liftM CreateChatRoomAnnouncement_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateChatRoomAnnouncement_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_success = createChatRoomAnnouncement_result_success obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_success = createChatRoomAnnouncement_result_success obj}
    , if obj == default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_e = createChatRoomAnnouncement_result_e obj} then P.Nothing else P.Just $ default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_e = createChatRoomAnnouncement_result_e obj}
    ]
from_CreateChatRoomAnnouncement_result :: CreateChatRoomAnnouncement_result -> T.ThriftVal
from_CreateChatRoomAnnouncement_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5998 -> (1, ("e",from_TalkException _v5998))) <$> createChatRoomAnnouncement_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5998 -> P.Just (0, ("success",from_ChatRoomAnnouncement _v5998))) $ createChatRoomAnnouncement_result_success record
    , (\_v5998 -> (1, ("e",from_TalkException _v5998))) <$> createChatRoomAnnouncement_result_e record
    ]
    )
write_CreateChatRoomAnnouncement_result :: T.Protocol p => p -> CreateChatRoomAnnouncement_result -> P.IO ()
write_CreateChatRoomAnnouncement_result oprot record = T.writeVal oprot $ from_CreateChatRoomAnnouncement_result record
encode_CreateChatRoomAnnouncement_result :: T.StatelessProtocol p => p -> CreateChatRoomAnnouncement_result -> LBS.ByteString
encode_CreateChatRoomAnnouncement_result oprot record = T.serializeVal oprot $ from_CreateChatRoomAnnouncement_result record
to_CreateChatRoomAnnouncement_result :: T.ThriftVal -> CreateChatRoomAnnouncement_result
to_CreateChatRoomAnnouncement_result (T.TStruct fields) = CreateChatRoomAnnouncement_result{
  createChatRoomAnnouncement_result_success = P.maybe (createChatRoomAnnouncement_result_success default_CreateChatRoomAnnouncement_result) (\(_,_val6000) -> (case _val6000 of {T.TStruct _val6001 -> (to_ChatRoomAnnouncement (T.TStruct _val6001)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createChatRoomAnnouncement_result_e = P.maybe (P.Nothing) (\(_,_val6000) -> P.Just (case _val6000 of {T.TStruct _val6002 -> (to_TalkException (T.TStruct _val6002)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateChatRoomAnnouncement_result _ = P.error "not a struct"
read_CreateChatRoomAnnouncement_result :: T.Protocol p => p -> P.IO CreateChatRoomAnnouncement_result
read_CreateChatRoomAnnouncement_result iprot = to_CreateChatRoomAnnouncement_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateChatRoomAnnouncement_result)
decode_CreateChatRoomAnnouncement_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateChatRoomAnnouncement_result
decode_CreateChatRoomAnnouncement_result iprot bs = to_CreateChatRoomAnnouncement_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateChatRoomAnnouncement_result) bs
typemap_CreateChatRoomAnnouncement_result :: T.TypeMap
typemap_CreateChatRoomAnnouncement_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ChatRoomAnnouncement))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateChatRoomAnnouncement_result :: CreateChatRoomAnnouncement_result
default_CreateChatRoomAnnouncement_result = CreateChatRoomAnnouncement_result{
  createChatRoomAnnouncement_result_success = default_ChatRoomAnnouncement,
  createChatRoomAnnouncement_result_e = P.Nothing}
data RemoveChatRoomAnnouncement_args = RemoveChatRoomAnnouncement_args  { removeChatRoomAnnouncement_args_reqSeq :: I.Int32
  , removeChatRoomAnnouncement_args_chatRoomMid :: LT.Text
  , removeChatRoomAnnouncement_args_announcementSeq :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveChatRoomAnnouncement_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeChatRoomAnnouncement_args_reqSeq record   `H.hashWithSalt` removeChatRoomAnnouncement_args_chatRoomMid record   `H.hashWithSalt` removeChatRoomAnnouncement_args_announcementSeq record  
instance QC.Arbitrary RemoveChatRoomAnnouncement_args where 
  arbitrary = M.liftM RemoveChatRoomAnnouncement_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveChatRoomAnnouncement_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_reqSeq = removeChatRoomAnnouncement_args_reqSeq obj} then P.Nothing else P.Just $ default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_reqSeq = removeChatRoomAnnouncement_args_reqSeq obj}
    , if obj == default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_chatRoomMid = removeChatRoomAnnouncement_args_chatRoomMid obj} then P.Nothing else P.Just $ default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_chatRoomMid = removeChatRoomAnnouncement_args_chatRoomMid obj}
    , if obj == default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_announcementSeq = removeChatRoomAnnouncement_args_announcementSeq obj} then P.Nothing else P.Just $ default_RemoveChatRoomAnnouncement_args{removeChatRoomAnnouncement_args_announcementSeq = removeChatRoomAnnouncement_args_announcementSeq obj}
    ]
from_RemoveChatRoomAnnouncement_args :: RemoveChatRoomAnnouncement_args -> T.ThriftVal
from_RemoveChatRoomAnnouncement_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6005 -> P.Just (1, ("reqSeq",T.TI32 _v6005))) $ removeChatRoomAnnouncement_args_reqSeq record
  , (\_v6005 -> P.Just (2, ("chatRoomMid",T.TString $ E.encodeUtf8 _v6005))) $ removeChatRoomAnnouncement_args_chatRoomMid record
  , (\_v6005 -> P.Just (3, ("announcementSeq",T.TI64 _v6005))) $ removeChatRoomAnnouncement_args_announcementSeq record
  ]
write_RemoveChatRoomAnnouncement_args :: T.Protocol p => p -> RemoveChatRoomAnnouncement_args -> P.IO ()
write_RemoveChatRoomAnnouncement_args oprot record = T.writeVal oprot $ from_RemoveChatRoomAnnouncement_args record
encode_RemoveChatRoomAnnouncement_args :: T.StatelessProtocol p => p -> RemoveChatRoomAnnouncement_args -> LBS.ByteString
encode_RemoveChatRoomAnnouncement_args oprot record = T.serializeVal oprot $ from_RemoveChatRoomAnnouncement_args record
to_RemoveChatRoomAnnouncement_args :: T.ThriftVal -> RemoveChatRoomAnnouncement_args
to_RemoveChatRoomAnnouncement_args (T.TStruct fields) = RemoveChatRoomAnnouncement_args{
  removeChatRoomAnnouncement_args_reqSeq = P.maybe (removeChatRoomAnnouncement_args_reqSeq default_RemoveChatRoomAnnouncement_args) (\(_,_val6007) -> (case _val6007 of {T.TI32 _val6008 -> _val6008; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeChatRoomAnnouncement_args_chatRoomMid = P.maybe (removeChatRoomAnnouncement_args_chatRoomMid default_RemoveChatRoomAnnouncement_args) (\(_,_val6007) -> (case _val6007 of {T.TString _val6009 -> E.decodeUtf8 _val6009; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  removeChatRoomAnnouncement_args_announcementSeq = P.maybe (removeChatRoomAnnouncement_args_announcementSeq default_RemoveChatRoomAnnouncement_args) (\(_,_val6007) -> (case _val6007 of {T.TI64 _val6010 -> _val6010; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RemoveChatRoomAnnouncement_args _ = P.error "not a struct"
read_RemoveChatRoomAnnouncement_args :: T.Protocol p => p -> P.IO RemoveChatRoomAnnouncement_args
read_RemoveChatRoomAnnouncement_args iprot = to_RemoveChatRoomAnnouncement_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveChatRoomAnnouncement_args)
decode_RemoveChatRoomAnnouncement_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveChatRoomAnnouncement_args
decode_RemoveChatRoomAnnouncement_args iprot bs = to_RemoveChatRoomAnnouncement_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveChatRoomAnnouncement_args) bs
typemap_RemoveChatRoomAnnouncement_args :: T.TypeMap
typemap_RemoveChatRoomAnnouncement_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("chatRoomMid",T.T_STRING)),(3,("announcementSeq",T.T_I64))]
default_RemoveChatRoomAnnouncement_args :: RemoveChatRoomAnnouncement_args
default_RemoveChatRoomAnnouncement_args = RemoveChatRoomAnnouncement_args{
  removeChatRoomAnnouncement_args_reqSeq = 0,
  removeChatRoomAnnouncement_args_chatRoomMid = "",
  removeChatRoomAnnouncement_args_announcementSeq = 0}
data RemoveChatRoomAnnouncement_result = RemoveChatRoomAnnouncement_result  { removeChatRoomAnnouncement_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveChatRoomAnnouncement_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeChatRoomAnnouncement_result_e record  
instance QC.Arbitrary RemoveChatRoomAnnouncement_result where 
  arbitrary = M.liftM RemoveChatRoomAnnouncement_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveChatRoomAnnouncement_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveChatRoomAnnouncement_result{removeChatRoomAnnouncement_result_e = removeChatRoomAnnouncement_result_e obj} then P.Nothing else P.Just $ default_RemoveChatRoomAnnouncement_result{removeChatRoomAnnouncement_result_e = removeChatRoomAnnouncement_result_e obj}
    ]
from_RemoveChatRoomAnnouncement_result :: RemoveChatRoomAnnouncement_result -> T.ThriftVal
from_RemoveChatRoomAnnouncement_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6013 -> (1, ("e",from_TalkException _v6013))) <$> removeChatRoomAnnouncement_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6013 -> (1, ("e",from_TalkException _v6013))) <$> removeChatRoomAnnouncement_result_e record
    ]
    )
write_RemoveChatRoomAnnouncement_result :: T.Protocol p => p -> RemoveChatRoomAnnouncement_result -> P.IO ()
write_RemoveChatRoomAnnouncement_result oprot record = T.writeVal oprot $ from_RemoveChatRoomAnnouncement_result record
encode_RemoveChatRoomAnnouncement_result :: T.StatelessProtocol p => p -> RemoveChatRoomAnnouncement_result -> LBS.ByteString
encode_RemoveChatRoomAnnouncement_result oprot record = T.serializeVal oprot $ from_RemoveChatRoomAnnouncement_result record
to_RemoveChatRoomAnnouncement_result :: T.ThriftVal -> RemoveChatRoomAnnouncement_result
to_RemoveChatRoomAnnouncement_result (T.TStruct fields) = RemoveChatRoomAnnouncement_result{
  removeChatRoomAnnouncement_result_e = P.maybe (P.Nothing) (\(_,_val6015) -> P.Just (case _val6015 of {T.TStruct _val6016 -> (to_TalkException (T.TStruct _val6016)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveChatRoomAnnouncement_result _ = P.error "not a struct"
read_RemoveChatRoomAnnouncement_result :: T.Protocol p => p -> P.IO RemoveChatRoomAnnouncement_result
read_RemoveChatRoomAnnouncement_result iprot = to_RemoveChatRoomAnnouncement_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveChatRoomAnnouncement_result)
decode_RemoveChatRoomAnnouncement_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveChatRoomAnnouncement_result
decode_RemoveChatRoomAnnouncement_result iprot bs = to_RemoveChatRoomAnnouncement_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveChatRoomAnnouncement_result) bs
typemap_RemoveChatRoomAnnouncement_result :: T.TypeMap
typemap_RemoveChatRoomAnnouncement_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveChatRoomAnnouncement_result :: RemoveChatRoomAnnouncement_result
default_RemoveChatRoomAnnouncement_result = RemoveChatRoomAnnouncement_result{
  removeChatRoomAnnouncement_result_e = P.Nothing}
data UnsendMessage_args = UnsendMessage_args  { unsendMessage_args_seq :: I.Int32
  , unsendMessage_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsendMessage_args_seq record   `H.hashWithSalt` unsendMessage_args_messageId record  
instance QC.Arbitrary UnsendMessage_args where 
  arbitrary = M.liftM UnsendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnsendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsendMessage_args{unsendMessage_args_seq = unsendMessage_args_seq obj} then P.Nothing else P.Just $ default_UnsendMessage_args{unsendMessage_args_seq = unsendMessage_args_seq obj}
    , if obj == default_UnsendMessage_args{unsendMessage_args_messageId = unsendMessage_args_messageId obj} then P.Nothing else P.Just $ default_UnsendMessage_args{unsendMessage_args_messageId = unsendMessage_args_messageId obj}
    ]
from_UnsendMessage_args :: UnsendMessage_args -> T.ThriftVal
from_UnsendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6019 -> P.Just (1, ("seq",T.TI32 _v6019))) $ unsendMessage_args_seq record
  , (\_v6019 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v6019))) $ unsendMessage_args_messageId record
  ]
write_UnsendMessage_args :: T.Protocol p => p -> UnsendMessage_args -> P.IO ()
write_UnsendMessage_args oprot record = T.writeVal oprot $ from_UnsendMessage_args record
encode_UnsendMessage_args :: T.StatelessProtocol p => p -> UnsendMessage_args -> LBS.ByteString
encode_UnsendMessage_args oprot record = T.serializeVal oprot $ from_UnsendMessage_args record
to_UnsendMessage_args :: T.ThriftVal -> UnsendMessage_args
to_UnsendMessage_args (T.TStruct fields) = UnsendMessage_args{
  unsendMessage_args_seq = P.maybe (unsendMessage_args_seq default_UnsendMessage_args) (\(_,_val6021) -> (case _val6021 of {T.TI32 _val6022 -> _val6022; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unsendMessage_args_messageId = P.maybe (unsendMessage_args_messageId default_UnsendMessage_args) (\(_,_val6021) -> (case _val6021 of {T.TString _val6023 -> E.decodeUtf8 _val6023; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnsendMessage_args _ = P.error "not a struct"
read_UnsendMessage_args :: T.Protocol p => p -> P.IO UnsendMessage_args
read_UnsendMessage_args iprot = to_UnsendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_UnsendMessage_args)
decode_UnsendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsendMessage_args
decode_UnsendMessage_args iprot bs = to_UnsendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsendMessage_args) bs
typemap_UnsendMessage_args :: T.TypeMap
typemap_UnsendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("messageId",T.T_STRING))]
default_UnsendMessage_args :: UnsendMessage_args
default_UnsendMessage_args = UnsendMessage_args{
  unsendMessage_args_seq = 0,
  unsendMessage_args_messageId = ""}
data UnsendMessage_result = UnsendMessage_result  { unsendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsendMessage_result_e record  
instance QC.Arbitrary UnsendMessage_result where 
  arbitrary = M.liftM UnsendMessage_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnsendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsendMessage_result{unsendMessage_result_e = unsendMessage_result_e obj} then P.Nothing else P.Just $ default_UnsendMessage_result{unsendMessage_result_e = unsendMessage_result_e obj}
    ]
from_UnsendMessage_result :: UnsendMessage_result -> T.ThriftVal
from_UnsendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6026 -> (1, ("e",from_TalkException _v6026))) <$> unsendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6026 -> (1, ("e",from_TalkException _v6026))) <$> unsendMessage_result_e record
    ]
    )
write_UnsendMessage_result :: T.Protocol p => p -> UnsendMessage_result -> P.IO ()
write_UnsendMessage_result oprot record = T.writeVal oprot $ from_UnsendMessage_result record
encode_UnsendMessage_result :: T.StatelessProtocol p => p -> UnsendMessage_result -> LBS.ByteString
encode_UnsendMessage_result oprot record = T.serializeVal oprot $ from_UnsendMessage_result record
to_UnsendMessage_result :: T.ThriftVal -> UnsendMessage_result
to_UnsendMessage_result (T.TStruct fields) = UnsendMessage_result{
  unsendMessage_result_e = P.maybe (P.Nothing) (\(_,_val6028) -> P.Just (case _val6028 of {T.TStruct _val6029 -> (to_TalkException (T.TStruct _val6029)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnsendMessage_result _ = P.error "not a struct"
read_UnsendMessage_result :: T.Protocol p => p -> P.IO UnsendMessage_result
read_UnsendMessage_result iprot = to_UnsendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_UnsendMessage_result)
decode_UnsendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsendMessage_result
decode_UnsendMessage_result iprot bs = to_UnsendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsendMessage_result) bs
typemap_UnsendMessage_result :: T.TypeMap
typemap_UnsendMessage_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnsendMessage_result :: UnsendMessage_result
default_UnsendMessage_result = UnsendMessage_result{
  unsendMessage_result_e = P.Nothing}
data GetGroupWithoutMembers_args = GetGroupWithoutMembers_args  { getGroupWithoutMembers_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupWithoutMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupWithoutMembers_args_groupId record  
instance QC.Arbitrary GetGroupWithoutMembers_args where 
  arbitrary = M.liftM GetGroupWithoutMembers_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupWithoutMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupWithoutMembers_args{getGroupWithoutMembers_args_groupId = getGroupWithoutMembers_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupWithoutMembers_args{getGroupWithoutMembers_args_groupId = getGroupWithoutMembers_args_groupId obj}
    ]
from_GetGroupWithoutMembers_args :: GetGroupWithoutMembers_args -> T.ThriftVal
from_GetGroupWithoutMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6032 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v6032))) $ getGroupWithoutMembers_args_groupId record
  ]
write_GetGroupWithoutMembers_args :: T.Protocol p => p -> GetGroupWithoutMembers_args -> P.IO ()
write_GetGroupWithoutMembers_args oprot record = T.writeVal oprot $ from_GetGroupWithoutMembers_args record
encode_GetGroupWithoutMembers_args :: T.StatelessProtocol p => p -> GetGroupWithoutMembers_args -> LBS.ByteString
encode_GetGroupWithoutMembers_args oprot record = T.serializeVal oprot $ from_GetGroupWithoutMembers_args record
to_GetGroupWithoutMembers_args :: T.ThriftVal -> GetGroupWithoutMembers_args
to_GetGroupWithoutMembers_args (T.TStruct fields) = GetGroupWithoutMembers_args{
  getGroupWithoutMembers_args_groupId = P.maybe (getGroupWithoutMembers_args_groupId default_GetGroupWithoutMembers_args) (\(_,_val6034) -> (case _val6034 of {T.TString _val6035 -> E.decodeUtf8 _val6035; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroupWithoutMembers_args _ = P.error "not a struct"
read_GetGroupWithoutMembers_args :: T.Protocol p => p -> P.IO GetGroupWithoutMembers_args
read_GetGroupWithoutMembers_args iprot = to_GetGroupWithoutMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupWithoutMembers_args)
decode_GetGroupWithoutMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupWithoutMembers_args
decode_GetGroupWithoutMembers_args iprot bs = to_GetGroupWithoutMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupWithoutMembers_args) bs
typemap_GetGroupWithoutMembers_args :: T.TypeMap
typemap_GetGroupWithoutMembers_args = Map.fromList [(2,("groupId",T.T_STRING))]
default_GetGroupWithoutMembers_args :: GetGroupWithoutMembers_args
default_GetGroupWithoutMembers_args = GetGroupWithoutMembers_args{
  getGroupWithoutMembers_args_groupId = ""}
data GetGroupWithoutMembers_result = GetGroupWithoutMembers_result  { getGroupWithoutMembers_result_success :: Group
  , getGroupWithoutMembers_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupWithoutMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupWithoutMembers_result_success record   `H.hashWithSalt` getGroupWithoutMembers_result_e record  
instance QC.Arbitrary GetGroupWithoutMembers_result where 
  arbitrary = M.liftM GetGroupWithoutMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupWithoutMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_success = getGroupWithoutMembers_result_success obj} then P.Nothing else P.Just $ default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_success = getGroupWithoutMembers_result_success obj}
    , if obj == default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_e = getGroupWithoutMembers_result_e obj} then P.Nothing else P.Just $ default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_e = getGroupWithoutMembers_result_e obj}
    ]
from_GetGroupWithoutMembers_result :: GetGroupWithoutMembers_result -> T.ThriftVal
from_GetGroupWithoutMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6038 -> (1, ("e",from_TalkException _v6038))) <$> getGroupWithoutMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6038 -> P.Just (0, ("success",from_Group _v6038))) $ getGroupWithoutMembers_result_success record
    , (\_v6038 -> (1, ("e",from_TalkException _v6038))) <$> getGroupWithoutMembers_result_e record
    ]
    )
write_GetGroupWithoutMembers_result :: T.Protocol p => p -> GetGroupWithoutMembers_result -> P.IO ()
write_GetGroupWithoutMembers_result oprot record = T.writeVal oprot $ from_GetGroupWithoutMembers_result record
encode_GetGroupWithoutMembers_result :: T.StatelessProtocol p => p -> GetGroupWithoutMembers_result -> LBS.ByteString
encode_GetGroupWithoutMembers_result oprot record = T.serializeVal oprot $ from_GetGroupWithoutMembers_result record
to_GetGroupWithoutMembers_result :: T.ThriftVal -> GetGroupWithoutMembers_result
to_GetGroupWithoutMembers_result (T.TStruct fields) = GetGroupWithoutMembers_result{
  getGroupWithoutMembers_result_success = P.maybe (getGroupWithoutMembers_result_success default_GetGroupWithoutMembers_result) (\(_,_val6040) -> (case _val6040 of {T.TStruct _val6041 -> (to_Group (T.TStruct _val6041)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupWithoutMembers_result_e = P.maybe (P.Nothing) (\(_,_val6040) -> P.Just (case _val6040 of {T.TStruct _val6042 -> (to_TalkException (T.TStruct _val6042)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupWithoutMembers_result _ = P.error "not a struct"
read_GetGroupWithoutMembers_result :: T.Protocol p => p -> P.IO GetGroupWithoutMembers_result
read_GetGroupWithoutMembers_result iprot = to_GetGroupWithoutMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupWithoutMembers_result)
decode_GetGroupWithoutMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupWithoutMembers_result
decode_GetGroupWithoutMembers_result iprot bs = to_GetGroupWithoutMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupWithoutMembers_result) bs
typemap_GetGroupWithoutMembers_result :: T.TypeMap
typemap_GetGroupWithoutMembers_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupWithoutMembers_result :: GetGroupWithoutMembers_result
default_GetGroupWithoutMembers_result = GetGroupWithoutMembers_result{
  getGroupWithoutMembers_result_success = default_Group,
  getGroupWithoutMembers_result_e = P.Nothing}
data RequestResendMessage_args = RequestResendMessage_args  { requestResendMessage_args_reqSeq :: I.Int32
  , requestResendMessage_args_senderMid :: LT.Text
  , requestResendMessage_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestResendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestResendMessage_args_reqSeq record   `H.hashWithSalt` requestResendMessage_args_senderMid record   `H.hashWithSalt` requestResendMessage_args_messageId record  
instance QC.Arbitrary RequestResendMessage_args where 
  arbitrary = M.liftM RequestResendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestResendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestResendMessage_args{requestResendMessage_args_reqSeq = requestResendMessage_args_reqSeq obj} then P.Nothing else P.Just $ default_RequestResendMessage_args{requestResendMessage_args_reqSeq = requestResendMessage_args_reqSeq obj}
    , if obj == default_RequestResendMessage_args{requestResendMessage_args_senderMid = requestResendMessage_args_senderMid obj} then P.Nothing else P.Just $ default_RequestResendMessage_args{requestResendMessage_args_senderMid = requestResendMessage_args_senderMid obj}
    , if obj == default_RequestResendMessage_args{requestResendMessage_args_messageId = requestResendMessage_args_messageId obj} then P.Nothing else P.Just $ default_RequestResendMessage_args{requestResendMessage_args_messageId = requestResendMessage_args_messageId obj}
    ]
from_RequestResendMessage_args :: RequestResendMessage_args -> T.ThriftVal
from_RequestResendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6045 -> P.Just (1, ("reqSeq",T.TI32 _v6045))) $ requestResendMessage_args_reqSeq record
  , (\_v6045 -> P.Just (2, ("senderMid",T.TString $ E.encodeUtf8 _v6045))) $ requestResendMessage_args_senderMid record
  , (\_v6045 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v6045))) $ requestResendMessage_args_messageId record
  ]
write_RequestResendMessage_args :: T.Protocol p => p -> RequestResendMessage_args -> P.IO ()
write_RequestResendMessage_args oprot record = T.writeVal oprot $ from_RequestResendMessage_args record
encode_RequestResendMessage_args :: T.StatelessProtocol p => p -> RequestResendMessage_args -> LBS.ByteString
encode_RequestResendMessage_args oprot record = T.serializeVal oprot $ from_RequestResendMessage_args record
to_RequestResendMessage_args :: T.ThriftVal -> RequestResendMessage_args
to_RequestResendMessage_args (T.TStruct fields) = RequestResendMessage_args{
  requestResendMessage_args_reqSeq = P.maybe (requestResendMessage_args_reqSeq default_RequestResendMessage_args) (\(_,_val6047) -> (case _val6047 of {T.TI32 _val6048 -> _val6048; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  requestResendMessage_args_senderMid = P.maybe (requestResendMessage_args_senderMid default_RequestResendMessage_args) (\(_,_val6047) -> (case _val6047 of {T.TString _val6049 -> E.decodeUtf8 _val6049; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestResendMessage_args_messageId = P.maybe (requestResendMessage_args_messageId default_RequestResendMessage_args) (\(_,_val6047) -> (case _val6047 of {T.TString _val6050 -> E.decodeUtf8 _val6050; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RequestResendMessage_args _ = P.error "not a struct"
read_RequestResendMessage_args :: T.Protocol p => p -> P.IO RequestResendMessage_args
read_RequestResendMessage_args iprot = to_RequestResendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestResendMessage_args)
decode_RequestResendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestResendMessage_args
decode_RequestResendMessage_args iprot bs = to_RequestResendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestResendMessage_args) bs
typemap_RequestResendMessage_args :: T.TypeMap
typemap_RequestResendMessage_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("senderMid",T.T_STRING)),(3,("messageId",T.T_STRING))]
default_RequestResendMessage_args :: RequestResendMessage_args
default_RequestResendMessage_args = RequestResendMessage_args{
  requestResendMessage_args_reqSeq = 0,
  requestResendMessage_args_senderMid = "",
  requestResendMessage_args_messageId = ""}
data RequestResendMessage_result = RequestResendMessage_result  { requestResendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestResendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestResendMessage_result_e record  
instance QC.Arbitrary RequestResendMessage_result where 
  arbitrary = M.liftM RequestResendMessage_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestResendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestResendMessage_result{requestResendMessage_result_e = requestResendMessage_result_e obj} then P.Nothing else P.Just $ default_RequestResendMessage_result{requestResendMessage_result_e = requestResendMessage_result_e obj}
    ]
from_RequestResendMessage_result :: RequestResendMessage_result -> T.ThriftVal
from_RequestResendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6053 -> (1, ("e",from_TalkException _v6053))) <$> requestResendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6053 -> (1, ("e",from_TalkException _v6053))) <$> requestResendMessage_result_e record
    ]
    )
write_RequestResendMessage_result :: T.Protocol p => p -> RequestResendMessage_result -> P.IO ()
write_RequestResendMessage_result oprot record = T.writeVal oprot $ from_RequestResendMessage_result record
encode_RequestResendMessage_result :: T.StatelessProtocol p => p -> RequestResendMessage_result -> LBS.ByteString
encode_RequestResendMessage_result oprot record = T.serializeVal oprot $ from_RequestResendMessage_result record
to_RequestResendMessage_result :: T.ThriftVal -> RequestResendMessage_result
to_RequestResendMessage_result (T.TStruct fields) = RequestResendMessage_result{
  requestResendMessage_result_e = P.maybe (P.Nothing) (\(_,_val6055) -> P.Just (case _val6055 of {T.TStruct _val6056 -> (to_TalkException (T.TStruct _val6056)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestResendMessage_result _ = P.error "not a struct"
read_RequestResendMessage_result :: T.Protocol p => p -> P.IO RequestResendMessage_result
read_RequestResendMessage_result iprot = to_RequestResendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestResendMessage_result)
decode_RequestResendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestResendMessage_result
decode_RequestResendMessage_result iprot bs = to_RequestResendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestResendMessage_result) bs
typemap_RequestResendMessage_result :: T.TypeMap
typemap_RequestResendMessage_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestResendMessage_result :: RequestResendMessage_result
default_RequestResendMessage_result = RequestResendMessage_result{
  requestResendMessage_result_e = P.Nothing}
data RespondResendMessage_args = RespondResendMessage_args  { respondResendMessage_args_reqSeq :: I.Int32
  , respondResendMessage_args_receiverMid :: LT.Text
  , respondResendMessage_args_originalMessageId :: LT.Text
  , respondResendMessage_args_resendMessage :: Message
  , respondResendMessage_args_errorCode :: ErrorCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondResendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondResendMessage_args_reqSeq record   `H.hashWithSalt` respondResendMessage_args_receiverMid record   `H.hashWithSalt` respondResendMessage_args_originalMessageId record   `H.hashWithSalt` respondResendMessage_args_resendMessage record   `H.hashWithSalt` respondResendMessage_args_errorCode record  
instance QC.Arbitrary RespondResendMessage_args where 
  arbitrary = M.liftM RespondResendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RespondResendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondResendMessage_args{respondResendMessage_args_reqSeq = respondResendMessage_args_reqSeq obj} then P.Nothing else P.Just $ default_RespondResendMessage_args{respondResendMessage_args_reqSeq = respondResendMessage_args_reqSeq obj}
    , if obj == default_RespondResendMessage_args{respondResendMessage_args_receiverMid = respondResendMessage_args_receiverMid obj} then P.Nothing else P.Just $ default_RespondResendMessage_args{respondResendMessage_args_receiverMid = respondResendMessage_args_receiverMid obj}
    , if obj == default_RespondResendMessage_args{respondResendMessage_args_originalMessageId = respondResendMessage_args_originalMessageId obj} then P.Nothing else P.Just $ default_RespondResendMessage_args{respondResendMessage_args_originalMessageId = respondResendMessage_args_originalMessageId obj}
    , if obj == default_RespondResendMessage_args{respondResendMessage_args_resendMessage = respondResendMessage_args_resendMessage obj} then P.Nothing else P.Just $ default_RespondResendMessage_args{respondResendMessage_args_resendMessage = respondResendMessage_args_resendMessage obj}
    , if obj == default_RespondResendMessage_args{respondResendMessage_args_errorCode = respondResendMessage_args_errorCode obj} then P.Nothing else P.Just $ default_RespondResendMessage_args{respondResendMessage_args_errorCode = respondResendMessage_args_errorCode obj}
    ]
from_RespondResendMessage_args :: RespondResendMessage_args -> T.ThriftVal
from_RespondResendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6059 -> P.Just (1, ("reqSeq",T.TI32 _v6059))) $ respondResendMessage_args_reqSeq record
  , (\_v6059 -> P.Just (2, ("receiverMid",T.TString $ E.encodeUtf8 _v6059))) $ respondResendMessage_args_receiverMid record
  , (\_v6059 -> P.Just (3, ("originalMessageId",T.TString $ E.encodeUtf8 _v6059))) $ respondResendMessage_args_originalMessageId record
  , (\_v6059 -> P.Just (4, ("resendMessage",from_Message _v6059))) $ respondResendMessage_args_resendMessage record
  , (\_v6059 -> P.Just (5, ("errorCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v6059))) $ respondResendMessage_args_errorCode record
  ]
write_RespondResendMessage_args :: T.Protocol p => p -> RespondResendMessage_args -> P.IO ()
write_RespondResendMessage_args oprot record = T.writeVal oprot $ from_RespondResendMessage_args record
encode_RespondResendMessage_args :: T.StatelessProtocol p => p -> RespondResendMessage_args -> LBS.ByteString
encode_RespondResendMessage_args oprot record = T.serializeVal oprot $ from_RespondResendMessage_args record
to_RespondResendMessage_args :: T.ThriftVal -> RespondResendMessage_args
to_RespondResendMessage_args (T.TStruct fields) = RespondResendMessage_args{
  respondResendMessage_args_reqSeq = P.maybe (respondResendMessage_args_reqSeq default_RespondResendMessage_args) (\(_,_val6061) -> (case _val6061 of {T.TI32 _val6062 -> _val6062; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  respondResendMessage_args_receiverMid = P.maybe (respondResendMessage_args_receiverMid default_RespondResendMessage_args) (\(_,_val6061) -> (case _val6061 of {T.TString _val6063 -> E.decodeUtf8 _val6063; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  respondResendMessage_args_originalMessageId = P.maybe (respondResendMessage_args_originalMessageId default_RespondResendMessage_args) (\(_,_val6061) -> (case _val6061 of {T.TString _val6064 -> E.decodeUtf8 _val6064; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  respondResendMessage_args_resendMessage = P.maybe (respondResendMessage_args_resendMessage default_RespondResendMessage_args) (\(_,_val6061) -> (case _val6061 of {T.TStruct _val6065 -> (to_Message (T.TStruct _val6065)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  respondResendMessage_args_errorCode = P.maybe (respondResendMessage_args_errorCode default_RespondResendMessage_args) (\(_,_val6061) -> (case _val6061 of {T.TI32 _val6066 -> P.toEnum $ P.fromIntegral _val6066; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RespondResendMessage_args _ = P.error "not a struct"
read_RespondResendMessage_args :: T.Protocol p => p -> P.IO RespondResendMessage_args
read_RespondResendMessage_args iprot = to_RespondResendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_RespondResendMessage_args)
decode_RespondResendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondResendMessage_args
decode_RespondResendMessage_args iprot bs = to_RespondResendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondResendMessage_args) bs
typemap_RespondResendMessage_args :: T.TypeMap
typemap_RespondResendMessage_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("receiverMid",T.T_STRING)),(3,("originalMessageId",T.T_STRING)),(4,("resendMessage",(T.T_STRUCT typemap_Message))),(5,("errorCode",T.T_I32))]
default_RespondResendMessage_args :: RespondResendMessage_args
default_RespondResendMessage_args = RespondResendMessage_args{
  respondResendMessage_args_reqSeq = 0,
  respondResendMessage_args_receiverMid = "",
  respondResendMessage_args_originalMessageId = "",
  respondResendMessage_args_resendMessage = default_Message,
  respondResendMessage_args_errorCode = (P.toEnum 0)}
data RespondResendMessage_result = RespondResendMessage_result  { respondResendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RespondResendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` respondResendMessage_result_e record  
instance QC.Arbitrary RespondResendMessage_result where 
  arbitrary = M.liftM RespondResendMessage_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RespondResendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RespondResendMessage_result{respondResendMessage_result_e = respondResendMessage_result_e obj} then P.Nothing else P.Just $ default_RespondResendMessage_result{respondResendMessage_result_e = respondResendMessage_result_e obj}
    ]
from_RespondResendMessage_result :: RespondResendMessage_result -> T.ThriftVal
from_RespondResendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6069 -> (1, ("e",from_TalkException _v6069))) <$> respondResendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6069 -> (1, ("e",from_TalkException _v6069))) <$> respondResendMessage_result_e record
    ]
    )
write_RespondResendMessage_result :: T.Protocol p => p -> RespondResendMessage_result -> P.IO ()
write_RespondResendMessage_result oprot record = T.writeVal oprot $ from_RespondResendMessage_result record
encode_RespondResendMessage_result :: T.StatelessProtocol p => p -> RespondResendMessage_result -> LBS.ByteString
encode_RespondResendMessage_result oprot record = T.serializeVal oprot $ from_RespondResendMessage_result record
to_RespondResendMessage_result :: T.ThriftVal -> RespondResendMessage_result
to_RespondResendMessage_result (T.TStruct fields) = RespondResendMessage_result{
  respondResendMessage_result_e = P.maybe (P.Nothing) (\(_,_val6071) -> P.Just (case _val6071 of {T.TStruct _val6072 -> (to_TalkException (T.TStruct _val6072)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RespondResendMessage_result _ = P.error "not a struct"
read_RespondResendMessage_result :: T.Protocol p => p -> P.IO RespondResendMessage_result
read_RespondResendMessage_result iprot = to_RespondResendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_RespondResendMessage_result)
decode_RespondResendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RespondResendMessage_result
decode_RespondResendMessage_result iprot bs = to_RespondResendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RespondResendMessage_result) bs
typemap_RespondResendMessage_result :: T.TypeMap
typemap_RespondResendMessage_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RespondResendMessage_result :: RespondResendMessage_result
default_RespondResendMessage_result = RespondResendMessage_result{
  respondResendMessage_result_e = P.Nothing}
data AcceptGroupInvitation_args = AcceptGroupInvitation_args  { acceptGroupInvitation_args_reqSeq :: I.Int32
  , acceptGroupInvitation_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitation_args_reqSeq record   `H.hashWithSalt` acceptGroupInvitation_args_groupId record  
instance QC.Arbitrary AcceptGroupInvitation_args where 
  arbitrary = M.liftM AcceptGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitation_args{acceptGroupInvitation_args_reqSeq = acceptGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_args{acceptGroupInvitation_args_reqSeq = acceptGroupInvitation_args_reqSeq obj}
    , if obj == default_AcceptGroupInvitation_args{acceptGroupInvitation_args_groupId = acceptGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_args{acceptGroupInvitation_args_groupId = acceptGroupInvitation_args_groupId obj}
    ]
from_AcceptGroupInvitation_args :: AcceptGroupInvitation_args -> T.ThriftVal
from_AcceptGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6075 -> P.Just (1, ("reqSeq",T.TI32 _v6075))) $ acceptGroupInvitation_args_reqSeq record
  , (\_v6075 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v6075))) $ acceptGroupInvitation_args_groupId record
  ]
write_AcceptGroupInvitation_args :: T.Protocol p => p -> AcceptGroupInvitation_args -> P.IO ()
write_AcceptGroupInvitation_args oprot record = T.writeVal oprot $ from_AcceptGroupInvitation_args record
encode_AcceptGroupInvitation_args :: T.StatelessProtocol p => p -> AcceptGroupInvitation_args -> LBS.ByteString
encode_AcceptGroupInvitation_args oprot record = T.serializeVal oprot $ from_AcceptGroupInvitation_args record
to_AcceptGroupInvitation_args :: T.ThriftVal -> AcceptGroupInvitation_args
to_AcceptGroupInvitation_args (T.TStruct fields) = AcceptGroupInvitation_args{
  acceptGroupInvitation_args_reqSeq = P.maybe (acceptGroupInvitation_args_reqSeq default_AcceptGroupInvitation_args) (\(_,_val6077) -> (case _val6077 of {T.TI32 _val6078 -> _val6078; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  acceptGroupInvitation_args_groupId = P.maybe (acceptGroupInvitation_args_groupId default_AcceptGroupInvitation_args) (\(_,_val6077) -> (case _val6077 of {T.TString _val6079 -> E.decodeUtf8 _val6079; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcceptGroupInvitation_args _ = P.error "not a struct"
read_AcceptGroupInvitation_args :: T.Protocol p => p -> P.IO AcceptGroupInvitation_args
read_AcceptGroupInvitation_args iprot = to_AcceptGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_args)
decode_AcceptGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitation_args
decode_AcceptGroupInvitation_args iprot bs = to_AcceptGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_args) bs
typemap_AcceptGroupInvitation_args :: T.TypeMap
typemap_AcceptGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_AcceptGroupInvitation_args :: AcceptGroupInvitation_args
default_AcceptGroupInvitation_args = AcceptGroupInvitation_args{
  acceptGroupInvitation_args_reqSeq = 0,
  acceptGroupInvitation_args_groupId = ""}
data AcceptGroupInvitation_result = AcceptGroupInvitation_result  { acceptGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitation_result_e record  
instance QC.Arbitrary AcceptGroupInvitation_result where 
  arbitrary = M.liftM AcceptGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = acceptGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = acceptGroupInvitation_result_e obj}
    ]
from_AcceptGroupInvitation_result :: AcceptGroupInvitation_result -> T.ThriftVal
from_AcceptGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6082 -> (1, ("e",from_TalkException _v6082))) <$> acceptGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6082 -> (1, ("e",from_TalkException _v6082))) <$> acceptGroupInvitation_result_e record
    ]
    )
write_AcceptGroupInvitation_result :: T.Protocol p => p -> AcceptGroupInvitation_result -> P.IO ()
write_AcceptGroupInvitation_result oprot record = T.writeVal oprot $ from_AcceptGroupInvitation_result record
encode_AcceptGroupInvitation_result :: T.StatelessProtocol p => p -> AcceptGroupInvitation_result -> LBS.ByteString
encode_AcceptGroupInvitation_result oprot record = T.serializeVal oprot $ from_AcceptGroupInvitation_result record
to_AcceptGroupInvitation_result :: T.ThriftVal -> AcceptGroupInvitation_result
to_AcceptGroupInvitation_result (T.TStruct fields) = AcceptGroupInvitation_result{
  acceptGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val6084) -> P.Just (case _val6084 of {T.TStruct _val6085 -> (to_TalkException (T.TStruct _val6085)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcceptGroupInvitation_result _ = P.error "not a struct"
read_AcceptGroupInvitation_result :: T.Protocol p => p -> P.IO AcceptGroupInvitation_result
read_AcceptGroupInvitation_result iprot = to_AcceptGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_result)
decode_AcceptGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitation_result
decode_AcceptGroupInvitation_result iprot bs = to_AcceptGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitation_result) bs
typemap_AcceptGroupInvitation_result :: T.TypeMap
typemap_AcceptGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcceptGroupInvitation_result :: AcceptGroupInvitation_result
default_AcceptGroupInvitation_result = AcceptGroupInvitation_result{
  acceptGroupInvitation_result_e = P.Nothing}
data AcceptGroupInvitationByTicket_args = AcceptGroupInvitationByTicket_args  { acceptGroupInvitationByTicket_args_reqSeq :: I.Int32
  , acceptGroupInvitationByTicket_args_GroupMid :: LT.Text
  , acceptGroupInvitationByTicket_args_ticketId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitationByTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitationByTicket_args_reqSeq record   `H.hashWithSalt` acceptGroupInvitationByTicket_args_GroupMid record   `H.hashWithSalt` acceptGroupInvitationByTicket_args_ticketId record  
instance QC.Arbitrary AcceptGroupInvitationByTicket_args where 
  arbitrary = M.liftM AcceptGroupInvitationByTicket_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitationByTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_reqSeq = acceptGroupInvitationByTicket_args_reqSeq obj} then P.Nothing else P.Just $ default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_reqSeq = acceptGroupInvitationByTicket_args_reqSeq obj}
    , if obj == default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_GroupMid = acceptGroupInvitationByTicket_args_GroupMid obj} then P.Nothing else P.Just $ default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_GroupMid = acceptGroupInvitationByTicket_args_GroupMid obj}
    , if obj == default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_ticketId = acceptGroupInvitationByTicket_args_ticketId obj} then P.Nothing else P.Just $ default_AcceptGroupInvitationByTicket_args{acceptGroupInvitationByTicket_args_ticketId = acceptGroupInvitationByTicket_args_ticketId obj}
    ]
from_AcceptGroupInvitationByTicket_args :: AcceptGroupInvitationByTicket_args -> T.ThriftVal
from_AcceptGroupInvitationByTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6088 -> P.Just (1, ("reqSeq",T.TI32 _v6088))) $ acceptGroupInvitationByTicket_args_reqSeq record
  , (\_v6088 -> P.Just (2, ("GroupMid",T.TString $ E.encodeUtf8 _v6088))) $ acceptGroupInvitationByTicket_args_GroupMid record
  , (\_v6088 -> P.Just (3, ("ticketId",T.TString $ E.encodeUtf8 _v6088))) $ acceptGroupInvitationByTicket_args_ticketId record
  ]
write_AcceptGroupInvitationByTicket_args :: T.Protocol p => p -> AcceptGroupInvitationByTicket_args -> P.IO ()
write_AcceptGroupInvitationByTicket_args oprot record = T.writeVal oprot $ from_AcceptGroupInvitationByTicket_args record
encode_AcceptGroupInvitationByTicket_args :: T.StatelessProtocol p => p -> AcceptGroupInvitationByTicket_args -> LBS.ByteString
encode_AcceptGroupInvitationByTicket_args oprot record = T.serializeVal oprot $ from_AcceptGroupInvitationByTicket_args record
to_AcceptGroupInvitationByTicket_args :: T.ThriftVal -> AcceptGroupInvitationByTicket_args
to_AcceptGroupInvitationByTicket_args (T.TStruct fields) = AcceptGroupInvitationByTicket_args{
  acceptGroupInvitationByTicket_args_reqSeq = P.maybe (acceptGroupInvitationByTicket_args_reqSeq default_AcceptGroupInvitationByTicket_args) (\(_,_val6090) -> (case _val6090 of {T.TI32 _val6091 -> _val6091; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  acceptGroupInvitationByTicket_args_GroupMid = P.maybe (acceptGroupInvitationByTicket_args_GroupMid default_AcceptGroupInvitationByTicket_args) (\(_,_val6090) -> (case _val6090 of {T.TString _val6092 -> E.decodeUtf8 _val6092; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acceptGroupInvitationByTicket_args_ticketId = P.maybe (acceptGroupInvitationByTicket_args_ticketId default_AcceptGroupInvitationByTicket_args) (\(_,_val6090) -> (case _val6090 of {T.TString _val6093 -> E.decodeUtf8 _val6093; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AcceptGroupInvitationByTicket_args _ = P.error "not a struct"
read_AcceptGroupInvitationByTicket_args :: T.Protocol p => p -> P.IO AcceptGroupInvitationByTicket_args
read_AcceptGroupInvitationByTicket_args iprot = to_AcceptGroupInvitationByTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitationByTicket_args)
decode_AcceptGroupInvitationByTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitationByTicket_args
decode_AcceptGroupInvitationByTicket_args iprot bs = to_AcceptGroupInvitationByTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitationByTicket_args) bs
typemap_AcceptGroupInvitationByTicket_args :: T.TypeMap
typemap_AcceptGroupInvitationByTicket_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("GroupMid",T.T_STRING)),(3,("ticketId",T.T_STRING))]
default_AcceptGroupInvitationByTicket_args :: AcceptGroupInvitationByTicket_args
default_AcceptGroupInvitationByTicket_args = AcceptGroupInvitationByTicket_args{
  acceptGroupInvitationByTicket_args_reqSeq = 0,
  acceptGroupInvitationByTicket_args_GroupMid = "",
  acceptGroupInvitationByTicket_args_ticketId = ""}
data AcceptGroupInvitationByTicket_result = AcceptGroupInvitationByTicket_result  { acceptGroupInvitationByTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptGroupInvitationByTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptGroupInvitationByTicket_result_e record  
instance QC.Arbitrary AcceptGroupInvitationByTicket_result where 
  arbitrary = M.liftM AcceptGroupInvitationByTicket_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcceptGroupInvitationByTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptGroupInvitationByTicket_result{acceptGroupInvitationByTicket_result_e = acceptGroupInvitationByTicket_result_e obj} then P.Nothing else P.Just $ default_AcceptGroupInvitationByTicket_result{acceptGroupInvitationByTicket_result_e = acceptGroupInvitationByTicket_result_e obj}
    ]
from_AcceptGroupInvitationByTicket_result :: AcceptGroupInvitationByTicket_result -> T.ThriftVal
from_AcceptGroupInvitationByTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6096 -> (1, ("e",from_TalkException _v6096))) <$> acceptGroupInvitationByTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6096 -> (1, ("e",from_TalkException _v6096))) <$> acceptGroupInvitationByTicket_result_e record
    ]
    )
write_AcceptGroupInvitationByTicket_result :: T.Protocol p => p -> AcceptGroupInvitationByTicket_result -> P.IO ()
write_AcceptGroupInvitationByTicket_result oprot record = T.writeVal oprot $ from_AcceptGroupInvitationByTicket_result record
encode_AcceptGroupInvitationByTicket_result :: T.StatelessProtocol p => p -> AcceptGroupInvitationByTicket_result -> LBS.ByteString
encode_AcceptGroupInvitationByTicket_result oprot record = T.serializeVal oprot $ from_AcceptGroupInvitationByTicket_result record
to_AcceptGroupInvitationByTicket_result :: T.ThriftVal -> AcceptGroupInvitationByTicket_result
to_AcceptGroupInvitationByTicket_result (T.TStruct fields) = AcceptGroupInvitationByTicket_result{
  acceptGroupInvitationByTicket_result_e = P.maybe (P.Nothing) (\(_,_val6098) -> P.Just (case _val6098 of {T.TStruct _val6099 -> (to_TalkException (T.TStruct _val6099)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcceptGroupInvitationByTicket_result _ = P.error "not a struct"
read_AcceptGroupInvitationByTicket_result :: T.Protocol p => p -> P.IO AcceptGroupInvitationByTicket_result
read_AcceptGroupInvitationByTicket_result iprot = to_AcceptGroupInvitationByTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_AcceptGroupInvitationByTicket_result)
decode_AcceptGroupInvitationByTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptGroupInvitationByTicket_result
decode_AcceptGroupInvitationByTicket_result iprot bs = to_AcceptGroupInvitationByTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptGroupInvitationByTicket_result) bs
typemap_AcceptGroupInvitationByTicket_result :: T.TypeMap
typemap_AcceptGroupInvitationByTicket_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcceptGroupInvitationByTicket_result :: AcceptGroupInvitationByTicket_result
default_AcceptGroupInvitationByTicket_result = AcceptGroupInvitationByTicket_result{
  acceptGroupInvitationByTicket_result_e = P.Nothing}
data AcceptProximityMatches_args = AcceptProximityMatches_args  { acceptProximityMatches_args_sessionId :: LT.Text
  , acceptProximityMatches_args_ids :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptProximityMatches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptProximityMatches_args_sessionId record   `H.hashWithSalt` acceptProximityMatches_args_ids record  
instance QC.Arbitrary AcceptProximityMatches_args where 
  arbitrary = M.liftM AcceptProximityMatches_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcceptProximityMatches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptProximityMatches_args{acceptProximityMatches_args_sessionId = acceptProximityMatches_args_sessionId obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_args{acceptProximityMatches_args_sessionId = acceptProximityMatches_args_sessionId obj}
    , if obj == default_AcceptProximityMatches_args{acceptProximityMatches_args_ids = acceptProximityMatches_args_ids obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_args{acceptProximityMatches_args_ids = acceptProximityMatches_args_ids obj}
    ]
from_AcceptProximityMatches_args :: AcceptProximityMatches_args -> T.ThriftVal
from_AcceptProximityMatches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6102 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6102))) $ acceptProximityMatches_args_sessionId record
  , (\_v6102 -> P.Just (3, ("ids",T.TSet T.T_STRING $ P.map (\_v6104 -> T.TString $ E.encodeUtf8 _v6104) $ Set.toList _v6102))) $ acceptProximityMatches_args_ids record
  ]
write_AcceptProximityMatches_args :: T.Protocol p => p -> AcceptProximityMatches_args -> P.IO ()
write_AcceptProximityMatches_args oprot record = T.writeVal oprot $ from_AcceptProximityMatches_args record
encode_AcceptProximityMatches_args :: T.StatelessProtocol p => p -> AcceptProximityMatches_args -> LBS.ByteString
encode_AcceptProximityMatches_args oprot record = T.serializeVal oprot $ from_AcceptProximityMatches_args record
to_AcceptProximityMatches_args :: T.ThriftVal -> AcceptProximityMatches_args
to_AcceptProximityMatches_args (T.TStruct fields) = AcceptProximityMatches_args{
  acceptProximityMatches_args_sessionId = P.maybe (acceptProximityMatches_args_sessionId default_AcceptProximityMatches_args) (\(_,_val6106) -> (case _val6106 of {T.TString _val6107 -> E.decodeUtf8 _val6107; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acceptProximityMatches_args_ids = P.maybe (acceptProximityMatches_args_ids default_AcceptProximityMatches_args) (\(_,_val6106) -> (case _val6106 of {T.TSet _ _val6108 -> (Set.fromList $ P.map (\_v6109 -> (case _v6109 of {T.TString _val6110 -> E.decodeUtf8 _val6110; _ -> P.error "wrong type"})) _val6108); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AcceptProximityMatches_args _ = P.error "not a struct"
read_AcceptProximityMatches_args :: T.Protocol p => p -> P.IO AcceptProximityMatches_args
read_AcceptProximityMatches_args iprot = to_AcceptProximityMatches_args <$> T.readVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_args)
decode_AcceptProximityMatches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptProximityMatches_args
decode_AcceptProximityMatches_args iprot bs = to_AcceptProximityMatches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_args) bs
typemap_AcceptProximityMatches_args :: T.TypeMap
typemap_AcceptProximityMatches_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("ids",(T.T_SET T.T_STRING)))]
default_AcceptProximityMatches_args :: AcceptProximityMatches_args
default_AcceptProximityMatches_args = AcceptProximityMatches_args{
  acceptProximityMatches_args_sessionId = "",
  acceptProximityMatches_args_ids = Set.empty}
data AcceptProximityMatches_result = AcceptProximityMatches_result  { acceptProximityMatches_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcceptProximityMatches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acceptProximityMatches_result_e record  
instance QC.Arbitrary AcceptProximityMatches_result where 
  arbitrary = M.liftM AcceptProximityMatches_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcceptProximityMatches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcceptProximityMatches_result{acceptProximityMatches_result_e = acceptProximityMatches_result_e obj} then P.Nothing else P.Just $ default_AcceptProximityMatches_result{acceptProximityMatches_result_e = acceptProximityMatches_result_e obj}
    ]
from_AcceptProximityMatches_result :: AcceptProximityMatches_result -> T.ThriftVal
from_AcceptProximityMatches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6113 -> (1, ("e",from_TalkException _v6113))) <$> acceptProximityMatches_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6113 -> (1, ("e",from_TalkException _v6113))) <$> acceptProximityMatches_result_e record
    ]
    )
write_AcceptProximityMatches_result :: T.Protocol p => p -> AcceptProximityMatches_result -> P.IO ()
write_AcceptProximityMatches_result oprot record = T.writeVal oprot $ from_AcceptProximityMatches_result record
encode_AcceptProximityMatches_result :: T.StatelessProtocol p => p -> AcceptProximityMatches_result -> LBS.ByteString
encode_AcceptProximityMatches_result oprot record = T.serializeVal oprot $ from_AcceptProximityMatches_result record
to_AcceptProximityMatches_result :: T.ThriftVal -> AcceptProximityMatches_result
to_AcceptProximityMatches_result (T.TStruct fields) = AcceptProximityMatches_result{
  acceptProximityMatches_result_e = P.maybe (P.Nothing) (\(_,_val6115) -> P.Just (case _val6115 of {T.TStruct _val6116 -> (to_TalkException (T.TStruct _val6116)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcceptProximityMatches_result _ = P.error "not a struct"
read_AcceptProximityMatches_result :: T.Protocol p => p -> P.IO AcceptProximityMatches_result
read_AcceptProximityMatches_result iprot = to_AcceptProximityMatches_result <$> T.readVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_result)
decode_AcceptProximityMatches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcceptProximityMatches_result
decode_AcceptProximityMatches_result iprot bs = to_AcceptProximityMatches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcceptProximityMatches_result) bs
typemap_AcceptProximityMatches_result :: T.TypeMap
typemap_AcceptProximityMatches_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcceptProximityMatches_result :: AcceptProximityMatches_result
default_AcceptProximityMatches_result = AcceptProximityMatches_result{
  acceptProximityMatches_result_e = P.Nothing}
data AcquireCallRoute_args = AcquireCallRoute_args  { acquireCallRoute_args_to :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallRoute_args_to record  
instance QC.Arbitrary AcquireCallRoute_args where 
  arbitrary = M.liftM AcquireCallRoute_args (QC.arbitrary)
  shrink obj | obj == default_AcquireCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallRoute_args{acquireCallRoute_args_to = acquireCallRoute_args_to obj} then P.Nothing else P.Just $ default_AcquireCallRoute_args{acquireCallRoute_args_to = acquireCallRoute_args_to obj}
    ]
from_AcquireCallRoute_args :: AcquireCallRoute_args -> T.ThriftVal
from_AcquireCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6119 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v6119))) $ acquireCallRoute_args_to record
  ]
write_AcquireCallRoute_args :: T.Protocol p => p -> AcquireCallRoute_args -> P.IO ()
write_AcquireCallRoute_args oprot record = T.writeVal oprot $ from_AcquireCallRoute_args record
encode_AcquireCallRoute_args :: T.StatelessProtocol p => p -> AcquireCallRoute_args -> LBS.ByteString
encode_AcquireCallRoute_args oprot record = T.serializeVal oprot $ from_AcquireCallRoute_args record
to_AcquireCallRoute_args :: T.ThriftVal -> AcquireCallRoute_args
to_AcquireCallRoute_args (T.TStruct fields) = AcquireCallRoute_args{
  acquireCallRoute_args_to = P.maybe (acquireCallRoute_args_to default_AcquireCallRoute_args) (\(_,_val6121) -> (case _val6121 of {T.TString _val6122 -> E.decodeUtf8 _val6122; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireCallRoute_args _ = P.error "not a struct"
read_AcquireCallRoute_args :: T.Protocol p => p -> P.IO AcquireCallRoute_args
read_AcquireCallRoute_args iprot = to_AcquireCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallRoute_args)
decode_AcquireCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallRoute_args
decode_AcquireCallRoute_args iprot bs = to_AcquireCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallRoute_args) bs
typemap_AcquireCallRoute_args :: T.TypeMap
typemap_AcquireCallRoute_args = Map.fromList [(2,("to",T.T_STRING))]
default_AcquireCallRoute_args :: AcquireCallRoute_args
default_AcquireCallRoute_args = AcquireCallRoute_args{
  acquireCallRoute_args_to = ""}
data AcquireCallRoute_result = AcquireCallRoute_result  { acquireCallRoute_result_success :: (Vector.Vector LT.Text)
  , acquireCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallRoute_result_success record   `H.hashWithSalt` acquireCallRoute_result_e record  
instance QC.Arbitrary AcquireCallRoute_result where 
  arbitrary = M.liftM AcquireCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallRoute_result{acquireCallRoute_result_success = acquireCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquireCallRoute_result{acquireCallRoute_result_success = acquireCallRoute_result_success obj}
    , if obj == default_AcquireCallRoute_result{acquireCallRoute_result_e = acquireCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquireCallRoute_result{acquireCallRoute_result_e = acquireCallRoute_result_e obj}
    ]
from_AcquireCallRoute_result :: AcquireCallRoute_result -> T.ThriftVal
from_AcquireCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6125 -> (1, ("e",from_TalkException _v6125))) <$> acquireCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6125 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6127 -> T.TString $ E.encodeUtf8 _v6127) $ Vector.toList _v6125))) $ acquireCallRoute_result_success record
    , (\_v6125 -> (1, ("e",from_TalkException _v6125))) <$> acquireCallRoute_result_e record
    ]
    )
write_AcquireCallRoute_result :: T.Protocol p => p -> AcquireCallRoute_result -> P.IO ()
write_AcquireCallRoute_result oprot record = T.writeVal oprot $ from_AcquireCallRoute_result record
encode_AcquireCallRoute_result :: T.StatelessProtocol p => p -> AcquireCallRoute_result -> LBS.ByteString
encode_AcquireCallRoute_result oprot record = T.serializeVal oprot $ from_AcquireCallRoute_result record
to_AcquireCallRoute_result :: T.ThriftVal -> AcquireCallRoute_result
to_AcquireCallRoute_result (T.TStruct fields) = AcquireCallRoute_result{
  acquireCallRoute_result_success = P.maybe (acquireCallRoute_result_success default_AcquireCallRoute_result) (\(_,_val6129) -> (case _val6129 of {T.TList _ _val6130 -> (Vector.fromList $ P.map (\_v6131 -> (case _v6131 of {T.TString _val6132 -> E.decodeUtf8 _val6132; _ -> P.error "wrong type"})) _val6130); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val6129) -> P.Just (case _val6129 of {T.TStruct _val6133 -> (to_TalkException (T.TStruct _val6133)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireCallRoute_result _ = P.error "not a struct"
read_AcquireCallRoute_result :: T.Protocol p => p -> P.IO AcquireCallRoute_result
read_AcquireCallRoute_result iprot = to_AcquireCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallRoute_result)
decode_AcquireCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallRoute_result
decode_AcquireCallRoute_result iprot bs = to_AcquireCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallRoute_result) bs
typemap_AcquireCallRoute_result :: T.TypeMap
typemap_AcquireCallRoute_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireCallRoute_result :: AcquireCallRoute_result
default_AcquireCallRoute_result = AcquireCallRoute_result{
  acquireCallRoute_result_success = Vector.empty,
  acquireCallRoute_result_e = P.Nothing}
data AcquireCallTicket_args = AcquireCallTicket_args  { acquireCallTicket_args_to :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallTicket_args_to record  
instance QC.Arbitrary AcquireCallTicket_args where 
  arbitrary = M.liftM AcquireCallTicket_args (QC.arbitrary)
  shrink obj | obj == default_AcquireCallTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallTicket_args{acquireCallTicket_args_to = acquireCallTicket_args_to obj} then P.Nothing else P.Just $ default_AcquireCallTicket_args{acquireCallTicket_args_to = acquireCallTicket_args_to obj}
    ]
from_AcquireCallTicket_args :: AcquireCallTicket_args -> T.ThriftVal
from_AcquireCallTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6136 -> P.Just (2, ("to",T.TString $ E.encodeUtf8 _v6136))) $ acquireCallTicket_args_to record
  ]
write_AcquireCallTicket_args :: T.Protocol p => p -> AcquireCallTicket_args -> P.IO ()
write_AcquireCallTicket_args oprot record = T.writeVal oprot $ from_AcquireCallTicket_args record
encode_AcquireCallTicket_args :: T.StatelessProtocol p => p -> AcquireCallTicket_args -> LBS.ByteString
encode_AcquireCallTicket_args oprot record = T.serializeVal oprot $ from_AcquireCallTicket_args record
to_AcquireCallTicket_args :: T.ThriftVal -> AcquireCallTicket_args
to_AcquireCallTicket_args (T.TStruct fields) = AcquireCallTicket_args{
  acquireCallTicket_args_to = P.maybe (acquireCallTicket_args_to default_AcquireCallTicket_args) (\(_,_val6138) -> (case _val6138 of {T.TString _val6139 -> E.decodeUtf8 _val6139; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireCallTicket_args _ = P.error "not a struct"
read_AcquireCallTicket_args :: T.Protocol p => p -> P.IO AcquireCallTicket_args
read_AcquireCallTicket_args iprot = to_AcquireCallTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallTicket_args)
decode_AcquireCallTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallTicket_args
decode_AcquireCallTicket_args iprot bs = to_AcquireCallTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallTicket_args) bs
typemap_AcquireCallTicket_args :: T.TypeMap
typemap_AcquireCallTicket_args = Map.fromList [(2,("to",T.T_STRING))]
default_AcquireCallTicket_args :: AcquireCallTicket_args
default_AcquireCallTicket_args = AcquireCallTicket_args{
  acquireCallTicket_args_to = ""}
data AcquireCallTicket_result = AcquireCallTicket_result  { acquireCallTicket_result_success :: LT.Text
  , acquireCallTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireCallTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireCallTicket_result_success record   `H.hashWithSalt` acquireCallTicket_result_e record  
instance QC.Arbitrary AcquireCallTicket_result where 
  arbitrary = M.liftM AcquireCallTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireCallTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireCallTicket_result{acquireCallTicket_result_success = acquireCallTicket_result_success obj} then P.Nothing else P.Just $ default_AcquireCallTicket_result{acquireCallTicket_result_success = acquireCallTicket_result_success obj}
    , if obj == default_AcquireCallTicket_result{acquireCallTicket_result_e = acquireCallTicket_result_e obj} then P.Nothing else P.Just $ default_AcquireCallTicket_result{acquireCallTicket_result_e = acquireCallTicket_result_e obj}
    ]
from_AcquireCallTicket_result :: AcquireCallTicket_result -> T.ThriftVal
from_AcquireCallTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6142 -> (1, ("e",from_TalkException _v6142))) <$> acquireCallTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6142 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6142))) $ acquireCallTicket_result_success record
    , (\_v6142 -> (1, ("e",from_TalkException _v6142))) <$> acquireCallTicket_result_e record
    ]
    )
write_AcquireCallTicket_result :: T.Protocol p => p -> AcquireCallTicket_result -> P.IO ()
write_AcquireCallTicket_result oprot record = T.writeVal oprot $ from_AcquireCallTicket_result record
encode_AcquireCallTicket_result :: T.StatelessProtocol p => p -> AcquireCallTicket_result -> LBS.ByteString
encode_AcquireCallTicket_result oprot record = T.serializeVal oprot $ from_AcquireCallTicket_result record
to_AcquireCallTicket_result :: T.ThriftVal -> AcquireCallTicket_result
to_AcquireCallTicket_result (T.TStruct fields) = AcquireCallTicket_result{
  acquireCallTicket_result_success = P.maybe (acquireCallTicket_result_success default_AcquireCallTicket_result) (\(_,_val6144) -> (case _val6144 of {T.TString _val6145 -> E.decodeUtf8 _val6145; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireCallTicket_result_e = P.maybe (P.Nothing) (\(_,_val6144) -> P.Just (case _val6144 of {T.TStruct _val6146 -> (to_TalkException (T.TStruct _val6146)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireCallTicket_result _ = P.error "not a struct"
read_AcquireCallTicket_result :: T.Protocol p => p -> P.IO AcquireCallTicket_result
read_AcquireCallTicket_result iprot = to_AcquireCallTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireCallTicket_result)
decode_AcquireCallTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireCallTicket_result
decode_AcquireCallTicket_result iprot bs = to_AcquireCallTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireCallTicket_result) bs
typemap_AcquireCallTicket_result :: T.TypeMap
typemap_AcquireCallTicket_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireCallTicket_result :: AcquireCallTicket_result
default_AcquireCallTicket_result = AcquireCallTicket_result{
  acquireCallTicket_result_success = "",
  acquireCallTicket_result_e = P.Nothing}
data AcquireEncryptedAccessToken_args = AcquireEncryptedAccessToken_args  { acquireEncryptedAccessToken_args_featureType :: FeatureType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireEncryptedAccessToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireEncryptedAccessToken_args_featureType record  
instance QC.Arbitrary AcquireEncryptedAccessToken_args where 
  arbitrary = M.liftM AcquireEncryptedAccessToken_args (QC.arbitrary)
  shrink obj | obj == default_AcquireEncryptedAccessToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireEncryptedAccessToken_args{acquireEncryptedAccessToken_args_featureType = acquireEncryptedAccessToken_args_featureType obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_args{acquireEncryptedAccessToken_args_featureType = acquireEncryptedAccessToken_args_featureType obj}
    ]
from_AcquireEncryptedAccessToken_args :: AcquireEncryptedAccessToken_args -> T.ThriftVal
from_AcquireEncryptedAccessToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6149 -> P.Just (2, ("featureType",T.TI32 $ P.fromIntegral $ P.fromEnum _v6149))) $ acquireEncryptedAccessToken_args_featureType record
  ]
write_AcquireEncryptedAccessToken_args :: T.Protocol p => p -> AcquireEncryptedAccessToken_args -> P.IO ()
write_AcquireEncryptedAccessToken_args oprot record = T.writeVal oprot $ from_AcquireEncryptedAccessToken_args record
encode_AcquireEncryptedAccessToken_args :: T.StatelessProtocol p => p -> AcquireEncryptedAccessToken_args -> LBS.ByteString
encode_AcquireEncryptedAccessToken_args oprot record = T.serializeVal oprot $ from_AcquireEncryptedAccessToken_args record
to_AcquireEncryptedAccessToken_args :: T.ThriftVal -> AcquireEncryptedAccessToken_args
to_AcquireEncryptedAccessToken_args (T.TStruct fields) = AcquireEncryptedAccessToken_args{
  acquireEncryptedAccessToken_args_featureType = P.maybe (acquireEncryptedAccessToken_args_featureType default_AcquireEncryptedAccessToken_args) (\(_,_val6151) -> (case _val6151 of {T.TI32 _val6152 -> P.toEnum $ P.fromIntegral _val6152; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquireEncryptedAccessToken_args _ = P.error "not a struct"
read_AcquireEncryptedAccessToken_args :: T.Protocol p => p -> P.IO AcquireEncryptedAccessToken_args
read_AcquireEncryptedAccessToken_args iprot = to_AcquireEncryptedAccessToken_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_args)
decode_AcquireEncryptedAccessToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireEncryptedAccessToken_args
decode_AcquireEncryptedAccessToken_args iprot bs = to_AcquireEncryptedAccessToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_args) bs
typemap_AcquireEncryptedAccessToken_args :: T.TypeMap
typemap_AcquireEncryptedAccessToken_args = Map.fromList [(2,("featureType",T.T_I32))]
default_AcquireEncryptedAccessToken_args :: AcquireEncryptedAccessToken_args
default_AcquireEncryptedAccessToken_args = AcquireEncryptedAccessToken_args{
  acquireEncryptedAccessToken_args_featureType = (P.toEnum 0)}
data AcquireEncryptedAccessToken_result = AcquireEncryptedAccessToken_result  { acquireEncryptedAccessToken_result_success :: LT.Text
  , acquireEncryptedAccessToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireEncryptedAccessToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireEncryptedAccessToken_result_success record   `H.hashWithSalt` acquireEncryptedAccessToken_result_e record  
instance QC.Arbitrary AcquireEncryptedAccessToken_result where 
  arbitrary = M.liftM AcquireEncryptedAccessToken_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireEncryptedAccessToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = acquireEncryptedAccessToken_result_success obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = acquireEncryptedAccessToken_result_success obj}
    , if obj == default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = acquireEncryptedAccessToken_result_e obj} then P.Nothing else P.Just $ default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = acquireEncryptedAccessToken_result_e obj}
    ]
from_AcquireEncryptedAccessToken_result :: AcquireEncryptedAccessToken_result -> T.ThriftVal
from_AcquireEncryptedAccessToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6155 -> (1, ("e",from_TalkException _v6155))) <$> acquireEncryptedAccessToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6155 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6155))) $ acquireEncryptedAccessToken_result_success record
    , (\_v6155 -> (1, ("e",from_TalkException _v6155))) <$> acquireEncryptedAccessToken_result_e record
    ]
    )
write_AcquireEncryptedAccessToken_result :: T.Protocol p => p -> AcquireEncryptedAccessToken_result -> P.IO ()
write_AcquireEncryptedAccessToken_result oprot record = T.writeVal oprot $ from_AcquireEncryptedAccessToken_result record
encode_AcquireEncryptedAccessToken_result :: T.StatelessProtocol p => p -> AcquireEncryptedAccessToken_result -> LBS.ByteString
encode_AcquireEncryptedAccessToken_result oprot record = T.serializeVal oprot $ from_AcquireEncryptedAccessToken_result record
to_AcquireEncryptedAccessToken_result :: T.ThriftVal -> AcquireEncryptedAccessToken_result
to_AcquireEncryptedAccessToken_result (T.TStruct fields) = AcquireEncryptedAccessToken_result{
  acquireEncryptedAccessToken_result_success = P.maybe (acquireEncryptedAccessToken_result_success default_AcquireEncryptedAccessToken_result) (\(_,_val6157) -> (case _val6157 of {T.TString _val6158 -> E.decodeUtf8 _val6158; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireEncryptedAccessToken_result_e = P.maybe (P.Nothing) (\(_,_val6157) -> P.Just (case _val6157 of {T.TStruct _val6159 -> (to_TalkException (T.TStruct _val6159)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireEncryptedAccessToken_result _ = P.error "not a struct"
read_AcquireEncryptedAccessToken_result :: T.Protocol p => p -> P.IO AcquireEncryptedAccessToken_result
read_AcquireEncryptedAccessToken_result iprot = to_AcquireEncryptedAccessToken_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_result)
decode_AcquireEncryptedAccessToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireEncryptedAccessToken_result
decode_AcquireEncryptedAccessToken_result iprot bs = to_AcquireEncryptedAccessToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireEncryptedAccessToken_result) bs
typemap_AcquireEncryptedAccessToken_result :: T.TypeMap
typemap_AcquireEncryptedAccessToken_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireEncryptedAccessToken_result :: AcquireEncryptedAccessToken_result
default_AcquireEncryptedAccessToken_result = AcquireEncryptedAccessToken_result{
  acquireEncryptedAccessToken_result_success = "",
  acquireEncryptedAccessToken_result_e = P.Nothing}
data AddSnsId_args = AddSnsId_args  { addSnsId_args_snsIdType :: SnsIdType
  , addSnsId_args_snsAccessToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addSnsId_args_snsIdType record   `H.hashWithSalt` addSnsId_args_snsAccessToken record  
instance QC.Arbitrary AddSnsId_args where 
  arbitrary = M.liftM AddSnsId_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddSnsId_args{addSnsId_args_snsIdType = addSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_AddSnsId_args{addSnsId_args_snsIdType = addSnsId_args_snsIdType obj}
    , if obj == default_AddSnsId_args{addSnsId_args_snsAccessToken = addSnsId_args_snsAccessToken obj} then P.Nothing else P.Just $ default_AddSnsId_args{addSnsId_args_snsAccessToken = addSnsId_args_snsAccessToken obj}
    ]
from_AddSnsId_args :: AddSnsId_args -> T.ThriftVal
from_AddSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6162 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v6162))) $ addSnsId_args_snsIdType record
  , (\_v6162 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v6162))) $ addSnsId_args_snsAccessToken record
  ]
write_AddSnsId_args :: T.Protocol p => p -> AddSnsId_args -> P.IO ()
write_AddSnsId_args oprot record = T.writeVal oprot $ from_AddSnsId_args record
encode_AddSnsId_args :: T.StatelessProtocol p => p -> AddSnsId_args -> LBS.ByteString
encode_AddSnsId_args oprot record = T.serializeVal oprot $ from_AddSnsId_args record
to_AddSnsId_args :: T.ThriftVal -> AddSnsId_args
to_AddSnsId_args (T.TStruct fields) = AddSnsId_args{
  addSnsId_args_snsIdType = P.maybe (addSnsId_args_snsIdType default_AddSnsId_args) (\(_,_val6164) -> (case _val6164 of {T.TI32 _val6165 -> P.toEnum $ P.fromIntegral _val6165; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addSnsId_args_snsAccessToken = P.maybe (addSnsId_args_snsAccessToken default_AddSnsId_args) (\(_,_val6164) -> (case _val6164 of {T.TString _val6166 -> E.decodeUtf8 _val6166; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AddSnsId_args _ = P.error "not a struct"
read_AddSnsId_args :: T.Protocol p => p -> P.IO AddSnsId_args
read_AddSnsId_args iprot = to_AddSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_AddSnsId_args)
decode_AddSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddSnsId_args
decode_AddSnsId_args iprot bs = to_AddSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddSnsId_args) bs
typemap_AddSnsId_args :: T.TypeMap
typemap_AddSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING))]
default_AddSnsId_args :: AddSnsId_args
default_AddSnsId_args = AddSnsId_args{
  addSnsId_args_snsIdType = (P.toEnum 0),
  addSnsId_args_snsAccessToken = ""}
data AddSnsId_result = AddSnsId_result  { addSnsId_result_success :: LT.Text
  , addSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addSnsId_result_success record   `H.hashWithSalt` addSnsId_result_e record  
instance QC.Arbitrary AddSnsId_result where 
  arbitrary = M.liftM AddSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddSnsId_result{addSnsId_result_success = addSnsId_result_success obj} then P.Nothing else P.Just $ default_AddSnsId_result{addSnsId_result_success = addSnsId_result_success obj}
    , if obj == default_AddSnsId_result{addSnsId_result_e = addSnsId_result_e obj} then P.Nothing else P.Just $ default_AddSnsId_result{addSnsId_result_e = addSnsId_result_e obj}
    ]
from_AddSnsId_result :: AddSnsId_result -> T.ThriftVal
from_AddSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6169 -> (1, ("e",from_TalkException _v6169))) <$> addSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6169 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6169))) $ addSnsId_result_success record
    , (\_v6169 -> (1, ("e",from_TalkException _v6169))) <$> addSnsId_result_e record
    ]
    )
write_AddSnsId_result :: T.Protocol p => p -> AddSnsId_result -> P.IO ()
write_AddSnsId_result oprot record = T.writeVal oprot $ from_AddSnsId_result record
encode_AddSnsId_result :: T.StatelessProtocol p => p -> AddSnsId_result -> LBS.ByteString
encode_AddSnsId_result oprot record = T.serializeVal oprot $ from_AddSnsId_result record
to_AddSnsId_result :: T.ThriftVal -> AddSnsId_result
to_AddSnsId_result (T.TStruct fields) = AddSnsId_result{
  addSnsId_result_success = P.maybe (addSnsId_result_success default_AddSnsId_result) (\(_,_val6171) -> (case _val6171 of {T.TString _val6172 -> E.decodeUtf8 _val6172; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  addSnsId_result_e = P.maybe (P.Nothing) (\(_,_val6171) -> P.Just (case _val6171 of {T.TStruct _val6173 -> (to_TalkException (T.TStruct _val6173)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddSnsId_result _ = P.error "not a struct"
read_AddSnsId_result :: T.Protocol p => p -> P.IO AddSnsId_result
read_AddSnsId_result iprot = to_AddSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_AddSnsId_result)
decode_AddSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddSnsId_result
decode_AddSnsId_result iprot bs = to_AddSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddSnsId_result) bs
typemap_AddSnsId_result :: T.TypeMap
typemap_AddSnsId_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddSnsId_result :: AddSnsId_result
default_AddSnsId_result = AddSnsId_result{
  addSnsId_result_success = "",
  addSnsId_result_e = P.Nothing}
data BlockContact_args = BlockContact_args  { blockContact_args_reqSeq :: I.Int32
  , blockContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockContact_args_reqSeq record   `H.hashWithSalt` blockContact_args_id record  
instance QC.Arbitrary BlockContact_args where 
  arbitrary = M.liftM BlockContact_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BlockContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockContact_args{blockContact_args_reqSeq = blockContact_args_reqSeq obj} then P.Nothing else P.Just $ default_BlockContact_args{blockContact_args_reqSeq = blockContact_args_reqSeq obj}
    , if obj == default_BlockContact_args{blockContact_args_id = blockContact_args_id obj} then P.Nothing else P.Just $ default_BlockContact_args{blockContact_args_id = blockContact_args_id obj}
    ]
from_BlockContact_args :: BlockContact_args -> T.ThriftVal
from_BlockContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6176 -> P.Just (1, ("reqSeq",T.TI32 _v6176))) $ blockContact_args_reqSeq record
  , (\_v6176 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v6176))) $ blockContact_args_id record
  ]
write_BlockContact_args :: T.Protocol p => p -> BlockContact_args -> P.IO ()
write_BlockContact_args oprot record = T.writeVal oprot $ from_BlockContact_args record
encode_BlockContact_args :: T.StatelessProtocol p => p -> BlockContact_args -> LBS.ByteString
encode_BlockContact_args oprot record = T.serializeVal oprot $ from_BlockContact_args record
to_BlockContact_args :: T.ThriftVal -> BlockContact_args
to_BlockContact_args (T.TStruct fields) = BlockContact_args{
  blockContact_args_reqSeq = P.maybe (blockContact_args_reqSeq default_BlockContact_args) (\(_,_val6178) -> (case _val6178 of {T.TI32 _val6179 -> _val6179; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  blockContact_args_id = P.maybe (blockContact_args_id default_BlockContact_args) (\(_,_val6178) -> (case _val6178 of {T.TString _val6180 -> E.decodeUtf8 _val6180; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BlockContact_args _ = P.error "not a struct"
read_BlockContact_args :: T.Protocol p => p -> P.IO BlockContact_args
read_BlockContact_args iprot = to_BlockContact_args <$> T.readVal iprot (T.T_STRUCT typemap_BlockContact_args)
decode_BlockContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockContact_args
decode_BlockContact_args iprot bs = to_BlockContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockContact_args) bs
typemap_BlockContact_args :: T.TypeMap
typemap_BlockContact_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_BlockContact_args :: BlockContact_args
default_BlockContact_args = BlockContact_args{
  blockContact_args_reqSeq = 0,
  blockContact_args_id = ""}
data BlockContact_result = BlockContact_result  { blockContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockContact_result_e record  
instance QC.Arbitrary BlockContact_result where 
  arbitrary = M.liftM BlockContact_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BlockContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockContact_result{blockContact_result_e = blockContact_result_e obj} then P.Nothing else P.Just $ default_BlockContact_result{blockContact_result_e = blockContact_result_e obj}
    ]
from_BlockContact_result :: BlockContact_result -> T.ThriftVal
from_BlockContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6183 -> (1, ("e",from_TalkException _v6183))) <$> blockContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6183 -> (1, ("e",from_TalkException _v6183))) <$> blockContact_result_e record
    ]
    )
write_BlockContact_result :: T.Protocol p => p -> BlockContact_result -> P.IO ()
write_BlockContact_result oprot record = T.writeVal oprot $ from_BlockContact_result record
encode_BlockContact_result :: T.StatelessProtocol p => p -> BlockContact_result -> LBS.ByteString
encode_BlockContact_result oprot record = T.serializeVal oprot $ from_BlockContact_result record
to_BlockContact_result :: T.ThriftVal -> BlockContact_result
to_BlockContact_result (T.TStruct fields) = BlockContact_result{
  blockContact_result_e = P.maybe (P.Nothing) (\(_,_val6185) -> P.Just (case _val6185 of {T.TStruct _val6186 -> (to_TalkException (T.TStruct _val6186)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BlockContact_result _ = P.error "not a struct"
read_BlockContact_result :: T.Protocol p => p -> P.IO BlockContact_result
read_BlockContact_result iprot = to_BlockContact_result <$> T.readVal iprot (T.T_STRUCT typemap_BlockContact_result)
decode_BlockContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockContact_result
decode_BlockContact_result iprot bs = to_BlockContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockContact_result) bs
typemap_BlockContact_result :: T.TypeMap
typemap_BlockContact_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BlockContact_result :: BlockContact_result
default_BlockContact_result = BlockContact_result{
  blockContact_result_e = P.Nothing}
data BlockRecommendation_args = BlockRecommendation_args  { blockRecommendation_args_reqSeq :: I.Int32
  , blockRecommendation_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockRecommendation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockRecommendation_args_reqSeq record   `H.hashWithSalt` blockRecommendation_args_id record  
instance QC.Arbitrary BlockRecommendation_args where 
  arbitrary = M.liftM BlockRecommendation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BlockRecommendation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockRecommendation_args{blockRecommendation_args_reqSeq = blockRecommendation_args_reqSeq obj} then P.Nothing else P.Just $ default_BlockRecommendation_args{blockRecommendation_args_reqSeq = blockRecommendation_args_reqSeq obj}
    , if obj == default_BlockRecommendation_args{blockRecommendation_args_id = blockRecommendation_args_id obj} then P.Nothing else P.Just $ default_BlockRecommendation_args{blockRecommendation_args_id = blockRecommendation_args_id obj}
    ]
from_BlockRecommendation_args :: BlockRecommendation_args -> T.ThriftVal
from_BlockRecommendation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6189 -> P.Just (1, ("reqSeq",T.TI32 _v6189))) $ blockRecommendation_args_reqSeq record
  , (\_v6189 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v6189))) $ blockRecommendation_args_id record
  ]
write_BlockRecommendation_args :: T.Protocol p => p -> BlockRecommendation_args -> P.IO ()
write_BlockRecommendation_args oprot record = T.writeVal oprot $ from_BlockRecommendation_args record
encode_BlockRecommendation_args :: T.StatelessProtocol p => p -> BlockRecommendation_args -> LBS.ByteString
encode_BlockRecommendation_args oprot record = T.serializeVal oprot $ from_BlockRecommendation_args record
to_BlockRecommendation_args :: T.ThriftVal -> BlockRecommendation_args
to_BlockRecommendation_args (T.TStruct fields) = BlockRecommendation_args{
  blockRecommendation_args_reqSeq = P.maybe (blockRecommendation_args_reqSeq default_BlockRecommendation_args) (\(_,_val6191) -> (case _val6191 of {T.TI32 _val6192 -> _val6192; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  blockRecommendation_args_id = P.maybe (blockRecommendation_args_id default_BlockRecommendation_args) (\(_,_val6191) -> (case _val6191 of {T.TString _val6193 -> E.decodeUtf8 _val6193; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BlockRecommendation_args _ = P.error "not a struct"
read_BlockRecommendation_args :: T.Protocol p => p -> P.IO BlockRecommendation_args
read_BlockRecommendation_args iprot = to_BlockRecommendation_args <$> T.readVal iprot (T.T_STRUCT typemap_BlockRecommendation_args)
decode_BlockRecommendation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockRecommendation_args
decode_BlockRecommendation_args iprot bs = to_BlockRecommendation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockRecommendation_args) bs
typemap_BlockRecommendation_args :: T.TypeMap
typemap_BlockRecommendation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_BlockRecommendation_args :: BlockRecommendation_args
default_BlockRecommendation_args = BlockRecommendation_args{
  blockRecommendation_args_reqSeq = 0,
  blockRecommendation_args_id = ""}
data BlockRecommendation_result = BlockRecommendation_result  { blockRecommendation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BlockRecommendation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` blockRecommendation_result_e record  
instance QC.Arbitrary BlockRecommendation_result where 
  arbitrary = M.liftM BlockRecommendation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BlockRecommendation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BlockRecommendation_result{blockRecommendation_result_e = blockRecommendation_result_e obj} then P.Nothing else P.Just $ default_BlockRecommendation_result{blockRecommendation_result_e = blockRecommendation_result_e obj}
    ]
from_BlockRecommendation_result :: BlockRecommendation_result -> T.ThriftVal
from_BlockRecommendation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6196 -> (1, ("e",from_TalkException _v6196))) <$> blockRecommendation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6196 -> (1, ("e",from_TalkException _v6196))) <$> blockRecommendation_result_e record
    ]
    )
write_BlockRecommendation_result :: T.Protocol p => p -> BlockRecommendation_result -> P.IO ()
write_BlockRecommendation_result oprot record = T.writeVal oprot $ from_BlockRecommendation_result record
encode_BlockRecommendation_result :: T.StatelessProtocol p => p -> BlockRecommendation_result -> LBS.ByteString
encode_BlockRecommendation_result oprot record = T.serializeVal oprot $ from_BlockRecommendation_result record
to_BlockRecommendation_result :: T.ThriftVal -> BlockRecommendation_result
to_BlockRecommendation_result (T.TStruct fields) = BlockRecommendation_result{
  blockRecommendation_result_e = P.maybe (P.Nothing) (\(_,_val6198) -> P.Just (case _val6198 of {T.TStruct _val6199 -> (to_TalkException (T.TStruct _val6199)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BlockRecommendation_result _ = P.error "not a struct"
read_BlockRecommendation_result :: T.Protocol p => p -> P.IO BlockRecommendation_result
read_BlockRecommendation_result iprot = to_BlockRecommendation_result <$> T.readVal iprot (T.T_STRUCT typemap_BlockRecommendation_result)
decode_BlockRecommendation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BlockRecommendation_result
decode_BlockRecommendation_result iprot bs = to_BlockRecommendation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BlockRecommendation_result) bs
typemap_BlockRecommendation_result :: T.TypeMap
typemap_BlockRecommendation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BlockRecommendation_result :: BlockRecommendation_result
default_BlockRecommendation_result = BlockRecommendation_result{
  blockRecommendation_result_e = P.Nothing}
data CancelGroupInvitation_args = CancelGroupInvitation_args  { cancelGroupInvitation_args_reqSeq :: I.Int32
  , cancelGroupInvitation_args_groupId :: LT.Text
  , cancelGroupInvitation_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CancelGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` cancelGroupInvitation_args_reqSeq record   `H.hashWithSalt` cancelGroupInvitation_args_groupId record   `H.hashWithSalt` cancelGroupInvitation_args_contactIds record  
instance QC.Arbitrary CancelGroupInvitation_args where 
  arbitrary = M.liftM CancelGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CancelGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_reqSeq = cancelGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_reqSeq = cancelGroupInvitation_args_reqSeq obj}
    , if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_groupId = cancelGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_groupId = cancelGroupInvitation_args_groupId obj}
    , if obj == default_CancelGroupInvitation_args{cancelGroupInvitation_args_contactIds = cancelGroupInvitation_args_contactIds obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_args{cancelGroupInvitation_args_contactIds = cancelGroupInvitation_args_contactIds obj}
    ]
from_CancelGroupInvitation_args :: CancelGroupInvitation_args -> T.ThriftVal
from_CancelGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6202 -> P.Just (1, ("reqSeq",T.TI32 _v6202))) $ cancelGroupInvitation_args_reqSeq record
  , (\_v6202 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v6202))) $ cancelGroupInvitation_args_groupId record
  , (\_v6202 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v6204 -> T.TString $ E.encodeUtf8 _v6204) $ Vector.toList _v6202))) $ cancelGroupInvitation_args_contactIds record
  ]
write_CancelGroupInvitation_args :: T.Protocol p => p -> CancelGroupInvitation_args -> P.IO ()
write_CancelGroupInvitation_args oprot record = T.writeVal oprot $ from_CancelGroupInvitation_args record
encode_CancelGroupInvitation_args :: T.StatelessProtocol p => p -> CancelGroupInvitation_args -> LBS.ByteString
encode_CancelGroupInvitation_args oprot record = T.serializeVal oprot $ from_CancelGroupInvitation_args record
to_CancelGroupInvitation_args :: T.ThriftVal -> CancelGroupInvitation_args
to_CancelGroupInvitation_args (T.TStruct fields) = CancelGroupInvitation_args{
  cancelGroupInvitation_args_reqSeq = P.maybe (cancelGroupInvitation_args_reqSeq default_CancelGroupInvitation_args) (\(_,_val6206) -> (case _val6206 of {T.TI32 _val6207 -> _val6207; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  cancelGroupInvitation_args_groupId = P.maybe (cancelGroupInvitation_args_groupId default_CancelGroupInvitation_args) (\(_,_val6206) -> (case _val6206 of {T.TString _val6208 -> E.decodeUtf8 _val6208; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  cancelGroupInvitation_args_contactIds = P.maybe (cancelGroupInvitation_args_contactIds default_CancelGroupInvitation_args) (\(_,_val6206) -> (case _val6206 of {T.TList _ _val6209 -> (Vector.fromList $ P.map (\_v6210 -> (case _v6210 of {T.TString _val6211 -> E.decodeUtf8 _val6211; _ -> P.error "wrong type"})) _val6209); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CancelGroupInvitation_args _ = P.error "not a struct"
read_CancelGroupInvitation_args :: T.Protocol p => p -> P.IO CancelGroupInvitation_args
read_CancelGroupInvitation_args iprot = to_CancelGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_args)
decode_CancelGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CancelGroupInvitation_args
decode_CancelGroupInvitation_args iprot bs = to_CancelGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_args) bs
typemap_CancelGroupInvitation_args :: T.TypeMap
typemap_CancelGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CancelGroupInvitation_args :: CancelGroupInvitation_args
default_CancelGroupInvitation_args = CancelGroupInvitation_args{
  cancelGroupInvitation_args_reqSeq = 0,
  cancelGroupInvitation_args_groupId = "",
  cancelGroupInvitation_args_contactIds = Vector.empty}
data CancelGroupInvitation_result = CancelGroupInvitation_result  { cancelGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CancelGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` cancelGroupInvitation_result_e record  
instance QC.Arbitrary CancelGroupInvitation_result where 
  arbitrary = M.liftM CancelGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CancelGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = cancelGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = cancelGroupInvitation_result_e obj}
    ]
from_CancelGroupInvitation_result :: CancelGroupInvitation_result -> T.ThriftVal
from_CancelGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6214 -> (1, ("e",from_TalkException _v6214))) <$> cancelGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6214 -> (1, ("e",from_TalkException _v6214))) <$> cancelGroupInvitation_result_e record
    ]
    )
write_CancelGroupInvitation_result :: T.Protocol p => p -> CancelGroupInvitation_result -> P.IO ()
write_CancelGroupInvitation_result oprot record = T.writeVal oprot $ from_CancelGroupInvitation_result record
encode_CancelGroupInvitation_result :: T.StatelessProtocol p => p -> CancelGroupInvitation_result -> LBS.ByteString
encode_CancelGroupInvitation_result oprot record = T.serializeVal oprot $ from_CancelGroupInvitation_result record
to_CancelGroupInvitation_result :: T.ThriftVal -> CancelGroupInvitation_result
to_CancelGroupInvitation_result (T.TStruct fields) = CancelGroupInvitation_result{
  cancelGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val6216) -> P.Just (case _val6216 of {T.TStruct _val6217 -> (to_TalkException (T.TStruct _val6217)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CancelGroupInvitation_result _ = P.error "not a struct"
read_CancelGroupInvitation_result :: T.Protocol p => p -> P.IO CancelGroupInvitation_result
read_CancelGroupInvitation_result iprot = to_CancelGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_result)
decode_CancelGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CancelGroupInvitation_result
decode_CancelGroupInvitation_result iprot bs = to_CancelGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CancelGroupInvitation_result) bs
typemap_CancelGroupInvitation_result :: T.TypeMap
typemap_CancelGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CancelGroupInvitation_result :: CancelGroupInvitation_result
default_CancelGroupInvitation_result = CancelGroupInvitation_result{
  cancelGroupInvitation_result_e = P.Nothing}
data ChangeVerificationMethod_args = ChangeVerificationMethod_args  { changeVerificationMethod_args_sessionId :: LT.Text
  , changeVerificationMethod_args_method :: VerificationMethod
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChangeVerificationMethod_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` changeVerificationMethod_args_sessionId record   `H.hashWithSalt` changeVerificationMethod_args_method record  
instance QC.Arbitrary ChangeVerificationMethod_args where 
  arbitrary = M.liftM ChangeVerificationMethod_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ChangeVerificationMethod_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChangeVerificationMethod_args{changeVerificationMethod_args_sessionId = changeVerificationMethod_args_sessionId obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_args{changeVerificationMethod_args_sessionId = changeVerificationMethod_args_sessionId obj}
    , if obj == default_ChangeVerificationMethod_args{changeVerificationMethod_args_method = changeVerificationMethod_args_method obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_args{changeVerificationMethod_args_method = changeVerificationMethod_args_method obj}
    ]
from_ChangeVerificationMethod_args :: ChangeVerificationMethod_args -> T.ThriftVal
from_ChangeVerificationMethod_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6220 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6220))) $ changeVerificationMethod_args_sessionId record
  , (\_v6220 -> P.Just (3, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v6220))) $ changeVerificationMethod_args_method record
  ]
write_ChangeVerificationMethod_args :: T.Protocol p => p -> ChangeVerificationMethod_args -> P.IO ()
write_ChangeVerificationMethod_args oprot record = T.writeVal oprot $ from_ChangeVerificationMethod_args record
encode_ChangeVerificationMethod_args :: T.StatelessProtocol p => p -> ChangeVerificationMethod_args -> LBS.ByteString
encode_ChangeVerificationMethod_args oprot record = T.serializeVal oprot $ from_ChangeVerificationMethod_args record
to_ChangeVerificationMethod_args :: T.ThriftVal -> ChangeVerificationMethod_args
to_ChangeVerificationMethod_args (T.TStruct fields) = ChangeVerificationMethod_args{
  changeVerificationMethod_args_sessionId = P.maybe (changeVerificationMethod_args_sessionId default_ChangeVerificationMethod_args) (\(_,_val6222) -> (case _val6222 of {T.TString _val6223 -> E.decodeUtf8 _val6223; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  changeVerificationMethod_args_method = P.maybe (changeVerificationMethod_args_method default_ChangeVerificationMethod_args) (\(_,_val6222) -> (case _val6222 of {T.TI32 _val6224 -> P.toEnum $ P.fromIntegral _val6224; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ChangeVerificationMethod_args _ = P.error "not a struct"
read_ChangeVerificationMethod_args :: T.Protocol p => p -> P.IO ChangeVerificationMethod_args
read_ChangeVerificationMethod_args iprot = to_ChangeVerificationMethod_args <$> T.readVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_args)
decode_ChangeVerificationMethod_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ChangeVerificationMethod_args
decode_ChangeVerificationMethod_args iprot bs = to_ChangeVerificationMethod_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_args) bs
typemap_ChangeVerificationMethod_args :: T.TypeMap
typemap_ChangeVerificationMethod_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("method",T.T_I32))]
default_ChangeVerificationMethod_args :: ChangeVerificationMethod_args
default_ChangeVerificationMethod_args = ChangeVerificationMethod_args{
  changeVerificationMethod_args_sessionId = "",
  changeVerificationMethod_args_method = (P.toEnum 0)}
data ChangeVerificationMethod_result = ChangeVerificationMethod_result  { changeVerificationMethod_result_success :: VerificationSessionData
  , changeVerificationMethod_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ChangeVerificationMethod_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` changeVerificationMethod_result_success record   `H.hashWithSalt` changeVerificationMethod_result_e record  
instance QC.Arbitrary ChangeVerificationMethod_result where 
  arbitrary = M.liftM ChangeVerificationMethod_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ChangeVerificationMethod_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = changeVerificationMethod_result_success obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = changeVerificationMethod_result_success obj}
    , if obj == default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = changeVerificationMethod_result_e obj} then P.Nothing else P.Just $ default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = changeVerificationMethod_result_e obj}
    ]
from_ChangeVerificationMethod_result :: ChangeVerificationMethod_result -> T.ThriftVal
from_ChangeVerificationMethod_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6227 -> (1, ("e",from_TalkException _v6227))) <$> changeVerificationMethod_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6227 -> P.Just (0, ("success",from_VerificationSessionData _v6227))) $ changeVerificationMethod_result_success record
    , (\_v6227 -> (1, ("e",from_TalkException _v6227))) <$> changeVerificationMethod_result_e record
    ]
    )
write_ChangeVerificationMethod_result :: T.Protocol p => p -> ChangeVerificationMethod_result -> P.IO ()
write_ChangeVerificationMethod_result oprot record = T.writeVal oprot $ from_ChangeVerificationMethod_result record
encode_ChangeVerificationMethod_result :: T.StatelessProtocol p => p -> ChangeVerificationMethod_result -> LBS.ByteString
encode_ChangeVerificationMethod_result oprot record = T.serializeVal oprot $ from_ChangeVerificationMethod_result record
to_ChangeVerificationMethod_result :: T.ThriftVal -> ChangeVerificationMethod_result
to_ChangeVerificationMethod_result (T.TStruct fields) = ChangeVerificationMethod_result{
  changeVerificationMethod_result_success = P.maybe (changeVerificationMethod_result_success default_ChangeVerificationMethod_result) (\(_,_val6229) -> (case _val6229 of {T.TStruct _val6230 -> (to_VerificationSessionData (T.TStruct _val6230)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  changeVerificationMethod_result_e = P.maybe (P.Nothing) (\(_,_val6229) -> P.Just (case _val6229 of {T.TStruct _val6231 -> (to_TalkException (T.TStruct _val6231)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ChangeVerificationMethod_result _ = P.error "not a struct"
read_ChangeVerificationMethod_result :: T.Protocol p => p -> P.IO ChangeVerificationMethod_result
read_ChangeVerificationMethod_result iprot = to_ChangeVerificationMethod_result <$> T.readVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_result)
decode_ChangeVerificationMethod_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ChangeVerificationMethod_result
decode_ChangeVerificationMethod_result iprot bs = to_ChangeVerificationMethod_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ChangeVerificationMethod_result) bs
typemap_ChangeVerificationMethod_result :: T.TypeMap
typemap_ChangeVerificationMethod_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ChangeVerificationMethod_result :: ChangeVerificationMethod_result
default_ChangeVerificationMethod_result = ChangeVerificationMethod_result{
  changeVerificationMethod_result_success = default_VerificationSessionData,
  changeVerificationMethod_result_e = P.Nothing}
data ClearIdentityCredential_args = ClearIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ClearIdentityCredential_args where 
  arbitrary = QC.elements [ClearIdentityCredential_args]
from_ClearIdentityCredential_args :: ClearIdentityCredential_args -> T.ThriftVal
from_ClearIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ClearIdentityCredential_args :: T.Protocol p => p -> ClearIdentityCredential_args -> P.IO ()
write_ClearIdentityCredential_args oprot record = T.writeVal oprot $ from_ClearIdentityCredential_args record
encode_ClearIdentityCredential_args :: T.StatelessProtocol p => p -> ClearIdentityCredential_args -> LBS.ByteString
encode_ClearIdentityCredential_args oprot record = T.serializeVal oprot $ from_ClearIdentityCredential_args record
to_ClearIdentityCredential_args :: T.ThriftVal -> ClearIdentityCredential_args
to_ClearIdentityCredential_args (T.TStruct fields) = ClearIdentityCredential_args{

  }
to_ClearIdentityCredential_args _ = P.error "not a struct"
read_ClearIdentityCredential_args :: T.Protocol p => p -> P.IO ClearIdentityCredential_args
read_ClearIdentityCredential_args iprot = to_ClearIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_args)
decode_ClearIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearIdentityCredential_args
decode_ClearIdentityCredential_args iprot bs = to_ClearIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_args) bs
typemap_ClearIdentityCredential_args :: T.TypeMap
typemap_ClearIdentityCredential_args = Map.fromList []
default_ClearIdentityCredential_args :: ClearIdentityCredential_args
default_ClearIdentityCredential_args = ClearIdentityCredential_args{
}
data ClearIdentityCredential_result = ClearIdentityCredential_result  { clearIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearIdentityCredential_result_e record  
instance QC.Arbitrary ClearIdentityCredential_result where 
  arbitrary = M.liftM ClearIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ClearIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearIdentityCredential_result{clearIdentityCredential_result_e = clearIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_ClearIdentityCredential_result{clearIdentityCredential_result_e = clearIdentityCredential_result_e obj}
    ]
from_ClearIdentityCredential_result :: ClearIdentityCredential_result -> T.ThriftVal
from_ClearIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6239 -> (1, ("e",from_TalkException _v6239))) <$> clearIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6239 -> (1, ("e",from_TalkException _v6239))) <$> clearIdentityCredential_result_e record
    ]
    )
write_ClearIdentityCredential_result :: T.Protocol p => p -> ClearIdentityCredential_result -> P.IO ()
write_ClearIdentityCredential_result oprot record = T.writeVal oprot $ from_ClearIdentityCredential_result record
encode_ClearIdentityCredential_result :: T.StatelessProtocol p => p -> ClearIdentityCredential_result -> LBS.ByteString
encode_ClearIdentityCredential_result oprot record = T.serializeVal oprot $ from_ClearIdentityCredential_result record
to_ClearIdentityCredential_result :: T.ThriftVal -> ClearIdentityCredential_result
to_ClearIdentityCredential_result (T.TStruct fields) = ClearIdentityCredential_result{
  clearIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val6241) -> P.Just (case _val6241 of {T.TStruct _val6242 -> (to_TalkException (T.TStruct _val6242)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ClearIdentityCredential_result _ = P.error "not a struct"
read_ClearIdentityCredential_result :: T.Protocol p => p -> P.IO ClearIdentityCredential_result
read_ClearIdentityCredential_result iprot = to_ClearIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_result)
decode_ClearIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearIdentityCredential_result
decode_ClearIdentityCredential_result iprot bs = to_ClearIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearIdentityCredential_result) bs
typemap_ClearIdentityCredential_result :: T.TypeMap
typemap_ClearIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ClearIdentityCredential_result :: ClearIdentityCredential_result
default_ClearIdentityCredential_result = ClearIdentityCredential_result{
  clearIdentityCredential_result_e = P.Nothing}
data ClearMessageBox_args = ClearMessageBox_args  { clearMessageBox_args_channelId :: LT.Text
  , clearMessageBox_args_messageBoxId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearMessageBox_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearMessageBox_args_channelId record   `H.hashWithSalt` clearMessageBox_args_messageBoxId record  
instance QC.Arbitrary ClearMessageBox_args where 
  arbitrary = M.liftM ClearMessageBox_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ClearMessageBox_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearMessageBox_args{clearMessageBox_args_channelId = clearMessageBox_args_channelId obj} then P.Nothing else P.Just $ default_ClearMessageBox_args{clearMessageBox_args_channelId = clearMessageBox_args_channelId obj}
    , if obj == default_ClearMessageBox_args{clearMessageBox_args_messageBoxId = clearMessageBox_args_messageBoxId obj} then P.Nothing else P.Just $ default_ClearMessageBox_args{clearMessageBox_args_messageBoxId = clearMessageBox_args_messageBoxId obj}
    ]
from_ClearMessageBox_args :: ClearMessageBox_args -> T.ThriftVal
from_ClearMessageBox_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6245 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v6245))) $ clearMessageBox_args_channelId record
  , (\_v6245 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v6245))) $ clearMessageBox_args_messageBoxId record
  ]
write_ClearMessageBox_args :: T.Protocol p => p -> ClearMessageBox_args -> P.IO ()
write_ClearMessageBox_args oprot record = T.writeVal oprot $ from_ClearMessageBox_args record
encode_ClearMessageBox_args :: T.StatelessProtocol p => p -> ClearMessageBox_args -> LBS.ByteString
encode_ClearMessageBox_args oprot record = T.serializeVal oprot $ from_ClearMessageBox_args record
to_ClearMessageBox_args :: T.ThriftVal -> ClearMessageBox_args
to_ClearMessageBox_args (T.TStruct fields) = ClearMessageBox_args{
  clearMessageBox_args_channelId = P.maybe (clearMessageBox_args_channelId default_ClearMessageBox_args) (\(_,_val6247) -> (case _val6247 of {T.TString _val6248 -> E.decodeUtf8 _val6248; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  clearMessageBox_args_messageBoxId = P.maybe (clearMessageBox_args_messageBoxId default_ClearMessageBox_args) (\(_,_val6247) -> (case _val6247 of {T.TString _val6249 -> E.decodeUtf8 _val6249; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ClearMessageBox_args _ = P.error "not a struct"
read_ClearMessageBox_args :: T.Protocol p => p -> P.IO ClearMessageBox_args
read_ClearMessageBox_args iprot = to_ClearMessageBox_args <$> T.readVal iprot (T.T_STRUCT typemap_ClearMessageBox_args)
decode_ClearMessageBox_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearMessageBox_args
decode_ClearMessageBox_args iprot bs = to_ClearMessageBox_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearMessageBox_args) bs
typemap_ClearMessageBox_args :: T.TypeMap
typemap_ClearMessageBox_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING))]
default_ClearMessageBox_args :: ClearMessageBox_args
default_ClearMessageBox_args = ClearMessageBox_args{
  clearMessageBox_args_channelId = "",
  clearMessageBox_args_messageBoxId = ""}
data ClearMessageBox_result = ClearMessageBox_result  { clearMessageBox_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ClearMessageBox_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` clearMessageBox_result_e record  
instance QC.Arbitrary ClearMessageBox_result where 
  arbitrary = M.liftM ClearMessageBox_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ClearMessageBox_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ClearMessageBox_result{clearMessageBox_result_e = clearMessageBox_result_e obj} then P.Nothing else P.Just $ default_ClearMessageBox_result{clearMessageBox_result_e = clearMessageBox_result_e obj}
    ]
from_ClearMessageBox_result :: ClearMessageBox_result -> T.ThriftVal
from_ClearMessageBox_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6252 -> (1, ("e",from_TalkException _v6252))) <$> clearMessageBox_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6252 -> (1, ("e",from_TalkException _v6252))) <$> clearMessageBox_result_e record
    ]
    )
write_ClearMessageBox_result :: T.Protocol p => p -> ClearMessageBox_result -> P.IO ()
write_ClearMessageBox_result oprot record = T.writeVal oprot $ from_ClearMessageBox_result record
encode_ClearMessageBox_result :: T.StatelessProtocol p => p -> ClearMessageBox_result -> LBS.ByteString
encode_ClearMessageBox_result oprot record = T.serializeVal oprot $ from_ClearMessageBox_result record
to_ClearMessageBox_result :: T.ThriftVal -> ClearMessageBox_result
to_ClearMessageBox_result (T.TStruct fields) = ClearMessageBox_result{
  clearMessageBox_result_e = P.maybe (P.Nothing) (\(_,_val6254) -> P.Just (case _val6254 of {T.TStruct _val6255 -> (to_TalkException (T.TStruct _val6255)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ClearMessageBox_result _ = P.error "not a struct"
read_ClearMessageBox_result :: T.Protocol p => p -> P.IO ClearMessageBox_result
read_ClearMessageBox_result iprot = to_ClearMessageBox_result <$> T.readVal iprot (T.T_STRUCT typemap_ClearMessageBox_result)
decode_ClearMessageBox_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ClearMessageBox_result
decode_ClearMessageBox_result iprot bs = to_ClearMessageBox_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ClearMessageBox_result) bs
typemap_ClearMessageBox_result :: T.TypeMap
typemap_ClearMessageBox_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ClearMessageBox_result :: ClearMessageBox_result
default_ClearMessageBox_result = ClearMessageBox_result{
  clearMessageBox_result_e = P.Nothing}
data CloseProximityMatch_args = CloseProximityMatch_args  { closeProximityMatch_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CloseProximityMatch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` closeProximityMatch_args_sessionId record  
instance QC.Arbitrary CloseProximityMatch_args where 
  arbitrary = M.liftM CloseProximityMatch_args (QC.arbitrary)
  shrink obj | obj == default_CloseProximityMatch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CloseProximityMatch_args{closeProximityMatch_args_sessionId = closeProximityMatch_args_sessionId obj} then P.Nothing else P.Just $ default_CloseProximityMatch_args{closeProximityMatch_args_sessionId = closeProximityMatch_args_sessionId obj}
    ]
from_CloseProximityMatch_args :: CloseProximityMatch_args -> T.ThriftVal
from_CloseProximityMatch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6258 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6258))) $ closeProximityMatch_args_sessionId record
  ]
write_CloseProximityMatch_args :: T.Protocol p => p -> CloseProximityMatch_args -> P.IO ()
write_CloseProximityMatch_args oprot record = T.writeVal oprot $ from_CloseProximityMatch_args record
encode_CloseProximityMatch_args :: T.StatelessProtocol p => p -> CloseProximityMatch_args -> LBS.ByteString
encode_CloseProximityMatch_args oprot record = T.serializeVal oprot $ from_CloseProximityMatch_args record
to_CloseProximityMatch_args :: T.ThriftVal -> CloseProximityMatch_args
to_CloseProximityMatch_args (T.TStruct fields) = CloseProximityMatch_args{
  closeProximityMatch_args_sessionId = P.maybe (closeProximityMatch_args_sessionId default_CloseProximityMatch_args) (\(_,_val6260) -> (case _val6260 of {T.TString _val6261 -> E.decodeUtf8 _val6261; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CloseProximityMatch_args _ = P.error "not a struct"
read_CloseProximityMatch_args :: T.Protocol p => p -> P.IO CloseProximityMatch_args
read_CloseProximityMatch_args iprot = to_CloseProximityMatch_args <$> T.readVal iprot (T.T_STRUCT typemap_CloseProximityMatch_args)
decode_CloseProximityMatch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CloseProximityMatch_args
decode_CloseProximityMatch_args iprot bs = to_CloseProximityMatch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CloseProximityMatch_args) bs
typemap_CloseProximityMatch_args :: T.TypeMap
typemap_CloseProximityMatch_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_CloseProximityMatch_args :: CloseProximityMatch_args
default_CloseProximityMatch_args = CloseProximityMatch_args{
  closeProximityMatch_args_sessionId = ""}
data CloseProximityMatch_result = CloseProximityMatch_result  { closeProximityMatch_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CloseProximityMatch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` closeProximityMatch_result_e record  
instance QC.Arbitrary CloseProximityMatch_result where 
  arbitrary = M.liftM CloseProximityMatch_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CloseProximityMatch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CloseProximityMatch_result{closeProximityMatch_result_e = closeProximityMatch_result_e obj} then P.Nothing else P.Just $ default_CloseProximityMatch_result{closeProximityMatch_result_e = closeProximityMatch_result_e obj}
    ]
from_CloseProximityMatch_result :: CloseProximityMatch_result -> T.ThriftVal
from_CloseProximityMatch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6264 -> (1, ("e",from_TalkException _v6264))) <$> closeProximityMatch_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6264 -> (1, ("e",from_TalkException _v6264))) <$> closeProximityMatch_result_e record
    ]
    )
write_CloseProximityMatch_result :: T.Protocol p => p -> CloseProximityMatch_result -> P.IO ()
write_CloseProximityMatch_result oprot record = T.writeVal oprot $ from_CloseProximityMatch_result record
encode_CloseProximityMatch_result :: T.StatelessProtocol p => p -> CloseProximityMatch_result -> LBS.ByteString
encode_CloseProximityMatch_result oprot record = T.serializeVal oprot $ from_CloseProximityMatch_result record
to_CloseProximityMatch_result :: T.ThriftVal -> CloseProximityMatch_result
to_CloseProximityMatch_result (T.TStruct fields) = CloseProximityMatch_result{
  closeProximityMatch_result_e = P.maybe (P.Nothing) (\(_,_val6266) -> P.Just (case _val6266 of {T.TStruct _val6267 -> (to_TalkException (T.TStruct _val6267)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CloseProximityMatch_result _ = P.error "not a struct"
read_CloseProximityMatch_result :: T.Protocol p => p -> P.IO CloseProximityMatch_result
read_CloseProximityMatch_result iprot = to_CloseProximityMatch_result <$> T.readVal iprot (T.T_STRUCT typemap_CloseProximityMatch_result)
decode_CloseProximityMatch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CloseProximityMatch_result
decode_CloseProximityMatch_result iprot bs = to_CloseProximityMatch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CloseProximityMatch_result) bs
typemap_CloseProximityMatch_result :: T.TypeMap
typemap_CloseProximityMatch_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CloseProximityMatch_result :: CloseProximityMatch_result
default_CloseProximityMatch_result = CloseProximityMatch_result{
  closeProximityMatch_result_e = P.Nothing}
data CommitSendMessage_args = CommitSendMessage_args  { commitSendMessage_args_seq :: I.Int32
  , commitSendMessage_args_messageId :: LT.Text
  , commitSendMessage_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessage_args_seq record   `H.hashWithSalt` commitSendMessage_args_messageId record   `H.hashWithSalt` commitSendMessage_args_receiverMids record  
instance QC.Arbitrary CommitSendMessage_args where 
  arbitrary = M.liftM CommitSendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitSendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessage_args{commitSendMessage_args_seq = commitSendMessage_args_seq obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_seq = commitSendMessage_args_seq obj}
    , if obj == default_CommitSendMessage_args{commitSendMessage_args_messageId = commitSendMessage_args_messageId obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_messageId = commitSendMessage_args_messageId obj}
    , if obj == default_CommitSendMessage_args{commitSendMessage_args_receiverMids = commitSendMessage_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitSendMessage_args{commitSendMessage_args_receiverMids = commitSendMessage_args_receiverMids obj}
    ]
from_CommitSendMessage_args :: CommitSendMessage_args -> T.ThriftVal
from_CommitSendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6270 -> P.Just (1, ("seq",T.TI32 _v6270))) $ commitSendMessage_args_seq record
  , (\_v6270 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v6270))) $ commitSendMessage_args_messageId record
  , (\_v6270 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v6272 -> T.TString $ E.encodeUtf8 _v6272) $ Vector.toList _v6270))) $ commitSendMessage_args_receiverMids record
  ]
write_CommitSendMessage_args :: T.Protocol p => p -> CommitSendMessage_args -> P.IO ()
write_CommitSendMessage_args oprot record = T.writeVal oprot $ from_CommitSendMessage_args record
encode_CommitSendMessage_args :: T.StatelessProtocol p => p -> CommitSendMessage_args -> LBS.ByteString
encode_CommitSendMessage_args oprot record = T.serializeVal oprot $ from_CommitSendMessage_args record
to_CommitSendMessage_args :: T.ThriftVal -> CommitSendMessage_args
to_CommitSendMessage_args (T.TStruct fields) = CommitSendMessage_args{
  commitSendMessage_args_seq = P.maybe (commitSendMessage_args_seq default_CommitSendMessage_args) (\(_,_val6274) -> (case _val6274 of {T.TI32 _val6275 -> _val6275; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitSendMessage_args_messageId = P.maybe (commitSendMessage_args_messageId default_CommitSendMessage_args) (\(_,_val6274) -> (case _val6274 of {T.TString _val6276 -> E.decodeUtf8 _val6276; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitSendMessage_args_receiverMids = P.maybe (commitSendMessage_args_receiverMids default_CommitSendMessage_args) (\(_,_val6274) -> (case _val6274 of {T.TList _ _val6277 -> (Vector.fromList $ P.map (\_v6278 -> (case _v6278 of {T.TString _val6279 -> E.decodeUtf8 _val6279; _ -> P.error "wrong type"})) _val6277); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitSendMessage_args _ = P.error "not a struct"
read_CommitSendMessage_args :: T.Protocol p => p -> P.IO CommitSendMessage_args
read_CommitSendMessage_args iprot = to_CommitSendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessage_args)
decode_CommitSendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessage_args
decode_CommitSendMessage_args iprot bs = to_CommitSendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessage_args) bs
typemap_CommitSendMessage_args :: T.TypeMap
typemap_CommitSendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("messageId",T.T_STRING)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitSendMessage_args :: CommitSendMessage_args
default_CommitSendMessage_args = CommitSendMessage_args{
  commitSendMessage_args_seq = 0,
  commitSendMessage_args_messageId = "",
  commitSendMessage_args_receiverMids = Vector.empty}
data CommitSendMessage_result = CommitSendMessage_result  { commitSendMessage_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitSendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessage_result_success record   `H.hashWithSalt` commitSendMessage_result_e record  
instance QC.Arbitrary CommitSendMessage_result where 
  arbitrary = M.liftM CommitSendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitSendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessage_result{commitSendMessage_result_success = commitSendMessage_result_success obj} then P.Nothing else P.Just $ default_CommitSendMessage_result{commitSendMessage_result_success = commitSendMessage_result_success obj}
    , if obj == default_CommitSendMessage_result{commitSendMessage_result_e = commitSendMessage_result_e obj} then P.Nothing else P.Just $ default_CommitSendMessage_result{commitSendMessage_result_e = commitSendMessage_result_e obj}
    ]
from_CommitSendMessage_result :: CommitSendMessage_result -> T.ThriftVal
from_CommitSendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6282 -> (1, ("e",from_TalkException _v6282))) <$> commitSendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6282 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k6283,_v6284) -> (T.TString $ E.encodeUtf8 _k6283, T.TString $ E.encodeUtf8 _v6284)) $ Map.toList _v6282))) $ commitSendMessage_result_success record
    , (\_v6282 -> (1, ("e",from_TalkException _v6282))) <$> commitSendMessage_result_e record
    ]
    )
write_CommitSendMessage_result :: T.Protocol p => p -> CommitSendMessage_result -> P.IO ()
write_CommitSendMessage_result oprot record = T.writeVal oprot $ from_CommitSendMessage_result record
encode_CommitSendMessage_result :: T.StatelessProtocol p => p -> CommitSendMessage_result -> LBS.ByteString
encode_CommitSendMessage_result oprot record = T.serializeVal oprot $ from_CommitSendMessage_result record
to_CommitSendMessage_result :: T.ThriftVal -> CommitSendMessage_result
to_CommitSendMessage_result (T.TStruct fields) = CommitSendMessage_result{
  commitSendMessage_result_success = P.maybe (commitSendMessage_result_success default_CommitSendMessage_result) (\(_,_val6286) -> (case _val6286 of {T.TMap _ _ _val6287 -> (Map.fromList $ P.map (\(_k6289,_v6288) -> ((case _k6289 of {T.TString _val6290 -> E.decodeUtf8 _val6290; _ -> P.error "wrong type"}),(case _v6288 of {T.TString _val6291 -> E.decodeUtf8 _val6291; _ -> P.error "wrong type"}))) _val6287); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitSendMessage_result_e = P.maybe (P.Nothing) (\(_,_val6286) -> P.Just (case _val6286 of {T.TStruct _val6292 -> (to_TalkException (T.TStruct _val6292)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitSendMessage_result _ = P.error "not a struct"
read_CommitSendMessage_result :: T.Protocol p => p -> P.IO CommitSendMessage_result
read_CommitSendMessage_result iprot = to_CommitSendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessage_result)
decode_CommitSendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessage_result
decode_CommitSendMessage_result iprot bs = to_CommitSendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessage_result) bs
typemap_CommitSendMessage_result :: T.TypeMap
typemap_CommitSendMessage_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitSendMessage_result :: CommitSendMessage_result
default_CommitSendMessage_result = CommitSendMessage_result{
  commitSendMessage_result_success = Map.empty,
  commitSendMessage_result_e = P.Nothing}
data CommitSendMessages_args = CommitSendMessages_args  { commitSendMessages_args_seq :: I.Int32
  , commitSendMessages_args_messageIds :: (Vector.Vector LT.Text)
  , commitSendMessages_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessages_args_seq record   `H.hashWithSalt` commitSendMessages_args_messageIds record   `H.hashWithSalt` commitSendMessages_args_receiverMids record  
instance QC.Arbitrary CommitSendMessages_args where 
  arbitrary = M.liftM CommitSendMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitSendMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessages_args{commitSendMessages_args_seq = commitSendMessages_args_seq obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_seq = commitSendMessages_args_seq obj}
    , if obj == default_CommitSendMessages_args{commitSendMessages_args_messageIds = commitSendMessages_args_messageIds obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_messageIds = commitSendMessages_args_messageIds obj}
    , if obj == default_CommitSendMessages_args{commitSendMessages_args_receiverMids = commitSendMessages_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitSendMessages_args{commitSendMessages_args_receiverMids = commitSendMessages_args_receiverMids obj}
    ]
from_CommitSendMessages_args :: CommitSendMessages_args -> T.ThriftVal
from_CommitSendMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6295 -> P.Just (1, ("seq",T.TI32 _v6295))) $ commitSendMessages_args_seq record
  , (\_v6295 -> P.Just (2, ("messageIds",T.TList T.T_STRING $ P.map (\_v6297 -> T.TString $ E.encodeUtf8 _v6297) $ Vector.toList _v6295))) $ commitSendMessages_args_messageIds record
  , (\_v6295 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v6299 -> T.TString $ E.encodeUtf8 _v6299) $ Vector.toList _v6295))) $ commitSendMessages_args_receiverMids record
  ]
write_CommitSendMessages_args :: T.Protocol p => p -> CommitSendMessages_args -> P.IO ()
write_CommitSendMessages_args oprot record = T.writeVal oprot $ from_CommitSendMessages_args record
encode_CommitSendMessages_args :: T.StatelessProtocol p => p -> CommitSendMessages_args -> LBS.ByteString
encode_CommitSendMessages_args oprot record = T.serializeVal oprot $ from_CommitSendMessages_args record
to_CommitSendMessages_args :: T.ThriftVal -> CommitSendMessages_args
to_CommitSendMessages_args (T.TStruct fields) = CommitSendMessages_args{
  commitSendMessages_args_seq = P.maybe (commitSendMessages_args_seq default_CommitSendMessages_args) (\(_,_val6301) -> (case _val6301 of {T.TI32 _val6302 -> _val6302; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitSendMessages_args_messageIds = P.maybe (commitSendMessages_args_messageIds default_CommitSendMessages_args) (\(_,_val6301) -> (case _val6301 of {T.TList _ _val6303 -> (Vector.fromList $ P.map (\_v6304 -> (case _v6304 of {T.TString _val6305 -> E.decodeUtf8 _val6305; _ -> P.error "wrong type"})) _val6303); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitSendMessages_args_receiverMids = P.maybe (commitSendMessages_args_receiverMids default_CommitSendMessages_args) (\(_,_val6301) -> (case _val6301 of {T.TList _ _val6306 -> (Vector.fromList $ P.map (\_v6307 -> (case _v6307 of {T.TString _val6308 -> E.decodeUtf8 _val6308; _ -> P.error "wrong type"})) _val6306); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitSendMessages_args _ = P.error "not a struct"
read_CommitSendMessages_args :: T.Protocol p => p -> P.IO CommitSendMessages_args
read_CommitSendMessages_args iprot = to_CommitSendMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessages_args)
decode_CommitSendMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessages_args
decode_CommitSendMessages_args iprot bs = to_CommitSendMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessages_args) bs
typemap_CommitSendMessages_args :: T.TypeMap
typemap_CommitSendMessages_args = Map.fromList [(1,("seq",T.T_I32)),(2,("messageIds",(T.T_LIST T.T_STRING))),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitSendMessages_args :: CommitSendMessages_args
default_CommitSendMessages_args = CommitSendMessages_args{
  commitSendMessages_args_seq = 0,
  commitSendMessages_args_messageIds = Vector.empty,
  commitSendMessages_args_receiverMids = Vector.empty}
data CommitSendMessages_result = CommitSendMessages_result  { commitSendMessages_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitSendMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitSendMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitSendMessages_result_success record   `H.hashWithSalt` commitSendMessages_result_e record  
instance QC.Arbitrary CommitSendMessages_result where 
  arbitrary = M.liftM CommitSendMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitSendMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitSendMessages_result{commitSendMessages_result_success = commitSendMessages_result_success obj} then P.Nothing else P.Just $ default_CommitSendMessages_result{commitSendMessages_result_success = commitSendMessages_result_success obj}
    , if obj == default_CommitSendMessages_result{commitSendMessages_result_e = commitSendMessages_result_e obj} then P.Nothing else P.Just $ default_CommitSendMessages_result{commitSendMessages_result_e = commitSendMessages_result_e obj}
    ]
from_CommitSendMessages_result :: CommitSendMessages_result -> T.ThriftVal
from_CommitSendMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6311 -> (1, ("e",from_TalkException _v6311))) <$> commitSendMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6311 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k6312,_v6313) -> (T.TString $ E.encodeUtf8 _k6312, T.TString $ E.encodeUtf8 _v6313)) $ Map.toList _v6311))) $ commitSendMessages_result_success record
    , (\_v6311 -> (1, ("e",from_TalkException _v6311))) <$> commitSendMessages_result_e record
    ]
    )
write_CommitSendMessages_result :: T.Protocol p => p -> CommitSendMessages_result -> P.IO ()
write_CommitSendMessages_result oprot record = T.writeVal oprot $ from_CommitSendMessages_result record
encode_CommitSendMessages_result :: T.StatelessProtocol p => p -> CommitSendMessages_result -> LBS.ByteString
encode_CommitSendMessages_result oprot record = T.serializeVal oprot $ from_CommitSendMessages_result record
to_CommitSendMessages_result :: T.ThriftVal -> CommitSendMessages_result
to_CommitSendMessages_result (T.TStruct fields) = CommitSendMessages_result{
  commitSendMessages_result_success = P.maybe (commitSendMessages_result_success default_CommitSendMessages_result) (\(_,_val6315) -> (case _val6315 of {T.TMap _ _ _val6316 -> (Map.fromList $ P.map (\(_k6318,_v6317) -> ((case _k6318 of {T.TString _val6319 -> E.decodeUtf8 _val6319; _ -> P.error "wrong type"}),(case _v6317 of {T.TString _val6320 -> E.decodeUtf8 _val6320; _ -> P.error "wrong type"}))) _val6316); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitSendMessages_result_e = P.maybe (P.Nothing) (\(_,_val6315) -> P.Just (case _val6315 of {T.TStruct _val6321 -> (to_TalkException (T.TStruct _val6321)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitSendMessages_result _ = P.error "not a struct"
read_CommitSendMessages_result :: T.Protocol p => p -> P.IO CommitSendMessages_result
read_CommitSendMessages_result iprot = to_CommitSendMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitSendMessages_result)
decode_CommitSendMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitSendMessages_result
decode_CommitSendMessages_result iprot bs = to_CommitSendMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitSendMessages_result) bs
typemap_CommitSendMessages_result :: T.TypeMap
typemap_CommitSendMessages_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitSendMessages_result :: CommitSendMessages_result
default_CommitSendMessages_result = CommitSendMessages_result{
  commitSendMessages_result_success = Map.empty,
  commitSendMessages_result_e = P.Nothing}
data CommitUpdateProfile_args = CommitUpdateProfile_args  { commitUpdateProfile_args_seq :: I.Int32
  , commitUpdateProfile_args_attrs :: (Vector.Vector ProfileAttribute)
  , commitUpdateProfile_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitUpdateProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitUpdateProfile_args_seq record   `H.hashWithSalt` commitUpdateProfile_args_attrs record   `H.hashWithSalt` commitUpdateProfile_args_receiverMids record  
instance QC.Arbitrary CommitUpdateProfile_args where 
  arbitrary = M.liftM CommitUpdateProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CommitUpdateProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_seq = commitUpdateProfile_args_seq obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_seq = commitUpdateProfile_args_seq obj}
    , if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_attrs = commitUpdateProfile_args_attrs obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_attrs = commitUpdateProfile_args_attrs obj}
    , if obj == default_CommitUpdateProfile_args{commitUpdateProfile_args_receiverMids = commitUpdateProfile_args_receiverMids obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_args{commitUpdateProfile_args_receiverMids = commitUpdateProfile_args_receiverMids obj}
    ]
from_CommitUpdateProfile_args :: CommitUpdateProfile_args -> T.ThriftVal
from_CommitUpdateProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6324 -> P.Just (1, ("seq",T.TI32 _v6324))) $ commitUpdateProfile_args_seq record
  , (\_v6324 -> P.Just (2, ("attrs",T.TList T.T_I32 $ P.map (\_v6326 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v6326) $ Vector.toList _v6324))) $ commitUpdateProfile_args_attrs record
  , (\_v6324 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v6328 -> T.TString $ E.encodeUtf8 _v6328) $ Vector.toList _v6324))) $ commitUpdateProfile_args_receiverMids record
  ]
write_CommitUpdateProfile_args :: T.Protocol p => p -> CommitUpdateProfile_args -> P.IO ()
write_CommitUpdateProfile_args oprot record = T.writeVal oprot $ from_CommitUpdateProfile_args record
encode_CommitUpdateProfile_args :: T.StatelessProtocol p => p -> CommitUpdateProfile_args -> LBS.ByteString
encode_CommitUpdateProfile_args oprot record = T.serializeVal oprot $ from_CommitUpdateProfile_args record
to_CommitUpdateProfile_args :: T.ThriftVal -> CommitUpdateProfile_args
to_CommitUpdateProfile_args (T.TStruct fields) = CommitUpdateProfile_args{
  commitUpdateProfile_args_seq = P.maybe (commitUpdateProfile_args_seq default_CommitUpdateProfile_args) (\(_,_val6330) -> (case _val6330 of {T.TI32 _val6331 -> _val6331; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  commitUpdateProfile_args_attrs = P.maybe (commitUpdateProfile_args_attrs default_CommitUpdateProfile_args) (\(_,_val6330) -> (case _val6330 of {T.TList _ _val6332 -> (Vector.fromList $ P.map (\_v6333 -> (case _v6333 of {T.TI32 _val6334 -> P.toEnum $ P.fromIntegral _val6334; _ -> P.error "wrong type"})) _val6332); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  commitUpdateProfile_args_receiverMids = P.maybe (commitUpdateProfile_args_receiverMids default_CommitUpdateProfile_args) (\(_,_val6330) -> (case _val6330 of {T.TList _ _val6335 -> (Vector.fromList $ P.map (\_v6336 -> (case _v6336 of {T.TString _val6337 -> E.decodeUtf8 _val6337; _ -> P.error "wrong type"})) _val6335); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CommitUpdateProfile_args _ = P.error "not a struct"
read_CommitUpdateProfile_args :: T.Protocol p => p -> P.IO CommitUpdateProfile_args
read_CommitUpdateProfile_args iprot = to_CommitUpdateProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_args)
decode_CommitUpdateProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitUpdateProfile_args
decode_CommitUpdateProfile_args iprot bs = to_CommitUpdateProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_args) bs
typemap_CommitUpdateProfile_args :: T.TypeMap
typemap_CommitUpdateProfile_args = Map.fromList [(1,("seq",T.T_I32)),(2,("attrs",(T.T_LIST T.T_I32))),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_CommitUpdateProfile_args :: CommitUpdateProfile_args
default_CommitUpdateProfile_args = CommitUpdateProfile_args{
  commitUpdateProfile_args_seq = 0,
  commitUpdateProfile_args_attrs = Vector.empty,
  commitUpdateProfile_args_receiverMids = Vector.empty}
data CommitUpdateProfile_result = CommitUpdateProfile_result  { commitUpdateProfile_result_success :: (Map.HashMap LT.Text LT.Text)
  , commitUpdateProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CommitUpdateProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` commitUpdateProfile_result_success record   `H.hashWithSalt` commitUpdateProfile_result_e record  
instance QC.Arbitrary CommitUpdateProfile_result where 
  arbitrary = M.liftM CommitUpdateProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CommitUpdateProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CommitUpdateProfile_result{commitUpdateProfile_result_success = commitUpdateProfile_result_success obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_result{commitUpdateProfile_result_success = commitUpdateProfile_result_success obj}
    , if obj == default_CommitUpdateProfile_result{commitUpdateProfile_result_e = commitUpdateProfile_result_e obj} then P.Nothing else P.Just $ default_CommitUpdateProfile_result{commitUpdateProfile_result_e = commitUpdateProfile_result_e obj}
    ]
from_CommitUpdateProfile_result :: CommitUpdateProfile_result -> T.ThriftVal
from_CommitUpdateProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6340 -> (1, ("e",from_TalkException _v6340))) <$> commitUpdateProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6340 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k6341,_v6342) -> (T.TString $ E.encodeUtf8 _k6341, T.TString $ E.encodeUtf8 _v6342)) $ Map.toList _v6340))) $ commitUpdateProfile_result_success record
    , (\_v6340 -> (1, ("e",from_TalkException _v6340))) <$> commitUpdateProfile_result_e record
    ]
    )
write_CommitUpdateProfile_result :: T.Protocol p => p -> CommitUpdateProfile_result -> P.IO ()
write_CommitUpdateProfile_result oprot record = T.writeVal oprot $ from_CommitUpdateProfile_result record
encode_CommitUpdateProfile_result :: T.StatelessProtocol p => p -> CommitUpdateProfile_result -> LBS.ByteString
encode_CommitUpdateProfile_result oprot record = T.serializeVal oprot $ from_CommitUpdateProfile_result record
to_CommitUpdateProfile_result :: T.ThriftVal -> CommitUpdateProfile_result
to_CommitUpdateProfile_result (T.TStruct fields) = CommitUpdateProfile_result{
  commitUpdateProfile_result_success = P.maybe (commitUpdateProfile_result_success default_CommitUpdateProfile_result) (\(_,_val6344) -> (case _val6344 of {T.TMap _ _ _val6345 -> (Map.fromList $ P.map (\(_k6347,_v6346) -> ((case _k6347 of {T.TString _val6348 -> E.decodeUtf8 _val6348; _ -> P.error "wrong type"}),(case _v6346 of {T.TString _val6349 -> E.decodeUtf8 _val6349; _ -> P.error "wrong type"}))) _val6345); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  commitUpdateProfile_result_e = P.maybe (P.Nothing) (\(_,_val6344) -> P.Just (case _val6344 of {T.TStruct _val6350 -> (to_TalkException (T.TStruct _val6350)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CommitUpdateProfile_result _ = P.error "not a struct"
read_CommitUpdateProfile_result :: T.Protocol p => p -> P.IO CommitUpdateProfile_result
read_CommitUpdateProfile_result iprot = to_CommitUpdateProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_result)
decode_CommitUpdateProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CommitUpdateProfile_result
decode_CommitUpdateProfile_result iprot bs = to_CommitUpdateProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CommitUpdateProfile_result) bs
typemap_CommitUpdateProfile_result :: T.TypeMap
typemap_CommitUpdateProfile_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CommitUpdateProfile_result :: CommitUpdateProfile_result
default_CommitUpdateProfile_result = CommitUpdateProfile_result{
  commitUpdateProfile_result_success = Map.empty,
  commitUpdateProfile_result_e = P.Nothing}
data ConfirmEmail_args = ConfirmEmail_args  { confirmEmail_args_verifier :: LT.Text
  , confirmEmail_args_pinCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmEmail_args_verifier record   `H.hashWithSalt` confirmEmail_args_pinCode record  
instance QC.Arbitrary ConfirmEmail_args where 
  arbitrary = M.liftM ConfirmEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ConfirmEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmEmail_args{confirmEmail_args_verifier = confirmEmail_args_verifier obj} then P.Nothing else P.Just $ default_ConfirmEmail_args{confirmEmail_args_verifier = confirmEmail_args_verifier obj}
    , if obj == default_ConfirmEmail_args{confirmEmail_args_pinCode = confirmEmail_args_pinCode obj} then P.Nothing else P.Just $ default_ConfirmEmail_args{confirmEmail_args_pinCode = confirmEmail_args_pinCode obj}
    ]
from_ConfirmEmail_args :: ConfirmEmail_args -> T.ThriftVal
from_ConfirmEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6353 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v6353))) $ confirmEmail_args_verifier record
  , (\_v6353 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v6353))) $ confirmEmail_args_pinCode record
  ]
write_ConfirmEmail_args :: T.Protocol p => p -> ConfirmEmail_args -> P.IO ()
write_ConfirmEmail_args oprot record = T.writeVal oprot $ from_ConfirmEmail_args record
encode_ConfirmEmail_args :: T.StatelessProtocol p => p -> ConfirmEmail_args -> LBS.ByteString
encode_ConfirmEmail_args oprot record = T.serializeVal oprot $ from_ConfirmEmail_args record
to_ConfirmEmail_args :: T.ThriftVal -> ConfirmEmail_args
to_ConfirmEmail_args (T.TStruct fields) = ConfirmEmail_args{
  confirmEmail_args_verifier = P.maybe (confirmEmail_args_verifier default_ConfirmEmail_args) (\(_,_val6355) -> (case _val6355 of {T.TString _val6356 -> E.decodeUtf8 _val6356; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  confirmEmail_args_pinCode = P.maybe (confirmEmail_args_pinCode default_ConfirmEmail_args) (\(_,_val6355) -> (case _val6355 of {T.TString _val6357 -> E.decodeUtf8 _val6357; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ConfirmEmail_args _ = P.error "not a struct"
read_ConfirmEmail_args :: T.Protocol p => p -> P.IO ConfirmEmail_args
read_ConfirmEmail_args iprot = to_ConfirmEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmEmail_args)
decode_ConfirmEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmEmail_args
decode_ConfirmEmail_args iprot bs = to_ConfirmEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmEmail_args) bs
typemap_ConfirmEmail_args :: T.TypeMap
typemap_ConfirmEmail_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING))]
default_ConfirmEmail_args :: ConfirmEmail_args
default_ConfirmEmail_args = ConfirmEmail_args{
  confirmEmail_args_verifier = "",
  confirmEmail_args_pinCode = ""}
data ConfirmEmail_result = ConfirmEmail_result  { confirmEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ConfirmEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` confirmEmail_result_e record  
instance QC.Arbitrary ConfirmEmail_result where 
  arbitrary = M.liftM ConfirmEmail_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ConfirmEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ConfirmEmail_result{confirmEmail_result_e = confirmEmail_result_e obj} then P.Nothing else P.Just $ default_ConfirmEmail_result{confirmEmail_result_e = confirmEmail_result_e obj}
    ]
from_ConfirmEmail_result :: ConfirmEmail_result -> T.ThriftVal
from_ConfirmEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6360 -> (1, ("e",from_TalkException _v6360))) <$> confirmEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6360 -> (1, ("e",from_TalkException _v6360))) <$> confirmEmail_result_e record
    ]
    )
write_ConfirmEmail_result :: T.Protocol p => p -> ConfirmEmail_result -> P.IO ()
write_ConfirmEmail_result oprot record = T.writeVal oprot $ from_ConfirmEmail_result record
encode_ConfirmEmail_result :: T.StatelessProtocol p => p -> ConfirmEmail_result -> LBS.ByteString
encode_ConfirmEmail_result oprot record = T.serializeVal oprot $ from_ConfirmEmail_result record
to_ConfirmEmail_result :: T.ThriftVal -> ConfirmEmail_result
to_ConfirmEmail_result (T.TStruct fields) = ConfirmEmail_result{
  confirmEmail_result_e = P.maybe (P.Nothing) (\(_,_val6362) -> P.Just (case _val6362 of {T.TStruct _val6363 -> (to_TalkException (T.TStruct _val6363)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ConfirmEmail_result _ = P.error "not a struct"
read_ConfirmEmail_result :: T.Protocol p => p -> P.IO ConfirmEmail_result
read_ConfirmEmail_result iprot = to_ConfirmEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_ConfirmEmail_result)
decode_ConfirmEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ConfirmEmail_result
decode_ConfirmEmail_result iprot bs = to_ConfirmEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ConfirmEmail_result) bs
typemap_ConfirmEmail_result :: T.TypeMap
typemap_ConfirmEmail_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ConfirmEmail_result :: ConfirmEmail_result
default_ConfirmEmail_result = ConfirmEmail_result{
  confirmEmail_result_e = P.Nothing}
data CreateGroup_args = CreateGroup_args  { createGroup_args_seq :: I.Int32
  , createGroup_args_name :: LT.Text
  , createGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createGroup_args_seq record   `H.hashWithSalt` createGroup_args_name record   `H.hashWithSalt` createGroup_args_contactIds record  
instance QC.Arbitrary CreateGroup_args where 
  arbitrary = M.liftM CreateGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateGroup_args{createGroup_args_seq = createGroup_args_seq obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_seq = createGroup_args_seq obj}
    , if obj == default_CreateGroup_args{createGroup_args_name = createGroup_args_name obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_name = createGroup_args_name obj}
    , if obj == default_CreateGroup_args{createGroup_args_contactIds = createGroup_args_contactIds obj} then P.Nothing else P.Just $ default_CreateGroup_args{createGroup_args_contactIds = createGroup_args_contactIds obj}
    ]
from_CreateGroup_args :: CreateGroup_args -> T.ThriftVal
from_CreateGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6366 -> P.Just (1, ("seq",T.TI32 _v6366))) $ createGroup_args_seq record
  , (\_v6366 -> P.Just (2, ("name",T.TString $ E.encodeUtf8 _v6366))) $ createGroup_args_name record
  , (\_v6366 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v6368 -> T.TString $ E.encodeUtf8 _v6368) $ Vector.toList _v6366))) $ createGroup_args_contactIds record
  ]
write_CreateGroup_args :: T.Protocol p => p -> CreateGroup_args -> P.IO ()
write_CreateGroup_args oprot record = T.writeVal oprot $ from_CreateGroup_args record
encode_CreateGroup_args :: T.StatelessProtocol p => p -> CreateGroup_args -> LBS.ByteString
encode_CreateGroup_args oprot record = T.serializeVal oprot $ from_CreateGroup_args record
to_CreateGroup_args :: T.ThriftVal -> CreateGroup_args
to_CreateGroup_args (T.TStruct fields) = CreateGroup_args{
  createGroup_args_seq = P.maybe (createGroup_args_seq default_CreateGroup_args) (\(_,_val6370) -> (case _val6370 of {T.TI32 _val6371 -> _val6371; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createGroup_args_name = P.maybe (createGroup_args_name default_CreateGroup_args) (\(_,_val6370) -> (case _val6370 of {T.TString _val6372 -> E.decodeUtf8 _val6372; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createGroup_args_contactIds = P.maybe (createGroup_args_contactIds default_CreateGroup_args) (\(_,_val6370) -> (case _val6370 of {T.TList _ _val6373 -> (Vector.fromList $ P.map (\_v6374 -> (case _v6374 of {T.TString _val6375 -> E.decodeUtf8 _val6375; _ -> P.error "wrong type"})) _val6373); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateGroup_args _ = P.error "not a struct"
read_CreateGroup_args :: T.Protocol p => p -> P.IO CreateGroup_args
read_CreateGroup_args iprot = to_CreateGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateGroup_args)
decode_CreateGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateGroup_args
decode_CreateGroup_args iprot bs = to_CreateGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateGroup_args) bs
typemap_CreateGroup_args :: T.TypeMap
typemap_CreateGroup_args = Map.fromList [(1,("seq",T.T_I32)),(2,("name",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateGroup_args :: CreateGroup_args
default_CreateGroup_args = CreateGroup_args{
  createGroup_args_seq = 0,
  createGroup_args_name = "",
  createGroup_args_contactIds = Vector.empty}
data CreateGroup_result = CreateGroup_result  { createGroup_result_success :: Group
  , createGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createGroup_result_success record   `H.hashWithSalt` createGroup_result_e record  
instance QC.Arbitrary CreateGroup_result where 
  arbitrary = M.liftM CreateGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateGroup_result{createGroup_result_success = createGroup_result_success obj} then P.Nothing else P.Just $ default_CreateGroup_result{createGroup_result_success = createGroup_result_success obj}
    , if obj == default_CreateGroup_result{createGroup_result_e = createGroup_result_e obj} then P.Nothing else P.Just $ default_CreateGroup_result{createGroup_result_e = createGroup_result_e obj}
    ]
from_CreateGroup_result :: CreateGroup_result -> T.ThriftVal
from_CreateGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6378 -> (1, ("e",from_TalkException _v6378))) <$> createGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6378 -> P.Just (0, ("success",from_Group _v6378))) $ createGroup_result_success record
    , (\_v6378 -> (1, ("e",from_TalkException _v6378))) <$> createGroup_result_e record
    ]
    )
write_CreateGroup_result :: T.Protocol p => p -> CreateGroup_result -> P.IO ()
write_CreateGroup_result oprot record = T.writeVal oprot $ from_CreateGroup_result record
encode_CreateGroup_result :: T.StatelessProtocol p => p -> CreateGroup_result -> LBS.ByteString
encode_CreateGroup_result oprot record = T.serializeVal oprot $ from_CreateGroup_result record
to_CreateGroup_result :: T.ThriftVal -> CreateGroup_result
to_CreateGroup_result (T.TStruct fields) = CreateGroup_result{
  createGroup_result_success = P.maybe (createGroup_result_success default_CreateGroup_result) (\(_,_val6380) -> (case _val6380 of {T.TStruct _val6381 -> (to_Group (T.TStruct _val6381)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createGroup_result_e = P.maybe (P.Nothing) (\(_,_val6380) -> P.Just (case _val6380 of {T.TStruct _val6382 -> (to_TalkException (T.TStruct _val6382)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateGroup_result _ = P.error "not a struct"
read_CreateGroup_result :: T.Protocol p => p -> P.IO CreateGroup_result
read_CreateGroup_result iprot = to_CreateGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateGroup_result)
decode_CreateGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateGroup_result
decode_CreateGroup_result iprot bs = to_CreateGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateGroup_result) bs
typemap_CreateGroup_result :: T.TypeMap
typemap_CreateGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateGroup_result :: CreateGroup_result
default_CreateGroup_result = CreateGroup_result{
  createGroup_result_success = default_Group,
  createGroup_result_e = P.Nothing}
data CreateQrcodeBase64Image_args = CreateQrcodeBase64Image_args  { createQrcodeBase64Image_args_url :: LT.Text
  , createQrcodeBase64Image_args_characterSet :: LT.Text
  , createQrcodeBase64Image_args_imageSize :: I.Int32
  , createQrcodeBase64Image_args_x :: I.Int32
  , createQrcodeBase64Image_args_y :: I.Int32
  , createQrcodeBase64Image_args_width :: I.Int32
  , createQrcodeBase64Image_args_height :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateQrcodeBase64Image_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createQrcodeBase64Image_args_url record   `H.hashWithSalt` createQrcodeBase64Image_args_characterSet record   `H.hashWithSalt` createQrcodeBase64Image_args_imageSize record   `H.hashWithSalt` createQrcodeBase64Image_args_x record   `H.hashWithSalt` createQrcodeBase64Image_args_y record   `H.hashWithSalt` createQrcodeBase64Image_args_width record   `H.hashWithSalt` createQrcodeBase64Image_args_height record  
instance QC.Arbitrary CreateQrcodeBase64Image_args where 
  arbitrary = M.liftM CreateQrcodeBase64Image_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateQrcodeBase64Image_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_url = createQrcodeBase64Image_args_url obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_url = createQrcodeBase64Image_args_url obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_characterSet = createQrcodeBase64Image_args_characterSet obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_characterSet = createQrcodeBase64Image_args_characterSet obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_imageSize = createQrcodeBase64Image_args_imageSize obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_imageSize = createQrcodeBase64Image_args_imageSize obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_x = createQrcodeBase64Image_args_x obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_x = createQrcodeBase64Image_args_x obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_y = createQrcodeBase64Image_args_y obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_y = createQrcodeBase64Image_args_y obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_width = createQrcodeBase64Image_args_width obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_width = createQrcodeBase64Image_args_width obj}
    , if obj == default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_height = createQrcodeBase64Image_args_height obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_args{createQrcodeBase64Image_args_height = createQrcodeBase64Image_args_height obj}
    ]
from_CreateQrcodeBase64Image_args :: CreateQrcodeBase64Image_args -> T.ThriftVal
from_CreateQrcodeBase64Image_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6385 -> P.Just (2, ("url",T.TString $ E.encodeUtf8 _v6385))) $ createQrcodeBase64Image_args_url record
  , (\_v6385 -> P.Just (3, ("characterSet",T.TString $ E.encodeUtf8 _v6385))) $ createQrcodeBase64Image_args_characterSet record
  , (\_v6385 -> P.Just (4, ("imageSize",T.TI32 _v6385))) $ createQrcodeBase64Image_args_imageSize record
  , (\_v6385 -> P.Just (5, ("x",T.TI32 _v6385))) $ createQrcodeBase64Image_args_x record
  , (\_v6385 -> P.Just (6, ("y",T.TI32 _v6385))) $ createQrcodeBase64Image_args_y record
  , (\_v6385 -> P.Just (7, ("width",T.TI32 _v6385))) $ createQrcodeBase64Image_args_width record
  , (\_v6385 -> P.Just (8, ("height",T.TI32 _v6385))) $ createQrcodeBase64Image_args_height record
  ]
write_CreateQrcodeBase64Image_args :: T.Protocol p => p -> CreateQrcodeBase64Image_args -> P.IO ()
write_CreateQrcodeBase64Image_args oprot record = T.writeVal oprot $ from_CreateQrcodeBase64Image_args record
encode_CreateQrcodeBase64Image_args :: T.StatelessProtocol p => p -> CreateQrcodeBase64Image_args -> LBS.ByteString
encode_CreateQrcodeBase64Image_args oprot record = T.serializeVal oprot $ from_CreateQrcodeBase64Image_args record
to_CreateQrcodeBase64Image_args :: T.ThriftVal -> CreateQrcodeBase64Image_args
to_CreateQrcodeBase64Image_args (T.TStruct fields) = CreateQrcodeBase64Image_args{
  createQrcodeBase64Image_args_url = P.maybe (createQrcodeBase64Image_args_url default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TString _val6388 -> E.decodeUtf8 _val6388; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createQrcodeBase64Image_args_characterSet = P.maybe (createQrcodeBase64Image_args_characterSet default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TString _val6389 -> E.decodeUtf8 _val6389; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createQrcodeBase64Image_args_imageSize = P.maybe (createQrcodeBase64Image_args_imageSize default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TI32 _val6390 -> _val6390; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  createQrcodeBase64Image_args_x = P.maybe (createQrcodeBase64Image_args_x default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TI32 _val6391 -> _val6391; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  createQrcodeBase64Image_args_y = P.maybe (createQrcodeBase64Image_args_y default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TI32 _val6392 -> _val6392; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  createQrcodeBase64Image_args_width = P.maybe (createQrcodeBase64Image_args_width default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TI32 _val6393 -> _val6393; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  createQrcodeBase64Image_args_height = P.maybe (createQrcodeBase64Image_args_height default_CreateQrcodeBase64Image_args) (\(_,_val6387) -> (case _val6387 of {T.TI32 _val6394 -> _val6394; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_CreateQrcodeBase64Image_args _ = P.error "not a struct"
read_CreateQrcodeBase64Image_args :: T.Protocol p => p -> P.IO CreateQrcodeBase64Image_args
read_CreateQrcodeBase64Image_args iprot = to_CreateQrcodeBase64Image_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_args)
decode_CreateQrcodeBase64Image_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateQrcodeBase64Image_args
decode_CreateQrcodeBase64Image_args iprot bs = to_CreateQrcodeBase64Image_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_args) bs
typemap_CreateQrcodeBase64Image_args :: T.TypeMap
typemap_CreateQrcodeBase64Image_args = Map.fromList [(2,("url",T.T_STRING)),(3,("characterSet",T.T_STRING)),(4,("imageSize",T.T_I32)),(5,("x",T.T_I32)),(6,("y",T.T_I32)),(7,("width",T.T_I32)),(8,("height",T.T_I32))]
default_CreateQrcodeBase64Image_args :: CreateQrcodeBase64Image_args
default_CreateQrcodeBase64Image_args = CreateQrcodeBase64Image_args{
  createQrcodeBase64Image_args_url = "",
  createQrcodeBase64Image_args_characterSet = "",
  createQrcodeBase64Image_args_imageSize = 0,
  createQrcodeBase64Image_args_x = 0,
  createQrcodeBase64Image_args_y = 0,
  createQrcodeBase64Image_args_width = 0,
  createQrcodeBase64Image_args_height = 0}
data CreateQrcodeBase64Image_result = CreateQrcodeBase64Image_result  { createQrcodeBase64Image_result_success :: LT.Text
  , createQrcodeBase64Image_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateQrcodeBase64Image_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createQrcodeBase64Image_result_success record   `H.hashWithSalt` createQrcodeBase64Image_result_e record  
instance QC.Arbitrary CreateQrcodeBase64Image_result where 
  arbitrary = M.liftM CreateQrcodeBase64Image_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateQrcodeBase64Image_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = createQrcodeBase64Image_result_success obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = createQrcodeBase64Image_result_success obj}
    , if obj == default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = createQrcodeBase64Image_result_e obj} then P.Nothing else P.Just $ default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = createQrcodeBase64Image_result_e obj}
    ]
from_CreateQrcodeBase64Image_result :: CreateQrcodeBase64Image_result -> T.ThriftVal
from_CreateQrcodeBase64Image_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6397 -> (1, ("e",from_TalkException _v6397))) <$> createQrcodeBase64Image_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6397 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6397))) $ createQrcodeBase64Image_result_success record
    , (\_v6397 -> (1, ("e",from_TalkException _v6397))) <$> createQrcodeBase64Image_result_e record
    ]
    )
write_CreateQrcodeBase64Image_result :: T.Protocol p => p -> CreateQrcodeBase64Image_result -> P.IO ()
write_CreateQrcodeBase64Image_result oprot record = T.writeVal oprot $ from_CreateQrcodeBase64Image_result record
encode_CreateQrcodeBase64Image_result :: T.StatelessProtocol p => p -> CreateQrcodeBase64Image_result -> LBS.ByteString
encode_CreateQrcodeBase64Image_result oprot record = T.serializeVal oprot $ from_CreateQrcodeBase64Image_result record
to_CreateQrcodeBase64Image_result :: T.ThriftVal -> CreateQrcodeBase64Image_result
to_CreateQrcodeBase64Image_result (T.TStruct fields) = CreateQrcodeBase64Image_result{
  createQrcodeBase64Image_result_success = P.maybe (createQrcodeBase64Image_result_success default_CreateQrcodeBase64Image_result) (\(_,_val6399) -> (case _val6399 of {T.TString _val6400 -> E.decodeUtf8 _val6400; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createQrcodeBase64Image_result_e = P.maybe (P.Nothing) (\(_,_val6399) -> P.Just (case _val6399 of {T.TStruct _val6401 -> (to_TalkException (T.TStruct _val6401)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateQrcodeBase64Image_result _ = P.error "not a struct"
read_CreateQrcodeBase64Image_result :: T.Protocol p => p -> P.IO CreateQrcodeBase64Image_result
read_CreateQrcodeBase64Image_result iprot = to_CreateQrcodeBase64Image_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_result)
decode_CreateQrcodeBase64Image_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateQrcodeBase64Image_result
decode_CreateQrcodeBase64Image_result iprot bs = to_CreateQrcodeBase64Image_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateQrcodeBase64Image_result) bs
typemap_CreateQrcodeBase64Image_result :: T.TypeMap
typemap_CreateQrcodeBase64Image_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateQrcodeBase64Image_result :: CreateQrcodeBase64Image_result
default_CreateQrcodeBase64Image_result = CreateQrcodeBase64Image_result{
  createQrcodeBase64Image_result_success = "",
  createQrcodeBase64Image_result_e = P.Nothing}
data CreateRoom_args = CreateRoom_args  { createRoom_args_reqSeq :: I.Int32
  , createRoom_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoom_args_reqSeq record   `H.hashWithSalt` createRoom_args_contactIds record  
instance QC.Arbitrary CreateRoom_args where 
  arbitrary = M.liftM CreateRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoom_args{createRoom_args_reqSeq = createRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateRoom_args{createRoom_args_reqSeq = createRoom_args_reqSeq obj}
    , if obj == default_CreateRoom_args{createRoom_args_contactIds = createRoom_args_contactIds obj} then P.Nothing else P.Just $ default_CreateRoom_args{createRoom_args_contactIds = createRoom_args_contactIds obj}
    ]
from_CreateRoom_args :: CreateRoom_args -> T.ThriftVal
from_CreateRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6404 -> P.Just (1, ("reqSeq",T.TI32 _v6404))) $ createRoom_args_reqSeq record
  , (\_v6404 -> P.Just (2, ("contactIds",T.TList T.T_STRING $ P.map (\_v6406 -> T.TString $ E.encodeUtf8 _v6406) $ Vector.toList _v6404))) $ createRoom_args_contactIds record
  ]
write_CreateRoom_args :: T.Protocol p => p -> CreateRoom_args -> P.IO ()
write_CreateRoom_args oprot record = T.writeVal oprot $ from_CreateRoom_args record
encode_CreateRoom_args :: T.StatelessProtocol p => p -> CreateRoom_args -> LBS.ByteString
encode_CreateRoom_args oprot record = T.serializeVal oprot $ from_CreateRoom_args record
to_CreateRoom_args :: T.ThriftVal -> CreateRoom_args
to_CreateRoom_args (T.TStruct fields) = CreateRoom_args{
  createRoom_args_reqSeq = P.maybe (createRoom_args_reqSeq default_CreateRoom_args) (\(_,_val6408) -> (case _val6408 of {T.TI32 _val6409 -> _val6409; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createRoom_args_contactIds = P.maybe (createRoom_args_contactIds default_CreateRoom_args) (\(_,_val6408) -> (case _val6408 of {T.TList _ _val6410 -> (Vector.fromList $ P.map (\_v6411 -> (case _v6411 of {T.TString _val6412 -> E.decodeUtf8 _val6412; _ -> P.error "wrong type"})) _val6410); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateRoom_args _ = P.error "not a struct"
read_CreateRoom_args :: T.Protocol p => p -> P.IO CreateRoom_args
read_CreateRoom_args iprot = to_CreateRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoom_args)
decode_CreateRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoom_args
decode_CreateRoom_args iprot bs = to_CreateRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoom_args) bs
typemap_CreateRoom_args :: T.TypeMap
typemap_CreateRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateRoom_args :: CreateRoom_args
default_CreateRoom_args = CreateRoom_args{
  createRoom_args_reqSeq = 0,
  createRoom_args_contactIds = Vector.empty}
data CreateRoom_result = CreateRoom_result  { createRoom_result_success :: Room
  , createRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoom_result_success record   `H.hashWithSalt` createRoom_result_e record  
instance QC.Arbitrary CreateRoom_result where 
  arbitrary = M.liftM CreateRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoom_result{createRoom_result_success = createRoom_result_success obj} then P.Nothing else P.Just $ default_CreateRoom_result{createRoom_result_success = createRoom_result_success obj}
    , if obj == default_CreateRoom_result{createRoom_result_e = createRoom_result_e obj} then P.Nothing else P.Just $ default_CreateRoom_result{createRoom_result_e = createRoom_result_e obj}
    ]
from_CreateRoom_result :: CreateRoom_result -> T.ThriftVal
from_CreateRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6415 -> (1, ("e",from_TalkException _v6415))) <$> createRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6415 -> P.Just (0, ("success",from_Room _v6415))) $ createRoom_result_success record
    , (\_v6415 -> (1, ("e",from_TalkException _v6415))) <$> createRoom_result_e record
    ]
    )
write_CreateRoom_result :: T.Protocol p => p -> CreateRoom_result -> P.IO ()
write_CreateRoom_result oprot record = T.writeVal oprot $ from_CreateRoom_result record
encode_CreateRoom_result :: T.StatelessProtocol p => p -> CreateRoom_result -> LBS.ByteString
encode_CreateRoom_result oprot record = T.serializeVal oprot $ from_CreateRoom_result record
to_CreateRoom_result :: T.ThriftVal -> CreateRoom_result
to_CreateRoom_result (T.TStruct fields) = CreateRoom_result{
  createRoom_result_success = P.maybe (createRoom_result_success default_CreateRoom_result) (\(_,_val6417) -> (case _val6417 of {T.TStruct _val6418 -> (to_Room (T.TStruct _val6418)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createRoom_result_e = P.maybe (P.Nothing) (\(_,_val6417) -> P.Just (case _val6417 of {T.TStruct _val6419 -> (to_TalkException (T.TStruct _val6419)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateRoom_result _ = P.error "not a struct"
read_CreateRoom_result :: T.Protocol p => p -> P.IO CreateRoom_result
read_CreateRoom_result iprot = to_CreateRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoom_result)
decode_CreateRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoom_result
decode_CreateRoom_result iprot bs = to_CreateRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoom_result) bs
typemap_CreateRoom_result :: T.TypeMap
typemap_CreateRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateRoom_result :: CreateRoom_result
default_CreateRoom_result = CreateRoom_result{
  createRoom_result_success = default_Room,
  createRoom_result_e = P.Nothing}
data CreateSession_args = CreateSession_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSession_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary CreateSession_args where 
  arbitrary = QC.elements [CreateSession_args]
from_CreateSession_args :: CreateSession_args -> T.ThriftVal
from_CreateSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_CreateSession_args :: T.Protocol p => p -> CreateSession_args -> P.IO ()
write_CreateSession_args oprot record = T.writeVal oprot $ from_CreateSession_args record
encode_CreateSession_args :: T.StatelessProtocol p => p -> CreateSession_args -> LBS.ByteString
encode_CreateSession_args oprot record = T.serializeVal oprot $ from_CreateSession_args record
to_CreateSession_args :: T.ThriftVal -> CreateSession_args
to_CreateSession_args (T.TStruct fields) = CreateSession_args{

  }
to_CreateSession_args _ = P.error "not a struct"
read_CreateSession_args :: T.Protocol p => p -> P.IO CreateSession_args
read_CreateSession_args iprot = to_CreateSession_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSession_args)
decode_CreateSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSession_args
decode_CreateSession_args iprot bs = to_CreateSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSession_args) bs
typemap_CreateSession_args :: T.TypeMap
typemap_CreateSession_args = Map.fromList []
default_CreateSession_args :: CreateSession_args
default_CreateSession_args = CreateSession_args{
}
data CreateSession_result = CreateSession_result  { createSession_result_success :: LT.Text
  , createSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSession_result_success record   `H.hashWithSalt` createSession_result_e record  
instance QC.Arbitrary CreateSession_result where 
  arbitrary = M.liftM CreateSession_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSession_result{createSession_result_success = createSession_result_success obj} then P.Nothing else P.Just $ default_CreateSession_result{createSession_result_success = createSession_result_success obj}
    , if obj == default_CreateSession_result{createSession_result_e = createSession_result_e obj} then P.Nothing else P.Just $ default_CreateSession_result{createSession_result_e = createSession_result_e obj}
    ]
from_CreateSession_result :: CreateSession_result -> T.ThriftVal
from_CreateSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6427 -> (1, ("e",from_TalkException _v6427))) <$> createSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6427 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6427))) $ createSession_result_success record
    , (\_v6427 -> (1, ("e",from_TalkException _v6427))) <$> createSession_result_e record
    ]
    )
write_CreateSession_result :: T.Protocol p => p -> CreateSession_result -> P.IO ()
write_CreateSession_result oprot record = T.writeVal oprot $ from_CreateSession_result record
encode_CreateSession_result :: T.StatelessProtocol p => p -> CreateSession_result -> LBS.ByteString
encode_CreateSession_result oprot record = T.serializeVal oprot $ from_CreateSession_result record
to_CreateSession_result :: T.ThriftVal -> CreateSession_result
to_CreateSession_result (T.TStruct fields) = CreateSession_result{
  createSession_result_success = P.maybe (createSession_result_success default_CreateSession_result) (\(_,_val6429) -> (case _val6429 of {T.TString _val6430 -> E.decodeUtf8 _val6430; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSession_result_e = P.maybe (P.Nothing) (\(_,_val6429) -> P.Just (case _val6429 of {T.TStruct _val6431 -> (to_TalkException (T.TStruct _val6431)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateSession_result _ = P.error "not a struct"
read_CreateSession_result :: T.Protocol p => p -> P.IO CreateSession_result
read_CreateSession_result iprot = to_CreateSession_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSession_result)
decode_CreateSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSession_result
decode_CreateSession_result iprot bs = to_CreateSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSession_result) bs
typemap_CreateSession_result :: T.TypeMap
typemap_CreateSession_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateSession_result :: CreateSession_result
default_CreateSession_result = CreateSession_result{
  createSession_result_success = "",
  createSession_result_e = P.Nothing}
data FetchAnnouncements_args = FetchAnnouncements_args  { fetchAnnouncements_args_lastFetchedIndex :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchAnnouncements_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchAnnouncements_args_lastFetchedIndex record  
instance QC.Arbitrary FetchAnnouncements_args where 
  arbitrary = M.liftM FetchAnnouncements_args (QC.arbitrary)
  shrink obj | obj == default_FetchAnnouncements_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchAnnouncements_args{fetchAnnouncements_args_lastFetchedIndex = fetchAnnouncements_args_lastFetchedIndex obj} then P.Nothing else P.Just $ default_FetchAnnouncements_args{fetchAnnouncements_args_lastFetchedIndex = fetchAnnouncements_args_lastFetchedIndex obj}
    ]
from_FetchAnnouncements_args :: FetchAnnouncements_args -> T.ThriftVal
from_FetchAnnouncements_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6434 -> P.Just (2, ("lastFetchedIndex",T.TI32 _v6434))) $ fetchAnnouncements_args_lastFetchedIndex record
  ]
write_FetchAnnouncements_args :: T.Protocol p => p -> FetchAnnouncements_args -> P.IO ()
write_FetchAnnouncements_args oprot record = T.writeVal oprot $ from_FetchAnnouncements_args record
encode_FetchAnnouncements_args :: T.StatelessProtocol p => p -> FetchAnnouncements_args -> LBS.ByteString
encode_FetchAnnouncements_args oprot record = T.serializeVal oprot $ from_FetchAnnouncements_args record
to_FetchAnnouncements_args :: T.ThriftVal -> FetchAnnouncements_args
to_FetchAnnouncements_args (T.TStruct fields) = FetchAnnouncements_args{
  fetchAnnouncements_args_lastFetchedIndex = P.maybe (fetchAnnouncements_args_lastFetchedIndex default_FetchAnnouncements_args) (\(_,_val6436) -> (case _val6436 of {T.TI32 _val6437 -> _val6437; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FetchAnnouncements_args _ = P.error "not a struct"
read_FetchAnnouncements_args :: T.Protocol p => p -> P.IO FetchAnnouncements_args
read_FetchAnnouncements_args iprot = to_FetchAnnouncements_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchAnnouncements_args)
decode_FetchAnnouncements_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchAnnouncements_args
decode_FetchAnnouncements_args iprot bs = to_FetchAnnouncements_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchAnnouncements_args) bs
typemap_FetchAnnouncements_args :: T.TypeMap
typemap_FetchAnnouncements_args = Map.fromList [(2,("lastFetchedIndex",T.T_I32))]
default_FetchAnnouncements_args :: FetchAnnouncements_args
default_FetchAnnouncements_args = FetchAnnouncements_args{
  fetchAnnouncements_args_lastFetchedIndex = 0}
data FetchAnnouncements_result = FetchAnnouncements_result  { fetchAnnouncements_result_success :: (Vector.Vector Announcement)
  , fetchAnnouncements_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchAnnouncements_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchAnnouncements_result_success record   `H.hashWithSalt` fetchAnnouncements_result_e record  
instance QC.Arbitrary FetchAnnouncements_result where 
  arbitrary = M.liftM FetchAnnouncements_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchAnnouncements_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchAnnouncements_result{fetchAnnouncements_result_success = fetchAnnouncements_result_success obj} then P.Nothing else P.Just $ default_FetchAnnouncements_result{fetchAnnouncements_result_success = fetchAnnouncements_result_success obj}
    , if obj == default_FetchAnnouncements_result{fetchAnnouncements_result_e = fetchAnnouncements_result_e obj} then P.Nothing else P.Just $ default_FetchAnnouncements_result{fetchAnnouncements_result_e = fetchAnnouncements_result_e obj}
    ]
from_FetchAnnouncements_result :: FetchAnnouncements_result -> T.ThriftVal
from_FetchAnnouncements_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6440 -> (1, ("e",from_TalkException _v6440))) <$> fetchAnnouncements_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6440 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Announcement) $ P.map (\_v6442 -> from_Announcement _v6442) $ Vector.toList _v6440))) $ fetchAnnouncements_result_success record
    , (\_v6440 -> (1, ("e",from_TalkException _v6440))) <$> fetchAnnouncements_result_e record
    ]
    )
write_FetchAnnouncements_result :: T.Protocol p => p -> FetchAnnouncements_result -> P.IO ()
write_FetchAnnouncements_result oprot record = T.writeVal oprot $ from_FetchAnnouncements_result record
encode_FetchAnnouncements_result :: T.StatelessProtocol p => p -> FetchAnnouncements_result -> LBS.ByteString
encode_FetchAnnouncements_result oprot record = T.serializeVal oprot $ from_FetchAnnouncements_result record
to_FetchAnnouncements_result :: T.ThriftVal -> FetchAnnouncements_result
to_FetchAnnouncements_result (T.TStruct fields) = FetchAnnouncements_result{
  fetchAnnouncements_result_success = P.maybe (fetchAnnouncements_result_success default_FetchAnnouncements_result) (\(_,_val6444) -> (case _val6444 of {T.TList _ _val6445 -> (Vector.fromList $ P.map (\_v6446 -> (case _v6446 of {T.TStruct _val6447 -> (to_Announcement (T.TStruct _val6447)); _ -> P.error "wrong type"})) _val6445); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchAnnouncements_result_e = P.maybe (P.Nothing) (\(_,_val6444) -> P.Just (case _val6444 of {T.TStruct _val6448 -> (to_TalkException (T.TStruct _val6448)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchAnnouncements_result _ = P.error "not a struct"
read_FetchAnnouncements_result :: T.Protocol p => p -> P.IO FetchAnnouncements_result
read_FetchAnnouncements_result iprot = to_FetchAnnouncements_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchAnnouncements_result)
decode_FetchAnnouncements_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchAnnouncements_result
decode_FetchAnnouncements_result iprot bs = to_FetchAnnouncements_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchAnnouncements_result) bs
typemap_FetchAnnouncements_result :: T.TypeMap
typemap_FetchAnnouncements_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Announcement)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchAnnouncements_result :: FetchAnnouncements_result
default_FetchAnnouncements_result = FetchAnnouncements_result{
  fetchAnnouncements_result_success = Vector.empty,
  fetchAnnouncements_result_e = P.Nothing}
data FetchMessages_args = FetchMessages_args  { fetchMessages_args_localTs :: I.Int64
  , fetchMessages_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessages_args_localTs record   `H.hashWithSalt` fetchMessages_args_count record  
instance QC.Arbitrary FetchMessages_args where 
  arbitrary = M.liftM FetchMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessages_args{fetchMessages_args_localTs = fetchMessages_args_localTs obj} then P.Nothing else P.Just $ default_FetchMessages_args{fetchMessages_args_localTs = fetchMessages_args_localTs obj}
    , if obj == default_FetchMessages_args{fetchMessages_args_count = fetchMessages_args_count obj} then P.Nothing else P.Just $ default_FetchMessages_args{fetchMessages_args_count = fetchMessages_args_count obj}
    ]
from_FetchMessages_args :: FetchMessages_args -> T.ThriftVal
from_FetchMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6451 -> P.Just (2, ("localTs",T.TI64 _v6451))) $ fetchMessages_args_localTs record
  , (\_v6451 -> P.Just (3, ("count",T.TI32 _v6451))) $ fetchMessages_args_count record
  ]
write_FetchMessages_args :: T.Protocol p => p -> FetchMessages_args -> P.IO ()
write_FetchMessages_args oprot record = T.writeVal oprot $ from_FetchMessages_args record
encode_FetchMessages_args :: T.StatelessProtocol p => p -> FetchMessages_args -> LBS.ByteString
encode_FetchMessages_args oprot record = T.serializeVal oprot $ from_FetchMessages_args record
to_FetchMessages_args :: T.ThriftVal -> FetchMessages_args
to_FetchMessages_args (T.TStruct fields) = FetchMessages_args{
  fetchMessages_args_localTs = P.maybe (fetchMessages_args_localTs default_FetchMessages_args) (\(_,_val6453) -> (case _val6453 of {T.TI64 _val6454 -> _val6454; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchMessages_args_count = P.maybe (fetchMessages_args_count default_FetchMessages_args) (\(_,_val6453) -> (case _val6453 of {T.TI32 _val6455 -> _val6455; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FetchMessages_args _ = P.error "not a struct"
read_FetchMessages_args :: T.Protocol p => p -> P.IO FetchMessages_args
read_FetchMessages_args iprot = to_FetchMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessages_args)
decode_FetchMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessages_args
decode_FetchMessages_args iprot bs = to_FetchMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessages_args) bs
typemap_FetchMessages_args :: T.TypeMap
typemap_FetchMessages_args = Map.fromList [(2,("localTs",T.T_I64)),(3,("count",T.T_I32))]
default_FetchMessages_args :: FetchMessages_args
default_FetchMessages_args = FetchMessages_args{
  fetchMessages_args_localTs = 0,
  fetchMessages_args_count = 0}
data FetchMessages_result = FetchMessages_result  { fetchMessages_result_success :: (Vector.Vector Message)
  , fetchMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchMessages_result_success record   `H.hashWithSalt` fetchMessages_result_e record  
instance QC.Arbitrary FetchMessages_result where 
  arbitrary = M.liftM FetchMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchMessages_result{fetchMessages_result_success = fetchMessages_result_success obj} then P.Nothing else P.Just $ default_FetchMessages_result{fetchMessages_result_success = fetchMessages_result_success obj}
    , if obj == default_FetchMessages_result{fetchMessages_result_e = fetchMessages_result_e obj} then P.Nothing else P.Just $ default_FetchMessages_result{fetchMessages_result_e = fetchMessages_result_e obj}
    ]
from_FetchMessages_result :: FetchMessages_result -> T.ThriftVal
from_FetchMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6458 -> (1, ("e",from_TalkException _v6458))) <$> fetchMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6458 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v6460 -> from_Message _v6460) $ Vector.toList _v6458))) $ fetchMessages_result_success record
    , (\_v6458 -> (1, ("e",from_TalkException _v6458))) <$> fetchMessages_result_e record
    ]
    )
write_FetchMessages_result :: T.Protocol p => p -> FetchMessages_result -> P.IO ()
write_FetchMessages_result oprot record = T.writeVal oprot $ from_FetchMessages_result record
encode_FetchMessages_result :: T.StatelessProtocol p => p -> FetchMessages_result -> LBS.ByteString
encode_FetchMessages_result oprot record = T.serializeVal oprot $ from_FetchMessages_result record
to_FetchMessages_result :: T.ThriftVal -> FetchMessages_result
to_FetchMessages_result (T.TStruct fields) = FetchMessages_result{
  fetchMessages_result_success = P.maybe (fetchMessages_result_success default_FetchMessages_result) (\(_,_val6462) -> (case _val6462 of {T.TList _ _val6463 -> (Vector.fromList $ P.map (\_v6464 -> (case _v6464 of {T.TStruct _val6465 -> (to_Message (T.TStruct _val6465)); _ -> P.error "wrong type"})) _val6463); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchMessages_result_e = P.maybe (P.Nothing) (\(_,_val6462) -> P.Just (case _val6462 of {T.TStruct _val6466 -> (to_TalkException (T.TStruct _val6466)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchMessages_result _ = P.error "not a struct"
read_FetchMessages_result :: T.Protocol p => p -> P.IO FetchMessages_result
read_FetchMessages_result iprot = to_FetchMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchMessages_result)
decode_FetchMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchMessages_result
decode_FetchMessages_result iprot bs = to_FetchMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchMessages_result) bs
typemap_FetchMessages_result :: T.TypeMap
typemap_FetchMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FetchMessages_result :: FetchMessages_result
default_FetchMessages_result = FetchMessages_result{
  fetchMessages_result_success = Vector.empty,
  fetchMessages_result_e = P.Nothing}
data FetchOperations_args = FetchOperations_args  { fetchOperations_args_localRev :: I.Int64
  , fetchOperations_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOperations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOperations_args_localRev record   `H.hashWithSalt` fetchOperations_args_count record  
instance QC.Arbitrary FetchOperations_args where 
  arbitrary = M.liftM FetchOperations_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchOperations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOperations_args{fetchOperations_args_localRev = fetchOperations_args_localRev obj} then P.Nothing else P.Just $ default_FetchOperations_args{fetchOperations_args_localRev = fetchOperations_args_localRev obj}
    , if obj == default_FetchOperations_args{fetchOperations_args_count = fetchOperations_args_count obj} then P.Nothing else P.Just $ default_FetchOperations_args{fetchOperations_args_count = fetchOperations_args_count obj}
    ]
from_FetchOperations_args :: FetchOperations_args -> T.ThriftVal
from_FetchOperations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6469 -> P.Just (2, ("localRev",T.TI64 _v6469))) $ fetchOperations_args_localRev record
  , (\_v6469 -> P.Just (3, ("count",T.TI32 _v6469))) $ fetchOperations_args_count record
  ]
write_FetchOperations_args :: T.Protocol p => p -> FetchOperations_args -> P.IO ()
write_FetchOperations_args oprot record = T.writeVal oprot $ from_FetchOperations_args record
encode_FetchOperations_args :: T.StatelessProtocol p => p -> FetchOperations_args -> LBS.ByteString
encode_FetchOperations_args oprot record = T.serializeVal oprot $ from_FetchOperations_args record
to_FetchOperations_args :: T.ThriftVal -> FetchOperations_args
to_FetchOperations_args (T.TStruct fields) = FetchOperations_args{
  fetchOperations_args_localRev = P.maybe (fetchOperations_args_localRev default_FetchOperations_args) (\(_,_val6471) -> (case _val6471 of {T.TI64 _val6472 -> _val6472; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchOperations_args_count = P.maybe (fetchOperations_args_count default_FetchOperations_args) (\(_,_val6471) -> (case _val6471 of {T.TI32 _val6473 -> _val6473; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FetchOperations_args _ = P.error "not a struct"
read_FetchOperations_args :: T.Protocol p => p -> P.IO FetchOperations_args
read_FetchOperations_args iprot = to_FetchOperations_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchOperations_args)
decode_FetchOperations_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOperations_args
decode_FetchOperations_args iprot bs = to_FetchOperations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOperations_args) bs
typemap_FetchOperations_args :: T.TypeMap
typemap_FetchOperations_args = Map.fromList [(2,("localRev",T.T_I64)),(3,("count",T.T_I32))]
default_FetchOperations_args :: FetchOperations_args
default_FetchOperations_args = FetchOperations_args{
  fetchOperations_args_localRev = 0,
  fetchOperations_args_count = 0}
data FetchOperations_result = FetchOperations_result  { fetchOperations_result_success :: (Vector.Vector Operation)
  , fetchOperations_result_e :: P.Maybe ShouldSyncException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOperations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOperations_result_success record   `H.hashWithSalt` fetchOperations_result_e record  
instance QC.Arbitrary FetchOperations_result where 
  arbitrary = M.liftM FetchOperations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchOperations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOperations_result{fetchOperations_result_success = fetchOperations_result_success obj} then P.Nothing else P.Just $ default_FetchOperations_result{fetchOperations_result_success = fetchOperations_result_success obj}
    , if obj == default_FetchOperations_result{fetchOperations_result_e = fetchOperations_result_e obj} then P.Nothing else P.Just $ default_FetchOperations_result{fetchOperations_result_e = fetchOperations_result_e obj}
    ]
from_FetchOperations_result :: FetchOperations_result -> T.ThriftVal
from_FetchOperations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6476 -> (1, ("e",from_ShouldSyncException _v6476))) <$> fetchOperations_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6476 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Operation) $ P.map (\_v6478 -> from_Operation _v6478) $ Vector.toList _v6476))) $ fetchOperations_result_success record
    , (\_v6476 -> (1, ("e",from_ShouldSyncException _v6476))) <$> fetchOperations_result_e record
    ]
    )
write_FetchOperations_result :: T.Protocol p => p -> FetchOperations_result -> P.IO ()
write_FetchOperations_result oprot record = T.writeVal oprot $ from_FetchOperations_result record
encode_FetchOperations_result :: T.StatelessProtocol p => p -> FetchOperations_result -> LBS.ByteString
encode_FetchOperations_result oprot record = T.serializeVal oprot $ from_FetchOperations_result record
to_FetchOperations_result :: T.ThriftVal -> FetchOperations_result
to_FetchOperations_result (T.TStruct fields) = FetchOperations_result{
  fetchOperations_result_success = P.maybe (fetchOperations_result_success default_FetchOperations_result) (\(_,_val6480) -> (case _val6480 of {T.TList _ _val6481 -> (Vector.fromList $ P.map (\_v6482 -> (case _v6482 of {T.TStruct _val6483 -> (to_Operation (T.TStruct _val6483)); _ -> P.error "wrong type"})) _val6481); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchOperations_result_e = P.maybe (P.Nothing) (\(_,_val6480) -> P.Just (case _val6480 of {T.TStruct _val6484 -> (to_ShouldSyncException (T.TStruct _val6484)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchOperations_result _ = P.error "not a struct"
read_FetchOperations_result :: T.Protocol p => p -> P.IO FetchOperations_result
read_FetchOperations_result iprot = to_FetchOperations_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchOperations_result)
decode_FetchOperations_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOperations_result
decode_FetchOperations_result iprot bs = to_FetchOperations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOperations_result) bs
typemap_FetchOperations_result :: T.TypeMap
typemap_FetchOperations_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Operation)))),(1,("e",(T.T_STRUCT typemap_ShouldSyncException)))]
default_FetchOperations_result :: FetchOperations_result
default_FetchOperations_result = FetchOperations_result{
  fetchOperations_result_success = Vector.empty,
  fetchOperations_result_e = P.Nothing}
data FetchOps_args = FetchOps_args  { fetchOps_args_localRev :: I.Int64
  , fetchOps_args_count :: I.Int32
  , fetchOps_args_globalRev :: I.Int64
  , fetchOps_args_individualRev :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOps_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOps_args_localRev record   `H.hashWithSalt` fetchOps_args_count record   `H.hashWithSalt` fetchOps_args_globalRev record   `H.hashWithSalt` fetchOps_args_individualRev record  
instance QC.Arbitrary FetchOps_args where 
  arbitrary = M.liftM FetchOps_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FetchOps_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOps_args{fetchOps_args_localRev = fetchOps_args_localRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_localRev = fetchOps_args_localRev obj}
    , if obj == default_FetchOps_args{fetchOps_args_count = fetchOps_args_count obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_count = fetchOps_args_count obj}
    , if obj == default_FetchOps_args{fetchOps_args_globalRev = fetchOps_args_globalRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_globalRev = fetchOps_args_globalRev obj}
    , if obj == default_FetchOps_args{fetchOps_args_individualRev = fetchOps_args_individualRev obj} then P.Nothing else P.Just $ default_FetchOps_args{fetchOps_args_individualRev = fetchOps_args_individualRev obj}
    ]
from_FetchOps_args :: FetchOps_args -> T.ThriftVal
from_FetchOps_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6487 -> P.Just (2, ("localRev",T.TI64 _v6487))) $ fetchOps_args_localRev record
  , (\_v6487 -> P.Just (3, ("count",T.TI32 _v6487))) $ fetchOps_args_count record
  , (\_v6487 -> P.Just (4, ("globalRev",T.TI64 _v6487))) $ fetchOps_args_globalRev record
  , (\_v6487 -> P.Just (5, ("individualRev",T.TI64 _v6487))) $ fetchOps_args_individualRev record
  ]
write_FetchOps_args :: T.Protocol p => p -> FetchOps_args -> P.IO ()
write_FetchOps_args oprot record = T.writeVal oprot $ from_FetchOps_args record
encode_FetchOps_args :: T.StatelessProtocol p => p -> FetchOps_args -> LBS.ByteString
encode_FetchOps_args oprot record = T.serializeVal oprot $ from_FetchOps_args record
to_FetchOps_args :: T.ThriftVal -> FetchOps_args
to_FetchOps_args (T.TStruct fields) = FetchOps_args{
  fetchOps_args_localRev = P.maybe (fetchOps_args_localRev default_FetchOps_args) (\(_,_val6489) -> (case _val6489 of {T.TI64 _val6490 -> _val6490; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  fetchOps_args_count = P.maybe (fetchOps_args_count default_FetchOps_args) (\(_,_val6489) -> (case _val6489 of {T.TI32 _val6491 -> _val6491; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  fetchOps_args_globalRev = P.maybe (fetchOps_args_globalRev default_FetchOps_args) (\(_,_val6489) -> (case _val6489 of {T.TI64 _val6492 -> _val6492; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  fetchOps_args_individualRev = P.maybe (fetchOps_args_individualRev default_FetchOps_args) (\(_,_val6489) -> (case _val6489 of {T.TI64 _val6493 -> _val6493; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_FetchOps_args _ = P.error "not a struct"
read_FetchOps_args :: T.Protocol p => p -> P.IO FetchOps_args
read_FetchOps_args iprot = to_FetchOps_args <$> T.readVal iprot (T.T_STRUCT typemap_FetchOps_args)
decode_FetchOps_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOps_args
decode_FetchOps_args iprot bs = to_FetchOps_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOps_args) bs
typemap_FetchOps_args :: T.TypeMap
typemap_FetchOps_args = Map.fromList [(2,("localRev",T.T_I64)),(3,("count",T.T_I32)),(4,("globalRev",T.T_I64)),(5,("individualRev",T.T_I64))]
default_FetchOps_args :: FetchOps_args
default_FetchOps_args = FetchOps_args{
  fetchOps_args_localRev = 0,
  fetchOps_args_count = 0,
  fetchOps_args_globalRev = 0,
  fetchOps_args_individualRev = 0}
data FetchOps_result = FetchOps_result  { fetchOps_result_success :: (Vector.Vector Operation)
  , fetchOps_result_e :: P.Maybe ShouldSyncException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FetchOps_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` fetchOps_result_success record   `H.hashWithSalt` fetchOps_result_e record  
instance QC.Arbitrary FetchOps_result where 
  arbitrary = M.liftM FetchOps_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FetchOps_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FetchOps_result{fetchOps_result_success = fetchOps_result_success obj} then P.Nothing else P.Just $ default_FetchOps_result{fetchOps_result_success = fetchOps_result_success obj}
    , if obj == default_FetchOps_result{fetchOps_result_e = fetchOps_result_e obj} then P.Nothing else P.Just $ default_FetchOps_result{fetchOps_result_e = fetchOps_result_e obj}
    ]
from_FetchOps_result :: FetchOps_result -> T.ThriftVal
from_FetchOps_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6496 -> (1, ("e",from_ShouldSyncException _v6496))) <$> fetchOps_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6496 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Operation) $ P.map (\_v6498 -> from_Operation _v6498) $ Vector.toList _v6496))) $ fetchOps_result_success record
    , (\_v6496 -> (1, ("e",from_ShouldSyncException _v6496))) <$> fetchOps_result_e record
    ]
    )
write_FetchOps_result :: T.Protocol p => p -> FetchOps_result -> P.IO ()
write_FetchOps_result oprot record = T.writeVal oprot $ from_FetchOps_result record
encode_FetchOps_result :: T.StatelessProtocol p => p -> FetchOps_result -> LBS.ByteString
encode_FetchOps_result oprot record = T.serializeVal oprot $ from_FetchOps_result record
to_FetchOps_result :: T.ThriftVal -> FetchOps_result
to_FetchOps_result (T.TStruct fields) = FetchOps_result{
  fetchOps_result_success = P.maybe (fetchOps_result_success default_FetchOps_result) (\(_,_val6500) -> (case _val6500 of {T.TList _ _val6501 -> (Vector.fromList $ P.map (\_v6502 -> (case _v6502 of {T.TStruct _val6503 -> (to_Operation (T.TStruct _val6503)); _ -> P.error "wrong type"})) _val6501); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  fetchOps_result_e = P.maybe (P.Nothing) (\(_,_val6500) -> P.Just (case _val6500 of {T.TStruct _val6504 -> (to_ShouldSyncException (T.TStruct _val6504)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FetchOps_result _ = P.error "not a struct"
read_FetchOps_result :: T.Protocol p => p -> P.IO FetchOps_result
read_FetchOps_result iprot = to_FetchOps_result <$> T.readVal iprot (T.T_STRUCT typemap_FetchOps_result)
decode_FetchOps_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FetchOps_result
decode_FetchOps_result iprot bs = to_FetchOps_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FetchOps_result) bs
typemap_FetchOps_result :: T.TypeMap
typemap_FetchOps_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Operation)))),(1,("e",(T.T_STRUCT typemap_ShouldSyncException)))]
default_FetchOps_result :: FetchOps_result
default_FetchOps_result = FetchOps_result{
  fetchOps_result_success = Vector.empty,
  fetchOps_result_e = P.Nothing}
data FindAndAddContactsByEmail_args = FindAndAddContactsByEmail_args  { findAndAddContactsByEmail_args_reqSeq :: I.Int32
  , findAndAddContactsByEmail_args_emails :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByEmail_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByEmail_args_emails record  
instance QC.Arbitrary FindAndAddContactsByEmail_args where 
  arbitrary = M.liftM FindAndAddContactsByEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_reqSeq = findAndAddContactsByEmail_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_reqSeq = findAndAddContactsByEmail_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_emails = findAndAddContactsByEmail_args_emails obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_args{findAndAddContactsByEmail_args_emails = findAndAddContactsByEmail_args_emails obj}
    ]
from_FindAndAddContactsByEmail_args :: FindAndAddContactsByEmail_args -> T.ThriftVal
from_FindAndAddContactsByEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6507 -> P.Just (1, ("reqSeq",T.TI32 _v6507))) $ findAndAddContactsByEmail_args_reqSeq record
  , (\_v6507 -> P.Just (2, ("emails",T.TSet T.T_STRING $ P.map (\_v6509 -> T.TString $ E.encodeUtf8 _v6509) $ Set.toList _v6507))) $ findAndAddContactsByEmail_args_emails record
  ]
write_FindAndAddContactsByEmail_args :: T.Protocol p => p -> FindAndAddContactsByEmail_args -> P.IO ()
write_FindAndAddContactsByEmail_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByEmail_args record
encode_FindAndAddContactsByEmail_args :: T.StatelessProtocol p => p -> FindAndAddContactsByEmail_args -> LBS.ByteString
encode_FindAndAddContactsByEmail_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByEmail_args record
to_FindAndAddContactsByEmail_args :: T.ThriftVal -> FindAndAddContactsByEmail_args
to_FindAndAddContactsByEmail_args (T.TStruct fields) = FindAndAddContactsByEmail_args{
  findAndAddContactsByEmail_args_reqSeq = P.maybe (findAndAddContactsByEmail_args_reqSeq default_FindAndAddContactsByEmail_args) (\(_,_val6511) -> (case _val6511 of {T.TI32 _val6512 -> _val6512; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByEmail_args_emails = P.maybe (findAndAddContactsByEmail_args_emails default_FindAndAddContactsByEmail_args) (\(_,_val6511) -> (case _val6511 of {T.TSet _ _val6513 -> (Set.fromList $ P.map (\_v6514 -> (case _v6514 of {T.TString _val6515 -> E.decodeUtf8 _val6515; _ -> P.error "wrong type"})) _val6513); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByEmail_args _ = P.error "not a struct"
read_FindAndAddContactsByEmail_args :: T.Protocol p => p -> P.IO FindAndAddContactsByEmail_args
read_FindAndAddContactsByEmail_args iprot = to_FindAndAddContactsByEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_args)
decode_FindAndAddContactsByEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByEmail_args
decode_FindAndAddContactsByEmail_args iprot bs = to_FindAndAddContactsByEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_args) bs
typemap_FindAndAddContactsByEmail_args :: T.TypeMap
typemap_FindAndAddContactsByEmail_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("emails",(T.T_SET T.T_STRING)))]
default_FindAndAddContactsByEmail_args :: FindAndAddContactsByEmail_args
default_FindAndAddContactsByEmail_args = FindAndAddContactsByEmail_args{
  findAndAddContactsByEmail_args_reqSeq = 0,
  findAndAddContactsByEmail_args_emails = Set.empty}
data FindAndAddContactsByEmail_result = FindAndAddContactsByEmail_result  { findAndAddContactsByEmail_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByEmail_result_success record   `H.hashWithSalt` findAndAddContactsByEmail_result_e record  
instance QC.Arbitrary FindAndAddContactsByEmail_result where 
  arbitrary = M.liftM FindAndAddContactsByEmail_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = findAndAddContactsByEmail_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = findAndAddContactsByEmail_result_success obj}
    , if obj == default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = findAndAddContactsByEmail_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = findAndAddContactsByEmail_result_e obj}
    ]
from_FindAndAddContactsByEmail_result :: FindAndAddContactsByEmail_result -> T.ThriftVal
from_FindAndAddContactsByEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6518 -> (1, ("e",from_TalkException _v6518))) <$> findAndAddContactsByEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6518 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6519,_v6520) -> (T.TString $ E.encodeUtf8 _k6519, from_Contact _v6520)) $ Map.toList _v6518))) $ findAndAddContactsByEmail_result_success record
    , (\_v6518 -> (1, ("e",from_TalkException _v6518))) <$> findAndAddContactsByEmail_result_e record
    ]
    )
write_FindAndAddContactsByEmail_result :: T.Protocol p => p -> FindAndAddContactsByEmail_result -> P.IO ()
write_FindAndAddContactsByEmail_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByEmail_result record
encode_FindAndAddContactsByEmail_result :: T.StatelessProtocol p => p -> FindAndAddContactsByEmail_result -> LBS.ByteString
encode_FindAndAddContactsByEmail_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByEmail_result record
to_FindAndAddContactsByEmail_result :: T.ThriftVal -> FindAndAddContactsByEmail_result
to_FindAndAddContactsByEmail_result (T.TStruct fields) = FindAndAddContactsByEmail_result{
  findAndAddContactsByEmail_result_success = P.maybe (findAndAddContactsByEmail_result_success default_FindAndAddContactsByEmail_result) (\(_,_val6522) -> (case _val6522 of {T.TMap _ _ _val6523 -> (Map.fromList $ P.map (\(_k6525,_v6524) -> ((case _k6525 of {T.TString _val6526 -> E.decodeUtf8 _val6526; _ -> P.error "wrong type"}),(case _v6524 of {T.TStruct _val6527 -> (to_Contact (T.TStruct _val6527)); _ -> P.error "wrong type"}))) _val6523); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByEmail_result_e = P.maybe (P.Nothing) (\(_,_val6522) -> P.Just (case _val6522 of {T.TStruct _val6528 -> (to_TalkException (T.TStruct _val6528)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByEmail_result _ = P.error "not a struct"
read_FindAndAddContactsByEmail_result :: T.Protocol p => p -> P.IO FindAndAddContactsByEmail_result
read_FindAndAddContactsByEmail_result iprot = to_FindAndAddContactsByEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_result)
decode_FindAndAddContactsByEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByEmail_result
decode_FindAndAddContactsByEmail_result iprot bs = to_FindAndAddContactsByEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByEmail_result) bs
typemap_FindAndAddContactsByEmail_result :: T.TypeMap
typemap_FindAndAddContactsByEmail_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByEmail_result :: FindAndAddContactsByEmail_result
default_FindAndAddContactsByEmail_result = FindAndAddContactsByEmail_result{
  findAndAddContactsByEmail_result_success = Map.empty,
  findAndAddContactsByEmail_result_e = P.Nothing}
data FindAndAddContactsByMid_args = FindAndAddContactsByMid_args  { findAndAddContactsByMid_args_reqSeq :: I.Int32
  , findAndAddContactsByMid_args_mid :: LT.Text
  , findAndAddContactsByMid_args_type :: ContactType
  , findAndAddContactsByMid_args_reference :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByMid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByMid_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByMid_args_mid record   `H.hashWithSalt` findAndAddContactsByMid_args_type record   `H.hashWithSalt` findAndAddContactsByMid_args_reference record  
instance QC.Arbitrary FindAndAddContactsByMid_args where 
  arbitrary = M.liftM FindAndAddContactsByMid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByMid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reqSeq = findAndAddContactsByMid_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reqSeq = findAndAddContactsByMid_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_mid = findAndAddContactsByMid_args_mid obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_mid = findAndAddContactsByMid_args_mid obj}
    , if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_type = findAndAddContactsByMid_args_type obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_type = findAndAddContactsByMid_args_type obj}
    , if obj == default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reference = findAndAddContactsByMid_args_reference obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_args{findAndAddContactsByMid_args_reference = findAndAddContactsByMid_args_reference obj}
    ]
from_FindAndAddContactsByMid_args :: FindAndAddContactsByMid_args -> T.ThriftVal
from_FindAndAddContactsByMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6531 -> P.Just (1, ("reqSeq",T.TI32 _v6531))) $ findAndAddContactsByMid_args_reqSeq record
  , (\_v6531 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v6531))) $ findAndAddContactsByMid_args_mid record
  , (\_v6531 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v6531))) $ findAndAddContactsByMid_args_type record
  , (\_v6531 -> P.Just (4, ("reference",T.TString $ E.encodeUtf8 _v6531))) $ findAndAddContactsByMid_args_reference record
  ]
write_FindAndAddContactsByMid_args :: T.Protocol p => p -> FindAndAddContactsByMid_args -> P.IO ()
write_FindAndAddContactsByMid_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByMid_args record
encode_FindAndAddContactsByMid_args :: T.StatelessProtocol p => p -> FindAndAddContactsByMid_args -> LBS.ByteString
encode_FindAndAddContactsByMid_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByMid_args record
to_FindAndAddContactsByMid_args :: T.ThriftVal -> FindAndAddContactsByMid_args
to_FindAndAddContactsByMid_args (T.TStruct fields) = FindAndAddContactsByMid_args{
  findAndAddContactsByMid_args_reqSeq = P.maybe (findAndAddContactsByMid_args_reqSeq default_FindAndAddContactsByMid_args) (\(_,_val6533) -> (case _val6533 of {T.TI32 _val6534 -> _val6534; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByMid_args_mid = P.maybe (findAndAddContactsByMid_args_mid default_FindAndAddContactsByMid_args) (\(_,_val6533) -> (case _val6533 of {T.TString _val6535 -> E.decodeUtf8 _val6535; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findAndAddContactsByMid_args_type = P.maybe (findAndAddContactsByMid_args_type default_FindAndAddContactsByMid_args) (\(_,_val6533) -> (case _val6533 of {T.TI32 _val6536 -> P.toEnum $ P.fromIntegral _val6536; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  findAndAddContactsByMid_args_reference = P.maybe (findAndAddContactsByMid_args_reference default_FindAndAddContactsByMid_args) (\(_,_val6533) -> (case _val6533 of {T.TString _val6537 -> E.decodeUtf8 _val6537; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FindAndAddContactsByMid_args _ = P.error "not a struct"
read_FindAndAddContactsByMid_args :: T.Protocol p => p -> P.IO FindAndAddContactsByMid_args
read_FindAndAddContactsByMid_args iprot = to_FindAndAddContactsByMid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_args)
decode_FindAndAddContactsByMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByMid_args
decode_FindAndAddContactsByMid_args iprot bs = to_FindAndAddContactsByMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_args) bs
typemap_FindAndAddContactsByMid_args :: T.TypeMap
typemap_FindAndAddContactsByMid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("mid",T.T_STRING)),(3,("type",T.T_I32)),(4,("reference",T.T_STRING))]
default_FindAndAddContactsByMid_args :: FindAndAddContactsByMid_args
default_FindAndAddContactsByMid_args = FindAndAddContactsByMid_args{
  findAndAddContactsByMid_args_reqSeq = 0,
  findAndAddContactsByMid_args_mid = "",
  findAndAddContactsByMid_args_type = (P.toEnum 0),
  findAndAddContactsByMid_args_reference = ""}
data FindAndAddContactsByMid_result = FindAndAddContactsByMid_result  { findAndAddContactsByMid_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByMid_result_success record   `H.hashWithSalt` findAndAddContactsByMid_result_e record  
instance QC.Arbitrary FindAndAddContactsByMid_result where 
  arbitrary = M.liftM FindAndAddContactsByMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = findAndAddContactsByMid_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = findAndAddContactsByMid_result_success obj}
    , if obj == default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = findAndAddContactsByMid_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = findAndAddContactsByMid_result_e obj}
    ]
from_FindAndAddContactsByMid_result :: FindAndAddContactsByMid_result -> T.ThriftVal
from_FindAndAddContactsByMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6540 -> (1, ("e",from_TalkException _v6540))) <$> findAndAddContactsByMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6540 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6541,_v6542) -> (T.TString $ E.encodeUtf8 _k6541, from_Contact _v6542)) $ Map.toList _v6540))) $ findAndAddContactsByMid_result_success record
    , (\_v6540 -> (1, ("e",from_TalkException _v6540))) <$> findAndAddContactsByMid_result_e record
    ]
    )
write_FindAndAddContactsByMid_result :: T.Protocol p => p -> FindAndAddContactsByMid_result -> P.IO ()
write_FindAndAddContactsByMid_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByMid_result record
encode_FindAndAddContactsByMid_result :: T.StatelessProtocol p => p -> FindAndAddContactsByMid_result -> LBS.ByteString
encode_FindAndAddContactsByMid_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByMid_result record
to_FindAndAddContactsByMid_result :: T.ThriftVal -> FindAndAddContactsByMid_result
to_FindAndAddContactsByMid_result (T.TStruct fields) = FindAndAddContactsByMid_result{
  findAndAddContactsByMid_result_success = P.maybe (findAndAddContactsByMid_result_success default_FindAndAddContactsByMid_result) (\(_,_val6544) -> (case _val6544 of {T.TMap _ _ _val6545 -> (Map.fromList $ P.map (\(_k6547,_v6546) -> ((case _k6547 of {T.TString _val6548 -> E.decodeUtf8 _val6548; _ -> P.error "wrong type"}),(case _v6546 of {T.TStruct _val6549 -> (to_Contact (T.TStruct _val6549)); _ -> P.error "wrong type"}))) _val6545); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByMid_result_e = P.maybe (P.Nothing) (\(_,_val6544) -> P.Just (case _val6544 of {T.TStruct _val6550 -> (to_TalkException (T.TStruct _val6550)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByMid_result _ = P.error "not a struct"
read_FindAndAddContactsByMid_result :: T.Protocol p => p -> P.IO FindAndAddContactsByMid_result
read_FindAndAddContactsByMid_result iprot = to_FindAndAddContactsByMid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_result)
decode_FindAndAddContactsByMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByMid_result
decode_FindAndAddContactsByMid_result iprot bs = to_FindAndAddContactsByMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByMid_result) bs
typemap_FindAndAddContactsByMid_result :: T.TypeMap
typemap_FindAndAddContactsByMid_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByMid_result :: FindAndAddContactsByMid_result
default_FindAndAddContactsByMid_result = FindAndAddContactsByMid_result{
  findAndAddContactsByMid_result_success = Map.empty,
  findAndAddContactsByMid_result_e = P.Nothing}
data FindGroupByTicketV2_args = FindGroupByTicketV2_args  { findGroupByTicketV2_args_ticketId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindGroupByTicketV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findGroupByTicketV2_args_ticketId record  
instance QC.Arbitrary FindGroupByTicketV2_args where 
  arbitrary = M.liftM FindGroupByTicketV2_args (QC.arbitrary)
  shrink obj | obj == default_FindGroupByTicketV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindGroupByTicketV2_args{findGroupByTicketV2_args_ticketId = findGroupByTicketV2_args_ticketId obj} then P.Nothing else P.Just $ default_FindGroupByTicketV2_args{findGroupByTicketV2_args_ticketId = findGroupByTicketV2_args_ticketId obj}
    ]
from_FindGroupByTicketV2_args :: FindGroupByTicketV2_args -> T.ThriftVal
from_FindGroupByTicketV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6553 -> P.Just (1, ("ticketId",T.TString $ E.encodeUtf8 _v6553))) $ findGroupByTicketV2_args_ticketId record
  ]
write_FindGroupByTicketV2_args :: T.Protocol p => p -> FindGroupByTicketV2_args -> P.IO ()
write_FindGroupByTicketV2_args oprot record = T.writeVal oprot $ from_FindGroupByTicketV2_args record
encode_FindGroupByTicketV2_args :: T.StatelessProtocol p => p -> FindGroupByTicketV2_args -> LBS.ByteString
encode_FindGroupByTicketV2_args oprot record = T.serializeVal oprot $ from_FindGroupByTicketV2_args record
to_FindGroupByTicketV2_args :: T.ThriftVal -> FindGroupByTicketV2_args
to_FindGroupByTicketV2_args (T.TStruct fields) = FindGroupByTicketV2_args{
  findGroupByTicketV2_args_ticketId = P.maybe (findGroupByTicketV2_args_ticketId default_FindGroupByTicketV2_args) (\(_,_val6555) -> (case _val6555 of {T.TString _val6556 -> E.decodeUtf8 _val6556; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindGroupByTicketV2_args _ = P.error "not a struct"
read_FindGroupByTicketV2_args :: T.Protocol p => p -> P.IO FindGroupByTicketV2_args
read_FindGroupByTicketV2_args iprot = to_FindGroupByTicketV2_args <$> T.readVal iprot (T.T_STRUCT typemap_FindGroupByTicketV2_args)
decode_FindGroupByTicketV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindGroupByTicketV2_args
decode_FindGroupByTicketV2_args iprot bs = to_FindGroupByTicketV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindGroupByTicketV2_args) bs
typemap_FindGroupByTicketV2_args :: T.TypeMap
typemap_FindGroupByTicketV2_args = Map.fromList [(1,("ticketId",T.T_STRING))]
default_FindGroupByTicketV2_args :: FindGroupByTicketV2_args
default_FindGroupByTicketV2_args = FindGroupByTicketV2_args{
  findGroupByTicketV2_args_ticketId = ""}
data FindGroupByTicketV2_result = FindGroupByTicketV2_result  { findGroupByTicketV2_result_success :: Group
  , findGroupByTicketV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindGroupByTicketV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findGroupByTicketV2_result_success record   `H.hashWithSalt` findGroupByTicketV2_result_e record  
instance QC.Arbitrary FindGroupByTicketV2_result where 
  arbitrary = M.liftM FindGroupByTicketV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindGroupByTicketV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindGroupByTicketV2_result{findGroupByTicketV2_result_success = findGroupByTicketV2_result_success obj} then P.Nothing else P.Just $ default_FindGroupByTicketV2_result{findGroupByTicketV2_result_success = findGroupByTicketV2_result_success obj}
    , if obj == default_FindGroupByTicketV2_result{findGroupByTicketV2_result_e = findGroupByTicketV2_result_e obj} then P.Nothing else P.Just $ default_FindGroupByTicketV2_result{findGroupByTicketV2_result_e = findGroupByTicketV2_result_e obj}
    ]
from_FindGroupByTicketV2_result :: FindGroupByTicketV2_result -> T.ThriftVal
from_FindGroupByTicketV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6559 -> (1, ("e",from_TalkException _v6559))) <$> findGroupByTicketV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6559 -> P.Just (0, ("success",from_Group _v6559))) $ findGroupByTicketV2_result_success record
    , (\_v6559 -> (1, ("e",from_TalkException _v6559))) <$> findGroupByTicketV2_result_e record
    ]
    )
write_FindGroupByTicketV2_result :: T.Protocol p => p -> FindGroupByTicketV2_result -> P.IO ()
write_FindGroupByTicketV2_result oprot record = T.writeVal oprot $ from_FindGroupByTicketV2_result record
encode_FindGroupByTicketV2_result :: T.StatelessProtocol p => p -> FindGroupByTicketV2_result -> LBS.ByteString
encode_FindGroupByTicketV2_result oprot record = T.serializeVal oprot $ from_FindGroupByTicketV2_result record
to_FindGroupByTicketV2_result :: T.ThriftVal -> FindGroupByTicketV2_result
to_FindGroupByTicketV2_result (T.TStruct fields) = FindGroupByTicketV2_result{
  findGroupByTicketV2_result_success = P.maybe (findGroupByTicketV2_result_success default_FindGroupByTicketV2_result) (\(_,_val6561) -> (case _val6561 of {T.TStruct _val6562 -> (to_Group (T.TStruct _val6562)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findGroupByTicketV2_result_e = P.maybe (P.Nothing) (\(_,_val6561) -> P.Just (case _val6561 of {T.TStruct _val6563 -> (to_TalkException (T.TStruct _val6563)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindGroupByTicketV2_result _ = P.error "not a struct"
read_FindGroupByTicketV2_result :: T.Protocol p => p -> P.IO FindGroupByTicketV2_result
read_FindGroupByTicketV2_result iprot = to_FindGroupByTicketV2_result <$> T.readVal iprot (T.T_STRUCT typemap_FindGroupByTicketV2_result)
decode_FindGroupByTicketV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindGroupByTicketV2_result
decode_FindGroupByTicketV2_result iprot bs = to_FindGroupByTicketV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindGroupByTicketV2_result) bs
typemap_FindGroupByTicketV2_result :: T.TypeMap
typemap_FindGroupByTicketV2_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindGroupByTicketV2_result :: FindGroupByTicketV2_result
default_FindGroupByTicketV2_result = FindGroupByTicketV2_result{
  findGroupByTicketV2_result_success = default_Group,
  findGroupByTicketV2_result_e = P.Nothing}
data FindAndAddContactsByPhone_args = FindAndAddContactsByPhone_args  { findAndAddContactsByPhone_args_reqSeq :: I.Int32
  , findAndAddContactsByPhone_args_phones :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByPhone_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByPhone_args_phones record  
instance QC.Arbitrary FindAndAddContactsByPhone_args where 
  arbitrary = M.liftM FindAndAddContactsByPhone_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_reqSeq = findAndAddContactsByPhone_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_reqSeq = findAndAddContactsByPhone_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_phones = findAndAddContactsByPhone_args_phones obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_args{findAndAddContactsByPhone_args_phones = findAndAddContactsByPhone_args_phones obj}
    ]
from_FindAndAddContactsByPhone_args :: FindAndAddContactsByPhone_args -> T.ThriftVal
from_FindAndAddContactsByPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6566 -> P.Just (1, ("reqSeq",T.TI32 _v6566))) $ findAndAddContactsByPhone_args_reqSeq record
  , (\_v6566 -> P.Just (2, ("phones",T.TSet T.T_STRING $ P.map (\_v6568 -> T.TString $ E.encodeUtf8 _v6568) $ Set.toList _v6566))) $ findAndAddContactsByPhone_args_phones record
  ]
write_FindAndAddContactsByPhone_args :: T.Protocol p => p -> FindAndAddContactsByPhone_args -> P.IO ()
write_FindAndAddContactsByPhone_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByPhone_args record
encode_FindAndAddContactsByPhone_args :: T.StatelessProtocol p => p -> FindAndAddContactsByPhone_args -> LBS.ByteString
encode_FindAndAddContactsByPhone_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByPhone_args record
to_FindAndAddContactsByPhone_args :: T.ThriftVal -> FindAndAddContactsByPhone_args
to_FindAndAddContactsByPhone_args (T.TStruct fields) = FindAndAddContactsByPhone_args{
  findAndAddContactsByPhone_args_reqSeq = P.maybe (findAndAddContactsByPhone_args_reqSeq default_FindAndAddContactsByPhone_args) (\(_,_val6570) -> (case _val6570 of {T.TI32 _val6571 -> _val6571; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByPhone_args_phones = P.maybe (findAndAddContactsByPhone_args_phones default_FindAndAddContactsByPhone_args) (\(_,_val6570) -> (case _val6570 of {T.TSet _ _val6572 -> (Set.fromList $ P.map (\_v6573 -> (case _v6573 of {T.TString _val6574 -> E.decodeUtf8 _val6574; _ -> P.error "wrong type"})) _val6572); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByPhone_args _ = P.error "not a struct"
read_FindAndAddContactsByPhone_args :: T.Protocol p => p -> P.IO FindAndAddContactsByPhone_args
read_FindAndAddContactsByPhone_args iprot = to_FindAndAddContactsByPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_args)
decode_FindAndAddContactsByPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByPhone_args
decode_FindAndAddContactsByPhone_args iprot bs = to_FindAndAddContactsByPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_args) bs
typemap_FindAndAddContactsByPhone_args :: T.TypeMap
typemap_FindAndAddContactsByPhone_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("phones",(T.T_SET T.T_STRING)))]
default_FindAndAddContactsByPhone_args :: FindAndAddContactsByPhone_args
default_FindAndAddContactsByPhone_args = FindAndAddContactsByPhone_args{
  findAndAddContactsByPhone_args_reqSeq = 0,
  findAndAddContactsByPhone_args_phones = Set.empty}
data FindAndAddContactsByPhone_result = FindAndAddContactsByPhone_result  { findAndAddContactsByPhone_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByPhone_result_success record   `H.hashWithSalt` findAndAddContactsByPhone_result_e record  
instance QC.Arbitrary FindAndAddContactsByPhone_result where 
  arbitrary = M.liftM FindAndAddContactsByPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = findAndAddContactsByPhone_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = findAndAddContactsByPhone_result_success obj}
    , if obj == default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = findAndAddContactsByPhone_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = findAndAddContactsByPhone_result_e obj}
    ]
from_FindAndAddContactsByPhone_result :: FindAndAddContactsByPhone_result -> T.ThriftVal
from_FindAndAddContactsByPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6577 -> (1, ("e",from_TalkException _v6577))) <$> findAndAddContactsByPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6577 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6578,_v6579) -> (T.TString $ E.encodeUtf8 _k6578, from_Contact _v6579)) $ Map.toList _v6577))) $ findAndAddContactsByPhone_result_success record
    , (\_v6577 -> (1, ("e",from_TalkException _v6577))) <$> findAndAddContactsByPhone_result_e record
    ]
    )
write_FindAndAddContactsByPhone_result :: T.Protocol p => p -> FindAndAddContactsByPhone_result -> P.IO ()
write_FindAndAddContactsByPhone_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByPhone_result record
encode_FindAndAddContactsByPhone_result :: T.StatelessProtocol p => p -> FindAndAddContactsByPhone_result -> LBS.ByteString
encode_FindAndAddContactsByPhone_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByPhone_result record
to_FindAndAddContactsByPhone_result :: T.ThriftVal -> FindAndAddContactsByPhone_result
to_FindAndAddContactsByPhone_result (T.TStruct fields) = FindAndAddContactsByPhone_result{
  findAndAddContactsByPhone_result_success = P.maybe (findAndAddContactsByPhone_result_success default_FindAndAddContactsByPhone_result) (\(_,_val6581) -> (case _val6581 of {T.TMap _ _ _val6582 -> (Map.fromList $ P.map (\(_k6584,_v6583) -> ((case _k6584 of {T.TString _val6585 -> E.decodeUtf8 _val6585; _ -> P.error "wrong type"}),(case _v6583 of {T.TStruct _val6586 -> (to_Contact (T.TStruct _val6586)); _ -> P.error "wrong type"}))) _val6582); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByPhone_result_e = P.maybe (P.Nothing) (\(_,_val6581) -> P.Just (case _val6581 of {T.TStruct _val6587 -> (to_TalkException (T.TStruct _val6587)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByPhone_result _ = P.error "not a struct"
read_FindAndAddContactsByPhone_result :: T.Protocol p => p -> P.IO FindAndAddContactsByPhone_result
read_FindAndAddContactsByPhone_result iprot = to_FindAndAddContactsByPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_result)
decode_FindAndAddContactsByPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByPhone_result
decode_FindAndAddContactsByPhone_result iprot bs = to_FindAndAddContactsByPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByPhone_result) bs
typemap_FindAndAddContactsByPhone_result :: T.TypeMap
typemap_FindAndAddContactsByPhone_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByPhone_result :: FindAndAddContactsByPhone_result
default_FindAndAddContactsByPhone_result = FindAndAddContactsByPhone_result{
  findAndAddContactsByPhone_result_success = Map.empty,
  findAndAddContactsByPhone_result_e = P.Nothing}
data GetFriendRequests_args = GetFriendRequests_args  { getFriendRequests_args_direction :: FriendRequestDirection
  , getFriendRequests_args_lastSeenSeqId :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendRequests_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendRequests_args_direction record   `H.hashWithSalt` getFriendRequests_args_lastSeenSeqId record  
instance QC.Arbitrary GetFriendRequests_args where 
  arbitrary = M.liftM GetFriendRequests_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetFriendRequests_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendRequests_args{getFriendRequests_args_direction = getFriendRequests_args_direction obj} then P.Nothing else P.Just $ default_GetFriendRequests_args{getFriendRequests_args_direction = getFriendRequests_args_direction obj}
    , if obj == default_GetFriendRequests_args{getFriendRequests_args_lastSeenSeqId = getFriendRequests_args_lastSeenSeqId obj} then P.Nothing else P.Just $ default_GetFriendRequests_args{getFriendRequests_args_lastSeenSeqId = getFriendRequests_args_lastSeenSeqId obj}
    ]
from_GetFriendRequests_args :: GetFriendRequests_args -> T.ThriftVal
from_GetFriendRequests_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6590 -> P.Just (1, ("direction",T.TI32 $ P.fromIntegral $ P.fromEnum _v6590))) $ getFriendRequests_args_direction record
  , (\_v6590 -> P.Just (2, ("lastSeenSeqId",T.TI64 _v6590))) $ getFriendRequests_args_lastSeenSeqId record
  ]
write_GetFriendRequests_args :: T.Protocol p => p -> GetFriendRequests_args -> P.IO ()
write_GetFriendRequests_args oprot record = T.writeVal oprot $ from_GetFriendRequests_args record
encode_GetFriendRequests_args :: T.StatelessProtocol p => p -> GetFriendRequests_args -> LBS.ByteString
encode_GetFriendRequests_args oprot record = T.serializeVal oprot $ from_GetFriendRequests_args record
to_GetFriendRequests_args :: T.ThriftVal -> GetFriendRequests_args
to_GetFriendRequests_args (T.TStruct fields) = GetFriendRequests_args{
  getFriendRequests_args_direction = P.maybe (getFriendRequests_args_direction default_GetFriendRequests_args) (\(_,_val6592) -> (case _val6592 of {T.TI32 _val6593 -> P.toEnum $ P.fromIntegral _val6593; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getFriendRequests_args_lastSeenSeqId = P.maybe (getFriendRequests_args_lastSeenSeqId default_GetFriendRequests_args) (\(_,_val6592) -> (case _val6592 of {T.TI64 _val6594 -> _val6594; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetFriendRequests_args _ = P.error "not a struct"
read_GetFriendRequests_args :: T.Protocol p => p -> P.IO GetFriendRequests_args
read_GetFriendRequests_args iprot = to_GetFriendRequests_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendRequests_args)
decode_GetFriendRequests_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendRequests_args
decode_GetFriendRequests_args iprot bs = to_GetFriendRequests_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendRequests_args) bs
typemap_GetFriendRequests_args :: T.TypeMap
typemap_GetFriendRequests_args = Map.fromList [(1,("direction",T.T_I32)),(2,("lastSeenSeqId",T.T_I64))]
default_GetFriendRequests_args :: GetFriendRequests_args
default_GetFriendRequests_args = GetFriendRequests_args{
  getFriendRequests_args_direction = (P.toEnum 0),
  getFriendRequests_args_lastSeenSeqId = 0}
data GetFriendRequests_result = GetFriendRequests_result  { getFriendRequests_result_success :: (Vector.Vector FriendRequest)
  , getFriendRequests_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendRequests_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendRequests_result_success record   `H.hashWithSalt` getFriendRequests_result_e record  
instance QC.Arbitrary GetFriendRequests_result where 
  arbitrary = M.liftM GetFriendRequests_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendRequests_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendRequests_result{getFriendRequests_result_success = getFriendRequests_result_success obj} then P.Nothing else P.Just $ default_GetFriendRequests_result{getFriendRequests_result_success = getFriendRequests_result_success obj}
    , if obj == default_GetFriendRequests_result{getFriendRequests_result_e = getFriendRequests_result_e obj} then P.Nothing else P.Just $ default_GetFriendRequests_result{getFriendRequests_result_e = getFriendRequests_result_e obj}
    ]
from_GetFriendRequests_result :: GetFriendRequests_result -> T.ThriftVal
from_GetFriendRequests_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6597 -> (1, ("e",from_TalkException _v6597))) <$> getFriendRequests_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6597 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_FriendRequest) $ P.map (\_v6599 -> from_FriendRequest _v6599) $ Vector.toList _v6597))) $ getFriendRequests_result_success record
    , (\_v6597 -> (1, ("e",from_TalkException _v6597))) <$> getFriendRequests_result_e record
    ]
    )
write_GetFriendRequests_result :: T.Protocol p => p -> GetFriendRequests_result -> P.IO ()
write_GetFriendRequests_result oprot record = T.writeVal oprot $ from_GetFriendRequests_result record
encode_GetFriendRequests_result :: T.StatelessProtocol p => p -> GetFriendRequests_result -> LBS.ByteString
encode_GetFriendRequests_result oprot record = T.serializeVal oprot $ from_GetFriendRequests_result record
to_GetFriendRequests_result :: T.ThriftVal -> GetFriendRequests_result
to_GetFriendRequests_result (T.TStruct fields) = GetFriendRequests_result{
  getFriendRequests_result_success = P.maybe (getFriendRequests_result_success default_GetFriendRequests_result) (\(_,_val6601) -> (case _val6601 of {T.TList _ _val6602 -> (Vector.fromList $ P.map (\_v6603 -> (case _v6603 of {T.TStruct _val6604 -> (to_FriendRequest (T.TStruct _val6604)); _ -> P.error "wrong type"})) _val6602); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendRequests_result_e = P.maybe (P.Nothing) (\(_,_val6601) -> P.Just (case _val6601 of {T.TStruct _val6605 -> (to_TalkException (T.TStruct _val6605)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendRequests_result _ = P.error "not a struct"
read_GetFriendRequests_result :: T.Protocol p => p -> P.IO GetFriendRequests_result
read_GetFriendRequests_result iprot = to_GetFriendRequests_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendRequests_result)
decode_GetFriendRequests_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendRequests_result
decode_GetFriendRequests_result iprot bs = to_GetFriendRequests_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendRequests_result) bs
typemap_GetFriendRequests_result :: T.TypeMap
typemap_GetFriendRequests_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_FriendRequest)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFriendRequests_result :: GetFriendRequests_result
default_GetFriendRequests_result = GetFriendRequests_result{
  getFriendRequests_result_success = Vector.empty,
  getFriendRequests_result_e = P.Nothing}
data RemoveFriendRequest_args = RemoveFriendRequest_args  { removeFriendRequest_args_direction :: FriendRequestDirection
  , removeFriendRequest_args_midOrEMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveFriendRequest_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeFriendRequest_args_direction record   `H.hashWithSalt` removeFriendRequest_args_midOrEMid record  
instance QC.Arbitrary RemoveFriendRequest_args where 
  arbitrary = M.liftM RemoveFriendRequest_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveFriendRequest_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveFriendRequest_args{removeFriendRequest_args_direction = removeFriendRequest_args_direction obj} then P.Nothing else P.Just $ default_RemoveFriendRequest_args{removeFriendRequest_args_direction = removeFriendRequest_args_direction obj}
    , if obj == default_RemoveFriendRequest_args{removeFriendRequest_args_midOrEMid = removeFriendRequest_args_midOrEMid obj} then P.Nothing else P.Just $ default_RemoveFriendRequest_args{removeFriendRequest_args_midOrEMid = removeFriendRequest_args_midOrEMid obj}
    ]
from_RemoveFriendRequest_args :: RemoveFriendRequest_args -> T.ThriftVal
from_RemoveFriendRequest_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6608 -> P.Just (1, ("direction",T.TI32 $ P.fromIntegral $ P.fromEnum _v6608))) $ removeFriendRequest_args_direction record
  , (\_v6608 -> P.Just (2, ("midOrEMid",T.TString $ E.encodeUtf8 _v6608))) $ removeFriendRequest_args_midOrEMid record
  ]
write_RemoveFriendRequest_args :: T.Protocol p => p -> RemoveFriendRequest_args -> P.IO ()
write_RemoveFriendRequest_args oprot record = T.writeVal oprot $ from_RemoveFriendRequest_args record
encode_RemoveFriendRequest_args :: T.StatelessProtocol p => p -> RemoveFriendRequest_args -> LBS.ByteString
encode_RemoveFriendRequest_args oprot record = T.serializeVal oprot $ from_RemoveFriendRequest_args record
to_RemoveFriendRequest_args :: T.ThriftVal -> RemoveFriendRequest_args
to_RemoveFriendRequest_args (T.TStruct fields) = RemoveFriendRequest_args{
  removeFriendRequest_args_direction = P.maybe (removeFriendRequest_args_direction default_RemoveFriendRequest_args) (\(_,_val6610) -> (case _val6610 of {T.TI32 _val6611 -> P.toEnum $ P.fromIntegral _val6611; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeFriendRequest_args_midOrEMid = P.maybe (removeFriendRequest_args_midOrEMid default_RemoveFriendRequest_args) (\(_,_val6610) -> (case _val6610 of {T.TString _val6612 -> E.decodeUtf8 _val6612; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveFriendRequest_args _ = P.error "not a struct"
read_RemoveFriendRequest_args :: T.Protocol p => p -> P.IO RemoveFriendRequest_args
read_RemoveFriendRequest_args iprot = to_RemoveFriendRequest_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveFriendRequest_args)
decode_RemoveFriendRequest_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveFriendRequest_args
decode_RemoveFriendRequest_args iprot bs = to_RemoveFriendRequest_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveFriendRequest_args) bs
typemap_RemoveFriendRequest_args :: T.TypeMap
typemap_RemoveFriendRequest_args = Map.fromList [(1,("direction",T.T_I32)),(2,("midOrEMid",T.T_STRING))]
default_RemoveFriendRequest_args :: RemoveFriendRequest_args
default_RemoveFriendRequest_args = RemoveFriendRequest_args{
  removeFriendRequest_args_direction = (P.toEnum 0),
  removeFriendRequest_args_midOrEMid = ""}
data RemoveFriendRequest_result = RemoveFriendRequest_result  { removeFriendRequest_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveFriendRequest_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeFriendRequest_result_e record  
instance QC.Arbitrary RemoveFriendRequest_result where 
  arbitrary = M.liftM RemoveFriendRequest_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveFriendRequest_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveFriendRequest_result{removeFriendRequest_result_e = removeFriendRequest_result_e obj} then P.Nothing else P.Just $ default_RemoveFriendRequest_result{removeFriendRequest_result_e = removeFriendRequest_result_e obj}
    ]
from_RemoveFriendRequest_result :: RemoveFriendRequest_result -> T.ThriftVal
from_RemoveFriendRequest_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6615 -> (1, ("e",from_TalkException _v6615))) <$> removeFriendRequest_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6615 -> (1, ("e",from_TalkException _v6615))) <$> removeFriendRequest_result_e record
    ]
    )
write_RemoveFriendRequest_result :: T.Protocol p => p -> RemoveFriendRequest_result -> P.IO ()
write_RemoveFriendRequest_result oprot record = T.writeVal oprot $ from_RemoveFriendRequest_result record
encode_RemoveFriendRequest_result :: T.StatelessProtocol p => p -> RemoveFriendRequest_result -> LBS.ByteString
encode_RemoveFriendRequest_result oprot record = T.serializeVal oprot $ from_RemoveFriendRequest_result record
to_RemoveFriendRequest_result :: T.ThriftVal -> RemoveFriendRequest_result
to_RemoveFriendRequest_result (T.TStruct fields) = RemoveFriendRequest_result{
  removeFriendRequest_result_e = P.maybe (P.Nothing) (\(_,_val6617) -> P.Just (case _val6617 of {T.TStruct _val6618 -> (to_TalkException (T.TStruct _val6618)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveFriendRequest_result _ = P.error "not a struct"
read_RemoveFriendRequest_result :: T.Protocol p => p -> P.IO RemoveFriendRequest_result
read_RemoveFriendRequest_result iprot = to_RemoveFriendRequest_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveFriendRequest_result)
decode_RemoveFriendRequest_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveFriendRequest_result
decode_RemoveFriendRequest_result iprot bs = to_RemoveFriendRequest_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveFriendRequest_result) bs
typemap_RemoveFriendRequest_result :: T.TypeMap
typemap_RemoveFriendRequest_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveFriendRequest_result :: RemoveFriendRequest_result
default_RemoveFriendRequest_result = RemoveFriendRequest_result{
  removeFriendRequest_result_e = P.Nothing}
data FindAndAddContactsByUserid_args = FindAndAddContactsByUserid_args  { findAndAddContactsByUserid_args_reqSeq :: I.Int32
  , findAndAddContactsByUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByUserid_args_reqSeq record   `H.hashWithSalt` findAndAddContactsByUserid_args_userid record  
instance QC.Arbitrary FindAndAddContactsByUserid_args where 
  arbitrary = M.liftM FindAndAddContactsByUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_reqSeq = findAndAddContactsByUserid_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_reqSeq = findAndAddContactsByUserid_args_reqSeq obj}
    , if obj == default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_userid = findAndAddContactsByUserid_args_userid obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_args{findAndAddContactsByUserid_args_userid = findAndAddContactsByUserid_args_userid obj}
    ]
from_FindAndAddContactsByUserid_args :: FindAndAddContactsByUserid_args -> T.ThriftVal
from_FindAndAddContactsByUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6621 -> P.Just (1, ("reqSeq",T.TI32 _v6621))) $ findAndAddContactsByUserid_args_reqSeq record
  , (\_v6621 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v6621))) $ findAndAddContactsByUserid_args_userid record
  ]
write_FindAndAddContactsByUserid_args :: T.Protocol p => p -> FindAndAddContactsByUserid_args -> P.IO ()
write_FindAndAddContactsByUserid_args oprot record = T.writeVal oprot $ from_FindAndAddContactsByUserid_args record
encode_FindAndAddContactsByUserid_args :: T.StatelessProtocol p => p -> FindAndAddContactsByUserid_args -> LBS.ByteString
encode_FindAndAddContactsByUserid_args oprot record = T.serializeVal oprot $ from_FindAndAddContactsByUserid_args record
to_FindAndAddContactsByUserid_args :: T.ThriftVal -> FindAndAddContactsByUserid_args
to_FindAndAddContactsByUserid_args (T.TStruct fields) = FindAndAddContactsByUserid_args{
  findAndAddContactsByUserid_args_reqSeq = P.maybe (findAndAddContactsByUserid_args_reqSeq default_FindAndAddContactsByUserid_args) (\(_,_val6623) -> (case _val6623 of {T.TI32 _val6624 -> _val6624; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactsByUserid_args_userid = P.maybe (findAndAddContactsByUserid_args_userid default_FindAndAddContactsByUserid_args) (\(_,_val6623) -> (case _val6623 of {T.TString _val6625 -> E.decodeUtf8 _val6625; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindAndAddContactsByUserid_args _ = P.error "not a struct"
read_FindAndAddContactsByUserid_args :: T.Protocol p => p -> P.IO FindAndAddContactsByUserid_args
read_FindAndAddContactsByUserid_args iprot = to_FindAndAddContactsByUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_args)
decode_FindAndAddContactsByUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByUserid_args
decode_FindAndAddContactsByUserid_args iprot bs = to_FindAndAddContactsByUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_args) bs
typemap_FindAndAddContactsByUserid_args :: T.TypeMap
typemap_FindAndAddContactsByUserid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("userid",T.T_STRING))]
default_FindAndAddContactsByUserid_args :: FindAndAddContactsByUserid_args
default_FindAndAddContactsByUserid_args = FindAndAddContactsByUserid_args{
  findAndAddContactsByUserid_args_reqSeq = 0,
  findAndAddContactsByUserid_args_userid = ""}
data FindAndAddContactsByUserid_result = FindAndAddContactsByUserid_result  { findAndAddContactsByUserid_result_success :: (Map.HashMap LT.Text Contact)
  , findAndAddContactsByUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactsByUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactsByUserid_result_success record   `H.hashWithSalt` findAndAddContactsByUserid_result_e record  
instance QC.Arbitrary FindAndAddContactsByUserid_result where 
  arbitrary = M.liftM FindAndAddContactsByUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactsByUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = findAndAddContactsByUserid_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = findAndAddContactsByUserid_result_success obj}
    , if obj == default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = findAndAddContactsByUserid_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = findAndAddContactsByUserid_result_e obj}
    ]
from_FindAndAddContactsByUserid_result :: FindAndAddContactsByUserid_result -> T.ThriftVal
from_FindAndAddContactsByUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6628 -> (1, ("e",from_TalkException _v6628))) <$> findAndAddContactsByUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6628 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6629,_v6630) -> (T.TString $ E.encodeUtf8 _k6629, from_Contact _v6630)) $ Map.toList _v6628))) $ findAndAddContactsByUserid_result_success record
    , (\_v6628 -> (1, ("e",from_TalkException _v6628))) <$> findAndAddContactsByUserid_result_e record
    ]
    )
write_FindAndAddContactsByUserid_result :: T.Protocol p => p -> FindAndAddContactsByUserid_result -> P.IO ()
write_FindAndAddContactsByUserid_result oprot record = T.writeVal oprot $ from_FindAndAddContactsByUserid_result record
encode_FindAndAddContactsByUserid_result :: T.StatelessProtocol p => p -> FindAndAddContactsByUserid_result -> LBS.ByteString
encode_FindAndAddContactsByUserid_result oprot record = T.serializeVal oprot $ from_FindAndAddContactsByUserid_result record
to_FindAndAddContactsByUserid_result :: T.ThriftVal -> FindAndAddContactsByUserid_result
to_FindAndAddContactsByUserid_result (T.TStruct fields) = FindAndAddContactsByUserid_result{
  findAndAddContactsByUserid_result_success = P.maybe (findAndAddContactsByUserid_result_success default_FindAndAddContactsByUserid_result) (\(_,_val6632) -> (case _val6632 of {T.TMap _ _ _val6633 -> (Map.fromList $ P.map (\(_k6635,_v6634) -> ((case _k6635 of {T.TString _val6636 -> E.decodeUtf8 _val6636; _ -> P.error "wrong type"}),(case _v6634 of {T.TStruct _val6637 -> (to_Contact (T.TStruct _val6637)); _ -> P.error "wrong type"}))) _val6633); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactsByUserid_result_e = P.maybe (P.Nothing) (\(_,_val6632) -> P.Just (case _val6632 of {T.TStruct _val6638 -> (to_TalkException (T.TStruct _val6638)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactsByUserid_result _ = P.error "not a struct"
read_FindAndAddContactsByUserid_result :: T.Protocol p => p -> P.IO FindAndAddContactsByUserid_result
read_FindAndAddContactsByUserid_result iprot = to_FindAndAddContactsByUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_result)
decode_FindAndAddContactsByUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactsByUserid_result
decode_FindAndAddContactsByUserid_result iprot bs = to_FindAndAddContactsByUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactsByUserid_result) bs
typemap_FindAndAddContactsByUserid_result :: T.TypeMap
typemap_FindAndAddContactsByUserid_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactsByUserid_result :: FindAndAddContactsByUserid_result
default_FindAndAddContactsByUserid_result = FindAndAddContactsByUserid_result{
  findAndAddContactsByUserid_result_success = Map.empty,
  findAndAddContactsByUserid_result_e = P.Nothing}
data FindContactByUserid_args = FindContactByUserid_args  { findContactByUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserid_args_userid record  
instance QC.Arbitrary FindContactByUserid_args where 
  arbitrary = M.liftM FindContactByUserid_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserid_args{findContactByUserid_args_userid = findContactByUserid_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUserid_args{findContactByUserid_args_userid = findContactByUserid_args_userid obj}
    ]
from_FindContactByUserid_args :: FindContactByUserid_args -> T.ThriftVal
from_FindContactByUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6641 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v6641))) $ findContactByUserid_args_userid record
  ]
write_FindContactByUserid_args :: T.Protocol p => p -> FindContactByUserid_args -> P.IO ()
write_FindContactByUserid_args oprot record = T.writeVal oprot $ from_FindContactByUserid_args record
encode_FindContactByUserid_args :: T.StatelessProtocol p => p -> FindContactByUserid_args -> LBS.ByteString
encode_FindContactByUserid_args oprot record = T.serializeVal oprot $ from_FindContactByUserid_args record
to_FindContactByUserid_args :: T.ThriftVal -> FindContactByUserid_args
to_FindContactByUserid_args (T.TStruct fields) = FindContactByUserid_args{
  findContactByUserid_args_userid = P.maybe (findContactByUserid_args_userid default_FindContactByUserid_args) (\(_,_val6643) -> (case _val6643 of {T.TString _val6644 -> E.decodeUtf8 _val6644; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUserid_args _ = P.error "not a struct"
read_FindContactByUserid_args :: T.Protocol p => p -> P.IO FindContactByUserid_args
read_FindContactByUserid_args iprot = to_FindContactByUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserid_args)
decode_FindContactByUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserid_args
decode_FindContactByUserid_args iprot bs = to_FindContactByUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserid_args) bs
typemap_FindContactByUserid_args :: T.TypeMap
typemap_FindContactByUserid_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUserid_args :: FindContactByUserid_args
default_FindContactByUserid_args = FindContactByUserid_args{
  findContactByUserid_args_userid = ""}
data FindContactByUserid_result = FindContactByUserid_result  { findContactByUserid_result_success :: Contact
  , findContactByUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserid_result_success record   `H.hashWithSalt` findContactByUserid_result_e record  
instance QC.Arbitrary FindContactByUserid_result where 
  arbitrary = M.liftM FindContactByUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserid_result{findContactByUserid_result_success = findContactByUserid_result_success obj} then P.Nothing else P.Just $ default_FindContactByUserid_result{findContactByUserid_result_success = findContactByUserid_result_success obj}
    , if obj == default_FindContactByUserid_result{findContactByUserid_result_e = findContactByUserid_result_e obj} then P.Nothing else P.Just $ default_FindContactByUserid_result{findContactByUserid_result_e = findContactByUserid_result_e obj}
    ]
from_FindContactByUserid_result :: FindContactByUserid_result -> T.ThriftVal
from_FindContactByUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6647 -> (1, ("e",from_TalkException _v6647))) <$> findContactByUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6647 -> P.Just (0, ("success",from_Contact _v6647))) $ findContactByUserid_result_success record
    , (\_v6647 -> (1, ("e",from_TalkException _v6647))) <$> findContactByUserid_result_e record
    ]
    )
write_FindContactByUserid_result :: T.Protocol p => p -> FindContactByUserid_result -> P.IO ()
write_FindContactByUserid_result oprot record = T.writeVal oprot $ from_FindContactByUserid_result record
encode_FindContactByUserid_result :: T.StatelessProtocol p => p -> FindContactByUserid_result -> LBS.ByteString
encode_FindContactByUserid_result oprot record = T.serializeVal oprot $ from_FindContactByUserid_result record
to_FindContactByUserid_result :: T.ThriftVal -> FindContactByUserid_result
to_FindContactByUserid_result (T.TStruct fields) = FindContactByUserid_result{
  findContactByUserid_result_success = P.maybe (findContactByUserid_result_success default_FindContactByUserid_result) (\(_,_val6649) -> (case _val6649 of {T.TStruct _val6650 -> (to_Contact (T.TStruct _val6650)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUserid_result_e = P.maybe (P.Nothing) (\(_,_val6649) -> P.Just (case _val6649 of {T.TStruct _val6651 -> (to_TalkException (T.TStruct _val6651)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUserid_result _ = P.error "not a struct"
read_FindContactByUserid_result :: T.Protocol p => p -> P.IO FindContactByUserid_result
read_FindContactByUserid_result iprot = to_FindContactByUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserid_result)
decode_FindContactByUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserid_result
decode_FindContactByUserid_result iprot bs = to_FindContactByUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserid_result) bs
typemap_FindContactByUserid_result :: T.TypeMap
typemap_FindContactByUserid_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUserid_result :: FindContactByUserid_result
default_FindContactByUserid_result = FindContactByUserid_result{
  findContactByUserid_result_success = default_Contact,
  findContactByUserid_result_e = P.Nothing}
data FindContactByUserTicket_args = FindContactByUserTicket_args  { findContactByUserTicket_args_ticketIdWithTag :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserTicket_args_ticketIdWithTag record  
instance QC.Arbitrary FindContactByUserTicket_args where 
  arbitrary = M.liftM FindContactByUserTicket_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserTicket_args{findContactByUserTicket_args_ticketIdWithTag = findContactByUserTicket_args_ticketIdWithTag obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_args{findContactByUserTicket_args_ticketIdWithTag = findContactByUserTicket_args_ticketIdWithTag obj}
    ]
from_FindContactByUserTicket_args :: FindContactByUserTicket_args -> T.ThriftVal
from_FindContactByUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6654 -> P.Just (2, ("ticketIdWithTag",T.TString $ E.encodeUtf8 _v6654))) $ findContactByUserTicket_args_ticketIdWithTag record
  ]
write_FindContactByUserTicket_args :: T.Protocol p => p -> FindContactByUserTicket_args -> P.IO ()
write_FindContactByUserTicket_args oprot record = T.writeVal oprot $ from_FindContactByUserTicket_args record
encode_FindContactByUserTicket_args :: T.StatelessProtocol p => p -> FindContactByUserTicket_args -> LBS.ByteString
encode_FindContactByUserTicket_args oprot record = T.serializeVal oprot $ from_FindContactByUserTicket_args record
to_FindContactByUserTicket_args :: T.ThriftVal -> FindContactByUserTicket_args
to_FindContactByUserTicket_args (T.TStruct fields) = FindContactByUserTicket_args{
  findContactByUserTicket_args_ticketIdWithTag = P.maybe (findContactByUserTicket_args_ticketIdWithTag default_FindContactByUserTicket_args) (\(_,_val6656) -> (case _val6656 of {T.TString _val6657 -> E.decodeUtf8 _val6657; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUserTicket_args _ = P.error "not a struct"
read_FindContactByUserTicket_args :: T.Protocol p => p -> P.IO FindContactByUserTicket_args
read_FindContactByUserTicket_args iprot = to_FindContactByUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_args)
decode_FindContactByUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserTicket_args
decode_FindContactByUserTicket_args iprot bs = to_FindContactByUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_args) bs
typemap_FindContactByUserTicket_args :: T.TypeMap
typemap_FindContactByUserTicket_args = Map.fromList [(2,("ticketIdWithTag",T.T_STRING))]
default_FindContactByUserTicket_args :: FindContactByUserTicket_args
default_FindContactByUserTicket_args = FindContactByUserTicket_args{
  findContactByUserTicket_args_ticketIdWithTag = ""}
data FindContactByUserTicket_result = FindContactByUserTicket_result  { findContactByUserTicket_result_success :: Contact
  , findContactByUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUserTicket_result_success record   `H.hashWithSalt` findContactByUserTicket_result_e record  
instance QC.Arbitrary FindContactByUserTicket_result where 
  arbitrary = M.liftM FindContactByUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUserTicket_result{findContactByUserTicket_result_success = findContactByUserTicket_result_success obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_result{findContactByUserTicket_result_success = findContactByUserTicket_result_success obj}
    , if obj == default_FindContactByUserTicket_result{findContactByUserTicket_result_e = findContactByUserTicket_result_e obj} then P.Nothing else P.Just $ default_FindContactByUserTicket_result{findContactByUserTicket_result_e = findContactByUserTicket_result_e obj}
    ]
from_FindContactByUserTicket_result :: FindContactByUserTicket_result -> T.ThriftVal
from_FindContactByUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6660 -> (1, ("e",from_TalkException _v6660))) <$> findContactByUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6660 -> P.Just (0, ("success",from_Contact _v6660))) $ findContactByUserTicket_result_success record
    , (\_v6660 -> (1, ("e",from_TalkException _v6660))) <$> findContactByUserTicket_result_e record
    ]
    )
write_FindContactByUserTicket_result :: T.Protocol p => p -> FindContactByUserTicket_result -> P.IO ()
write_FindContactByUserTicket_result oprot record = T.writeVal oprot $ from_FindContactByUserTicket_result record
encode_FindContactByUserTicket_result :: T.StatelessProtocol p => p -> FindContactByUserTicket_result -> LBS.ByteString
encode_FindContactByUserTicket_result oprot record = T.serializeVal oprot $ from_FindContactByUserTicket_result record
to_FindContactByUserTicket_result :: T.ThriftVal -> FindContactByUserTicket_result
to_FindContactByUserTicket_result (T.TStruct fields) = FindContactByUserTicket_result{
  findContactByUserTicket_result_success = P.maybe (findContactByUserTicket_result_success default_FindContactByUserTicket_result) (\(_,_val6662) -> (case _val6662 of {T.TStruct _val6663 -> (to_Contact (T.TStruct _val6663)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val6662) -> P.Just (case _val6662 of {T.TStruct _val6664 -> (to_TalkException (T.TStruct _val6664)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUserTicket_result _ = P.error "not a struct"
read_FindContactByUserTicket_result :: T.Protocol p => p -> P.IO FindContactByUserTicket_result
read_FindContactByUserTicket_result iprot = to_FindContactByUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_result)
decode_FindContactByUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUserTicket_result
decode_FindContactByUserTicket_result iprot bs = to_FindContactByUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUserTicket_result) bs
typemap_FindContactByUserTicket_result :: T.TypeMap
typemap_FindContactByUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUserTicket_result :: FindContactByUserTicket_result
default_FindContactByUserTicket_result = FindContactByUserTicket_result{
  findContactByUserTicket_result_success = default_Contact,
  findContactByUserTicket_result_e = P.Nothing}
data FindContactsByEmail_args = FindContactsByEmail_args  { findContactsByEmail_args_emails :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByEmail_args_emails record  
instance QC.Arbitrary FindContactsByEmail_args where 
  arbitrary = M.liftM FindContactsByEmail_args (QC.arbitrary)
  shrink obj | obj == default_FindContactsByEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByEmail_args{findContactsByEmail_args_emails = findContactsByEmail_args_emails obj} then P.Nothing else P.Just $ default_FindContactsByEmail_args{findContactsByEmail_args_emails = findContactsByEmail_args_emails obj}
    ]
from_FindContactsByEmail_args :: FindContactsByEmail_args -> T.ThriftVal
from_FindContactsByEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6667 -> P.Just (2, ("emails",T.TSet T.T_STRING $ P.map (\_v6669 -> T.TString $ E.encodeUtf8 _v6669) $ Set.toList _v6667))) $ findContactsByEmail_args_emails record
  ]
write_FindContactsByEmail_args :: T.Protocol p => p -> FindContactsByEmail_args -> P.IO ()
write_FindContactsByEmail_args oprot record = T.writeVal oprot $ from_FindContactsByEmail_args record
encode_FindContactsByEmail_args :: T.StatelessProtocol p => p -> FindContactsByEmail_args -> LBS.ByteString
encode_FindContactsByEmail_args oprot record = T.serializeVal oprot $ from_FindContactsByEmail_args record
to_FindContactsByEmail_args :: T.ThriftVal -> FindContactsByEmail_args
to_FindContactsByEmail_args (T.TStruct fields) = FindContactsByEmail_args{
  findContactsByEmail_args_emails = P.maybe (findContactsByEmail_args_emails default_FindContactsByEmail_args) (\(_,_val6671) -> (case _val6671 of {T.TSet _ _val6672 -> (Set.fromList $ P.map (\_v6673 -> (case _v6673 of {T.TString _val6674 -> E.decodeUtf8 _val6674; _ -> P.error "wrong type"})) _val6672); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactsByEmail_args _ = P.error "not a struct"
read_FindContactsByEmail_args :: T.Protocol p => p -> P.IO FindContactsByEmail_args
read_FindContactsByEmail_args iprot = to_FindContactsByEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByEmail_args)
decode_FindContactsByEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByEmail_args
decode_FindContactsByEmail_args iprot bs = to_FindContactsByEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByEmail_args) bs
typemap_FindContactsByEmail_args :: T.TypeMap
typemap_FindContactsByEmail_args = Map.fromList [(2,("emails",(T.T_SET T.T_STRING)))]
default_FindContactsByEmail_args :: FindContactsByEmail_args
default_FindContactsByEmail_args = FindContactsByEmail_args{
  findContactsByEmail_args_emails = Set.empty}
data FindContactsByEmail_result = FindContactsByEmail_result  { findContactsByEmail_result_success :: (Map.HashMap LT.Text Contact)
  , findContactsByEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByEmail_result_success record   `H.hashWithSalt` findContactsByEmail_result_e record  
instance QC.Arbitrary FindContactsByEmail_result where 
  arbitrary = M.liftM FindContactsByEmail_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactsByEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByEmail_result{findContactsByEmail_result_success = findContactsByEmail_result_success obj} then P.Nothing else P.Just $ default_FindContactsByEmail_result{findContactsByEmail_result_success = findContactsByEmail_result_success obj}
    , if obj == default_FindContactsByEmail_result{findContactsByEmail_result_e = findContactsByEmail_result_e obj} then P.Nothing else P.Just $ default_FindContactsByEmail_result{findContactsByEmail_result_e = findContactsByEmail_result_e obj}
    ]
from_FindContactsByEmail_result :: FindContactsByEmail_result -> T.ThriftVal
from_FindContactsByEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6677 -> (1, ("e",from_TalkException _v6677))) <$> findContactsByEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6677 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6678,_v6679) -> (T.TString $ E.encodeUtf8 _k6678, from_Contact _v6679)) $ Map.toList _v6677))) $ findContactsByEmail_result_success record
    , (\_v6677 -> (1, ("e",from_TalkException _v6677))) <$> findContactsByEmail_result_e record
    ]
    )
write_FindContactsByEmail_result :: T.Protocol p => p -> FindContactsByEmail_result -> P.IO ()
write_FindContactsByEmail_result oprot record = T.writeVal oprot $ from_FindContactsByEmail_result record
encode_FindContactsByEmail_result :: T.StatelessProtocol p => p -> FindContactsByEmail_result -> LBS.ByteString
encode_FindContactsByEmail_result oprot record = T.serializeVal oprot $ from_FindContactsByEmail_result record
to_FindContactsByEmail_result :: T.ThriftVal -> FindContactsByEmail_result
to_FindContactsByEmail_result (T.TStruct fields) = FindContactsByEmail_result{
  findContactsByEmail_result_success = P.maybe (findContactsByEmail_result_success default_FindContactsByEmail_result) (\(_,_val6681) -> (case _val6681 of {T.TMap _ _ _val6682 -> (Map.fromList $ P.map (\(_k6684,_v6683) -> ((case _k6684 of {T.TString _val6685 -> E.decodeUtf8 _val6685; _ -> P.error "wrong type"}),(case _v6683 of {T.TStruct _val6686 -> (to_Contact (T.TStruct _val6686)); _ -> P.error "wrong type"}))) _val6682); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactsByEmail_result_e = P.maybe (P.Nothing) (\(_,_val6681) -> P.Just (case _val6681 of {T.TStruct _val6687 -> (to_TalkException (T.TStruct _val6687)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactsByEmail_result _ = P.error "not a struct"
read_FindContactsByEmail_result :: T.Protocol p => p -> P.IO FindContactsByEmail_result
read_FindContactsByEmail_result iprot = to_FindContactsByEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByEmail_result)
decode_FindContactsByEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByEmail_result
decode_FindContactsByEmail_result iprot bs = to_FindContactsByEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByEmail_result) bs
typemap_FindContactsByEmail_result :: T.TypeMap
typemap_FindContactsByEmail_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactsByEmail_result :: FindContactsByEmail_result
default_FindContactsByEmail_result = FindContactsByEmail_result{
  findContactsByEmail_result_success = Map.empty,
  findContactsByEmail_result_e = P.Nothing}
data FindContactsByPhone_args = FindContactsByPhone_args  { findContactsByPhone_args_phones :: (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByPhone_args_phones record  
instance QC.Arbitrary FindContactsByPhone_args where 
  arbitrary = M.liftM FindContactsByPhone_args (QC.arbitrary)
  shrink obj | obj == default_FindContactsByPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByPhone_args{findContactsByPhone_args_phones = findContactsByPhone_args_phones obj} then P.Nothing else P.Just $ default_FindContactsByPhone_args{findContactsByPhone_args_phones = findContactsByPhone_args_phones obj}
    ]
from_FindContactsByPhone_args :: FindContactsByPhone_args -> T.ThriftVal
from_FindContactsByPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6690 -> P.Just (2, ("phones",T.TSet T.T_STRING $ P.map (\_v6692 -> T.TString $ E.encodeUtf8 _v6692) $ Set.toList _v6690))) $ findContactsByPhone_args_phones record
  ]
write_FindContactsByPhone_args :: T.Protocol p => p -> FindContactsByPhone_args -> P.IO ()
write_FindContactsByPhone_args oprot record = T.writeVal oprot $ from_FindContactsByPhone_args record
encode_FindContactsByPhone_args :: T.StatelessProtocol p => p -> FindContactsByPhone_args -> LBS.ByteString
encode_FindContactsByPhone_args oprot record = T.serializeVal oprot $ from_FindContactsByPhone_args record
to_FindContactsByPhone_args :: T.ThriftVal -> FindContactsByPhone_args
to_FindContactsByPhone_args (T.TStruct fields) = FindContactsByPhone_args{
  findContactsByPhone_args_phones = P.maybe (findContactsByPhone_args_phones default_FindContactsByPhone_args) (\(_,_val6694) -> (case _val6694 of {T.TSet _ _val6695 -> (Set.fromList $ P.map (\_v6696 -> (case _v6696 of {T.TString _val6697 -> E.decodeUtf8 _val6697; _ -> P.error "wrong type"})) _val6695); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactsByPhone_args _ = P.error "not a struct"
read_FindContactsByPhone_args :: T.Protocol p => p -> P.IO FindContactsByPhone_args
read_FindContactsByPhone_args iprot = to_FindContactsByPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByPhone_args)
decode_FindContactsByPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByPhone_args
decode_FindContactsByPhone_args iprot bs = to_FindContactsByPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByPhone_args) bs
typemap_FindContactsByPhone_args :: T.TypeMap
typemap_FindContactsByPhone_args = Map.fromList [(2,("phones",(T.T_SET T.T_STRING)))]
default_FindContactsByPhone_args :: FindContactsByPhone_args
default_FindContactsByPhone_args = FindContactsByPhone_args{
  findContactsByPhone_args_phones = Set.empty}
data FindContactsByPhone_result = FindContactsByPhone_result  { findContactsByPhone_result_success :: (Map.HashMap LT.Text Contact)
  , findContactsByPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactsByPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactsByPhone_result_success record   `H.hashWithSalt` findContactsByPhone_result_e record  
instance QC.Arbitrary FindContactsByPhone_result where 
  arbitrary = M.liftM FindContactsByPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactsByPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactsByPhone_result{findContactsByPhone_result_success = findContactsByPhone_result_success obj} then P.Nothing else P.Just $ default_FindContactsByPhone_result{findContactsByPhone_result_success = findContactsByPhone_result_success obj}
    , if obj == default_FindContactsByPhone_result{findContactsByPhone_result_e = findContactsByPhone_result_e obj} then P.Nothing else P.Just $ default_FindContactsByPhone_result{findContactsByPhone_result_e = findContactsByPhone_result_e obj}
    ]
from_FindContactsByPhone_result :: FindContactsByPhone_result -> T.ThriftVal
from_FindContactsByPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6700 -> (1, ("e",from_TalkException _v6700))) <$> findContactsByPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6700 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_Contact) $ P.map (\(_k6701,_v6702) -> (T.TString $ E.encodeUtf8 _k6701, from_Contact _v6702)) $ Map.toList _v6700))) $ findContactsByPhone_result_success record
    , (\_v6700 -> (1, ("e",from_TalkException _v6700))) <$> findContactsByPhone_result_e record
    ]
    )
write_FindContactsByPhone_result :: T.Protocol p => p -> FindContactsByPhone_result -> P.IO ()
write_FindContactsByPhone_result oprot record = T.writeVal oprot $ from_FindContactsByPhone_result record
encode_FindContactsByPhone_result :: T.StatelessProtocol p => p -> FindContactsByPhone_result -> LBS.ByteString
encode_FindContactsByPhone_result oprot record = T.serializeVal oprot $ from_FindContactsByPhone_result record
to_FindContactsByPhone_result :: T.ThriftVal -> FindContactsByPhone_result
to_FindContactsByPhone_result (T.TStruct fields) = FindContactsByPhone_result{
  findContactsByPhone_result_success = P.maybe (findContactsByPhone_result_success default_FindContactsByPhone_result) (\(_,_val6704) -> (case _val6704 of {T.TMap _ _ _val6705 -> (Map.fromList $ P.map (\(_k6707,_v6706) -> ((case _k6707 of {T.TString _val6708 -> E.decodeUtf8 _val6708; _ -> P.error "wrong type"}),(case _v6706 of {T.TStruct _val6709 -> (to_Contact (T.TStruct _val6709)); _ -> P.error "wrong type"}))) _val6705); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactsByPhone_result_e = P.maybe (P.Nothing) (\(_,_val6704) -> P.Just (case _val6704 of {T.TStruct _val6710 -> (to_TalkException (T.TStruct _val6710)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactsByPhone_result _ = P.error "not a struct"
read_FindContactsByPhone_result :: T.Protocol p => p -> P.IO FindContactsByPhone_result
read_FindContactsByPhone_result iprot = to_FindContactsByPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactsByPhone_result)
decode_FindContactsByPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactsByPhone_result
decode_FindContactsByPhone_result iprot bs = to_FindContactsByPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactsByPhone_result) bs
typemap_FindContactsByPhone_result :: T.TypeMap
typemap_FindContactsByPhone_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactsByPhone_result :: FindContactsByPhone_result
default_FindContactsByPhone_result = FindContactsByPhone_result{
  findContactsByPhone_result_success = Map.empty,
  findContactsByPhone_result_e = P.Nothing}
data FindSnsIdUserStatus_args = FindSnsIdUserStatus_args  { findSnsIdUserStatus_args_snsIdType :: SnsIdType
  , findSnsIdUserStatus_args_snsAccessToken :: LT.Text
  , findSnsIdUserStatus_args_udidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSnsIdUserStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSnsIdUserStatus_args_snsIdType record   `H.hashWithSalt` findSnsIdUserStatus_args_snsAccessToken record   `H.hashWithSalt` findSnsIdUserStatus_args_udidHash record  
instance QC.Arbitrary FindSnsIdUserStatus_args where 
  arbitrary = M.liftM FindSnsIdUserStatus_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindSnsIdUserStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsIdType = findSnsIdUserStatus_args_snsIdType obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsIdType = findSnsIdUserStatus_args_snsIdType obj}
    , if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsAccessToken = findSnsIdUserStatus_args_snsAccessToken obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_snsAccessToken = findSnsIdUserStatus_args_snsAccessToken obj}
    , if obj == default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_udidHash = findSnsIdUserStatus_args_udidHash obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_args{findSnsIdUserStatus_args_udidHash = findSnsIdUserStatus_args_udidHash obj}
    ]
from_FindSnsIdUserStatus_args :: FindSnsIdUserStatus_args -> T.ThriftVal
from_FindSnsIdUserStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6713 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v6713))) $ findSnsIdUserStatus_args_snsIdType record
  , (\_v6713 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v6713))) $ findSnsIdUserStatus_args_snsAccessToken record
  , (\_v6713 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v6713))) $ findSnsIdUserStatus_args_udidHash record
  ]
write_FindSnsIdUserStatus_args :: T.Protocol p => p -> FindSnsIdUserStatus_args -> P.IO ()
write_FindSnsIdUserStatus_args oprot record = T.writeVal oprot $ from_FindSnsIdUserStatus_args record
encode_FindSnsIdUserStatus_args :: T.StatelessProtocol p => p -> FindSnsIdUserStatus_args -> LBS.ByteString
encode_FindSnsIdUserStatus_args oprot record = T.serializeVal oprot $ from_FindSnsIdUserStatus_args record
to_FindSnsIdUserStatus_args :: T.ThriftVal -> FindSnsIdUserStatus_args
to_FindSnsIdUserStatus_args (T.TStruct fields) = FindSnsIdUserStatus_args{
  findSnsIdUserStatus_args_snsIdType = P.maybe (findSnsIdUserStatus_args_snsIdType default_FindSnsIdUserStatus_args) (\(_,_val6715) -> (case _val6715 of {T.TI32 _val6716 -> P.toEnum $ P.fromIntegral _val6716; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findSnsIdUserStatus_args_snsAccessToken = P.maybe (findSnsIdUserStatus_args_snsAccessToken default_FindSnsIdUserStatus_args) (\(_,_val6715) -> (case _val6715 of {T.TString _val6717 -> E.decodeUtf8 _val6717; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  findSnsIdUserStatus_args_udidHash = P.maybe (findSnsIdUserStatus_args_udidHash default_FindSnsIdUserStatus_args) (\(_,_val6715) -> (case _val6715 of {T.TString _val6718 -> E.decodeUtf8 _val6718; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_FindSnsIdUserStatus_args _ = P.error "not a struct"
read_FindSnsIdUserStatus_args :: T.Protocol p => p -> P.IO FindSnsIdUserStatus_args
read_FindSnsIdUserStatus_args iprot = to_FindSnsIdUserStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_args)
decode_FindSnsIdUserStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSnsIdUserStatus_args
decode_FindSnsIdUserStatus_args iprot bs = to_FindSnsIdUserStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_args) bs
typemap_FindSnsIdUserStatus_args :: T.TypeMap
typemap_FindSnsIdUserStatus_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("udidHash",T.T_STRING))]
default_FindSnsIdUserStatus_args :: FindSnsIdUserStatus_args
default_FindSnsIdUserStatus_args = FindSnsIdUserStatus_args{
  findSnsIdUserStatus_args_snsIdType = (P.toEnum 0),
  findSnsIdUserStatus_args_snsAccessToken = "",
  findSnsIdUserStatus_args_udidHash = ""}
data FindSnsIdUserStatus_result = FindSnsIdUserStatus_result  { findSnsIdUserStatus_result_success :: SnsIdUserStatus
  , findSnsIdUserStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindSnsIdUserStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findSnsIdUserStatus_result_success record   `H.hashWithSalt` findSnsIdUserStatus_result_e record  
instance QC.Arbitrary FindSnsIdUserStatus_result where 
  arbitrary = M.liftM FindSnsIdUserStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindSnsIdUserStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = findSnsIdUserStatus_result_success obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = findSnsIdUserStatus_result_success obj}
    , if obj == default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = findSnsIdUserStatus_result_e obj} then P.Nothing else P.Just $ default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = findSnsIdUserStatus_result_e obj}
    ]
from_FindSnsIdUserStatus_result :: FindSnsIdUserStatus_result -> T.ThriftVal
from_FindSnsIdUserStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6721 -> (1, ("e",from_TalkException _v6721))) <$> findSnsIdUserStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6721 -> P.Just (0, ("success",from_SnsIdUserStatus _v6721))) $ findSnsIdUserStatus_result_success record
    , (\_v6721 -> (1, ("e",from_TalkException _v6721))) <$> findSnsIdUserStatus_result_e record
    ]
    )
write_FindSnsIdUserStatus_result :: T.Protocol p => p -> FindSnsIdUserStatus_result -> P.IO ()
write_FindSnsIdUserStatus_result oprot record = T.writeVal oprot $ from_FindSnsIdUserStatus_result record
encode_FindSnsIdUserStatus_result :: T.StatelessProtocol p => p -> FindSnsIdUserStatus_result -> LBS.ByteString
encode_FindSnsIdUserStatus_result oprot record = T.serializeVal oprot $ from_FindSnsIdUserStatus_result record
to_FindSnsIdUserStatus_result :: T.ThriftVal -> FindSnsIdUserStatus_result
to_FindSnsIdUserStatus_result (T.TStruct fields) = FindSnsIdUserStatus_result{
  findSnsIdUserStatus_result_success = P.maybe (findSnsIdUserStatus_result_success default_FindSnsIdUserStatus_result) (\(_,_val6723) -> (case _val6723 of {T.TStruct _val6724 -> (to_SnsIdUserStatus (T.TStruct _val6724)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findSnsIdUserStatus_result_e = P.maybe (P.Nothing) (\(_,_val6723) -> P.Just (case _val6723 of {T.TStruct _val6725 -> (to_TalkException (T.TStruct _val6725)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindSnsIdUserStatus_result _ = P.error "not a struct"
read_FindSnsIdUserStatus_result :: T.Protocol p => p -> P.IO FindSnsIdUserStatus_result
read_FindSnsIdUserStatus_result iprot = to_FindSnsIdUserStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_result)
decode_FindSnsIdUserStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindSnsIdUserStatus_result
decode_FindSnsIdUserStatus_result iprot bs = to_FindSnsIdUserStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindSnsIdUserStatus_result) bs
typemap_FindSnsIdUserStatus_result :: T.TypeMap
typemap_FindSnsIdUserStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SnsIdUserStatus))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindSnsIdUserStatus_result :: FindSnsIdUserStatus_result
default_FindSnsIdUserStatus_result = FindSnsIdUserStatus_result{
  findSnsIdUserStatus_result_success = default_SnsIdUserStatus,
  findSnsIdUserStatus_result_e = P.Nothing}
data FinishUpdateVerification_args = FinishUpdateVerification_args  { finishUpdateVerification_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FinishUpdateVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` finishUpdateVerification_args_sessionId record  
instance QC.Arbitrary FinishUpdateVerification_args where 
  arbitrary = M.liftM FinishUpdateVerification_args (QC.arbitrary)
  shrink obj | obj == default_FinishUpdateVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FinishUpdateVerification_args{finishUpdateVerification_args_sessionId = finishUpdateVerification_args_sessionId obj} then P.Nothing else P.Just $ default_FinishUpdateVerification_args{finishUpdateVerification_args_sessionId = finishUpdateVerification_args_sessionId obj}
    ]
from_FinishUpdateVerification_args :: FinishUpdateVerification_args -> T.ThriftVal
from_FinishUpdateVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6728 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6728))) $ finishUpdateVerification_args_sessionId record
  ]
write_FinishUpdateVerification_args :: T.Protocol p => p -> FinishUpdateVerification_args -> P.IO ()
write_FinishUpdateVerification_args oprot record = T.writeVal oprot $ from_FinishUpdateVerification_args record
encode_FinishUpdateVerification_args :: T.StatelessProtocol p => p -> FinishUpdateVerification_args -> LBS.ByteString
encode_FinishUpdateVerification_args oprot record = T.serializeVal oprot $ from_FinishUpdateVerification_args record
to_FinishUpdateVerification_args :: T.ThriftVal -> FinishUpdateVerification_args
to_FinishUpdateVerification_args (T.TStruct fields) = FinishUpdateVerification_args{
  finishUpdateVerification_args_sessionId = P.maybe (finishUpdateVerification_args_sessionId default_FinishUpdateVerification_args) (\(_,_val6730) -> (case _val6730 of {T.TString _val6731 -> E.decodeUtf8 _val6731; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FinishUpdateVerification_args _ = P.error "not a struct"
read_FinishUpdateVerification_args :: T.Protocol p => p -> P.IO FinishUpdateVerification_args
read_FinishUpdateVerification_args iprot = to_FinishUpdateVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_args)
decode_FinishUpdateVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FinishUpdateVerification_args
decode_FinishUpdateVerification_args iprot bs = to_FinishUpdateVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_args) bs
typemap_FinishUpdateVerification_args :: T.TypeMap
typemap_FinishUpdateVerification_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_FinishUpdateVerification_args :: FinishUpdateVerification_args
default_FinishUpdateVerification_args = FinishUpdateVerification_args{
  finishUpdateVerification_args_sessionId = ""}
data FinishUpdateVerification_result = FinishUpdateVerification_result  { finishUpdateVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FinishUpdateVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` finishUpdateVerification_result_e record  
instance QC.Arbitrary FinishUpdateVerification_result where 
  arbitrary = M.liftM FinishUpdateVerification_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FinishUpdateVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FinishUpdateVerification_result{finishUpdateVerification_result_e = finishUpdateVerification_result_e obj} then P.Nothing else P.Just $ default_FinishUpdateVerification_result{finishUpdateVerification_result_e = finishUpdateVerification_result_e obj}
    ]
from_FinishUpdateVerification_result :: FinishUpdateVerification_result -> T.ThriftVal
from_FinishUpdateVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6734 -> (1, ("e",from_TalkException _v6734))) <$> finishUpdateVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6734 -> (1, ("e",from_TalkException _v6734))) <$> finishUpdateVerification_result_e record
    ]
    )
write_FinishUpdateVerification_result :: T.Protocol p => p -> FinishUpdateVerification_result -> P.IO ()
write_FinishUpdateVerification_result oprot record = T.writeVal oprot $ from_FinishUpdateVerification_result record
encode_FinishUpdateVerification_result :: T.StatelessProtocol p => p -> FinishUpdateVerification_result -> LBS.ByteString
encode_FinishUpdateVerification_result oprot record = T.serializeVal oprot $ from_FinishUpdateVerification_result record
to_FinishUpdateVerification_result :: T.ThriftVal -> FinishUpdateVerification_result
to_FinishUpdateVerification_result (T.TStruct fields) = FinishUpdateVerification_result{
  finishUpdateVerification_result_e = P.maybe (P.Nothing) (\(_,_val6736) -> P.Just (case _val6736 of {T.TStruct _val6737 -> (to_TalkException (T.TStruct _val6737)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FinishUpdateVerification_result _ = P.error "not a struct"
read_FinishUpdateVerification_result :: T.Protocol p => p -> P.IO FinishUpdateVerification_result
read_FinishUpdateVerification_result iprot = to_FinishUpdateVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_result)
decode_FinishUpdateVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FinishUpdateVerification_result
decode_FinishUpdateVerification_result iprot bs = to_FinishUpdateVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FinishUpdateVerification_result) bs
typemap_FinishUpdateVerification_result :: T.TypeMap
typemap_FinishUpdateVerification_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FinishUpdateVerification_result :: FinishUpdateVerification_result
default_FinishUpdateVerification_result = FinishUpdateVerification_result{
  finishUpdateVerification_result_e = P.Nothing}
data GenerateUserTicket_args = GenerateUserTicket_args  { generateUserTicket_args_expirationTime :: I.Int64
  , generateUserTicket_args_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GenerateUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` generateUserTicket_args_expirationTime record   `H.hashWithSalt` generateUserTicket_args_maxUseCount record  
instance QC.Arbitrary GenerateUserTicket_args where 
  arbitrary = M.liftM GenerateUserTicket_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GenerateUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GenerateUserTicket_args{generateUserTicket_args_expirationTime = generateUserTicket_args_expirationTime obj} then P.Nothing else P.Just $ default_GenerateUserTicket_args{generateUserTicket_args_expirationTime = generateUserTicket_args_expirationTime obj}
    , if obj == default_GenerateUserTicket_args{generateUserTicket_args_maxUseCount = generateUserTicket_args_maxUseCount obj} then P.Nothing else P.Just $ default_GenerateUserTicket_args{generateUserTicket_args_maxUseCount = generateUserTicket_args_maxUseCount obj}
    ]
from_GenerateUserTicket_args :: GenerateUserTicket_args -> T.ThriftVal
from_GenerateUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6740 -> P.Just (3, ("expirationTime",T.TI64 _v6740))) $ generateUserTicket_args_expirationTime record
  , (\_v6740 -> P.Just (4, ("maxUseCount",T.TI32 _v6740))) $ generateUserTicket_args_maxUseCount record
  ]
write_GenerateUserTicket_args :: T.Protocol p => p -> GenerateUserTicket_args -> P.IO ()
write_GenerateUserTicket_args oprot record = T.writeVal oprot $ from_GenerateUserTicket_args record
encode_GenerateUserTicket_args :: T.StatelessProtocol p => p -> GenerateUserTicket_args -> LBS.ByteString
encode_GenerateUserTicket_args oprot record = T.serializeVal oprot $ from_GenerateUserTicket_args record
to_GenerateUserTicket_args :: T.ThriftVal -> GenerateUserTicket_args
to_GenerateUserTicket_args (T.TStruct fields) = GenerateUserTicket_args{
  generateUserTicket_args_expirationTime = P.maybe (generateUserTicket_args_expirationTime default_GenerateUserTicket_args) (\(_,_val6742) -> (case _val6742 of {T.TI64 _val6743 -> _val6743; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  generateUserTicket_args_maxUseCount = P.maybe (generateUserTicket_args_maxUseCount default_GenerateUserTicket_args) (\(_,_val6742) -> (case _val6742 of {T.TI32 _val6744 -> _val6744; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GenerateUserTicket_args _ = P.error "not a struct"
read_GenerateUserTicket_args :: T.Protocol p => p -> P.IO GenerateUserTicket_args
read_GenerateUserTicket_args iprot = to_GenerateUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_GenerateUserTicket_args)
decode_GenerateUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GenerateUserTicket_args
decode_GenerateUserTicket_args iprot bs = to_GenerateUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GenerateUserTicket_args) bs
typemap_GenerateUserTicket_args :: T.TypeMap
typemap_GenerateUserTicket_args = Map.fromList [(3,("expirationTime",T.T_I64)),(4,("maxUseCount",T.T_I32))]
default_GenerateUserTicket_args :: GenerateUserTicket_args
default_GenerateUserTicket_args = GenerateUserTicket_args{
  generateUserTicket_args_expirationTime = 0,
  generateUserTicket_args_maxUseCount = 0}
data GenerateUserTicket_result = GenerateUserTicket_result  { generateUserTicket_result_success :: Ticket
  , generateUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GenerateUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` generateUserTicket_result_success record   `H.hashWithSalt` generateUserTicket_result_e record  
instance QC.Arbitrary GenerateUserTicket_result where 
  arbitrary = M.liftM GenerateUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GenerateUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GenerateUserTicket_result{generateUserTicket_result_success = generateUserTicket_result_success obj} then P.Nothing else P.Just $ default_GenerateUserTicket_result{generateUserTicket_result_success = generateUserTicket_result_success obj}
    , if obj == default_GenerateUserTicket_result{generateUserTicket_result_e = generateUserTicket_result_e obj} then P.Nothing else P.Just $ default_GenerateUserTicket_result{generateUserTicket_result_e = generateUserTicket_result_e obj}
    ]
from_GenerateUserTicket_result :: GenerateUserTicket_result -> T.ThriftVal
from_GenerateUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6747 -> (1, ("e",from_TalkException _v6747))) <$> generateUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6747 -> P.Just (0, ("success",from_Ticket _v6747))) $ generateUserTicket_result_success record
    , (\_v6747 -> (1, ("e",from_TalkException _v6747))) <$> generateUserTicket_result_e record
    ]
    )
write_GenerateUserTicket_result :: T.Protocol p => p -> GenerateUserTicket_result -> P.IO ()
write_GenerateUserTicket_result oprot record = T.writeVal oprot $ from_GenerateUserTicket_result record
encode_GenerateUserTicket_result :: T.StatelessProtocol p => p -> GenerateUserTicket_result -> LBS.ByteString
encode_GenerateUserTicket_result oprot record = T.serializeVal oprot $ from_GenerateUserTicket_result record
to_GenerateUserTicket_result :: T.ThriftVal -> GenerateUserTicket_result
to_GenerateUserTicket_result (T.TStruct fields) = GenerateUserTicket_result{
  generateUserTicket_result_success = P.maybe (generateUserTicket_result_success default_GenerateUserTicket_result) (\(_,_val6749) -> (case _val6749 of {T.TStruct _val6750 -> (to_Ticket (T.TStruct _val6750)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  generateUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val6749) -> P.Just (case _val6749 of {T.TStruct _val6751 -> (to_TalkException (T.TStruct _val6751)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GenerateUserTicket_result _ = P.error "not a struct"
read_GenerateUserTicket_result :: T.Protocol p => p -> P.IO GenerateUserTicket_result
read_GenerateUserTicket_result iprot = to_GenerateUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_GenerateUserTicket_result)
decode_GenerateUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GenerateUserTicket_result
decode_GenerateUserTicket_result iprot bs = to_GenerateUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GenerateUserTicket_result) bs
typemap_GenerateUserTicket_result :: T.TypeMap
typemap_GenerateUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Ticket))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GenerateUserTicket_result :: GenerateUserTicket_result
default_GenerateUserTicket_result = GenerateUserTicket_result{
  generateUserTicket_result_success = default_Ticket,
  generateUserTicket_result_e = P.Nothing}
data DestroyMessage_args = DestroyMessage_args  { destroyMessage_args_seq :: I.Int32
  , destroyMessage_args_chatId :: LT.Text
  , destroyMessage_args_messageId :: LT.Text
  , destroyMessage_args_sessionId :: I.Int8
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` destroyMessage_args_seq record   `H.hashWithSalt` destroyMessage_args_chatId record   `H.hashWithSalt` destroyMessage_args_messageId record   `H.hashWithSalt` destroyMessage_args_sessionId record  
instance QC.Arbitrary DestroyMessage_args where 
  arbitrary = M.liftM DestroyMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DestroyMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DestroyMessage_args{destroyMessage_args_seq = destroyMessage_args_seq obj} then P.Nothing else P.Just $ default_DestroyMessage_args{destroyMessage_args_seq = destroyMessage_args_seq obj}
    , if obj == default_DestroyMessage_args{destroyMessage_args_chatId = destroyMessage_args_chatId obj} then P.Nothing else P.Just $ default_DestroyMessage_args{destroyMessage_args_chatId = destroyMessage_args_chatId obj}
    , if obj == default_DestroyMessage_args{destroyMessage_args_messageId = destroyMessage_args_messageId obj} then P.Nothing else P.Just $ default_DestroyMessage_args{destroyMessage_args_messageId = destroyMessage_args_messageId obj}
    , if obj == default_DestroyMessage_args{destroyMessage_args_sessionId = destroyMessage_args_sessionId obj} then P.Nothing else P.Just $ default_DestroyMessage_args{destroyMessage_args_sessionId = destroyMessage_args_sessionId obj}
    ]
from_DestroyMessage_args :: DestroyMessage_args -> T.ThriftVal
from_DestroyMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6754 -> P.Just (1, ("seq",T.TI32 _v6754))) $ destroyMessage_args_seq record
  , (\_v6754 -> P.Just (2, ("chatId",T.TString $ E.encodeUtf8 _v6754))) $ destroyMessage_args_chatId record
  , (\_v6754 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v6754))) $ destroyMessage_args_messageId record
  , (\_v6754 -> P.Just (4, ("sessionId",T.TByte _v6754))) $ destroyMessage_args_sessionId record
  ]
write_DestroyMessage_args :: T.Protocol p => p -> DestroyMessage_args -> P.IO ()
write_DestroyMessage_args oprot record = T.writeVal oprot $ from_DestroyMessage_args record
encode_DestroyMessage_args :: T.StatelessProtocol p => p -> DestroyMessage_args -> LBS.ByteString
encode_DestroyMessage_args oprot record = T.serializeVal oprot $ from_DestroyMessage_args record
to_DestroyMessage_args :: T.ThriftVal -> DestroyMessage_args
to_DestroyMessage_args (T.TStruct fields) = DestroyMessage_args{
  destroyMessage_args_seq = P.maybe (destroyMessage_args_seq default_DestroyMessage_args) (\(_,_val6756) -> (case _val6756 of {T.TI32 _val6757 -> _val6757; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  destroyMessage_args_chatId = P.maybe (destroyMessage_args_chatId default_DestroyMessage_args) (\(_,_val6756) -> (case _val6756 of {T.TString _val6758 -> E.decodeUtf8 _val6758; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  destroyMessage_args_messageId = P.maybe (destroyMessage_args_messageId default_DestroyMessage_args) (\(_,_val6756) -> (case _val6756 of {T.TString _val6759 -> E.decodeUtf8 _val6759; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  destroyMessage_args_sessionId = P.maybe (destroyMessage_args_sessionId default_DestroyMessage_args) (\(_,_val6756) -> (case _val6756 of {T.TByte _val6760 -> _val6760; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_DestroyMessage_args _ = P.error "not a struct"
read_DestroyMessage_args :: T.Protocol p => p -> P.IO DestroyMessage_args
read_DestroyMessage_args iprot = to_DestroyMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessage_args)
decode_DestroyMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessage_args
decode_DestroyMessage_args iprot bs = to_DestroyMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessage_args) bs
typemap_DestroyMessage_args :: T.TypeMap
typemap_DestroyMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("chatId",T.T_STRING)),(3,("messageId",T.T_STRING)),(4,("sessionId",T.T_BYTE))]
default_DestroyMessage_args :: DestroyMessage_args
default_DestroyMessage_args = DestroyMessage_args{
  destroyMessage_args_seq = 0,
  destroyMessage_args_chatId = "",
  destroyMessage_args_messageId = "",
  destroyMessage_args_sessionId = 0}
data DestroyMessage_result = DestroyMessage_result  { destroyMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DestroyMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` destroyMessage_result_e record  
instance QC.Arbitrary DestroyMessage_result where 
  arbitrary = M.liftM DestroyMessage_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DestroyMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DestroyMessage_result{destroyMessage_result_e = destroyMessage_result_e obj} then P.Nothing else P.Just $ default_DestroyMessage_result{destroyMessage_result_e = destroyMessage_result_e obj}
    ]
from_DestroyMessage_result :: DestroyMessage_result -> T.ThriftVal
from_DestroyMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6763 -> (1, ("e",from_TalkException _v6763))) <$> destroyMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6763 -> (1, ("e",from_TalkException _v6763))) <$> destroyMessage_result_e record
    ]
    )
write_DestroyMessage_result :: T.Protocol p => p -> DestroyMessage_result -> P.IO ()
write_DestroyMessage_result oprot record = T.writeVal oprot $ from_DestroyMessage_result record
encode_DestroyMessage_result :: T.StatelessProtocol p => p -> DestroyMessage_result -> LBS.ByteString
encode_DestroyMessage_result oprot record = T.serializeVal oprot $ from_DestroyMessage_result record
to_DestroyMessage_result :: T.ThriftVal -> DestroyMessage_result
to_DestroyMessage_result (T.TStruct fields) = DestroyMessage_result{
  destroyMessage_result_e = P.maybe (P.Nothing) (\(_,_val6765) -> P.Just (case _val6765 of {T.TStruct _val6766 -> (to_TalkException (T.TStruct _val6766)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DestroyMessage_result _ = P.error "not a struct"
read_DestroyMessage_result :: T.Protocol p => p -> P.IO DestroyMessage_result
read_DestroyMessage_result iprot = to_DestroyMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_DestroyMessage_result)
decode_DestroyMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DestroyMessage_result
decode_DestroyMessage_result iprot bs = to_DestroyMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DestroyMessage_result) bs
typemap_DestroyMessage_result :: T.TypeMap
typemap_DestroyMessage_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DestroyMessage_result :: DestroyMessage_result
default_DestroyMessage_result = DestroyMessage_result{
  destroyMessage_result_e = P.Nothing}
data GetAcceptedProximityMatches_args = GetAcceptedProximityMatches_args  { getAcceptedProximityMatches_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAcceptedProximityMatches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAcceptedProximityMatches_args_sessionId record  
instance QC.Arbitrary GetAcceptedProximityMatches_args where 
  arbitrary = M.liftM GetAcceptedProximityMatches_args (QC.arbitrary)
  shrink obj | obj == default_GetAcceptedProximityMatches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAcceptedProximityMatches_args{getAcceptedProximityMatches_args_sessionId = getAcceptedProximityMatches_args_sessionId obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_args{getAcceptedProximityMatches_args_sessionId = getAcceptedProximityMatches_args_sessionId obj}
    ]
from_GetAcceptedProximityMatches_args :: GetAcceptedProximityMatches_args -> T.ThriftVal
from_GetAcceptedProximityMatches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6769 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6769))) $ getAcceptedProximityMatches_args_sessionId record
  ]
write_GetAcceptedProximityMatches_args :: T.Protocol p => p -> GetAcceptedProximityMatches_args -> P.IO ()
write_GetAcceptedProximityMatches_args oprot record = T.writeVal oprot $ from_GetAcceptedProximityMatches_args record
encode_GetAcceptedProximityMatches_args :: T.StatelessProtocol p => p -> GetAcceptedProximityMatches_args -> LBS.ByteString
encode_GetAcceptedProximityMatches_args oprot record = T.serializeVal oprot $ from_GetAcceptedProximityMatches_args record
to_GetAcceptedProximityMatches_args :: T.ThriftVal -> GetAcceptedProximityMatches_args
to_GetAcceptedProximityMatches_args (T.TStruct fields) = GetAcceptedProximityMatches_args{
  getAcceptedProximityMatches_args_sessionId = P.maybe (getAcceptedProximityMatches_args_sessionId default_GetAcceptedProximityMatches_args) (\(_,_val6771) -> (case _val6771 of {T.TString _val6772 -> E.decodeUtf8 _val6772; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetAcceptedProximityMatches_args _ = P.error "not a struct"
read_GetAcceptedProximityMatches_args :: T.Protocol p => p -> P.IO GetAcceptedProximityMatches_args
read_GetAcceptedProximityMatches_args iprot = to_GetAcceptedProximityMatches_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_args)
decode_GetAcceptedProximityMatches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAcceptedProximityMatches_args
decode_GetAcceptedProximityMatches_args iprot bs = to_GetAcceptedProximityMatches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_args) bs
typemap_GetAcceptedProximityMatches_args :: T.TypeMap
typemap_GetAcceptedProximityMatches_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetAcceptedProximityMatches_args :: GetAcceptedProximityMatches_args
default_GetAcceptedProximityMatches_args = GetAcceptedProximityMatches_args{
  getAcceptedProximityMatches_args_sessionId = ""}
data GetAcceptedProximityMatches_result = GetAcceptedProximityMatches_result  { getAcceptedProximityMatches_result_success :: (Set.HashSet LT.Text)
  , getAcceptedProximityMatches_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAcceptedProximityMatches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAcceptedProximityMatches_result_success record   `H.hashWithSalt` getAcceptedProximityMatches_result_e record  
instance QC.Arbitrary GetAcceptedProximityMatches_result where 
  arbitrary = M.liftM GetAcceptedProximityMatches_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAcceptedProximityMatches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = getAcceptedProximityMatches_result_success obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = getAcceptedProximityMatches_result_success obj}
    , if obj == default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = getAcceptedProximityMatches_result_e obj} then P.Nothing else P.Just $ default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = getAcceptedProximityMatches_result_e obj}
    ]
from_GetAcceptedProximityMatches_result :: GetAcceptedProximityMatches_result -> T.ThriftVal
from_GetAcceptedProximityMatches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6775 -> (1, ("e",from_TalkException _v6775))) <$> getAcceptedProximityMatches_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6775 -> P.Just (0, ("success",T.TSet T.T_STRING $ P.map (\_v6777 -> T.TString $ E.encodeUtf8 _v6777) $ Set.toList _v6775))) $ getAcceptedProximityMatches_result_success record
    , (\_v6775 -> (1, ("e",from_TalkException _v6775))) <$> getAcceptedProximityMatches_result_e record
    ]
    )
write_GetAcceptedProximityMatches_result :: T.Protocol p => p -> GetAcceptedProximityMatches_result -> P.IO ()
write_GetAcceptedProximityMatches_result oprot record = T.writeVal oprot $ from_GetAcceptedProximityMatches_result record
encode_GetAcceptedProximityMatches_result :: T.StatelessProtocol p => p -> GetAcceptedProximityMatches_result -> LBS.ByteString
encode_GetAcceptedProximityMatches_result oprot record = T.serializeVal oprot $ from_GetAcceptedProximityMatches_result record
to_GetAcceptedProximityMatches_result :: T.ThriftVal -> GetAcceptedProximityMatches_result
to_GetAcceptedProximityMatches_result (T.TStruct fields) = GetAcceptedProximityMatches_result{
  getAcceptedProximityMatches_result_success = P.maybe (getAcceptedProximityMatches_result_success default_GetAcceptedProximityMatches_result) (\(_,_val6779) -> (case _val6779 of {T.TSet _ _val6780 -> (Set.fromList $ P.map (\_v6781 -> (case _v6781 of {T.TString _val6782 -> E.decodeUtf8 _val6782; _ -> P.error "wrong type"})) _val6780); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAcceptedProximityMatches_result_e = P.maybe (P.Nothing) (\(_,_val6779) -> P.Just (case _val6779 of {T.TStruct _val6783 -> (to_TalkException (T.TStruct _val6783)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAcceptedProximityMatches_result _ = P.error "not a struct"
read_GetAcceptedProximityMatches_result :: T.Protocol p => p -> P.IO GetAcceptedProximityMatches_result
read_GetAcceptedProximityMatches_result iprot = to_GetAcceptedProximityMatches_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_result)
decode_GetAcceptedProximityMatches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAcceptedProximityMatches_result
decode_GetAcceptedProximityMatches_result iprot bs = to_GetAcceptedProximityMatches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAcceptedProximityMatches_result) bs
typemap_GetAcceptedProximityMatches_result :: T.TypeMap
typemap_GetAcceptedProximityMatches_result = Map.fromList [(0,("success",(T.T_SET T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAcceptedProximityMatches_result :: GetAcceptedProximityMatches_result
default_GetAcceptedProximityMatches_result = GetAcceptedProximityMatches_result{
  getAcceptedProximityMatches_result_success = Set.empty,
  getAcceptedProximityMatches_result_e = P.Nothing}
data GetActiveBuddySubscriberIds_args = GetActiveBuddySubscriberIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActiveBuddySubscriberIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetActiveBuddySubscriberIds_args where 
  arbitrary = QC.elements [GetActiveBuddySubscriberIds_args]
from_GetActiveBuddySubscriberIds_args :: GetActiveBuddySubscriberIds_args -> T.ThriftVal
from_GetActiveBuddySubscriberIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetActiveBuddySubscriberIds_args :: T.Protocol p => p -> GetActiveBuddySubscriberIds_args -> P.IO ()
write_GetActiveBuddySubscriberIds_args oprot record = T.writeVal oprot $ from_GetActiveBuddySubscriberIds_args record
encode_GetActiveBuddySubscriberIds_args :: T.StatelessProtocol p => p -> GetActiveBuddySubscriberIds_args -> LBS.ByteString
encode_GetActiveBuddySubscriberIds_args oprot record = T.serializeVal oprot $ from_GetActiveBuddySubscriberIds_args record
to_GetActiveBuddySubscriberIds_args :: T.ThriftVal -> GetActiveBuddySubscriberIds_args
to_GetActiveBuddySubscriberIds_args (T.TStruct fields) = GetActiveBuddySubscriberIds_args{

  }
to_GetActiveBuddySubscriberIds_args _ = P.error "not a struct"
read_GetActiveBuddySubscriberIds_args :: T.Protocol p => p -> P.IO GetActiveBuddySubscriberIds_args
read_GetActiveBuddySubscriberIds_args iprot = to_GetActiveBuddySubscriberIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_args)
decode_GetActiveBuddySubscriberIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActiveBuddySubscriberIds_args
decode_GetActiveBuddySubscriberIds_args iprot bs = to_GetActiveBuddySubscriberIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_args) bs
typemap_GetActiveBuddySubscriberIds_args :: T.TypeMap
typemap_GetActiveBuddySubscriberIds_args = Map.fromList []
default_GetActiveBuddySubscriberIds_args :: GetActiveBuddySubscriberIds_args
default_GetActiveBuddySubscriberIds_args = GetActiveBuddySubscriberIds_args{
}
data GetActiveBuddySubscriberIds_result = GetActiveBuddySubscriberIds_result  { getActiveBuddySubscriberIds_result_success :: (Vector.Vector LT.Text)
  , getActiveBuddySubscriberIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActiveBuddySubscriberIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActiveBuddySubscriberIds_result_success record   `H.hashWithSalt` getActiveBuddySubscriberIds_result_e record  
instance QC.Arbitrary GetActiveBuddySubscriberIds_result where 
  arbitrary = M.liftM GetActiveBuddySubscriberIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetActiveBuddySubscriberIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = getActiveBuddySubscriberIds_result_success obj} then P.Nothing else P.Just $ default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = getActiveBuddySubscriberIds_result_success obj}
    , if obj == default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = getActiveBuddySubscriberIds_result_e obj} then P.Nothing else P.Just $ default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = getActiveBuddySubscriberIds_result_e obj}
    ]
from_GetActiveBuddySubscriberIds_result :: GetActiveBuddySubscriberIds_result -> T.ThriftVal
from_GetActiveBuddySubscriberIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6791 -> (1, ("e",from_TalkException _v6791))) <$> getActiveBuddySubscriberIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6791 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6793 -> T.TString $ E.encodeUtf8 _v6793) $ Vector.toList _v6791))) $ getActiveBuddySubscriberIds_result_success record
    , (\_v6791 -> (1, ("e",from_TalkException _v6791))) <$> getActiveBuddySubscriberIds_result_e record
    ]
    )
write_GetActiveBuddySubscriberIds_result :: T.Protocol p => p -> GetActiveBuddySubscriberIds_result -> P.IO ()
write_GetActiveBuddySubscriberIds_result oprot record = T.writeVal oprot $ from_GetActiveBuddySubscriberIds_result record
encode_GetActiveBuddySubscriberIds_result :: T.StatelessProtocol p => p -> GetActiveBuddySubscriberIds_result -> LBS.ByteString
encode_GetActiveBuddySubscriberIds_result oprot record = T.serializeVal oprot $ from_GetActiveBuddySubscriberIds_result record
to_GetActiveBuddySubscriberIds_result :: T.ThriftVal -> GetActiveBuddySubscriberIds_result
to_GetActiveBuddySubscriberIds_result (T.TStruct fields) = GetActiveBuddySubscriberIds_result{
  getActiveBuddySubscriberIds_result_success = P.maybe (getActiveBuddySubscriberIds_result_success default_GetActiveBuddySubscriberIds_result) (\(_,_val6795) -> (case _val6795 of {T.TList _ _val6796 -> (Vector.fromList $ P.map (\_v6797 -> (case _v6797 of {T.TString _val6798 -> E.decodeUtf8 _val6798; _ -> P.error "wrong type"})) _val6796); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getActiveBuddySubscriberIds_result_e = P.maybe (P.Nothing) (\(_,_val6795) -> P.Just (case _val6795 of {T.TStruct _val6799 -> (to_TalkException (T.TStruct _val6799)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetActiveBuddySubscriberIds_result _ = P.error "not a struct"
read_GetActiveBuddySubscriberIds_result :: T.Protocol p => p -> P.IO GetActiveBuddySubscriberIds_result
read_GetActiveBuddySubscriberIds_result iprot = to_GetActiveBuddySubscriberIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_result)
decode_GetActiveBuddySubscriberIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActiveBuddySubscriberIds_result
decode_GetActiveBuddySubscriberIds_result iprot bs = to_GetActiveBuddySubscriberIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActiveBuddySubscriberIds_result) bs
typemap_GetActiveBuddySubscriberIds_result :: T.TypeMap
typemap_GetActiveBuddySubscriberIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetActiveBuddySubscriberIds_result :: GetActiveBuddySubscriberIds_result
default_GetActiveBuddySubscriberIds_result = GetActiveBuddySubscriberIds_result{
  getActiveBuddySubscriberIds_result_success = Vector.empty,
  getActiveBuddySubscriberIds_result_e = P.Nothing}
data GetAllContactIds_args = GetAllContactIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIds_args where 
  arbitrary = QC.elements [GetAllContactIds_args]
from_GetAllContactIds_args :: GetAllContactIds_args -> T.ThriftVal
from_GetAllContactIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIds_args :: T.Protocol p => p -> GetAllContactIds_args -> P.IO ()
write_GetAllContactIds_args oprot record = T.writeVal oprot $ from_GetAllContactIds_args record
encode_GetAllContactIds_args :: T.StatelessProtocol p => p -> GetAllContactIds_args -> LBS.ByteString
encode_GetAllContactIds_args oprot record = T.serializeVal oprot $ from_GetAllContactIds_args record
to_GetAllContactIds_args :: T.ThriftVal -> GetAllContactIds_args
to_GetAllContactIds_args (T.TStruct fields) = GetAllContactIds_args{

  }
to_GetAllContactIds_args _ = P.error "not a struct"
read_GetAllContactIds_args :: T.Protocol p => p -> P.IO GetAllContactIds_args
read_GetAllContactIds_args iprot = to_GetAllContactIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIds_args)
decode_GetAllContactIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIds_args
decode_GetAllContactIds_args iprot bs = to_GetAllContactIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIds_args) bs
typemap_GetAllContactIds_args :: T.TypeMap
typemap_GetAllContactIds_args = Map.fromList []
default_GetAllContactIds_args :: GetAllContactIds_args
default_GetAllContactIds_args = GetAllContactIds_args{
}
data GetAllContactIds_result = GetAllContactIds_result  { getAllContactIds_result_success :: (Vector.Vector LT.Text)
  , getAllContactIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIds_result_success record   `H.hashWithSalt` getAllContactIds_result_e record  
instance QC.Arbitrary GetAllContactIds_result where 
  arbitrary = M.liftM GetAllContactIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIds_result{getAllContactIds_result_success = getAllContactIds_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIds_result{getAllContactIds_result_success = getAllContactIds_result_success obj}
    , if obj == default_GetAllContactIds_result{getAllContactIds_result_e = getAllContactIds_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIds_result{getAllContactIds_result_e = getAllContactIds_result_e obj}
    ]
from_GetAllContactIds_result :: GetAllContactIds_result -> T.ThriftVal
from_GetAllContactIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6807 -> (1, ("e",from_TalkException _v6807))) <$> getAllContactIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6807 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6809 -> T.TString $ E.encodeUtf8 _v6809) $ Vector.toList _v6807))) $ getAllContactIds_result_success record
    , (\_v6807 -> (1, ("e",from_TalkException _v6807))) <$> getAllContactIds_result_e record
    ]
    )
write_GetAllContactIds_result :: T.Protocol p => p -> GetAllContactIds_result -> P.IO ()
write_GetAllContactIds_result oprot record = T.writeVal oprot $ from_GetAllContactIds_result record
encode_GetAllContactIds_result :: T.StatelessProtocol p => p -> GetAllContactIds_result -> LBS.ByteString
encode_GetAllContactIds_result oprot record = T.serializeVal oprot $ from_GetAllContactIds_result record
to_GetAllContactIds_result :: T.ThriftVal -> GetAllContactIds_result
to_GetAllContactIds_result (T.TStruct fields) = GetAllContactIds_result{
  getAllContactIds_result_success = P.maybe (getAllContactIds_result_success default_GetAllContactIds_result) (\(_,_val6811) -> (case _val6811 of {T.TList _ _val6812 -> (Vector.fromList $ P.map (\_v6813 -> (case _v6813 of {T.TString _val6814 -> E.decodeUtf8 _val6814; _ -> P.error "wrong type"})) _val6812); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIds_result_e = P.maybe (P.Nothing) (\(_,_val6811) -> P.Just (case _val6811 of {T.TStruct _val6815 -> (to_TalkException (T.TStruct _val6815)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIds_result _ = P.error "not a struct"
read_GetAllContactIds_result :: T.Protocol p => p -> P.IO GetAllContactIds_result
read_GetAllContactIds_result iprot = to_GetAllContactIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIds_result)
decode_GetAllContactIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIds_result
decode_GetAllContactIds_result iprot bs = to_GetAllContactIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIds_result) bs
typemap_GetAllContactIds_result :: T.TypeMap
typemap_GetAllContactIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIds_result :: GetAllContactIds_result
default_GetAllContactIds_result = GetAllContactIds_result{
  getAllContactIds_result_success = Vector.empty,
  getAllContactIds_result_e = P.Nothing}
data GetAuthQrcode_args = GetAuthQrcode_args  { getAuthQrcode_args_keepLoggedIn :: P.Bool
  , getAuthQrcode_args_systemName :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthQrcode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthQrcode_args_keepLoggedIn record   `H.hashWithSalt` getAuthQrcode_args_systemName record  
instance QC.Arbitrary GetAuthQrcode_args where 
  arbitrary = M.liftM GetAuthQrcode_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetAuthQrcode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthQrcode_args{getAuthQrcode_args_keepLoggedIn = getAuthQrcode_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_GetAuthQrcode_args{getAuthQrcode_args_keepLoggedIn = getAuthQrcode_args_keepLoggedIn obj}
    , if obj == default_GetAuthQrcode_args{getAuthQrcode_args_systemName = getAuthQrcode_args_systemName obj} then P.Nothing else P.Just $ default_GetAuthQrcode_args{getAuthQrcode_args_systemName = getAuthQrcode_args_systemName obj}
    ]
from_GetAuthQrcode_args :: GetAuthQrcode_args -> T.ThriftVal
from_GetAuthQrcode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6818 -> P.Just (2, ("keepLoggedIn",T.TBool _v6818))) $ getAuthQrcode_args_keepLoggedIn record
  , (\_v6818 -> P.Just (3, ("systemName",T.TString $ E.encodeUtf8 _v6818))) $ getAuthQrcode_args_systemName record
  ]
write_GetAuthQrcode_args :: T.Protocol p => p -> GetAuthQrcode_args -> P.IO ()
write_GetAuthQrcode_args oprot record = T.writeVal oprot $ from_GetAuthQrcode_args record
encode_GetAuthQrcode_args :: T.StatelessProtocol p => p -> GetAuthQrcode_args -> LBS.ByteString
encode_GetAuthQrcode_args oprot record = T.serializeVal oprot $ from_GetAuthQrcode_args record
to_GetAuthQrcode_args :: T.ThriftVal -> GetAuthQrcode_args
to_GetAuthQrcode_args (T.TStruct fields) = GetAuthQrcode_args{
  getAuthQrcode_args_keepLoggedIn = P.maybe (getAuthQrcode_args_keepLoggedIn default_GetAuthQrcode_args) (\(_,_val6820) -> (case _val6820 of {T.TBool _val6821 -> _val6821; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getAuthQrcode_args_systemName = P.maybe (getAuthQrcode_args_systemName default_GetAuthQrcode_args) (\(_,_val6820) -> (case _val6820 of {T.TString _val6822 -> E.decodeUtf8 _val6822; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetAuthQrcode_args _ = P.error "not a struct"
read_GetAuthQrcode_args :: T.Protocol p => p -> P.IO GetAuthQrcode_args
read_GetAuthQrcode_args iprot = to_GetAuthQrcode_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthQrcode_args)
decode_GetAuthQrcode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthQrcode_args
decode_GetAuthQrcode_args iprot bs = to_GetAuthQrcode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthQrcode_args) bs
typemap_GetAuthQrcode_args :: T.TypeMap
typemap_GetAuthQrcode_args = Map.fromList [(2,("keepLoggedIn",T.T_BOOL)),(3,("systemName",T.T_STRING))]
default_GetAuthQrcode_args :: GetAuthQrcode_args
default_GetAuthQrcode_args = GetAuthQrcode_args{
  getAuthQrcode_args_keepLoggedIn = P.False,
  getAuthQrcode_args_systemName = ""}
data GetAuthQrcode_result = GetAuthQrcode_result  { getAuthQrcode_result_success :: AuthQrcode
  , getAuthQrcode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAuthQrcode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAuthQrcode_result_success record   `H.hashWithSalt` getAuthQrcode_result_e record  
instance QC.Arbitrary GetAuthQrcode_result where 
  arbitrary = M.liftM GetAuthQrcode_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAuthQrcode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAuthQrcode_result{getAuthQrcode_result_success = getAuthQrcode_result_success obj} then P.Nothing else P.Just $ default_GetAuthQrcode_result{getAuthQrcode_result_success = getAuthQrcode_result_success obj}
    , if obj == default_GetAuthQrcode_result{getAuthQrcode_result_e = getAuthQrcode_result_e obj} then P.Nothing else P.Just $ default_GetAuthQrcode_result{getAuthQrcode_result_e = getAuthQrcode_result_e obj}
    ]
from_GetAuthQrcode_result :: GetAuthQrcode_result -> T.ThriftVal
from_GetAuthQrcode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6825 -> (1, ("e",from_TalkException _v6825))) <$> getAuthQrcode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6825 -> P.Just (0, ("success",from_AuthQrcode _v6825))) $ getAuthQrcode_result_success record
    , (\_v6825 -> (1, ("e",from_TalkException _v6825))) <$> getAuthQrcode_result_e record
    ]
    )
write_GetAuthQrcode_result :: T.Protocol p => p -> GetAuthQrcode_result -> P.IO ()
write_GetAuthQrcode_result oprot record = T.writeVal oprot $ from_GetAuthQrcode_result record
encode_GetAuthQrcode_result :: T.StatelessProtocol p => p -> GetAuthQrcode_result -> LBS.ByteString
encode_GetAuthQrcode_result oprot record = T.serializeVal oprot $ from_GetAuthQrcode_result record
to_GetAuthQrcode_result :: T.ThriftVal -> GetAuthQrcode_result
to_GetAuthQrcode_result (T.TStruct fields) = GetAuthQrcode_result{
  getAuthQrcode_result_success = P.maybe (getAuthQrcode_result_success default_GetAuthQrcode_result) (\(_,_val6827) -> (case _val6827 of {T.TStruct _val6828 -> (to_AuthQrcode (T.TStruct _val6828)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAuthQrcode_result_e = P.maybe (P.Nothing) (\(_,_val6827) -> P.Just (case _val6827 of {T.TStruct _val6829 -> (to_TalkException (T.TStruct _val6829)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAuthQrcode_result _ = P.error "not a struct"
read_GetAuthQrcode_result :: T.Protocol p => p -> P.IO GetAuthQrcode_result
read_GetAuthQrcode_result iprot = to_GetAuthQrcode_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAuthQrcode_result)
decode_GetAuthQrcode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAuthQrcode_result
decode_GetAuthQrcode_result iprot bs = to_GetAuthQrcode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAuthQrcode_result) bs
typemap_GetAuthQrcode_result :: T.TypeMap
typemap_GetAuthQrcode_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AuthQrcode))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAuthQrcode_result :: GetAuthQrcode_result
default_GetAuthQrcode_result = GetAuthQrcode_result{
  getAuthQrcode_result_success = default_AuthQrcode,
  getAuthQrcode_result_e = P.Nothing}
data GetBlockedContactIds_args = GetBlockedContactIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBlockedContactIds_args where 
  arbitrary = QC.elements [GetBlockedContactIds_args]
from_GetBlockedContactIds_args :: GetBlockedContactIds_args -> T.ThriftVal
from_GetBlockedContactIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBlockedContactIds_args :: T.Protocol p => p -> GetBlockedContactIds_args -> P.IO ()
write_GetBlockedContactIds_args oprot record = T.writeVal oprot $ from_GetBlockedContactIds_args record
encode_GetBlockedContactIds_args :: T.StatelessProtocol p => p -> GetBlockedContactIds_args -> LBS.ByteString
encode_GetBlockedContactIds_args oprot record = T.serializeVal oprot $ from_GetBlockedContactIds_args record
to_GetBlockedContactIds_args :: T.ThriftVal -> GetBlockedContactIds_args
to_GetBlockedContactIds_args (T.TStruct fields) = GetBlockedContactIds_args{

  }
to_GetBlockedContactIds_args _ = P.error "not a struct"
read_GetBlockedContactIds_args :: T.Protocol p => p -> P.IO GetBlockedContactIds_args
read_GetBlockedContactIds_args iprot = to_GetBlockedContactIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_args)
decode_GetBlockedContactIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIds_args
decode_GetBlockedContactIds_args iprot bs = to_GetBlockedContactIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_args) bs
typemap_GetBlockedContactIds_args :: T.TypeMap
typemap_GetBlockedContactIds_args = Map.fromList []
default_GetBlockedContactIds_args :: GetBlockedContactIds_args
default_GetBlockedContactIds_args = GetBlockedContactIds_args{
}
data GetBlockedContactIds_result = GetBlockedContactIds_result  { getBlockedContactIds_result_success :: (Vector.Vector LT.Text)
  , getBlockedContactIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIds_result_success record   `H.hashWithSalt` getBlockedContactIds_result_e record  
instance QC.Arbitrary GetBlockedContactIds_result where 
  arbitrary = M.liftM GetBlockedContactIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIds_result{getBlockedContactIds_result_success = getBlockedContactIds_result_success obj} then P.Nothing else P.Just $ default_GetBlockedContactIds_result{getBlockedContactIds_result_success = getBlockedContactIds_result_success obj}
    , if obj == default_GetBlockedContactIds_result{getBlockedContactIds_result_e = getBlockedContactIds_result_e obj} then P.Nothing else P.Just $ default_GetBlockedContactIds_result{getBlockedContactIds_result_e = getBlockedContactIds_result_e obj}
    ]
from_GetBlockedContactIds_result :: GetBlockedContactIds_result -> T.ThriftVal
from_GetBlockedContactIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6837 -> (1, ("e",from_TalkException _v6837))) <$> getBlockedContactIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6837 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6839 -> T.TString $ E.encodeUtf8 _v6839) $ Vector.toList _v6837))) $ getBlockedContactIds_result_success record
    , (\_v6837 -> (1, ("e",from_TalkException _v6837))) <$> getBlockedContactIds_result_e record
    ]
    )
write_GetBlockedContactIds_result :: T.Protocol p => p -> GetBlockedContactIds_result -> P.IO ()
write_GetBlockedContactIds_result oprot record = T.writeVal oprot $ from_GetBlockedContactIds_result record
encode_GetBlockedContactIds_result :: T.StatelessProtocol p => p -> GetBlockedContactIds_result -> LBS.ByteString
encode_GetBlockedContactIds_result oprot record = T.serializeVal oprot $ from_GetBlockedContactIds_result record
to_GetBlockedContactIds_result :: T.ThriftVal -> GetBlockedContactIds_result
to_GetBlockedContactIds_result (T.TStruct fields) = GetBlockedContactIds_result{
  getBlockedContactIds_result_success = P.maybe (getBlockedContactIds_result_success default_GetBlockedContactIds_result) (\(_,_val6841) -> (case _val6841 of {T.TList _ _val6842 -> (Vector.fromList $ P.map (\_v6843 -> (case _v6843 of {T.TString _val6844 -> E.decodeUtf8 _val6844; _ -> P.error "wrong type"})) _val6842); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedContactIds_result_e = P.maybe (P.Nothing) (\(_,_val6841) -> P.Just (case _val6841 of {T.TStruct _val6845 -> (to_TalkException (T.TStruct _val6845)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedContactIds_result _ = P.error "not a struct"
read_GetBlockedContactIds_result :: T.Protocol p => p -> P.IO GetBlockedContactIds_result
read_GetBlockedContactIds_result iprot = to_GetBlockedContactIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_result)
decode_GetBlockedContactIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIds_result
decode_GetBlockedContactIds_result iprot bs = to_GetBlockedContactIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIds_result) bs
typemap_GetBlockedContactIds_result :: T.TypeMap
typemap_GetBlockedContactIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedContactIds_result :: GetBlockedContactIds_result
default_GetBlockedContactIds_result = GetBlockedContactIds_result{
  getBlockedContactIds_result_success = Vector.empty,
  getBlockedContactIds_result_e = P.Nothing}
data RegisterWithPhoneNumber_args = RegisterWithPhoneNumber_args  { registerWithPhoneNumber_args_sessionId :: LT.Text
  , registerWithPhoneNumber_args_migrationPincodeSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithPhoneNumber_args_sessionId record   `H.hashWithSalt` registerWithPhoneNumber_args_migrationPincodeSessionId record  
instance QC.Arbitrary RegisterWithPhoneNumber_args where 
  arbitrary = M.liftM RegisterWithPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithPhoneNumber_args{registerWithPhoneNumber_args_sessionId = registerWithPhoneNumber_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumber_args{registerWithPhoneNumber_args_sessionId = registerWithPhoneNumber_args_sessionId obj}
    , if obj == default_RegisterWithPhoneNumber_args{registerWithPhoneNumber_args_migrationPincodeSessionId = registerWithPhoneNumber_args_migrationPincodeSessionId obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumber_args{registerWithPhoneNumber_args_migrationPincodeSessionId = registerWithPhoneNumber_args_migrationPincodeSessionId obj}
    ]
from_RegisterWithPhoneNumber_args :: RegisterWithPhoneNumber_args -> T.ThriftVal
from_RegisterWithPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6848 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6848))) $ registerWithPhoneNumber_args_sessionId record
  , (\_v6848 -> P.Just (3, ("migrationPincodeSessionId",T.TString $ E.encodeUtf8 _v6848))) $ registerWithPhoneNumber_args_migrationPincodeSessionId record
  ]
write_RegisterWithPhoneNumber_args :: T.Protocol p => p -> RegisterWithPhoneNumber_args -> P.IO ()
write_RegisterWithPhoneNumber_args oprot record = T.writeVal oprot $ from_RegisterWithPhoneNumber_args record
encode_RegisterWithPhoneNumber_args :: T.StatelessProtocol p => p -> RegisterWithPhoneNumber_args -> LBS.ByteString
encode_RegisterWithPhoneNumber_args oprot record = T.serializeVal oprot $ from_RegisterWithPhoneNumber_args record
to_RegisterWithPhoneNumber_args :: T.ThriftVal -> RegisterWithPhoneNumber_args
to_RegisterWithPhoneNumber_args (T.TStruct fields) = RegisterWithPhoneNumber_args{
  registerWithPhoneNumber_args_sessionId = P.maybe (registerWithPhoneNumber_args_sessionId default_RegisterWithPhoneNumber_args) (\(_,_val6850) -> (case _val6850 of {T.TString _val6851 -> E.decodeUtf8 _val6851; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithPhoneNumber_args_migrationPincodeSessionId = P.maybe (registerWithPhoneNumber_args_migrationPincodeSessionId default_RegisterWithPhoneNumber_args) (\(_,_val6850) -> (case _val6850 of {T.TString _val6852 -> E.decodeUtf8 _val6852; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterWithPhoneNumber_args _ = P.error "not a struct"
read_RegisterWithPhoneNumber_args :: T.Protocol p => p -> P.IO RegisterWithPhoneNumber_args
read_RegisterWithPhoneNumber_args iprot = to_RegisterWithPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumber_args)
decode_RegisterWithPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithPhoneNumber_args
decode_RegisterWithPhoneNumber_args iprot bs = to_RegisterWithPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumber_args) bs
typemap_RegisterWithPhoneNumber_args :: T.TypeMap
typemap_RegisterWithPhoneNumber_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("migrationPincodeSessionId",T.T_STRING))]
default_RegisterWithPhoneNumber_args :: RegisterWithPhoneNumber_args
default_RegisterWithPhoneNumber_args = RegisterWithPhoneNumber_args{
  registerWithPhoneNumber_args_sessionId = "",
  registerWithPhoneNumber_args_migrationPincodeSessionId = ""}
data RegisterWithPhoneNumber_result = RegisterWithPhoneNumber_result  { registerWithPhoneNumber_result_success :: RegisterWithPhoneNumberResult
  , registerWithPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithPhoneNumber_result_success record   `H.hashWithSalt` registerWithPhoneNumber_result_e record  
instance QC.Arbitrary RegisterWithPhoneNumber_result where 
  arbitrary = M.liftM RegisterWithPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_success = registerWithPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_success = registerWithPhoneNumber_result_success obj}
    , if obj == default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_e = registerWithPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_e = registerWithPhoneNumber_result_e obj}
    ]
from_RegisterWithPhoneNumber_result :: RegisterWithPhoneNumber_result -> T.ThriftVal
from_RegisterWithPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6855 -> (1, ("e",from_TalkException _v6855))) <$> registerWithPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6855 -> P.Just (0, ("success",from_RegisterWithPhoneNumberResult _v6855))) $ registerWithPhoneNumber_result_success record
    , (\_v6855 -> (1, ("e",from_TalkException _v6855))) <$> registerWithPhoneNumber_result_e record
    ]
    )
write_RegisterWithPhoneNumber_result :: T.Protocol p => p -> RegisterWithPhoneNumber_result -> P.IO ()
write_RegisterWithPhoneNumber_result oprot record = T.writeVal oprot $ from_RegisterWithPhoneNumber_result record
encode_RegisterWithPhoneNumber_result :: T.StatelessProtocol p => p -> RegisterWithPhoneNumber_result -> LBS.ByteString
encode_RegisterWithPhoneNumber_result oprot record = T.serializeVal oprot $ from_RegisterWithPhoneNumber_result record
to_RegisterWithPhoneNumber_result :: T.ThriftVal -> RegisterWithPhoneNumber_result
to_RegisterWithPhoneNumber_result (T.TStruct fields) = RegisterWithPhoneNumber_result{
  registerWithPhoneNumber_result_success = P.maybe (registerWithPhoneNumber_result_success default_RegisterWithPhoneNumber_result) (\(_,_val6857) -> (case _val6857 of {T.TStruct _val6858 -> (to_RegisterWithPhoneNumberResult (T.TStruct _val6858)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val6857) -> P.Just (case _val6857 of {T.TStruct _val6859 -> (to_TalkException (T.TStruct _val6859)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithPhoneNumber_result _ = P.error "not a struct"
read_RegisterWithPhoneNumber_result :: T.Protocol p => p -> P.IO RegisterWithPhoneNumber_result
read_RegisterWithPhoneNumber_result iprot = to_RegisterWithPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumber_result)
decode_RegisterWithPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithPhoneNumber_result
decode_RegisterWithPhoneNumber_result iprot bs = to_RegisterWithPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumber_result) bs
typemap_RegisterWithPhoneNumber_result :: T.TypeMap
typemap_RegisterWithPhoneNumber_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RegisterWithPhoneNumberResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithPhoneNumber_result :: RegisterWithPhoneNumber_result
default_RegisterWithPhoneNumber_result = RegisterWithPhoneNumber_result{
  registerWithPhoneNumber_result_success = default_RegisterWithPhoneNumberResult,
  registerWithPhoneNumber_result_e = P.Nothing}
data RegisterWithPhoneNumberAndPassword_args = RegisterWithPhoneNumberAndPassword_args  { registerWithPhoneNumberAndPassword_args_sessionId :: LT.Text
  , registerWithPhoneNumberAndPassword_args_keynm :: LT.Text
  , registerWithPhoneNumberAndPassword_args_encrypted :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithPhoneNumberAndPassword_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithPhoneNumberAndPassword_args_sessionId record   `H.hashWithSalt` registerWithPhoneNumberAndPassword_args_keynm record   `H.hashWithSalt` registerWithPhoneNumberAndPassword_args_encrypted record  
instance QC.Arbitrary RegisterWithPhoneNumberAndPassword_args where 
  arbitrary = M.liftM RegisterWithPhoneNumberAndPassword_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithPhoneNumberAndPassword_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_sessionId = registerWithPhoneNumberAndPassword_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_sessionId = registerWithPhoneNumberAndPassword_args_sessionId obj}
    , if obj == default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_keynm = registerWithPhoneNumberAndPassword_args_keynm obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_keynm = registerWithPhoneNumberAndPassword_args_keynm obj}
    , if obj == default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_encrypted = registerWithPhoneNumberAndPassword_args_encrypted obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberAndPassword_args{registerWithPhoneNumberAndPassword_args_encrypted = registerWithPhoneNumberAndPassword_args_encrypted obj}
    ]
from_RegisterWithPhoneNumberAndPassword_args :: RegisterWithPhoneNumberAndPassword_args -> T.ThriftVal
from_RegisterWithPhoneNumberAndPassword_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6862 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6862))) $ registerWithPhoneNumberAndPassword_args_sessionId record
  , (\_v6862 -> P.Just (3, ("keynm",T.TString $ E.encodeUtf8 _v6862))) $ registerWithPhoneNumberAndPassword_args_keynm record
  , (\_v6862 -> P.Just (4, ("encrypted",T.TString $ E.encodeUtf8 _v6862))) $ registerWithPhoneNumberAndPassword_args_encrypted record
  ]
write_RegisterWithPhoneNumberAndPassword_args :: T.Protocol p => p -> RegisterWithPhoneNumberAndPassword_args -> P.IO ()
write_RegisterWithPhoneNumberAndPassword_args oprot record = T.writeVal oprot $ from_RegisterWithPhoneNumberAndPassword_args record
encode_RegisterWithPhoneNumberAndPassword_args :: T.StatelessProtocol p => p -> RegisterWithPhoneNumberAndPassword_args -> LBS.ByteString
encode_RegisterWithPhoneNumberAndPassword_args oprot record = T.serializeVal oprot $ from_RegisterWithPhoneNumberAndPassword_args record
to_RegisterWithPhoneNumberAndPassword_args :: T.ThriftVal -> RegisterWithPhoneNumberAndPassword_args
to_RegisterWithPhoneNumberAndPassword_args (T.TStruct fields) = RegisterWithPhoneNumberAndPassword_args{
  registerWithPhoneNumberAndPassword_args_sessionId = P.maybe (registerWithPhoneNumberAndPassword_args_sessionId default_RegisterWithPhoneNumberAndPassword_args) (\(_,_val6864) -> (case _val6864 of {T.TString _val6865 -> E.decodeUtf8 _val6865; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithPhoneNumberAndPassword_args_keynm = P.maybe (registerWithPhoneNumberAndPassword_args_keynm default_RegisterWithPhoneNumberAndPassword_args) (\(_,_val6864) -> (case _val6864 of {T.TString _val6866 -> E.decodeUtf8 _val6866; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithPhoneNumberAndPassword_args_encrypted = P.maybe (registerWithPhoneNumberAndPassword_args_encrypted default_RegisterWithPhoneNumberAndPassword_args) (\(_,_val6864) -> (case _val6864 of {T.TString _val6867 -> E.decodeUtf8 _val6867; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterWithPhoneNumberAndPassword_args _ = P.error "not a struct"
read_RegisterWithPhoneNumberAndPassword_args :: T.Protocol p => p -> P.IO RegisterWithPhoneNumberAndPassword_args
read_RegisterWithPhoneNumberAndPassword_args iprot = to_RegisterWithPhoneNumberAndPassword_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberAndPassword_args)
decode_RegisterWithPhoneNumberAndPassword_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithPhoneNumberAndPassword_args
decode_RegisterWithPhoneNumberAndPassword_args iprot bs = to_RegisterWithPhoneNumberAndPassword_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberAndPassword_args) bs
typemap_RegisterWithPhoneNumberAndPassword_args :: T.TypeMap
typemap_RegisterWithPhoneNumberAndPassword_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("keynm",T.T_STRING)),(4,("encrypted",T.T_STRING))]
default_RegisterWithPhoneNumberAndPassword_args :: RegisterWithPhoneNumberAndPassword_args
default_RegisterWithPhoneNumberAndPassword_args = RegisterWithPhoneNumberAndPassword_args{
  registerWithPhoneNumberAndPassword_args_sessionId = "",
  registerWithPhoneNumberAndPassword_args_keynm = "",
  registerWithPhoneNumberAndPassword_args_encrypted = ""}
data RegisterWithPhoneNumberAndPassword_result = RegisterWithPhoneNumberAndPassword_result  { registerWithPhoneNumberAndPassword_result_success :: RegisterWithPhoneNumberResult
  , registerWithPhoneNumberAndPassword_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithPhoneNumberAndPassword_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithPhoneNumberAndPassword_result_success record   `H.hashWithSalt` registerWithPhoneNumberAndPassword_result_e record  
instance QC.Arbitrary RegisterWithPhoneNumberAndPassword_result where 
  arbitrary = M.liftM RegisterWithPhoneNumberAndPassword_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithPhoneNumberAndPassword_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_success = registerWithPhoneNumberAndPassword_result_success obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_success = registerWithPhoneNumberAndPassword_result_success obj}
    , if obj == default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_e = registerWithPhoneNumberAndPassword_result_e obj} then P.Nothing else P.Just $ default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_e = registerWithPhoneNumberAndPassword_result_e obj}
    ]
from_RegisterWithPhoneNumberAndPassword_result :: RegisterWithPhoneNumberAndPassword_result -> T.ThriftVal
from_RegisterWithPhoneNumberAndPassword_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6870 -> (1, ("e",from_TalkException _v6870))) <$> registerWithPhoneNumberAndPassword_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6870 -> P.Just (0, ("success",from_RegisterWithPhoneNumberResult _v6870))) $ registerWithPhoneNumberAndPassword_result_success record
    , (\_v6870 -> (1, ("e",from_TalkException _v6870))) <$> registerWithPhoneNumberAndPassword_result_e record
    ]
    )
write_RegisterWithPhoneNumberAndPassword_result :: T.Protocol p => p -> RegisterWithPhoneNumberAndPassword_result -> P.IO ()
write_RegisterWithPhoneNumberAndPassword_result oprot record = T.writeVal oprot $ from_RegisterWithPhoneNumberAndPassword_result record
encode_RegisterWithPhoneNumberAndPassword_result :: T.StatelessProtocol p => p -> RegisterWithPhoneNumberAndPassword_result -> LBS.ByteString
encode_RegisterWithPhoneNumberAndPassword_result oprot record = T.serializeVal oprot $ from_RegisterWithPhoneNumberAndPassword_result record
to_RegisterWithPhoneNumberAndPassword_result :: T.ThriftVal -> RegisterWithPhoneNumberAndPassword_result
to_RegisterWithPhoneNumberAndPassword_result (T.TStruct fields) = RegisterWithPhoneNumberAndPassword_result{
  registerWithPhoneNumberAndPassword_result_success = P.maybe (registerWithPhoneNumberAndPassword_result_success default_RegisterWithPhoneNumberAndPassword_result) (\(_,_val6872) -> (case _val6872 of {T.TStruct _val6873 -> (to_RegisterWithPhoneNumberResult (T.TStruct _val6873)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithPhoneNumberAndPassword_result_e = P.maybe (P.Nothing) (\(_,_val6872) -> P.Just (case _val6872 of {T.TStruct _val6874 -> (to_TalkException (T.TStruct _val6874)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithPhoneNumberAndPassword_result _ = P.error "not a struct"
read_RegisterWithPhoneNumberAndPassword_result :: T.Protocol p => p -> P.IO RegisterWithPhoneNumberAndPassword_result
read_RegisterWithPhoneNumberAndPassword_result iprot = to_RegisterWithPhoneNumberAndPassword_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberAndPassword_result)
decode_RegisterWithPhoneNumberAndPassword_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithPhoneNumberAndPassword_result
decode_RegisterWithPhoneNumberAndPassword_result iprot bs = to_RegisterWithPhoneNumberAndPassword_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithPhoneNumberAndPassword_result) bs
typemap_RegisterWithPhoneNumberAndPassword_result :: T.TypeMap
typemap_RegisterWithPhoneNumberAndPassword_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RegisterWithPhoneNumberResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithPhoneNumberAndPassword_result :: RegisterWithPhoneNumberAndPassword_result
default_RegisterWithPhoneNumberAndPassword_result = RegisterWithPhoneNumberAndPassword_result{
  registerWithPhoneNumberAndPassword_result_success = default_RegisterWithPhoneNumberResult,
  registerWithPhoneNumberAndPassword_result_e = P.Nothing}
data GetAnalyticsInfo_args = GetAnalyticsInfo_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAnalyticsInfo_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAnalyticsInfo_args where 
  arbitrary = QC.elements [GetAnalyticsInfo_args]
from_GetAnalyticsInfo_args :: GetAnalyticsInfo_args -> T.ThriftVal
from_GetAnalyticsInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAnalyticsInfo_args :: T.Protocol p => p -> GetAnalyticsInfo_args -> P.IO ()
write_GetAnalyticsInfo_args oprot record = T.writeVal oprot $ from_GetAnalyticsInfo_args record
encode_GetAnalyticsInfo_args :: T.StatelessProtocol p => p -> GetAnalyticsInfo_args -> LBS.ByteString
encode_GetAnalyticsInfo_args oprot record = T.serializeVal oprot $ from_GetAnalyticsInfo_args record
to_GetAnalyticsInfo_args :: T.ThriftVal -> GetAnalyticsInfo_args
to_GetAnalyticsInfo_args (T.TStruct fields) = GetAnalyticsInfo_args{

  }
to_GetAnalyticsInfo_args _ = P.error "not a struct"
read_GetAnalyticsInfo_args :: T.Protocol p => p -> P.IO GetAnalyticsInfo_args
read_GetAnalyticsInfo_args iprot = to_GetAnalyticsInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAnalyticsInfo_args)
decode_GetAnalyticsInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAnalyticsInfo_args
decode_GetAnalyticsInfo_args iprot bs = to_GetAnalyticsInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAnalyticsInfo_args) bs
typemap_GetAnalyticsInfo_args :: T.TypeMap
typemap_GetAnalyticsInfo_args = Map.fromList []
default_GetAnalyticsInfo_args :: GetAnalyticsInfo_args
default_GetAnalyticsInfo_args = GetAnalyticsInfo_args{
}
data GetAnalyticsInfo_result = GetAnalyticsInfo_result  { getAnalyticsInfo_result_success :: AnalyticsInfo
  , getAnalyticsInfo_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAnalyticsInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAnalyticsInfo_result_success record   `H.hashWithSalt` getAnalyticsInfo_result_e record  
instance QC.Arbitrary GetAnalyticsInfo_result where 
  arbitrary = M.liftM GetAnalyticsInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAnalyticsInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAnalyticsInfo_result{getAnalyticsInfo_result_success = getAnalyticsInfo_result_success obj} then P.Nothing else P.Just $ default_GetAnalyticsInfo_result{getAnalyticsInfo_result_success = getAnalyticsInfo_result_success obj}
    , if obj == default_GetAnalyticsInfo_result{getAnalyticsInfo_result_e = getAnalyticsInfo_result_e obj} then P.Nothing else P.Just $ default_GetAnalyticsInfo_result{getAnalyticsInfo_result_e = getAnalyticsInfo_result_e obj}
    ]
from_GetAnalyticsInfo_result :: GetAnalyticsInfo_result -> T.ThriftVal
from_GetAnalyticsInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6882 -> (1, ("e",from_TalkException _v6882))) <$> getAnalyticsInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6882 -> P.Just (0, ("success",from_AnalyticsInfo _v6882))) $ getAnalyticsInfo_result_success record
    , (\_v6882 -> (1, ("e",from_TalkException _v6882))) <$> getAnalyticsInfo_result_e record
    ]
    )
write_GetAnalyticsInfo_result :: T.Protocol p => p -> GetAnalyticsInfo_result -> P.IO ()
write_GetAnalyticsInfo_result oprot record = T.writeVal oprot $ from_GetAnalyticsInfo_result record
encode_GetAnalyticsInfo_result :: T.StatelessProtocol p => p -> GetAnalyticsInfo_result -> LBS.ByteString
encode_GetAnalyticsInfo_result oprot record = T.serializeVal oprot $ from_GetAnalyticsInfo_result record
to_GetAnalyticsInfo_result :: T.ThriftVal -> GetAnalyticsInfo_result
to_GetAnalyticsInfo_result (T.TStruct fields) = GetAnalyticsInfo_result{
  getAnalyticsInfo_result_success = P.maybe (getAnalyticsInfo_result_success default_GetAnalyticsInfo_result) (\(_,_val6884) -> (case _val6884 of {T.TStruct _val6885 -> (to_AnalyticsInfo (T.TStruct _val6885)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAnalyticsInfo_result_e = P.maybe (P.Nothing) (\(_,_val6884) -> P.Just (case _val6884 of {T.TStruct _val6886 -> (to_TalkException (T.TStruct _val6886)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAnalyticsInfo_result _ = P.error "not a struct"
read_GetAnalyticsInfo_result :: T.Protocol p => p -> P.IO GetAnalyticsInfo_result
read_GetAnalyticsInfo_result iprot = to_GetAnalyticsInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAnalyticsInfo_result)
decode_GetAnalyticsInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAnalyticsInfo_result
decode_GetAnalyticsInfo_result iprot bs = to_GetAnalyticsInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAnalyticsInfo_result) bs
typemap_GetAnalyticsInfo_result :: T.TypeMap
typemap_GetAnalyticsInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AnalyticsInfo))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAnalyticsInfo_result :: GetAnalyticsInfo_result
default_GetAnalyticsInfo_result = GetAnalyticsInfo_result{
  getAnalyticsInfo_result_success = default_AnalyticsInfo,
  getAnalyticsInfo_result_e = P.Nothing}
data ReportClientStatistics_args = ReportClientStatistics_args  { reportClientStatistics_args_reqSeq :: I.Int32
  , reportClientStatistics_args_category :: ReportCategory
  , reportClientStatistics_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportClientStatistics_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportClientStatistics_args_reqSeq record   `H.hashWithSalt` reportClientStatistics_args_category record   `H.hashWithSalt` reportClientStatistics_args_count record  
instance QC.Arbitrary ReportClientStatistics_args where 
  arbitrary = M.liftM ReportClientStatistics_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportClientStatistics_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportClientStatistics_args{reportClientStatistics_args_reqSeq = reportClientStatistics_args_reqSeq obj} then P.Nothing else P.Just $ default_ReportClientStatistics_args{reportClientStatistics_args_reqSeq = reportClientStatistics_args_reqSeq obj}
    , if obj == default_ReportClientStatistics_args{reportClientStatistics_args_category = reportClientStatistics_args_category obj} then P.Nothing else P.Just $ default_ReportClientStatistics_args{reportClientStatistics_args_category = reportClientStatistics_args_category obj}
    , if obj == default_ReportClientStatistics_args{reportClientStatistics_args_count = reportClientStatistics_args_count obj} then P.Nothing else P.Just $ default_ReportClientStatistics_args{reportClientStatistics_args_count = reportClientStatistics_args_count obj}
    ]
from_ReportClientStatistics_args :: ReportClientStatistics_args -> T.ThriftVal
from_ReportClientStatistics_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6889 -> P.Just (1, ("reqSeq",T.TI32 _v6889))) $ reportClientStatistics_args_reqSeq record
  , (\_v6889 -> P.Just (2, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v6889))) $ reportClientStatistics_args_category record
  , (\_v6889 -> P.Just (3, ("count",T.TI32 _v6889))) $ reportClientStatistics_args_count record
  ]
write_ReportClientStatistics_args :: T.Protocol p => p -> ReportClientStatistics_args -> P.IO ()
write_ReportClientStatistics_args oprot record = T.writeVal oprot $ from_ReportClientStatistics_args record
encode_ReportClientStatistics_args :: T.StatelessProtocol p => p -> ReportClientStatistics_args -> LBS.ByteString
encode_ReportClientStatistics_args oprot record = T.serializeVal oprot $ from_ReportClientStatistics_args record
to_ReportClientStatistics_args :: T.ThriftVal -> ReportClientStatistics_args
to_ReportClientStatistics_args (T.TStruct fields) = ReportClientStatistics_args{
  reportClientStatistics_args_reqSeq = P.maybe (reportClientStatistics_args_reqSeq default_ReportClientStatistics_args) (\(_,_val6891) -> (case _val6891 of {T.TI32 _val6892 -> _val6892; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  reportClientStatistics_args_category = P.maybe (reportClientStatistics_args_category default_ReportClientStatistics_args) (\(_,_val6891) -> (case _val6891 of {T.TI32 _val6893 -> P.toEnum $ P.fromIntegral _val6893; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportClientStatistics_args_count = P.maybe (reportClientStatistics_args_count default_ReportClientStatistics_args) (\(_,_val6891) -> (case _val6891 of {T.TI32 _val6894 -> _val6894; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportClientStatistics_args _ = P.error "not a struct"
read_ReportClientStatistics_args :: T.Protocol p => p -> P.IO ReportClientStatistics_args
read_ReportClientStatistics_args iprot = to_ReportClientStatistics_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportClientStatistics_args)
decode_ReportClientStatistics_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportClientStatistics_args
decode_ReportClientStatistics_args iprot bs = to_ReportClientStatistics_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportClientStatistics_args) bs
typemap_ReportClientStatistics_args :: T.TypeMap
typemap_ReportClientStatistics_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("category",T.T_I32)),(3,("count",T.T_I32))]
default_ReportClientStatistics_args :: ReportClientStatistics_args
default_ReportClientStatistics_args = ReportClientStatistics_args{
  reportClientStatistics_args_reqSeq = 0,
  reportClientStatistics_args_category = (P.toEnum 0),
  reportClientStatistics_args_count = 0}
data ReportClientStatistics_result = ReportClientStatistics_result  { reportClientStatistics_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportClientStatistics_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportClientStatistics_result_e record  
instance QC.Arbitrary ReportClientStatistics_result where 
  arbitrary = M.liftM ReportClientStatistics_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportClientStatistics_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportClientStatistics_result{reportClientStatistics_result_e = reportClientStatistics_result_e obj} then P.Nothing else P.Just $ default_ReportClientStatistics_result{reportClientStatistics_result_e = reportClientStatistics_result_e obj}
    ]
from_ReportClientStatistics_result :: ReportClientStatistics_result -> T.ThriftVal
from_ReportClientStatistics_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6897 -> (1, ("e",from_TalkException _v6897))) <$> reportClientStatistics_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6897 -> (1, ("e",from_TalkException _v6897))) <$> reportClientStatistics_result_e record
    ]
    )
write_ReportClientStatistics_result :: T.Protocol p => p -> ReportClientStatistics_result -> P.IO ()
write_ReportClientStatistics_result oprot record = T.writeVal oprot $ from_ReportClientStatistics_result record
encode_ReportClientStatistics_result :: T.StatelessProtocol p => p -> ReportClientStatistics_result -> LBS.ByteString
encode_ReportClientStatistics_result oprot record = T.serializeVal oprot $ from_ReportClientStatistics_result record
to_ReportClientStatistics_result :: T.ThriftVal -> ReportClientStatistics_result
to_ReportClientStatistics_result (T.TStruct fields) = ReportClientStatistics_result{
  reportClientStatistics_result_e = P.maybe (P.Nothing) (\(_,_val6899) -> P.Just (case _val6899 of {T.TStruct _val6900 -> (to_TalkException (T.TStruct _val6900)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportClientStatistics_result _ = P.error "not a struct"
read_ReportClientStatistics_result :: T.Protocol p => p -> P.IO ReportClientStatistics_result
read_ReportClientStatistics_result iprot = to_ReportClientStatistics_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportClientStatistics_result)
decode_ReportClientStatistics_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportClientStatistics_result
decode_ReportClientStatistics_result iprot bs = to_ReportClientStatistics_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportClientStatistics_result) bs
typemap_ReportClientStatistics_result :: T.TypeMap
typemap_ReportClientStatistics_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportClientStatistics_result :: ReportClientStatistics_result
default_ReportClientStatistics_result = ReportClientStatistics_result{
  reportClientStatistics_result_e = P.Nothing}
data VerifyPhoneNumberForLogin_args = VerifyPhoneNumberForLogin_args  { verifyPhoneNumberForLogin_args_verifierFromPhone :: LT.Text
  , verifyPhoneNumberForLogin_args_pinCodeForPhone :: LT.Text
  , verifyPhoneNumberForLogin_args_verifierFromLogin :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhoneNumberForLogin_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhoneNumberForLogin_args_verifierFromPhone record   `H.hashWithSalt` verifyPhoneNumberForLogin_args_pinCodeForPhone record   `H.hashWithSalt` verifyPhoneNumberForLogin_args_verifierFromLogin record  
instance QC.Arbitrary VerifyPhoneNumberForLogin_args where 
  arbitrary = M.liftM VerifyPhoneNumberForLogin_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyPhoneNumberForLogin_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_verifierFromPhone = verifyPhoneNumberForLogin_args_verifierFromPhone obj} then P.Nothing else P.Just $ default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_verifierFromPhone = verifyPhoneNumberForLogin_args_verifierFromPhone obj}
    , if obj == default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_pinCodeForPhone = verifyPhoneNumberForLogin_args_pinCodeForPhone obj} then P.Nothing else P.Just $ default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_pinCodeForPhone = verifyPhoneNumberForLogin_args_pinCodeForPhone obj}
    , if obj == default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_verifierFromLogin = verifyPhoneNumberForLogin_args_verifierFromLogin obj} then P.Nothing else P.Just $ default_VerifyPhoneNumberForLogin_args{verifyPhoneNumberForLogin_args_verifierFromLogin = verifyPhoneNumberForLogin_args_verifierFromLogin obj}
    ]
from_VerifyPhoneNumberForLogin_args :: VerifyPhoneNumberForLogin_args -> T.ThriftVal
from_VerifyPhoneNumberForLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6903 -> P.Just (2, ("verifierFromPhone",T.TString $ E.encodeUtf8 _v6903))) $ verifyPhoneNumberForLogin_args_verifierFromPhone record
  , (\_v6903 -> P.Just (3, ("pinCodeForPhone",T.TString $ E.encodeUtf8 _v6903))) $ verifyPhoneNumberForLogin_args_pinCodeForPhone record
  , (\_v6903 -> P.Just (4, ("verifierFromLogin",T.TString $ E.encodeUtf8 _v6903))) $ verifyPhoneNumberForLogin_args_verifierFromLogin record
  ]
write_VerifyPhoneNumberForLogin_args :: T.Protocol p => p -> VerifyPhoneNumberForLogin_args -> P.IO ()
write_VerifyPhoneNumberForLogin_args oprot record = T.writeVal oprot $ from_VerifyPhoneNumberForLogin_args record
encode_VerifyPhoneNumberForLogin_args :: T.StatelessProtocol p => p -> VerifyPhoneNumberForLogin_args -> LBS.ByteString
encode_VerifyPhoneNumberForLogin_args oprot record = T.serializeVal oprot $ from_VerifyPhoneNumberForLogin_args record
to_VerifyPhoneNumberForLogin_args :: T.ThriftVal -> VerifyPhoneNumberForLogin_args
to_VerifyPhoneNumberForLogin_args (T.TStruct fields) = VerifyPhoneNumberForLogin_args{
  verifyPhoneNumberForLogin_args_verifierFromPhone = P.maybe (verifyPhoneNumberForLogin_args_verifierFromPhone default_VerifyPhoneNumberForLogin_args) (\(_,_val6905) -> (case _val6905 of {T.TString _val6906 -> E.decodeUtf8 _val6906; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyPhoneNumberForLogin_args_pinCodeForPhone = P.maybe (verifyPhoneNumberForLogin_args_pinCodeForPhone default_VerifyPhoneNumberForLogin_args) (\(_,_val6905) -> (case _val6905 of {T.TString _val6907 -> E.decodeUtf8 _val6907; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyPhoneNumberForLogin_args_verifierFromLogin = P.maybe (verifyPhoneNumberForLogin_args_verifierFromLogin default_VerifyPhoneNumberForLogin_args) (\(_,_val6905) -> (case _val6905 of {T.TString _val6908 -> E.decodeUtf8 _val6908; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_VerifyPhoneNumberForLogin_args _ = P.error "not a struct"
read_VerifyPhoneNumberForLogin_args :: T.Protocol p => p -> P.IO VerifyPhoneNumberForLogin_args
read_VerifyPhoneNumberForLogin_args iprot = to_VerifyPhoneNumberForLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhoneNumberForLogin_args)
decode_VerifyPhoneNumberForLogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhoneNumberForLogin_args
decode_VerifyPhoneNumberForLogin_args iprot bs = to_VerifyPhoneNumberForLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhoneNumberForLogin_args) bs
typemap_VerifyPhoneNumberForLogin_args :: T.TypeMap
typemap_VerifyPhoneNumberForLogin_args = Map.fromList [(2,("verifierFromPhone",T.T_STRING)),(3,("pinCodeForPhone",T.T_STRING)),(4,("verifierFromLogin",T.T_STRING))]
default_VerifyPhoneNumberForLogin_args :: VerifyPhoneNumberForLogin_args
default_VerifyPhoneNumberForLogin_args = VerifyPhoneNumberForLogin_args{
  verifyPhoneNumberForLogin_args_verifierFromPhone = "",
  verifyPhoneNumberForLogin_args_pinCodeForPhone = "",
  verifyPhoneNumberForLogin_args_verifierFromLogin = ""}
data VerifyPhoneNumberForLogin_result = VerifyPhoneNumberForLogin_result  { verifyPhoneNumberForLogin_result_success :: LT.Text
  , verifyPhoneNumberForLogin_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhoneNumberForLogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhoneNumberForLogin_result_success record   `H.hashWithSalt` verifyPhoneNumberForLogin_result_e record  
instance QC.Arbitrary VerifyPhoneNumberForLogin_result where 
  arbitrary = M.liftM VerifyPhoneNumberForLogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyPhoneNumberForLogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_success = verifyPhoneNumberForLogin_result_success obj} then P.Nothing else P.Just $ default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_success = verifyPhoneNumberForLogin_result_success obj}
    , if obj == default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_e = verifyPhoneNumberForLogin_result_e obj} then P.Nothing else P.Just $ default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_e = verifyPhoneNumberForLogin_result_e obj}
    ]
from_VerifyPhoneNumberForLogin_result :: VerifyPhoneNumberForLogin_result -> T.ThriftVal
from_VerifyPhoneNumberForLogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6911 -> (1, ("e",from_TalkException _v6911))) <$> verifyPhoneNumberForLogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6911 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v6911))) $ verifyPhoneNumberForLogin_result_success record
    , (\_v6911 -> (1, ("e",from_TalkException _v6911))) <$> verifyPhoneNumberForLogin_result_e record
    ]
    )
write_VerifyPhoneNumberForLogin_result :: T.Protocol p => p -> VerifyPhoneNumberForLogin_result -> P.IO ()
write_VerifyPhoneNumberForLogin_result oprot record = T.writeVal oprot $ from_VerifyPhoneNumberForLogin_result record
encode_VerifyPhoneNumberForLogin_result :: T.StatelessProtocol p => p -> VerifyPhoneNumberForLogin_result -> LBS.ByteString
encode_VerifyPhoneNumberForLogin_result oprot record = T.serializeVal oprot $ from_VerifyPhoneNumberForLogin_result record
to_VerifyPhoneNumberForLogin_result :: T.ThriftVal -> VerifyPhoneNumberForLogin_result
to_VerifyPhoneNumberForLogin_result (T.TStruct fields) = VerifyPhoneNumberForLogin_result{
  verifyPhoneNumberForLogin_result_success = P.maybe (verifyPhoneNumberForLogin_result_success default_VerifyPhoneNumberForLogin_result) (\(_,_val6913) -> (case _val6913 of {T.TString _val6914 -> E.decodeUtf8 _val6914; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyPhoneNumberForLogin_result_e = P.maybe (P.Nothing) (\(_,_val6913) -> P.Just (case _val6913 of {T.TStruct _val6915 -> (to_TalkException (T.TStruct _val6915)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyPhoneNumberForLogin_result _ = P.error "not a struct"
read_VerifyPhoneNumberForLogin_result :: T.Protocol p => p -> P.IO VerifyPhoneNumberForLogin_result
read_VerifyPhoneNumberForLogin_result iprot = to_VerifyPhoneNumberForLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhoneNumberForLogin_result)
decode_VerifyPhoneNumberForLogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhoneNumberForLogin_result
decode_VerifyPhoneNumberForLogin_result iprot bs = to_VerifyPhoneNumberForLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhoneNumberForLogin_result) bs
typemap_VerifyPhoneNumberForLogin_result :: T.TypeMap
typemap_VerifyPhoneNumberForLogin_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyPhoneNumberForLogin_result :: VerifyPhoneNumberForLogin_result
default_VerifyPhoneNumberForLogin_result = VerifyPhoneNumberForLogin_result{
  verifyPhoneNumberForLogin_result_success = "",
  verifyPhoneNumberForLogin_result_e = P.Nothing}
data VerifyPhoneNumber_args = VerifyPhoneNumber_args  { verifyPhoneNumber_args_sessionId :: LT.Text
  , verifyPhoneNumber_args_pinCode :: LT.Text
  , verifyPhoneNumber_args_udidHash :: LT.Text
  , verifyPhoneNumber_args_migrationPincodeSessionId :: LT.Text
  , verifyPhoneNumber_args_oldUdidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhoneNumber_args_sessionId record   `H.hashWithSalt` verifyPhoneNumber_args_pinCode record   `H.hashWithSalt` verifyPhoneNumber_args_udidHash record   `H.hashWithSalt` verifyPhoneNumber_args_migrationPincodeSessionId record   `H.hashWithSalt` verifyPhoneNumber_args_oldUdidHash record  
instance QC.Arbitrary VerifyPhoneNumber_args where 
  arbitrary = M.liftM VerifyPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhoneNumber_args{verifyPhoneNumber_args_sessionId = verifyPhoneNumber_args_sessionId obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_args{verifyPhoneNumber_args_sessionId = verifyPhoneNumber_args_sessionId obj}
    , if obj == default_VerifyPhoneNumber_args{verifyPhoneNumber_args_pinCode = verifyPhoneNumber_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_args{verifyPhoneNumber_args_pinCode = verifyPhoneNumber_args_pinCode obj}
    , if obj == default_VerifyPhoneNumber_args{verifyPhoneNumber_args_udidHash = verifyPhoneNumber_args_udidHash obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_args{verifyPhoneNumber_args_udidHash = verifyPhoneNumber_args_udidHash obj}
    , if obj == default_VerifyPhoneNumber_args{verifyPhoneNumber_args_migrationPincodeSessionId = verifyPhoneNumber_args_migrationPincodeSessionId obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_args{verifyPhoneNumber_args_migrationPincodeSessionId = verifyPhoneNumber_args_migrationPincodeSessionId obj}
    , if obj == default_VerifyPhoneNumber_args{verifyPhoneNumber_args_oldUdidHash = verifyPhoneNumber_args_oldUdidHash obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_args{verifyPhoneNumber_args_oldUdidHash = verifyPhoneNumber_args_oldUdidHash obj}
    ]
from_VerifyPhoneNumber_args :: VerifyPhoneNumber_args -> T.ThriftVal
from_VerifyPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6918 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v6918))) $ verifyPhoneNumber_args_sessionId record
  , (\_v6918 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v6918))) $ verifyPhoneNumber_args_pinCode record
  , (\_v6918 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v6918))) $ verifyPhoneNumber_args_udidHash record
  , (\_v6918 -> P.Just (5, ("migrationPincodeSessionId",T.TString $ E.encodeUtf8 _v6918))) $ verifyPhoneNumber_args_migrationPincodeSessionId record
  , (\_v6918 -> P.Just (6, ("oldUdidHash",T.TString $ E.encodeUtf8 _v6918))) $ verifyPhoneNumber_args_oldUdidHash record
  ]
write_VerifyPhoneNumber_args :: T.Protocol p => p -> VerifyPhoneNumber_args -> P.IO ()
write_VerifyPhoneNumber_args oprot record = T.writeVal oprot $ from_VerifyPhoneNumber_args record
encode_VerifyPhoneNumber_args :: T.StatelessProtocol p => p -> VerifyPhoneNumber_args -> LBS.ByteString
encode_VerifyPhoneNumber_args oprot record = T.serializeVal oprot $ from_VerifyPhoneNumber_args record
to_VerifyPhoneNumber_args :: T.ThriftVal -> VerifyPhoneNumber_args
to_VerifyPhoneNumber_args (T.TStruct fields) = VerifyPhoneNumber_args{
  verifyPhoneNumber_args_sessionId = P.maybe (verifyPhoneNumber_args_sessionId default_VerifyPhoneNumber_args) (\(_,_val6920) -> (case _val6920 of {T.TString _val6921 -> E.decodeUtf8 _val6921; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyPhoneNumber_args_pinCode = P.maybe (verifyPhoneNumber_args_pinCode default_VerifyPhoneNumber_args) (\(_,_val6920) -> (case _val6920 of {T.TString _val6922 -> E.decodeUtf8 _val6922; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyPhoneNumber_args_udidHash = P.maybe (verifyPhoneNumber_args_udidHash default_VerifyPhoneNumber_args) (\(_,_val6920) -> (case _val6920 of {T.TString _val6923 -> E.decodeUtf8 _val6923; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  verifyPhoneNumber_args_migrationPincodeSessionId = P.maybe (verifyPhoneNumber_args_migrationPincodeSessionId default_VerifyPhoneNumber_args) (\(_,_val6920) -> (case _val6920 of {T.TString _val6924 -> E.decodeUtf8 _val6924; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  verifyPhoneNumber_args_oldUdidHash = P.maybe (verifyPhoneNumber_args_oldUdidHash default_VerifyPhoneNumber_args) (\(_,_val6920) -> (case _val6920 of {T.TString _val6925 -> E.decodeUtf8 _val6925; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_VerifyPhoneNumber_args _ = P.error "not a struct"
read_VerifyPhoneNumber_args :: T.Protocol p => p -> P.IO VerifyPhoneNumber_args
read_VerifyPhoneNumber_args iprot = to_VerifyPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhoneNumber_args)
decode_VerifyPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhoneNumber_args
decode_VerifyPhoneNumber_args iprot bs = to_VerifyPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhoneNumber_args) bs
typemap_VerifyPhoneNumber_args :: T.TypeMap
typemap_VerifyPhoneNumber_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("pinCode",T.T_STRING)),(4,("udidHash",T.T_STRING)),(5,("migrationPincodeSessionId",T.T_STRING)),(6,("oldUdidHash",T.T_STRING))]
default_VerifyPhoneNumber_args :: VerifyPhoneNumber_args
default_VerifyPhoneNumber_args = VerifyPhoneNumber_args{
  verifyPhoneNumber_args_sessionId = "",
  verifyPhoneNumber_args_pinCode = "",
  verifyPhoneNumber_args_udidHash = "",
  verifyPhoneNumber_args_migrationPincodeSessionId = "",
  verifyPhoneNumber_args_oldUdidHash = ""}
data VerifyPhoneNumber_result = VerifyPhoneNumber_result  { verifyPhoneNumber_result_success :: PhoneVerificationResult
  , verifyPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhoneNumber_result_success record   `H.hashWithSalt` verifyPhoneNumber_result_e record  
instance QC.Arbitrary VerifyPhoneNumber_result where 
  arbitrary = M.liftM VerifyPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhoneNumber_result{verifyPhoneNumber_result_success = verifyPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_result{verifyPhoneNumber_result_success = verifyPhoneNumber_result_success obj}
    , if obj == default_VerifyPhoneNumber_result{verifyPhoneNumber_result_e = verifyPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_VerifyPhoneNumber_result{verifyPhoneNumber_result_e = verifyPhoneNumber_result_e obj}
    ]
from_VerifyPhoneNumber_result :: VerifyPhoneNumber_result -> T.ThriftVal
from_VerifyPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6928 -> (1, ("e",from_TalkException _v6928))) <$> verifyPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6928 -> P.Just (0, ("success",from_PhoneVerificationResult _v6928))) $ verifyPhoneNumber_result_success record
    , (\_v6928 -> (1, ("e",from_TalkException _v6928))) <$> verifyPhoneNumber_result_e record
    ]
    )
write_VerifyPhoneNumber_result :: T.Protocol p => p -> VerifyPhoneNumber_result -> P.IO ()
write_VerifyPhoneNumber_result oprot record = T.writeVal oprot $ from_VerifyPhoneNumber_result record
encode_VerifyPhoneNumber_result :: T.StatelessProtocol p => p -> VerifyPhoneNumber_result -> LBS.ByteString
encode_VerifyPhoneNumber_result oprot record = T.serializeVal oprot $ from_VerifyPhoneNumber_result record
to_VerifyPhoneNumber_result :: T.ThriftVal -> VerifyPhoneNumber_result
to_VerifyPhoneNumber_result (T.TStruct fields) = VerifyPhoneNumber_result{
  verifyPhoneNumber_result_success = P.maybe (verifyPhoneNumber_result_success default_VerifyPhoneNumber_result) (\(_,_val6930) -> (case _val6930 of {T.TStruct _val6931 -> (to_PhoneVerificationResult (T.TStruct _val6931)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val6930) -> P.Just (case _val6930 of {T.TStruct _val6932 -> (to_TalkException (T.TStruct _val6932)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyPhoneNumber_result _ = P.error "not a struct"
read_VerifyPhoneNumber_result :: T.Protocol p => p -> P.IO VerifyPhoneNumber_result
read_VerifyPhoneNumber_result iprot = to_VerifyPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhoneNumber_result)
decode_VerifyPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhoneNumber_result
decode_VerifyPhoneNumber_result iprot bs = to_VerifyPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhoneNumber_result) bs
typemap_VerifyPhoneNumber_result :: T.TypeMap
typemap_VerifyPhoneNumber_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PhoneVerificationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyPhoneNumber_result :: VerifyPhoneNumber_result
default_VerifyPhoneNumber_result = VerifyPhoneNumber_result{
  verifyPhoneNumber_result_success = default_PhoneVerificationResult,
  verifyPhoneNumber_result_e = P.Nothing}
data GetBlockedContactIdsByRange_args = GetBlockedContactIdsByRange_args  { getBlockedContactIdsByRange_args_start :: I.Int32
  , getBlockedContactIdsByRange_args_count :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIdsByRange_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIdsByRange_args_start record   `H.hashWithSalt` getBlockedContactIdsByRange_args_count record  
instance QC.Arbitrary GetBlockedContactIdsByRange_args where 
  arbitrary = M.liftM GetBlockedContactIdsByRange_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIdsByRange_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_start = getBlockedContactIdsByRange_args_start obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_start = getBlockedContactIdsByRange_args_start obj}
    , if obj == default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_count = getBlockedContactIdsByRange_args_count obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_args{getBlockedContactIdsByRange_args_count = getBlockedContactIdsByRange_args_count obj}
    ]
from_GetBlockedContactIdsByRange_args :: GetBlockedContactIdsByRange_args -> T.ThriftVal
from_GetBlockedContactIdsByRange_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6935 -> P.Just (2, ("start",T.TI32 _v6935))) $ getBlockedContactIdsByRange_args_start record
  , (\_v6935 -> P.Just (3, ("count",T.TI32 _v6935))) $ getBlockedContactIdsByRange_args_count record
  ]
write_GetBlockedContactIdsByRange_args :: T.Protocol p => p -> GetBlockedContactIdsByRange_args -> P.IO ()
write_GetBlockedContactIdsByRange_args oprot record = T.writeVal oprot $ from_GetBlockedContactIdsByRange_args record
encode_GetBlockedContactIdsByRange_args :: T.StatelessProtocol p => p -> GetBlockedContactIdsByRange_args -> LBS.ByteString
encode_GetBlockedContactIdsByRange_args oprot record = T.serializeVal oprot $ from_GetBlockedContactIdsByRange_args record
to_GetBlockedContactIdsByRange_args :: T.ThriftVal -> GetBlockedContactIdsByRange_args
to_GetBlockedContactIdsByRange_args (T.TStruct fields) = GetBlockedContactIdsByRange_args{
  getBlockedContactIdsByRange_args_start = P.maybe (getBlockedContactIdsByRange_args_start default_GetBlockedContactIdsByRange_args) (\(_,_val6937) -> (case _val6937 of {T.TI32 _val6938 -> _val6938; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getBlockedContactIdsByRange_args_count = P.maybe (getBlockedContactIdsByRange_args_count default_GetBlockedContactIdsByRange_args) (\(_,_val6937) -> (case _val6937 of {T.TI32 _val6939 -> _val6939; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetBlockedContactIdsByRange_args _ = P.error "not a struct"
read_GetBlockedContactIdsByRange_args :: T.Protocol p => p -> P.IO GetBlockedContactIdsByRange_args
read_GetBlockedContactIdsByRange_args iprot = to_GetBlockedContactIdsByRange_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_args)
decode_GetBlockedContactIdsByRange_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIdsByRange_args
decode_GetBlockedContactIdsByRange_args iprot bs = to_GetBlockedContactIdsByRange_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_args) bs
typemap_GetBlockedContactIdsByRange_args :: T.TypeMap
typemap_GetBlockedContactIdsByRange_args = Map.fromList [(2,("start",T.T_I32)),(3,("count",T.T_I32))]
default_GetBlockedContactIdsByRange_args :: GetBlockedContactIdsByRange_args
default_GetBlockedContactIdsByRange_args = GetBlockedContactIdsByRange_args{
  getBlockedContactIdsByRange_args_start = 0,
  getBlockedContactIdsByRange_args_count = 0}
data GetBlockedContactIdsByRange_result = GetBlockedContactIdsByRange_result  { getBlockedContactIdsByRange_result_success :: (Vector.Vector LT.Text)
  , getBlockedContactIdsByRange_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedContactIdsByRange_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedContactIdsByRange_result_success record   `H.hashWithSalt` getBlockedContactIdsByRange_result_e record  
instance QC.Arbitrary GetBlockedContactIdsByRange_result where 
  arbitrary = M.liftM GetBlockedContactIdsByRange_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedContactIdsByRange_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = getBlockedContactIdsByRange_result_success obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = getBlockedContactIdsByRange_result_success obj}
    , if obj == default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = getBlockedContactIdsByRange_result_e obj} then P.Nothing else P.Just $ default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = getBlockedContactIdsByRange_result_e obj}
    ]
from_GetBlockedContactIdsByRange_result :: GetBlockedContactIdsByRange_result -> T.ThriftVal
from_GetBlockedContactIdsByRange_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6942 -> (1, ("e",from_TalkException _v6942))) <$> getBlockedContactIdsByRange_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6942 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6944 -> T.TString $ E.encodeUtf8 _v6944) $ Vector.toList _v6942))) $ getBlockedContactIdsByRange_result_success record
    , (\_v6942 -> (1, ("e",from_TalkException _v6942))) <$> getBlockedContactIdsByRange_result_e record
    ]
    )
write_GetBlockedContactIdsByRange_result :: T.Protocol p => p -> GetBlockedContactIdsByRange_result -> P.IO ()
write_GetBlockedContactIdsByRange_result oprot record = T.writeVal oprot $ from_GetBlockedContactIdsByRange_result record
encode_GetBlockedContactIdsByRange_result :: T.StatelessProtocol p => p -> GetBlockedContactIdsByRange_result -> LBS.ByteString
encode_GetBlockedContactIdsByRange_result oprot record = T.serializeVal oprot $ from_GetBlockedContactIdsByRange_result record
to_GetBlockedContactIdsByRange_result :: T.ThriftVal -> GetBlockedContactIdsByRange_result
to_GetBlockedContactIdsByRange_result (T.TStruct fields) = GetBlockedContactIdsByRange_result{
  getBlockedContactIdsByRange_result_success = P.maybe (getBlockedContactIdsByRange_result_success default_GetBlockedContactIdsByRange_result) (\(_,_val6946) -> (case _val6946 of {T.TList _ _val6947 -> (Vector.fromList $ P.map (\_v6948 -> (case _v6948 of {T.TString _val6949 -> E.decodeUtf8 _val6949; _ -> P.error "wrong type"})) _val6947); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedContactIdsByRange_result_e = P.maybe (P.Nothing) (\(_,_val6946) -> P.Just (case _val6946 of {T.TStruct _val6950 -> (to_TalkException (T.TStruct _val6950)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedContactIdsByRange_result _ = P.error "not a struct"
read_GetBlockedContactIdsByRange_result :: T.Protocol p => p -> P.IO GetBlockedContactIdsByRange_result
read_GetBlockedContactIdsByRange_result iprot = to_GetBlockedContactIdsByRange_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_result)
decode_GetBlockedContactIdsByRange_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedContactIdsByRange_result
decode_GetBlockedContactIdsByRange_result iprot bs = to_GetBlockedContactIdsByRange_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedContactIdsByRange_result) bs
typemap_GetBlockedContactIdsByRange_result :: T.TypeMap
typemap_GetBlockedContactIdsByRange_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedContactIdsByRange_result :: GetBlockedContactIdsByRange_result
default_GetBlockedContactIdsByRange_result = GetBlockedContactIdsByRange_result{
  getBlockedContactIdsByRange_result_success = Vector.empty,
  getBlockedContactIdsByRange_result_e = P.Nothing}
data GetBlockedRecommendationIds_args = GetBlockedRecommendationIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedRecommendationIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBlockedRecommendationIds_args where 
  arbitrary = QC.elements [GetBlockedRecommendationIds_args]
from_GetBlockedRecommendationIds_args :: GetBlockedRecommendationIds_args -> T.ThriftVal
from_GetBlockedRecommendationIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBlockedRecommendationIds_args :: T.Protocol p => p -> GetBlockedRecommendationIds_args -> P.IO ()
write_GetBlockedRecommendationIds_args oprot record = T.writeVal oprot $ from_GetBlockedRecommendationIds_args record
encode_GetBlockedRecommendationIds_args :: T.StatelessProtocol p => p -> GetBlockedRecommendationIds_args -> LBS.ByteString
encode_GetBlockedRecommendationIds_args oprot record = T.serializeVal oprot $ from_GetBlockedRecommendationIds_args record
to_GetBlockedRecommendationIds_args :: T.ThriftVal -> GetBlockedRecommendationIds_args
to_GetBlockedRecommendationIds_args (T.TStruct fields) = GetBlockedRecommendationIds_args{

  }
to_GetBlockedRecommendationIds_args _ = P.error "not a struct"
read_GetBlockedRecommendationIds_args :: T.Protocol p => p -> P.IO GetBlockedRecommendationIds_args
read_GetBlockedRecommendationIds_args iprot = to_GetBlockedRecommendationIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_args)
decode_GetBlockedRecommendationIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedRecommendationIds_args
decode_GetBlockedRecommendationIds_args iprot bs = to_GetBlockedRecommendationIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_args) bs
typemap_GetBlockedRecommendationIds_args :: T.TypeMap
typemap_GetBlockedRecommendationIds_args = Map.fromList []
default_GetBlockedRecommendationIds_args :: GetBlockedRecommendationIds_args
default_GetBlockedRecommendationIds_args = GetBlockedRecommendationIds_args{
}
data GetBlockedRecommendationIds_result = GetBlockedRecommendationIds_result  { getBlockedRecommendationIds_result_success :: (Vector.Vector LT.Text)
  , getBlockedRecommendationIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBlockedRecommendationIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBlockedRecommendationIds_result_success record   `H.hashWithSalt` getBlockedRecommendationIds_result_e record  
instance QC.Arbitrary GetBlockedRecommendationIds_result where 
  arbitrary = M.liftM GetBlockedRecommendationIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBlockedRecommendationIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = getBlockedRecommendationIds_result_success obj} then P.Nothing else P.Just $ default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = getBlockedRecommendationIds_result_success obj}
    , if obj == default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = getBlockedRecommendationIds_result_e obj} then P.Nothing else P.Just $ default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = getBlockedRecommendationIds_result_e obj}
    ]
from_GetBlockedRecommendationIds_result :: GetBlockedRecommendationIds_result -> T.ThriftVal
from_GetBlockedRecommendationIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6958 -> (1, ("e",from_TalkException _v6958))) <$> getBlockedRecommendationIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6958 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6960 -> T.TString $ E.encodeUtf8 _v6960) $ Vector.toList _v6958))) $ getBlockedRecommendationIds_result_success record
    , (\_v6958 -> (1, ("e",from_TalkException _v6958))) <$> getBlockedRecommendationIds_result_e record
    ]
    )
write_GetBlockedRecommendationIds_result :: T.Protocol p => p -> GetBlockedRecommendationIds_result -> P.IO ()
write_GetBlockedRecommendationIds_result oprot record = T.writeVal oprot $ from_GetBlockedRecommendationIds_result record
encode_GetBlockedRecommendationIds_result :: T.StatelessProtocol p => p -> GetBlockedRecommendationIds_result -> LBS.ByteString
encode_GetBlockedRecommendationIds_result oprot record = T.serializeVal oprot $ from_GetBlockedRecommendationIds_result record
to_GetBlockedRecommendationIds_result :: T.ThriftVal -> GetBlockedRecommendationIds_result
to_GetBlockedRecommendationIds_result (T.TStruct fields) = GetBlockedRecommendationIds_result{
  getBlockedRecommendationIds_result_success = P.maybe (getBlockedRecommendationIds_result_success default_GetBlockedRecommendationIds_result) (\(_,_val6962) -> (case _val6962 of {T.TList _ _val6963 -> (Vector.fromList $ P.map (\_v6964 -> (case _v6964 of {T.TString _val6965 -> E.decodeUtf8 _val6965; _ -> P.error "wrong type"})) _val6963); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBlockedRecommendationIds_result_e = P.maybe (P.Nothing) (\(_,_val6962) -> P.Just (case _val6962 of {T.TStruct _val6966 -> (to_TalkException (T.TStruct _val6966)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBlockedRecommendationIds_result _ = P.error "not a struct"
read_GetBlockedRecommendationIds_result :: T.Protocol p => p -> P.IO GetBlockedRecommendationIds_result
read_GetBlockedRecommendationIds_result iprot = to_GetBlockedRecommendationIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_result)
decode_GetBlockedRecommendationIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBlockedRecommendationIds_result
decode_GetBlockedRecommendationIds_result iprot bs = to_GetBlockedRecommendationIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBlockedRecommendationIds_result) bs
typemap_GetBlockedRecommendationIds_result :: T.TypeMap
typemap_GetBlockedRecommendationIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBlockedRecommendationIds_result :: GetBlockedRecommendationIds_result
default_GetBlockedRecommendationIds_result = GetBlockedRecommendationIds_result{
  getBlockedRecommendationIds_result_success = Vector.empty,
  getBlockedRecommendationIds_result_e = P.Nothing}
data GetBuddyBlockerIds_args = GetBuddyBlockerIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyBlockerIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetBuddyBlockerIds_args where 
  arbitrary = QC.elements [GetBuddyBlockerIds_args]
from_GetBuddyBlockerIds_args :: GetBuddyBlockerIds_args -> T.ThriftVal
from_GetBuddyBlockerIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetBuddyBlockerIds_args :: T.Protocol p => p -> GetBuddyBlockerIds_args -> P.IO ()
write_GetBuddyBlockerIds_args oprot record = T.writeVal oprot $ from_GetBuddyBlockerIds_args record
encode_GetBuddyBlockerIds_args :: T.StatelessProtocol p => p -> GetBuddyBlockerIds_args -> LBS.ByteString
encode_GetBuddyBlockerIds_args oprot record = T.serializeVal oprot $ from_GetBuddyBlockerIds_args record
to_GetBuddyBlockerIds_args :: T.ThriftVal -> GetBuddyBlockerIds_args
to_GetBuddyBlockerIds_args (T.TStruct fields) = GetBuddyBlockerIds_args{

  }
to_GetBuddyBlockerIds_args _ = P.error "not a struct"
read_GetBuddyBlockerIds_args :: T.Protocol p => p -> P.IO GetBuddyBlockerIds_args
read_GetBuddyBlockerIds_args iprot = to_GetBuddyBlockerIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_args)
decode_GetBuddyBlockerIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyBlockerIds_args
decode_GetBuddyBlockerIds_args iprot bs = to_GetBuddyBlockerIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_args) bs
typemap_GetBuddyBlockerIds_args :: T.TypeMap
typemap_GetBuddyBlockerIds_args = Map.fromList []
default_GetBuddyBlockerIds_args :: GetBuddyBlockerIds_args
default_GetBuddyBlockerIds_args = GetBuddyBlockerIds_args{
}
data GetBuddyBlockerIds_result = GetBuddyBlockerIds_result  { getBuddyBlockerIds_result_success :: (Vector.Vector LT.Text)
  , getBuddyBlockerIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyBlockerIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyBlockerIds_result_success record   `H.hashWithSalt` getBuddyBlockerIds_result_e record  
instance QC.Arbitrary GetBuddyBlockerIds_result where 
  arbitrary = M.liftM GetBuddyBlockerIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBuddyBlockerIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = getBuddyBlockerIds_result_success obj} then P.Nothing else P.Just $ default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = getBuddyBlockerIds_result_success obj}
    , if obj == default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = getBuddyBlockerIds_result_e obj} then P.Nothing else P.Just $ default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = getBuddyBlockerIds_result_e obj}
    ]
from_GetBuddyBlockerIds_result :: GetBuddyBlockerIds_result -> T.ThriftVal
from_GetBuddyBlockerIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6974 -> (1, ("e",from_TalkException _v6974))) <$> getBuddyBlockerIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6974 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v6976 -> T.TString $ E.encodeUtf8 _v6976) $ Vector.toList _v6974))) $ getBuddyBlockerIds_result_success record
    , (\_v6974 -> (1, ("e",from_TalkException _v6974))) <$> getBuddyBlockerIds_result_e record
    ]
    )
write_GetBuddyBlockerIds_result :: T.Protocol p => p -> GetBuddyBlockerIds_result -> P.IO ()
write_GetBuddyBlockerIds_result oprot record = T.writeVal oprot $ from_GetBuddyBlockerIds_result record
encode_GetBuddyBlockerIds_result :: T.StatelessProtocol p => p -> GetBuddyBlockerIds_result -> LBS.ByteString
encode_GetBuddyBlockerIds_result oprot record = T.serializeVal oprot $ from_GetBuddyBlockerIds_result record
to_GetBuddyBlockerIds_result :: T.ThriftVal -> GetBuddyBlockerIds_result
to_GetBuddyBlockerIds_result (T.TStruct fields) = GetBuddyBlockerIds_result{
  getBuddyBlockerIds_result_success = P.maybe (getBuddyBlockerIds_result_success default_GetBuddyBlockerIds_result) (\(_,_val6978) -> (case _val6978 of {T.TList _ _val6979 -> (Vector.fromList $ P.map (\_v6980 -> (case _v6980 of {T.TString _val6981 -> E.decodeUtf8 _val6981; _ -> P.error "wrong type"})) _val6979); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBuddyBlockerIds_result_e = P.maybe (P.Nothing) (\(_,_val6978) -> P.Just (case _val6978 of {T.TStruct _val6982 -> (to_TalkException (T.TStruct _val6982)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBuddyBlockerIds_result _ = P.error "not a struct"
read_GetBuddyBlockerIds_result :: T.Protocol p => p -> P.IO GetBuddyBlockerIds_result
read_GetBuddyBlockerIds_result iprot = to_GetBuddyBlockerIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_result)
decode_GetBuddyBlockerIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyBlockerIds_result
decode_GetBuddyBlockerIds_result iprot bs = to_GetBuddyBlockerIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyBlockerIds_result) bs
typemap_GetBuddyBlockerIds_result :: T.TypeMap
typemap_GetBuddyBlockerIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBuddyBlockerIds_result :: GetBuddyBlockerIds_result
default_GetBuddyBlockerIds_result = GetBuddyBlockerIds_result{
  getBuddyBlockerIds_result_success = Vector.empty,
  getBuddyBlockerIds_result_e = P.Nothing}
data GetBuddyLocation_args = GetBuddyLocation_args  { getBuddyLocation_args_mid :: LT.Text
  , getBuddyLocation_args_index :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyLocation_args_mid record   `H.hashWithSalt` getBuddyLocation_args_index record  
instance QC.Arbitrary GetBuddyLocation_args where 
  arbitrary = M.liftM GetBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyLocation_args{getBuddyLocation_args_mid = getBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_GetBuddyLocation_args{getBuddyLocation_args_mid = getBuddyLocation_args_mid obj}
    , if obj == default_GetBuddyLocation_args{getBuddyLocation_args_index = getBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_GetBuddyLocation_args{getBuddyLocation_args_index = getBuddyLocation_args_index obj}
    ]
from_GetBuddyLocation_args :: GetBuddyLocation_args -> T.ThriftVal
from_GetBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6985 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v6985))) $ getBuddyLocation_args_mid record
  , (\_v6985 -> P.Just (3, ("index",T.TI32 _v6985))) $ getBuddyLocation_args_index record
  ]
write_GetBuddyLocation_args :: T.Protocol p => p -> GetBuddyLocation_args -> P.IO ()
write_GetBuddyLocation_args oprot record = T.writeVal oprot $ from_GetBuddyLocation_args record
encode_GetBuddyLocation_args :: T.StatelessProtocol p => p -> GetBuddyLocation_args -> LBS.ByteString
encode_GetBuddyLocation_args oprot record = T.serializeVal oprot $ from_GetBuddyLocation_args record
to_GetBuddyLocation_args :: T.ThriftVal -> GetBuddyLocation_args
to_GetBuddyLocation_args (T.TStruct fields) = GetBuddyLocation_args{
  getBuddyLocation_args_mid = P.maybe (getBuddyLocation_args_mid default_GetBuddyLocation_args) (\(_,_val6987) -> (case _val6987 of {T.TString _val6988 -> E.decodeUtf8 _val6988; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getBuddyLocation_args_index = P.maybe (getBuddyLocation_args_index default_GetBuddyLocation_args) (\(_,_val6987) -> (case _val6987 of {T.TI32 _val6989 -> _val6989; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetBuddyLocation_args _ = P.error "not a struct"
read_GetBuddyLocation_args :: T.Protocol p => p -> P.IO GetBuddyLocation_args
read_GetBuddyLocation_args iprot = to_GetBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyLocation_args)
decode_GetBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyLocation_args
decode_GetBuddyLocation_args iprot bs = to_GetBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyLocation_args) bs
typemap_GetBuddyLocation_args :: T.TypeMap
typemap_GetBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32))]
default_GetBuddyLocation_args :: GetBuddyLocation_args
default_GetBuddyLocation_args = GetBuddyLocation_args{
  getBuddyLocation_args_mid = "",
  getBuddyLocation_args_index = 0}
data GetBuddyLocation_result = GetBuddyLocation_result  { getBuddyLocation_result_success :: Geolocation
  , getBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBuddyLocation_result_success record   `H.hashWithSalt` getBuddyLocation_result_e record  
instance QC.Arbitrary GetBuddyLocation_result where 
  arbitrary = M.liftM GetBuddyLocation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBuddyLocation_result{getBuddyLocation_result_success = getBuddyLocation_result_success obj} then P.Nothing else P.Just $ default_GetBuddyLocation_result{getBuddyLocation_result_success = getBuddyLocation_result_success obj}
    , if obj == default_GetBuddyLocation_result{getBuddyLocation_result_e = getBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_GetBuddyLocation_result{getBuddyLocation_result_e = getBuddyLocation_result_e obj}
    ]
from_GetBuddyLocation_result :: GetBuddyLocation_result -> T.ThriftVal
from_GetBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v6992 -> (1, ("e",from_TalkException _v6992))) <$> getBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v6992 -> P.Just (0, ("success",from_Geolocation _v6992))) $ getBuddyLocation_result_success record
    , (\_v6992 -> (1, ("e",from_TalkException _v6992))) <$> getBuddyLocation_result_e record
    ]
    )
write_GetBuddyLocation_result :: T.Protocol p => p -> GetBuddyLocation_result -> P.IO ()
write_GetBuddyLocation_result oprot record = T.writeVal oprot $ from_GetBuddyLocation_result record
encode_GetBuddyLocation_result :: T.StatelessProtocol p => p -> GetBuddyLocation_result -> LBS.ByteString
encode_GetBuddyLocation_result oprot record = T.serializeVal oprot $ from_GetBuddyLocation_result record
to_GetBuddyLocation_result :: T.ThriftVal -> GetBuddyLocation_result
to_GetBuddyLocation_result (T.TStruct fields) = GetBuddyLocation_result{
  getBuddyLocation_result_success = P.maybe (getBuddyLocation_result_success default_GetBuddyLocation_result) (\(_,_val6994) -> (case _val6994 of {T.TStruct _val6995 -> (to_Geolocation (T.TStruct _val6995)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val6994) -> P.Just (case _val6994 of {T.TStruct _val6996 -> (to_TalkException (T.TStruct _val6996)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBuddyLocation_result _ = P.error "not a struct"
read_GetBuddyLocation_result :: T.Protocol p => p -> P.IO GetBuddyLocation_result
read_GetBuddyLocation_result iprot = to_GetBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBuddyLocation_result)
decode_GetBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBuddyLocation_result
decode_GetBuddyLocation_result iprot bs = to_GetBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBuddyLocation_result) bs
typemap_GetBuddyLocation_result :: T.TypeMap
typemap_GetBuddyLocation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Geolocation))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetBuddyLocation_result :: GetBuddyLocation_result
default_GetBuddyLocation_result = GetBuddyLocation_result{
  getBuddyLocation_result_success = default_Geolocation,
  getBuddyLocation_result_e = P.Nothing}
data GetCompactContactsModifiedSince_args = GetCompactContactsModifiedSince_args  { getCompactContactsModifiedSince_args_timestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContactsModifiedSince_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContactsModifiedSince_args_timestamp record  
instance QC.Arbitrary GetCompactContactsModifiedSince_args where 
  arbitrary = M.liftM GetCompactContactsModifiedSince_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContactsModifiedSince_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContactsModifiedSince_args{getCompactContactsModifiedSince_args_timestamp = getCompactContactsModifiedSince_args_timestamp obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_args{getCompactContactsModifiedSince_args_timestamp = getCompactContactsModifiedSince_args_timestamp obj}
    ]
from_GetCompactContactsModifiedSince_args :: GetCompactContactsModifiedSince_args -> T.ThriftVal
from_GetCompactContactsModifiedSince_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v6999 -> P.Just (2, ("timestamp",T.TI64 _v6999))) $ getCompactContactsModifiedSince_args_timestamp record
  ]
write_GetCompactContactsModifiedSince_args :: T.Protocol p => p -> GetCompactContactsModifiedSince_args -> P.IO ()
write_GetCompactContactsModifiedSince_args oprot record = T.writeVal oprot $ from_GetCompactContactsModifiedSince_args record
encode_GetCompactContactsModifiedSince_args :: T.StatelessProtocol p => p -> GetCompactContactsModifiedSince_args -> LBS.ByteString
encode_GetCompactContactsModifiedSince_args oprot record = T.serializeVal oprot $ from_GetCompactContactsModifiedSince_args record
to_GetCompactContactsModifiedSince_args :: T.ThriftVal -> GetCompactContactsModifiedSince_args
to_GetCompactContactsModifiedSince_args (T.TStruct fields) = GetCompactContactsModifiedSince_args{
  getCompactContactsModifiedSince_args_timestamp = P.maybe (getCompactContactsModifiedSince_args_timestamp default_GetCompactContactsModifiedSince_args) (\(_,_val7001) -> (case _val7001 of {T.TI64 _val7002 -> _val7002; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContactsModifiedSince_args _ = P.error "not a struct"
read_GetCompactContactsModifiedSince_args :: T.Protocol p => p -> P.IO GetCompactContactsModifiedSince_args
read_GetCompactContactsModifiedSince_args iprot = to_GetCompactContactsModifiedSince_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_args)
decode_GetCompactContactsModifiedSince_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContactsModifiedSince_args
decode_GetCompactContactsModifiedSince_args iprot bs = to_GetCompactContactsModifiedSince_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_args) bs
typemap_GetCompactContactsModifiedSince_args :: T.TypeMap
typemap_GetCompactContactsModifiedSince_args = Map.fromList [(2,("timestamp",T.T_I64))]
default_GetCompactContactsModifiedSince_args :: GetCompactContactsModifiedSince_args
default_GetCompactContactsModifiedSince_args = GetCompactContactsModifiedSince_args{
  getCompactContactsModifiedSince_args_timestamp = 0}
data GetCompactContactsModifiedSince_result = GetCompactContactsModifiedSince_result  { getCompactContactsModifiedSince_result_success :: (Vector.Vector CompactContact)
  , getCompactContactsModifiedSince_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContactsModifiedSince_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContactsModifiedSince_result_success record   `H.hashWithSalt` getCompactContactsModifiedSince_result_e record  
instance QC.Arbitrary GetCompactContactsModifiedSince_result where 
  arbitrary = M.liftM GetCompactContactsModifiedSince_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContactsModifiedSince_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = getCompactContactsModifiedSince_result_success obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = getCompactContactsModifiedSince_result_success obj}
    , if obj == default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = getCompactContactsModifiedSince_result_e obj} then P.Nothing else P.Just $ default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = getCompactContactsModifiedSince_result_e obj}
    ]
from_GetCompactContactsModifiedSince_result :: GetCompactContactsModifiedSince_result -> T.ThriftVal
from_GetCompactContactsModifiedSince_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7005 -> (1, ("e",from_TalkException _v7005))) <$> getCompactContactsModifiedSince_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7005 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v7007 -> from_CompactContact _v7007) $ Vector.toList _v7005))) $ getCompactContactsModifiedSince_result_success record
    , (\_v7005 -> (1, ("e",from_TalkException _v7005))) <$> getCompactContactsModifiedSince_result_e record
    ]
    )
write_GetCompactContactsModifiedSince_result :: T.Protocol p => p -> GetCompactContactsModifiedSince_result -> P.IO ()
write_GetCompactContactsModifiedSince_result oprot record = T.writeVal oprot $ from_GetCompactContactsModifiedSince_result record
encode_GetCompactContactsModifiedSince_result :: T.StatelessProtocol p => p -> GetCompactContactsModifiedSince_result -> LBS.ByteString
encode_GetCompactContactsModifiedSince_result oprot record = T.serializeVal oprot $ from_GetCompactContactsModifiedSince_result record
to_GetCompactContactsModifiedSince_result :: T.ThriftVal -> GetCompactContactsModifiedSince_result
to_GetCompactContactsModifiedSince_result (T.TStruct fields) = GetCompactContactsModifiedSince_result{
  getCompactContactsModifiedSince_result_success = P.maybe (getCompactContactsModifiedSince_result_success default_GetCompactContactsModifiedSince_result) (\(_,_val7009) -> (case _val7009 of {T.TList _ _val7010 -> (Vector.fromList $ P.map (\_v7011 -> (case _v7011 of {T.TStruct _val7012 -> (to_CompactContact (T.TStruct _val7012)); _ -> P.error "wrong type"})) _val7010); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContactsModifiedSince_result_e = P.maybe (P.Nothing) (\(_,_val7009) -> P.Just (case _val7009 of {T.TStruct _val7013 -> (to_TalkException (T.TStruct _val7013)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContactsModifiedSince_result _ = P.error "not a struct"
read_GetCompactContactsModifiedSince_result :: T.Protocol p => p -> P.IO GetCompactContactsModifiedSince_result
read_GetCompactContactsModifiedSince_result iprot = to_GetCompactContactsModifiedSince_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_result)
decode_GetCompactContactsModifiedSince_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContactsModifiedSince_result
decode_GetCompactContactsModifiedSince_result iprot bs = to_GetCompactContactsModifiedSince_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContactsModifiedSince_result) bs
typemap_GetCompactContactsModifiedSince_result :: T.TypeMap
typemap_GetCompactContactsModifiedSince_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContactsModifiedSince_result :: GetCompactContactsModifiedSince_result
default_GetCompactContactsModifiedSince_result = GetCompactContactsModifiedSince_result{
  getCompactContactsModifiedSince_result_success = Vector.empty,
  getCompactContactsModifiedSince_result_e = P.Nothing}
data GetCompactGroup_args = GetCompactGroup_args  { getCompactGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactGroup_args_groupId record  
instance QC.Arbitrary GetCompactGroup_args where 
  arbitrary = M.liftM GetCompactGroup_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactGroup_args{getCompactGroup_args_groupId = getCompactGroup_args_groupId obj} then P.Nothing else P.Just $ default_GetCompactGroup_args{getCompactGroup_args_groupId = getCompactGroup_args_groupId obj}
    ]
from_GetCompactGroup_args :: GetCompactGroup_args -> T.ThriftVal
from_GetCompactGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7016 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v7016))) $ getCompactGroup_args_groupId record
  ]
write_GetCompactGroup_args :: T.Protocol p => p -> GetCompactGroup_args -> P.IO ()
write_GetCompactGroup_args oprot record = T.writeVal oprot $ from_GetCompactGroup_args record
encode_GetCompactGroup_args :: T.StatelessProtocol p => p -> GetCompactGroup_args -> LBS.ByteString
encode_GetCompactGroup_args oprot record = T.serializeVal oprot $ from_GetCompactGroup_args record
to_GetCompactGroup_args :: T.ThriftVal -> GetCompactGroup_args
to_GetCompactGroup_args (T.TStruct fields) = GetCompactGroup_args{
  getCompactGroup_args_groupId = P.maybe (getCompactGroup_args_groupId default_GetCompactGroup_args) (\(_,_val7018) -> (case _val7018 of {T.TString _val7019 -> E.decodeUtf8 _val7019; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactGroup_args _ = P.error "not a struct"
read_GetCompactGroup_args :: T.Protocol p => p -> P.IO GetCompactGroup_args
read_GetCompactGroup_args iprot = to_GetCompactGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactGroup_args)
decode_GetCompactGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactGroup_args
decode_GetCompactGroup_args iprot bs = to_GetCompactGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactGroup_args) bs
typemap_GetCompactGroup_args :: T.TypeMap
typemap_GetCompactGroup_args = Map.fromList [(2,("groupId",T.T_STRING))]
default_GetCompactGroup_args :: GetCompactGroup_args
default_GetCompactGroup_args = GetCompactGroup_args{
  getCompactGroup_args_groupId = ""}
data GetCompactGroup_result = GetCompactGroup_result  { getCompactGroup_result_success :: Group
  , getCompactGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactGroup_result_success record   `H.hashWithSalt` getCompactGroup_result_e record  
instance QC.Arbitrary GetCompactGroup_result where 
  arbitrary = M.liftM GetCompactGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactGroup_result{getCompactGroup_result_success = getCompactGroup_result_success obj} then P.Nothing else P.Just $ default_GetCompactGroup_result{getCompactGroup_result_success = getCompactGroup_result_success obj}
    , if obj == default_GetCompactGroup_result{getCompactGroup_result_e = getCompactGroup_result_e obj} then P.Nothing else P.Just $ default_GetCompactGroup_result{getCompactGroup_result_e = getCompactGroup_result_e obj}
    ]
from_GetCompactGroup_result :: GetCompactGroup_result -> T.ThriftVal
from_GetCompactGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7022 -> (1, ("e",from_TalkException _v7022))) <$> getCompactGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7022 -> P.Just (0, ("success",from_Group _v7022))) $ getCompactGroup_result_success record
    , (\_v7022 -> (1, ("e",from_TalkException _v7022))) <$> getCompactGroup_result_e record
    ]
    )
write_GetCompactGroup_result :: T.Protocol p => p -> GetCompactGroup_result -> P.IO ()
write_GetCompactGroup_result oprot record = T.writeVal oprot $ from_GetCompactGroup_result record
encode_GetCompactGroup_result :: T.StatelessProtocol p => p -> GetCompactGroup_result -> LBS.ByteString
encode_GetCompactGroup_result oprot record = T.serializeVal oprot $ from_GetCompactGroup_result record
to_GetCompactGroup_result :: T.ThriftVal -> GetCompactGroup_result
to_GetCompactGroup_result (T.TStruct fields) = GetCompactGroup_result{
  getCompactGroup_result_success = P.maybe (getCompactGroup_result_success default_GetCompactGroup_result) (\(_,_val7024) -> (case _val7024 of {T.TStruct _val7025 -> (to_Group (T.TStruct _val7025)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactGroup_result_e = P.maybe (P.Nothing) (\(_,_val7024) -> P.Just (case _val7024 of {T.TStruct _val7026 -> (to_TalkException (T.TStruct _val7026)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactGroup_result _ = P.error "not a struct"
read_GetCompactGroup_result :: T.Protocol p => p -> P.IO GetCompactGroup_result
read_GetCompactGroup_result iprot = to_GetCompactGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactGroup_result)
decode_GetCompactGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactGroup_result
decode_GetCompactGroup_result iprot bs = to_GetCompactGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactGroup_result) bs
typemap_GetCompactGroup_result :: T.TypeMap
typemap_GetCompactGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactGroup_result :: GetCompactGroup_result
default_GetCompactGroup_result = GetCompactGroup_result{
  getCompactGroup_result_success = default_Group,
  getCompactGroup_result_e = P.Nothing}
data GetCompactRoom_args = GetCompactRoom_args  { getCompactRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactRoom_args_roomId record  
instance QC.Arbitrary GetCompactRoom_args where 
  arbitrary = M.liftM GetCompactRoom_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactRoom_args{getCompactRoom_args_roomId = getCompactRoom_args_roomId obj} then P.Nothing else P.Just $ default_GetCompactRoom_args{getCompactRoom_args_roomId = getCompactRoom_args_roomId obj}
    ]
from_GetCompactRoom_args :: GetCompactRoom_args -> T.ThriftVal
from_GetCompactRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7029 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v7029))) $ getCompactRoom_args_roomId record
  ]
write_GetCompactRoom_args :: T.Protocol p => p -> GetCompactRoom_args -> P.IO ()
write_GetCompactRoom_args oprot record = T.writeVal oprot $ from_GetCompactRoom_args record
encode_GetCompactRoom_args :: T.StatelessProtocol p => p -> GetCompactRoom_args -> LBS.ByteString
encode_GetCompactRoom_args oprot record = T.serializeVal oprot $ from_GetCompactRoom_args record
to_GetCompactRoom_args :: T.ThriftVal -> GetCompactRoom_args
to_GetCompactRoom_args (T.TStruct fields) = GetCompactRoom_args{
  getCompactRoom_args_roomId = P.maybe (getCompactRoom_args_roomId default_GetCompactRoom_args) (\(_,_val7031) -> (case _val7031 of {T.TString _val7032 -> E.decodeUtf8 _val7032; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactRoom_args _ = P.error "not a struct"
read_GetCompactRoom_args :: T.Protocol p => p -> P.IO GetCompactRoom_args
read_GetCompactRoom_args iprot = to_GetCompactRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactRoom_args)
decode_GetCompactRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactRoom_args
decode_GetCompactRoom_args iprot bs = to_GetCompactRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactRoom_args) bs
typemap_GetCompactRoom_args :: T.TypeMap
typemap_GetCompactRoom_args = Map.fromList [(2,("roomId",T.T_STRING))]
default_GetCompactRoom_args :: GetCompactRoom_args
default_GetCompactRoom_args = GetCompactRoom_args{
  getCompactRoom_args_roomId = ""}
data GetCompactRoom_result = GetCompactRoom_result  { getCompactRoom_result_success :: Room
  , getCompactRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactRoom_result_success record   `H.hashWithSalt` getCompactRoom_result_e record  
instance QC.Arbitrary GetCompactRoom_result where 
  arbitrary = M.liftM GetCompactRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactRoom_result{getCompactRoom_result_success = getCompactRoom_result_success obj} then P.Nothing else P.Just $ default_GetCompactRoom_result{getCompactRoom_result_success = getCompactRoom_result_success obj}
    , if obj == default_GetCompactRoom_result{getCompactRoom_result_e = getCompactRoom_result_e obj} then P.Nothing else P.Just $ default_GetCompactRoom_result{getCompactRoom_result_e = getCompactRoom_result_e obj}
    ]
from_GetCompactRoom_result :: GetCompactRoom_result -> T.ThriftVal
from_GetCompactRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7035 -> (1, ("e",from_TalkException _v7035))) <$> getCompactRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7035 -> P.Just (0, ("success",from_Room _v7035))) $ getCompactRoom_result_success record
    , (\_v7035 -> (1, ("e",from_TalkException _v7035))) <$> getCompactRoom_result_e record
    ]
    )
write_GetCompactRoom_result :: T.Protocol p => p -> GetCompactRoom_result -> P.IO ()
write_GetCompactRoom_result oprot record = T.writeVal oprot $ from_GetCompactRoom_result record
encode_GetCompactRoom_result :: T.StatelessProtocol p => p -> GetCompactRoom_result -> LBS.ByteString
encode_GetCompactRoom_result oprot record = T.serializeVal oprot $ from_GetCompactRoom_result record
to_GetCompactRoom_result :: T.ThriftVal -> GetCompactRoom_result
to_GetCompactRoom_result (T.TStruct fields) = GetCompactRoom_result{
  getCompactRoom_result_success = P.maybe (getCompactRoom_result_success default_GetCompactRoom_result) (\(_,_val7037) -> (case _val7037 of {T.TStruct _val7038 -> (to_Room (T.TStruct _val7038)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactRoom_result_e = P.maybe (P.Nothing) (\(_,_val7037) -> P.Just (case _val7037 of {T.TStruct _val7039 -> (to_TalkException (T.TStruct _val7039)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactRoom_result _ = P.error "not a struct"
read_GetCompactRoom_result :: T.Protocol p => p -> P.IO GetCompactRoom_result
read_GetCompactRoom_result iprot = to_GetCompactRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactRoom_result)
decode_GetCompactRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactRoom_result
decode_GetCompactRoom_result iprot bs = to_GetCompactRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactRoom_result) bs
typemap_GetCompactRoom_result :: T.TypeMap
typemap_GetCompactRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactRoom_result :: GetCompactRoom_result
default_GetCompactRoom_result = GetCompactRoom_result{
  getCompactRoom_result_success = default_Room,
  getCompactRoom_result_e = P.Nothing}
data GetContact_args = GetContact_args  { getContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContact_args_id record  
instance QC.Arbitrary GetContact_args where 
  arbitrary = M.liftM GetContact_args (QC.arbitrary)
  shrink obj | obj == default_GetContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContact_args{getContact_args_id = getContact_args_id obj} then P.Nothing else P.Just $ default_GetContact_args{getContact_args_id = getContact_args_id obj}
    ]
from_GetContact_args :: GetContact_args -> T.ThriftVal
from_GetContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7042 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v7042))) $ getContact_args_id record
  ]
write_GetContact_args :: T.Protocol p => p -> GetContact_args -> P.IO ()
write_GetContact_args oprot record = T.writeVal oprot $ from_GetContact_args record
encode_GetContact_args :: T.StatelessProtocol p => p -> GetContact_args -> LBS.ByteString
encode_GetContact_args oprot record = T.serializeVal oprot $ from_GetContact_args record
to_GetContact_args :: T.ThriftVal -> GetContact_args
to_GetContact_args (T.TStruct fields) = GetContact_args{
  getContact_args_id = P.maybe (getContact_args_id default_GetContact_args) (\(_,_val7044) -> (case _val7044 of {T.TString _val7045 -> E.decodeUtf8 _val7045; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContact_args _ = P.error "not a struct"
read_GetContact_args :: T.Protocol p => p -> P.IO GetContact_args
read_GetContact_args iprot = to_GetContact_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContact_args)
decode_GetContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContact_args
decode_GetContact_args iprot bs = to_GetContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContact_args) bs
typemap_GetContact_args :: T.TypeMap
typemap_GetContact_args = Map.fromList [(2,("id",T.T_STRING))]
default_GetContact_args :: GetContact_args
default_GetContact_args = GetContact_args{
  getContact_args_id = ""}
data GetContact_result = GetContact_result  { getContact_result_success :: Contact
  , getContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContact_result_success record   `H.hashWithSalt` getContact_result_e record  
instance QC.Arbitrary GetContact_result where 
  arbitrary = M.liftM GetContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContact_result{getContact_result_success = getContact_result_success obj} then P.Nothing else P.Just $ default_GetContact_result{getContact_result_success = getContact_result_success obj}
    , if obj == default_GetContact_result{getContact_result_e = getContact_result_e obj} then P.Nothing else P.Just $ default_GetContact_result{getContact_result_e = getContact_result_e obj}
    ]
from_GetContact_result :: GetContact_result -> T.ThriftVal
from_GetContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7048 -> (1, ("e",from_TalkException _v7048))) <$> getContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7048 -> P.Just (0, ("success",from_Contact _v7048))) $ getContact_result_success record
    , (\_v7048 -> (1, ("e",from_TalkException _v7048))) <$> getContact_result_e record
    ]
    )
write_GetContact_result :: T.Protocol p => p -> GetContact_result -> P.IO ()
write_GetContact_result oprot record = T.writeVal oprot $ from_GetContact_result record
encode_GetContact_result :: T.StatelessProtocol p => p -> GetContact_result -> LBS.ByteString
encode_GetContact_result oprot record = T.serializeVal oprot $ from_GetContact_result record
to_GetContact_result :: T.ThriftVal -> GetContact_result
to_GetContact_result (T.TStruct fields) = GetContact_result{
  getContact_result_success = P.maybe (getContact_result_success default_GetContact_result) (\(_,_val7050) -> (case _val7050 of {T.TStruct _val7051 -> (to_Contact (T.TStruct _val7051)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContact_result_e = P.maybe (P.Nothing) (\(_,_val7050) -> P.Just (case _val7050 of {T.TStruct _val7052 -> (to_TalkException (T.TStruct _val7052)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContact_result _ = P.error "not a struct"
read_GetContact_result :: T.Protocol p => p -> P.IO GetContact_result
read_GetContact_result iprot = to_GetContact_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContact_result)
decode_GetContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContact_result
decode_GetContact_result iprot bs = to_GetContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContact_result) bs
typemap_GetContact_result :: T.TypeMap
typemap_GetContact_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContact_result :: GetContact_result
default_GetContact_result = GetContact_result{
  getContact_result_success = default_Contact,
  getContact_result_e = P.Nothing}
data GetContacts_args = GetContacts_args  { getContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContacts_args_ids record  
instance QC.Arbitrary GetContacts_args where 
  arbitrary = M.liftM GetContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContacts_args{getContacts_args_ids = getContacts_args_ids obj} then P.Nothing else P.Just $ default_GetContacts_args{getContacts_args_ids = getContacts_args_ids obj}
    ]
from_GetContacts_args :: GetContacts_args -> T.ThriftVal
from_GetContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7055 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v7057 -> T.TString $ E.encodeUtf8 _v7057) $ Vector.toList _v7055))) $ getContacts_args_ids record
  ]
write_GetContacts_args :: T.Protocol p => p -> GetContacts_args -> P.IO ()
write_GetContacts_args oprot record = T.writeVal oprot $ from_GetContacts_args record
encode_GetContacts_args :: T.StatelessProtocol p => p -> GetContacts_args -> LBS.ByteString
encode_GetContacts_args oprot record = T.serializeVal oprot $ from_GetContacts_args record
to_GetContacts_args :: T.ThriftVal -> GetContacts_args
to_GetContacts_args (T.TStruct fields) = GetContacts_args{
  getContacts_args_ids = P.maybe (getContacts_args_ids default_GetContacts_args) (\(_,_val7059) -> (case _val7059 of {T.TList _ _val7060 -> (Vector.fromList $ P.map (\_v7061 -> (case _v7061 of {T.TString _val7062 -> E.decodeUtf8 _val7062; _ -> P.error "wrong type"})) _val7060); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContacts_args _ = P.error "not a struct"
read_GetContacts_args :: T.Protocol p => p -> P.IO GetContacts_args
read_GetContacts_args iprot = to_GetContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContacts_args)
decode_GetContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContacts_args
decode_GetContacts_args iprot bs = to_GetContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContacts_args) bs
typemap_GetContacts_args :: T.TypeMap
typemap_GetContacts_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContacts_args :: GetContacts_args
default_GetContacts_args = GetContacts_args{
  getContacts_args_ids = Vector.empty}
data GetContacts_result = GetContacts_result  { getContacts_result_success :: (Vector.Vector Contact)
  , getContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContacts_result_success record   `H.hashWithSalt` getContacts_result_e record  
instance QC.Arbitrary GetContacts_result where 
  arbitrary = M.liftM GetContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContacts_result{getContacts_result_success = getContacts_result_success obj} then P.Nothing else P.Just $ default_GetContacts_result{getContacts_result_success = getContacts_result_success obj}
    , if obj == default_GetContacts_result{getContacts_result_e = getContacts_result_e obj} then P.Nothing else P.Just $ default_GetContacts_result{getContacts_result_e = getContacts_result_e obj}
    ]
from_GetContacts_result :: GetContacts_result -> T.ThriftVal
from_GetContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7065 -> (1, ("e",from_TalkException _v7065))) <$> getContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7065 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v7067 -> from_Contact _v7067) $ Vector.toList _v7065))) $ getContacts_result_success record
    , (\_v7065 -> (1, ("e",from_TalkException _v7065))) <$> getContacts_result_e record
    ]
    )
write_GetContacts_result :: T.Protocol p => p -> GetContacts_result -> P.IO ()
write_GetContacts_result oprot record = T.writeVal oprot $ from_GetContacts_result record
encode_GetContacts_result :: T.StatelessProtocol p => p -> GetContacts_result -> LBS.ByteString
encode_GetContacts_result oprot record = T.serializeVal oprot $ from_GetContacts_result record
to_GetContacts_result :: T.ThriftVal -> GetContacts_result
to_GetContacts_result (T.TStruct fields) = GetContacts_result{
  getContacts_result_success = P.maybe (getContacts_result_success default_GetContacts_result) (\(_,_val7069) -> (case _val7069 of {T.TList _ _val7070 -> (Vector.fromList $ P.map (\_v7071 -> (case _v7071 of {T.TStruct _val7072 -> (to_Contact (T.TStruct _val7072)); _ -> P.error "wrong type"})) _val7070); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContacts_result_e = P.maybe (P.Nothing) (\(_,_val7069) -> P.Just (case _val7069 of {T.TStruct _val7073 -> (to_TalkException (T.TStruct _val7073)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContacts_result _ = P.error "not a struct"
read_GetContacts_result :: T.Protocol p => p -> P.IO GetContacts_result
read_GetContacts_result iprot = to_GetContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContacts_result)
decode_GetContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContacts_result
decode_GetContacts_result iprot bs = to_GetContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContacts_result) bs
typemap_GetContacts_result :: T.TypeMap
typemap_GetContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContacts_result :: GetContacts_result
default_GetContacts_result = GetContacts_result{
  getContacts_result_success = Vector.empty,
  getContacts_result_e = P.Nothing}
data GetContactWithFriendRequestStatus_args = GetContactWithFriendRequestStatus_args  { getContactWithFriendRequestStatus_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactWithFriendRequestStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactWithFriendRequestStatus_args_id record  
instance QC.Arbitrary GetContactWithFriendRequestStatus_args where 
  arbitrary = M.liftM GetContactWithFriendRequestStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetContactWithFriendRequestStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactWithFriendRequestStatus_args{getContactWithFriendRequestStatus_args_id = getContactWithFriendRequestStatus_args_id obj} then P.Nothing else P.Just $ default_GetContactWithFriendRequestStatus_args{getContactWithFriendRequestStatus_args_id = getContactWithFriendRequestStatus_args_id obj}
    ]
from_GetContactWithFriendRequestStatus_args :: GetContactWithFriendRequestStatus_args -> T.ThriftVal
from_GetContactWithFriendRequestStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7076 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v7076))) $ getContactWithFriendRequestStatus_args_id record
  ]
write_GetContactWithFriendRequestStatus_args :: T.Protocol p => p -> GetContactWithFriendRequestStatus_args -> P.IO ()
write_GetContactWithFriendRequestStatus_args oprot record = T.writeVal oprot $ from_GetContactWithFriendRequestStatus_args record
encode_GetContactWithFriendRequestStatus_args :: T.StatelessProtocol p => p -> GetContactWithFriendRequestStatus_args -> LBS.ByteString
encode_GetContactWithFriendRequestStatus_args oprot record = T.serializeVal oprot $ from_GetContactWithFriendRequestStatus_args record
to_GetContactWithFriendRequestStatus_args :: T.ThriftVal -> GetContactWithFriendRequestStatus_args
to_GetContactWithFriendRequestStatus_args (T.TStruct fields) = GetContactWithFriendRequestStatus_args{
  getContactWithFriendRequestStatus_args_id = P.maybe (getContactWithFriendRequestStatus_args_id default_GetContactWithFriendRequestStatus_args) (\(_,_val7078) -> (case _val7078 of {T.TString _val7079 -> E.decodeUtf8 _val7079; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContactWithFriendRequestStatus_args _ = P.error "not a struct"
read_GetContactWithFriendRequestStatus_args :: T.Protocol p => p -> P.IO GetContactWithFriendRequestStatus_args
read_GetContactWithFriendRequestStatus_args iprot = to_GetContactWithFriendRequestStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContactWithFriendRequestStatus_args)
decode_GetContactWithFriendRequestStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactWithFriendRequestStatus_args
decode_GetContactWithFriendRequestStatus_args iprot bs = to_GetContactWithFriendRequestStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactWithFriendRequestStatus_args) bs
typemap_GetContactWithFriendRequestStatus_args :: T.TypeMap
typemap_GetContactWithFriendRequestStatus_args = Map.fromList [(2,("id",T.T_STRING))]
default_GetContactWithFriendRequestStatus_args :: GetContactWithFriendRequestStatus_args
default_GetContactWithFriendRequestStatus_args = GetContactWithFriendRequestStatus_args{
  getContactWithFriendRequestStatus_args_id = ""}
data GetContactWithFriendRequestStatus_result = GetContactWithFriendRequestStatus_result  { getContactWithFriendRequestStatus_result_success :: Contact
  , getContactWithFriendRequestStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactWithFriendRequestStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactWithFriendRequestStatus_result_success record   `H.hashWithSalt` getContactWithFriendRequestStatus_result_e record  
instance QC.Arbitrary GetContactWithFriendRequestStatus_result where 
  arbitrary = M.liftM GetContactWithFriendRequestStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContactWithFriendRequestStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_success = getContactWithFriendRequestStatus_result_success obj} then P.Nothing else P.Just $ default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_success = getContactWithFriendRequestStatus_result_success obj}
    , if obj == default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_e = getContactWithFriendRequestStatus_result_e obj} then P.Nothing else P.Just $ default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_e = getContactWithFriendRequestStatus_result_e obj}
    ]
from_GetContactWithFriendRequestStatus_result :: GetContactWithFriendRequestStatus_result -> T.ThriftVal
from_GetContactWithFriendRequestStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7082 -> (1, ("e",from_TalkException _v7082))) <$> getContactWithFriendRequestStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7082 -> P.Just (0, ("success",from_Contact _v7082))) $ getContactWithFriendRequestStatus_result_success record
    , (\_v7082 -> (1, ("e",from_TalkException _v7082))) <$> getContactWithFriendRequestStatus_result_e record
    ]
    )
write_GetContactWithFriendRequestStatus_result :: T.Protocol p => p -> GetContactWithFriendRequestStatus_result -> P.IO ()
write_GetContactWithFriendRequestStatus_result oprot record = T.writeVal oprot $ from_GetContactWithFriendRequestStatus_result record
encode_GetContactWithFriendRequestStatus_result :: T.StatelessProtocol p => p -> GetContactWithFriendRequestStatus_result -> LBS.ByteString
encode_GetContactWithFriendRequestStatus_result oprot record = T.serializeVal oprot $ from_GetContactWithFriendRequestStatus_result record
to_GetContactWithFriendRequestStatus_result :: T.ThriftVal -> GetContactWithFriendRequestStatus_result
to_GetContactWithFriendRequestStatus_result (T.TStruct fields) = GetContactWithFriendRequestStatus_result{
  getContactWithFriendRequestStatus_result_success = P.maybe (getContactWithFriendRequestStatus_result_success default_GetContactWithFriendRequestStatus_result) (\(_,_val7084) -> (case _val7084 of {T.TStruct _val7085 -> (to_Contact (T.TStruct _val7085)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContactWithFriendRequestStatus_result_e = P.maybe (P.Nothing) (\(_,_val7084) -> P.Just (case _val7084 of {T.TStruct _val7086 -> (to_TalkException (T.TStruct _val7086)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContactWithFriendRequestStatus_result _ = P.error "not a struct"
read_GetContactWithFriendRequestStatus_result :: T.Protocol p => p -> P.IO GetContactWithFriendRequestStatus_result
read_GetContactWithFriendRequestStatus_result iprot = to_GetContactWithFriendRequestStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContactWithFriendRequestStatus_result)
decode_GetContactWithFriendRequestStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactWithFriendRequestStatus_result
decode_GetContactWithFriendRequestStatus_result iprot bs = to_GetContactWithFriendRequestStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactWithFriendRequestStatus_result) bs
typemap_GetContactWithFriendRequestStatus_result :: T.TypeMap
typemap_GetContactWithFriendRequestStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContactWithFriendRequestStatus_result :: GetContactWithFriendRequestStatus_result
default_GetContactWithFriendRequestStatus_result = GetContactWithFriendRequestStatus_result{
  getContactWithFriendRequestStatus_result_success = default_Contact,
  getContactWithFriendRequestStatus_result_e = P.Nothing}
data GetCountryWithRequestIp_args = GetCountryWithRequestIp_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCountryWithRequestIp_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetCountryWithRequestIp_args where 
  arbitrary = QC.elements [GetCountryWithRequestIp_args]
from_GetCountryWithRequestIp_args :: GetCountryWithRequestIp_args -> T.ThriftVal
from_GetCountryWithRequestIp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetCountryWithRequestIp_args :: T.Protocol p => p -> GetCountryWithRequestIp_args -> P.IO ()
write_GetCountryWithRequestIp_args oprot record = T.writeVal oprot $ from_GetCountryWithRequestIp_args record
encode_GetCountryWithRequestIp_args :: T.StatelessProtocol p => p -> GetCountryWithRequestIp_args -> LBS.ByteString
encode_GetCountryWithRequestIp_args oprot record = T.serializeVal oprot $ from_GetCountryWithRequestIp_args record
to_GetCountryWithRequestIp_args :: T.ThriftVal -> GetCountryWithRequestIp_args
to_GetCountryWithRequestIp_args (T.TStruct fields) = GetCountryWithRequestIp_args{

  }
to_GetCountryWithRequestIp_args _ = P.error "not a struct"
read_GetCountryWithRequestIp_args :: T.Protocol p => p -> P.IO GetCountryWithRequestIp_args
read_GetCountryWithRequestIp_args iprot = to_GetCountryWithRequestIp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_args)
decode_GetCountryWithRequestIp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCountryWithRequestIp_args
decode_GetCountryWithRequestIp_args iprot bs = to_GetCountryWithRequestIp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_args) bs
typemap_GetCountryWithRequestIp_args :: T.TypeMap
typemap_GetCountryWithRequestIp_args = Map.fromList []
default_GetCountryWithRequestIp_args :: GetCountryWithRequestIp_args
default_GetCountryWithRequestIp_args = GetCountryWithRequestIp_args{
}
data GetCountryWithRequestIp_result = GetCountryWithRequestIp_result  { getCountryWithRequestIp_result_success :: LT.Text
  , getCountryWithRequestIp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCountryWithRequestIp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCountryWithRequestIp_result_success record   `H.hashWithSalt` getCountryWithRequestIp_result_e record  
instance QC.Arbitrary GetCountryWithRequestIp_result where 
  arbitrary = M.liftM GetCountryWithRequestIp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCountryWithRequestIp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = getCountryWithRequestIp_result_success obj} then P.Nothing else P.Just $ default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = getCountryWithRequestIp_result_success obj}
    , if obj == default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = getCountryWithRequestIp_result_e obj} then P.Nothing else P.Just $ default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = getCountryWithRequestIp_result_e obj}
    ]
from_GetCountryWithRequestIp_result :: GetCountryWithRequestIp_result -> T.ThriftVal
from_GetCountryWithRequestIp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7094 -> (1, ("e",from_TalkException _v7094))) <$> getCountryWithRequestIp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7094 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v7094))) $ getCountryWithRequestIp_result_success record
    , (\_v7094 -> (1, ("e",from_TalkException _v7094))) <$> getCountryWithRequestIp_result_e record
    ]
    )
write_GetCountryWithRequestIp_result :: T.Protocol p => p -> GetCountryWithRequestIp_result -> P.IO ()
write_GetCountryWithRequestIp_result oprot record = T.writeVal oprot $ from_GetCountryWithRequestIp_result record
encode_GetCountryWithRequestIp_result :: T.StatelessProtocol p => p -> GetCountryWithRequestIp_result -> LBS.ByteString
encode_GetCountryWithRequestIp_result oprot record = T.serializeVal oprot $ from_GetCountryWithRequestIp_result record
to_GetCountryWithRequestIp_result :: T.ThriftVal -> GetCountryWithRequestIp_result
to_GetCountryWithRequestIp_result (T.TStruct fields) = GetCountryWithRequestIp_result{
  getCountryWithRequestIp_result_success = P.maybe (getCountryWithRequestIp_result_success default_GetCountryWithRequestIp_result) (\(_,_val7096) -> (case _val7096 of {T.TString _val7097 -> E.decodeUtf8 _val7097; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCountryWithRequestIp_result_e = P.maybe (P.Nothing) (\(_,_val7096) -> P.Just (case _val7096 of {T.TStruct _val7098 -> (to_TalkException (T.TStruct _val7098)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCountryWithRequestIp_result _ = P.error "not a struct"
read_GetCountryWithRequestIp_result :: T.Protocol p => p -> P.IO GetCountryWithRequestIp_result
read_GetCountryWithRequestIp_result iprot = to_GetCountryWithRequestIp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_result)
decode_GetCountryWithRequestIp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCountryWithRequestIp_result
decode_GetCountryWithRequestIp_result iprot bs = to_GetCountryWithRequestIp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCountryWithRequestIp_result) bs
typemap_GetCountryWithRequestIp_result :: T.TypeMap
typemap_GetCountryWithRequestIp_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCountryWithRequestIp_result :: GetCountryWithRequestIp_result
default_GetCountryWithRequestIp_result = GetCountryWithRequestIp_result{
  getCountryWithRequestIp_result_success = "",
  getCountryWithRequestIp_result_e = P.Nothing}
data GetFavoriteMids_args = GetFavoriteMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMids_args where 
  arbitrary = QC.elements [GetFavoriteMids_args]
from_GetFavoriteMids_args :: GetFavoriteMids_args -> T.ThriftVal
from_GetFavoriteMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMids_args :: T.Protocol p => p -> GetFavoriteMids_args -> P.IO ()
write_GetFavoriteMids_args oprot record = T.writeVal oprot $ from_GetFavoriteMids_args record
encode_GetFavoriteMids_args :: T.StatelessProtocol p => p -> GetFavoriteMids_args -> LBS.ByteString
encode_GetFavoriteMids_args oprot record = T.serializeVal oprot $ from_GetFavoriteMids_args record
to_GetFavoriteMids_args :: T.ThriftVal -> GetFavoriteMids_args
to_GetFavoriteMids_args (T.TStruct fields) = GetFavoriteMids_args{

  }
to_GetFavoriteMids_args _ = P.error "not a struct"
read_GetFavoriteMids_args :: T.Protocol p => p -> P.IO GetFavoriteMids_args
read_GetFavoriteMids_args iprot = to_GetFavoriteMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMids_args)
decode_GetFavoriteMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMids_args
decode_GetFavoriteMids_args iprot bs = to_GetFavoriteMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMids_args) bs
typemap_GetFavoriteMids_args :: T.TypeMap
typemap_GetFavoriteMids_args = Map.fromList []
default_GetFavoriteMids_args :: GetFavoriteMids_args
default_GetFavoriteMids_args = GetFavoriteMids_args{
}
data GetFavoriteMids_result = GetFavoriteMids_result  { getFavoriteMids_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMids_result_success record   `H.hashWithSalt` getFavoriteMids_result_e record  
instance QC.Arbitrary GetFavoriteMids_result where 
  arbitrary = M.liftM GetFavoriteMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMids_result{getFavoriteMids_result_success = getFavoriteMids_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMids_result{getFavoriteMids_result_success = getFavoriteMids_result_success obj}
    , if obj == default_GetFavoriteMids_result{getFavoriteMids_result_e = getFavoriteMids_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMids_result{getFavoriteMids_result_e = getFavoriteMids_result_e obj}
    ]
from_GetFavoriteMids_result :: GetFavoriteMids_result -> T.ThriftVal
from_GetFavoriteMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7106 -> (1, ("e",from_TalkException _v7106))) <$> getFavoriteMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7106 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v7108 -> T.TString $ E.encodeUtf8 _v7108) $ Vector.toList _v7106))) $ getFavoriteMids_result_success record
    , (\_v7106 -> (1, ("e",from_TalkException _v7106))) <$> getFavoriteMids_result_e record
    ]
    )
write_GetFavoriteMids_result :: T.Protocol p => p -> GetFavoriteMids_result -> P.IO ()
write_GetFavoriteMids_result oprot record = T.writeVal oprot $ from_GetFavoriteMids_result record
encode_GetFavoriteMids_result :: T.StatelessProtocol p => p -> GetFavoriteMids_result -> LBS.ByteString
encode_GetFavoriteMids_result oprot record = T.serializeVal oprot $ from_GetFavoriteMids_result record
to_GetFavoriteMids_result :: T.ThriftVal -> GetFavoriteMids_result
to_GetFavoriteMids_result (T.TStruct fields) = GetFavoriteMids_result{
  getFavoriteMids_result_success = P.maybe (getFavoriteMids_result_success default_GetFavoriteMids_result) (\(_,_val7110) -> (case _val7110 of {T.TList _ _val7111 -> (Vector.fromList $ P.map (\_v7112 -> (case _v7112 of {T.TString _val7113 -> E.decodeUtf8 _val7113; _ -> P.error "wrong type"})) _val7111); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMids_result_e = P.maybe (P.Nothing) (\(_,_val7110) -> P.Just (case _val7110 of {T.TStruct _val7114 -> (to_TalkException (T.TStruct _val7114)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMids_result _ = P.error "not a struct"
read_GetFavoriteMids_result :: T.Protocol p => p -> P.IO GetFavoriteMids_result
read_GetFavoriteMids_result iprot = to_GetFavoriteMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMids_result)
decode_GetFavoriteMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMids_result
decode_GetFavoriteMids_result iprot bs = to_GetFavoriteMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMids_result) bs
typemap_GetFavoriteMids_result :: T.TypeMap
typemap_GetFavoriteMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMids_result :: GetFavoriteMids_result
default_GetFavoriteMids_result = GetFavoriteMids_result{
  getFavoriteMids_result_success = Vector.empty,
  getFavoriteMids_result_e = P.Nothing}
data GetGroup_args = GetGroup_args  { getGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroup_args_groupId record  
instance QC.Arbitrary GetGroup_args where 
  arbitrary = M.liftM GetGroup_args (QC.arbitrary)
  shrink obj | obj == default_GetGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroup_args{getGroup_args_groupId = getGroup_args_groupId obj} then P.Nothing else P.Just $ default_GetGroup_args{getGroup_args_groupId = getGroup_args_groupId obj}
    ]
from_GetGroup_args :: GetGroup_args -> T.ThriftVal
from_GetGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7117 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v7117))) $ getGroup_args_groupId record
  ]
write_GetGroup_args :: T.Protocol p => p -> GetGroup_args -> P.IO ()
write_GetGroup_args oprot record = T.writeVal oprot $ from_GetGroup_args record
encode_GetGroup_args :: T.StatelessProtocol p => p -> GetGroup_args -> LBS.ByteString
encode_GetGroup_args oprot record = T.serializeVal oprot $ from_GetGroup_args record
to_GetGroup_args :: T.ThriftVal -> GetGroup_args
to_GetGroup_args (T.TStruct fields) = GetGroup_args{
  getGroup_args_groupId = P.maybe (getGroup_args_groupId default_GetGroup_args) (\(_,_val7119) -> (case _val7119 of {T.TString _val7120 -> E.decodeUtf8 _val7120; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroup_args _ = P.error "not a struct"
read_GetGroup_args :: T.Protocol p => p -> P.IO GetGroup_args
read_GetGroup_args iprot = to_GetGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroup_args)
decode_GetGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroup_args
decode_GetGroup_args iprot bs = to_GetGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroup_args) bs
typemap_GetGroup_args :: T.TypeMap
typemap_GetGroup_args = Map.fromList [(2,("groupId",T.T_STRING))]
default_GetGroup_args :: GetGroup_args
default_GetGroup_args = GetGroup_args{
  getGroup_args_groupId = ""}
data GetGroup_result = GetGroup_result  { getGroup_result_success :: Group
  , getGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroup_result_success record   `H.hashWithSalt` getGroup_result_e record  
instance QC.Arbitrary GetGroup_result where 
  arbitrary = M.liftM GetGroup_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroup_result{getGroup_result_success = getGroup_result_success obj} then P.Nothing else P.Just $ default_GetGroup_result{getGroup_result_success = getGroup_result_success obj}
    , if obj == default_GetGroup_result{getGroup_result_e = getGroup_result_e obj} then P.Nothing else P.Just $ default_GetGroup_result{getGroup_result_e = getGroup_result_e obj}
    ]
from_GetGroup_result :: GetGroup_result -> T.ThriftVal
from_GetGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7123 -> (1, ("e",from_TalkException _v7123))) <$> getGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7123 -> P.Just (0, ("success",from_Group _v7123))) $ getGroup_result_success record
    , (\_v7123 -> (1, ("e",from_TalkException _v7123))) <$> getGroup_result_e record
    ]
    )
write_GetGroup_result :: T.Protocol p => p -> GetGroup_result -> P.IO ()
write_GetGroup_result oprot record = T.writeVal oprot $ from_GetGroup_result record
encode_GetGroup_result :: T.StatelessProtocol p => p -> GetGroup_result -> LBS.ByteString
encode_GetGroup_result oprot record = T.serializeVal oprot $ from_GetGroup_result record
to_GetGroup_result :: T.ThriftVal -> GetGroup_result
to_GetGroup_result (T.TStruct fields) = GetGroup_result{
  getGroup_result_success = P.maybe (getGroup_result_success default_GetGroup_result) (\(_,_val7125) -> (case _val7125 of {T.TStruct _val7126 -> (to_Group (T.TStruct _val7126)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroup_result_e = P.maybe (P.Nothing) (\(_,_val7125) -> P.Just (case _val7125 of {T.TStruct _val7127 -> (to_TalkException (T.TStruct _val7127)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroup_result _ = P.error "not a struct"
read_GetGroup_result :: T.Protocol p => p -> P.IO GetGroup_result
read_GetGroup_result iprot = to_GetGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroup_result)
decode_GetGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroup_result
decode_GetGroup_result iprot bs = to_GetGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroup_result) bs
typemap_GetGroup_result :: T.TypeMap
typemap_GetGroup_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroup_result :: GetGroup_result
default_GetGroup_result = GetGroup_result{
  getGroup_result_success = default_Group,
  getGroup_result_e = P.Nothing}
data GetGroupIdsInvited_args = GetGroupIdsInvited_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsInvited_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetGroupIdsInvited_args where 
  arbitrary = QC.elements [GetGroupIdsInvited_args]
from_GetGroupIdsInvited_args :: GetGroupIdsInvited_args -> T.ThriftVal
from_GetGroupIdsInvited_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetGroupIdsInvited_args :: T.Protocol p => p -> GetGroupIdsInvited_args -> P.IO ()
write_GetGroupIdsInvited_args oprot record = T.writeVal oprot $ from_GetGroupIdsInvited_args record
encode_GetGroupIdsInvited_args :: T.StatelessProtocol p => p -> GetGroupIdsInvited_args -> LBS.ByteString
encode_GetGroupIdsInvited_args oprot record = T.serializeVal oprot $ from_GetGroupIdsInvited_args record
to_GetGroupIdsInvited_args :: T.ThriftVal -> GetGroupIdsInvited_args
to_GetGroupIdsInvited_args (T.TStruct fields) = GetGroupIdsInvited_args{

  }
to_GetGroupIdsInvited_args _ = P.error "not a struct"
read_GetGroupIdsInvited_args :: T.Protocol p => p -> P.IO GetGroupIdsInvited_args
read_GetGroupIdsInvited_args iprot = to_GetGroupIdsInvited_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_args)
decode_GetGroupIdsInvited_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsInvited_args
decode_GetGroupIdsInvited_args iprot bs = to_GetGroupIdsInvited_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_args) bs
typemap_GetGroupIdsInvited_args :: T.TypeMap
typemap_GetGroupIdsInvited_args = Map.fromList []
default_GetGroupIdsInvited_args :: GetGroupIdsInvited_args
default_GetGroupIdsInvited_args = GetGroupIdsInvited_args{
}
data GetGroupIdsInvited_result = GetGroupIdsInvited_result  { getGroupIdsInvited_result_success :: (Vector.Vector LT.Text)
  , getGroupIdsInvited_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsInvited_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupIdsInvited_result_success record   `H.hashWithSalt` getGroupIdsInvited_result_e record  
instance QC.Arbitrary GetGroupIdsInvited_result where 
  arbitrary = M.liftM GetGroupIdsInvited_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupIdsInvited_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = getGroupIdsInvited_result_success obj} then P.Nothing else P.Just $ default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = getGroupIdsInvited_result_success obj}
    , if obj == default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = getGroupIdsInvited_result_e obj} then P.Nothing else P.Just $ default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = getGroupIdsInvited_result_e obj}
    ]
from_GetGroupIdsInvited_result :: GetGroupIdsInvited_result -> T.ThriftVal
from_GetGroupIdsInvited_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7135 -> (1, ("e",from_TalkException _v7135))) <$> getGroupIdsInvited_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7135 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v7137 -> T.TString $ E.encodeUtf8 _v7137) $ Vector.toList _v7135))) $ getGroupIdsInvited_result_success record
    , (\_v7135 -> (1, ("e",from_TalkException _v7135))) <$> getGroupIdsInvited_result_e record
    ]
    )
write_GetGroupIdsInvited_result :: T.Protocol p => p -> GetGroupIdsInvited_result -> P.IO ()
write_GetGroupIdsInvited_result oprot record = T.writeVal oprot $ from_GetGroupIdsInvited_result record
encode_GetGroupIdsInvited_result :: T.StatelessProtocol p => p -> GetGroupIdsInvited_result -> LBS.ByteString
encode_GetGroupIdsInvited_result oprot record = T.serializeVal oprot $ from_GetGroupIdsInvited_result record
to_GetGroupIdsInvited_result :: T.ThriftVal -> GetGroupIdsInvited_result
to_GetGroupIdsInvited_result (T.TStruct fields) = GetGroupIdsInvited_result{
  getGroupIdsInvited_result_success = P.maybe (getGroupIdsInvited_result_success default_GetGroupIdsInvited_result) (\(_,_val7139) -> (case _val7139 of {T.TList _ _val7140 -> (Vector.fromList $ P.map (\_v7141 -> (case _v7141 of {T.TString _val7142 -> E.decodeUtf8 _val7142; _ -> P.error "wrong type"})) _val7140); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupIdsInvited_result_e = P.maybe (P.Nothing) (\(_,_val7139) -> P.Just (case _val7139 of {T.TStruct _val7143 -> (to_TalkException (T.TStruct _val7143)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupIdsInvited_result _ = P.error "not a struct"
read_GetGroupIdsInvited_result :: T.Protocol p => p -> P.IO GetGroupIdsInvited_result
read_GetGroupIdsInvited_result iprot = to_GetGroupIdsInvited_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_result)
decode_GetGroupIdsInvited_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsInvited_result
decode_GetGroupIdsInvited_result iprot bs = to_GetGroupIdsInvited_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsInvited_result) bs
typemap_GetGroupIdsInvited_result :: T.TypeMap
typemap_GetGroupIdsInvited_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupIdsInvited_result :: GetGroupIdsInvited_result
default_GetGroupIdsInvited_result = GetGroupIdsInvited_result{
  getGroupIdsInvited_result_success = Vector.empty,
  getGroupIdsInvited_result_e = P.Nothing}
data GetGroupIdsJoined_args = GetGroupIdsJoined_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsJoined_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetGroupIdsJoined_args where 
  arbitrary = QC.elements [GetGroupIdsJoined_args]
from_GetGroupIdsJoined_args :: GetGroupIdsJoined_args -> T.ThriftVal
from_GetGroupIdsJoined_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetGroupIdsJoined_args :: T.Protocol p => p -> GetGroupIdsJoined_args -> P.IO ()
write_GetGroupIdsJoined_args oprot record = T.writeVal oprot $ from_GetGroupIdsJoined_args record
encode_GetGroupIdsJoined_args :: T.StatelessProtocol p => p -> GetGroupIdsJoined_args -> LBS.ByteString
encode_GetGroupIdsJoined_args oprot record = T.serializeVal oprot $ from_GetGroupIdsJoined_args record
to_GetGroupIdsJoined_args :: T.ThriftVal -> GetGroupIdsJoined_args
to_GetGroupIdsJoined_args (T.TStruct fields) = GetGroupIdsJoined_args{

  }
to_GetGroupIdsJoined_args _ = P.error "not a struct"
read_GetGroupIdsJoined_args :: T.Protocol p => p -> P.IO GetGroupIdsJoined_args
read_GetGroupIdsJoined_args iprot = to_GetGroupIdsJoined_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_args)
decode_GetGroupIdsJoined_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsJoined_args
decode_GetGroupIdsJoined_args iprot bs = to_GetGroupIdsJoined_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_args) bs
typemap_GetGroupIdsJoined_args :: T.TypeMap
typemap_GetGroupIdsJoined_args = Map.fromList []
default_GetGroupIdsJoined_args :: GetGroupIdsJoined_args
default_GetGroupIdsJoined_args = GetGroupIdsJoined_args{
}
data GetGroupIdsJoined_result = GetGroupIdsJoined_result  { getGroupIdsJoined_result_success :: (Vector.Vector LT.Text)
  , getGroupIdsJoined_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupIdsJoined_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupIdsJoined_result_success record   `H.hashWithSalt` getGroupIdsJoined_result_e record  
instance QC.Arbitrary GetGroupIdsJoined_result where 
  arbitrary = M.liftM GetGroupIdsJoined_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupIdsJoined_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = getGroupIdsJoined_result_success obj} then P.Nothing else P.Just $ default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = getGroupIdsJoined_result_success obj}
    , if obj == default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = getGroupIdsJoined_result_e obj} then P.Nothing else P.Just $ default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = getGroupIdsJoined_result_e obj}
    ]
from_GetGroupIdsJoined_result :: GetGroupIdsJoined_result -> T.ThriftVal
from_GetGroupIdsJoined_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7151 -> (1, ("e",from_TalkException _v7151))) <$> getGroupIdsJoined_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7151 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v7153 -> T.TString $ E.encodeUtf8 _v7153) $ Vector.toList _v7151))) $ getGroupIdsJoined_result_success record
    , (\_v7151 -> (1, ("e",from_TalkException _v7151))) <$> getGroupIdsJoined_result_e record
    ]
    )
write_GetGroupIdsJoined_result :: T.Protocol p => p -> GetGroupIdsJoined_result -> P.IO ()
write_GetGroupIdsJoined_result oprot record = T.writeVal oprot $ from_GetGroupIdsJoined_result record
encode_GetGroupIdsJoined_result :: T.StatelessProtocol p => p -> GetGroupIdsJoined_result -> LBS.ByteString
encode_GetGroupIdsJoined_result oprot record = T.serializeVal oprot $ from_GetGroupIdsJoined_result record
to_GetGroupIdsJoined_result :: T.ThriftVal -> GetGroupIdsJoined_result
to_GetGroupIdsJoined_result (T.TStruct fields) = GetGroupIdsJoined_result{
  getGroupIdsJoined_result_success = P.maybe (getGroupIdsJoined_result_success default_GetGroupIdsJoined_result) (\(_,_val7155) -> (case _val7155 of {T.TList _ _val7156 -> (Vector.fromList $ P.map (\_v7157 -> (case _v7157 of {T.TString _val7158 -> E.decodeUtf8 _val7158; _ -> P.error "wrong type"})) _val7156); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupIdsJoined_result_e = P.maybe (P.Nothing) (\(_,_val7155) -> P.Just (case _val7155 of {T.TStruct _val7159 -> (to_TalkException (T.TStruct _val7159)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupIdsJoined_result _ = P.error "not a struct"
read_GetGroupIdsJoined_result :: T.Protocol p => p -> P.IO GetGroupIdsJoined_result
read_GetGroupIdsJoined_result iprot = to_GetGroupIdsJoined_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_result)
decode_GetGroupIdsJoined_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupIdsJoined_result
decode_GetGroupIdsJoined_result iprot bs = to_GetGroupIdsJoined_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupIdsJoined_result) bs
typemap_GetGroupIdsJoined_result :: T.TypeMap
typemap_GetGroupIdsJoined_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupIdsJoined_result :: GetGroupIdsJoined_result
default_GetGroupIdsJoined_result = GetGroupIdsJoined_result{
  getGroupIdsJoined_result_success = Vector.empty,
  getGroupIdsJoined_result_e = P.Nothing}
data GetGroups_args = GetGroups_args  { getGroups_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroups_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroups_args_groupIds record  
instance QC.Arbitrary GetGroups_args where 
  arbitrary = M.liftM GetGroups_args (QC.arbitrary)
  shrink obj | obj == default_GetGroups_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroups_args{getGroups_args_groupIds = getGroups_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroups_args{getGroups_args_groupIds = getGroups_args_groupIds obj}
    ]
from_GetGroups_args :: GetGroups_args -> T.ThriftVal
from_GetGroups_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7162 -> P.Just (2, ("groupIds",T.TList T.T_STRING $ P.map (\_v7164 -> T.TString $ E.encodeUtf8 _v7164) $ Vector.toList _v7162))) $ getGroups_args_groupIds record
  ]
write_GetGroups_args :: T.Protocol p => p -> GetGroups_args -> P.IO ()
write_GetGroups_args oprot record = T.writeVal oprot $ from_GetGroups_args record
encode_GetGroups_args :: T.StatelessProtocol p => p -> GetGroups_args -> LBS.ByteString
encode_GetGroups_args oprot record = T.serializeVal oprot $ from_GetGroups_args record
to_GetGroups_args :: T.ThriftVal -> GetGroups_args
to_GetGroups_args (T.TStruct fields) = GetGroups_args{
  getGroups_args_groupIds = P.maybe (getGroups_args_groupIds default_GetGroups_args) (\(_,_val7166) -> (case _val7166 of {T.TList _ _val7167 -> (Vector.fromList $ P.map (\_v7168 -> (case _v7168 of {T.TString _val7169 -> E.decodeUtf8 _val7169; _ -> P.error "wrong type"})) _val7167); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroups_args _ = P.error "not a struct"
read_GetGroups_args :: T.Protocol p => p -> P.IO GetGroups_args
read_GetGroups_args iprot = to_GetGroups_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroups_args)
decode_GetGroups_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroups_args
decode_GetGroups_args iprot bs = to_GetGroups_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroups_args) bs
typemap_GetGroups_args :: T.TypeMap
typemap_GetGroups_args = Map.fromList [(2,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroups_args :: GetGroups_args
default_GetGroups_args = GetGroups_args{
  getGroups_args_groupIds = Vector.empty}
data GetGroups_result = GetGroups_result  { getGroups_result_success :: (Vector.Vector Group)
  , getGroups_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroups_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroups_result_success record   `H.hashWithSalt` getGroups_result_e record  
instance QC.Arbitrary GetGroups_result where 
  arbitrary = M.liftM GetGroups_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroups_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroups_result{getGroups_result_success = getGroups_result_success obj} then P.Nothing else P.Just $ default_GetGroups_result{getGroups_result_success = getGroups_result_success obj}
    , if obj == default_GetGroups_result{getGroups_result_e = getGroups_result_e obj} then P.Nothing else P.Just $ default_GetGroups_result{getGroups_result_e = getGroups_result_e obj}
    ]
from_GetGroups_result :: GetGroups_result -> T.ThriftVal
from_GetGroups_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7172 -> (1, ("e",from_TalkException _v7172))) <$> getGroups_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7172 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v7174 -> from_Group _v7174) $ Vector.toList _v7172))) $ getGroups_result_success record
    , (\_v7172 -> (1, ("e",from_TalkException _v7172))) <$> getGroups_result_e record
    ]
    )
write_GetGroups_result :: T.Protocol p => p -> GetGroups_result -> P.IO ()
write_GetGroups_result oprot record = T.writeVal oprot $ from_GetGroups_result record
encode_GetGroups_result :: T.StatelessProtocol p => p -> GetGroups_result -> LBS.ByteString
encode_GetGroups_result oprot record = T.serializeVal oprot $ from_GetGroups_result record
to_GetGroups_result :: T.ThriftVal -> GetGroups_result
to_GetGroups_result (T.TStruct fields) = GetGroups_result{
  getGroups_result_success = P.maybe (getGroups_result_success default_GetGroups_result) (\(_,_val7176) -> (case _val7176 of {T.TList _ _val7177 -> (Vector.fromList $ P.map (\_v7178 -> (case _v7178 of {T.TStruct _val7179 -> (to_Group (T.TStruct _val7179)); _ -> P.error "wrong type"})) _val7177); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroups_result_e = P.maybe (P.Nothing) (\(_,_val7176) -> P.Just (case _val7176 of {T.TStruct _val7180 -> (to_TalkException (T.TStruct _val7180)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroups_result _ = P.error "not a struct"
read_GetGroups_result :: T.Protocol p => p -> P.IO GetGroups_result
read_GetGroups_result iprot = to_GetGroups_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroups_result)
decode_GetGroups_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroups_result
decode_GetGroups_result iprot bs = to_GetGroups_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroups_result) bs
typemap_GetGroups_result :: T.TypeMap
typemap_GetGroups_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroups_result :: GetGroups_result
default_GetGroups_result = GetGroups_result{
  getGroups_result_success = Vector.empty,
  getGroups_result_e = P.Nothing}
data GetHiddenContactMids_args = GetHiddenContactMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetHiddenContactMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetHiddenContactMids_args where 
  arbitrary = QC.elements [GetHiddenContactMids_args]
from_GetHiddenContactMids_args :: GetHiddenContactMids_args -> T.ThriftVal
from_GetHiddenContactMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetHiddenContactMids_args :: T.Protocol p => p -> GetHiddenContactMids_args -> P.IO ()
write_GetHiddenContactMids_args oprot record = T.writeVal oprot $ from_GetHiddenContactMids_args record
encode_GetHiddenContactMids_args :: T.StatelessProtocol p => p -> GetHiddenContactMids_args -> LBS.ByteString
encode_GetHiddenContactMids_args oprot record = T.serializeVal oprot $ from_GetHiddenContactMids_args record
to_GetHiddenContactMids_args :: T.ThriftVal -> GetHiddenContactMids_args
to_GetHiddenContactMids_args (T.TStruct fields) = GetHiddenContactMids_args{

  }
to_GetHiddenContactMids_args _ = P.error "not a struct"
read_GetHiddenContactMids_args :: T.Protocol p => p -> P.IO GetHiddenContactMids_args
read_GetHiddenContactMids_args iprot = to_GetHiddenContactMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_args)
decode_GetHiddenContactMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetHiddenContactMids_args
decode_GetHiddenContactMids_args iprot bs = to_GetHiddenContactMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_args) bs
typemap_GetHiddenContactMids_args :: T.TypeMap
typemap_GetHiddenContactMids_args = Map.fromList []
default_GetHiddenContactMids_args :: GetHiddenContactMids_args
default_GetHiddenContactMids_args = GetHiddenContactMids_args{
}
data GetHiddenContactMids_result = GetHiddenContactMids_result  { getHiddenContactMids_result_success :: (Vector.Vector LT.Text)
  , getHiddenContactMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetHiddenContactMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getHiddenContactMids_result_success record   `H.hashWithSalt` getHiddenContactMids_result_e record  
instance QC.Arbitrary GetHiddenContactMids_result where 
  arbitrary = M.liftM GetHiddenContactMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetHiddenContactMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetHiddenContactMids_result{getHiddenContactMids_result_success = getHiddenContactMids_result_success obj} then P.Nothing else P.Just $ default_GetHiddenContactMids_result{getHiddenContactMids_result_success = getHiddenContactMids_result_success obj}
    , if obj == default_GetHiddenContactMids_result{getHiddenContactMids_result_e = getHiddenContactMids_result_e obj} then P.Nothing else P.Just $ default_GetHiddenContactMids_result{getHiddenContactMids_result_e = getHiddenContactMids_result_e obj}
    ]
from_GetHiddenContactMids_result :: GetHiddenContactMids_result -> T.ThriftVal
from_GetHiddenContactMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7188 -> (1, ("e",from_TalkException _v7188))) <$> getHiddenContactMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7188 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v7190 -> T.TString $ E.encodeUtf8 _v7190) $ Vector.toList _v7188))) $ getHiddenContactMids_result_success record
    , (\_v7188 -> (1, ("e",from_TalkException _v7188))) <$> getHiddenContactMids_result_e record
    ]
    )
write_GetHiddenContactMids_result :: T.Protocol p => p -> GetHiddenContactMids_result -> P.IO ()
write_GetHiddenContactMids_result oprot record = T.writeVal oprot $ from_GetHiddenContactMids_result record
encode_GetHiddenContactMids_result :: T.StatelessProtocol p => p -> GetHiddenContactMids_result -> LBS.ByteString
encode_GetHiddenContactMids_result oprot record = T.serializeVal oprot $ from_GetHiddenContactMids_result record
to_GetHiddenContactMids_result :: T.ThriftVal -> GetHiddenContactMids_result
to_GetHiddenContactMids_result (T.TStruct fields) = GetHiddenContactMids_result{
  getHiddenContactMids_result_success = P.maybe (getHiddenContactMids_result_success default_GetHiddenContactMids_result) (\(_,_val7192) -> (case _val7192 of {T.TList _ _val7193 -> (Vector.fromList $ P.map (\_v7194 -> (case _v7194 of {T.TString _val7195 -> E.decodeUtf8 _val7195; _ -> P.error "wrong type"})) _val7193); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getHiddenContactMids_result_e = P.maybe (P.Nothing) (\(_,_val7192) -> P.Just (case _val7192 of {T.TStruct _val7196 -> (to_TalkException (T.TStruct _val7196)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetHiddenContactMids_result _ = P.error "not a struct"
read_GetHiddenContactMids_result :: T.Protocol p => p -> P.IO GetHiddenContactMids_result
read_GetHiddenContactMids_result iprot = to_GetHiddenContactMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_result)
decode_GetHiddenContactMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetHiddenContactMids_result
decode_GetHiddenContactMids_result iprot bs = to_GetHiddenContactMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetHiddenContactMids_result) bs
typemap_GetHiddenContactMids_result :: T.TypeMap
typemap_GetHiddenContactMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetHiddenContactMids_result :: GetHiddenContactMids_result
default_GetHiddenContactMids_result = GetHiddenContactMids_result{
  getHiddenContactMids_result_success = Vector.empty,
  getHiddenContactMids_result_e = P.Nothing}
data GetIdentityIdentifier_args = GetIdentityIdentifier_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityIdentifier_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityIdentifier_args where 
  arbitrary = QC.elements [GetIdentityIdentifier_args]
from_GetIdentityIdentifier_args :: GetIdentityIdentifier_args -> T.ThriftVal
from_GetIdentityIdentifier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityIdentifier_args :: T.Protocol p => p -> GetIdentityIdentifier_args -> P.IO ()
write_GetIdentityIdentifier_args oprot record = T.writeVal oprot $ from_GetIdentityIdentifier_args record
encode_GetIdentityIdentifier_args :: T.StatelessProtocol p => p -> GetIdentityIdentifier_args -> LBS.ByteString
encode_GetIdentityIdentifier_args oprot record = T.serializeVal oprot $ from_GetIdentityIdentifier_args record
to_GetIdentityIdentifier_args :: T.ThriftVal -> GetIdentityIdentifier_args
to_GetIdentityIdentifier_args (T.TStruct fields) = GetIdentityIdentifier_args{

  }
to_GetIdentityIdentifier_args _ = P.error "not a struct"
read_GetIdentityIdentifier_args :: T.Protocol p => p -> P.IO GetIdentityIdentifier_args
read_GetIdentityIdentifier_args iprot = to_GetIdentityIdentifier_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_args)
decode_GetIdentityIdentifier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityIdentifier_args
decode_GetIdentityIdentifier_args iprot bs = to_GetIdentityIdentifier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_args) bs
typemap_GetIdentityIdentifier_args :: T.TypeMap
typemap_GetIdentityIdentifier_args = Map.fromList []
default_GetIdentityIdentifier_args :: GetIdentityIdentifier_args
default_GetIdentityIdentifier_args = GetIdentityIdentifier_args{
}
data GetIdentityIdentifier_result = GetIdentityIdentifier_result  { getIdentityIdentifier_result_success :: LT.Text
  , getIdentityIdentifier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityIdentifier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityIdentifier_result_success record   `H.hashWithSalt` getIdentityIdentifier_result_e record  
instance QC.Arbitrary GetIdentityIdentifier_result where 
  arbitrary = M.liftM GetIdentityIdentifier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityIdentifier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = getIdentityIdentifier_result_success obj} then P.Nothing else P.Just $ default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = getIdentityIdentifier_result_success obj}
    , if obj == default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = getIdentityIdentifier_result_e obj} then P.Nothing else P.Just $ default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = getIdentityIdentifier_result_e obj}
    ]
from_GetIdentityIdentifier_result :: GetIdentityIdentifier_result -> T.ThriftVal
from_GetIdentityIdentifier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7204 -> (1, ("e",from_TalkException _v7204))) <$> getIdentityIdentifier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7204 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v7204))) $ getIdentityIdentifier_result_success record
    , (\_v7204 -> (1, ("e",from_TalkException _v7204))) <$> getIdentityIdentifier_result_e record
    ]
    )
write_GetIdentityIdentifier_result :: T.Protocol p => p -> GetIdentityIdentifier_result -> P.IO ()
write_GetIdentityIdentifier_result oprot record = T.writeVal oprot $ from_GetIdentityIdentifier_result record
encode_GetIdentityIdentifier_result :: T.StatelessProtocol p => p -> GetIdentityIdentifier_result -> LBS.ByteString
encode_GetIdentityIdentifier_result oprot record = T.serializeVal oprot $ from_GetIdentityIdentifier_result record
to_GetIdentityIdentifier_result :: T.ThriftVal -> GetIdentityIdentifier_result
to_GetIdentityIdentifier_result (T.TStruct fields) = GetIdentityIdentifier_result{
  getIdentityIdentifier_result_success = P.maybe (getIdentityIdentifier_result_success default_GetIdentityIdentifier_result) (\(_,_val7206) -> (case _val7206 of {T.TString _val7207 -> E.decodeUtf8 _val7207; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityIdentifier_result_e = P.maybe (P.Nothing) (\(_,_val7206) -> P.Just (case _val7206 of {T.TStruct _val7208 -> (to_TalkException (T.TStruct _val7208)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityIdentifier_result _ = P.error "not a struct"
read_GetIdentityIdentifier_result :: T.Protocol p => p -> P.IO GetIdentityIdentifier_result
read_GetIdentityIdentifier_result iprot = to_GetIdentityIdentifier_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_result)
decode_GetIdentityIdentifier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityIdentifier_result
decode_GetIdentityIdentifier_result iprot bs = to_GetIdentityIdentifier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityIdentifier_result) bs
typemap_GetIdentityIdentifier_result :: T.TypeMap
typemap_GetIdentityIdentifier_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityIdentifier_result :: GetIdentityIdentifier_result
default_GetIdentityIdentifier_result = GetIdentityIdentifier_result{
  getIdentityIdentifier_result_success = "",
  getIdentityIdentifier_result_e = P.Nothing}
data GetLastAnnouncementIndex_args = GetLastAnnouncementIndex_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastAnnouncementIndex_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetLastAnnouncementIndex_args where 
  arbitrary = QC.elements [GetLastAnnouncementIndex_args]
from_GetLastAnnouncementIndex_args :: GetLastAnnouncementIndex_args -> T.ThriftVal
from_GetLastAnnouncementIndex_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetLastAnnouncementIndex_args :: T.Protocol p => p -> GetLastAnnouncementIndex_args -> P.IO ()
write_GetLastAnnouncementIndex_args oprot record = T.writeVal oprot $ from_GetLastAnnouncementIndex_args record
encode_GetLastAnnouncementIndex_args :: T.StatelessProtocol p => p -> GetLastAnnouncementIndex_args -> LBS.ByteString
encode_GetLastAnnouncementIndex_args oprot record = T.serializeVal oprot $ from_GetLastAnnouncementIndex_args record
to_GetLastAnnouncementIndex_args :: T.ThriftVal -> GetLastAnnouncementIndex_args
to_GetLastAnnouncementIndex_args (T.TStruct fields) = GetLastAnnouncementIndex_args{

  }
to_GetLastAnnouncementIndex_args _ = P.error "not a struct"
read_GetLastAnnouncementIndex_args :: T.Protocol p => p -> P.IO GetLastAnnouncementIndex_args
read_GetLastAnnouncementIndex_args iprot = to_GetLastAnnouncementIndex_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_args)
decode_GetLastAnnouncementIndex_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastAnnouncementIndex_args
decode_GetLastAnnouncementIndex_args iprot bs = to_GetLastAnnouncementIndex_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_args) bs
typemap_GetLastAnnouncementIndex_args :: T.TypeMap
typemap_GetLastAnnouncementIndex_args = Map.fromList []
default_GetLastAnnouncementIndex_args :: GetLastAnnouncementIndex_args
default_GetLastAnnouncementIndex_args = GetLastAnnouncementIndex_args{
}
data GetLastAnnouncementIndex_result = GetLastAnnouncementIndex_result  { getLastAnnouncementIndex_result_success :: I.Int32
  , getLastAnnouncementIndex_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastAnnouncementIndex_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastAnnouncementIndex_result_success record   `H.hashWithSalt` getLastAnnouncementIndex_result_e record  
instance QC.Arbitrary GetLastAnnouncementIndex_result where 
  arbitrary = M.liftM GetLastAnnouncementIndex_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastAnnouncementIndex_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = getLastAnnouncementIndex_result_success obj} then P.Nothing else P.Just $ default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = getLastAnnouncementIndex_result_success obj}
    , if obj == default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = getLastAnnouncementIndex_result_e obj} then P.Nothing else P.Just $ default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = getLastAnnouncementIndex_result_e obj}
    ]
from_GetLastAnnouncementIndex_result :: GetLastAnnouncementIndex_result -> T.ThriftVal
from_GetLastAnnouncementIndex_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7216 -> (1, ("e",from_TalkException _v7216))) <$> getLastAnnouncementIndex_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7216 -> P.Just (0, ("success",T.TI32 _v7216))) $ getLastAnnouncementIndex_result_success record
    , (\_v7216 -> (1, ("e",from_TalkException _v7216))) <$> getLastAnnouncementIndex_result_e record
    ]
    )
write_GetLastAnnouncementIndex_result :: T.Protocol p => p -> GetLastAnnouncementIndex_result -> P.IO ()
write_GetLastAnnouncementIndex_result oprot record = T.writeVal oprot $ from_GetLastAnnouncementIndex_result record
encode_GetLastAnnouncementIndex_result :: T.StatelessProtocol p => p -> GetLastAnnouncementIndex_result -> LBS.ByteString
encode_GetLastAnnouncementIndex_result oprot record = T.serializeVal oprot $ from_GetLastAnnouncementIndex_result record
to_GetLastAnnouncementIndex_result :: T.ThriftVal -> GetLastAnnouncementIndex_result
to_GetLastAnnouncementIndex_result (T.TStruct fields) = GetLastAnnouncementIndex_result{
  getLastAnnouncementIndex_result_success = P.maybe (getLastAnnouncementIndex_result_success default_GetLastAnnouncementIndex_result) (\(_,_val7218) -> (case _val7218 of {T.TI32 _val7219 -> _val7219; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastAnnouncementIndex_result_e = P.maybe (P.Nothing) (\(_,_val7218) -> P.Just (case _val7218 of {T.TStruct _val7220 -> (to_TalkException (T.TStruct _val7220)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastAnnouncementIndex_result _ = P.error "not a struct"
read_GetLastAnnouncementIndex_result :: T.Protocol p => p -> P.IO GetLastAnnouncementIndex_result
read_GetLastAnnouncementIndex_result iprot = to_GetLastAnnouncementIndex_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_result)
decode_GetLastAnnouncementIndex_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastAnnouncementIndex_result
decode_GetLastAnnouncementIndex_result iprot bs = to_GetLastAnnouncementIndex_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastAnnouncementIndex_result) bs
typemap_GetLastAnnouncementIndex_result :: T.TypeMap
typemap_GetLastAnnouncementIndex_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastAnnouncementIndex_result :: GetLastAnnouncementIndex_result
default_GetLastAnnouncementIndex_result = GetLastAnnouncementIndex_result{
  getLastAnnouncementIndex_result_success = 0,
  getLastAnnouncementIndex_result_e = P.Nothing}
data GetLastOpRevision_args = GetLastOpRevision_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastOpRevision_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetLastOpRevision_args where 
  arbitrary = QC.elements [GetLastOpRevision_args]
from_GetLastOpRevision_args :: GetLastOpRevision_args -> T.ThriftVal
from_GetLastOpRevision_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetLastOpRevision_args :: T.Protocol p => p -> GetLastOpRevision_args -> P.IO ()
write_GetLastOpRevision_args oprot record = T.writeVal oprot $ from_GetLastOpRevision_args record
encode_GetLastOpRevision_args :: T.StatelessProtocol p => p -> GetLastOpRevision_args -> LBS.ByteString
encode_GetLastOpRevision_args oprot record = T.serializeVal oprot $ from_GetLastOpRevision_args record
to_GetLastOpRevision_args :: T.ThriftVal -> GetLastOpRevision_args
to_GetLastOpRevision_args (T.TStruct fields) = GetLastOpRevision_args{

  }
to_GetLastOpRevision_args _ = P.error "not a struct"
read_GetLastOpRevision_args :: T.Protocol p => p -> P.IO GetLastOpRevision_args
read_GetLastOpRevision_args iprot = to_GetLastOpRevision_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastOpRevision_args)
decode_GetLastOpRevision_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastOpRevision_args
decode_GetLastOpRevision_args iprot bs = to_GetLastOpRevision_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastOpRevision_args) bs
typemap_GetLastOpRevision_args :: T.TypeMap
typemap_GetLastOpRevision_args = Map.fromList []
default_GetLastOpRevision_args :: GetLastOpRevision_args
default_GetLastOpRevision_args = GetLastOpRevision_args{
}
data GetLastOpRevision_result = GetLastOpRevision_result  { getLastOpRevision_result_success :: I.Int64
  , getLastOpRevision_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastOpRevision_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastOpRevision_result_success record   `H.hashWithSalt` getLastOpRevision_result_e record  
instance QC.Arbitrary GetLastOpRevision_result where 
  arbitrary = M.liftM GetLastOpRevision_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastOpRevision_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastOpRevision_result{getLastOpRevision_result_success = getLastOpRevision_result_success obj} then P.Nothing else P.Just $ default_GetLastOpRevision_result{getLastOpRevision_result_success = getLastOpRevision_result_success obj}
    , if obj == default_GetLastOpRevision_result{getLastOpRevision_result_e = getLastOpRevision_result_e obj} then P.Nothing else P.Just $ default_GetLastOpRevision_result{getLastOpRevision_result_e = getLastOpRevision_result_e obj}
    ]
from_GetLastOpRevision_result :: GetLastOpRevision_result -> T.ThriftVal
from_GetLastOpRevision_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7228 -> (1, ("e",from_TalkException _v7228))) <$> getLastOpRevision_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7228 -> P.Just (0, ("success",T.TI64 _v7228))) $ getLastOpRevision_result_success record
    , (\_v7228 -> (1, ("e",from_TalkException _v7228))) <$> getLastOpRevision_result_e record
    ]
    )
write_GetLastOpRevision_result :: T.Protocol p => p -> GetLastOpRevision_result -> P.IO ()
write_GetLastOpRevision_result oprot record = T.writeVal oprot $ from_GetLastOpRevision_result record
encode_GetLastOpRevision_result :: T.StatelessProtocol p => p -> GetLastOpRevision_result -> LBS.ByteString
encode_GetLastOpRevision_result oprot record = T.serializeVal oprot $ from_GetLastOpRevision_result record
to_GetLastOpRevision_result :: T.ThriftVal -> GetLastOpRevision_result
to_GetLastOpRevision_result (T.TStruct fields) = GetLastOpRevision_result{
  getLastOpRevision_result_success = P.maybe (getLastOpRevision_result_success default_GetLastOpRevision_result) (\(_,_val7230) -> (case _val7230 of {T.TI64 _val7231 -> _val7231; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastOpRevision_result_e = P.maybe (P.Nothing) (\(_,_val7230) -> P.Just (case _val7230 of {T.TStruct _val7232 -> (to_TalkException (T.TStruct _val7232)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastOpRevision_result _ = P.error "not a struct"
read_GetLastOpRevision_result :: T.Protocol p => p -> P.IO GetLastOpRevision_result
read_GetLastOpRevision_result iprot = to_GetLastOpRevision_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastOpRevision_result)
decode_GetLastOpRevision_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastOpRevision_result
decode_GetLastOpRevision_result iprot bs = to_GetLastOpRevision_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastOpRevision_result) bs
typemap_GetLastOpRevision_result :: T.TypeMap
typemap_GetLastOpRevision_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastOpRevision_result :: GetLastOpRevision_result
default_GetLastOpRevision_result = GetLastOpRevision_result{
  getLastOpRevision_result_success = 0,
  getLastOpRevision_result_e = P.Nothing}
data GetSuggestRevisions_args = GetSuggestRevisions_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSuggestRevisions_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSuggestRevisions_args where 
  arbitrary = QC.elements [GetSuggestRevisions_args]
from_GetSuggestRevisions_args :: GetSuggestRevisions_args -> T.ThriftVal
from_GetSuggestRevisions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSuggestRevisions_args :: T.Protocol p => p -> GetSuggestRevisions_args -> P.IO ()
write_GetSuggestRevisions_args oprot record = T.writeVal oprot $ from_GetSuggestRevisions_args record
encode_GetSuggestRevisions_args :: T.StatelessProtocol p => p -> GetSuggestRevisions_args -> LBS.ByteString
encode_GetSuggestRevisions_args oprot record = T.serializeVal oprot $ from_GetSuggestRevisions_args record
to_GetSuggestRevisions_args :: T.ThriftVal -> GetSuggestRevisions_args
to_GetSuggestRevisions_args (T.TStruct fields) = GetSuggestRevisions_args{

  }
to_GetSuggestRevisions_args _ = P.error "not a struct"
read_GetSuggestRevisions_args :: T.Protocol p => p -> P.IO GetSuggestRevisions_args
read_GetSuggestRevisions_args iprot = to_GetSuggestRevisions_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSuggestRevisions_args)
decode_GetSuggestRevisions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSuggestRevisions_args
decode_GetSuggestRevisions_args iprot bs = to_GetSuggestRevisions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSuggestRevisions_args) bs
typemap_GetSuggestRevisions_args :: T.TypeMap
typemap_GetSuggestRevisions_args = Map.fromList []
default_GetSuggestRevisions_args :: GetSuggestRevisions_args
default_GetSuggestRevisions_args = GetSuggestRevisions_args{
}
data GetSuggestRevisions_result = GetSuggestRevisions_result  { getSuggestRevisions_result_success :: SuggestDictionaryRevisions
  , getSuggestRevisions_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSuggestRevisions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSuggestRevisions_result_success record   `H.hashWithSalt` getSuggestRevisions_result_e record  
instance QC.Arbitrary GetSuggestRevisions_result where 
  arbitrary = M.liftM GetSuggestRevisions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSuggestRevisions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSuggestRevisions_result{getSuggestRevisions_result_success = getSuggestRevisions_result_success obj} then P.Nothing else P.Just $ default_GetSuggestRevisions_result{getSuggestRevisions_result_success = getSuggestRevisions_result_success obj}
    , if obj == default_GetSuggestRevisions_result{getSuggestRevisions_result_e = getSuggestRevisions_result_e obj} then P.Nothing else P.Just $ default_GetSuggestRevisions_result{getSuggestRevisions_result_e = getSuggestRevisions_result_e obj}
    ]
from_GetSuggestRevisions_result :: GetSuggestRevisions_result -> T.ThriftVal
from_GetSuggestRevisions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7240 -> (1, ("e",from_TalkException _v7240))) <$> getSuggestRevisions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7240 -> P.Just (0, ("success",from_SuggestDictionaryRevisions _v7240))) $ getSuggestRevisions_result_success record
    , (\_v7240 -> (1, ("e",from_TalkException _v7240))) <$> getSuggestRevisions_result_e record
    ]
    )
write_GetSuggestRevisions_result :: T.Protocol p => p -> GetSuggestRevisions_result -> P.IO ()
write_GetSuggestRevisions_result oprot record = T.writeVal oprot $ from_GetSuggestRevisions_result record
encode_GetSuggestRevisions_result :: T.StatelessProtocol p => p -> GetSuggestRevisions_result -> LBS.ByteString
encode_GetSuggestRevisions_result oprot record = T.serializeVal oprot $ from_GetSuggestRevisions_result record
to_GetSuggestRevisions_result :: T.ThriftVal -> GetSuggestRevisions_result
to_GetSuggestRevisions_result (T.TStruct fields) = GetSuggestRevisions_result{
  getSuggestRevisions_result_success = P.maybe (getSuggestRevisions_result_success default_GetSuggestRevisions_result) (\(_,_val7242) -> (case _val7242 of {T.TStruct _val7243 -> (to_SuggestDictionaryRevisions (T.TStruct _val7243)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSuggestRevisions_result_e = P.maybe (P.Nothing) (\(_,_val7242) -> P.Just (case _val7242 of {T.TStruct _val7244 -> (to_TalkException (T.TStruct _val7244)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSuggestRevisions_result _ = P.error "not a struct"
read_GetSuggestRevisions_result :: T.Protocol p => p -> P.IO GetSuggestRevisions_result
read_GetSuggestRevisions_result iprot = to_GetSuggestRevisions_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSuggestRevisions_result)
decode_GetSuggestRevisions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSuggestRevisions_result
decode_GetSuggestRevisions_result iprot bs = to_GetSuggestRevisions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSuggestRevisions_result) bs
typemap_GetSuggestRevisions_result :: T.TypeMap
typemap_GetSuggestRevisions_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SuggestDictionaryRevisions))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSuggestRevisions_result :: GetSuggestRevisions_result
default_GetSuggestRevisions_result = GetSuggestRevisions_result{
  getSuggestRevisions_result_success = default_SuggestDictionaryRevisions,
  getSuggestRevisions_result_e = P.Nothing}
data GetPreviousMessagesV2WithReadCount_args = GetPreviousMessagesV2WithReadCount_args  { getPreviousMessagesV2WithReadCount_args_messageBoxId :: LT.Text
  , getPreviousMessagesV2WithReadCount_args_endMessageId :: MessageBoxV2MessageId
  , getPreviousMessagesV2WithReadCount_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessagesV2WithReadCount_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessagesV2WithReadCount_args_messageBoxId record   `H.hashWithSalt` getPreviousMessagesV2WithReadCount_args_endMessageId record   `H.hashWithSalt` getPreviousMessagesV2WithReadCount_args_messagesCount record  
instance QC.Arbitrary GetPreviousMessagesV2WithReadCount_args where 
  arbitrary = M.liftM GetPreviousMessagesV2WithReadCount_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessagesV2WithReadCount_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_messageBoxId = getPreviousMessagesV2WithReadCount_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_messageBoxId = getPreviousMessagesV2WithReadCount_args_messageBoxId obj}
    , if obj == default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_endMessageId = getPreviousMessagesV2WithReadCount_args_endMessageId obj} then P.Nothing else P.Just $ default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_endMessageId = getPreviousMessagesV2WithReadCount_args_endMessageId obj}
    , if obj == default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_messagesCount = getPreviousMessagesV2WithReadCount_args_messagesCount obj} then P.Nothing else P.Just $ default_GetPreviousMessagesV2WithReadCount_args{getPreviousMessagesV2WithReadCount_args_messagesCount = getPreviousMessagesV2WithReadCount_args_messagesCount obj}
    ]
from_GetPreviousMessagesV2WithReadCount_args :: GetPreviousMessagesV2WithReadCount_args -> T.ThriftVal
from_GetPreviousMessagesV2WithReadCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7247 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v7247))) $ getPreviousMessagesV2WithReadCount_args_messageBoxId record
  , (\_v7247 -> P.Just (3, ("endMessageId",from_MessageBoxV2MessageId _v7247))) $ getPreviousMessagesV2WithReadCount_args_endMessageId record
  , (\_v7247 -> P.Just (4, ("messagesCount",T.TI32 _v7247))) $ getPreviousMessagesV2WithReadCount_args_messagesCount record
  ]
write_GetPreviousMessagesV2WithReadCount_args :: T.Protocol p => p -> GetPreviousMessagesV2WithReadCount_args -> P.IO ()
write_GetPreviousMessagesV2WithReadCount_args oprot record = T.writeVal oprot $ from_GetPreviousMessagesV2WithReadCount_args record
encode_GetPreviousMessagesV2WithReadCount_args :: T.StatelessProtocol p => p -> GetPreviousMessagesV2WithReadCount_args -> LBS.ByteString
encode_GetPreviousMessagesV2WithReadCount_args oprot record = T.serializeVal oprot $ from_GetPreviousMessagesV2WithReadCount_args record
to_GetPreviousMessagesV2WithReadCount_args :: T.ThriftVal -> GetPreviousMessagesV2WithReadCount_args
to_GetPreviousMessagesV2WithReadCount_args (T.TStruct fields) = GetPreviousMessagesV2WithReadCount_args{
  getPreviousMessagesV2WithReadCount_args_messageBoxId = P.maybe (getPreviousMessagesV2WithReadCount_args_messageBoxId default_GetPreviousMessagesV2WithReadCount_args) (\(_,_val7249) -> (case _val7249 of {T.TString _val7250 -> E.decodeUtf8 _val7250; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPreviousMessagesV2WithReadCount_args_endMessageId = P.maybe (getPreviousMessagesV2WithReadCount_args_endMessageId default_GetPreviousMessagesV2WithReadCount_args) (\(_,_val7249) -> (case _val7249 of {T.TStruct _val7251 -> (to_MessageBoxV2MessageId (T.TStruct _val7251)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPreviousMessagesV2WithReadCount_args_messagesCount = P.maybe (getPreviousMessagesV2WithReadCount_args_messagesCount default_GetPreviousMessagesV2WithReadCount_args) (\(_,_val7249) -> (case _val7249 of {T.TI32 _val7252 -> _val7252; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetPreviousMessagesV2WithReadCount_args _ = P.error "not a struct"
read_GetPreviousMessagesV2WithReadCount_args :: T.Protocol p => p -> P.IO GetPreviousMessagesV2WithReadCount_args
read_GetPreviousMessagesV2WithReadCount_args iprot = to_GetPreviousMessagesV2WithReadCount_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessagesV2WithReadCount_args)
decode_GetPreviousMessagesV2WithReadCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessagesV2WithReadCount_args
decode_GetPreviousMessagesV2WithReadCount_args iprot bs = to_GetPreviousMessagesV2WithReadCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessagesV2WithReadCount_args) bs
typemap_GetPreviousMessagesV2WithReadCount_args :: T.TypeMap
typemap_GetPreviousMessagesV2WithReadCount_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("endMessageId",(T.T_STRUCT typemap_MessageBoxV2MessageId))),(4,("messagesCount",T.T_I32))]
default_GetPreviousMessagesV2WithReadCount_args :: GetPreviousMessagesV2WithReadCount_args
default_GetPreviousMessagesV2WithReadCount_args = GetPreviousMessagesV2WithReadCount_args{
  getPreviousMessagesV2WithReadCount_args_messageBoxId = "",
  getPreviousMessagesV2WithReadCount_args_endMessageId = default_MessageBoxV2MessageId,
  getPreviousMessagesV2WithReadCount_args_messagesCount = 0}
data GetPreviousMessagesV2WithReadCount_result = GetPreviousMessagesV2WithReadCount_result  { getPreviousMessagesV2WithReadCount_result_success :: (Vector.Vector Message)
  , getPreviousMessagesV2WithReadCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessagesV2WithReadCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessagesV2WithReadCount_result_success record   `H.hashWithSalt` getPreviousMessagesV2WithReadCount_result_e record  
instance QC.Arbitrary GetPreviousMessagesV2WithReadCount_result where 
  arbitrary = M.liftM GetPreviousMessagesV2WithReadCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessagesV2WithReadCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_success = getPreviousMessagesV2WithReadCount_result_success obj} then P.Nothing else P.Just $ default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_success = getPreviousMessagesV2WithReadCount_result_success obj}
    , if obj == default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_e = getPreviousMessagesV2WithReadCount_result_e obj} then P.Nothing else P.Just $ default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_e = getPreviousMessagesV2WithReadCount_result_e obj}
    ]
from_GetPreviousMessagesV2WithReadCount_result :: GetPreviousMessagesV2WithReadCount_result -> T.ThriftVal
from_GetPreviousMessagesV2WithReadCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7255 -> (1, ("e",from_TalkException _v7255))) <$> getPreviousMessagesV2WithReadCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7255 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v7257 -> from_Message _v7257) $ Vector.toList _v7255))) $ getPreviousMessagesV2WithReadCount_result_success record
    , (\_v7255 -> (1, ("e",from_TalkException _v7255))) <$> getPreviousMessagesV2WithReadCount_result_e record
    ]
    )
write_GetPreviousMessagesV2WithReadCount_result :: T.Protocol p => p -> GetPreviousMessagesV2WithReadCount_result -> P.IO ()
write_GetPreviousMessagesV2WithReadCount_result oprot record = T.writeVal oprot $ from_GetPreviousMessagesV2WithReadCount_result record
encode_GetPreviousMessagesV2WithReadCount_result :: T.StatelessProtocol p => p -> GetPreviousMessagesV2WithReadCount_result -> LBS.ByteString
encode_GetPreviousMessagesV2WithReadCount_result oprot record = T.serializeVal oprot $ from_GetPreviousMessagesV2WithReadCount_result record
to_GetPreviousMessagesV2WithReadCount_result :: T.ThriftVal -> GetPreviousMessagesV2WithReadCount_result
to_GetPreviousMessagesV2WithReadCount_result (T.TStruct fields) = GetPreviousMessagesV2WithReadCount_result{
  getPreviousMessagesV2WithReadCount_result_success = P.maybe (getPreviousMessagesV2WithReadCount_result_success default_GetPreviousMessagesV2WithReadCount_result) (\(_,_val7259) -> (case _val7259 of {T.TList _ _val7260 -> (Vector.fromList $ P.map (\_v7261 -> (case _v7261 of {T.TStruct _val7262 -> (to_Message (T.TStruct _val7262)); _ -> P.error "wrong type"})) _val7260); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPreviousMessagesV2WithReadCount_result_e = P.maybe (P.Nothing) (\(_,_val7259) -> P.Just (case _val7259 of {T.TStruct _val7263 -> (to_TalkException (T.TStruct _val7263)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreviousMessagesV2WithReadCount_result _ = P.error "not a struct"
read_GetPreviousMessagesV2WithReadCount_result :: T.Protocol p => p -> P.IO GetPreviousMessagesV2WithReadCount_result
read_GetPreviousMessagesV2WithReadCount_result iprot = to_GetPreviousMessagesV2WithReadCount_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessagesV2WithReadCount_result)
decode_GetPreviousMessagesV2WithReadCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessagesV2WithReadCount_result
decode_GetPreviousMessagesV2WithReadCount_result iprot bs = to_GetPreviousMessagesV2WithReadCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessagesV2WithReadCount_result) bs
typemap_GetPreviousMessagesV2WithReadCount_result :: T.TypeMap
typemap_GetPreviousMessagesV2WithReadCount_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPreviousMessagesV2WithReadCount_result :: GetPreviousMessagesV2WithReadCount_result
default_GetPreviousMessagesV2WithReadCount_result = GetPreviousMessagesV2WithReadCount_result{
  getPreviousMessagesV2WithReadCount_result_success = Vector.empty,
  getPreviousMessagesV2WithReadCount_result_e = P.Nothing}
data GetMessageBox_args = GetMessageBox_args  { getMessageBox_args_channelId :: LT.Text
  , getMessageBox_args_messageBoxId :: LT.Text
  , getMessageBox_args_lastMessagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBox_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBox_args_channelId record   `H.hashWithSalt` getMessageBox_args_messageBoxId record   `H.hashWithSalt` getMessageBox_args_lastMessagesCount record  
instance QC.Arbitrary GetMessageBox_args where 
  arbitrary = M.liftM GetMessageBox_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBox_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBox_args{getMessageBox_args_channelId = getMessageBox_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_channelId = getMessageBox_args_channelId obj}
    , if obj == default_GetMessageBox_args{getMessageBox_args_messageBoxId = getMessageBox_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_messageBoxId = getMessageBox_args_messageBoxId obj}
    , if obj == default_GetMessageBox_args{getMessageBox_args_lastMessagesCount = getMessageBox_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBox_args{getMessageBox_args_lastMessagesCount = getMessageBox_args_lastMessagesCount obj}
    ]
from_GetMessageBox_args :: GetMessageBox_args -> T.ThriftVal
from_GetMessageBox_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7266 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v7266))) $ getMessageBox_args_channelId record
  , (\_v7266 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v7266))) $ getMessageBox_args_messageBoxId record
  , (\_v7266 -> P.Just (4, ("lastMessagesCount",T.TI32 _v7266))) $ getMessageBox_args_lastMessagesCount record
  ]
write_GetMessageBox_args :: T.Protocol p => p -> GetMessageBox_args -> P.IO ()
write_GetMessageBox_args oprot record = T.writeVal oprot $ from_GetMessageBox_args record
encode_GetMessageBox_args :: T.StatelessProtocol p => p -> GetMessageBox_args -> LBS.ByteString
encode_GetMessageBox_args oprot record = T.serializeVal oprot $ from_GetMessageBox_args record
to_GetMessageBox_args :: T.ThriftVal -> GetMessageBox_args
to_GetMessageBox_args (T.TStruct fields) = GetMessageBox_args{
  getMessageBox_args_channelId = P.maybe (getMessageBox_args_channelId default_GetMessageBox_args) (\(_,_val7268) -> (case _val7268 of {T.TString _val7269 -> E.decodeUtf8 _val7269; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBox_args_messageBoxId = P.maybe (getMessageBox_args_messageBoxId default_GetMessageBox_args) (\(_,_val7268) -> (case _val7268 of {T.TString _val7270 -> E.decodeUtf8 _val7270; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessageBox_args_lastMessagesCount = P.maybe (getMessageBox_args_lastMessagesCount default_GetMessageBox_args) (\(_,_val7268) -> (case _val7268 of {T.TI32 _val7271 -> _val7271; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetMessageBox_args _ = P.error "not a struct"
read_GetMessageBox_args :: T.Protocol p => p -> P.IO GetMessageBox_args
read_GetMessageBox_args iprot = to_GetMessageBox_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBox_args)
decode_GetMessageBox_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBox_args
decode_GetMessageBox_args iprot bs = to_GetMessageBox_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBox_args) bs
typemap_GetMessageBox_args :: T.TypeMap
typemap_GetMessageBox_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING)),(4,("lastMessagesCount",T.T_I32))]
default_GetMessageBox_args :: GetMessageBox_args
default_GetMessageBox_args = GetMessageBox_args{
  getMessageBox_args_channelId = "",
  getMessageBox_args_messageBoxId = "",
  getMessageBox_args_lastMessagesCount = 0}
data GetMessageBox_result = GetMessageBox_result  { getMessageBox_result_success :: TMessageBox
  , getMessageBox_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBox_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBox_result_success record   `H.hashWithSalt` getMessageBox_result_e record  
instance QC.Arbitrary GetMessageBox_result where 
  arbitrary = M.liftM GetMessageBox_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBox_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBox_result{getMessageBox_result_success = getMessageBox_result_success obj} then P.Nothing else P.Just $ default_GetMessageBox_result{getMessageBox_result_success = getMessageBox_result_success obj}
    , if obj == default_GetMessageBox_result{getMessageBox_result_e = getMessageBox_result_e obj} then P.Nothing else P.Just $ default_GetMessageBox_result{getMessageBox_result_e = getMessageBox_result_e obj}
    ]
from_GetMessageBox_result :: GetMessageBox_result -> T.ThriftVal
from_GetMessageBox_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7274 -> (1, ("e",from_TalkException _v7274))) <$> getMessageBox_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7274 -> P.Just (0, ("success",from_TMessageBox _v7274))) $ getMessageBox_result_success record
    , (\_v7274 -> (1, ("e",from_TalkException _v7274))) <$> getMessageBox_result_e record
    ]
    )
write_GetMessageBox_result :: T.Protocol p => p -> GetMessageBox_result -> P.IO ()
write_GetMessageBox_result oprot record = T.writeVal oprot $ from_GetMessageBox_result record
encode_GetMessageBox_result :: T.StatelessProtocol p => p -> GetMessageBox_result -> LBS.ByteString
encode_GetMessageBox_result oprot record = T.serializeVal oprot $ from_GetMessageBox_result record
to_GetMessageBox_result :: T.ThriftVal -> GetMessageBox_result
to_GetMessageBox_result (T.TStruct fields) = GetMessageBox_result{
  getMessageBox_result_success = P.maybe (getMessageBox_result_success default_GetMessageBox_result) (\(_,_val7276) -> (case _val7276 of {T.TStruct _val7277 -> (to_TMessageBox (T.TStruct _val7277)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBox_result_e = P.maybe (P.Nothing) (\(_,_val7276) -> P.Just (case _val7276 of {T.TStruct _val7278 -> (to_TalkException (T.TStruct _val7278)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBox_result _ = P.error "not a struct"
read_GetMessageBox_result :: T.Protocol p => p -> P.IO GetMessageBox_result
read_GetMessageBox_result iprot = to_GetMessageBox_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBox_result)
decode_GetMessageBox_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBox_result
decode_GetMessageBox_result iprot bs = to_GetMessageBox_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBox_result) bs
typemap_GetMessageBox_result :: T.TypeMap
typemap_GetMessageBox_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBox))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBox_result :: GetMessageBox_result
default_GetMessageBox_result = GetMessageBox_result{
  getMessageBox_result_success = default_TMessageBox,
  getMessageBox_result_e = P.Nothing}
data GetMessageBoxCompactWrapUp_args = GetMessageBoxCompactWrapUp_args  { getMessageBoxCompactWrapUp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUp_args_mid record  
instance QC.Arbitrary GetMessageBoxCompactWrapUp_args where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUp_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUp_args{getMessageBoxCompactWrapUp_args_mid = getMessageBoxCompactWrapUp_args_mid obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_args{getMessageBoxCompactWrapUp_args_mid = getMessageBoxCompactWrapUp_args_mid obj}
    ]
from_GetMessageBoxCompactWrapUp_args :: GetMessageBoxCompactWrapUp_args -> T.ThriftVal
from_GetMessageBoxCompactWrapUp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7281 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v7281))) $ getMessageBoxCompactWrapUp_args_mid record
  ]
write_GetMessageBoxCompactWrapUp_args :: T.Protocol p => p -> GetMessageBoxCompactWrapUp_args -> P.IO ()
write_GetMessageBoxCompactWrapUp_args oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUp_args record
encode_GetMessageBoxCompactWrapUp_args :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUp_args -> LBS.ByteString
encode_GetMessageBoxCompactWrapUp_args oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUp_args record
to_GetMessageBoxCompactWrapUp_args :: T.ThriftVal -> GetMessageBoxCompactWrapUp_args
to_GetMessageBoxCompactWrapUp_args (T.TStruct fields) = GetMessageBoxCompactWrapUp_args{
  getMessageBoxCompactWrapUp_args_mid = P.maybe (getMessageBoxCompactWrapUp_args_mid default_GetMessageBoxCompactWrapUp_args) (\(_,_val7283) -> (case _val7283 of {T.TString _val7284 -> E.decodeUtf8 _val7284; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageBoxCompactWrapUp_args _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUp_args :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUp_args
read_GetMessageBoxCompactWrapUp_args iprot = to_GetMessageBoxCompactWrapUp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_args)
decode_GetMessageBoxCompactWrapUp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUp_args
decode_GetMessageBoxCompactWrapUp_args iprot bs = to_GetMessageBoxCompactWrapUp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_args) bs
typemap_GetMessageBoxCompactWrapUp_args :: T.TypeMap
typemap_GetMessageBoxCompactWrapUp_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetMessageBoxCompactWrapUp_args :: GetMessageBoxCompactWrapUp_args
default_GetMessageBoxCompactWrapUp_args = GetMessageBoxCompactWrapUp_args{
  getMessageBoxCompactWrapUp_args_mid = ""}
data GetMessageBoxCompactWrapUp_result = GetMessageBoxCompactWrapUp_result  { getMessageBoxCompactWrapUp_result_success :: TMessageBoxWrapUp
  , getMessageBoxCompactWrapUp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUp_result_success record   `H.hashWithSalt` getMessageBoxCompactWrapUp_result_e record  
instance QC.Arbitrary GetMessageBoxCompactWrapUp_result where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = getMessageBoxCompactWrapUp_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = getMessageBoxCompactWrapUp_result_success obj}
    , if obj == default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = getMessageBoxCompactWrapUp_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = getMessageBoxCompactWrapUp_result_e obj}
    ]
from_GetMessageBoxCompactWrapUp_result :: GetMessageBoxCompactWrapUp_result -> T.ThriftVal
from_GetMessageBoxCompactWrapUp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7287 -> (1, ("e",from_TalkException _v7287))) <$> getMessageBoxCompactWrapUp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7287 -> P.Just (0, ("success",from_TMessageBoxWrapUp _v7287))) $ getMessageBoxCompactWrapUp_result_success record
    , (\_v7287 -> (1, ("e",from_TalkException _v7287))) <$> getMessageBoxCompactWrapUp_result_e record
    ]
    )
write_GetMessageBoxCompactWrapUp_result :: T.Protocol p => p -> GetMessageBoxCompactWrapUp_result -> P.IO ()
write_GetMessageBoxCompactWrapUp_result oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUp_result record
encode_GetMessageBoxCompactWrapUp_result :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUp_result -> LBS.ByteString
encode_GetMessageBoxCompactWrapUp_result oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUp_result record
to_GetMessageBoxCompactWrapUp_result :: T.ThriftVal -> GetMessageBoxCompactWrapUp_result
to_GetMessageBoxCompactWrapUp_result (T.TStruct fields) = GetMessageBoxCompactWrapUp_result{
  getMessageBoxCompactWrapUp_result_success = P.maybe (getMessageBoxCompactWrapUp_result_success default_GetMessageBoxCompactWrapUp_result) (\(_,_val7289) -> (case _val7289 of {T.TStruct _val7290 -> (to_TMessageBoxWrapUp (T.TStruct _val7290)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxCompactWrapUp_result_e = P.maybe (P.Nothing) (\(_,_val7289) -> P.Just (case _val7289 of {T.TStruct _val7291 -> (to_TalkException (T.TStruct _val7291)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxCompactWrapUp_result _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUp_result :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUp_result
read_GetMessageBoxCompactWrapUp_result iprot = to_GetMessageBoxCompactWrapUp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_result)
decode_GetMessageBoxCompactWrapUp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUp_result
decode_GetMessageBoxCompactWrapUp_result iprot bs = to_GetMessageBoxCompactWrapUp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUp_result) bs
typemap_GetMessageBoxCompactWrapUp_result :: T.TypeMap
typemap_GetMessageBoxCompactWrapUp_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUp))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxCompactWrapUp_result :: GetMessageBoxCompactWrapUp_result
default_GetMessageBoxCompactWrapUp_result = GetMessageBoxCompactWrapUp_result{
  getMessageBoxCompactWrapUp_result_success = default_TMessageBoxWrapUp,
  getMessageBoxCompactWrapUp_result_e = P.Nothing}
data GetMessageBoxCompactWrapUpList_args = GetMessageBoxCompactWrapUpList_args  { getMessageBoxCompactWrapUpList_args_start :: I.Int32
  , getMessageBoxCompactWrapUpList_args_messageBoxCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpList_args_start record   `H.hashWithSalt` getMessageBoxCompactWrapUpList_args_messageBoxCount record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpList_args where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_start = getMessageBoxCompactWrapUpList_args_start obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_start = getMessageBoxCompactWrapUpList_args_start obj}
    , if obj == default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_messageBoxCount = getMessageBoxCompactWrapUpList_args_messageBoxCount obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_args{getMessageBoxCompactWrapUpList_args_messageBoxCount = getMessageBoxCompactWrapUpList_args_messageBoxCount obj}
    ]
from_GetMessageBoxCompactWrapUpList_args :: GetMessageBoxCompactWrapUpList_args -> T.ThriftVal
from_GetMessageBoxCompactWrapUpList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7294 -> P.Just (2, ("start",T.TI32 _v7294))) $ getMessageBoxCompactWrapUpList_args_start record
  , (\_v7294 -> P.Just (3, ("messageBoxCount",T.TI32 _v7294))) $ getMessageBoxCompactWrapUpList_args_messageBoxCount record
  ]
write_GetMessageBoxCompactWrapUpList_args :: T.Protocol p => p -> GetMessageBoxCompactWrapUpList_args -> P.IO ()
write_GetMessageBoxCompactWrapUpList_args oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpList_args record
encode_GetMessageBoxCompactWrapUpList_args :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpList_args -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpList_args record
to_GetMessageBoxCompactWrapUpList_args :: T.ThriftVal -> GetMessageBoxCompactWrapUpList_args
to_GetMessageBoxCompactWrapUpList_args (T.TStruct fields) = GetMessageBoxCompactWrapUpList_args{
  getMessageBoxCompactWrapUpList_args_start = P.maybe (getMessageBoxCompactWrapUpList_args_start default_GetMessageBoxCompactWrapUpList_args) (\(_,_val7296) -> (case _val7296 of {T.TI32 _val7297 -> _val7297; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxCompactWrapUpList_args_messageBoxCount = P.maybe (getMessageBoxCompactWrapUpList_args_messageBoxCount default_GetMessageBoxCompactWrapUpList_args) (\(_,_val7296) -> (case _val7296 of {T.TI32 _val7298 -> _val7298; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxCompactWrapUpList_args _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpList_args :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpList_args
read_GetMessageBoxCompactWrapUpList_args iprot = to_GetMessageBoxCompactWrapUpList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_args)
decode_GetMessageBoxCompactWrapUpList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpList_args
decode_GetMessageBoxCompactWrapUpList_args iprot bs = to_GetMessageBoxCompactWrapUpList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_args) bs
typemap_GetMessageBoxCompactWrapUpList_args :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpList_args = Map.fromList [(2,("start",T.T_I32)),(3,("messageBoxCount",T.T_I32))]
default_GetMessageBoxCompactWrapUpList_args :: GetMessageBoxCompactWrapUpList_args
default_GetMessageBoxCompactWrapUpList_args = GetMessageBoxCompactWrapUpList_args{
  getMessageBoxCompactWrapUpList_args_start = 0,
  getMessageBoxCompactWrapUpList_args_messageBoxCount = 0}
data GetMessageBoxCompactWrapUpList_result = GetMessageBoxCompactWrapUpList_result  { getMessageBoxCompactWrapUpList_result_success :: TMessageBoxWrapUpResponse
  , getMessageBoxCompactWrapUpList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpList_result_success record   `H.hashWithSalt` getMessageBoxCompactWrapUpList_result_e record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpList_result where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = getMessageBoxCompactWrapUpList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = getMessageBoxCompactWrapUpList_result_success obj}
    , if obj == default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = getMessageBoxCompactWrapUpList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = getMessageBoxCompactWrapUpList_result_e obj}
    ]
from_GetMessageBoxCompactWrapUpList_result :: GetMessageBoxCompactWrapUpList_result -> T.ThriftVal
from_GetMessageBoxCompactWrapUpList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7301 -> (1, ("e",from_TalkException _v7301))) <$> getMessageBoxCompactWrapUpList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7301 -> P.Just (0, ("success",from_TMessageBoxWrapUpResponse _v7301))) $ getMessageBoxCompactWrapUpList_result_success record
    , (\_v7301 -> (1, ("e",from_TalkException _v7301))) <$> getMessageBoxCompactWrapUpList_result_e record
    ]
    )
write_GetMessageBoxCompactWrapUpList_result :: T.Protocol p => p -> GetMessageBoxCompactWrapUpList_result -> P.IO ()
write_GetMessageBoxCompactWrapUpList_result oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpList_result record
encode_GetMessageBoxCompactWrapUpList_result :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpList_result -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpList_result record
to_GetMessageBoxCompactWrapUpList_result :: T.ThriftVal -> GetMessageBoxCompactWrapUpList_result
to_GetMessageBoxCompactWrapUpList_result (T.TStruct fields) = GetMessageBoxCompactWrapUpList_result{
  getMessageBoxCompactWrapUpList_result_success = P.maybe (getMessageBoxCompactWrapUpList_result_success default_GetMessageBoxCompactWrapUpList_result) (\(_,_val7303) -> (case _val7303 of {T.TStruct _val7304 -> (to_TMessageBoxWrapUpResponse (T.TStruct _val7304)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxCompactWrapUpList_result_e = P.maybe (P.Nothing) (\(_,_val7303) -> P.Just (case _val7303 of {T.TStruct _val7305 -> (to_TalkException (T.TStruct _val7305)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxCompactWrapUpList_result _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpList_result :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpList_result
read_GetMessageBoxCompactWrapUpList_result iprot = to_GetMessageBoxCompactWrapUpList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_result)
decode_GetMessageBoxCompactWrapUpList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpList_result
decode_GetMessageBoxCompactWrapUpList_result iprot bs = to_GetMessageBoxCompactWrapUpList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpList_result) bs
typemap_GetMessageBoxCompactWrapUpList_result :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUpResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxCompactWrapUpList_result :: GetMessageBoxCompactWrapUpList_result
default_GetMessageBoxCompactWrapUpList_result = GetMessageBoxCompactWrapUpList_result{
  getMessageBoxCompactWrapUpList_result_success = default_TMessageBoxWrapUpResponse,
  getMessageBoxCompactWrapUpList_result_e = P.Nothing}
data GetMessageBoxList_args = GetMessageBoxList_args  { getMessageBoxList_args_channelId :: LT.Text
  , getMessageBoxList_args_lastMessagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxList_args_channelId record   `H.hashWithSalt` getMessageBoxList_args_lastMessagesCount record  
instance QC.Arbitrary GetMessageBoxList_args where 
  arbitrary = M.liftM GetMessageBoxList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxList_args{getMessageBoxList_args_channelId = getMessageBoxList_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBoxList_args{getMessageBoxList_args_channelId = getMessageBoxList_args_channelId obj}
    , if obj == default_GetMessageBoxList_args{getMessageBoxList_args_lastMessagesCount = getMessageBoxList_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBoxList_args{getMessageBoxList_args_lastMessagesCount = getMessageBoxList_args_lastMessagesCount obj}
    ]
from_GetMessageBoxList_args :: GetMessageBoxList_args -> T.ThriftVal
from_GetMessageBoxList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7308 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v7308))) $ getMessageBoxList_args_channelId record
  , (\_v7308 -> P.Just (3, ("lastMessagesCount",T.TI32 _v7308))) $ getMessageBoxList_args_lastMessagesCount record
  ]
write_GetMessageBoxList_args :: T.Protocol p => p -> GetMessageBoxList_args -> P.IO ()
write_GetMessageBoxList_args oprot record = T.writeVal oprot $ from_GetMessageBoxList_args record
encode_GetMessageBoxList_args :: T.StatelessProtocol p => p -> GetMessageBoxList_args -> LBS.ByteString
encode_GetMessageBoxList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxList_args record
to_GetMessageBoxList_args :: T.ThriftVal -> GetMessageBoxList_args
to_GetMessageBoxList_args (T.TStruct fields) = GetMessageBoxList_args{
  getMessageBoxList_args_channelId = P.maybe (getMessageBoxList_args_channelId default_GetMessageBoxList_args) (\(_,_val7310) -> (case _val7310 of {T.TString _val7311 -> E.decodeUtf8 _val7311; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxList_args_lastMessagesCount = P.maybe (getMessageBoxList_args_lastMessagesCount default_GetMessageBoxList_args) (\(_,_val7310) -> (case _val7310 of {T.TI32 _val7312 -> _val7312; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxList_args _ = P.error "not a struct"
read_GetMessageBoxList_args :: T.Protocol p => p -> P.IO GetMessageBoxList_args
read_GetMessageBoxList_args iprot = to_GetMessageBoxList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxList_args)
decode_GetMessageBoxList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxList_args
decode_GetMessageBoxList_args iprot bs = to_GetMessageBoxList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxList_args) bs
typemap_GetMessageBoxList_args :: T.TypeMap
typemap_GetMessageBoxList_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("lastMessagesCount",T.T_I32))]
default_GetMessageBoxList_args :: GetMessageBoxList_args
default_GetMessageBoxList_args = GetMessageBoxList_args{
  getMessageBoxList_args_channelId = "",
  getMessageBoxList_args_lastMessagesCount = 0}
data GetMessageBoxList_result = GetMessageBoxList_result  { getMessageBoxList_result_success :: (Vector.Vector TMessageBox)
  , getMessageBoxList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxList_result_success record   `H.hashWithSalt` getMessageBoxList_result_e record  
instance QC.Arbitrary GetMessageBoxList_result where 
  arbitrary = M.liftM GetMessageBoxList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxList_result{getMessageBoxList_result_success = getMessageBoxList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxList_result{getMessageBoxList_result_success = getMessageBoxList_result_success obj}
    , if obj == default_GetMessageBoxList_result{getMessageBoxList_result_e = getMessageBoxList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxList_result{getMessageBoxList_result_e = getMessageBoxList_result_e obj}
    ]
from_GetMessageBoxList_result :: GetMessageBoxList_result -> T.ThriftVal
from_GetMessageBoxList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7315 -> (1, ("e",from_TalkException _v7315))) <$> getMessageBoxList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7315 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_TMessageBox) $ P.map (\_v7317 -> from_TMessageBox _v7317) $ Vector.toList _v7315))) $ getMessageBoxList_result_success record
    , (\_v7315 -> (1, ("e",from_TalkException _v7315))) <$> getMessageBoxList_result_e record
    ]
    )
write_GetMessageBoxList_result :: T.Protocol p => p -> GetMessageBoxList_result -> P.IO ()
write_GetMessageBoxList_result oprot record = T.writeVal oprot $ from_GetMessageBoxList_result record
encode_GetMessageBoxList_result :: T.StatelessProtocol p => p -> GetMessageBoxList_result -> LBS.ByteString
encode_GetMessageBoxList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxList_result record
to_GetMessageBoxList_result :: T.ThriftVal -> GetMessageBoxList_result
to_GetMessageBoxList_result (T.TStruct fields) = GetMessageBoxList_result{
  getMessageBoxList_result_success = P.maybe (getMessageBoxList_result_success default_GetMessageBoxList_result) (\(_,_val7319) -> (case _val7319 of {T.TList _ _val7320 -> (Vector.fromList $ P.map (\_v7321 -> (case _v7321 of {T.TStruct _val7322 -> (to_TMessageBox (T.TStruct _val7322)); _ -> P.error "wrong type"})) _val7320); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxList_result_e = P.maybe (P.Nothing) (\(_,_val7319) -> P.Just (case _val7319 of {T.TStruct _val7323 -> (to_TalkException (T.TStruct _val7323)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxList_result _ = P.error "not a struct"
read_GetMessageBoxList_result :: T.Protocol p => p -> P.IO GetMessageBoxList_result
read_GetMessageBoxList_result iprot = to_GetMessageBoxList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxList_result)
decode_GetMessageBoxList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxList_result
decode_GetMessageBoxList_result iprot bs = to_GetMessageBoxList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxList_result) bs
typemap_GetMessageBoxList_result :: T.TypeMap
typemap_GetMessageBoxList_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_TMessageBox)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxList_result :: GetMessageBoxList_result
default_GetMessageBoxList_result = GetMessageBoxList_result{
  getMessageBoxList_result_success = Vector.empty,
  getMessageBoxList_result_e = P.Nothing}
data GetMessageBoxListByStatus_args = GetMessageBoxListByStatus_args  { getMessageBoxListByStatus_args_channelId :: LT.Text
  , getMessageBoxListByStatus_args_lastMessagesCount :: I.Int32
  , getMessageBoxListByStatus_args_status :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxListByStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxListByStatus_args_channelId record   `H.hashWithSalt` getMessageBoxListByStatus_args_lastMessagesCount record   `H.hashWithSalt` getMessageBoxListByStatus_args_status record  
instance QC.Arbitrary GetMessageBoxListByStatus_args where 
  arbitrary = M.liftM GetMessageBoxListByStatus_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxListByStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_channelId = getMessageBoxListByStatus_args_channelId obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_channelId = getMessageBoxListByStatus_args_channelId obj}
    , if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_lastMessagesCount = getMessageBoxListByStatus_args_lastMessagesCount obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_lastMessagesCount = getMessageBoxListByStatus_args_lastMessagesCount obj}
    , if obj == default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_status = getMessageBoxListByStatus_args_status obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_args{getMessageBoxListByStatus_args_status = getMessageBoxListByStatus_args_status obj}
    ]
from_GetMessageBoxListByStatus_args :: GetMessageBoxListByStatus_args -> T.ThriftVal
from_GetMessageBoxListByStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7326 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v7326))) $ getMessageBoxListByStatus_args_channelId record
  , (\_v7326 -> P.Just (3, ("lastMessagesCount",T.TI32 _v7326))) $ getMessageBoxListByStatus_args_lastMessagesCount record
  , (\_v7326 -> P.Just (4, ("status",T.TI32 _v7326))) $ getMessageBoxListByStatus_args_status record
  ]
write_GetMessageBoxListByStatus_args :: T.Protocol p => p -> GetMessageBoxListByStatus_args -> P.IO ()
write_GetMessageBoxListByStatus_args oprot record = T.writeVal oprot $ from_GetMessageBoxListByStatus_args record
encode_GetMessageBoxListByStatus_args :: T.StatelessProtocol p => p -> GetMessageBoxListByStatus_args -> LBS.ByteString
encode_GetMessageBoxListByStatus_args oprot record = T.serializeVal oprot $ from_GetMessageBoxListByStatus_args record
to_GetMessageBoxListByStatus_args :: T.ThriftVal -> GetMessageBoxListByStatus_args
to_GetMessageBoxListByStatus_args (T.TStruct fields) = GetMessageBoxListByStatus_args{
  getMessageBoxListByStatus_args_channelId = P.maybe (getMessageBoxListByStatus_args_channelId default_GetMessageBoxListByStatus_args) (\(_,_val7328) -> (case _val7328 of {T.TString _val7329 -> E.decodeUtf8 _val7329; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxListByStatus_args_lastMessagesCount = P.maybe (getMessageBoxListByStatus_args_lastMessagesCount default_GetMessageBoxListByStatus_args) (\(_,_val7328) -> (case _val7328 of {T.TI32 _val7330 -> _val7330; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessageBoxListByStatus_args_status = P.maybe (getMessageBoxListByStatus_args_status default_GetMessageBoxListByStatus_args) (\(_,_val7328) -> (case _val7328 of {T.TI32 _val7331 -> _val7331; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetMessageBoxListByStatus_args _ = P.error "not a struct"
read_GetMessageBoxListByStatus_args :: T.Protocol p => p -> P.IO GetMessageBoxListByStatus_args
read_GetMessageBoxListByStatus_args iprot = to_GetMessageBoxListByStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_args)
decode_GetMessageBoxListByStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxListByStatus_args
decode_GetMessageBoxListByStatus_args iprot bs = to_GetMessageBoxListByStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_args) bs
typemap_GetMessageBoxListByStatus_args :: T.TypeMap
typemap_GetMessageBoxListByStatus_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("lastMessagesCount",T.T_I32)),(4,("status",T.T_I32))]
default_GetMessageBoxListByStatus_args :: GetMessageBoxListByStatus_args
default_GetMessageBoxListByStatus_args = GetMessageBoxListByStatus_args{
  getMessageBoxListByStatus_args_channelId = "",
  getMessageBoxListByStatus_args_lastMessagesCount = 0,
  getMessageBoxListByStatus_args_status = 0}
data GetMessageBoxListByStatus_result = GetMessageBoxListByStatus_result  { getMessageBoxListByStatus_result_success :: (Vector.Vector TMessageBox)
  , getMessageBoxListByStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxListByStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxListByStatus_result_success record   `H.hashWithSalt` getMessageBoxListByStatus_result_e record  
instance QC.Arbitrary GetMessageBoxListByStatus_result where 
  arbitrary = M.liftM GetMessageBoxListByStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxListByStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = getMessageBoxListByStatus_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = getMessageBoxListByStatus_result_success obj}
    , if obj == default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = getMessageBoxListByStatus_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = getMessageBoxListByStatus_result_e obj}
    ]
from_GetMessageBoxListByStatus_result :: GetMessageBoxListByStatus_result -> T.ThriftVal
from_GetMessageBoxListByStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7334 -> (1, ("e",from_TalkException _v7334))) <$> getMessageBoxListByStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7334 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_TMessageBox) $ P.map (\_v7336 -> from_TMessageBox _v7336) $ Vector.toList _v7334))) $ getMessageBoxListByStatus_result_success record
    , (\_v7334 -> (1, ("e",from_TalkException _v7334))) <$> getMessageBoxListByStatus_result_e record
    ]
    )
write_GetMessageBoxListByStatus_result :: T.Protocol p => p -> GetMessageBoxListByStatus_result -> P.IO ()
write_GetMessageBoxListByStatus_result oprot record = T.writeVal oprot $ from_GetMessageBoxListByStatus_result record
encode_GetMessageBoxListByStatus_result :: T.StatelessProtocol p => p -> GetMessageBoxListByStatus_result -> LBS.ByteString
encode_GetMessageBoxListByStatus_result oprot record = T.serializeVal oprot $ from_GetMessageBoxListByStatus_result record
to_GetMessageBoxListByStatus_result :: T.ThriftVal -> GetMessageBoxListByStatus_result
to_GetMessageBoxListByStatus_result (T.TStruct fields) = GetMessageBoxListByStatus_result{
  getMessageBoxListByStatus_result_success = P.maybe (getMessageBoxListByStatus_result_success default_GetMessageBoxListByStatus_result) (\(_,_val7338) -> (case _val7338 of {T.TList _ _val7339 -> (Vector.fromList $ P.map (\_v7340 -> (case _v7340 of {T.TStruct _val7341 -> (to_TMessageBox (T.TStruct _val7341)); _ -> P.error "wrong type"})) _val7339); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxListByStatus_result_e = P.maybe (P.Nothing) (\(_,_val7338) -> P.Just (case _val7338 of {T.TStruct _val7342 -> (to_TalkException (T.TStruct _val7342)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxListByStatus_result _ = P.error "not a struct"
read_GetMessageBoxListByStatus_result :: T.Protocol p => p -> P.IO GetMessageBoxListByStatus_result
read_GetMessageBoxListByStatus_result iprot = to_GetMessageBoxListByStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_result)
decode_GetMessageBoxListByStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxListByStatus_result
decode_GetMessageBoxListByStatus_result iprot bs = to_GetMessageBoxListByStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxListByStatus_result) bs
typemap_GetMessageBoxListByStatus_result :: T.TypeMap
typemap_GetMessageBoxListByStatus_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_TMessageBox)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxListByStatus_result :: GetMessageBoxListByStatus_result
default_GetMessageBoxListByStatus_result = GetMessageBoxListByStatus_result{
  getMessageBoxListByStatus_result_success = Vector.empty,
  getMessageBoxListByStatus_result_e = P.Nothing}
data GetMessageBoxWrapUp_args = GetMessageBoxWrapUp_args  { getMessageBoxWrapUp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUp_args_mid record  
instance QC.Arbitrary GetMessageBoxWrapUp_args where 
  arbitrary = M.liftM GetMessageBoxWrapUp_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUp_args{getMessageBoxWrapUp_args_mid = getMessageBoxWrapUp_args_mid obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_args{getMessageBoxWrapUp_args_mid = getMessageBoxWrapUp_args_mid obj}
    ]
from_GetMessageBoxWrapUp_args :: GetMessageBoxWrapUp_args -> T.ThriftVal
from_GetMessageBoxWrapUp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7345 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v7345))) $ getMessageBoxWrapUp_args_mid record
  ]
write_GetMessageBoxWrapUp_args :: T.Protocol p => p -> GetMessageBoxWrapUp_args -> P.IO ()
write_GetMessageBoxWrapUp_args oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUp_args record
encode_GetMessageBoxWrapUp_args :: T.StatelessProtocol p => p -> GetMessageBoxWrapUp_args -> LBS.ByteString
encode_GetMessageBoxWrapUp_args oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUp_args record
to_GetMessageBoxWrapUp_args :: T.ThriftVal -> GetMessageBoxWrapUp_args
to_GetMessageBoxWrapUp_args (T.TStruct fields) = GetMessageBoxWrapUp_args{
  getMessageBoxWrapUp_args_mid = P.maybe (getMessageBoxWrapUp_args_mid default_GetMessageBoxWrapUp_args) (\(_,_val7347) -> (case _val7347 of {T.TString _val7348 -> E.decodeUtf8 _val7348; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageBoxWrapUp_args _ = P.error "not a struct"
read_GetMessageBoxWrapUp_args :: T.Protocol p => p -> P.IO GetMessageBoxWrapUp_args
read_GetMessageBoxWrapUp_args iprot = to_GetMessageBoxWrapUp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_args)
decode_GetMessageBoxWrapUp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUp_args
decode_GetMessageBoxWrapUp_args iprot bs = to_GetMessageBoxWrapUp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_args) bs
typemap_GetMessageBoxWrapUp_args :: T.TypeMap
typemap_GetMessageBoxWrapUp_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetMessageBoxWrapUp_args :: GetMessageBoxWrapUp_args
default_GetMessageBoxWrapUp_args = GetMessageBoxWrapUp_args{
  getMessageBoxWrapUp_args_mid = ""}
data GetMessageBoxWrapUp_result = GetMessageBoxWrapUp_result  { getMessageBoxWrapUp_result_success :: TMessageBoxWrapUp
  , getMessageBoxWrapUp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUp_result_success record   `H.hashWithSalt` getMessageBoxWrapUp_result_e record  
instance QC.Arbitrary GetMessageBoxWrapUp_result where 
  arbitrary = M.liftM GetMessageBoxWrapUp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = getMessageBoxWrapUp_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = getMessageBoxWrapUp_result_success obj}
    , if obj == default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = getMessageBoxWrapUp_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = getMessageBoxWrapUp_result_e obj}
    ]
from_GetMessageBoxWrapUp_result :: GetMessageBoxWrapUp_result -> T.ThriftVal
from_GetMessageBoxWrapUp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7351 -> (1, ("e",from_TalkException _v7351))) <$> getMessageBoxWrapUp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7351 -> P.Just (0, ("success",from_TMessageBoxWrapUp _v7351))) $ getMessageBoxWrapUp_result_success record
    , (\_v7351 -> (1, ("e",from_TalkException _v7351))) <$> getMessageBoxWrapUp_result_e record
    ]
    )
write_GetMessageBoxWrapUp_result :: T.Protocol p => p -> GetMessageBoxWrapUp_result -> P.IO ()
write_GetMessageBoxWrapUp_result oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUp_result record
encode_GetMessageBoxWrapUp_result :: T.StatelessProtocol p => p -> GetMessageBoxWrapUp_result -> LBS.ByteString
encode_GetMessageBoxWrapUp_result oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUp_result record
to_GetMessageBoxWrapUp_result :: T.ThriftVal -> GetMessageBoxWrapUp_result
to_GetMessageBoxWrapUp_result (T.TStruct fields) = GetMessageBoxWrapUp_result{
  getMessageBoxWrapUp_result_success = P.maybe (getMessageBoxWrapUp_result_success default_GetMessageBoxWrapUp_result) (\(_,_val7353) -> (case _val7353 of {T.TStruct _val7354 -> (to_TMessageBoxWrapUp (T.TStruct _val7354)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxWrapUp_result_e = P.maybe (P.Nothing) (\(_,_val7353) -> P.Just (case _val7353 of {T.TStruct _val7355 -> (to_TalkException (T.TStruct _val7355)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxWrapUp_result _ = P.error "not a struct"
read_GetMessageBoxWrapUp_result :: T.Protocol p => p -> P.IO GetMessageBoxWrapUp_result
read_GetMessageBoxWrapUp_result iprot = to_GetMessageBoxWrapUp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_result)
decode_GetMessageBoxWrapUp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUp_result
decode_GetMessageBoxWrapUp_result iprot bs = to_GetMessageBoxWrapUp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUp_result) bs
typemap_GetMessageBoxWrapUp_result :: T.TypeMap
typemap_GetMessageBoxWrapUp_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUp))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxWrapUp_result :: GetMessageBoxWrapUp_result
default_GetMessageBoxWrapUp_result = GetMessageBoxWrapUp_result{
  getMessageBoxWrapUp_result_success = default_TMessageBoxWrapUp,
  getMessageBoxWrapUp_result_e = P.Nothing}
data GetMessageBoxWrapUpList_args = GetMessageBoxWrapUpList_args  { getMessageBoxWrapUpList_args_start :: I.Int32
  , getMessageBoxWrapUpList_args_messageBoxCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUpList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUpList_args_start record   `H.hashWithSalt` getMessageBoxWrapUpList_args_messageBoxCount record  
instance QC.Arbitrary GetMessageBoxWrapUpList_args where 
  arbitrary = M.liftM GetMessageBoxWrapUpList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUpList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_start = getMessageBoxWrapUpList_args_start obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_start = getMessageBoxWrapUpList_args_start obj}
    , if obj == default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_messageBoxCount = getMessageBoxWrapUpList_args_messageBoxCount obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_args{getMessageBoxWrapUpList_args_messageBoxCount = getMessageBoxWrapUpList_args_messageBoxCount obj}
    ]
from_GetMessageBoxWrapUpList_args :: GetMessageBoxWrapUpList_args -> T.ThriftVal
from_GetMessageBoxWrapUpList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7358 -> P.Just (2, ("start",T.TI32 _v7358))) $ getMessageBoxWrapUpList_args_start record
  , (\_v7358 -> P.Just (3, ("messageBoxCount",T.TI32 _v7358))) $ getMessageBoxWrapUpList_args_messageBoxCount record
  ]
write_GetMessageBoxWrapUpList_args :: T.Protocol p => p -> GetMessageBoxWrapUpList_args -> P.IO ()
write_GetMessageBoxWrapUpList_args oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUpList_args record
encode_GetMessageBoxWrapUpList_args :: T.StatelessProtocol p => p -> GetMessageBoxWrapUpList_args -> LBS.ByteString
encode_GetMessageBoxWrapUpList_args oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUpList_args record
to_GetMessageBoxWrapUpList_args :: T.ThriftVal -> GetMessageBoxWrapUpList_args
to_GetMessageBoxWrapUpList_args (T.TStruct fields) = GetMessageBoxWrapUpList_args{
  getMessageBoxWrapUpList_args_start = P.maybe (getMessageBoxWrapUpList_args_start default_GetMessageBoxWrapUpList_args) (\(_,_val7360) -> (case _val7360 of {T.TI32 _val7361 -> _val7361; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessageBoxWrapUpList_args_messageBoxCount = P.maybe (getMessageBoxWrapUpList_args_messageBoxCount default_GetMessageBoxWrapUpList_args) (\(_,_val7360) -> (case _val7360 of {T.TI32 _val7362 -> _val7362; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetMessageBoxWrapUpList_args _ = P.error "not a struct"
read_GetMessageBoxWrapUpList_args :: T.Protocol p => p -> P.IO GetMessageBoxWrapUpList_args
read_GetMessageBoxWrapUpList_args iprot = to_GetMessageBoxWrapUpList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_args)
decode_GetMessageBoxWrapUpList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUpList_args
decode_GetMessageBoxWrapUpList_args iprot bs = to_GetMessageBoxWrapUpList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_args) bs
typemap_GetMessageBoxWrapUpList_args :: T.TypeMap
typemap_GetMessageBoxWrapUpList_args = Map.fromList [(2,("start",T.T_I32)),(3,("messageBoxCount",T.T_I32))]
default_GetMessageBoxWrapUpList_args :: GetMessageBoxWrapUpList_args
default_GetMessageBoxWrapUpList_args = GetMessageBoxWrapUpList_args{
  getMessageBoxWrapUpList_args_start = 0,
  getMessageBoxWrapUpList_args_messageBoxCount = 0}
data GetMessageBoxWrapUpList_result = GetMessageBoxWrapUpList_result  { getMessageBoxWrapUpList_result_success :: TMessageBoxWrapUpResponse
  , getMessageBoxWrapUpList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxWrapUpList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxWrapUpList_result_success record   `H.hashWithSalt` getMessageBoxWrapUpList_result_e record  
instance QC.Arbitrary GetMessageBoxWrapUpList_result where 
  arbitrary = M.liftM GetMessageBoxWrapUpList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxWrapUpList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = getMessageBoxWrapUpList_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = getMessageBoxWrapUpList_result_success obj}
    , if obj == default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = getMessageBoxWrapUpList_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = getMessageBoxWrapUpList_result_e obj}
    ]
from_GetMessageBoxWrapUpList_result :: GetMessageBoxWrapUpList_result -> T.ThriftVal
from_GetMessageBoxWrapUpList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7365 -> (1, ("e",from_TalkException _v7365))) <$> getMessageBoxWrapUpList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7365 -> P.Just (0, ("success",from_TMessageBoxWrapUpResponse _v7365))) $ getMessageBoxWrapUpList_result_success record
    , (\_v7365 -> (1, ("e",from_TalkException _v7365))) <$> getMessageBoxWrapUpList_result_e record
    ]
    )
write_GetMessageBoxWrapUpList_result :: T.Protocol p => p -> GetMessageBoxWrapUpList_result -> P.IO ()
write_GetMessageBoxWrapUpList_result oprot record = T.writeVal oprot $ from_GetMessageBoxWrapUpList_result record
encode_GetMessageBoxWrapUpList_result :: T.StatelessProtocol p => p -> GetMessageBoxWrapUpList_result -> LBS.ByteString
encode_GetMessageBoxWrapUpList_result oprot record = T.serializeVal oprot $ from_GetMessageBoxWrapUpList_result record
to_GetMessageBoxWrapUpList_result :: T.ThriftVal -> GetMessageBoxWrapUpList_result
to_GetMessageBoxWrapUpList_result (T.TStruct fields) = GetMessageBoxWrapUpList_result{
  getMessageBoxWrapUpList_result_success = P.maybe (getMessageBoxWrapUpList_result_success default_GetMessageBoxWrapUpList_result) (\(_,_val7367) -> (case _val7367 of {T.TStruct _val7368 -> (to_TMessageBoxWrapUpResponse (T.TStruct _val7368)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxWrapUpList_result_e = P.maybe (P.Nothing) (\(_,_val7367) -> P.Just (case _val7367 of {T.TStruct _val7369 -> (to_TalkException (T.TStruct _val7369)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxWrapUpList_result _ = P.error "not a struct"
read_GetMessageBoxWrapUpList_result :: T.Protocol p => p -> P.IO GetMessageBoxWrapUpList_result
read_GetMessageBoxWrapUpList_result iprot = to_GetMessageBoxWrapUpList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_result)
decode_GetMessageBoxWrapUpList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxWrapUpList_result
decode_GetMessageBoxWrapUpList_result iprot bs = to_GetMessageBoxWrapUpList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxWrapUpList_result) bs
typemap_GetMessageBoxWrapUpList_result :: T.TypeMap
typemap_GetMessageBoxWrapUpList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUpResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxWrapUpList_result :: GetMessageBoxWrapUpList_result
default_GetMessageBoxWrapUpList_result = GetMessageBoxWrapUpList_result{
  getMessageBoxWrapUpList_result_success = default_TMessageBoxWrapUpResponse,
  getMessageBoxWrapUpList_result_e = P.Nothing}
data GetMessagesBySequenceNumber_args = GetMessagesBySequenceNumber_args  { getMessagesBySequenceNumber_args_channelId :: LT.Text
  , getMessagesBySequenceNumber_args_messageBoxId :: LT.Text
  , getMessagesBySequenceNumber_args_startSeq :: I.Int64
  , getMessagesBySequenceNumber_args_endSeq :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessagesBySequenceNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessagesBySequenceNumber_args_channelId record   `H.hashWithSalt` getMessagesBySequenceNumber_args_messageBoxId record   `H.hashWithSalt` getMessagesBySequenceNumber_args_startSeq record   `H.hashWithSalt` getMessagesBySequenceNumber_args_endSeq record  
instance QC.Arbitrary GetMessagesBySequenceNumber_args where 
  arbitrary = M.liftM GetMessagesBySequenceNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetMessagesBySequenceNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_channelId = getMessagesBySequenceNumber_args_channelId obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_channelId = getMessagesBySequenceNumber_args_channelId obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_messageBoxId = getMessagesBySequenceNumber_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_messageBoxId = getMessagesBySequenceNumber_args_messageBoxId obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_startSeq = getMessagesBySequenceNumber_args_startSeq obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_startSeq = getMessagesBySequenceNumber_args_startSeq obj}
    , if obj == default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_endSeq = getMessagesBySequenceNumber_args_endSeq obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_args{getMessagesBySequenceNumber_args_endSeq = getMessagesBySequenceNumber_args_endSeq obj}
    ]
from_GetMessagesBySequenceNumber_args :: GetMessagesBySequenceNumber_args -> T.ThriftVal
from_GetMessagesBySequenceNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7372 -> P.Just (2, ("channelId",T.TString $ E.encodeUtf8 _v7372))) $ getMessagesBySequenceNumber_args_channelId record
  , (\_v7372 -> P.Just (3, ("messageBoxId",T.TString $ E.encodeUtf8 _v7372))) $ getMessagesBySequenceNumber_args_messageBoxId record
  , (\_v7372 -> P.Just (4, ("startSeq",T.TI64 _v7372))) $ getMessagesBySequenceNumber_args_startSeq record
  , (\_v7372 -> P.Just (5, ("endSeq",T.TI64 _v7372))) $ getMessagesBySequenceNumber_args_endSeq record
  ]
write_GetMessagesBySequenceNumber_args :: T.Protocol p => p -> GetMessagesBySequenceNumber_args -> P.IO ()
write_GetMessagesBySequenceNumber_args oprot record = T.writeVal oprot $ from_GetMessagesBySequenceNumber_args record
encode_GetMessagesBySequenceNumber_args :: T.StatelessProtocol p => p -> GetMessagesBySequenceNumber_args -> LBS.ByteString
encode_GetMessagesBySequenceNumber_args oprot record = T.serializeVal oprot $ from_GetMessagesBySequenceNumber_args record
to_GetMessagesBySequenceNumber_args :: T.ThriftVal -> GetMessagesBySequenceNumber_args
to_GetMessagesBySequenceNumber_args (T.TStruct fields) = GetMessagesBySequenceNumber_args{
  getMessagesBySequenceNumber_args_channelId = P.maybe (getMessagesBySequenceNumber_args_channelId default_GetMessagesBySequenceNumber_args) (\(_,_val7374) -> (case _val7374 of {T.TString _val7375 -> E.decodeUtf8 _val7375; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getMessagesBySequenceNumber_args_messageBoxId = P.maybe (getMessagesBySequenceNumber_args_messageBoxId default_GetMessagesBySequenceNumber_args) (\(_,_val7374) -> (case _val7374 of {T.TString _val7376 -> E.decodeUtf8 _val7376; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getMessagesBySequenceNumber_args_startSeq = P.maybe (getMessagesBySequenceNumber_args_startSeq default_GetMessagesBySequenceNumber_args) (\(_,_val7374) -> (case _val7374 of {T.TI64 _val7377 -> _val7377; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getMessagesBySequenceNumber_args_endSeq = P.maybe (getMessagesBySequenceNumber_args_endSeq default_GetMessagesBySequenceNumber_args) (\(_,_val7374) -> (case _val7374 of {T.TI64 _val7378 -> _val7378; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetMessagesBySequenceNumber_args _ = P.error "not a struct"
read_GetMessagesBySequenceNumber_args :: T.Protocol p => p -> P.IO GetMessagesBySequenceNumber_args
read_GetMessagesBySequenceNumber_args iprot = to_GetMessagesBySequenceNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_args)
decode_GetMessagesBySequenceNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessagesBySequenceNumber_args
decode_GetMessagesBySequenceNumber_args iprot bs = to_GetMessagesBySequenceNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_args) bs
typemap_GetMessagesBySequenceNumber_args :: T.TypeMap
typemap_GetMessagesBySequenceNumber_args = Map.fromList [(2,("channelId",T.T_STRING)),(3,("messageBoxId",T.T_STRING)),(4,("startSeq",T.T_I64)),(5,("endSeq",T.T_I64))]
default_GetMessagesBySequenceNumber_args :: GetMessagesBySequenceNumber_args
default_GetMessagesBySequenceNumber_args = GetMessagesBySequenceNumber_args{
  getMessagesBySequenceNumber_args_channelId = "",
  getMessagesBySequenceNumber_args_messageBoxId = "",
  getMessagesBySequenceNumber_args_startSeq = 0,
  getMessagesBySequenceNumber_args_endSeq = 0}
data GetMessagesBySequenceNumber_result = GetMessagesBySequenceNumber_result  { getMessagesBySequenceNumber_result_success :: (Vector.Vector Message)
  , getMessagesBySequenceNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessagesBySequenceNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessagesBySequenceNumber_result_success record   `H.hashWithSalt` getMessagesBySequenceNumber_result_e record  
instance QC.Arbitrary GetMessagesBySequenceNumber_result where 
  arbitrary = M.liftM GetMessagesBySequenceNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessagesBySequenceNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = getMessagesBySequenceNumber_result_success obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = getMessagesBySequenceNumber_result_success obj}
    , if obj == default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = getMessagesBySequenceNumber_result_e obj} then P.Nothing else P.Just $ default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = getMessagesBySequenceNumber_result_e obj}
    ]
from_GetMessagesBySequenceNumber_result :: GetMessagesBySequenceNumber_result -> T.ThriftVal
from_GetMessagesBySequenceNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7381 -> (1, ("e",from_TalkException _v7381))) <$> getMessagesBySequenceNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7381 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v7383 -> from_Message _v7383) $ Vector.toList _v7381))) $ getMessagesBySequenceNumber_result_success record
    , (\_v7381 -> (1, ("e",from_TalkException _v7381))) <$> getMessagesBySequenceNumber_result_e record
    ]
    )
write_GetMessagesBySequenceNumber_result :: T.Protocol p => p -> GetMessagesBySequenceNumber_result -> P.IO ()
write_GetMessagesBySequenceNumber_result oprot record = T.writeVal oprot $ from_GetMessagesBySequenceNumber_result record
encode_GetMessagesBySequenceNumber_result :: T.StatelessProtocol p => p -> GetMessagesBySequenceNumber_result -> LBS.ByteString
encode_GetMessagesBySequenceNumber_result oprot record = T.serializeVal oprot $ from_GetMessagesBySequenceNumber_result record
to_GetMessagesBySequenceNumber_result :: T.ThriftVal -> GetMessagesBySequenceNumber_result
to_GetMessagesBySequenceNumber_result (T.TStruct fields) = GetMessagesBySequenceNumber_result{
  getMessagesBySequenceNumber_result_success = P.maybe (getMessagesBySequenceNumber_result_success default_GetMessagesBySequenceNumber_result) (\(_,_val7385) -> (case _val7385 of {T.TList _ _val7386 -> (Vector.fromList $ P.map (\_v7387 -> (case _v7387 of {T.TStruct _val7388 -> (to_Message (T.TStruct _val7388)); _ -> P.error "wrong type"})) _val7386); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessagesBySequenceNumber_result_e = P.maybe (P.Nothing) (\(_,_val7385) -> P.Just (case _val7385 of {T.TStruct _val7389 -> (to_TalkException (T.TStruct _val7389)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessagesBySequenceNumber_result _ = P.error "not a struct"
read_GetMessagesBySequenceNumber_result :: T.Protocol p => p -> P.IO GetMessagesBySequenceNumber_result
read_GetMessagesBySequenceNumber_result iprot = to_GetMessagesBySequenceNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_result)
decode_GetMessagesBySequenceNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessagesBySequenceNumber_result
decode_GetMessagesBySequenceNumber_result iprot bs = to_GetMessagesBySequenceNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessagesBySequenceNumber_result) bs
typemap_GetMessagesBySequenceNumber_result :: T.TypeMap
typemap_GetMessagesBySequenceNumber_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessagesBySequenceNumber_result :: GetMessagesBySequenceNumber_result
default_GetMessagesBySequenceNumber_result = GetMessagesBySequenceNumber_result{
  getMessagesBySequenceNumber_result_success = Vector.empty,
  getMessagesBySequenceNumber_result_e = P.Nothing}
data GetNextMessages_args = GetNextMessages_args  { getNextMessages_args_messageBoxId :: LT.Text
  , getNextMessages_args_startSeq :: I.Int64
  , getNextMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessages_args_messageBoxId record   `H.hashWithSalt` getNextMessages_args_startSeq record   `H.hashWithSalt` getNextMessages_args_messagesCount record  
instance QC.Arbitrary GetNextMessages_args where 
  arbitrary = M.liftM GetNextMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNextMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessages_args{getNextMessages_args_messageBoxId = getNextMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_messageBoxId = getNextMessages_args_messageBoxId obj}
    , if obj == default_GetNextMessages_args{getNextMessages_args_startSeq = getNextMessages_args_startSeq obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_startSeq = getNextMessages_args_startSeq obj}
    , if obj == default_GetNextMessages_args{getNextMessages_args_messagesCount = getNextMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetNextMessages_args{getNextMessages_args_messagesCount = getNextMessages_args_messagesCount obj}
    ]
from_GetNextMessages_args :: GetNextMessages_args -> T.ThriftVal
from_GetNextMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7392 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v7392))) $ getNextMessages_args_messageBoxId record
  , (\_v7392 -> P.Just (3, ("startSeq",T.TI64 _v7392))) $ getNextMessages_args_startSeq record
  , (\_v7392 -> P.Just (4, ("messagesCount",T.TI32 _v7392))) $ getNextMessages_args_messagesCount record
  ]
write_GetNextMessages_args :: T.Protocol p => p -> GetNextMessages_args -> P.IO ()
write_GetNextMessages_args oprot record = T.writeVal oprot $ from_GetNextMessages_args record
encode_GetNextMessages_args :: T.StatelessProtocol p => p -> GetNextMessages_args -> LBS.ByteString
encode_GetNextMessages_args oprot record = T.serializeVal oprot $ from_GetNextMessages_args record
to_GetNextMessages_args :: T.ThriftVal -> GetNextMessages_args
to_GetNextMessages_args (T.TStruct fields) = GetNextMessages_args{
  getNextMessages_args_messageBoxId = P.maybe (getNextMessages_args_messageBoxId default_GetNextMessages_args) (\(_,_val7394) -> (case _val7394 of {T.TString _val7395 -> E.decodeUtf8 _val7395; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNextMessages_args_startSeq = P.maybe (getNextMessages_args_startSeq default_GetNextMessages_args) (\(_,_val7394) -> (case _val7394 of {T.TI64 _val7396 -> _val7396; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNextMessages_args_messagesCount = P.maybe (getNextMessages_args_messagesCount default_GetNextMessages_args) (\(_,_val7394) -> (case _val7394 of {T.TI32 _val7397 -> _val7397; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetNextMessages_args _ = P.error "not a struct"
read_GetNextMessages_args :: T.Protocol p => p -> P.IO GetNextMessages_args
read_GetNextMessages_args iprot = to_GetNextMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessages_args)
decode_GetNextMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessages_args
decode_GetNextMessages_args iprot bs = to_GetNextMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessages_args) bs
typemap_GetNextMessages_args :: T.TypeMap
typemap_GetNextMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("startSeq",T.T_I64)),(4,("messagesCount",T.T_I32))]
default_GetNextMessages_args :: GetNextMessages_args
default_GetNextMessages_args = GetNextMessages_args{
  getNextMessages_args_messageBoxId = "",
  getNextMessages_args_startSeq = 0,
  getNextMessages_args_messagesCount = 0}
data GetNextMessages_result = GetNextMessages_result  { getNextMessages_result_success :: (Vector.Vector Message)
  , getNextMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessages_result_success record   `H.hashWithSalt` getNextMessages_result_e record  
instance QC.Arbitrary GetNextMessages_result where 
  arbitrary = M.liftM GetNextMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNextMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessages_result{getNextMessages_result_success = getNextMessages_result_success obj} then P.Nothing else P.Just $ default_GetNextMessages_result{getNextMessages_result_success = getNextMessages_result_success obj}
    , if obj == default_GetNextMessages_result{getNextMessages_result_e = getNextMessages_result_e obj} then P.Nothing else P.Just $ default_GetNextMessages_result{getNextMessages_result_e = getNextMessages_result_e obj}
    ]
from_GetNextMessages_result :: GetNextMessages_result -> T.ThriftVal
from_GetNextMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7400 -> (1, ("e",from_TalkException _v7400))) <$> getNextMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7400 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v7402 -> from_Message _v7402) $ Vector.toList _v7400))) $ getNextMessages_result_success record
    , (\_v7400 -> (1, ("e",from_TalkException _v7400))) <$> getNextMessages_result_e record
    ]
    )
write_GetNextMessages_result :: T.Protocol p => p -> GetNextMessages_result -> P.IO ()
write_GetNextMessages_result oprot record = T.writeVal oprot $ from_GetNextMessages_result record
encode_GetNextMessages_result :: T.StatelessProtocol p => p -> GetNextMessages_result -> LBS.ByteString
encode_GetNextMessages_result oprot record = T.serializeVal oprot $ from_GetNextMessages_result record
to_GetNextMessages_result :: T.ThriftVal -> GetNextMessages_result
to_GetNextMessages_result (T.TStruct fields) = GetNextMessages_result{
  getNextMessages_result_success = P.maybe (getNextMessages_result_success default_GetNextMessages_result) (\(_,_val7404) -> (case _val7404 of {T.TList _ _val7405 -> (Vector.fromList $ P.map (\_v7406 -> (case _v7406 of {T.TStruct _val7407 -> (to_Message (T.TStruct _val7407)); _ -> P.error "wrong type"})) _val7405); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNextMessages_result_e = P.maybe (P.Nothing) (\(_,_val7404) -> P.Just (case _val7404 of {T.TStruct _val7408 -> (to_TalkException (T.TStruct _val7408)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNextMessages_result _ = P.error "not a struct"
read_GetNextMessages_result :: T.Protocol p => p -> P.IO GetNextMessages_result
read_GetNextMessages_result iprot = to_GetNextMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessages_result)
decode_GetNextMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessages_result
decode_GetNextMessages_result iprot bs = to_GetNextMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessages_result) bs
typemap_GetNextMessages_result :: T.TypeMap
typemap_GetNextMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNextMessages_result :: GetNextMessages_result
default_GetNextMessages_result = GetNextMessages_result{
  getNextMessages_result_success = Vector.empty,
  getNextMessages_result_e = P.Nothing}
data GetNotificationPolicy_args = GetNotificationPolicy_args  { getNotificationPolicy_args_carrier :: CarrierCode
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationPolicy_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationPolicy_args_carrier record  
instance QC.Arbitrary GetNotificationPolicy_args where 
  arbitrary = M.liftM GetNotificationPolicy_args (QC.arbitrary)
  shrink obj | obj == default_GetNotificationPolicy_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationPolicy_args{getNotificationPolicy_args_carrier = getNotificationPolicy_args_carrier obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_args{getNotificationPolicy_args_carrier = getNotificationPolicy_args_carrier obj}
    ]
from_GetNotificationPolicy_args :: GetNotificationPolicy_args -> T.ThriftVal
from_GetNotificationPolicy_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7411 -> P.Just (2, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v7411))) $ getNotificationPolicy_args_carrier record
  ]
write_GetNotificationPolicy_args :: T.Protocol p => p -> GetNotificationPolicy_args -> P.IO ()
write_GetNotificationPolicy_args oprot record = T.writeVal oprot $ from_GetNotificationPolicy_args record
encode_GetNotificationPolicy_args :: T.StatelessProtocol p => p -> GetNotificationPolicy_args -> LBS.ByteString
encode_GetNotificationPolicy_args oprot record = T.serializeVal oprot $ from_GetNotificationPolicy_args record
to_GetNotificationPolicy_args :: T.ThriftVal -> GetNotificationPolicy_args
to_GetNotificationPolicy_args (T.TStruct fields) = GetNotificationPolicy_args{
  getNotificationPolicy_args_carrier = P.maybe (getNotificationPolicy_args_carrier default_GetNotificationPolicy_args) (\(_,_val7413) -> (case _val7413 of {T.TI32 _val7414 -> P.toEnum $ P.fromIntegral _val7414; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotificationPolicy_args _ = P.error "not a struct"
read_GetNotificationPolicy_args :: T.Protocol p => p -> P.IO GetNotificationPolicy_args
read_GetNotificationPolicy_args iprot = to_GetNotificationPolicy_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_args)
decode_GetNotificationPolicy_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationPolicy_args
decode_GetNotificationPolicy_args iprot bs = to_GetNotificationPolicy_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_args) bs
typemap_GetNotificationPolicy_args :: T.TypeMap
typemap_GetNotificationPolicy_args = Map.fromList [(2,("carrier",T.T_I32))]
default_GetNotificationPolicy_args :: GetNotificationPolicy_args
default_GetNotificationPolicy_args = GetNotificationPolicy_args{
  getNotificationPolicy_args_carrier = (P.toEnum 0)}
data GetNotificationPolicy_result = GetNotificationPolicy_result  { getNotificationPolicy_result_success :: (Vector.Vector NotificationType)
  , getNotificationPolicy_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotificationPolicy_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotificationPolicy_result_success record   `H.hashWithSalt` getNotificationPolicy_result_e record  
instance QC.Arbitrary GetNotificationPolicy_result where 
  arbitrary = M.liftM GetNotificationPolicy_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotificationPolicy_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotificationPolicy_result{getNotificationPolicy_result_success = getNotificationPolicy_result_success obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_result{getNotificationPolicy_result_success = getNotificationPolicy_result_success obj}
    , if obj == default_GetNotificationPolicy_result{getNotificationPolicy_result_e = getNotificationPolicy_result_e obj} then P.Nothing else P.Just $ default_GetNotificationPolicy_result{getNotificationPolicy_result_e = getNotificationPolicy_result_e obj}
    ]
from_GetNotificationPolicy_result :: GetNotificationPolicy_result -> T.ThriftVal
from_GetNotificationPolicy_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7417 -> (1, ("e",from_TalkException _v7417))) <$> getNotificationPolicy_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7417 -> P.Just (0, ("success",T.TList T.T_I32 $ P.map (\_v7419 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v7419) $ Vector.toList _v7417))) $ getNotificationPolicy_result_success record
    , (\_v7417 -> (1, ("e",from_TalkException _v7417))) <$> getNotificationPolicy_result_e record
    ]
    )
write_GetNotificationPolicy_result :: T.Protocol p => p -> GetNotificationPolicy_result -> P.IO ()
write_GetNotificationPolicy_result oprot record = T.writeVal oprot $ from_GetNotificationPolicy_result record
encode_GetNotificationPolicy_result :: T.StatelessProtocol p => p -> GetNotificationPolicy_result -> LBS.ByteString
encode_GetNotificationPolicy_result oprot record = T.serializeVal oprot $ from_GetNotificationPolicy_result record
to_GetNotificationPolicy_result :: T.ThriftVal -> GetNotificationPolicy_result
to_GetNotificationPolicy_result (T.TStruct fields) = GetNotificationPolicy_result{
  getNotificationPolicy_result_success = P.maybe (getNotificationPolicy_result_success default_GetNotificationPolicy_result) (\(_,_val7421) -> (case _val7421 of {T.TList _ _val7422 -> (Vector.fromList $ P.map (\_v7423 -> (case _v7423 of {T.TI32 _val7424 -> P.toEnum $ P.fromIntegral _val7424; _ -> P.error "wrong type"})) _val7422); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotificationPolicy_result_e = P.maybe (P.Nothing) (\(_,_val7421) -> P.Just (case _val7421 of {T.TStruct _val7425 -> (to_TalkException (T.TStruct _val7425)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNotificationPolicy_result _ = P.error "not a struct"
read_GetNotificationPolicy_result :: T.Protocol p => p -> P.IO GetNotificationPolicy_result
read_GetNotificationPolicy_result iprot = to_GetNotificationPolicy_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_result)
decode_GetNotificationPolicy_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotificationPolicy_result
decode_GetNotificationPolicy_result iprot bs = to_GetNotificationPolicy_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotificationPolicy_result) bs
typemap_GetNotificationPolicy_result :: T.TypeMap
typemap_GetNotificationPolicy_result = Map.fromList [(0,("success",(T.T_LIST T.T_I32))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNotificationPolicy_result :: GetNotificationPolicy_result
default_GetNotificationPolicy_result = GetNotificationPolicy_result{
  getNotificationPolicy_result_success = Vector.empty,
  getNotificationPolicy_result_e = P.Nothing}
data GetPreviousMessages_args = GetPreviousMessages_args  { getPreviousMessages_args_messageBoxId :: LT.Text
  , getPreviousMessages_args_endSeq :: I.Int64
  , getPreviousMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessages_args_messageBoxId record   `H.hashWithSalt` getPreviousMessages_args_endSeq record   `H.hashWithSalt` getPreviousMessages_args_messagesCount record  
instance QC.Arbitrary GetPreviousMessages_args where 
  arbitrary = M.liftM GetPreviousMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessages_args{getPreviousMessages_args_messageBoxId = getPreviousMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_messageBoxId = getPreviousMessages_args_messageBoxId obj}
    , if obj == default_GetPreviousMessages_args{getPreviousMessages_args_endSeq = getPreviousMessages_args_endSeq obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_endSeq = getPreviousMessages_args_endSeq obj}
    , if obj == default_GetPreviousMessages_args{getPreviousMessages_args_messagesCount = getPreviousMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetPreviousMessages_args{getPreviousMessages_args_messagesCount = getPreviousMessages_args_messagesCount obj}
    ]
from_GetPreviousMessages_args :: GetPreviousMessages_args -> T.ThriftVal
from_GetPreviousMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7428 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v7428))) $ getPreviousMessages_args_messageBoxId record
  , (\_v7428 -> P.Just (3, ("endSeq",T.TI64 _v7428))) $ getPreviousMessages_args_endSeq record
  , (\_v7428 -> P.Just (4, ("messagesCount",T.TI32 _v7428))) $ getPreviousMessages_args_messagesCount record
  ]
write_GetPreviousMessages_args :: T.Protocol p => p -> GetPreviousMessages_args -> P.IO ()
write_GetPreviousMessages_args oprot record = T.writeVal oprot $ from_GetPreviousMessages_args record
encode_GetPreviousMessages_args :: T.StatelessProtocol p => p -> GetPreviousMessages_args -> LBS.ByteString
encode_GetPreviousMessages_args oprot record = T.serializeVal oprot $ from_GetPreviousMessages_args record
to_GetPreviousMessages_args :: T.ThriftVal -> GetPreviousMessages_args
to_GetPreviousMessages_args (T.TStruct fields) = GetPreviousMessages_args{
  getPreviousMessages_args_messageBoxId = P.maybe (getPreviousMessages_args_messageBoxId default_GetPreviousMessages_args) (\(_,_val7430) -> (case _val7430 of {T.TString _val7431 -> E.decodeUtf8 _val7431; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPreviousMessages_args_endSeq = P.maybe (getPreviousMessages_args_endSeq default_GetPreviousMessages_args) (\(_,_val7430) -> (case _val7430 of {T.TI64 _val7432 -> _val7432; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPreviousMessages_args_messagesCount = P.maybe (getPreviousMessages_args_messagesCount default_GetPreviousMessages_args) (\(_,_val7430) -> (case _val7430 of {T.TI32 _val7433 -> _val7433; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetPreviousMessages_args _ = P.error "not a struct"
read_GetPreviousMessages_args :: T.Protocol p => p -> P.IO GetPreviousMessages_args
read_GetPreviousMessages_args iprot = to_GetPreviousMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessages_args)
decode_GetPreviousMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessages_args
decode_GetPreviousMessages_args iprot bs = to_GetPreviousMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessages_args) bs
typemap_GetPreviousMessages_args :: T.TypeMap
typemap_GetPreviousMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("endSeq",T.T_I64)),(4,("messagesCount",T.T_I32))]
default_GetPreviousMessages_args :: GetPreviousMessages_args
default_GetPreviousMessages_args = GetPreviousMessages_args{
  getPreviousMessages_args_messageBoxId = "",
  getPreviousMessages_args_endSeq = 0,
  getPreviousMessages_args_messagesCount = 0}
data GetPreviousMessages_result = GetPreviousMessages_result  { getPreviousMessages_result_success :: (Vector.Vector Message)
  , getPreviousMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreviousMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreviousMessages_result_success record   `H.hashWithSalt` getPreviousMessages_result_e record  
instance QC.Arbitrary GetPreviousMessages_result where 
  arbitrary = M.liftM GetPreviousMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPreviousMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreviousMessages_result{getPreviousMessages_result_success = getPreviousMessages_result_success obj} then P.Nothing else P.Just $ default_GetPreviousMessages_result{getPreviousMessages_result_success = getPreviousMessages_result_success obj}
    , if obj == default_GetPreviousMessages_result{getPreviousMessages_result_e = getPreviousMessages_result_e obj} then P.Nothing else P.Just $ default_GetPreviousMessages_result{getPreviousMessages_result_e = getPreviousMessages_result_e obj}
    ]
from_GetPreviousMessages_result :: GetPreviousMessages_result -> T.ThriftVal
from_GetPreviousMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7436 -> (1, ("e",from_TalkException _v7436))) <$> getPreviousMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7436 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v7438 -> from_Message _v7438) $ Vector.toList _v7436))) $ getPreviousMessages_result_success record
    , (\_v7436 -> (1, ("e",from_TalkException _v7436))) <$> getPreviousMessages_result_e record
    ]
    )
write_GetPreviousMessages_result :: T.Protocol p => p -> GetPreviousMessages_result -> P.IO ()
write_GetPreviousMessages_result oprot record = T.writeVal oprot $ from_GetPreviousMessages_result record
encode_GetPreviousMessages_result :: T.StatelessProtocol p => p -> GetPreviousMessages_result -> LBS.ByteString
encode_GetPreviousMessages_result oprot record = T.serializeVal oprot $ from_GetPreviousMessages_result record
to_GetPreviousMessages_result :: T.ThriftVal -> GetPreviousMessages_result
to_GetPreviousMessages_result (T.TStruct fields) = GetPreviousMessages_result{
  getPreviousMessages_result_success = P.maybe (getPreviousMessages_result_success default_GetPreviousMessages_result) (\(_,_val7440) -> (case _val7440 of {T.TList _ _val7441 -> (Vector.fromList $ P.map (\_v7442 -> (case _v7442 of {T.TStruct _val7443 -> (to_Message (T.TStruct _val7443)); _ -> P.error "wrong type"})) _val7441); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPreviousMessages_result_e = P.maybe (P.Nothing) (\(_,_val7440) -> P.Just (case _val7440 of {T.TStruct _val7444 -> (to_TalkException (T.TStruct _val7444)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreviousMessages_result _ = P.error "not a struct"
read_GetPreviousMessages_result :: T.Protocol p => p -> P.IO GetPreviousMessages_result
read_GetPreviousMessages_result iprot = to_GetPreviousMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPreviousMessages_result)
decode_GetPreviousMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreviousMessages_result
decode_GetPreviousMessages_result iprot bs = to_GetPreviousMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreviousMessages_result) bs
typemap_GetPreviousMessages_result :: T.TypeMap
typemap_GetPreviousMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPreviousMessages_result :: GetPreviousMessages_result
default_GetPreviousMessages_result = GetPreviousMessages_result{
  getPreviousMessages_result_success = Vector.empty,
  getPreviousMessages_result_e = P.Nothing}
data GetProfile_args = GetProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfile_args where 
  arbitrary = QC.elements [GetProfile_args]
from_GetProfile_args :: GetProfile_args -> T.ThriftVal
from_GetProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfile_args :: T.Protocol p => p -> GetProfile_args -> P.IO ()
write_GetProfile_args oprot record = T.writeVal oprot $ from_GetProfile_args record
encode_GetProfile_args :: T.StatelessProtocol p => p -> GetProfile_args -> LBS.ByteString
encode_GetProfile_args oprot record = T.serializeVal oprot $ from_GetProfile_args record
to_GetProfile_args :: T.ThriftVal -> GetProfile_args
to_GetProfile_args (T.TStruct fields) = GetProfile_args{

  }
to_GetProfile_args _ = P.error "not a struct"
read_GetProfile_args :: T.Protocol p => p -> P.IO GetProfile_args
read_GetProfile_args iprot = to_GetProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfile_args)
decode_GetProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfile_args
decode_GetProfile_args iprot bs = to_GetProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfile_args) bs
typemap_GetProfile_args :: T.TypeMap
typemap_GetProfile_args = Map.fromList []
default_GetProfile_args :: GetProfile_args
default_GetProfile_args = GetProfile_args{
}
data GetProfile_result = GetProfile_result  { getProfile_result_success :: Profile
  , getProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfile_result_success record   `H.hashWithSalt` getProfile_result_e record  
instance QC.Arbitrary GetProfile_result where 
  arbitrary = M.liftM GetProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfile_result{getProfile_result_success = getProfile_result_success obj} then P.Nothing else P.Just $ default_GetProfile_result{getProfile_result_success = getProfile_result_success obj}
    , if obj == default_GetProfile_result{getProfile_result_e = getProfile_result_e obj} then P.Nothing else P.Just $ default_GetProfile_result{getProfile_result_e = getProfile_result_e obj}
    ]
from_GetProfile_result :: GetProfile_result -> T.ThriftVal
from_GetProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7452 -> (1, ("e",from_TalkException _v7452))) <$> getProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7452 -> P.Just (0, ("success",from_Profile _v7452))) $ getProfile_result_success record
    , (\_v7452 -> (1, ("e",from_TalkException _v7452))) <$> getProfile_result_e record
    ]
    )
write_GetProfile_result :: T.Protocol p => p -> GetProfile_result -> P.IO ()
write_GetProfile_result oprot record = T.writeVal oprot $ from_GetProfile_result record
encode_GetProfile_result :: T.StatelessProtocol p => p -> GetProfile_result -> LBS.ByteString
encode_GetProfile_result oprot record = T.serializeVal oprot $ from_GetProfile_result record
to_GetProfile_result :: T.ThriftVal -> GetProfile_result
to_GetProfile_result (T.TStruct fields) = GetProfile_result{
  getProfile_result_success = P.maybe (getProfile_result_success default_GetProfile_result) (\(_,_val7454) -> (case _val7454 of {T.TStruct _val7455 -> (to_Profile (T.TStruct _val7455)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfile_result_e = P.maybe (P.Nothing) (\(_,_val7454) -> P.Just (case _val7454 of {T.TStruct _val7456 -> (to_TalkException (T.TStruct _val7456)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfile_result _ = P.error "not a struct"
read_GetProfile_result :: T.Protocol p => p -> P.IO GetProfile_result
read_GetProfile_result iprot = to_GetProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfile_result)
decode_GetProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfile_result
decode_GetProfile_result iprot bs = to_GetProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfile_result) bs
typemap_GetProfile_result :: T.TypeMap
typemap_GetProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfile_result :: GetProfile_result
default_GetProfile_result = GetProfile_result{
  getProfile_result_success = default_Profile,
  getProfile_result_e = P.Nothing}
data GetProximityMatchCandidateList_args = GetProximityMatchCandidateList_args  { getProximityMatchCandidateList_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidateList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidateList_args_sessionId record  
instance QC.Arbitrary GetProximityMatchCandidateList_args where 
  arbitrary = M.liftM GetProximityMatchCandidateList_args (QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidateList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidateList_args{getProximityMatchCandidateList_args_sessionId = getProximityMatchCandidateList_args_sessionId obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_args{getProximityMatchCandidateList_args_sessionId = getProximityMatchCandidateList_args_sessionId obj}
    ]
from_GetProximityMatchCandidateList_args :: GetProximityMatchCandidateList_args -> T.ThriftVal
from_GetProximityMatchCandidateList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7459 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v7459))) $ getProximityMatchCandidateList_args_sessionId record
  ]
write_GetProximityMatchCandidateList_args :: T.Protocol p => p -> GetProximityMatchCandidateList_args -> P.IO ()
write_GetProximityMatchCandidateList_args oprot record = T.writeVal oprot $ from_GetProximityMatchCandidateList_args record
encode_GetProximityMatchCandidateList_args :: T.StatelessProtocol p => p -> GetProximityMatchCandidateList_args -> LBS.ByteString
encode_GetProximityMatchCandidateList_args oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidateList_args record
to_GetProximityMatchCandidateList_args :: T.ThriftVal -> GetProximityMatchCandidateList_args
to_GetProximityMatchCandidateList_args (T.TStruct fields) = GetProximityMatchCandidateList_args{
  getProximityMatchCandidateList_args_sessionId = P.maybe (getProximityMatchCandidateList_args_sessionId default_GetProximityMatchCandidateList_args) (\(_,_val7461) -> (case _val7461 of {T.TString _val7462 -> E.decodeUtf8 _val7462; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetProximityMatchCandidateList_args _ = P.error "not a struct"
read_GetProximityMatchCandidateList_args :: T.Protocol p => p -> P.IO GetProximityMatchCandidateList_args
read_GetProximityMatchCandidateList_args iprot = to_GetProximityMatchCandidateList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_args)
decode_GetProximityMatchCandidateList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidateList_args
decode_GetProximityMatchCandidateList_args iprot bs = to_GetProximityMatchCandidateList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_args) bs
typemap_GetProximityMatchCandidateList_args :: T.TypeMap
typemap_GetProximityMatchCandidateList_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetProximityMatchCandidateList_args :: GetProximityMatchCandidateList_args
default_GetProximityMatchCandidateList_args = GetProximityMatchCandidateList_args{
  getProximityMatchCandidateList_args_sessionId = ""}
data GetProximityMatchCandidateList_result = GetProximityMatchCandidateList_result  { getProximityMatchCandidateList_result_success :: ProximityMatchCandidateResult
  , getProximityMatchCandidateList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidateList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidateList_result_success record   `H.hashWithSalt` getProximityMatchCandidateList_result_e record  
instance QC.Arbitrary GetProximityMatchCandidateList_result where 
  arbitrary = M.liftM GetProximityMatchCandidateList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidateList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = getProximityMatchCandidateList_result_success obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = getProximityMatchCandidateList_result_success obj}
    , if obj == default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = getProximityMatchCandidateList_result_e obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = getProximityMatchCandidateList_result_e obj}
    ]
from_GetProximityMatchCandidateList_result :: GetProximityMatchCandidateList_result -> T.ThriftVal
from_GetProximityMatchCandidateList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7465 -> (1, ("e",from_TalkException _v7465))) <$> getProximityMatchCandidateList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7465 -> P.Just (0, ("success",from_ProximityMatchCandidateResult _v7465))) $ getProximityMatchCandidateList_result_success record
    , (\_v7465 -> (1, ("e",from_TalkException _v7465))) <$> getProximityMatchCandidateList_result_e record
    ]
    )
write_GetProximityMatchCandidateList_result :: T.Protocol p => p -> GetProximityMatchCandidateList_result -> P.IO ()
write_GetProximityMatchCandidateList_result oprot record = T.writeVal oprot $ from_GetProximityMatchCandidateList_result record
encode_GetProximityMatchCandidateList_result :: T.StatelessProtocol p => p -> GetProximityMatchCandidateList_result -> LBS.ByteString
encode_GetProximityMatchCandidateList_result oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidateList_result record
to_GetProximityMatchCandidateList_result :: T.ThriftVal -> GetProximityMatchCandidateList_result
to_GetProximityMatchCandidateList_result (T.TStruct fields) = GetProximityMatchCandidateList_result{
  getProximityMatchCandidateList_result_success = P.maybe (getProximityMatchCandidateList_result_success default_GetProximityMatchCandidateList_result) (\(_,_val7467) -> (case _val7467 of {T.TStruct _val7468 -> (to_ProximityMatchCandidateResult (T.TStruct _val7468)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProximityMatchCandidateList_result_e = P.maybe (P.Nothing) (\(_,_val7467) -> P.Just (case _val7467 of {T.TStruct _val7469 -> (to_TalkException (T.TStruct _val7469)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProximityMatchCandidateList_result _ = P.error "not a struct"
read_GetProximityMatchCandidateList_result :: T.Protocol p => p -> P.IO GetProximityMatchCandidateList_result
read_GetProximityMatchCandidateList_result iprot = to_GetProximityMatchCandidateList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_result)
decode_GetProximityMatchCandidateList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidateList_result
decode_GetProximityMatchCandidateList_result iprot bs = to_GetProximityMatchCandidateList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidateList_result) bs
typemap_GetProximityMatchCandidateList_result :: T.TypeMap
typemap_GetProximityMatchCandidateList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProximityMatchCandidateResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProximityMatchCandidateList_result :: GetProximityMatchCandidateList_result
default_GetProximityMatchCandidateList_result = GetProximityMatchCandidateList_result{
  getProximityMatchCandidateList_result_success = default_ProximityMatchCandidateResult,
  getProximityMatchCandidateList_result_e = P.Nothing}
data GetProximityMatchCandidates_args = GetProximityMatchCandidates_args  { getProximityMatchCandidates_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidates_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidates_args_sessionId record  
instance QC.Arbitrary GetProximityMatchCandidates_args where 
  arbitrary = M.liftM GetProximityMatchCandidates_args (QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidates_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidates_args{getProximityMatchCandidates_args_sessionId = getProximityMatchCandidates_args_sessionId obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_args{getProximityMatchCandidates_args_sessionId = getProximityMatchCandidates_args_sessionId obj}
    ]
from_GetProximityMatchCandidates_args :: GetProximityMatchCandidates_args -> T.ThriftVal
from_GetProximityMatchCandidates_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7472 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v7472))) $ getProximityMatchCandidates_args_sessionId record
  ]
write_GetProximityMatchCandidates_args :: T.Protocol p => p -> GetProximityMatchCandidates_args -> P.IO ()
write_GetProximityMatchCandidates_args oprot record = T.writeVal oprot $ from_GetProximityMatchCandidates_args record
encode_GetProximityMatchCandidates_args :: T.StatelessProtocol p => p -> GetProximityMatchCandidates_args -> LBS.ByteString
encode_GetProximityMatchCandidates_args oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidates_args record
to_GetProximityMatchCandidates_args :: T.ThriftVal -> GetProximityMatchCandidates_args
to_GetProximityMatchCandidates_args (T.TStruct fields) = GetProximityMatchCandidates_args{
  getProximityMatchCandidates_args_sessionId = P.maybe (getProximityMatchCandidates_args_sessionId default_GetProximityMatchCandidates_args) (\(_,_val7474) -> (case _val7474 of {T.TString _val7475 -> E.decodeUtf8 _val7475; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetProximityMatchCandidates_args _ = P.error "not a struct"
read_GetProximityMatchCandidates_args :: T.Protocol p => p -> P.IO GetProximityMatchCandidates_args
read_GetProximityMatchCandidates_args iprot = to_GetProximityMatchCandidates_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_args)
decode_GetProximityMatchCandidates_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidates_args
decode_GetProximityMatchCandidates_args iprot bs = to_GetProximityMatchCandidates_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_args) bs
typemap_GetProximityMatchCandidates_args :: T.TypeMap
typemap_GetProximityMatchCandidates_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_GetProximityMatchCandidates_args :: GetProximityMatchCandidates_args
default_GetProximityMatchCandidates_args = GetProximityMatchCandidates_args{
  getProximityMatchCandidates_args_sessionId = ""}
data GetProximityMatchCandidates_result = GetProximityMatchCandidates_result  { getProximityMatchCandidates_result_success :: (Set.HashSet Contact)
  , getProximityMatchCandidates_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProximityMatchCandidates_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProximityMatchCandidates_result_success record   `H.hashWithSalt` getProximityMatchCandidates_result_e record  
instance QC.Arbitrary GetProximityMatchCandidates_result where 
  arbitrary = M.liftM GetProximityMatchCandidates_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProximityMatchCandidates_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = getProximityMatchCandidates_result_success obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = getProximityMatchCandidates_result_success obj}
    , if obj == default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = getProximityMatchCandidates_result_e obj} then P.Nothing else P.Just $ default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = getProximityMatchCandidates_result_e obj}
    ]
from_GetProximityMatchCandidates_result :: GetProximityMatchCandidates_result -> T.ThriftVal
from_GetProximityMatchCandidates_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7478 -> (1, ("e",from_TalkException _v7478))) <$> getProximityMatchCandidates_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7478 -> P.Just (0, ("success",T.TSet (T.T_STRUCT typemap_Contact) $ P.map (\_v7480 -> from_Contact _v7480) $ Set.toList _v7478))) $ getProximityMatchCandidates_result_success record
    , (\_v7478 -> (1, ("e",from_TalkException _v7478))) <$> getProximityMatchCandidates_result_e record
    ]
    )
write_GetProximityMatchCandidates_result :: T.Protocol p => p -> GetProximityMatchCandidates_result -> P.IO ()
write_GetProximityMatchCandidates_result oprot record = T.writeVal oprot $ from_GetProximityMatchCandidates_result record
encode_GetProximityMatchCandidates_result :: T.StatelessProtocol p => p -> GetProximityMatchCandidates_result -> LBS.ByteString
encode_GetProximityMatchCandidates_result oprot record = T.serializeVal oprot $ from_GetProximityMatchCandidates_result record
to_GetProximityMatchCandidates_result :: T.ThriftVal -> GetProximityMatchCandidates_result
to_GetProximityMatchCandidates_result (T.TStruct fields) = GetProximityMatchCandidates_result{
  getProximityMatchCandidates_result_success = P.maybe (getProximityMatchCandidates_result_success default_GetProximityMatchCandidates_result) (\(_,_val7482) -> (case _val7482 of {T.TSet _ _val7483 -> (Set.fromList $ P.map (\_v7484 -> (case _v7484 of {T.TStruct _val7485 -> (to_Contact (T.TStruct _val7485)); _ -> P.error "wrong type"})) _val7483); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProximityMatchCandidates_result_e = P.maybe (P.Nothing) (\(_,_val7482) -> P.Just (case _val7482 of {T.TStruct _val7486 -> (to_TalkException (T.TStruct _val7486)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProximityMatchCandidates_result _ = P.error "not a struct"
read_GetProximityMatchCandidates_result :: T.Protocol p => p -> P.IO GetProximityMatchCandidates_result
read_GetProximityMatchCandidates_result iprot = to_GetProximityMatchCandidates_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_result)
decode_GetProximityMatchCandidates_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProximityMatchCandidates_result
decode_GetProximityMatchCandidates_result iprot bs = to_GetProximityMatchCandidates_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProximityMatchCandidates_result) bs
typemap_GetProximityMatchCandidates_result :: T.TypeMap
typemap_GetProximityMatchCandidates_result = Map.fromList [(0,("success",(T.T_SET (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProximityMatchCandidates_result :: GetProximityMatchCandidates_result
default_GetProximityMatchCandidates_result = GetProximityMatchCandidates_result{
  getProximityMatchCandidates_result_success = Set.empty,
  getProximityMatchCandidates_result_e = P.Nothing}
data GetRecentMessages_args = GetRecentMessages_args  { getRecentMessages_args_messageBoxId :: LT.Text
  , getRecentMessages_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessages_args_messageBoxId record   `H.hashWithSalt` getRecentMessages_args_messagesCount record  
instance QC.Arbitrary GetRecentMessages_args where 
  arbitrary = M.liftM GetRecentMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetRecentMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessages_args{getRecentMessages_args_messageBoxId = getRecentMessages_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetRecentMessages_args{getRecentMessages_args_messageBoxId = getRecentMessages_args_messageBoxId obj}
    , if obj == default_GetRecentMessages_args{getRecentMessages_args_messagesCount = getRecentMessages_args_messagesCount obj} then P.Nothing else P.Just $ default_GetRecentMessages_args{getRecentMessages_args_messagesCount = getRecentMessages_args_messagesCount obj}
    ]
from_GetRecentMessages_args :: GetRecentMessages_args -> T.ThriftVal
from_GetRecentMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7489 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v7489))) $ getRecentMessages_args_messageBoxId record
  , (\_v7489 -> P.Just (3, ("messagesCount",T.TI32 _v7489))) $ getRecentMessages_args_messagesCount record
  ]
write_GetRecentMessages_args :: T.Protocol p => p -> GetRecentMessages_args -> P.IO ()
write_GetRecentMessages_args oprot record = T.writeVal oprot $ from_GetRecentMessages_args record
encode_GetRecentMessages_args :: T.StatelessProtocol p => p -> GetRecentMessages_args -> LBS.ByteString
encode_GetRecentMessages_args oprot record = T.serializeVal oprot $ from_GetRecentMessages_args record
to_GetRecentMessages_args :: T.ThriftVal -> GetRecentMessages_args
to_GetRecentMessages_args (T.TStruct fields) = GetRecentMessages_args{
  getRecentMessages_args_messageBoxId = P.maybe (getRecentMessages_args_messageBoxId default_GetRecentMessages_args) (\(_,_val7491) -> (case _val7491 of {T.TString _val7492 -> E.decodeUtf8 _val7492; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getRecentMessages_args_messagesCount = P.maybe (getRecentMessages_args_messagesCount default_GetRecentMessages_args) (\(_,_val7491) -> (case _val7491 of {T.TI32 _val7493 -> _val7493; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetRecentMessages_args _ = P.error "not a struct"
read_GetRecentMessages_args :: T.Protocol p => p -> P.IO GetRecentMessages_args
read_GetRecentMessages_args iprot = to_GetRecentMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessages_args)
decode_GetRecentMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessages_args
decode_GetRecentMessages_args iprot bs = to_GetRecentMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessages_args) bs
typemap_GetRecentMessages_args :: T.TypeMap
typemap_GetRecentMessages_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("messagesCount",T.T_I32))]
default_GetRecentMessages_args :: GetRecentMessages_args
default_GetRecentMessages_args = GetRecentMessages_args{
  getRecentMessages_args_messageBoxId = "",
  getRecentMessages_args_messagesCount = 0}
data GetRecentMessages_result = GetRecentMessages_result  { getRecentMessages_result_success :: (Vector.Vector Message)
  , getRecentMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessages_result_success record   `H.hashWithSalt` getRecentMessages_result_e record  
instance QC.Arbitrary GetRecentMessages_result where 
  arbitrary = M.liftM GetRecentMessages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRecentMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessages_result{getRecentMessages_result_success = getRecentMessages_result_success obj} then P.Nothing else P.Just $ default_GetRecentMessages_result{getRecentMessages_result_success = getRecentMessages_result_success obj}
    , if obj == default_GetRecentMessages_result{getRecentMessages_result_e = getRecentMessages_result_e obj} then P.Nothing else P.Just $ default_GetRecentMessages_result{getRecentMessages_result_e = getRecentMessages_result_e obj}
    ]
from_GetRecentMessages_result :: GetRecentMessages_result -> T.ThriftVal
from_GetRecentMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7496 -> (1, ("e",from_TalkException _v7496))) <$> getRecentMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7496 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v7498 -> from_Message _v7498) $ Vector.toList _v7496))) $ getRecentMessages_result_success record
    , (\_v7496 -> (1, ("e",from_TalkException _v7496))) <$> getRecentMessages_result_e record
    ]
    )
write_GetRecentMessages_result :: T.Protocol p => p -> GetRecentMessages_result -> P.IO ()
write_GetRecentMessages_result oprot record = T.writeVal oprot $ from_GetRecentMessages_result record
encode_GetRecentMessages_result :: T.StatelessProtocol p => p -> GetRecentMessages_result -> LBS.ByteString
encode_GetRecentMessages_result oprot record = T.serializeVal oprot $ from_GetRecentMessages_result record
to_GetRecentMessages_result :: T.ThriftVal -> GetRecentMessages_result
to_GetRecentMessages_result (T.TStruct fields) = GetRecentMessages_result{
  getRecentMessages_result_success = P.maybe (getRecentMessages_result_success default_GetRecentMessages_result) (\(_,_val7500) -> (case _val7500 of {T.TList _ _val7501 -> (Vector.fromList $ P.map (\_v7502 -> (case _v7502 of {T.TStruct _val7503 -> (to_Message (T.TStruct _val7503)); _ -> P.error "wrong type"})) _val7501); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRecentMessages_result_e = P.maybe (P.Nothing) (\(_,_val7500) -> P.Just (case _val7500 of {T.TStruct _val7504 -> (to_TalkException (T.TStruct _val7504)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRecentMessages_result _ = P.error "not a struct"
read_GetRecentMessages_result :: T.Protocol p => p -> P.IO GetRecentMessages_result
read_GetRecentMessages_result iprot = to_GetRecentMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessages_result)
decode_GetRecentMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessages_result
decode_GetRecentMessages_result iprot bs = to_GetRecentMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessages_result) bs
typemap_GetRecentMessages_result :: T.TypeMap
typemap_GetRecentMessages_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRecentMessages_result :: GetRecentMessages_result
default_GetRecentMessages_result = GetRecentMessages_result{
  getRecentMessages_result_success = Vector.empty,
  getRecentMessages_result_e = P.Nothing}
data GetRecommendationIds_args = GetRecommendationIds_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecommendationIds_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetRecommendationIds_args where 
  arbitrary = QC.elements [GetRecommendationIds_args]
from_GetRecommendationIds_args :: GetRecommendationIds_args -> T.ThriftVal
from_GetRecommendationIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetRecommendationIds_args :: T.Protocol p => p -> GetRecommendationIds_args -> P.IO ()
write_GetRecommendationIds_args oprot record = T.writeVal oprot $ from_GetRecommendationIds_args record
encode_GetRecommendationIds_args :: T.StatelessProtocol p => p -> GetRecommendationIds_args -> LBS.ByteString
encode_GetRecommendationIds_args oprot record = T.serializeVal oprot $ from_GetRecommendationIds_args record
to_GetRecommendationIds_args :: T.ThriftVal -> GetRecommendationIds_args
to_GetRecommendationIds_args (T.TStruct fields) = GetRecommendationIds_args{

  }
to_GetRecommendationIds_args _ = P.error "not a struct"
read_GetRecommendationIds_args :: T.Protocol p => p -> P.IO GetRecommendationIds_args
read_GetRecommendationIds_args iprot = to_GetRecommendationIds_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRecommendationIds_args)
decode_GetRecommendationIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecommendationIds_args
decode_GetRecommendationIds_args iprot bs = to_GetRecommendationIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecommendationIds_args) bs
typemap_GetRecommendationIds_args :: T.TypeMap
typemap_GetRecommendationIds_args = Map.fromList []
default_GetRecommendationIds_args :: GetRecommendationIds_args
default_GetRecommendationIds_args = GetRecommendationIds_args{
}
data GetRecommendationIds_result = GetRecommendationIds_result  { getRecommendationIds_result_success :: (Vector.Vector LT.Text)
  , getRecommendationIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecommendationIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecommendationIds_result_success record   `H.hashWithSalt` getRecommendationIds_result_e record  
instance QC.Arbitrary GetRecommendationIds_result where 
  arbitrary = M.liftM GetRecommendationIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRecommendationIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecommendationIds_result{getRecommendationIds_result_success = getRecommendationIds_result_success obj} then P.Nothing else P.Just $ default_GetRecommendationIds_result{getRecommendationIds_result_success = getRecommendationIds_result_success obj}
    , if obj == default_GetRecommendationIds_result{getRecommendationIds_result_e = getRecommendationIds_result_e obj} then P.Nothing else P.Just $ default_GetRecommendationIds_result{getRecommendationIds_result_e = getRecommendationIds_result_e obj}
    ]
from_GetRecommendationIds_result :: GetRecommendationIds_result -> T.ThriftVal
from_GetRecommendationIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7512 -> (1, ("e",from_TalkException _v7512))) <$> getRecommendationIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7512 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v7514 -> T.TString $ E.encodeUtf8 _v7514) $ Vector.toList _v7512))) $ getRecommendationIds_result_success record
    , (\_v7512 -> (1, ("e",from_TalkException _v7512))) <$> getRecommendationIds_result_e record
    ]
    )
write_GetRecommendationIds_result :: T.Protocol p => p -> GetRecommendationIds_result -> P.IO ()
write_GetRecommendationIds_result oprot record = T.writeVal oprot $ from_GetRecommendationIds_result record
encode_GetRecommendationIds_result :: T.StatelessProtocol p => p -> GetRecommendationIds_result -> LBS.ByteString
encode_GetRecommendationIds_result oprot record = T.serializeVal oprot $ from_GetRecommendationIds_result record
to_GetRecommendationIds_result :: T.ThriftVal -> GetRecommendationIds_result
to_GetRecommendationIds_result (T.TStruct fields) = GetRecommendationIds_result{
  getRecommendationIds_result_success = P.maybe (getRecommendationIds_result_success default_GetRecommendationIds_result) (\(_,_val7516) -> (case _val7516 of {T.TList _ _val7517 -> (Vector.fromList $ P.map (\_v7518 -> (case _v7518 of {T.TString _val7519 -> E.decodeUtf8 _val7519; _ -> P.error "wrong type"})) _val7517); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRecommendationIds_result_e = P.maybe (P.Nothing) (\(_,_val7516) -> P.Just (case _val7516 of {T.TStruct _val7520 -> (to_TalkException (T.TStruct _val7520)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRecommendationIds_result _ = P.error "not a struct"
read_GetRecommendationIds_result :: T.Protocol p => p -> P.IO GetRecommendationIds_result
read_GetRecommendationIds_result iprot = to_GetRecommendationIds_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRecommendationIds_result)
decode_GetRecommendationIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecommendationIds_result
decode_GetRecommendationIds_result iprot bs = to_GetRecommendationIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecommendationIds_result) bs
typemap_GetRecommendationIds_result :: T.TypeMap
typemap_GetRecommendationIds_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRecommendationIds_result :: GetRecommendationIds_result
default_GetRecommendationIds_result = GetRecommendationIds_result{
  getRecommendationIds_result_success = Vector.empty,
  getRecommendationIds_result_e = P.Nothing}
data GetRoom_args = GetRoom_args  { getRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoom_args_roomId record  
instance QC.Arbitrary GetRoom_args where 
  arbitrary = M.liftM GetRoom_args (QC.arbitrary)
  shrink obj | obj == default_GetRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoom_args{getRoom_args_roomId = getRoom_args_roomId obj} then P.Nothing else P.Just $ default_GetRoom_args{getRoom_args_roomId = getRoom_args_roomId obj}
    ]
from_GetRoom_args :: GetRoom_args -> T.ThriftVal
from_GetRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7523 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v7523))) $ getRoom_args_roomId record
  ]
write_GetRoom_args :: T.Protocol p => p -> GetRoom_args -> P.IO ()
write_GetRoom_args oprot record = T.writeVal oprot $ from_GetRoom_args record
encode_GetRoom_args :: T.StatelessProtocol p => p -> GetRoom_args -> LBS.ByteString
encode_GetRoom_args oprot record = T.serializeVal oprot $ from_GetRoom_args record
to_GetRoom_args :: T.ThriftVal -> GetRoom_args
to_GetRoom_args (T.TStruct fields) = GetRoom_args{
  getRoom_args_roomId = P.maybe (getRoom_args_roomId default_GetRoom_args) (\(_,_val7525) -> (case _val7525 of {T.TString _val7526 -> E.decodeUtf8 _val7526; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetRoom_args _ = P.error "not a struct"
read_GetRoom_args :: T.Protocol p => p -> P.IO GetRoom_args
read_GetRoom_args iprot = to_GetRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoom_args)
decode_GetRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoom_args
decode_GetRoom_args iprot bs = to_GetRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoom_args) bs
typemap_GetRoom_args :: T.TypeMap
typemap_GetRoom_args = Map.fromList [(2,("roomId",T.T_STRING))]
default_GetRoom_args :: GetRoom_args
default_GetRoom_args = GetRoom_args{
  getRoom_args_roomId = ""}
data GetRoom_result = GetRoom_result  { getRoom_result_success :: Room
  , getRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoom_result_success record   `H.hashWithSalt` getRoom_result_e record  
instance QC.Arbitrary GetRoom_result where 
  arbitrary = M.liftM GetRoom_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoom_result{getRoom_result_success = getRoom_result_success obj} then P.Nothing else P.Just $ default_GetRoom_result{getRoom_result_success = getRoom_result_success obj}
    , if obj == default_GetRoom_result{getRoom_result_e = getRoom_result_e obj} then P.Nothing else P.Just $ default_GetRoom_result{getRoom_result_e = getRoom_result_e obj}
    ]
from_GetRoom_result :: GetRoom_result -> T.ThriftVal
from_GetRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7529 -> (1, ("e",from_TalkException _v7529))) <$> getRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7529 -> P.Just (0, ("success",from_Room _v7529))) $ getRoom_result_success record
    , (\_v7529 -> (1, ("e",from_TalkException _v7529))) <$> getRoom_result_e record
    ]
    )
write_GetRoom_result :: T.Protocol p => p -> GetRoom_result -> P.IO ()
write_GetRoom_result oprot record = T.writeVal oprot $ from_GetRoom_result record
encode_GetRoom_result :: T.StatelessProtocol p => p -> GetRoom_result -> LBS.ByteString
encode_GetRoom_result oprot record = T.serializeVal oprot $ from_GetRoom_result record
to_GetRoom_result :: T.ThriftVal -> GetRoom_result
to_GetRoom_result (T.TStruct fields) = GetRoom_result{
  getRoom_result_success = P.maybe (getRoom_result_success default_GetRoom_result) (\(_,_val7531) -> (case _val7531 of {T.TStruct _val7532 -> (to_Room (T.TStruct _val7532)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoom_result_e = P.maybe (P.Nothing) (\(_,_val7531) -> P.Just (case _val7531 of {T.TStruct _val7533 -> (to_TalkException (T.TStruct _val7533)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoom_result _ = P.error "not a struct"
read_GetRoom_result :: T.Protocol p => p -> P.IO GetRoom_result
read_GetRoom_result iprot = to_GetRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoom_result)
decode_GetRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoom_result
decode_GetRoom_result iprot bs = to_GetRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoom_result) bs
typemap_GetRoom_result :: T.TypeMap
typemap_GetRoom_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoom_result :: GetRoom_result
default_GetRoom_result = GetRoom_result{
  getRoom_result_success = default_Room,
  getRoom_result_e = P.Nothing}
data GetRSAKeyInfo_args = GetRSAKeyInfo_args  { getRSAKeyInfo_args_provider :: IdentityProvider
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKeyInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRSAKeyInfo_args_provider record  
instance QC.Arbitrary GetRSAKeyInfo_args where 
  arbitrary = M.liftM GetRSAKeyInfo_args (QC.arbitrary)
  shrink obj | obj == default_GetRSAKeyInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRSAKeyInfo_args{getRSAKeyInfo_args_provider = getRSAKeyInfo_args_provider obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_args{getRSAKeyInfo_args_provider = getRSAKeyInfo_args_provider obj}
    ]
from_GetRSAKeyInfo_args :: GetRSAKeyInfo_args -> T.ThriftVal
from_GetRSAKeyInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7536 -> P.Just (2, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v7536))) $ getRSAKeyInfo_args_provider record
  ]
write_GetRSAKeyInfo_args :: T.Protocol p => p -> GetRSAKeyInfo_args -> P.IO ()
write_GetRSAKeyInfo_args oprot record = T.writeVal oprot $ from_GetRSAKeyInfo_args record
encode_GetRSAKeyInfo_args :: T.StatelessProtocol p => p -> GetRSAKeyInfo_args -> LBS.ByteString
encode_GetRSAKeyInfo_args oprot record = T.serializeVal oprot $ from_GetRSAKeyInfo_args record
to_GetRSAKeyInfo_args :: T.ThriftVal -> GetRSAKeyInfo_args
to_GetRSAKeyInfo_args (T.TStruct fields) = GetRSAKeyInfo_args{
  getRSAKeyInfo_args_provider = P.maybe (getRSAKeyInfo_args_provider default_GetRSAKeyInfo_args) (\(_,_val7538) -> (case _val7538 of {T.TI32 _val7539 -> P.toEnum $ P.fromIntegral _val7539; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetRSAKeyInfo_args _ = P.error "not a struct"
read_GetRSAKeyInfo_args :: T.Protocol p => p -> P.IO GetRSAKeyInfo_args
read_GetRSAKeyInfo_args iprot = to_GetRSAKeyInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_args)
decode_GetRSAKeyInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKeyInfo_args
decode_GetRSAKeyInfo_args iprot bs = to_GetRSAKeyInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_args) bs
typemap_GetRSAKeyInfo_args :: T.TypeMap
typemap_GetRSAKeyInfo_args = Map.fromList [(2,("provider",T.T_I32))]
default_GetRSAKeyInfo_args :: GetRSAKeyInfo_args
default_GetRSAKeyInfo_args = GetRSAKeyInfo_args{
  getRSAKeyInfo_args_provider = (P.toEnum 0)}
data GetRSAKeyInfo_result = GetRSAKeyInfo_result  { getRSAKeyInfo_result_success :: RSAKey
  , getRSAKeyInfo_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRSAKeyInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRSAKeyInfo_result_success record   `H.hashWithSalt` getRSAKeyInfo_result_e record  
instance QC.Arbitrary GetRSAKeyInfo_result where 
  arbitrary = M.liftM GetRSAKeyInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRSAKeyInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = getRSAKeyInfo_result_success obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = getRSAKeyInfo_result_success obj}
    , if obj == default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = getRSAKeyInfo_result_e obj} then P.Nothing else P.Just $ default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = getRSAKeyInfo_result_e obj}
    ]
from_GetRSAKeyInfo_result :: GetRSAKeyInfo_result -> T.ThriftVal
from_GetRSAKeyInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7542 -> (1, ("e",from_TalkException _v7542))) <$> getRSAKeyInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7542 -> P.Just (0, ("success",from_RSAKey _v7542))) $ getRSAKeyInfo_result_success record
    , (\_v7542 -> (1, ("e",from_TalkException _v7542))) <$> getRSAKeyInfo_result_e record
    ]
    )
write_GetRSAKeyInfo_result :: T.Protocol p => p -> GetRSAKeyInfo_result -> P.IO ()
write_GetRSAKeyInfo_result oprot record = T.writeVal oprot $ from_GetRSAKeyInfo_result record
encode_GetRSAKeyInfo_result :: T.StatelessProtocol p => p -> GetRSAKeyInfo_result -> LBS.ByteString
encode_GetRSAKeyInfo_result oprot record = T.serializeVal oprot $ from_GetRSAKeyInfo_result record
to_GetRSAKeyInfo_result :: T.ThriftVal -> GetRSAKeyInfo_result
to_GetRSAKeyInfo_result (T.TStruct fields) = GetRSAKeyInfo_result{
  getRSAKeyInfo_result_success = P.maybe (getRSAKeyInfo_result_success default_GetRSAKeyInfo_result) (\(_,_val7544) -> (case _val7544 of {T.TStruct _val7545 -> (to_RSAKey (T.TStruct _val7545)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRSAKeyInfo_result_e = P.maybe (P.Nothing) (\(_,_val7544) -> P.Just (case _val7544 of {T.TStruct _val7546 -> (to_TalkException (T.TStruct _val7546)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRSAKeyInfo_result _ = P.error "not a struct"
read_GetRSAKeyInfo_result :: T.Protocol p => p -> P.IO GetRSAKeyInfo_result
read_GetRSAKeyInfo_result iprot = to_GetRSAKeyInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_result)
decode_GetRSAKeyInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRSAKeyInfo_result
decode_GetRSAKeyInfo_result iprot bs = to_GetRSAKeyInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRSAKeyInfo_result) bs
typemap_GetRSAKeyInfo_result :: T.TypeMap
typemap_GetRSAKeyInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RSAKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRSAKeyInfo_result :: GetRSAKeyInfo_result
default_GetRSAKeyInfo_result = GetRSAKeyInfo_result{
  getRSAKeyInfo_result_success = default_RSAKey,
  getRSAKeyInfo_result_e = P.Nothing}
data GetServerTime_args = GetServerTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetServerTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetServerTime_args where 
  arbitrary = QC.elements [GetServerTime_args]
from_GetServerTime_args :: GetServerTime_args -> T.ThriftVal
from_GetServerTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetServerTime_args :: T.Protocol p => p -> GetServerTime_args -> P.IO ()
write_GetServerTime_args oprot record = T.writeVal oprot $ from_GetServerTime_args record
encode_GetServerTime_args :: T.StatelessProtocol p => p -> GetServerTime_args -> LBS.ByteString
encode_GetServerTime_args oprot record = T.serializeVal oprot $ from_GetServerTime_args record
to_GetServerTime_args :: T.ThriftVal -> GetServerTime_args
to_GetServerTime_args (T.TStruct fields) = GetServerTime_args{

  }
to_GetServerTime_args _ = P.error "not a struct"
read_GetServerTime_args :: T.Protocol p => p -> P.IO GetServerTime_args
read_GetServerTime_args iprot = to_GetServerTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetServerTime_args)
decode_GetServerTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetServerTime_args
decode_GetServerTime_args iprot bs = to_GetServerTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetServerTime_args) bs
typemap_GetServerTime_args :: T.TypeMap
typemap_GetServerTime_args = Map.fromList []
default_GetServerTime_args :: GetServerTime_args
default_GetServerTime_args = GetServerTime_args{
}
data GetServerTime_result = GetServerTime_result  { getServerTime_result_success :: I.Int64
  , getServerTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetServerTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getServerTime_result_success record   `H.hashWithSalt` getServerTime_result_e record  
instance QC.Arbitrary GetServerTime_result where 
  arbitrary = M.liftM GetServerTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetServerTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetServerTime_result{getServerTime_result_success = getServerTime_result_success obj} then P.Nothing else P.Just $ default_GetServerTime_result{getServerTime_result_success = getServerTime_result_success obj}
    , if obj == default_GetServerTime_result{getServerTime_result_e = getServerTime_result_e obj} then P.Nothing else P.Just $ default_GetServerTime_result{getServerTime_result_e = getServerTime_result_e obj}
    ]
from_GetServerTime_result :: GetServerTime_result -> T.ThriftVal
from_GetServerTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7554 -> (1, ("e",from_TalkException _v7554))) <$> getServerTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7554 -> P.Just (0, ("success",T.TI64 _v7554))) $ getServerTime_result_success record
    , (\_v7554 -> (1, ("e",from_TalkException _v7554))) <$> getServerTime_result_e record
    ]
    )
write_GetServerTime_result :: T.Protocol p => p -> GetServerTime_result -> P.IO ()
write_GetServerTime_result oprot record = T.writeVal oprot $ from_GetServerTime_result record
encode_GetServerTime_result :: T.StatelessProtocol p => p -> GetServerTime_result -> LBS.ByteString
encode_GetServerTime_result oprot record = T.serializeVal oprot $ from_GetServerTime_result record
to_GetServerTime_result :: T.ThriftVal -> GetServerTime_result
to_GetServerTime_result (T.TStruct fields) = GetServerTime_result{
  getServerTime_result_success = P.maybe (getServerTime_result_success default_GetServerTime_result) (\(_,_val7556) -> (case _val7556 of {T.TI64 _val7557 -> _val7557; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getServerTime_result_e = P.maybe (P.Nothing) (\(_,_val7556) -> P.Just (case _val7556 of {T.TStruct _val7558 -> (to_TalkException (T.TStruct _val7558)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetServerTime_result _ = P.error "not a struct"
read_GetServerTime_result :: T.Protocol p => p -> P.IO GetServerTime_result
read_GetServerTime_result iprot = to_GetServerTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetServerTime_result)
decode_GetServerTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetServerTime_result
decode_GetServerTime_result iprot bs = to_GetServerTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetServerTime_result) bs
typemap_GetServerTime_result :: T.TypeMap
typemap_GetServerTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetServerTime_result :: GetServerTime_result
default_GetServerTime_result = GetServerTime_result{
  getServerTime_result_success = 0,
  getServerTime_result_e = P.Nothing}
data GetSessions_args = GetSessions_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSessions_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSessions_args where 
  arbitrary = QC.elements [GetSessions_args]
from_GetSessions_args :: GetSessions_args -> T.ThriftVal
from_GetSessions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSessions_args :: T.Protocol p => p -> GetSessions_args -> P.IO ()
write_GetSessions_args oprot record = T.writeVal oprot $ from_GetSessions_args record
encode_GetSessions_args :: T.StatelessProtocol p => p -> GetSessions_args -> LBS.ByteString
encode_GetSessions_args oprot record = T.serializeVal oprot $ from_GetSessions_args record
to_GetSessions_args :: T.ThriftVal -> GetSessions_args
to_GetSessions_args (T.TStruct fields) = GetSessions_args{

  }
to_GetSessions_args _ = P.error "not a struct"
read_GetSessions_args :: T.Protocol p => p -> P.IO GetSessions_args
read_GetSessions_args iprot = to_GetSessions_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSessions_args)
decode_GetSessions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSessions_args
decode_GetSessions_args iprot bs = to_GetSessions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSessions_args) bs
typemap_GetSessions_args :: T.TypeMap
typemap_GetSessions_args = Map.fromList []
default_GetSessions_args :: GetSessions_args
default_GetSessions_args = GetSessions_args{
}
data GetSessions_result = GetSessions_result  { getSessions_result_success :: (Vector.Vector LoginSession)
  , getSessions_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSessions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSessions_result_success record   `H.hashWithSalt` getSessions_result_e record  
instance QC.Arbitrary GetSessions_result where 
  arbitrary = M.liftM GetSessions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSessions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSessions_result{getSessions_result_success = getSessions_result_success obj} then P.Nothing else P.Just $ default_GetSessions_result{getSessions_result_success = getSessions_result_success obj}
    , if obj == default_GetSessions_result{getSessions_result_e = getSessions_result_e obj} then P.Nothing else P.Just $ default_GetSessions_result{getSessions_result_e = getSessions_result_e obj}
    ]
from_GetSessions_result :: GetSessions_result -> T.ThriftVal
from_GetSessions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7566 -> (1, ("e",from_TalkException _v7566))) <$> getSessions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7566 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_LoginSession) $ P.map (\_v7568 -> from_LoginSession _v7568) $ Vector.toList _v7566))) $ getSessions_result_success record
    , (\_v7566 -> (1, ("e",from_TalkException _v7566))) <$> getSessions_result_e record
    ]
    )
write_GetSessions_result :: T.Protocol p => p -> GetSessions_result -> P.IO ()
write_GetSessions_result oprot record = T.writeVal oprot $ from_GetSessions_result record
encode_GetSessions_result :: T.StatelessProtocol p => p -> GetSessions_result -> LBS.ByteString
encode_GetSessions_result oprot record = T.serializeVal oprot $ from_GetSessions_result record
to_GetSessions_result :: T.ThriftVal -> GetSessions_result
to_GetSessions_result (T.TStruct fields) = GetSessions_result{
  getSessions_result_success = P.maybe (getSessions_result_success default_GetSessions_result) (\(_,_val7570) -> (case _val7570 of {T.TList _ _val7571 -> (Vector.fromList $ P.map (\_v7572 -> (case _v7572 of {T.TStruct _val7573 -> (to_LoginSession (T.TStruct _val7573)); _ -> P.error "wrong type"})) _val7571); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSessions_result_e = P.maybe (P.Nothing) (\(_,_val7570) -> P.Just (case _val7570 of {T.TStruct _val7574 -> (to_TalkException (T.TStruct _val7574)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSessions_result _ = P.error "not a struct"
read_GetSessions_result :: T.Protocol p => p -> P.IO GetSessions_result
read_GetSessions_result iprot = to_GetSessions_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSessions_result)
decode_GetSessions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSessions_result
decode_GetSessions_result iprot bs = to_GetSessions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSessions_result) bs
typemap_GetSessions_result :: T.TypeMap
typemap_GetSessions_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_LoginSession)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSessions_result :: GetSessions_result
default_GetSessions_result = GetSessions_result{
  getSessions_result_success = Vector.empty,
  getSessions_result_e = P.Nothing}
data GetSettings_args = GetSettings_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettings_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSettings_args where 
  arbitrary = QC.elements [GetSettings_args]
from_GetSettings_args :: GetSettings_args -> T.ThriftVal
from_GetSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSettings_args :: T.Protocol p => p -> GetSettings_args -> P.IO ()
write_GetSettings_args oprot record = T.writeVal oprot $ from_GetSettings_args record
encode_GetSettings_args :: T.StatelessProtocol p => p -> GetSettings_args -> LBS.ByteString
encode_GetSettings_args oprot record = T.serializeVal oprot $ from_GetSettings_args record
to_GetSettings_args :: T.ThriftVal -> GetSettings_args
to_GetSettings_args (T.TStruct fields) = GetSettings_args{

  }
to_GetSettings_args _ = P.error "not a struct"
read_GetSettings_args :: T.Protocol p => p -> P.IO GetSettings_args
read_GetSettings_args iprot = to_GetSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSettings_args)
decode_GetSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettings_args
decode_GetSettings_args iprot bs = to_GetSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettings_args) bs
typemap_GetSettings_args :: T.TypeMap
typemap_GetSettings_args = Map.fromList []
default_GetSettings_args :: GetSettings_args
default_GetSettings_args = GetSettings_args{
}
data GetSettings_result = GetSettings_result  { getSettings_result_success :: Settings
  , getSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettings_result_success record   `H.hashWithSalt` getSettings_result_e record  
instance QC.Arbitrary GetSettings_result where 
  arbitrary = M.liftM GetSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettings_result{getSettings_result_success = getSettings_result_success obj} then P.Nothing else P.Just $ default_GetSettings_result{getSettings_result_success = getSettings_result_success obj}
    , if obj == default_GetSettings_result{getSettings_result_e = getSettings_result_e obj} then P.Nothing else P.Just $ default_GetSettings_result{getSettings_result_e = getSettings_result_e obj}
    ]
from_GetSettings_result :: GetSettings_result -> T.ThriftVal
from_GetSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7582 -> (1, ("e",from_TalkException _v7582))) <$> getSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7582 -> P.Just (0, ("success",from_Settings _v7582))) $ getSettings_result_success record
    , (\_v7582 -> (1, ("e",from_TalkException _v7582))) <$> getSettings_result_e record
    ]
    )
write_GetSettings_result :: T.Protocol p => p -> GetSettings_result -> P.IO ()
write_GetSettings_result oprot record = T.writeVal oprot $ from_GetSettings_result record
encode_GetSettings_result :: T.StatelessProtocol p => p -> GetSettings_result -> LBS.ByteString
encode_GetSettings_result oprot record = T.serializeVal oprot $ from_GetSettings_result record
to_GetSettings_result :: T.ThriftVal -> GetSettings_result
to_GetSettings_result (T.TStruct fields) = GetSettings_result{
  getSettings_result_success = P.maybe (getSettings_result_success default_GetSettings_result) (\(_,_val7584) -> (case _val7584 of {T.TStruct _val7585 -> (to_Settings (T.TStruct _val7585)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSettings_result_e = P.maybe (P.Nothing) (\(_,_val7584) -> P.Just (case _val7584 of {T.TStruct _val7586 -> (to_TalkException (T.TStruct _val7586)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSettings_result _ = P.error "not a struct"
read_GetSettings_result :: T.Protocol p => p -> P.IO GetSettings_result
read_GetSettings_result iprot = to_GetSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSettings_result)
decode_GetSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettings_result
decode_GetSettings_result iprot bs = to_GetSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettings_result) bs
typemap_GetSettings_result :: T.TypeMap
typemap_GetSettings_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Settings))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSettings_result :: GetSettings_result
default_GetSettings_result = GetSettings_result{
  getSettings_result_success = default_Settings,
  getSettings_result_e = P.Nothing}
data GetGroupsV2_args = GetGroupsV2_args  { getGroupsV2_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsV2_args_groupIds record  
instance QC.Arbitrary GetGroupsV2_args where 
  arbitrary = M.liftM GetGroupsV2_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupsV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsV2_args{getGroupsV2_args_groupIds = getGroupsV2_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroupsV2_args{getGroupsV2_args_groupIds = getGroupsV2_args_groupIds obj}
    ]
from_GetGroupsV2_args :: GetGroupsV2_args -> T.ThriftVal
from_GetGroupsV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7589 -> P.Just (2, ("groupIds",T.TList T.T_STRING $ P.map (\_v7591 -> T.TString $ E.encodeUtf8 _v7591) $ Vector.toList _v7589))) $ getGroupsV2_args_groupIds record
  ]
write_GetGroupsV2_args :: T.Protocol p => p -> GetGroupsV2_args -> P.IO ()
write_GetGroupsV2_args oprot record = T.writeVal oprot $ from_GetGroupsV2_args record
encode_GetGroupsV2_args :: T.StatelessProtocol p => p -> GetGroupsV2_args -> LBS.ByteString
encode_GetGroupsV2_args oprot record = T.serializeVal oprot $ from_GetGroupsV2_args record
to_GetGroupsV2_args :: T.ThriftVal -> GetGroupsV2_args
to_GetGroupsV2_args (T.TStruct fields) = GetGroupsV2_args{
  getGroupsV2_args_groupIds = P.maybe (getGroupsV2_args_groupIds default_GetGroupsV2_args) (\(_,_val7593) -> (case _val7593 of {T.TList _ _val7594 -> (Vector.fromList $ P.map (\_v7595 -> (case _v7595 of {T.TString _val7596 -> E.decodeUtf8 _val7596; _ -> P.error "wrong type"})) _val7594); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroupsV2_args _ = P.error "not a struct"
read_GetGroupsV2_args :: T.Protocol p => p -> P.IO GetGroupsV2_args
read_GetGroupsV2_args iprot = to_GetGroupsV2_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsV2_args)
decode_GetGroupsV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsV2_args
decode_GetGroupsV2_args iprot bs = to_GetGroupsV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsV2_args) bs
typemap_GetGroupsV2_args :: T.TypeMap
typemap_GetGroupsV2_args = Map.fromList [(2,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroupsV2_args :: GetGroupsV2_args
default_GetGroupsV2_args = GetGroupsV2_args{
  getGroupsV2_args_groupIds = Vector.empty}
data GetGroupsV2_result = GetGroupsV2_result  { getGroupsV2_result_success :: (Vector.Vector Group)
  , getGroupsV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsV2_result_success record   `H.hashWithSalt` getGroupsV2_result_e record  
instance QC.Arbitrary GetGroupsV2_result where 
  arbitrary = M.liftM GetGroupsV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupsV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsV2_result{getGroupsV2_result_success = getGroupsV2_result_success obj} then P.Nothing else P.Just $ default_GetGroupsV2_result{getGroupsV2_result_success = getGroupsV2_result_success obj}
    , if obj == default_GetGroupsV2_result{getGroupsV2_result_e = getGroupsV2_result_e obj} then P.Nothing else P.Just $ default_GetGroupsV2_result{getGroupsV2_result_e = getGroupsV2_result_e obj}
    ]
from_GetGroupsV2_result :: GetGroupsV2_result -> T.ThriftVal
from_GetGroupsV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7599 -> (1, ("e",from_TalkException _v7599))) <$> getGroupsV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7599 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v7601 -> from_Group _v7601) $ Vector.toList _v7599))) $ getGroupsV2_result_success record
    , (\_v7599 -> (1, ("e",from_TalkException _v7599))) <$> getGroupsV2_result_e record
    ]
    )
write_GetGroupsV2_result :: T.Protocol p => p -> GetGroupsV2_result -> P.IO ()
write_GetGroupsV2_result oprot record = T.writeVal oprot $ from_GetGroupsV2_result record
encode_GetGroupsV2_result :: T.StatelessProtocol p => p -> GetGroupsV2_result -> LBS.ByteString
encode_GetGroupsV2_result oprot record = T.serializeVal oprot $ from_GetGroupsV2_result record
to_GetGroupsV2_result :: T.ThriftVal -> GetGroupsV2_result
to_GetGroupsV2_result (T.TStruct fields) = GetGroupsV2_result{
  getGroupsV2_result_success = P.maybe (getGroupsV2_result_success default_GetGroupsV2_result) (\(_,_val7603) -> (case _val7603 of {T.TList _ _val7604 -> (Vector.fromList $ P.map (\_v7605 -> (case _v7605 of {T.TStruct _val7606 -> (to_Group (T.TStruct _val7606)); _ -> P.error "wrong type"})) _val7604); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupsV2_result_e = P.maybe (P.Nothing) (\(_,_val7603) -> P.Just (case _val7603 of {T.TStruct _val7607 -> (to_TalkException (T.TStruct _val7607)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsV2_result _ = P.error "not a struct"
read_GetGroupsV2_result :: T.Protocol p => p -> P.IO GetGroupsV2_result
read_GetGroupsV2_result iprot = to_GetGroupsV2_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsV2_result)
decode_GetGroupsV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsV2_result
decode_GetGroupsV2_result iprot bs = to_GetGroupsV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsV2_result) bs
typemap_GetGroupsV2_result :: T.TypeMap
typemap_GetGroupsV2_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupsV2_result :: GetGroupsV2_result
default_GetGroupsV2_result = GetGroupsV2_result{
  getGroupsV2_result_success = Vector.empty,
  getGroupsV2_result_e = P.Nothing}
data GetSettingsAttributes_args = GetSettingsAttributes_args  { getSettingsAttributes_args_attrBitset :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettingsAttributes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettingsAttributes_args_attrBitset record  
instance QC.Arbitrary GetSettingsAttributes_args where 
  arbitrary = M.liftM GetSettingsAttributes_args (QC.arbitrary)
  shrink obj | obj == default_GetSettingsAttributes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettingsAttributes_args{getSettingsAttributes_args_attrBitset = getSettingsAttributes_args_attrBitset obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_args{getSettingsAttributes_args_attrBitset = getSettingsAttributes_args_attrBitset obj}
    ]
from_GetSettingsAttributes_args :: GetSettingsAttributes_args -> T.ThriftVal
from_GetSettingsAttributes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7610 -> P.Just (2, ("attrBitset",T.TI32 _v7610))) $ getSettingsAttributes_args_attrBitset record
  ]
write_GetSettingsAttributes_args :: T.Protocol p => p -> GetSettingsAttributes_args -> P.IO ()
write_GetSettingsAttributes_args oprot record = T.writeVal oprot $ from_GetSettingsAttributes_args record
encode_GetSettingsAttributes_args :: T.StatelessProtocol p => p -> GetSettingsAttributes_args -> LBS.ByteString
encode_GetSettingsAttributes_args oprot record = T.serializeVal oprot $ from_GetSettingsAttributes_args record
to_GetSettingsAttributes_args :: T.ThriftVal -> GetSettingsAttributes_args
to_GetSettingsAttributes_args (T.TStruct fields) = GetSettingsAttributes_args{
  getSettingsAttributes_args_attrBitset = P.maybe (getSettingsAttributes_args_attrBitset default_GetSettingsAttributes_args) (\(_,_val7612) -> (case _val7612 of {T.TI32 _val7613 -> _val7613; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSettingsAttributes_args _ = P.error "not a struct"
read_GetSettingsAttributes_args :: T.Protocol p => p -> P.IO GetSettingsAttributes_args
read_GetSettingsAttributes_args iprot = to_GetSettingsAttributes_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_args)
decode_GetSettingsAttributes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettingsAttributes_args
decode_GetSettingsAttributes_args iprot bs = to_GetSettingsAttributes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_args) bs
typemap_GetSettingsAttributes_args :: T.TypeMap
typemap_GetSettingsAttributes_args = Map.fromList [(2,("attrBitset",T.T_I32))]
default_GetSettingsAttributes_args :: GetSettingsAttributes_args
default_GetSettingsAttributes_args = GetSettingsAttributes_args{
  getSettingsAttributes_args_attrBitset = 0}
data GetSettingsAttributes_result = GetSettingsAttributes_result  { getSettingsAttributes_result_success :: Settings
  , getSettingsAttributes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSettingsAttributes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSettingsAttributes_result_success record   `H.hashWithSalt` getSettingsAttributes_result_e record  
instance QC.Arbitrary GetSettingsAttributes_result where 
  arbitrary = M.liftM GetSettingsAttributes_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSettingsAttributes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSettingsAttributes_result{getSettingsAttributes_result_success = getSettingsAttributes_result_success obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_result{getSettingsAttributes_result_success = getSettingsAttributes_result_success obj}
    , if obj == default_GetSettingsAttributes_result{getSettingsAttributes_result_e = getSettingsAttributes_result_e obj} then P.Nothing else P.Just $ default_GetSettingsAttributes_result{getSettingsAttributes_result_e = getSettingsAttributes_result_e obj}
    ]
from_GetSettingsAttributes_result :: GetSettingsAttributes_result -> T.ThriftVal
from_GetSettingsAttributes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7616 -> (1, ("e",from_TalkException _v7616))) <$> getSettingsAttributes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7616 -> P.Just (0, ("success",from_Settings _v7616))) $ getSettingsAttributes_result_success record
    , (\_v7616 -> (1, ("e",from_TalkException _v7616))) <$> getSettingsAttributes_result_e record
    ]
    )
write_GetSettingsAttributes_result :: T.Protocol p => p -> GetSettingsAttributes_result -> P.IO ()
write_GetSettingsAttributes_result oprot record = T.writeVal oprot $ from_GetSettingsAttributes_result record
encode_GetSettingsAttributes_result :: T.StatelessProtocol p => p -> GetSettingsAttributes_result -> LBS.ByteString
encode_GetSettingsAttributes_result oprot record = T.serializeVal oprot $ from_GetSettingsAttributes_result record
to_GetSettingsAttributes_result :: T.ThriftVal -> GetSettingsAttributes_result
to_GetSettingsAttributes_result (T.TStruct fields) = GetSettingsAttributes_result{
  getSettingsAttributes_result_success = P.maybe (getSettingsAttributes_result_success default_GetSettingsAttributes_result) (\(_,_val7618) -> (case _val7618 of {T.TStruct _val7619 -> (to_Settings (T.TStruct _val7619)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSettingsAttributes_result_e = P.maybe (P.Nothing) (\(_,_val7618) -> P.Just (case _val7618 of {T.TStruct _val7620 -> (to_TalkException (T.TStruct _val7620)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSettingsAttributes_result _ = P.error "not a struct"
read_GetSettingsAttributes_result :: T.Protocol p => p -> P.IO GetSettingsAttributes_result
read_GetSettingsAttributes_result iprot = to_GetSettingsAttributes_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_result)
decode_GetSettingsAttributes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSettingsAttributes_result
decode_GetSettingsAttributes_result iprot bs = to_GetSettingsAttributes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSettingsAttributes_result) bs
typemap_GetSettingsAttributes_result :: T.TypeMap
typemap_GetSettingsAttributes_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Settings))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSettingsAttributes_result :: GetSettingsAttributes_result
default_GetSettingsAttributes_result = GetSettingsAttributes_result{
  getSettingsAttributes_result_success = default_Settings,
  getSettingsAttributes_result_e = P.Nothing}
data GetSystemConfiguration_args = GetSystemConfiguration_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSystemConfiguration_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetSystemConfiguration_args where 
  arbitrary = QC.elements [GetSystemConfiguration_args]
from_GetSystemConfiguration_args :: GetSystemConfiguration_args -> T.ThriftVal
from_GetSystemConfiguration_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetSystemConfiguration_args :: T.Protocol p => p -> GetSystemConfiguration_args -> P.IO ()
write_GetSystemConfiguration_args oprot record = T.writeVal oprot $ from_GetSystemConfiguration_args record
encode_GetSystemConfiguration_args :: T.StatelessProtocol p => p -> GetSystemConfiguration_args -> LBS.ByteString
encode_GetSystemConfiguration_args oprot record = T.serializeVal oprot $ from_GetSystemConfiguration_args record
to_GetSystemConfiguration_args :: T.ThriftVal -> GetSystemConfiguration_args
to_GetSystemConfiguration_args (T.TStruct fields) = GetSystemConfiguration_args{

  }
to_GetSystemConfiguration_args _ = P.error "not a struct"
read_GetSystemConfiguration_args :: T.Protocol p => p -> P.IO GetSystemConfiguration_args
read_GetSystemConfiguration_args iprot = to_GetSystemConfiguration_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_args)
decode_GetSystemConfiguration_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSystemConfiguration_args
decode_GetSystemConfiguration_args iprot bs = to_GetSystemConfiguration_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_args) bs
typemap_GetSystemConfiguration_args :: T.TypeMap
typemap_GetSystemConfiguration_args = Map.fromList []
default_GetSystemConfiguration_args :: GetSystemConfiguration_args
default_GetSystemConfiguration_args = GetSystemConfiguration_args{
}
data GetSystemConfiguration_result = GetSystemConfiguration_result  { getSystemConfiguration_result_success :: SystemConfiguration
  , getSystemConfiguration_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSystemConfiguration_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSystemConfiguration_result_success record   `H.hashWithSalt` getSystemConfiguration_result_e record  
instance QC.Arbitrary GetSystemConfiguration_result where 
  arbitrary = M.liftM GetSystemConfiguration_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSystemConfiguration_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSystemConfiguration_result{getSystemConfiguration_result_success = getSystemConfiguration_result_success obj} then P.Nothing else P.Just $ default_GetSystemConfiguration_result{getSystemConfiguration_result_success = getSystemConfiguration_result_success obj}
    , if obj == default_GetSystemConfiguration_result{getSystemConfiguration_result_e = getSystemConfiguration_result_e obj} then P.Nothing else P.Just $ default_GetSystemConfiguration_result{getSystemConfiguration_result_e = getSystemConfiguration_result_e obj}
    ]
from_GetSystemConfiguration_result :: GetSystemConfiguration_result -> T.ThriftVal
from_GetSystemConfiguration_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7628 -> (1, ("e",from_TalkException _v7628))) <$> getSystemConfiguration_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7628 -> P.Just (0, ("success",from_SystemConfiguration _v7628))) $ getSystemConfiguration_result_success record
    , (\_v7628 -> (1, ("e",from_TalkException _v7628))) <$> getSystemConfiguration_result_e record
    ]
    )
write_GetSystemConfiguration_result :: T.Protocol p => p -> GetSystemConfiguration_result -> P.IO ()
write_GetSystemConfiguration_result oprot record = T.writeVal oprot $ from_GetSystemConfiguration_result record
encode_GetSystemConfiguration_result :: T.StatelessProtocol p => p -> GetSystemConfiguration_result -> LBS.ByteString
encode_GetSystemConfiguration_result oprot record = T.serializeVal oprot $ from_GetSystemConfiguration_result record
to_GetSystemConfiguration_result :: T.ThriftVal -> GetSystemConfiguration_result
to_GetSystemConfiguration_result (T.TStruct fields) = GetSystemConfiguration_result{
  getSystemConfiguration_result_success = P.maybe (getSystemConfiguration_result_success default_GetSystemConfiguration_result) (\(_,_val7630) -> (case _val7630 of {T.TStruct _val7631 -> (to_SystemConfiguration (T.TStruct _val7631)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSystemConfiguration_result_e = P.maybe (P.Nothing) (\(_,_val7630) -> P.Just (case _val7630 of {T.TStruct _val7632 -> (to_TalkException (T.TStruct _val7632)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSystemConfiguration_result _ = P.error "not a struct"
read_GetSystemConfiguration_result :: T.Protocol p => p -> P.IO GetSystemConfiguration_result
read_GetSystemConfiguration_result iprot = to_GetSystemConfiguration_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_result)
decode_GetSystemConfiguration_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSystemConfiguration_result
decode_GetSystemConfiguration_result iprot bs = to_GetSystemConfiguration_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSystemConfiguration_result) bs
typemap_GetSystemConfiguration_result :: T.TypeMap
typemap_GetSystemConfiguration_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SystemConfiguration))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSystemConfiguration_result :: GetSystemConfiguration_result
default_GetSystemConfiguration_result = GetSystemConfiguration_result{
  getSystemConfiguration_result_success = default_SystemConfiguration,
  getSystemConfiguration_result_e = P.Nothing}
data GetUserTicket_args = GetUserTicket_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTicket_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserTicket_args where 
  arbitrary = QC.elements [GetUserTicket_args]
from_GetUserTicket_args :: GetUserTicket_args -> T.ThriftVal
from_GetUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserTicket_args :: T.Protocol p => p -> GetUserTicket_args -> P.IO ()
write_GetUserTicket_args oprot record = T.writeVal oprot $ from_GetUserTicket_args record
encode_GetUserTicket_args :: T.StatelessProtocol p => p -> GetUserTicket_args -> LBS.ByteString
encode_GetUserTicket_args oprot record = T.serializeVal oprot $ from_GetUserTicket_args record
to_GetUserTicket_args :: T.ThriftVal -> GetUserTicket_args
to_GetUserTicket_args (T.TStruct fields) = GetUserTicket_args{

  }
to_GetUserTicket_args _ = P.error "not a struct"
read_GetUserTicket_args :: T.Protocol p => p -> P.IO GetUserTicket_args
read_GetUserTicket_args iprot = to_GetUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTicket_args)
decode_GetUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTicket_args
decode_GetUserTicket_args iprot bs = to_GetUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTicket_args) bs
typemap_GetUserTicket_args :: T.TypeMap
typemap_GetUserTicket_args = Map.fromList []
default_GetUserTicket_args :: GetUserTicket_args
default_GetUserTicket_args = GetUserTicket_args{
}
data GetUserTicket_result = GetUserTicket_result  { getUserTicket_result_success :: Ticket
  , getUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTicket_result_success record   `H.hashWithSalt` getUserTicket_result_e record  
instance QC.Arbitrary GetUserTicket_result where 
  arbitrary = M.liftM GetUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTicket_result{getUserTicket_result_success = getUserTicket_result_success obj} then P.Nothing else P.Just $ default_GetUserTicket_result{getUserTicket_result_success = getUserTicket_result_success obj}
    , if obj == default_GetUserTicket_result{getUserTicket_result_e = getUserTicket_result_e obj} then P.Nothing else P.Just $ default_GetUserTicket_result{getUserTicket_result_e = getUserTicket_result_e obj}
    ]
from_GetUserTicket_result :: GetUserTicket_result -> T.ThriftVal
from_GetUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7640 -> (1, ("e",from_TalkException _v7640))) <$> getUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7640 -> P.Just (0, ("success",from_Ticket _v7640))) $ getUserTicket_result_success record
    , (\_v7640 -> (1, ("e",from_TalkException _v7640))) <$> getUserTicket_result_e record
    ]
    )
write_GetUserTicket_result :: T.Protocol p => p -> GetUserTicket_result -> P.IO ()
write_GetUserTicket_result oprot record = T.writeVal oprot $ from_GetUserTicket_result record
encode_GetUserTicket_result :: T.StatelessProtocol p => p -> GetUserTicket_result -> LBS.ByteString
encode_GetUserTicket_result oprot record = T.serializeVal oprot $ from_GetUserTicket_result record
to_GetUserTicket_result :: T.ThriftVal -> GetUserTicket_result
to_GetUserTicket_result (T.TStruct fields) = GetUserTicket_result{
  getUserTicket_result_success = P.maybe (getUserTicket_result_success default_GetUserTicket_result) (\(_,_val7642) -> (case _val7642 of {T.TStruct _val7643 -> (to_Ticket (T.TStruct _val7643)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val7642) -> P.Just (case _val7642 of {T.TStruct _val7644 -> (to_TalkException (T.TStruct _val7644)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTicket_result _ = P.error "not a struct"
read_GetUserTicket_result :: T.Protocol p => p -> P.IO GetUserTicket_result
read_GetUserTicket_result iprot = to_GetUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTicket_result)
decode_GetUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTicket_result
decode_GetUserTicket_result iprot bs = to_GetUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTicket_result) bs
typemap_GetUserTicket_result :: T.TypeMap
typemap_GetUserTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Ticket))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserTicket_result :: GetUserTicket_result
default_GetUserTicket_result = GetUserTicket_result{
  getUserTicket_result_success = default_Ticket,
  getUserTicket_result_e = P.Nothing}
data GetWapInvitation_args = GetWapInvitation_args  { getWapInvitation_args_invitationHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetWapInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getWapInvitation_args_invitationHash record  
instance QC.Arbitrary GetWapInvitation_args where 
  arbitrary = M.liftM GetWapInvitation_args (QC.arbitrary)
  shrink obj | obj == default_GetWapInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetWapInvitation_args{getWapInvitation_args_invitationHash = getWapInvitation_args_invitationHash obj} then P.Nothing else P.Just $ default_GetWapInvitation_args{getWapInvitation_args_invitationHash = getWapInvitation_args_invitationHash obj}
    ]
from_GetWapInvitation_args :: GetWapInvitation_args -> T.ThriftVal
from_GetWapInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7647 -> P.Just (2, ("invitationHash",T.TString $ E.encodeUtf8 _v7647))) $ getWapInvitation_args_invitationHash record
  ]
write_GetWapInvitation_args :: T.Protocol p => p -> GetWapInvitation_args -> P.IO ()
write_GetWapInvitation_args oprot record = T.writeVal oprot $ from_GetWapInvitation_args record
encode_GetWapInvitation_args :: T.StatelessProtocol p => p -> GetWapInvitation_args -> LBS.ByteString
encode_GetWapInvitation_args oprot record = T.serializeVal oprot $ from_GetWapInvitation_args record
to_GetWapInvitation_args :: T.ThriftVal -> GetWapInvitation_args
to_GetWapInvitation_args (T.TStruct fields) = GetWapInvitation_args{
  getWapInvitation_args_invitationHash = P.maybe (getWapInvitation_args_invitationHash default_GetWapInvitation_args) (\(_,_val7649) -> (case _val7649 of {T.TString _val7650 -> E.decodeUtf8 _val7650; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetWapInvitation_args _ = P.error "not a struct"
read_GetWapInvitation_args :: T.Protocol p => p -> P.IO GetWapInvitation_args
read_GetWapInvitation_args iprot = to_GetWapInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetWapInvitation_args)
decode_GetWapInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetWapInvitation_args
decode_GetWapInvitation_args iprot bs = to_GetWapInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetWapInvitation_args) bs
typemap_GetWapInvitation_args :: T.TypeMap
typemap_GetWapInvitation_args = Map.fromList [(2,("invitationHash",T.T_STRING))]
default_GetWapInvitation_args :: GetWapInvitation_args
default_GetWapInvitation_args = GetWapInvitation_args{
  getWapInvitation_args_invitationHash = ""}
data GetWapInvitation_result = GetWapInvitation_result  { getWapInvitation_result_success :: WapInvitation
  , getWapInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetWapInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getWapInvitation_result_success record   `H.hashWithSalt` getWapInvitation_result_e record  
instance QC.Arbitrary GetWapInvitation_result where 
  arbitrary = M.liftM GetWapInvitation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetWapInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetWapInvitation_result{getWapInvitation_result_success = getWapInvitation_result_success obj} then P.Nothing else P.Just $ default_GetWapInvitation_result{getWapInvitation_result_success = getWapInvitation_result_success obj}
    , if obj == default_GetWapInvitation_result{getWapInvitation_result_e = getWapInvitation_result_e obj} then P.Nothing else P.Just $ default_GetWapInvitation_result{getWapInvitation_result_e = getWapInvitation_result_e obj}
    ]
from_GetWapInvitation_result :: GetWapInvitation_result -> T.ThriftVal
from_GetWapInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7653 -> (1, ("e",from_TalkException _v7653))) <$> getWapInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7653 -> P.Just (0, ("success",from_WapInvitation _v7653))) $ getWapInvitation_result_success record
    , (\_v7653 -> (1, ("e",from_TalkException _v7653))) <$> getWapInvitation_result_e record
    ]
    )
write_GetWapInvitation_result :: T.Protocol p => p -> GetWapInvitation_result -> P.IO ()
write_GetWapInvitation_result oprot record = T.writeVal oprot $ from_GetWapInvitation_result record
encode_GetWapInvitation_result :: T.StatelessProtocol p => p -> GetWapInvitation_result -> LBS.ByteString
encode_GetWapInvitation_result oprot record = T.serializeVal oprot $ from_GetWapInvitation_result record
to_GetWapInvitation_result :: T.ThriftVal -> GetWapInvitation_result
to_GetWapInvitation_result (T.TStruct fields) = GetWapInvitation_result{
  getWapInvitation_result_success = P.maybe (getWapInvitation_result_success default_GetWapInvitation_result) (\(_,_val7655) -> (case _val7655 of {T.TStruct _val7656 -> (to_WapInvitation (T.TStruct _val7656)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getWapInvitation_result_e = P.maybe (P.Nothing) (\(_,_val7655) -> P.Just (case _val7655 of {T.TStruct _val7657 -> (to_TalkException (T.TStruct _val7657)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetWapInvitation_result _ = P.error "not a struct"
read_GetWapInvitation_result :: T.Protocol p => p -> P.IO GetWapInvitation_result
read_GetWapInvitation_result iprot = to_GetWapInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetWapInvitation_result)
decode_GetWapInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetWapInvitation_result
decode_GetWapInvitation_result iprot bs = to_GetWapInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetWapInvitation_result) bs
typemap_GetWapInvitation_result :: T.TypeMap
typemap_GetWapInvitation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_WapInvitation))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetWapInvitation_result :: GetWapInvitation_result
default_GetWapInvitation_result = GetWapInvitation_result{
  getWapInvitation_result_success = default_WapInvitation,
  getWapInvitation_result_e = P.Nothing}
data InvalidateUserTicket_args = InvalidateUserTicket_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InvalidateUserTicket_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary InvalidateUserTicket_args where 
  arbitrary = QC.elements [InvalidateUserTicket_args]
from_InvalidateUserTicket_args :: InvalidateUserTicket_args -> T.ThriftVal
from_InvalidateUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_InvalidateUserTicket_args :: T.Protocol p => p -> InvalidateUserTicket_args -> P.IO ()
write_InvalidateUserTicket_args oprot record = T.writeVal oprot $ from_InvalidateUserTicket_args record
encode_InvalidateUserTicket_args :: T.StatelessProtocol p => p -> InvalidateUserTicket_args -> LBS.ByteString
encode_InvalidateUserTicket_args oprot record = T.serializeVal oprot $ from_InvalidateUserTicket_args record
to_InvalidateUserTicket_args :: T.ThriftVal -> InvalidateUserTicket_args
to_InvalidateUserTicket_args (T.TStruct fields) = InvalidateUserTicket_args{

  }
to_InvalidateUserTicket_args _ = P.error "not a struct"
read_InvalidateUserTicket_args :: T.Protocol p => p -> P.IO InvalidateUserTicket_args
read_InvalidateUserTicket_args iprot = to_InvalidateUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_args)
decode_InvalidateUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InvalidateUserTicket_args
decode_InvalidateUserTicket_args iprot bs = to_InvalidateUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_args) bs
typemap_InvalidateUserTicket_args :: T.TypeMap
typemap_InvalidateUserTicket_args = Map.fromList []
default_InvalidateUserTicket_args :: InvalidateUserTicket_args
default_InvalidateUserTicket_args = InvalidateUserTicket_args{
}
data InvalidateUserTicket_result = InvalidateUserTicket_result  { invalidateUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InvalidateUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` invalidateUserTicket_result_e record  
instance QC.Arbitrary InvalidateUserTicket_result where 
  arbitrary = M.liftM InvalidateUserTicket_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InvalidateUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InvalidateUserTicket_result{invalidateUserTicket_result_e = invalidateUserTicket_result_e obj} then P.Nothing else P.Just $ default_InvalidateUserTicket_result{invalidateUserTicket_result_e = invalidateUserTicket_result_e obj}
    ]
from_InvalidateUserTicket_result :: InvalidateUserTicket_result -> T.ThriftVal
from_InvalidateUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7665 -> (1, ("e",from_TalkException _v7665))) <$> invalidateUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7665 -> (1, ("e",from_TalkException _v7665))) <$> invalidateUserTicket_result_e record
    ]
    )
write_InvalidateUserTicket_result :: T.Protocol p => p -> InvalidateUserTicket_result -> P.IO ()
write_InvalidateUserTicket_result oprot record = T.writeVal oprot $ from_InvalidateUserTicket_result record
encode_InvalidateUserTicket_result :: T.StatelessProtocol p => p -> InvalidateUserTicket_result -> LBS.ByteString
encode_InvalidateUserTicket_result oprot record = T.serializeVal oprot $ from_InvalidateUserTicket_result record
to_InvalidateUserTicket_result :: T.ThriftVal -> InvalidateUserTicket_result
to_InvalidateUserTicket_result (T.TStruct fields) = InvalidateUserTicket_result{
  invalidateUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val7667) -> P.Just (case _val7667 of {T.TStruct _val7668 -> (to_TalkException (T.TStruct _val7668)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InvalidateUserTicket_result _ = P.error "not a struct"
read_InvalidateUserTicket_result :: T.Protocol p => p -> P.IO InvalidateUserTicket_result
read_InvalidateUserTicket_result iprot = to_InvalidateUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_result)
decode_InvalidateUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InvalidateUserTicket_result
decode_InvalidateUserTicket_result iprot bs = to_InvalidateUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InvalidateUserTicket_result) bs
typemap_InvalidateUserTicket_result :: T.TypeMap
typemap_InvalidateUserTicket_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InvalidateUserTicket_result :: InvalidateUserTicket_result
default_InvalidateUserTicket_result = InvalidateUserTicket_result{
  invalidateUserTicket_result_e = P.Nothing}
data InviteFriendsBySms_args = InviteFriendsBySms_args  { inviteFriendsBySms_args_phoneNumberList :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteFriendsBySms_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteFriendsBySms_args_phoneNumberList record  
instance QC.Arbitrary InviteFriendsBySms_args where 
  arbitrary = M.liftM InviteFriendsBySms_args (QC.arbitrary)
  shrink obj | obj == default_InviteFriendsBySms_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteFriendsBySms_args{inviteFriendsBySms_args_phoneNumberList = inviteFriendsBySms_args_phoneNumberList obj} then P.Nothing else P.Just $ default_InviteFriendsBySms_args{inviteFriendsBySms_args_phoneNumberList = inviteFriendsBySms_args_phoneNumberList obj}
    ]
from_InviteFriendsBySms_args :: InviteFriendsBySms_args -> T.ThriftVal
from_InviteFriendsBySms_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7671 -> P.Just (2, ("phoneNumberList",T.TList T.T_STRING $ P.map (\_v7673 -> T.TString $ E.encodeUtf8 _v7673) $ Vector.toList _v7671))) $ inviteFriendsBySms_args_phoneNumberList record
  ]
write_InviteFriendsBySms_args :: T.Protocol p => p -> InviteFriendsBySms_args -> P.IO ()
write_InviteFriendsBySms_args oprot record = T.writeVal oprot $ from_InviteFriendsBySms_args record
encode_InviteFriendsBySms_args :: T.StatelessProtocol p => p -> InviteFriendsBySms_args -> LBS.ByteString
encode_InviteFriendsBySms_args oprot record = T.serializeVal oprot $ from_InviteFriendsBySms_args record
to_InviteFriendsBySms_args :: T.ThriftVal -> InviteFriendsBySms_args
to_InviteFriendsBySms_args (T.TStruct fields) = InviteFriendsBySms_args{
  inviteFriendsBySms_args_phoneNumberList = P.maybe (inviteFriendsBySms_args_phoneNumberList default_InviteFriendsBySms_args) (\(_,_val7675) -> (case _val7675 of {T.TList _ _val7676 -> (Vector.fromList $ P.map (\_v7677 -> (case _v7677 of {T.TString _val7678 -> E.decodeUtf8 _val7678; _ -> P.error "wrong type"})) _val7676); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InviteFriendsBySms_args _ = P.error "not a struct"
read_InviteFriendsBySms_args :: T.Protocol p => p -> P.IO InviteFriendsBySms_args
read_InviteFriendsBySms_args iprot = to_InviteFriendsBySms_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_args)
decode_InviteFriendsBySms_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteFriendsBySms_args
decode_InviteFriendsBySms_args iprot bs = to_InviteFriendsBySms_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_args) bs
typemap_InviteFriendsBySms_args :: T.TypeMap
typemap_InviteFriendsBySms_args = Map.fromList [(2,("phoneNumberList",(T.T_LIST T.T_STRING)))]
default_InviteFriendsBySms_args :: InviteFriendsBySms_args
default_InviteFriendsBySms_args = InviteFriendsBySms_args{
  inviteFriendsBySms_args_phoneNumberList = Vector.empty}
data InviteFriendsBySms_result = InviteFriendsBySms_result  { inviteFriendsBySms_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteFriendsBySms_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteFriendsBySms_result_e record  
instance QC.Arbitrary InviteFriendsBySms_result where 
  arbitrary = M.liftM InviteFriendsBySms_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteFriendsBySms_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = inviteFriendsBySms_result_e obj} then P.Nothing else P.Just $ default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = inviteFriendsBySms_result_e obj}
    ]
from_InviteFriendsBySms_result :: InviteFriendsBySms_result -> T.ThriftVal
from_InviteFriendsBySms_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7681 -> (1, ("e",from_TalkException _v7681))) <$> inviteFriendsBySms_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7681 -> (1, ("e",from_TalkException _v7681))) <$> inviteFriendsBySms_result_e record
    ]
    )
write_InviteFriendsBySms_result :: T.Protocol p => p -> InviteFriendsBySms_result -> P.IO ()
write_InviteFriendsBySms_result oprot record = T.writeVal oprot $ from_InviteFriendsBySms_result record
encode_InviteFriendsBySms_result :: T.StatelessProtocol p => p -> InviteFriendsBySms_result -> LBS.ByteString
encode_InviteFriendsBySms_result oprot record = T.serializeVal oprot $ from_InviteFriendsBySms_result record
to_InviteFriendsBySms_result :: T.ThriftVal -> InviteFriendsBySms_result
to_InviteFriendsBySms_result (T.TStruct fields) = InviteFriendsBySms_result{
  inviteFriendsBySms_result_e = P.maybe (P.Nothing) (\(_,_val7683) -> P.Just (case _val7683 of {T.TStruct _val7684 -> (to_TalkException (T.TStruct _val7684)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteFriendsBySms_result _ = P.error "not a struct"
read_InviteFriendsBySms_result :: T.Protocol p => p -> P.IO InviteFriendsBySms_result
read_InviteFriendsBySms_result iprot = to_InviteFriendsBySms_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_result)
decode_InviteFriendsBySms_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteFriendsBySms_result
decode_InviteFriendsBySms_result iprot bs = to_InviteFriendsBySms_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteFriendsBySms_result) bs
typemap_InviteFriendsBySms_result :: T.TypeMap
typemap_InviteFriendsBySms_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteFriendsBySms_result :: InviteFriendsBySms_result
default_InviteFriendsBySms_result = InviteFriendsBySms_result{
  inviteFriendsBySms_result_e = P.Nothing}
data InviteIntoGroup_args = InviteIntoGroup_args  { inviteIntoGroup_args_reqSeq :: I.Int32
  , inviteIntoGroup_args_groupId :: LT.Text
  , inviteIntoGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroup_args_reqSeq record   `H.hashWithSalt` inviteIntoGroup_args_groupId record   `H.hashWithSalt` inviteIntoGroup_args_contactIds record  
instance QC.Arbitrary InviteIntoGroup_args where 
  arbitrary = M.liftM InviteIntoGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_reqSeq = inviteIntoGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_reqSeq = inviteIntoGroup_args_reqSeq obj}
    , if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_groupId = inviteIntoGroup_args_groupId obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_groupId = inviteIntoGroup_args_groupId obj}
    , if obj == default_InviteIntoGroup_args{inviteIntoGroup_args_contactIds = inviteIntoGroup_args_contactIds obj} then P.Nothing else P.Just $ default_InviteIntoGroup_args{inviteIntoGroup_args_contactIds = inviteIntoGroup_args_contactIds obj}
    ]
from_InviteIntoGroup_args :: InviteIntoGroup_args -> T.ThriftVal
from_InviteIntoGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7687 -> P.Just (1, ("reqSeq",T.TI32 _v7687))) $ inviteIntoGroup_args_reqSeq record
  , (\_v7687 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v7687))) $ inviteIntoGroup_args_groupId record
  , (\_v7687 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v7689 -> T.TString $ E.encodeUtf8 _v7689) $ Vector.toList _v7687))) $ inviteIntoGroup_args_contactIds record
  ]
write_InviteIntoGroup_args :: T.Protocol p => p -> InviteIntoGroup_args -> P.IO ()
write_InviteIntoGroup_args oprot record = T.writeVal oprot $ from_InviteIntoGroup_args record
encode_InviteIntoGroup_args :: T.StatelessProtocol p => p -> InviteIntoGroup_args -> LBS.ByteString
encode_InviteIntoGroup_args oprot record = T.serializeVal oprot $ from_InviteIntoGroup_args record
to_InviteIntoGroup_args :: T.ThriftVal -> InviteIntoGroup_args
to_InviteIntoGroup_args (T.TStruct fields) = InviteIntoGroup_args{
  inviteIntoGroup_args_reqSeq = P.maybe (inviteIntoGroup_args_reqSeq default_InviteIntoGroup_args) (\(_,_val7691) -> (case _val7691 of {T.TI32 _val7692 -> _val7692; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteIntoGroup_args_groupId = P.maybe (inviteIntoGroup_args_groupId default_InviteIntoGroup_args) (\(_,_val7691) -> (case _val7691 of {T.TString _val7693 -> E.decodeUtf8 _val7693; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoGroup_args_contactIds = P.maybe (inviteIntoGroup_args_contactIds default_InviteIntoGroup_args) (\(_,_val7691) -> (case _val7691 of {T.TList _ _val7694 -> (Vector.fromList $ P.map (\_v7695 -> (case _v7695 of {T.TString _val7696 -> E.decodeUtf8 _val7696; _ -> P.error "wrong type"})) _val7694); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteIntoGroup_args _ = P.error "not a struct"
read_InviteIntoGroup_args :: T.Protocol p => p -> P.IO InviteIntoGroup_args
read_InviteIntoGroup_args iprot = to_InviteIntoGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroup_args)
decode_InviteIntoGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroup_args
decode_InviteIntoGroup_args iprot bs = to_InviteIntoGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroup_args) bs
typemap_InviteIntoGroup_args :: T.TypeMap
typemap_InviteIntoGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_InviteIntoGroup_args :: InviteIntoGroup_args
default_InviteIntoGroup_args = InviteIntoGroup_args{
  inviteIntoGroup_args_reqSeq = 0,
  inviteIntoGroup_args_groupId = "",
  inviteIntoGroup_args_contactIds = Vector.empty}
data InviteIntoGroup_result = InviteIntoGroup_result  { inviteIntoGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroup_result_e record  
instance QC.Arbitrary InviteIntoGroup_result where 
  arbitrary = M.liftM InviteIntoGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroup_result{inviteIntoGroup_result_e = inviteIntoGroup_result_e obj} then P.Nothing else P.Just $ default_InviteIntoGroup_result{inviteIntoGroup_result_e = inviteIntoGroup_result_e obj}
    ]
from_InviteIntoGroup_result :: InviteIntoGroup_result -> T.ThriftVal
from_InviteIntoGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7699 -> (1, ("e",from_TalkException _v7699))) <$> inviteIntoGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7699 -> (1, ("e",from_TalkException _v7699))) <$> inviteIntoGroup_result_e record
    ]
    )
write_InviteIntoGroup_result :: T.Protocol p => p -> InviteIntoGroup_result -> P.IO ()
write_InviteIntoGroup_result oprot record = T.writeVal oprot $ from_InviteIntoGroup_result record
encode_InviteIntoGroup_result :: T.StatelessProtocol p => p -> InviteIntoGroup_result -> LBS.ByteString
encode_InviteIntoGroup_result oprot record = T.serializeVal oprot $ from_InviteIntoGroup_result record
to_InviteIntoGroup_result :: T.ThriftVal -> InviteIntoGroup_result
to_InviteIntoGroup_result (T.TStruct fields) = InviteIntoGroup_result{
  inviteIntoGroup_result_e = P.maybe (P.Nothing) (\(_,_val7701) -> P.Just (case _val7701 of {T.TStruct _val7702 -> (to_TalkException (T.TStruct _val7702)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoGroup_result _ = P.error "not a struct"
read_InviteIntoGroup_result :: T.Protocol p => p -> P.IO InviteIntoGroup_result
read_InviteIntoGroup_result iprot = to_InviteIntoGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroup_result)
decode_InviteIntoGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroup_result
decode_InviteIntoGroup_result iprot bs = to_InviteIntoGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroup_result) bs
typemap_InviteIntoGroup_result :: T.TypeMap
typemap_InviteIntoGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoGroup_result :: InviteIntoGroup_result
default_InviteIntoGroup_result = InviteIntoGroup_result{
  inviteIntoGroup_result_e = P.Nothing}
data InviteIntoRoom_args = InviteIntoRoom_args  { inviteIntoRoom_args_reqSeq :: I.Int32
  , inviteIntoRoom_args_roomId :: LT.Text
  , inviteIntoRoom_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoRoom_args_reqSeq record   `H.hashWithSalt` inviteIntoRoom_args_roomId record   `H.hashWithSalt` inviteIntoRoom_args_contactIds record  
instance QC.Arbitrary InviteIntoRoom_args where 
  arbitrary = M.liftM InviteIntoRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_reqSeq = inviteIntoRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_reqSeq = inviteIntoRoom_args_reqSeq obj}
    , if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_roomId = inviteIntoRoom_args_roomId obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_roomId = inviteIntoRoom_args_roomId obj}
    , if obj == default_InviteIntoRoom_args{inviteIntoRoom_args_contactIds = inviteIntoRoom_args_contactIds obj} then P.Nothing else P.Just $ default_InviteIntoRoom_args{inviteIntoRoom_args_contactIds = inviteIntoRoom_args_contactIds obj}
    ]
from_InviteIntoRoom_args :: InviteIntoRoom_args -> T.ThriftVal
from_InviteIntoRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7705 -> P.Just (1, ("reqSeq",T.TI32 _v7705))) $ inviteIntoRoom_args_reqSeq record
  , (\_v7705 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v7705))) $ inviteIntoRoom_args_roomId record
  , (\_v7705 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v7707 -> T.TString $ E.encodeUtf8 _v7707) $ Vector.toList _v7705))) $ inviteIntoRoom_args_contactIds record
  ]
write_InviteIntoRoom_args :: T.Protocol p => p -> InviteIntoRoom_args -> P.IO ()
write_InviteIntoRoom_args oprot record = T.writeVal oprot $ from_InviteIntoRoom_args record
encode_InviteIntoRoom_args :: T.StatelessProtocol p => p -> InviteIntoRoom_args -> LBS.ByteString
encode_InviteIntoRoom_args oprot record = T.serializeVal oprot $ from_InviteIntoRoom_args record
to_InviteIntoRoom_args :: T.ThriftVal -> InviteIntoRoom_args
to_InviteIntoRoom_args (T.TStruct fields) = InviteIntoRoom_args{
  inviteIntoRoom_args_reqSeq = P.maybe (inviteIntoRoom_args_reqSeq default_InviteIntoRoom_args) (\(_,_val7709) -> (case _val7709 of {T.TI32 _val7710 -> _val7710; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteIntoRoom_args_roomId = P.maybe (inviteIntoRoom_args_roomId default_InviteIntoRoom_args) (\(_,_val7709) -> (case _val7709 of {T.TString _val7711 -> E.decodeUtf8 _val7711; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoRoom_args_contactIds = P.maybe (inviteIntoRoom_args_contactIds default_InviteIntoRoom_args) (\(_,_val7709) -> (case _val7709 of {T.TList _ _val7712 -> (Vector.fromList $ P.map (\_v7713 -> (case _v7713 of {T.TString _val7714 -> E.decodeUtf8 _val7714; _ -> P.error "wrong type"})) _val7712); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteIntoRoom_args _ = P.error "not a struct"
read_InviteIntoRoom_args :: T.Protocol p => p -> P.IO InviteIntoRoom_args
read_InviteIntoRoom_args iprot = to_InviteIntoRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoRoom_args)
decode_InviteIntoRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoRoom_args
decode_InviteIntoRoom_args iprot bs = to_InviteIntoRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoRoom_args) bs
typemap_InviteIntoRoom_args :: T.TypeMap
typemap_InviteIntoRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("roomId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_InviteIntoRoom_args :: InviteIntoRoom_args
default_InviteIntoRoom_args = InviteIntoRoom_args{
  inviteIntoRoom_args_reqSeq = 0,
  inviteIntoRoom_args_roomId = "",
  inviteIntoRoom_args_contactIds = Vector.empty}
data InviteIntoRoom_result = InviteIntoRoom_result  { inviteIntoRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoRoom_result_e record  
instance QC.Arbitrary InviteIntoRoom_result where 
  arbitrary = M.liftM InviteIntoRoom_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoRoom_result{inviteIntoRoom_result_e = inviteIntoRoom_result_e obj} then P.Nothing else P.Just $ default_InviteIntoRoom_result{inviteIntoRoom_result_e = inviteIntoRoom_result_e obj}
    ]
from_InviteIntoRoom_result :: InviteIntoRoom_result -> T.ThriftVal
from_InviteIntoRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7717 -> (1, ("e",from_TalkException _v7717))) <$> inviteIntoRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7717 -> (1, ("e",from_TalkException _v7717))) <$> inviteIntoRoom_result_e record
    ]
    )
write_InviteIntoRoom_result :: T.Protocol p => p -> InviteIntoRoom_result -> P.IO ()
write_InviteIntoRoom_result oprot record = T.writeVal oprot $ from_InviteIntoRoom_result record
encode_InviteIntoRoom_result :: T.StatelessProtocol p => p -> InviteIntoRoom_result -> LBS.ByteString
encode_InviteIntoRoom_result oprot record = T.serializeVal oprot $ from_InviteIntoRoom_result record
to_InviteIntoRoom_result :: T.ThriftVal -> InviteIntoRoom_result
to_InviteIntoRoom_result (T.TStruct fields) = InviteIntoRoom_result{
  inviteIntoRoom_result_e = P.maybe (P.Nothing) (\(_,_val7719) -> P.Just (case _val7719 of {T.TStruct _val7720 -> (to_TalkException (T.TStruct _val7720)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoRoom_result _ = P.error "not a struct"
read_InviteIntoRoom_result :: T.Protocol p => p -> P.IO InviteIntoRoom_result
read_InviteIntoRoom_result iprot = to_InviteIntoRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoRoom_result)
decode_InviteIntoRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoRoom_result
decode_InviteIntoRoom_result iprot bs = to_InviteIntoRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoRoom_result) bs
typemap_InviteIntoRoom_result :: T.TypeMap
typemap_InviteIntoRoom_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoRoom_result :: InviteIntoRoom_result
default_InviteIntoRoom_result = InviteIntoRoom_result{
  inviteIntoRoom_result_e = P.Nothing}
data InviteViaEmail_args = InviteViaEmail_args  { inviteViaEmail_args_reqSeq :: I.Int32
  , inviteViaEmail_args_email :: LT.Text
  , inviteViaEmail_args_name :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteViaEmail_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteViaEmail_args_reqSeq record   `H.hashWithSalt` inviteViaEmail_args_email record   `H.hashWithSalt` inviteViaEmail_args_name record  
instance QC.Arbitrary InviteViaEmail_args where 
  arbitrary = M.liftM InviteViaEmail_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteViaEmail_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteViaEmail_args{inviteViaEmail_args_reqSeq = inviteViaEmail_args_reqSeq obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_reqSeq = inviteViaEmail_args_reqSeq obj}
    , if obj == default_InviteViaEmail_args{inviteViaEmail_args_email = inviteViaEmail_args_email obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_email = inviteViaEmail_args_email obj}
    , if obj == default_InviteViaEmail_args{inviteViaEmail_args_name = inviteViaEmail_args_name obj} then P.Nothing else P.Just $ default_InviteViaEmail_args{inviteViaEmail_args_name = inviteViaEmail_args_name obj}
    ]
from_InviteViaEmail_args :: InviteViaEmail_args -> T.ThriftVal
from_InviteViaEmail_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7723 -> P.Just (1, ("reqSeq",T.TI32 _v7723))) $ inviteViaEmail_args_reqSeq record
  , (\_v7723 -> P.Just (2, ("email",T.TString $ E.encodeUtf8 _v7723))) $ inviteViaEmail_args_email record
  , (\_v7723 -> P.Just (3, ("name",T.TString $ E.encodeUtf8 _v7723))) $ inviteViaEmail_args_name record
  ]
write_InviteViaEmail_args :: T.Protocol p => p -> InviteViaEmail_args -> P.IO ()
write_InviteViaEmail_args oprot record = T.writeVal oprot $ from_InviteViaEmail_args record
encode_InviteViaEmail_args :: T.StatelessProtocol p => p -> InviteViaEmail_args -> LBS.ByteString
encode_InviteViaEmail_args oprot record = T.serializeVal oprot $ from_InviteViaEmail_args record
to_InviteViaEmail_args :: T.ThriftVal -> InviteViaEmail_args
to_InviteViaEmail_args (T.TStruct fields) = InviteViaEmail_args{
  inviteViaEmail_args_reqSeq = P.maybe (inviteViaEmail_args_reqSeq default_InviteViaEmail_args) (\(_,_val7725) -> (case _val7725 of {T.TI32 _val7726 -> _val7726; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteViaEmail_args_email = P.maybe (inviteViaEmail_args_email default_InviteViaEmail_args) (\(_,_val7725) -> (case _val7725 of {T.TString _val7727 -> E.decodeUtf8 _val7727; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteViaEmail_args_name = P.maybe (inviteViaEmail_args_name default_InviteViaEmail_args) (\(_,_val7725) -> (case _val7725 of {T.TString _val7728 -> E.decodeUtf8 _val7728; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_InviteViaEmail_args _ = P.error "not a struct"
read_InviteViaEmail_args :: T.Protocol p => p -> P.IO InviteViaEmail_args
read_InviteViaEmail_args iprot = to_InviteViaEmail_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteViaEmail_args)
decode_InviteViaEmail_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteViaEmail_args
decode_InviteViaEmail_args iprot bs = to_InviteViaEmail_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteViaEmail_args) bs
typemap_InviteViaEmail_args :: T.TypeMap
typemap_InviteViaEmail_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("email",T.T_STRING)),(3,("name",T.T_STRING))]
default_InviteViaEmail_args :: InviteViaEmail_args
default_InviteViaEmail_args = InviteViaEmail_args{
  inviteViaEmail_args_reqSeq = 0,
  inviteViaEmail_args_email = "",
  inviteViaEmail_args_name = ""}
data InviteViaEmail_result = InviteViaEmail_result  { inviteViaEmail_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteViaEmail_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteViaEmail_result_e record  
instance QC.Arbitrary InviteViaEmail_result where 
  arbitrary = M.liftM InviteViaEmail_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteViaEmail_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteViaEmail_result{inviteViaEmail_result_e = inviteViaEmail_result_e obj} then P.Nothing else P.Just $ default_InviteViaEmail_result{inviteViaEmail_result_e = inviteViaEmail_result_e obj}
    ]
from_InviteViaEmail_result :: InviteViaEmail_result -> T.ThriftVal
from_InviteViaEmail_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7731 -> (1, ("e",from_TalkException _v7731))) <$> inviteViaEmail_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7731 -> (1, ("e",from_TalkException _v7731))) <$> inviteViaEmail_result_e record
    ]
    )
write_InviteViaEmail_result :: T.Protocol p => p -> InviteViaEmail_result -> P.IO ()
write_InviteViaEmail_result oprot record = T.writeVal oprot $ from_InviteViaEmail_result record
encode_InviteViaEmail_result :: T.StatelessProtocol p => p -> InviteViaEmail_result -> LBS.ByteString
encode_InviteViaEmail_result oprot record = T.serializeVal oprot $ from_InviteViaEmail_result record
to_InviteViaEmail_result :: T.ThriftVal -> InviteViaEmail_result
to_InviteViaEmail_result (T.TStruct fields) = InviteViaEmail_result{
  inviteViaEmail_result_e = P.maybe (P.Nothing) (\(_,_val7733) -> P.Just (case _val7733 of {T.TStruct _val7734 -> (to_TalkException (T.TStruct _val7734)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteViaEmail_result _ = P.error "not a struct"
read_InviteViaEmail_result :: T.Protocol p => p -> P.IO InviteViaEmail_result
read_InviteViaEmail_result iprot = to_InviteViaEmail_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteViaEmail_result)
decode_InviteViaEmail_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteViaEmail_result
decode_InviteViaEmail_result iprot bs = to_InviteViaEmail_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteViaEmail_result) bs
typemap_InviteViaEmail_result :: T.TypeMap
typemap_InviteViaEmail_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteViaEmail_result :: InviteViaEmail_result
default_InviteViaEmail_result = InviteViaEmail_result{
  inviteViaEmail_result_e = P.Nothing}
data IsIdentityIdentifierAvailable_args = IsIdentityIdentifierAvailable_args  { isIdentityIdentifierAvailable_args_provider :: IdentityProvider
  , isIdentityIdentifierAvailable_args_identifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsIdentityIdentifierAvailable_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isIdentityIdentifierAvailable_args_provider record   `H.hashWithSalt` isIdentityIdentifierAvailable_args_identifier record  
instance QC.Arbitrary IsIdentityIdentifierAvailable_args where 
  arbitrary = M.liftM IsIdentityIdentifierAvailable_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_IsIdentityIdentifierAvailable_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_provider = isIdentityIdentifierAvailable_args_provider obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_provider = isIdentityIdentifierAvailable_args_provider obj}
    , if obj == default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_identifier = isIdentityIdentifierAvailable_args_identifier obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_args{isIdentityIdentifierAvailable_args_identifier = isIdentityIdentifierAvailable_args_identifier obj}
    ]
from_IsIdentityIdentifierAvailable_args :: IsIdentityIdentifierAvailable_args -> T.ThriftVal
from_IsIdentityIdentifierAvailable_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7737 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v7737))) $ isIdentityIdentifierAvailable_args_identifier record
  , (\_v7737 -> P.Just (3, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v7737))) $ isIdentityIdentifierAvailable_args_provider record
  ]
write_IsIdentityIdentifierAvailable_args :: T.Protocol p => p -> IsIdentityIdentifierAvailable_args -> P.IO ()
write_IsIdentityIdentifierAvailable_args oprot record = T.writeVal oprot $ from_IsIdentityIdentifierAvailable_args record
encode_IsIdentityIdentifierAvailable_args :: T.StatelessProtocol p => p -> IsIdentityIdentifierAvailable_args -> LBS.ByteString
encode_IsIdentityIdentifierAvailable_args oprot record = T.serializeVal oprot $ from_IsIdentityIdentifierAvailable_args record
to_IsIdentityIdentifierAvailable_args :: T.ThriftVal -> IsIdentityIdentifierAvailable_args
to_IsIdentityIdentifierAvailable_args (T.TStruct fields) = IsIdentityIdentifierAvailable_args{
  isIdentityIdentifierAvailable_args_provider = P.maybe (isIdentityIdentifierAvailable_args_provider default_IsIdentityIdentifierAvailable_args) (\(_,_val7739) -> (case _val7739 of {T.TI32 _val7740 -> P.toEnum $ P.fromIntegral _val7740; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  isIdentityIdentifierAvailable_args_identifier = P.maybe (isIdentityIdentifierAvailable_args_identifier default_IsIdentityIdentifierAvailable_args) (\(_,_val7739) -> (case _val7739 of {T.TString _val7741 -> E.decodeUtf8 _val7741; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsIdentityIdentifierAvailable_args _ = P.error "not a struct"
read_IsIdentityIdentifierAvailable_args :: T.Protocol p => p -> P.IO IsIdentityIdentifierAvailable_args
read_IsIdentityIdentifierAvailable_args iprot = to_IsIdentityIdentifierAvailable_args <$> T.readVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_args)
decode_IsIdentityIdentifierAvailable_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsIdentityIdentifierAvailable_args
decode_IsIdentityIdentifierAvailable_args iprot bs = to_IsIdentityIdentifierAvailable_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_args) bs
typemap_IsIdentityIdentifierAvailable_args :: T.TypeMap
typemap_IsIdentityIdentifierAvailable_args = Map.fromList [(2,("identifier",T.T_STRING)),(3,("provider",T.T_I32))]
default_IsIdentityIdentifierAvailable_args :: IsIdentityIdentifierAvailable_args
default_IsIdentityIdentifierAvailable_args = IsIdentityIdentifierAvailable_args{
  isIdentityIdentifierAvailable_args_identifier = "",
  isIdentityIdentifierAvailable_args_provider = (P.toEnum 0)}
data IsIdentityIdentifierAvailable_result = IsIdentityIdentifierAvailable_result  { isIdentityIdentifierAvailable_result_success :: P.Bool
  , isIdentityIdentifierAvailable_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsIdentityIdentifierAvailable_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isIdentityIdentifierAvailable_result_success record   `H.hashWithSalt` isIdentityIdentifierAvailable_result_e record  
instance QC.Arbitrary IsIdentityIdentifierAvailable_result where 
  arbitrary = M.liftM IsIdentityIdentifierAvailable_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsIdentityIdentifierAvailable_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = isIdentityIdentifierAvailable_result_success obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = isIdentityIdentifierAvailable_result_success obj}
    , if obj == default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = isIdentityIdentifierAvailable_result_e obj} then P.Nothing else P.Just $ default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = isIdentityIdentifierAvailable_result_e obj}
    ]
from_IsIdentityIdentifierAvailable_result :: IsIdentityIdentifierAvailable_result -> T.ThriftVal
from_IsIdentityIdentifierAvailable_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7744 -> (1, ("e",from_TalkException _v7744))) <$> isIdentityIdentifierAvailable_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7744 -> P.Just (0, ("success",T.TBool _v7744))) $ isIdentityIdentifierAvailable_result_success record
    , (\_v7744 -> (1, ("e",from_TalkException _v7744))) <$> isIdentityIdentifierAvailable_result_e record
    ]
    )
write_IsIdentityIdentifierAvailable_result :: T.Protocol p => p -> IsIdentityIdentifierAvailable_result -> P.IO ()
write_IsIdentityIdentifierAvailable_result oprot record = T.writeVal oprot $ from_IsIdentityIdentifierAvailable_result record
encode_IsIdentityIdentifierAvailable_result :: T.StatelessProtocol p => p -> IsIdentityIdentifierAvailable_result -> LBS.ByteString
encode_IsIdentityIdentifierAvailable_result oprot record = T.serializeVal oprot $ from_IsIdentityIdentifierAvailable_result record
to_IsIdentityIdentifierAvailable_result :: T.ThriftVal -> IsIdentityIdentifierAvailable_result
to_IsIdentityIdentifierAvailable_result (T.TStruct fields) = IsIdentityIdentifierAvailable_result{
  isIdentityIdentifierAvailable_result_success = P.maybe (isIdentityIdentifierAvailable_result_success default_IsIdentityIdentifierAvailable_result) (\(_,_val7746) -> (case _val7746 of {T.TBool _val7747 -> _val7747; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isIdentityIdentifierAvailable_result_e = P.maybe (P.Nothing) (\(_,_val7746) -> P.Just (case _val7746 of {T.TStruct _val7748 -> (to_TalkException (T.TStruct _val7748)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsIdentityIdentifierAvailable_result _ = P.error "not a struct"
read_IsIdentityIdentifierAvailable_result :: T.Protocol p => p -> P.IO IsIdentityIdentifierAvailable_result
read_IsIdentityIdentifierAvailable_result iprot = to_IsIdentityIdentifierAvailable_result <$> T.readVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_result)
decode_IsIdentityIdentifierAvailable_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsIdentityIdentifierAvailable_result
decode_IsIdentityIdentifierAvailable_result iprot bs = to_IsIdentityIdentifierAvailable_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsIdentityIdentifierAvailable_result) bs
typemap_IsIdentityIdentifierAvailable_result :: T.TypeMap
typemap_IsIdentityIdentifierAvailable_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsIdentityIdentifierAvailable_result :: IsIdentityIdentifierAvailable_result
default_IsIdentityIdentifierAvailable_result = IsIdentityIdentifierAvailable_result{
  isIdentityIdentifierAvailable_result_success = P.False,
  isIdentityIdentifierAvailable_result_e = P.Nothing}
data IsUseridAvailable_args = IsUseridAvailable_args  { isUseridAvailable_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsUseridAvailable_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isUseridAvailable_args_userid record  
instance QC.Arbitrary IsUseridAvailable_args where 
  arbitrary = M.liftM IsUseridAvailable_args (QC.arbitrary)
  shrink obj | obj == default_IsUseridAvailable_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsUseridAvailable_args{isUseridAvailable_args_userid = isUseridAvailable_args_userid obj} then P.Nothing else P.Just $ default_IsUseridAvailable_args{isUseridAvailable_args_userid = isUseridAvailable_args_userid obj}
    ]
from_IsUseridAvailable_args :: IsUseridAvailable_args -> T.ThriftVal
from_IsUseridAvailable_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7751 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v7751))) $ isUseridAvailable_args_userid record
  ]
write_IsUseridAvailable_args :: T.Protocol p => p -> IsUseridAvailable_args -> P.IO ()
write_IsUseridAvailable_args oprot record = T.writeVal oprot $ from_IsUseridAvailable_args record
encode_IsUseridAvailable_args :: T.StatelessProtocol p => p -> IsUseridAvailable_args -> LBS.ByteString
encode_IsUseridAvailable_args oprot record = T.serializeVal oprot $ from_IsUseridAvailable_args record
to_IsUseridAvailable_args :: T.ThriftVal -> IsUseridAvailable_args
to_IsUseridAvailable_args (T.TStruct fields) = IsUseridAvailable_args{
  isUseridAvailable_args_userid = P.maybe (isUseridAvailable_args_userid default_IsUseridAvailable_args) (\(_,_val7753) -> (case _val7753 of {T.TString _val7754 -> E.decodeUtf8 _val7754; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsUseridAvailable_args _ = P.error "not a struct"
read_IsUseridAvailable_args :: T.Protocol p => p -> P.IO IsUseridAvailable_args
read_IsUseridAvailable_args iprot = to_IsUseridAvailable_args <$> T.readVal iprot (T.T_STRUCT typemap_IsUseridAvailable_args)
decode_IsUseridAvailable_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsUseridAvailable_args
decode_IsUseridAvailable_args iprot bs = to_IsUseridAvailable_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsUseridAvailable_args) bs
typemap_IsUseridAvailable_args :: T.TypeMap
typemap_IsUseridAvailable_args = Map.fromList [(2,("userid",T.T_STRING))]
default_IsUseridAvailable_args :: IsUseridAvailable_args
default_IsUseridAvailable_args = IsUseridAvailable_args{
  isUseridAvailable_args_userid = ""}
data IsUseridAvailable_result = IsUseridAvailable_result  { isUseridAvailable_result_success :: P.Bool
  , isUseridAvailable_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsUseridAvailable_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isUseridAvailable_result_success record   `H.hashWithSalt` isUseridAvailable_result_e record  
instance QC.Arbitrary IsUseridAvailable_result where 
  arbitrary = M.liftM IsUseridAvailable_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsUseridAvailable_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsUseridAvailable_result{isUseridAvailable_result_success = isUseridAvailable_result_success obj} then P.Nothing else P.Just $ default_IsUseridAvailable_result{isUseridAvailable_result_success = isUseridAvailable_result_success obj}
    , if obj == default_IsUseridAvailable_result{isUseridAvailable_result_e = isUseridAvailable_result_e obj} then P.Nothing else P.Just $ default_IsUseridAvailable_result{isUseridAvailable_result_e = isUseridAvailable_result_e obj}
    ]
from_IsUseridAvailable_result :: IsUseridAvailable_result -> T.ThriftVal
from_IsUseridAvailable_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7757 -> (1, ("e",from_TalkException _v7757))) <$> isUseridAvailable_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7757 -> P.Just (0, ("success",T.TBool _v7757))) $ isUseridAvailable_result_success record
    , (\_v7757 -> (1, ("e",from_TalkException _v7757))) <$> isUseridAvailable_result_e record
    ]
    )
write_IsUseridAvailable_result :: T.Protocol p => p -> IsUseridAvailable_result -> P.IO ()
write_IsUseridAvailable_result oprot record = T.writeVal oprot $ from_IsUseridAvailable_result record
encode_IsUseridAvailable_result :: T.StatelessProtocol p => p -> IsUseridAvailable_result -> LBS.ByteString
encode_IsUseridAvailable_result oprot record = T.serializeVal oprot $ from_IsUseridAvailable_result record
to_IsUseridAvailable_result :: T.ThriftVal -> IsUseridAvailable_result
to_IsUseridAvailable_result (T.TStruct fields) = IsUseridAvailable_result{
  isUseridAvailable_result_success = P.maybe (isUseridAvailable_result_success default_IsUseridAvailable_result) (\(_,_val7759) -> (case _val7759 of {T.TBool _val7760 -> _val7760; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isUseridAvailable_result_e = P.maybe (P.Nothing) (\(_,_val7759) -> P.Just (case _val7759 of {T.TStruct _val7761 -> (to_TalkException (T.TStruct _val7761)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsUseridAvailable_result _ = P.error "not a struct"
read_IsUseridAvailable_result :: T.Protocol p => p -> P.IO IsUseridAvailable_result
read_IsUseridAvailable_result iprot = to_IsUseridAvailable_result <$> T.readVal iprot (T.T_STRUCT typemap_IsUseridAvailable_result)
decode_IsUseridAvailable_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsUseridAvailable_result
decode_IsUseridAvailable_result iprot bs = to_IsUseridAvailable_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsUseridAvailable_result) bs
typemap_IsUseridAvailable_result :: T.TypeMap
typemap_IsUseridAvailable_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsUseridAvailable_result :: IsUseridAvailable_result
default_IsUseridAvailable_result = IsUseridAvailable_result{
  isUseridAvailable_result_success = P.False,
  isUseridAvailable_result_e = P.Nothing}
data KickoutFromGroup_args = KickoutFromGroup_args  { kickoutFromGroup_args_reqSeq :: I.Int32
  , kickoutFromGroup_args_groupId :: LT.Text
  , kickoutFromGroup_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KickoutFromGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` kickoutFromGroup_args_reqSeq record   `H.hashWithSalt` kickoutFromGroup_args_groupId record   `H.hashWithSalt` kickoutFromGroup_args_contactIds record  
instance QC.Arbitrary KickoutFromGroup_args where 
  arbitrary = M.liftM KickoutFromGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_KickoutFromGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_reqSeq = kickoutFromGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_reqSeq = kickoutFromGroup_args_reqSeq obj}
    , if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_groupId = kickoutFromGroup_args_groupId obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_groupId = kickoutFromGroup_args_groupId obj}
    , if obj == default_KickoutFromGroup_args{kickoutFromGroup_args_contactIds = kickoutFromGroup_args_contactIds obj} then P.Nothing else P.Just $ default_KickoutFromGroup_args{kickoutFromGroup_args_contactIds = kickoutFromGroup_args_contactIds obj}
    ]
from_KickoutFromGroup_args :: KickoutFromGroup_args -> T.ThriftVal
from_KickoutFromGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7764 -> P.Just (1, ("reqSeq",T.TI32 _v7764))) $ kickoutFromGroup_args_reqSeq record
  , (\_v7764 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v7764))) $ kickoutFromGroup_args_groupId record
  , (\_v7764 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v7766 -> T.TString $ E.encodeUtf8 _v7766) $ Vector.toList _v7764))) $ kickoutFromGroup_args_contactIds record
  ]
write_KickoutFromGroup_args :: T.Protocol p => p -> KickoutFromGroup_args -> P.IO ()
write_KickoutFromGroup_args oprot record = T.writeVal oprot $ from_KickoutFromGroup_args record
encode_KickoutFromGroup_args :: T.StatelessProtocol p => p -> KickoutFromGroup_args -> LBS.ByteString
encode_KickoutFromGroup_args oprot record = T.serializeVal oprot $ from_KickoutFromGroup_args record
to_KickoutFromGroup_args :: T.ThriftVal -> KickoutFromGroup_args
to_KickoutFromGroup_args (T.TStruct fields) = KickoutFromGroup_args{
  kickoutFromGroup_args_reqSeq = P.maybe (kickoutFromGroup_args_reqSeq default_KickoutFromGroup_args) (\(_,_val7768) -> (case _val7768 of {T.TI32 _val7769 -> _val7769; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  kickoutFromGroup_args_groupId = P.maybe (kickoutFromGroup_args_groupId default_KickoutFromGroup_args) (\(_,_val7768) -> (case _val7768 of {T.TString _val7770 -> E.decodeUtf8 _val7770; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  kickoutFromGroup_args_contactIds = P.maybe (kickoutFromGroup_args_contactIds default_KickoutFromGroup_args) (\(_,_val7768) -> (case _val7768 of {T.TList _ _val7771 -> (Vector.fromList $ P.map (\_v7772 -> (case _v7772 of {T.TString _val7773 -> E.decodeUtf8 _val7773; _ -> P.error "wrong type"})) _val7771); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_KickoutFromGroup_args _ = P.error "not a struct"
read_KickoutFromGroup_args :: T.Protocol p => p -> P.IO KickoutFromGroup_args
read_KickoutFromGroup_args iprot = to_KickoutFromGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_KickoutFromGroup_args)
decode_KickoutFromGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> KickoutFromGroup_args
decode_KickoutFromGroup_args iprot bs = to_KickoutFromGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_KickoutFromGroup_args) bs
typemap_KickoutFromGroup_args :: T.TypeMap
typemap_KickoutFromGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_KickoutFromGroup_args :: KickoutFromGroup_args
default_KickoutFromGroup_args = KickoutFromGroup_args{
  kickoutFromGroup_args_reqSeq = 0,
  kickoutFromGroup_args_groupId = "",
  kickoutFromGroup_args_contactIds = Vector.empty}
data KickoutFromGroup_result = KickoutFromGroup_result  { kickoutFromGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KickoutFromGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` kickoutFromGroup_result_e record  
instance QC.Arbitrary KickoutFromGroup_result where 
  arbitrary = M.liftM KickoutFromGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_KickoutFromGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KickoutFromGroup_result{kickoutFromGroup_result_e = kickoutFromGroup_result_e obj} then P.Nothing else P.Just $ default_KickoutFromGroup_result{kickoutFromGroup_result_e = kickoutFromGroup_result_e obj}
    ]
from_KickoutFromGroup_result :: KickoutFromGroup_result -> T.ThriftVal
from_KickoutFromGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7776 -> (1, ("e",from_TalkException _v7776))) <$> kickoutFromGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7776 -> (1, ("e",from_TalkException _v7776))) <$> kickoutFromGroup_result_e record
    ]
    )
write_KickoutFromGroup_result :: T.Protocol p => p -> KickoutFromGroup_result -> P.IO ()
write_KickoutFromGroup_result oprot record = T.writeVal oprot $ from_KickoutFromGroup_result record
encode_KickoutFromGroup_result :: T.StatelessProtocol p => p -> KickoutFromGroup_result -> LBS.ByteString
encode_KickoutFromGroup_result oprot record = T.serializeVal oprot $ from_KickoutFromGroup_result record
to_KickoutFromGroup_result :: T.ThriftVal -> KickoutFromGroup_result
to_KickoutFromGroup_result (T.TStruct fields) = KickoutFromGroup_result{
  kickoutFromGroup_result_e = P.maybe (P.Nothing) (\(_,_val7778) -> P.Just (case _val7778 of {T.TStruct _val7779 -> (to_TalkException (T.TStruct _val7779)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_KickoutFromGroup_result _ = P.error "not a struct"
read_KickoutFromGroup_result :: T.Protocol p => p -> P.IO KickoutFromGroup_result
read_KickoutFromGroup_result iprot = to_KickoutFromGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_KickoutFromGroup_result)
decode_KickoutFromGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> KickoutFromGroup_result
decode_KickoutFromGroup_result iprot bs = to_KickoutFromGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_KickoutFromGroup_result) bs
typemap_KickoutFromGroup_result :: T.TypeMap
typemap_KickoutFromGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_KickoutFromGroup_result :: KickoutFromGroup_result
default_KickoutFromGroup_result = KickoutFromGroup_result{
  kickoutFromGroup_result_e = P.Nothing}
data ReissueGroupTicket_args = ReissueGroupTicket_args  { reissueGroupTicket_args_groupMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueGroupTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueGroupTicket_args_groupMid record  
instance QC.Arbitrary ReissueGroupTicket_args where 
  arbitrary = M.liftM ReissueGroupTicket_args (QC.arbitrary)
  shrink obj | obj == default_ReissueGroupTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueGroupTicket_args{reissueGroupTicket_args_groupMid = reissueGroupTicket_args_groupMid obj} then P.Nothing else P.Just $ default_ReissueGroupTicket_args{reissueGroupTicket_args_groupMid = reissueGroupTicket_args_groupMid obj}
    ]
from_ReissueGroupTicket_args :: ReissueGroupTicket_args -> T.ThriftVal
from_ReissueGroupTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7782 -> P.Just (1, ("groupMid",T.TString $ E.encodeUtf8 _v7782))) $ reissueGroupTicket_args_groupMid record
  ]
write_ReissueGroupTicket_args :: T.Protocol p => p -> ReissueGroupTicket_args -> P.IO ()
write_ReissueGroupTicket_args oprot record = T.writeVal oprot $ from_ReissueGroupTicket_args record
encode_ReissueGroupTicket_args :: T.StatelessProtocol p => p -> ReissueGroupTicket_args -> LBS.ByteString
encode_ReissueGroupTicket_args oprot record = T.serializeVal oprot $ from_ReissueGroupTicket_args record
to_ReissueGroupTicket_args :: T.ThriftVal -> ReissueGroupTicket_args
to_ReissueGroupTicket_args (T.TStruct fields) = ReissueGroupTicket_args{
  reissueGroupTicket_args_groupMid = P.maybe (reissueGroupTicket_args_groupMid default_ReissueGroupTicket_args) (\(_,_val7784) -> (case _val7784 of {T.TString _val7785 -> E.decodeUtf8 _val7785; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueGroupTicket_args _ = P.error "not a struct"
read_ReissueGroupTicket_args :: T.Protocol p => p -> P.IO ReissueGroupTicket_args
read_ReissueGroupTicket_args iprot = to_ReissueGroupTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_ReissueGroupTicket_args)
decode_ReissueGroupTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueGroupTicket_args
decode_ReissueGroupTicket_args iprot bs = to_ReissueGroupTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueGroupTicket_args) bs
typemap_ReissueGroupTicket_args :: T.TypeMap
typemap_ReissueGroupTicket_args = Map.fromList [(1,("groupMid",T.T_STRING))]
default_ReissueGroupTicket_args :: ReissueGroupTicket_args
default_ReissueGroupTicket_args = ReissueGroupTicket_args{
  reissueGroupTicket_args_groupMid = ""}
data ReissueGroupTicket_result = ReissueGroupTicket_result  { reissueGroupTicket_result_success :: LT.Text
  , reissueGroupTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueGroupTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueGroupTicket_result_success record   `H.hashWithSalt` reissueGroupTicket_result_e record  
instance QC.Arbitrary ReissueGroupTicket_result where 
  arbitrary = M.liftM ReissueGroupTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReissueGroupTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueGroupTicket_result{reissueGroupTicket_result_success = reissueGroupTicket_result_success obj} then P.Nothing else P.Just $ default_ReissueGroupTicket_result{reissueGroupTicket_result_success = reissueGroupTicket_result_success obj}
    , if obj == default_ReissueGroupTicket_result{reissueGroupTicket_result_e = reissueGroupTicket_result_e obj} then P.Nothing else P.Just $ default_ReissueGroupTicket_result{reissueGroupTicket_result_e = reissueGroupTicket_result_e obj}
    ]
from_ReissueGroupTicket_result :: ReissueGroupTicket_result -> T.ThriftVal
from_ReissueGroupTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7788 -> (1, ("e",from_TalkException _v7788))) <$> reissueGroupTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7788 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v7788))) $ reissueGroupTicket_result_success record
    , (\_v7788 -> (1, ("e",from_TalkException _v7788))) <$> reissueGroupTicket_result_e record
    ]
    )
write_ReissueGroupTicket_result :: T.Protocol p => p -> ReissueGroupTicket_result -> P.IO ()
write_ReissueGroupTicket_result oprot record = T.writeVal oprot $ from_ReissueGroupTicket_result record
encode_ReissueGroupTicket_result :: T.StatelessProtocol p => p -> ReissueGroupTicket_result -> LBS.ByteString
encode_ReissueGroupTicket_result oprot record = T.serializeVal oprot $ from_ReissueGroupTicket_result record
to_ReissueGroupTicket_result :: T.ThriftVal -> ReissueGroupTicket_result
to_ReissueGroupTicket_result (T.TStruct fields) = ReissueGroupTicket_result{
  reissueGroupTicket_result_success = P.maybe (reissueGroupTicket_result_success default_ReissueGroupTicket_result) (\(_,_val7790) -> (case _val7790 of {T.TString _val7791 -> E.decodeUtf8 _val7791; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reissueGroupTicket_result_e = P.maybe (P.Nothing) (\(_,_val7790) -> P.Just (case _val7790 of {T.TStruct _val7792 -> (to_TalkException (T.TStruct _val7792)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueGroupTicket_result _ = P.error "not a struct"
read_ReissueGroupTicket_result :: T.Protocol p => p -> P.IO ReissueGroupTicket_result
read_ReissueGroupTicket_result iprot = to_ReissueGroupTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_ReissueGroupTicket_result)
decode_ReissueGroupTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueGroupTicket_result
decode_ReissueGroupTicket_result iprot bs = to_ReissueGroupTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueGroupTicket_result) bs
typemap_ReissueGroupTicket_result :: T.TypeMap
typemap_ReissueGroupTicket_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReissueGroupTicket_result :: ReissueGroupTicket_result
default_ReissueGroupTicket_result = ReissueGroupTicket_result{
  reissueGroupTicket_result_success = "",
  reissueGroupTicket_result_e = P.Nothing}
data FindGroupByTicket_args = FindGroupByTicket_args  { findGroupByTicket_args_ticketId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindGroupByTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findGroupByTicket_args_ticketId record  
instance QC.Arbitrary FindGroupByTicket_args where 
  arbitrary = M.liftM FindGroupByTicket_args (QC.arbitrary)
  shrink obj | obj == default_FindGroupByTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindGroupByTicket_args{findGroupByTicket_args_ticketId = findGroupByTicket_args_ticketId obj} then P.Nothing else P.Just $ default_FindGroupByTicket_args{findGroupByTicket_args_ticketId = findGroupByTicket_args_ticketId obj}
    ]
from_FindGroupByTicket_args :: FindGroupByTicket_args -> T.ThriftVal
from_FindGroupByTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7795 -> P.Just (1, ("ticketId",T.TString $ E.encodeUtf8 _v7795))) $ findGroupByTicket_args_ticketId record
  ]
write_FindGroupByTicket_args :: T.Protocol p => p -> FindGroupByTicket_args -> P.IO ()
write_FindGroupByTicket_args oprot record = T.writeVal oprot $ from_FindGroupByTicket_args record
encode_FindGroupByTicket_args :: T.StatelessProtocol p => p -> FindGroupByTicket_args -> LBS.ByteString
encode_FindGroupByTicket_args oprot record = T.serializeVal oprot $ from_FindGroupByTicket_args record
to_FindGroupByTicket_args :: T.ThriftVal -> FindGroupByTicket_args
to_FindGroupByTicket_args (T.TStruct fields) = FindGroupByTicket_args{
  findGroupByTicket_args_ticketId = P.maybe (findGroupByTicket_args_ticketId default_FindGroupByTicket_args) (\(_,_val7797) -> (case _val7797 of {T.TString _val7798 -> E.decodeUtf8 _val7798; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindGroupByTicket_args _ = P.error "not a struct"
read_FindGroupByTicket_args :: T.Protocol p => p -> P.IO FindGroupByTicket_args
read_FindGroupByTicket_args iprot = to_FindGroupByTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_FindGroupByTicket_args)
decode_FindGroupByTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindGroupByTicket_args
decode_FindGroupByTicket_args iprot bs = to_FindGroupByTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindGroupByTicket_args) bs
typemap_FindGroupByTicket_args :: T.TypeMap
typemap_FindGroupByTicket_args = Map.fromList [(1,("ticketId",T.T_STRING))]
default_FindGroupByTicket_args :: FindGroupByTicket_args
default_FindGroupByTicket_args = FindGroupByTicket_args{
  findGroupByTicket_args_ticketId = ""}
data FindGroupByTicket_result = FindGroupByTicket_result  { findGroupByTicket_result_success :: Group
  , findGroupByTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindGroupByTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findGroupByTicket_result_success record   `H.hashWithSalt` findGroupByTicket_result_e record  
instance QC.Arbitrary FindGroupByTicket_result where 
  arbitrary = M.liftM FindGroupByTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindGroupByTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindGroupByTicket_result{findGroupByTicket_result_success = findGroupByTicket_result_success obj} then P.Nothing else P.Just $ default_FindGroupByTicket_result{findGroupByTicket_result_success = findGroupByTicket_result_success obj}
    , if obj == default_FindGroupByTicket_result{findGroupByTicket_result_e = findGroupByTicket_result_e obj} then P.Nothing else P.Just $ default_FindGroupByTicket_result{findGroupByTicket_result_e = findGroupByTicket_result_e obj}
    ]
from_FindGroupByTicket_result :: FindGroupByTicket_result -> T.ThriftVal
from_FindGroupByTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7801 -> (1, ("e",from_TalkException _v7801))) <$> findGroupByTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7801 -> P.Just (0, ("success",from_Group _v7801))) $ findGroupByTicket_result_success record
    , (\_v7801 -> (1, ("e",from_TalkException _v7801))) <$> findGroupByTicket_result_e record
    ]
    )
write_FindGroupByTicket_result :: T.Protocol p => p -> FindGroupByTicket_result -> P.IO ()
write_FindGroupByTicket_result oprot record = T.writeVal oprot $ from_FindGroupByTicket_result record
encode_FindGroupByTicket_result :: T.StatelessProtocol p => p -> FindGroupByTicket_result -> LBS.ByteString
encode_FindGroupByTicket_result oprot record = T.serializeVal oprot $ from_FindGroupByTicket_result record
to_FindGroupByTicket_result :: T.ThriftVal -> FindGroupByTicket_result
to_FindGroupByTicket_result (T.TStruct fields) = FindGroupByTicket_result{
  findGroupByTicket_result_success = P.maybe (findGroupByTicket_result_success default_FindGroupByTicket_result) (\(_,_val7803) -> (case _val7803 of {T.TStruct _val7804 -> (to_Group (T.TStruct _val7804)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findGroupByTicket_result_e = P.maybe (P.Nothing) (\(_,_val7803) -> P.Just (case _val7803 of {T.TStruct _val7805 -> (to_TalkException (T.TStruct _val7805)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindGroupByTicket_result _ = P.error "not a struct"
read_FindGroupByTicket_result :: T.Protocol p => p -> P.IO FindGroupByTicket_result
read_FindGroupByTicket_result iprot = to_FindGroupByTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_FindGroupByTicket_result)
decode_FindGroupByTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindGroupByTicket_result
decode_FindGroupByTicket_result iprot bs = to_FindGroupByTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindGroupByTicket_result) bs
typemap_FindGroupByTicket_result :: T.TypeMap
typemap_FindGroupByTicket_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Group))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindGroupByTicket_result :: FindGroupByTicket_result
default_FindGroupByTicket_result = FindGroupByTicket_result{
  findGroupByTicket_result_success = default_Group,
  findGroupByTicket_result_e = P.Nothing}
data LeaveGroup_args = LeaveGroup_args  { leaveGroup_args_reqSeq :: I.Int32
  , leaveGroup_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveGroup_args_reqSeq record   `H.hashWithSalt` leaveGroup_args_groupId record  
instance QC.Arbitrary LeaveGroup_args where 
  arbitrary = M.liftM LeaveGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LeaveGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveGroup_args{leaveGroup_args_reqSeq = leaveGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_LeaveGroup_args{leaveGroup_args_reqSeq = leaveGroup_args_reqSeq obj}
    , if obj == default_LeaveGroup_args{leaveGroup_args_groupId = leaveGroup_args_groupId obj} then P.Nothing else P.Just $ default_LeaveGroup_args{leaveGroup_args_groupId = leaveGroup_args_groupId obj}
    ]
from_LeaveGroup_args :: LeaveGroup_args -> T.ThriftVal
from_LeaveGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7808 -> P.Just (1, ("reqSeq",T.TI32 _v7808))) $ leaveGroup_args_reqSeq record
  , (\_v7808 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v7808))) $ leaveGroup_args_groupId record
  ]
write_LeaveGroup_args :: T.Protocol p => p -> LeaveGroup_args -> P.IO ()
write_LeaveGroup_args oprot record = T.writeVal oprot $ from_LeaveGroup_args record
encode_LeaveGroup_args :: T.StatelessProtocol p => p -> LeaveGroup_args -> LBS.ByteString
encode_LeaveGroup_args oprot record = T.serializeVal oprot $ from_LeaveGroup_args record
to_LeaveGroup_args :: T.ThriftVal -> LeaveGroup_args
to_LeaveGroup_args (T.TStruct fields) = LeaveGroup_args{
  leaveGroup_args_reqSeq = P.maybe (leaveGroup_args_reqSeq default_LeaveGroup_args) (\(_,_val7810) -> (case _val7810 of {T.TI32 _val7811 -> _val7811; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  leaveGroup_args_groupId = P.maybe (leaveGroup_args_groupId default_LeaveGroup_args) (\(_,_val7810) -> (case _val7810 of {T.TString _val7812 -> E.decodeUtf8 _val7812; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LeaveGroup_args _ = P.error "not a struct"
read_LeaveGroup_args :: T.Protocol p => p -> P.IO LeaveGroup_args
read_LeaveGroup_args iprot = to_LeaveGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveGroup_args)
decode_LeaveGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveGroup_args
decode_LeaveGroup_args iprot bs = to_LeaveGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveGroup_args) bs
typemap_LeaveGroup_args :: T.TypeMap
typemap_LeaveGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_LeaveGroup_args :: LeaveGroup_args
default_LeaveGroup_args = LeaveGroup_args{
  leaveGroup_args_reqSeq = 0,
  leaveGroup_args_groupId = ""}
data LeaveGroup_result = LeaveGroup_result  { leaveGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveGroup_result_e record  
instance QC.Arbitrary LeaveGroup_result where 
  arbitrary = M.liftM LeaveGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveGroup_result{leaveGroup_result_e = leaveGroup_result_e obj} then P.Nothing else P.Just $ default_LeaveGroup_result{leaveGroup_result_e = leaveGroup_result_e obj}
    ]
from_LeaveGroup_result :: LeaveGroup_result -> T.ThriftVal
from_LeaveGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7815 -> (1, ("e",from_TalkException _v7815))) <$> leaveGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7815 -> (1, ("e",from_TalkException _v7815))) <$> leaveGroup_result_e record
    ]
    )
write_LeaveGroup_result :: T.Protocol p => p -> LeaveGroup_result -> P.IO ()
write_LeaveGroup_result oprot record = T.writeVal oprot $ from_LeaveGroup_result record
encode_LeaveGroup_result :: T.StatelessProtocol p => p -> LeaveGroup_result -> LBS.ByteString
encode_LeaveGroup_result oprot record = T.serializeVal oprot $ from_LeaveGroup_result record
to_LeaveGroup_result :: T.ThriftVal -> LeaveGroup_result
to_LeaveGroup_result (T.TStruct fields) = LeaveGroup_result{
  leaveGroup_result_e = P.maybe (P.Nothing) (\(_,_val7817) -> P.Just (case _val7817 of {T.TStruct _val7818 -> (to_TalkException (T.TStruct _val7818)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveGroup_result _ = P.error "not a struct"
read_LeaveGroup_result :: T.Protocol p => p -> P.IO LeaveGroup_result
read_LeaveGroup_result iprot = to_LeaveGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveGroup_result)
decode_LeaveGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveGroup_result
decode_LeaveGroup_result iprot bs = to_LeaveGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveGroup_result) bs
typemap_LeaveGroup_result :: T.TypeMap
typemap_LeaveGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LeaveGroup_result :: LeaveGroup_result
default_LeaveGroup_result = LeaveGroup_result{
  leaveGroup_result_e = P.Nothing}
data LeaveRoom_args = LeaveRoom_args  { leaveRoom_args_reqSeq :: I.Int32
  , leaveRoom_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveRoom_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveRoom_args_reqSeq record   `H.hashWithSalt` leaveRoom_args_roomId record  
instance QC.Arbitrary LeaveRoom_args where 
  arbitrary = M.liftM LeaveRoom_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LeaveRoom_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveRoom_args{leaveRoom_args_reqSeq = leaveRoom_args_reqSeq obj} then P.Nothing else P.Just $ default_LeaveRoom_args{leaveRoom_args_reqSeq = leaveRoom_args_reqSeq obj}
    , if obj == default_LeaveRoom_args{leaveRoom_args_roomId = leaveRoom_args_roomId obj} then P.Nothing else P.Just $ default_LeaveRoom_args{leaveRoom_args_roomId = leaveRoom_args_roomId obj}
    ]
from_LeaveRoom_args :: LeaveRoom_args -> T.ThriftVal
from_LeaveRoom_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7821 -> P.Just (1, ("reqSeq",T.TI32 _v7821))) $ leaveRoom_args_reqSeq record
  , (\_v7821 -> P.Just (2, ("roomId",T.TString $ E.encodeUtf8 _v7821))) $ leaveRoom_args_roomId record
  ]
write_LeaveRoom_args :: T.Protocol p => p -> LeaveRoom_args -> P.IO ()
write_LeaveRoom_args oprot record = T.writeVal oprot $ from_LeaveRoom_args record
encode_LeaveRoom_args :: T.StatelessProtocol p => p -> LeaveRoom_args -> LBS.ByteString
encode_LeaveRoom_args oprot record = T.serializeVal oprot $ from_LeaveRoom_args record
to_LeaveRoom_args :: T.ThriftVal -> LeaveRoom_args
to_LeaveRoom_args (T.TStruct fields) = LeaveRoom_args{
  leaveRoom_args_reqSeq = P.maybe (leaveRoom_args_reqSeq default_LeaveRoom_args) (\(_,_val7823) -> (case _val7823 of {T.TI32 _val7824 -> _val7824; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  leaveRoom_args_roomId = P.maybe (leaveRoom_args_roomId default_LeaveRoom_args) (\(_,_val7823) -> (case _val7823 of {T.TString _val7825 -> E.decodeUtf8 _val7825; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LeaveRoom_args _ = P.error "not a struct"
read_LeaveRoom_args :: T.Protocol p => p -> P.IO LeaveRoom_args
read_LeaveRoom_args iprot = to_LeaveRoom_args <$> T.readVal iprot (T.T_STRUCT typemap_LeaveRoom_args)
decode_LeaveRoom_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveRoom_args
decode_LeaveRoom_args iprot bs = to_LeaveRoom_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveRoom_args) bs
typemap_LeaveRoom_args :: T.TypeMap
typemap_LeaveRoom_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("roomId",T.T_STRING))]
default_LeaveRoom_args :: LeaveRoom_args
default_LeaveRoom_args = LeaveRoom_args{
  leaveRoom_args_reqSeq = 0,
  leaveRoom_args_roomId = ""}
data LeaveRoom_result = LeaveRoom_result  { leaveRoom_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LeaveRoom_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` leaveRoom_result_e record  
instance QC.Arbitrary LeaveRoom_result where 
  arbitrary = M.liftM LeaveRoom_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LeaveRoom_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LeaveRoom_result{leaveRoom_result_e = leaveRoom_result_e obj} then P.Nothing else P.Just $ default_LeaveRoom_result{leaveRoom_result_e = leaveRoom_result_e obj}
    ]
from_LeaveRoom_result :: LeaveRoom_result -> T.ThriftVal
from_LeaveRoom_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7828 -> (1, ("e",from_TalkException _v7828))) <$> leaveRoom_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7828 -> (1, ("e",from_TalkException _v7828))) <$> leaveRoom_result_e record
    ]
    )
write_LeaveRoom_result :: T.Protocol p => p -> LeaveRoom_result -> P.IO ()
write_LeaveRoom_result oprot record = T.writeVal oprot $ from_LeaveRoom_result record
encode_LeaveRoom_result :: T.StatelessProtocol p => p -> LeaveRoom_result -> LBS.ByteString
encode_LeaveRoom_result oprot record = T.serializeVal oprot $ from_LeaveRoom_result record
to_LeaveRoom_result :: T.ThriftVal -> LeaveRoom_result
to_LeaveRoom_result (T.TStruct fields) = LeaveRoom_result{
  leaveRoom_result_e = P.maybe (P.Nothing) (\(_,_val7830) -> P.Just (case _val7830 of {T.TStruct _val7831 -> (to_TalkException (T.TStruct _val7831)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LeaveRoom_result _ = P.error "not a struct"
read_LeaveRoom_result :: T.Protocol p => p -> P.IO LeaveRoom_result
read_LeaveRoom_result iprot = to_LeaveRoom_result <$> T.readVal iprot (T.T_STRUCT typemap_LeaveRoom_result)
decode_LeaveRoom_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LeaveRoom_result
decode_LeaveRoom_result iprot bs = to_LeaveRoom_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LeaveRoom_result) bs
typemap_LeaveRoom_result :: T.TypeMap
typemap_LeaveRoom_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LeaveRoom_result :: LeaveRoom_result
default_LeaveRoom_result = LeaveRoom_result{
  leaveRoom_result_e = P.Nothing}
data LoginWithIdentityCredential_args = LoginWithIdentityCredential_args  { loginWithIdentityCredential_args_identityProvider :: IdentityProvider
  , loginWithIdentityCredential_args_identifier :: LT.Text
  , loginWithIdentityCredential_args_password :: LT.Text
  , loginWithIdentityCredential_args_keepLoggedIn :: P.Bool
  , loginWithIdentityCredential_args_accessLocation :: LT.Text
  , loginWithIdentityCredential_args_systemName :: LT.Text
  , loginWithIdentityCredential_args_certificate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredential_args_identityProvider record   `H.hashWithSalt` loginWithIdentityCredential_args_identifier record   `H.hashWithSalt` loginWithIdentityCredential_args_password record   `H.hashWithSalt` loginWithIdentityCredential_args_keepLoggedIn record   `H.hashWithSalt` loginWithIdentityCredential_args_accessLocation record   `H.hashWithSalt` loginWithIdentityCredential_args_systemName record   `H.hashWithSalt` loginWithIdentityCredential_args_certificate record  
instance QC.Arbitrary LoginWithIdentityCredential_args where 
  arbitrary = M.liftM LoginWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identityProvider = loginWithIdentityCredential_args_identityProvider obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identityProvider = loginWithIdentityCredential_args_identityProvider obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identifier = loginWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_identifier = loginWithIdentityCredential_args_identifier obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_password = loginWithIdentityCredential_args_password obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_password = loginWithIdentityCredential_args_password obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_keepLoggedIn = loginWithIdentityCredential_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_keepLoggedIn = loginWithIdentityCredential_args_keepLoggedIn obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_accessLocation = loginWithIdentityCredential_args_accessLocation obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_accessLocation = loginWithIdentityCredential_args_accessLocation obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_systemName = loginWithIdentityCredential_args_systemName obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_systemName = loginWithIdentityCredential_args_systemName obj}
    , if obj == default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_certificate = loginWithIdentityCredential_args_certificate obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_args{loginWithIdentityCredential_args_certificate = loginWithIdentityCredential_args_certificate obj}
    ]
from_LoginWithIdentityCredential_args :: LoginWithIdentityCredential_args -> T.ThriftVal
from_LoginWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7834 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v7834))) $ loginWithIdentityCredential_args_identifier record
  , (\_v7834 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v7834))) $ loginWithIdentityCredential_args_password record
  , (\_v7834 -> P.Just (5, ("keepLoggedIn",T.TBool _v7834))) $ loginWithIdentityCredential_args_keepLoggedIn record
  , (\_v7834 -> P.Just (6, ("accessLocation",T.TString $ E.encodeUtf8 _v7834))) $ loginWithIdentityCredential_args_accessLocation record
  , (\_v7834 -> P.Just (7, ("systemName",T.TString $ E.encodeUtf8 _v7834))) $ loginWithIdentityCredential_args_systemName record
  , (\_v7834 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v7834))) $ loginWithIdentityCredential_args_identityProvider record
  , (\_v7834 -> P.Just (9, ("certificate",T.TString $ E.encodeUtf8 _v7834))) $ loginWithIdentityCredential_args_certificate record
  ]
write_LoginWithIdentityCredential_args :: T.Protocol p => p -> LoginWithIdentityCredential_args -> P.IO ()
write_LoginWithIdentityCredential_args oprot record = T.writeVal oprot $ from_LoginWithIdentityCredential_args record
encode_LoginWithIdentityCredential_args :: T.StatelessProtocol p => p -> LoginWithIdentityCredential_args -> LBS.ByteString
encode_LoginWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredential_args record
to_LoginWithIdentityCredential_args :: T.ThriftVal -> LoginWithIdentityCredential_args
to_LoginWithIdentityCredential_args (T.TStruct fields) = LoginWithIdentityCredential_args{
  loginWithIdentityCredential_args_identityProvider = P.maybe (loginWithIdentityCredential_args_identityProvider default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TI32 _val7837 -> P.toEnum $ P.fromIntegral _val7837; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  loginWithIdentityCredential_args_identifier = P.maybe (loginWithIdentityCredential_args_identifier default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TString _val7838 -> E.decodeUtf8 _val7838; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginWithIdentityCredential_args_password = P.maybe (loginWithIdentityCredential_args_password default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TString _val7839 -> E.decodeUtf8 _val7839; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginWithIdentityCredential_args_keepLoggedIn = P.maybe (loginWithIdentityCredential_args_keepLoggedIn default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TBool _val7840 -> _val7840; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginWithIdentityCredential_args_accessLocation = P.maybe (loginWithIdentityCredential_args_accessLocation default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TString _val7841 -> E.decodeUtf8 _val7841; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginWithIdentityCredential_args_systemName = P.maybe (loginWithIdentityCredential_args_systemName default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TString _val7842 -> E.decodeUtf8 _val7842; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginWithIdentityCredential_args_certificate = P.maybe (loginWithIdentityCredential_args_certificate default_LoginWithIdentityCredential_args) (\(_,_val7836) -> (case _val7836 of {T.TString _val7843 -> E.decodeUtf8 _val7843; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_LoginWithIdentityCredential_args _ = P.error "not a struct"
read_LoginWithIdentityCredential_args :: T.Protocol p => p -> P.IO LoginWithIdentityCredential_args
read_LoginWithIdentityCredential_args iprot = to_LoginWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_args)
decode_LoginWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredential_args
decode_LoginWithIdentityCredential_args iprot bs = to_LoginWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_args) bs
typemap_LoginWithIdentityCredential_args :: T.TypeMap
typemap_LoginWithIdentityCredential_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(5,("keepLoggedIn",T.T_BOOL)),(6,("accessLocation",T.T_STRING)),(7,("systemName",T.T_STRING)),(8,("identityProvider",T.T_I32)),(9,("certificate",T.T_STRING))]
default_LoginWithIdentityCredential_args :: LoginWithIdentityCredential_args
default_LoginWithIdentityCredential_args = LoginWithIdentityCredential_args{
  loginWithIdentityCredential_args_identifier = "",
  loginWithIdentityCredential_args_password = "",
  loginWithIdentityCredential_args_keepLoggedIn = P.False,
  loginWithIdentityCredential_args_accessLocation = "",
  loginWithIdentityCredential_args_systemName = "",
  loginWithIdentityCredential_args_identityProvider = (P.toEnum 0),
  loginWithIdentityCredential_args_certificate = ""}
data LoginWithIdentityCredential_result = LoginWithIdentityCredential_result  { loginWithIdentityCredential_result_success :: LT.Text
  , loginWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredential_result_success record   `H.hashWithSalt` loginWithIdentityCredential_result_e record  
instance QC.Arbitrary LoginWithIdentityCredential_result where 
  arbitrary = M.liftM LoginWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = loginWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = loginWithIdentityCredential_result_success obj}
    , if obj == default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = loginWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = loginWithIdentityCredential_result_e obj}
    ]
from_LoginWithIdentityCredential_result :: LoginWithIdentityCredential_result -> T.ThriftVal
from_LoginWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7846 -> (1, ("e",from_TalkException _v7846))) <$> loginWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7846 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v7846))) $ loginWithIdentityCredential_result_success record
    , (\_v7846 -> (1, ("e",from_TalkException _v7846))) <$> loginWithIdentityCredential_result_e record
    ]
    )
write_LoginWithIdentityCredential_result :: T.Protocol p => p -> LoginWithIdentityCredential_result -> P.IO ()
write_LoginWithIdentityCredential_result oprot record = T.writeVal oprot $ from_LoginWithIdentityCredential_result record
encode_LoginWithIdentityCredential_result :: T.StatelessProtocol p => p -> LoginWithIdentityCredential_result -> LBS.ByteString
encode_LoginWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredential_result record
to_LoginWithIdentityCredential_result :: T.ThriftVal -> LoginWithIdentityCredential_result
to_LoginWithIdentityCredential_result (T.TStruct fields) = LoginWithIdentityCredential_result{
  loginWithIdentityCredential_result_success = P.maybe (loginWithIdentityCredential_result_success default_LoginWithIdentityCredential_result) (\(_,_val7848) -> (case _val7848 of {T.TString _val7849 -> E.decodeUtf8 _val7849; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val7848) -> P.Just (case _val7848 of {T.TStruct _val7850 -> (to_TalkException (T.TStruct _val7850)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithIdentityCredential_result _ = P.error "not a struct"
read_LoginWithIdentityCredential_result :: T.Protocol p => p -> P.IO LoginWithIdentityCredential_result
read_LoginWithIdentityCredential_result iprot = to_LoginWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_result)
decode_LoginWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredential_result
decode_LoginWithIdentityCredential_result iprot bs = to_LoginWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredential_result) bs
typemap_LoginWithIdentityCredential_result :: T.TypeMap
typemap_LoginWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithIdentityCredential_result :: LoginWithIdentityCredential_result
default_LoginWithIdentityCredential_result = LoginWithIdentityCredential_result{
  loginWithIdentityCredential_result_success = "",
  loginWithIdentityCredential_result_e = P.Nothing}
data LoginWithIdentityCredentialForCertificate_args = LoginWithIdentityCredentialForCertificate_args  { loginWithIdentityCredentialForCertificate_args_identityProvider :: IdentityProvider
  , loginWithIdentityCredentialForCertificate_args_identifier :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_password :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_keepLoggedIn :: P.Bool
  , loginWithIdentityCredentialForCertificate_args_accessLocation :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_systemName :: LT.Text
  , loginWithIdentityCredentialForCertificate_args_certificate :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredentialForCertificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_identityProvider record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_identifier record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_password record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_keepLoggedIn record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_accessLocation record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_systemName record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_args_certificate record  
instance QC.Arbitrary LoginWithIdentityCredentialForCertificate_args where 
  arbitrary = M.liftM LoginWithIdentityCredentialForCertificate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredentialForCertificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identityProvider = loginWithIdentityCredentialForCertificate_args_identityProvider obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identityProvider = loginWithIdentityCredentialForCertificate_args_identityProvider obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identifier = loginWithIdentityCredentialForCertificate_args_identifier obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_identifier = loginWithIdentityCredentialForCertificate_args_identifier obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_password = loginWithIdentityCredentialForCertificate_args_password obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_password = loginWithIdentityCredentialForCertificate_args_password obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_keepLoggedIn = loginWithIdentityCredentialForCertificate_args_keepLoggedIn obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_keepLoggedIn = loginWithIdentityCredentialForCertificate_args_keepLoggedIn obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_accessLocation = loginWithIdentityCredentialForCertificate_args_accessLocation obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_accessLocation = loginWithIdentityCredentialForCertificate_args_accessLocation obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_systemName = loginWithIdentityCredentialForCertificate_args_systemName obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_systemName = loginWithIdentityCredentialForCertificate_args_systemName obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_certificate = loginWithIdentityCredentialForCertificate_args_certificate obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_args{loginWithIdentityCredentialForCertificate_args_certificate = loginWithIdentityCredentialForCertificate_args_certificate obj}
    ]
from_LoginWithIdentityCredentialForCertificate_args :: LoginWithIdentityCredentialForCertificate_args -> T.ThriftVal
from_LoginWithIdentityCredentialForCertificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7853 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v7853))) $ loginWithIdentityCredentialForCertificate_args_identifier record
  , (\_v7853 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v7853))) $ loginWithIdentityCredentialForCertificate_args_password record
  , (\_v7853 -> P.Just (5, ("keepLoggedIn",T.TBool _v7853))) $ loginWithIdentityCredentialForCertificate_args_keepLoggedIn record
  , (\_v7853 -> P.Just (6, ("accessLocation",T.TString $ E.encodeUtf8 _v7853))) $ loginWithIdentityCredentialForCertificate_args_accessLocation record
  , (\_v7853 -> P.Just (7, ("systemName",T.TString $ E.encodeUtf8 _v7853))) $ loginWithIdentityCredentialForCertificate_args_systemName record
  , (\_v7853 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v7853))) $ loginWithIdentityCredentialForCertificate_args_identityProvider record
  , (\_v7853 -> P.Just (9, ("certificate",T.TString $ E.encodeUtf8 _v7853))) $ loginWithIdentityCredentialForCertificate_args_certificate record
  ]
write_LoginWithIdentityCredentialForCertificate_args :: T.Protocol p => p -> LoginWithIdentityCredentialForCertificate_args -> P.IO ()
write_LoginWithIdentityCredentialForCertificate_args oprot record = T.writeVal oprot $ from_LoginWithIdentityCredentialForCertificate_args record
encode_LoginWithIdentityCredentialForCertificate_args :: T.StatelessProtocol p => p -> LoginWithIdentityCredentialForCertificate_args -> LBS.ByteString
encode_LoginWithIdentityCredentialForCertificate_args oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredentialForCertificate_args record
to_LoginWithIdentityCredentialForCertificate_args :: T.ThriftVal -> LoginWithIdentityCredentialForCertificate_args
to_LoginWithIdentityCredentialForCertificate_args (T.TStruct fields) = LoginWithIdentityCredentialForCertificate_args{
  loginWithIdentityCredentialForCertificate_args_identityProvider = P.maybe (loginWithIdentityCredentialForCertificate_args_identityProvider default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TI32 _val7856 -> P.toEnum $ P.fromIntegral _val7856; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  loginWithIdentityCredentialForCertificate_args_identifier = P.maybe (loginWithIdentityCredentialForCertificate_args_identifier default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TString _val7857 -> E.decodeUtf8 _val7857; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  loginWithIdentityCredentialForCertificate_args_password = P.maybe (loginWithIdentityCredentialForCertificate_args_password default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TString _val7858 -> E.decodeUtf8 _val7858; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  loginWithIdentityCredentialForCertificate_args_keepLoggedIn = P.maybe (loginWithIdentityCredentialForCertificate_args_keepLoggedIn default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TBool _val7859 -> _val7859; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  loginWithIdentityCredentialForCertificate_args_accessLocation = P.maybe (loginWithIdentityCredentialForCertificate_args_accessLocation default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TString _val7860 -> E.decodeUtf8 _val7860; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  loginWithIdentityCredentialForCertificate_args_systemName = P.maybe (loginWithIdentityCredentialForCertificate_args_systemName default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TString _val7861 -> E.decodeUtf8 _val7861; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  loginWithIdentityCredentialForCertificate_args_certificate = P.maybe (loginWithIdentityCredentialForCertificate_args_certificate default_LoginWithIdentityCredentialForCertificate_args) (\(_,_val7855) -> (case _val7855 of {T.TString _val7862 -> E.decodeUtf8 _val7862; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_LoginWithIdentityCredentialForCertificate_args _ = P.error "not a struct"
read_LoginWithIdentityCredentialForCertificate_args :: T.Protocol p => p -> P.IO LoginWithIdentityCredentialForCertificate_args
read_LoginWithIdentityCredentialForCertificate_args iprot = to_LoginWithIdentityCredentialForCertificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_args)
decode_LoginWithIdentityCredentialForCertificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredentialForCertificate_args
decode_LoginWithIdentityCredentialForCertificate_args iprot bs = to_LoginWithIdentityCredentialForCertificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_args) bs
typemap_LoginWithIdentityCredentialForCertificate_args :: T.TypeMap
typemap_LoginWithIdentityCredentialForCertificate_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(5,("keepLoggedIn",T.T_BOOL)),(6,("accessLocation",T.T_STRING)),(7,("systemName",T.T_STRING)),(8,("identityProvider",T.T_I32)),(9,("certificate",T.T_STRING))]
default_LoginWithIdentityCredentialForCertificate_args :: LoginWithIdentityCredentialForCertificate_args
default_LoginWithIdentityCredentialForCertificate_args = LoginWithIdentityCredentialForCertificate_args{
  loginWithIdentityCredentialForCertificate_args_identifier = "",
  loginWithIdentityCredentialForCertificate_args_password = "",
  loginWithIdentityCredentialForCertificate_args_keepLoggedIn = P.False,
  loginWithIdentityCredentialForCertificate_args_accessLocation = "",
  loginWithIdentityCredentialForCertificate_args_systemName = "",
  loginWithIdentityCredentialForCertificate_args_identityProvider = (P.toEnum 0),
  loginWithIdentityCredentialForCertificate_args_certificate = ""}
data LoginWithIdentityCredentialForCertificate_result = LoginWithIdentityCredentialForCertificate_result  { loginWithIdentityCredentialForCertificate_result_success :: LoginResult
  , loginWithIdentityCredentialForCertificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithIdentityCredentialForCertificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_result_success record   `H.hashWithSalt` loginWithIdentityCredentialForCertificate_result_e record  
instance QC.Arbitrary LoginWithIdentityCredentialForCertificate_result where 
  arbitrary = M.liftM LoginWithIdentityCredentialForCertificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithIdentityCredentialForCertificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = loginWithIdentityCredentialForCertificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = loginWithIdentityCredentialForCertificate_result_success obj}
    , if obj == default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = loginWithIdentityCredentialForCertificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = loginWithIdentityCredentialForCertificate_result_e obj}
    ]
from_LoginWithIdentityCredentialForCertificate_result :: LoginWithIdentityCredentialForCertificate_result -> T.ThriftVal
from_LoginWithIdentityCredentialForCertificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7865 -> (1, ("e",from_TalkException _v7865))) <$> loginWithIdentityCredentialForCertificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7865 -> P.Just (0, ("success",from_LoginResult _v7865))) $ loginWithIdentityCredentialForCertificate_result_success record
    , (\_v7865 -> (1, ("e",from_TalkException _v7865))) <$> loginWithIdentityCredentialForCertificate_result_e record
    ]
    )
write_LoginWithIdentityCredentialForCertificate_result :: T.Protocol p => p -> LoginWithIdentityCredentialForCertificate_result -> P.IO ()
write_LoginWithIdentityCredentialForCertificate_result oprot record = T.writeVal oprot $ from_LoginWithIdentityCredentialForCertificate_result record
encode_LoginWithIdentityCredentialForCertificate_result :: T.StatelessProtocol p => p -> LoginWithIdentityCredentialForCertificate_result -> LBS.ByteString
encode_LoginWithIdentityCredentialForCertificate_result oprot record = T.serializeVal oprot $ from_LoginWithIdentityCredentialForCertificate_result record
to_LoginWithIdentityCredentialForCertificate_result :: T.ThriftVal -> LoginWithIdentityCredentialForCertificate_result
to_LoginWithIdentityCredentialForCertificate_result (T.TStruct fields) = LoginWithIdentityCredentialForCertificate_result{
  loginWithIdentityCredentialForCertificate_result_success = P.maybe (loginWithIdentityCredentialForCertificate_result_success default_LoginWithIdentityCredentialForCertificate_result) (\(_,_val7867) -> (case _val7867 of {T.TStruct _val7868 -> (to_LoginResult (T.TStruct _val7868)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithIdentityCredentialForCertificate_result_e = P.maybe (P.Nothing) (\(_,_val7867) -> P.Just (case _val7867 of {T.TStruct _val7869 -> (to_TalkException (T.TStruct _val7869)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithIdentityCredentialForCertificate_result _ = P.error "not a struct"
read_LoginWithIdentityCredentialForCertificate_result :: T.Protocol p => p -> P.IO LoginWithIdentityCredentialForCertificate_result
read_LoginWithIdentityCredentialForCertificate_result iprot = to_LoginWithIdentityCredentialForCertificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_result)
decode_LoginWithIdentityCredentialForCertificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithIdentityCredentialForCertificate_result
decode_LoginWithIdentityCredentialForCertificate_result iprot bs = to_LoginWithIdentityCredentialForCertificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithIdentityCredentialForCertificate_result) bs
typemap_LoginWithIdentityCredentialForCertificate_result :: T.TypeMap
typemap_LoginWithIdentityCredentialForCertificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithIdentityCredentialForCertificate_result :: LoginWithIdentityCredentialForCertificate_result
default_LoginWithIdentityCredentialForCertificate_result = LoginWithIdentityCredentialForCertificate_result{
  loginWithIdentityCredentialForCertificate_result_success = default_LoginResult,
  loginWithIdentityCredentialForCertificate_result_e = P.Nothing}
data LoginWithVerifier_args = LoginWithVerifier_args  { loginWithVerifier_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifier_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifier_args_verifier record  
instance QC.Arbitrary LoginWithVerifier_args where 
  arbitrary = M.liftM LoginWithVerifier_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifier_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifier_args{loginWithVerifier_args_verifier = loginWithVerifier_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifier_args{loginWithVerifier_args_verifier = loginWithVerifier_args_verifier obj}
    ]
from_LoginWithVerifier_args :: LoginWithVerifier_args -> T.ThriftVal
from_LoginWithVerifier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7872 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v7872))) $ loginWithVerifier_args_verifier record
  ]
write_LoginWithVerifier_args :: T.Protocol p => p -> LoginWithVerifier_args -> P.IO ()
write_LoginWithVerifier_args oprot record = T.writeVal oprot $ from_LoginWithVerifier_args record
encode_LoginWithVerifier_args :: T.StatelessProtocol p => p -> LoginWithVerifier_args -> LBS.ByteString
encode_LoginWithVerifier_args oprot record = T.serializeVal oprot $ from_LoginWithVerifier_args record
to_LoginWithVerifier_args :: T.ThriftVal -> LoginWithVerifier_args
to_LoginWithVerifier_args (T.TStruct fields) = LoginWithVerifier_args{
  loginWithVerifier_args_verifier = P.maybe (loginWithVerifier_args_verifier default_LoginWithVerifier_args) (\(_,_val7874) -> (case _val7874 of {T.TString _val7875 -> E.decodeUtf8 _val7875; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifier_args _ = P.error "not a struct"
read_LoginWithVerifier_args :: T.Protocol p => p -> P.IO LoginWithVerifier_args
read_LoginWithVerifier_args iprot = to_LoginWithVerifier_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifier_args)
decode_LoginWithVerifier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifier_args
decode_LoginWithVerifier_args iprot bs = to_LoginWithVerifier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifier_args) bs
typemap_LoginWithVerifier_args :: T.TypeMap
typemap_LoginWithVerifier_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifier_args :: LoginWithVerifier_args
default_LoginWithVerifier_args = LoginWithVerifier_args{
  loginWithVerifier_args_verifier = ""}
data LoginWithVerifier_result = LoginWithVerifier_result  { loginWithVerifier_result_success :: LT.Text
  , loginWithVerifier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifier_result_success record   `H.hashWithSalt` loginWithVerifier_result_e record  
instance QC.Arbitrary LoginWithVerifier_result where 
  arbitrary = M.liftM LoginWithVerifier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifier_result{loginWithVerifier_result_success = loginWithVerifier_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifier_result{loginWithVerifier_result_success = loginWithVerifier_result_success obj}
    , if obj == default_LoginWithVerifier_result{loginWithVerifier_result_e = loginWithVerifier_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifier_result{loginWithVerifier_result_e = loginWithVerifier_result_e obj}
    ]
from_LoginWithVerifier_result :: LoginWithVerifier_result -> T.ThriftVal
from_LoginWithVerifier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7878 -> (1, ("e",from_TalkException _v7878))) <$> loginWithVerifier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7878 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v7878))) $ loginWithVerifier_result_success record
    , (\_v7878 -> (1, ("e",from_TalkException _v7878))) <$> loginWithVerifier_result_e record
    ]
    )
write_LoginWithVerifier_result :: T.Protocol p => p -> LoginWithVerifier_result -> P.IO ()
write_LoginWithVerifier_result oprot record = T.writeVal oprot $ from_LoginWithVerifier_result record
encode_LoginWithVerifier_result :: T.StatelessProtocol p => p -> LoginWithVerifier_result -> LBS.ByteString
encode_LoginWithVerifier_result oprot record = T.serializeVal oprot $ from_LoginWithVerifier_result record
to_LoginWithVerifier_result :: T.ThriftVal -> LoginWithVerifier_result
to_LoginWithVerifier_result (T.TStruct fields) = LoginWithVerifier_result{
  loginWithVerifier_result_success = P.maybe (loginWithVerifier_result_success default_LoginWithVerifier_result) (\(_,_val7880) -> (case _val7880 of {T.TString _val7881 -> E.decodeUtf8 _val7881; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifier_result_e = P.maybe (P.Nothing) (\(_,_val7880) -> P.Just (case _val7880 of {T.TStruct _val7882 -> (to_TalkException (T.TStruct _val7882)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifier_result _ = P.error "not a struct"
read_LoginWithVerifier_result :: T.Protocol p => p -> P.IO LoginWithVerifier_result
read_LoginWithVerifier_result iprot = to_LoginWithVerifier_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifier_result)
decode_LoginWithVerifier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifier_result
decode_LoginWithVerifier_result iprot bs = to_LoginWithVerifier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifier_result) bs
typemap_LoginWithVerifier_result :: T.TypeMap
typemap_LoginWithVerifier_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifier_result :: LoginWithVerifier_result
default_LoginWithVerifier_result = LoginWithVerifier_result{
  loginWithVerifier_result_success = "",
  loginWithVerifier_result_e = P.Nothing}
data LoginWithVerifierForCerificate_args = LoginWithVerifierForCerificate_args  { loginWithVerifierForCerificate_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCerificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCerificate_args_verifier record  
instance QC.Arbitrary LoginWithVerifierForCerificate_args where 
  arbitrary = M.liftM LoginWithVerifierForCerificate_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCerificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCerificate_args{loginWithVerifierForCerificate_args_verifier = loginWithVerifierForCerificate_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_args{loginWithVerifierForCerificate_args_verifier = loginWithVerifierForCerificate_args_verifier obj}
    ]
from_LoginWithVerifierForCerificate_args :: LoginWithVerifierForCerificate_args -> T.ThriftVal
from_LoginWithVerifierForCerificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7885 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v7885))) $ loginWithVerifierForCerificate_args_verifier record
  ]
write_LoginWithVerifierForCerificate_args :: T.Protocol p => p -> LoginWithVerifierForCerificate_args -> P.IO ()
write_LoginWithVerifierForCerificate_args oprot record = T.writeVal oprot $ from_LoginWithVerifierForCerificate_args record
encode_LoginWithVerifierForCerificate_args :: T.StatelessProtocol p => p -> LoginWithVerifierForCerificate_args -> LBS.ByteString
encode_LoginWithVerifierForCerificate_args oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCerificate_args record
to_LoginWithVerifierForCerificate_args :: T.ThriftVal -> LoginWithVerifierForCerificate_args
to_LoginWithVerifierForCerificate_args (T.TStruct fields) = LoginWithVerifierForCerificate_args{
  loginWithVerifierForCerificate_args_verifier = P.maybe (loginWithVerifierForCerificate_args_verifier default_LoginWithVerifierForCerificate_args) (\(_,_val7887) -> (case _val7887 of {T.TString _val7888 -> E.decodeUtf8 _val7888; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifierForCerificate_args _ = P.error "not a struct"
read_LoginWithVerifierForCerificate_args :: T.Protocol p => p -> P.IO LoginWithVerifierForCerificate_args
read_LoginWithVerifierForCerificate_args iprot = to_LoginWithVerifierForCerificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_args)
decode_LoginWithVerifierForCerificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCerificate_args
decode_LoginWithVerifierForCerificate_args iprot bs = to_LoginWithVerifierForCerificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_args) bs
typemap_LoginWithVerifierForCerificate_args :: T.TypeMap
typemap_LoginWithVerifierForCerificate_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifierForCerificate_args :: LoginWithVerifierForCerificate_args
default_LoginWithVerifierForCerificate_args = LoginWithVerifierForCerificate_args{
  loginWithVerifierForCerificate_args_verifier = ""}
data LoginWithVerifierForCerificate_result = LoginWithVerifierForCerificate_result  { loginWithVerifierForCerificate_result_success :: LoginResult
  , loginWithVerifierForCerificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCerificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCerificate_result_success record   `H.hashWithSalt` loginWithVerifierForCerificate_result_e record  
instance QC.Arbitrary LoginWithVerifierForCerificate_result where 
  arbitrary = M.liftM LoginWithVerifierForCerificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCerificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = loginWithVerifierForCerificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = loginWithVerifierForCerificate_result_success obj}
    , if obj == default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = loginWithVerifierForCerificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = loginWithVerifierForCerificate_result_e obj}
    ]
from_LoginWithVerifierForCerificate_result :: LoginWithVerifierForCerificate_result -> T.ThriftVal
from_LoginWithVerifierForCerificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7891 -> (1, ("e",from_TalkException _v7891))) <$> loginWithVerifierForCerificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7891 -> P.Just (0, ("success",from_LoginResult _v7891))) $ loginWithVerifierForCerificate_result_success record
    , (\_v7891 -> (1, ("e",from_TalkException _v7891))) <$> loginWithVerifierForCerificate_result_e record
    ]
    )
write_LoginWithVerifierForCerificate_result :: T.Protocol p => p -> LoginWithVerifierForCerificate_result -> P.IO ()
write_LoginWithVerifierForCerificate_result oprot record = T.writeVal oprot $ from_LoginWithVerifierForCerificate_result record
encode_LoginWithVerifierForCerificate_result :: T.StatelessProtocol p => p -> LoginWithVerifierForCerificate_result -> LBS.ByteString
encode_LoginWithVerifierForCerificate_result oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCerificate_result record
to_LoginWithVerifierForCerificate_result :: T.ThriftVal -> LoginWithVerifierForCerificate_result
to_LoginWithVerifierForCerificate_result (T.TStruct fields) = LoginWithVerifierForCerificate_result{
  loginWithVerifierForCerificate_result_success = P.maybe (loginWithVerifierForCerificate_result_success default_LoginWithVerifierForCerificate_result) (\(_,_val7893) -> (case _val7893 of {T.TStruct _val7894 -> (to_LoginResult (T.TStruct _val7894)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifierForCerificate_result_e = P.maybe (P.Nothing) (\(_,_val7893) -> P.Just (case _val7893 of {T.TStruct _val7895 -> (to_TalkException (T.TStruct _val7895)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifierForCerificate_result _ = P.error "not a struct"
read_LoginWithVerifierForCerificate_result :: T.Protocol p => p -> P.IO LoginWithVerifierForCerificate_result
read_LoginWithVerifierForCerificate_result iprot = to_LoginWithVerifierForCerificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_result)
decode_LoginWithVerifierForCerificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCerificate_result
decode_LoginWithVerifierForCerificate_result iprot bs = to_LoginWithVerifierForCerificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCerificate_result) bs
typemap_LoginWithVerifierForCerificate_result :: T.TypeMap
typemap_LoginWithVerifierForCerificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifierForCerificate_result :: LoginWithVerifierForCerificate_result
default_LoginWithVerifierForCerificate_result = LoginWithVerifierForCerificate_result{
  loginWithVerifierForCerificate_result_success = default_LoginResult,
  loginWithVerifierForCerificate_result_e = P.Nothing}
data LoginWithVerifierForCertificate_args = LoginWithVerifierForCertificate_args  { loginWithVerifierForCertificate_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCertificate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCertificate_args_verifier record  
instance QC.Arbitrary LoginWithVerifierForCertificate_args where 
  arbitrary = M.liftM LoginWithVerifierForCertificate_args (QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCertificate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCertificate_args{loginWithVerifierForCertificate_args_verifier = loginWithVerifierForCertificate_args_verifier obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_args{loginWithVerifierForCertificate_args_verifier = loginWithVerifierForCertificate_args_verifier obj}
    ]
from_LoginWithVerifierForCertificate_args :: LoginWithVerifierForCertificate_args -> T.ThriftVal
from_LoginWithVerifierForCertificate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7898 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v7898))) $ loginWithVerifierForCertificate_args_verifier record
  ]
write_LoginWithVerifierForCertificate_args :: T.Protocol p => p -> LoginWithVerifierForCertificate_args -> P.IO ()
write_LoginWithVerifierForCertificate_args oprot record = T.writeVal oprot $ from_LoginWithVerifierForCertificate_args record
encode_LoginWithVerifierForCertificate_args :: T.StatelessProtocol p => p -> LoginWithVerifierForCertificate_args -> LBS.ByteString
encode_LoginWithVerifierForCertificate_args oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCertificate_args record
to_LoginWithVerifierForCertificate_args :: T.ThriftVal -> LoginWithVerifierForCertificate_args
to_LoginWithVerifierForCertificate_args (T.TStruct fields) = LoginWithVerifierForCertificate_args{
  loginWithVerifierForCertificate_args_verifier = P.maybe (loginWithVerifierForCertificate_args_verifier default_LoginWithVerifierForCertificate_args) (\(_,_val7900) -> (case _val7900 of {T.TString _val7901 -> E.decodeUtf8 _val7901; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_LoginWithVerifierForCertificate_args _ = P.error "not a struct"
read_LoginWithVerifierForCertificate_args :: T.Protocol p => p -> P.IO LoginWithVerifierForCertificate_args
read_LoginWithVerifierForCertificate_args iprot = to_LoginWithVerifierForCertificate_args <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_args)
decode_LoginWithVerifierForCertificate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCertificate_args
decode_LoginWithVerifierForCertificate_args iprot bs = to_LoginWithVerifierForCertificate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_args) bs
typemap_LoginWithVerifierForCertificate_args :: T.TypeMap
typemap_LoginWithVerifierForCertificate_args = Map.fromList [(3,("verifier",T.T_STRING))]
default_LoginWithVerifierForCertificate_args :: LoginWithVerifierForCertificate_args
default_LoginWithVerifierForCertificate_args = LoginWithVerifierForCertificate_args{
  loginWithVerifierForCertificate_args_verifier = ""}
data LoginWithVerifierForCertificate_result = LoginWithVerifierForCertificate_result  { loginWithVerifierForCertificate_result_success :: LoginResult
  , loginWithVerifierForCertificate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LoginWithVerifierForCertificate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` loginWithVerifierForCertificate_result_success record   `H.hashWithSalt` loginWithVerifierForCertificate_result_e record  
instance QC.Arbitrary LoginWithVerifierForCertificate_result where 
  arbitrary = M.liftM LoginWithVerifierForCertificate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LoginWithVerifierForCertificate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = loginWithVerifierForCertificate_result_success obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = loginWithVerifierForCertificate_result_success obj}
    , if obj == default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = loginWithVerifierForCertificate_result_e obj} then P.Nothing else P.Just $ default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = loginWithVerifierForCertificate_result_e obj}
    ]
from_LoginWithVerifierForCertificate_result :: LoginWithVerifierForCertificate_result -> T.ThriftVal
from_LoginWithVerifierForCertificate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7904 -> (1, ("e",from_TalkException _v7904))) <$> loginWithVerifierForCertificate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7904 -> P.Just (0, ("success",from_LoginResult _v7904))) $ loginWithVerifierForCertificate_result_success record
    , (\_v7904 -> (1, ("e",from_TalkException _v7904))) <$> loginWithVerifierForCertificate_result_e record
    ]
    )
write_LoginWithVerifierForCertificate_result :: T.Protocol p => p -> LoginWithVerifierForCertificate_result -> P.IO ()
write_LoginWithVerifierForCertificate_result oprot record = T.writeVal oprot $ from_LoginWithVerifierForCertificate_result record
encode_LoginWithVerifierForCertificate_result :: T.StatelessProtocol p => p -> LoginWithVerifierForCertificate_result -> LBS.ByteString
encode_LoginWithVerifierForCertificate_result oprot record = T.serializeVal oprot $ from_LoginWithVerifierForCertificate_result record
to_LoginWithVerifierForCertificate_result :: T.ThriftVal -> LoginWithVerifierForCertificate_result
to_LoginWithVerifierForCertificate_result (T.TStruct fields) = LoginWithVerifierForCertificate_result{
  loginWithVerifierForCertificate_result_success = P.maybe (loginWithVerifierForCertificate_result_success default_LoginWithVerifierForCertificate_result) (\(_,_val7906) -> (case _val7906 of {T.TStruct _val7907 -> (to_LoginResult (T.TStruct _val7907)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  loginWithVerifierForCertificate_result_e = P.maybe (P.Nothing) (\(_,_val7906) -> P.Just (case _val7906 of {T.TStruct _val7908 -> (to_TalkException (T.TStruct _val7908)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LoginWithVerifierForCertificate_result _ = P.error "not a struct"
read_LoginWithVerifierForCertificate_result :: T.Protocol p => p -> P.IO LoginWithVerifierForCertificate_result
read_LoginWithVerifierForCertificate_result iprot = to_LoginWithVerifierForCertificate_result <$> T.readVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_result)
decode_LoginWithVerifierForCertificate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LoginWithVerifierForCertificate_result
decode_LoginWithVerifierForCertificate_result iprot bs = to_LoginWithVerifierForCertificate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LoginWithVerifierForCertificate_result) bs
typemap_LoginWithVerifierForCertificate_result :: T.TypeMap
typemap_LoginWithVerifierForCertificate_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_LoginResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LoginWithVerifierForCertificate_result :: LoginWithVerifierForCertificate_result
default_LoginWithVerifierForCertificate_result = LoginWithVerifierForCertificate_result{
  loginWithVerifierForCertificate_result_success = default_LoginResult,
  loginWithVerifierForCertificate_result_e = P.Nothing}
data Logout_args = Logout_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Logout_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Logout_args where 
  arbitrary = QC.elements [Logout_args]
from_Logout_args :: Logout_args -> T.ThriftVal
from_Logout_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Logout_args :: T.Protocol p => p -> Logout_args -> P.IO ()
write_Logout_args oprot record = T.writeVal oprot $ from_Logout_args record
encode_Logout_args :: T.StatelessProtocol p => p -> Logout_args -> LBS.ByteString
encode_Logout_args oprot record = T.serializeVal oprot $ from_Logout_args record
to_Logout_args :: T.ThriftVal -> Logout_args
to_Logout_args (T.TStruct fields) = Logout_args{

  }
to_Logout_args _ = P.error "not a struct"
read_Logout_args :: T.Protocol p => p -> P.IO Logout_args
read_Logout_args iprot = to_Logout_args <$> T.readVal iprot (T.T_STRUCT typemap_Logout_args)
decode_Logout_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Logout_args
decode_Logout_args iprot bs = to_Logout_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Logout_args) bs
typemap_Logout_args :: T.TypeMap
typemap_Logout_args = Map.fromList []
default_Logout_args :: Logout_args
default_Logout_args = Logout_args{
}
data Logout_result = Logout_result  { logout_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Logout_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logout_result_e record  
instance QC.Arbitrary Logout_result where 
  arbitrary = M.liftM Logout_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Logout_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Logout_result{logout_result_e = logout_result_e obj} then P.Nothing else P.Just $ default_Logout_result{logout_result_e = logout_result_e obj}
    ]
from_Logout_result :: Logout_result -> T.ThriftVal
from_Logout_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7916 -> (1, ("e",from_TalkException _v7916))) <$> logout_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7916 -> (1, ("e",from_TalkException _v7916))) <$> logout_result_e record
    ]
    )
write_Logout_result :: T.Protocol p => p -> Logout_result -> P.IO ()
write_Logout_result oprot record = T.writeVal oprot $ from_Logout_result record
encode_Logout_result :: T.StatelessProtocol p => p -> Logout_result -> LBS.ByteString
encode_Logout_result oprot record = T.serializeVal oprot $ from_Logout_result record
to_Logout_result :: T.ThriftVal -> Logout_result
to_Logout_result (T.TStruct fields) = Logout_result{
  logout_result_e = P.maybe (P.Nothing) (\(_,_val7918) -> P.Just (case _val7918 of {T.TStruct _val7919 -> (to_TalkException (T.TStruct _val7919)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Logout_result _ = P.error "not a struct"
read_Logout_result :: T.Protocol p => p -> P.IO Logout_result
read_Logout_result iprot = to_Logout_result <$> T.readVal iprot (T.T_STRUCT typemap_Logout_result)
decode_Logout_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Logout_result
decode_Logout_result iprot bs = to_Logout_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Logout_result) bs
typemap_Logout_result :: T.TypeMap
typemap_Logout_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Logout_result :: Logout_result
default_Logout_result = Logout_result{
  logout_result_e = P.Nothing}
data LogoutSession_args = LogoutSession_args  { logoutSession_args_tokenKey :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutSession_args_tokenKey record  
instance QC.Arbitrary LogoutSession_args where 
  arbitrary = M.liftM LogoutSession_args (QC.arbitrary)
  shrink obj | obj == default_LogoutSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutSession_args{logoutSession_args_tokenKey = logoutSession_args_tokenKey obj} then P.Nothing else P.Just $ default_LogoutSession_args{logoutSession_args_tokenKey = logoutSession_args_tokenKey obj}
    ]
from_LogoutSession_args :: LogoutSession_args -> T.ThriftVal
from_LogoutSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7922 -> P.Just (2, ("tokenKey",T.TString $ E.encodeUtf8 _v7922))) $ logoutSession_args_tokenKey record
  ]
write_LogoutSession_args :: T.Protocol p => p -> LogoutSession_args -> P.IO ()
write_LogoutSession_args oprot record = T.writeVal oprot $ from_LogoutSession_args record
encode_LogoutSession_args :: T.StatelessProtocol p => p -> LogoutSession_args -> LBS.ByteString
encode_LogoutSession_args oprot record = T.serializeVal oprot $ from_LogoutSession_args record
to_LogoutSession_args :: T.ThriftVal -> LogoutSession_args
to_LogoutSession_args (T.TStruct fields) = LogoutSession_args{
  logoutSession_args_tokenKey = P.maybe (logoutSession_args_tokenKey default_LogoutSession_args) (\(_,_val7924) -> (case _val7924 of {T.TString _val7925 -> E.decodeUtf8 _val7925; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LogoutSession_args _ = P.error "not a struct"
read_LogoutSession_args :: T.Protocol p => p -> P.IO LogoutSession_args
read_LogoutSession_args iprot = to_LogoutSession_args <$> T.readVal iprot (T.T_STRUCT typemap_LogoutSession_args)
decode_LogoutSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutSession_args
decode_LogoutSession_args iprot bs = to_LogoutSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutSession_args) bs
typemap_LogoutSession_args :: T.TypeMap
typemap_LogoutSession_args = Map.fromList [(2,("tokenKey",T.T_STRING))]
default_LogoutSession_args :: LogoutSession_args
default_LogoutSession_args = LogoutSession_args{
  logoutSession_args_tokenKey = ""}
data LogoutSession_result = LogoutSession_result  { logoutSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LogoutSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` logoutSession_result_e record  
instance QC.Arbitrary LogoutSession_result where 
  arbitrary = M.liftM LogoutSession_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LogoutSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LogoutSession_result{logoutSession_result_e = logoutSession_result_e obj} then P.Nothing else P.Just $ default_LogoutSession_result{logoutSession_result_e = logoutSession_result_e obj}
    ]
from_LogoutSession_result :: LogoutSession_result -> T.ThriftVal
from_LogoutSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7928 -> (1, ("e",from_TalkException _v7928))) <$> logoutSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7928 -> (1, ("e",from_TalkException _v7928))) <$> logoutSession_result_e record
    ]
    )
write_LogoutSession_result :: T.Protocol p => p -> LogoutSession_result -> P.IO ()
write_LogoutSession_result oprot record = T.writeVal oprot $ from_LogoutSession_result record
encode_LogoutSession_result :: T.StatelessProtocol p => p -> LogoutSession_result -> LBS.ByteString
encode_LogoutSession_result oprot record = T.serializeVal oprot $ from_LogoutSession_result record
to_LogoutSession_result :: T.ThriftVal -> LogoutSession_result
to_LogoutSession_result (T.TStruct fields) = LogoutSession_result{
  logoutSession_result_e = P.maybe (P.Nothing) (\(_,_val7930) -> P.Just (case _val7930 of {T.TStruct _val7931 -> (to_TalkException (T.TStruct _val7931)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LogoutSession_result _ = P.error "not a struct"
read_LogoutSession_result :: T.Protocol p => p -> P.IO LogoutSession_result
read_LogoutSession_result iprot = to_LogoutSession_result <$> T.readVal iprot (T.T_STRUCT typemap_LogoutSession_result)
decode_LogoutSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LogoutSession_result
decode_LogoutSession_result iprot bs = to_LogoutSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LogoutSession_result) bs
typemap_LogoutSession_result :: T.TypeMap
typemap_LogoutSession_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LogoutSession_result :: LogoutSession_result
default_LogoutSession_result = LogoutSession_result{
  logoutSession_result_e = P.Nothing}
data Noop_args = Noop_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Noop_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary Noop_args where 
  arbitrary = QC.elements [Noop_args]
from_Noop_args :: Noop_args -> T.ThriftVal
from_Noop_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_Noop_args :: T.Protocol p => p -> Noop_args -> P.IO ()
write_Noop_args oprot record = T.writeVal oprot $ from_Noop_args record
encode_Noop_args :: T.StatelessProtocol p => p -> Noop_args -> LBS.ByteString
encode_Noop_args oprot record = T.serializeVal oprot $ from_Noop_args record
to_Noop_args :: T.ThriftVal -> Noop_args
to_Noop_args (T.TStruct fields) = Noop_args{

  }
to_Noop_args _ = P.error "not a struct"
read_Noop_args :: T.Protocol p => p -> P.IO Noop_args
read_Noop_args iprot = to_Noop_args <$> T.readVal iprot (T.T_STRUCT typemap_Noop_args)
decode_Noop_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Noop_args
decode_Noop_args iprot bs = to_Noop_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Noop_args) bs
typemap_Noop_args :: T.TypeMap
typemap_Noop_args = Map.fromList []
default_Noop_args :: Noop_args
default_Noop_args = Noop_args{
}
data Noop_result = Noop_result  { noop_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Noop_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` noop_result_e record  
instance QC.Arbitrary Noop_result where 
  arbitrary = M.liftM Noop_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Noop_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Noop_result{noop_result_e = noop_result_e obj} then P.Nothing else P.Just $ default_Noop_result{noop_result_e = noop_result_e obj}
    ]
from_Noop_result :: Noop_result -> T.ThriftVal
from_Noop_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7939 -> (1, ("e",from_TalkException _v7939))) <$> noop_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7939 -> (1, ("e",from_TalkException _v7939))) <$> noop_result_e record
    ]
    )
write_Noop_result :: T.Protocol p => p -> Noop_result -> P.IO ()
write_Noop_result oprot record = T.writeVal oprot $ from_Noop_result record
encode_Noop_result :: T.StatelessProtocol p => p -> Noop_result -> LBS.ByteString
encode_Noop_result oprot record = T.serializeVal oprot $ from_Noop_result record
to_Noop_result :: T.ThriftVal -> Noop_result
to_Noop_result (T.TStruct fields) = Noop_result{
  noop_result_e = P.maybe (P.Nothing) (\(_,_val7941) -> P.Just (case _val7941 of {T.TStruct _val7942 -> (to_TalkException (T.TStruct _val7942)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Noop_result _ = P.error "not a struct"
read_Noop_result :: T.Protocol p => p -> P.IO Noop_result
read_Noop_result iprot = to_Noop_result <$> T.readVal iprot (T.T_STRUCT typemap_Noop_result)
decode_Noop_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Noop_result
decode_Noop_result iprot bs = to_Noop_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Noop_result) bs
typemap_Noop_result :: T.TypeMap
typemap_Noop_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Noop_result :: Noop_result
default_Noop_result = Noop_result{
  noop_result_e = P.Nothing}
data NotifiedRedirect_args = NotifiedRedirect_args  { notifiedRedirect_args_paramMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifiedRedirect_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifiedRedirect_args_paramMap record  
instance QC.Arbitrary NotifiedRedirect_args where 
  arbitrary = M.liftM NotifiedRedirect_args (QC.arbitrary)
  shrink obj | obj == default_NotifiedRedirect_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifiedRedirect_args{notifiedRedirect_args_paramMap = notifiedRedirect_args_paramMap obj} then P.Nothing else P.Just $ default_NotifiedRedirect_args{notifiedRedirect_args_paramMap = notifiedRedirect_args_paramMap obj}
    ]
from_NotifiedRedirect_args :: NotifiedRedirect_args -> T.ThriftVal
from_NotifiedRedirect_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7945 -> P.Just (2, ("paramMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k7946,_v7947) -> (T.TString $ E.encodeUtf8 _k7946, T.TString $ E.encodeUtf8 _v7947)) $ Map.toList _v7945))) $ notifiedRedirect_args_paramMap record
  ]
write_NotifiedRedirect_args :: T.Protocol p => p -> NotifiedRedirect_args -> P.IO ()
write_NotifiedRedirect_args oprot record = T.writeVal oprot $ from_NotifiedRedirect_args record
encode_NotifiedRedirect_args :: T.StatelessProtocol p => p -> NotifiedRedirect_args -> LBS.ByteString
encode_NotifiedRedirect_args oprot record = T.serializeVal oprot $ from_NotifiedRedirect_args record
to_NotifiedRedirect_args :: T.ThriftVal -> NotifiedRedirect_args
to_NotifiedRedirect_args (T.TStruct fields) = NotifiedRedirect_args{
  notifiedRedirect_args_paramMap = P.maybe (notifiedRedirect_args_paramMap default_NotifiedRedirect_args) (\(_,_val7949) -> (case _val7949 of {T.TMap _ _ _val7950 -> (Map.fromList $ P.map (\(_k7952,_v7951) -> ((case _k7952 of {T.TString _val7953 -> E.decodeUtf8 _val7953; _ -> P.error "wrong type"}),(case _v7951 of {T.TString _val7954 -> E.decodeUtf8 _val7954; _ -> P.error "wrong type"}))) _val7950); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotifiedRedirect_args _ = P.error "not a struct"
read_NotifiedRedirect_args :: T.Protocol p => p -> P.IO NotifiedRedirect_args
read_NotifiedRedirect_args iprot = to_NotifiedRedirect_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifiedRedirect_args)
decode_NotifiedRedirect_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifiedRedirect_args
decode_NotifiedRedirect_args iprot bs = to_NotifiedRedirect_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifiedRedirect_args) bs
typemap_NotifiedRedirect_args :: T.TypeMap
typemap_NotifiedRedirect_args = Map.fromList [(2,("paramMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_NotifiedRedirect_args :: NotifiedRedirect_args
default_NotifiedRedirect_args = NotifiedRedirect_args{
  notifiedRedirect_args_paramMap = Map.empty}
data NotifiedRedirect_result = NotifiedRedirect_result  { notifiedRedirect_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifiedRedirect_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifiedRedirect_result_e record  
instance QC.Arbitrary NotifiedRedirect_result where 
  arbitrary = M.liftM NotifiedRedirect_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifiedRedirect_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifiedRedirect_result{notifiedRedirect_result_e = notifiedRedirect_result_e obj} then P.Nothing else P.Just $ default_NotifiedRedirect_result{notifiedRedirect_result_e = notifiedRedirect_result_e obj}
    ]
from_NotifiedRedirect_result :: NotifiedRedirect_result -> T.ThriftVal
from_NotifiedRedirect_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7957 -> (1, ("e",from_TalkException _v7957))) <$> notifiedRedirect_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7957 -> (1, ("e",from_TalkException _v7957))) <$> notifiedRedirect_result_e record
    ]
    )
write_NotifiedRedirect_result :: T.Protocol p => p -> NotifiedRedirect_result -> P.IO ()
write_NotifiedRedirect_result oprot record = T.writeVal oprot $ from_NotifiedRedirect_result record
encode_NotifiedRedirect_result :: T.StatelessProtocol p => p -> NotifiedRedirect_result -> LBS.ByteString
encode_NotifiedRedirect_result oprot record = T.serializeVal oprot $ from_NotifiedRedirect_result record
to_NotifiedRedirect_result :: T.ThriftVal -> NotifiedRedirect_result
to_NotifiedRedirect_result (T.TStruct fields) = NotifiedRedirect_result{
  notifiedRedirect_result_e = P.maybe (P.Nothing) (\(_,_val7959) -> P.Just (case _val7959 of {T.TStruct _val7960 -> (to_TalkException (T.TStruct _val7960)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifiedRedirect_result _ = P.error "not a struct"
read_NotifiedRedirect_result :: T.Protocol p => p -> P.IO NotifiedRedirect_result
read_NotifiedRedirect_result iprot = to_NotifiedRedirect_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifiedRedirect_result)
decode_NotifiedRedirect_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifiedRedirect_result
decode_NotifiedRedirect_result iprot bs = to_NotifiedRedirect_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifiedRedirect_result) bs
typemap_NotifiedRedirect_result :: T.TypeMap
typemap_NotifiedRedirect_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifiedRedirect_result :: NotifiedRedirect_result
default_NotifiedRedirect_result = NotifiedRedirect_result{
  notifiedRedirect_result_e = P.Nothing}
data NotifyBuddyOnAir_args = NotifyBuddyOnAir_args  { notifyBuddyOnAir_args_seq :: I.Int32
  , notifyBuddyOnAir_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyBuddyOnAir_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyBuddyOnAir_args_seq record   `H.hashWithSalt` notifyBuddyOnAir_args_receiverMids record  
instance QC.Arbitrary NotifyBuddyOnAir_args where 
  arbitrary = M.liftM NotifyBuddyOnAir_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyBuddyOnAir_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_seq = notifyBuddyOnAir_args_seq obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_seq = notifyBuddyOnAir_args_seq obj}
    , if obj == default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_receiverMids = notifyBuddyOnAir_args_receiverMids obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_args{notifyBuddyOnAir_args_receiverMids = notifyBuddyOnAir_args_receiverMids obj}
    ]
from_NotifyBuddyOnAir_args :: NotifyBuddyOnAir_args -> T.ThriftVal
from_NotifyBuddyOnAir_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7963 -> P.Just (1, ("seq",T.TI32 _v7963))) $ notifyBuddyOnAir_args_seq record
  , (\_v7963 -> P.Just (2, ("receiverMids",T.TList T.T_STRING $ P.map (\_v7965 -> T.TString $ E.encodeUtf8 _v7965) $ Vector.toList _v7963))) $ notifyBuddyOnAir_args_receiverMids record
  ]
write_NotifyBuddyOnAir_args :: T.Protocol p => p -> NotifyBuddyOnAir_args -> P.IO ()
write_NotifyBuddyOnAir_args oprot record = T.writeVal oprot $ from_NotifyBuddyOnAir_args record
encode_NotifyBuddyOnAir_args :: T.StatelessProtocol p => p -> NotifyBuddyOnAir_args -> LBS.ByteString
encode_NotifyBuddyOnAir_args oprot record = T.serializeVal oprot $ from_NotifyBuddyOnAir_args record
to_NotifyBuddyOnAir_args :: T.ThriftVal -> NotifyBuddyOnAir_args
to_NotifyBuddyOnAir_args (T.TStruct fields) = NotifyBuddyOnAir_args{
  notifyBuddyOnAir_args_seq = P.maybe (notifyBuddyOnAir_args_seq default_NotifyBuddyOnAir_args) (\(_,_val7967) -> (case _val7967 of {T.TI32 _val7968 -> _val7968; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notifyBuddyOnAir_args_receiverMids = P.maybe (notifyBuddyOnAir_args_receiverMids default_NotifyBuddyOnAir_args) (\(_,_val7967) -> (case _val7967 of {T.TList _ _val7969 -> (Vector.fromList $ P.map (\_v7970 -> (case _v7970 of {T.TString _val7971 -> E.decodeUtf8 _val7971; _ -> P.error "wrong type"})) _val7969); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NotifyBuddyOnAir_args _ = P.error "not a struct"
read_NotifyBuddyOnAir_args :: T.Protocol p => p -> P.IO NotifyBuddyOnAir_args
read_NotifyBuddyOnAir_args iprot = to_NotifyBuddyOnAir_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_args)
decode_NotifyBuddyOnAir_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyBuddyOnAir_args
decode_NotifyBuddyOnAir_args iprot bs = to_NotifyBuddyOnAir_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_args) bs
typemap_NotifyBuddyOnAir_args :: T.TypeMap
typemap_NotifyBuddyOnAir_args = Map.fromList [(1,("seq",T.T_I32)),(2,("receiverMids",(T.T_LIST T.T_STRING)))]
default_NotifyBuddyOnAir_args :: NotifyBuddyOnAir_args
default_NotifyBuddyOnAir_args = NotifyBuddyOnAir_args{
  notifyBuddyOnAir_args_seq = 0,
  notifyBuddyOnAir_args_receiverMids = Vector.empty}
data NotifyBuddyOnAir_result = NotifyBuddyOnAir_result  { notifyBuddyOnAir_result_success :: (Map.HashMap LT.Text LT.Text)
  , notifyBuddyOnAir_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyBuddyOnAir_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyBuddyOnAir_result_success record   `H.hashWithSalt` notifyBuddyOnAir_result_e record  
instance QC.Arbitrary NotifyBuddyOnAir_result where 
  arbitrary = M.liftM NotifyBuddyOnAir_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyBuddyOnAir_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = notifyBuddyOnAir_result_success obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = notifyBuddyOnAir_result_success obj}
    , if obj == default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = notifyBuddyOnAir_result_e obj} then P.Nothing else P.Just $ default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = notifyBuddyOnAir_result_e obj}
    ]
from_NotifyBuddyOnAir_result :: NotifyBuddyOnAir_result -> T.ThriftVal
from_NotifyBuddyOnAir_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7974 -> (1, ("e",from_TalkException _v7974))) <$> notifyBuddyOnAir_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7974 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k7975,_v7976) -> (T.TString $ E.encodeUtf8 _k7975, T.TString $ E.encodeUtf8 _v7976)) $ Map.toList _v7974))) $ notifyBuddyOnAir_result_success record
    , (\_v7974 -> (1, ("e",from_TalkException _v7974))) <$> notifyBuddyOnAir_result_e record
    ]
    )
write_NotifyBuddyOnAir_result :: T.Protocol p => p -> NotifyBuddyOnAir_result -> P.IO ()
write_NotifyBuddyOnAir_result oprot record = T.writeVal oprot $ from_NotifyBuddyOnAir_result record
encode_NotifyBuddyOnAir_result :: T.StatelessProtocol p => p -> NotifyBuddyOnAir_result -> LBS.ByteString
encode_NotifyBuddyOnAir_result oprot record = T.serializeVal oprot $ from_NotifyBuddyOnAir_result record
to_NotifyBuddyOnAir_result :: T.ThriftVal -> NotifyBuddyOnAir_result
to_NotifyBuddyOnAir_result (T.TStruct fields) = NotifyBuddyOnAir_result{
  notifyBuddyOnAir_result_success = P.maybe (notifyBuddyOnAir_result_success default_NotifyBuddyOnAir_result) (\(_,_val7978) -> (case _val7978 of {T.TMap _ _ _val7979 -> (Map.fromList $ P.map (\(_k7981,_v7980) -> ((case _k7981 of {T.TString _val7982 -> E.decodeUtf8 _val7982; _ -> P.error "wrong type"}),(case _v7980 of {T.TString _val7983 -> E.decodeUtf8 _val7983; _ -> P.error "wrong type"}))) _val7979); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  notifyBuddyOnAir_result_e = P.maybe (P.Nothing) (\(_,_val7978) -> P.Just (case _val7978 of {T.TStruct _val7984 -> (to_TalkException (T.TStruct _val7984)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyBuddyOnAir_result _ = P.error "not a struct"
read_NotifyBuddyOnAir_result :: T.Protocol p => p -> P.IO NotifyBuddyOnAir_result
read_NotifyBuddyOnAir_result iprot = to_NotifyBuddyOnAir_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_result)
decode_NotifyBuddyOnAir_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyBuddyOnAir_result
decode_NotifyBuddyOnAir_result iprot bs = to_NotifyBuddyOnAir_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyBuddyOnAir_result) bs
typemap_NotifyBuddyOnAir_result :: T.TypeMap
typemap_NotifyBuddyOnAir_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyBuddyOnAir_result :: NotifyBuddyOnAir_result
default_NotifyBuddyOnAir_result = NotifyBuddyOnAir_result{
  notifyBuddyOnAir_result_success = Map.empty,
  notifyBuddyOnAir_result_e = P.Nothing}
data NotifyIndividualEvent_args = NotifyIndividualEvent_args  { notifyIndividualEvent_args_notificationStatus :: NotificationStatus
  , notifyIndividualEvent_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyIndividualEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyIndividualEvent_args_notificationStatus record   `H.hashWithSalt` notifyIndividualEvent_args_receiverMids record  
instance QC.Arbitrary NotifyIndividualEvent_args where 
  arbitrary = M.liftM NotifyIndividualEvent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyIndividualEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyIndividualEvent_args{notifyIndividualEvent_args_notificationStatus = notifyIndividualEvent_args_notificationStatus obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_args{notifyIndividualEvent_args_notificationStatus = notifyIndividualEvent_args_notificationStatus obj}
    , if obj == default_NotifyIndividualEvent_args{notifyIndividualEvent_args_receiverMids = notifyIndividualEvent_args_receiverMids obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_args{notifyIndividualEvent_args_receiverMids = notifyIndividualEvent_args_receiverMids obj}
    ]
from_NotifyIndividualEvent_args :: NotifyIndividualEvent_args -> T.ThriftVal
from_NotifyIndividualEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v7987 -> P.Just (2, ("notificationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v7987))) $ notifyIndividualEvent_args_notificationStatus record
  , (\_v7987 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v7989 -> T.TString $ E.encodeUtf8 _v7989) $ Vector.toList _v7987))) $ notifyIndividualEvent_args_receiverMids record
  ]
write_NotifyIndividualEvent_args :: T.Protocol p => p -> NotifyIndividualEvent_args -> P.IO ()
write_NotifyIndividualEvent_args oprot record = T.writeVal oprot $ from_NotifyIndividualEvent_args record
encode_NotifyIndividualEvent_args :: T.StatelessProtocol p => p -> NotifyIndividualEvent_args -> LBS.ByteString
encode_NotifyIndividualEvent_args oprot record = T.serializeVal oprot $ from_NotifyIndividualEvent_args record
to_NotifyIndividualEvent_args :: T.ThriftVal -> NotifyIndividualEvent_args
to_NotifyIndividualEvent_args (T.TStruct fields) = NotifyIndividualEvent_args{
  notifyIndividualEvent_args_notificationStatus = P.maybe (notifyIndividualEvent_args_notificationStatus default_NotifyIndividualEvent_args) (\(_,_val7991) -> (case _val7991 of {T.TI32 _val7992 -> P.toEnum $ P.fromIntegral _val7992; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyIndividualEvent_args_receiverMids = P.maybe (notifyIndividualEvent_args_receiverMids default_NotifyIndividualEvent_args) (\(_,_val7991) -> (case _val7991 of {T.TList _ _val7993 -> (Vector.fromList $ P.map (\_v7994 -> (case _v7994 of {T.TString _val7995 -> E.decodeUtf8 _val7995; _ -> P.error "wrong type"})) _val7993); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyIndividualEvent_args _ = P.error "not a struct"
read_NotifyIndividualEvent_args :: T.Protocol p => p -> P.IO NotifyIndividualEvent_args
read_NotifyIndividualEvent_args iprot = to_NotifyIndividualEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_args)
decode_NotifyIndividualEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyIndividualEvent_args
decode_NotifyIndividualEvent_args iprot bs = to_NotifyIndividualEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_args) bs
typemap_NotifyIndividualEvent_args :: T.TypeMap
typemap_NotifyIndividualEvent_args = Map.fromList [(2,("notificationStatus",T.T_I32)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_NotifyIndividualEvent_args :: NotifyIndividualEvent_args
default_NotifyIndividualEvent_args = NotifyIndividualEvent_args{
  notifyIndividualEvent_args_notificationStatus = (P.toEnum 0),
  notifyIndividualEvent_args_receiverMids = Vector.empty}
data NotifyIndividualEvent_result = NotifyIndividualEvent_result  { notifyIndividualEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyIndividualEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyIndividualEvent_result_e record  
instance QC.Arbitrary NotifyIndividualEvent_result where 
  arbitrary = M.liftM NotifyIndividualEvent_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyIndividualEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = notifyIndividualEvent_result_e obj} then P.Nothing else P.Just $ default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = notifyIndividualEvent_result_e obj}
    ]
from_NotifyIndividualEvent_result :: NotifyIndividualEvent_result -> T.ThriftVal
from_NotifyIndividualEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v7998 -> (1, ("e",from_TalkException _v7998))) <$> notifyIndividualEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v7998 -> (1, ("e",from_TalkException _v7998))) <$> notifyIndividualEvent_result_e record
    ]
    )
write_NotifyIndividualEvent_result :: T.Protocol p => p -> NotifyIndividualEvent_result -> P.IO ()
write_NotifyIndividualEvent_result oprot record = T.writeVal oprot $ from_NotifyIndividualEvent_result record
encode_NotifyIndividualEvent_result :: T.StatelessProtocol p => p -> NotifyIndividualEvent_result -> LBS.ByteString
encode_NotifyIndividualEvent_result oprot record = T.serializeVal oprot $ from_NotifyIndividualEvent_result record
to_NotifyIndividualEvent_result :: T.ThriftVal -> NotifyIndividualEvent_result
to_NotifyIndividualEvent_result (T.TStruct fields) = NotifyIndividualEvent_result{
  notifyIndividualEvent_result_e = P.maybe (P.Nothing) (\(_,_val8000) -> P.Just (case _val8000 of {T.TStruct _val8001 -> (to_TalkException (T.TStruct _val8001)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyIndividualEvent_result _ = P.error "not a struct"
read_NotifyIndividualEvent_result :: T.Protocol p => p -> P.IO NotifyIndividualEvent_result
read_NotifyIndividualEvent_result iprot = to_NotifyIndividualEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_result)
decode_NotifyIndividualEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyIndividualEvent_result
decode_NotifyIndividualEvent_result iprot bs = to_NotifyIndividualEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyIndividualEvent_result) bs
typemap_NotifyIndividualEvent_result :: T.TypeMap
typemap_NotifyIndividualEvent_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyIndividualEvent_result :: NotifyIndividualEvent_result
default_NotifyIndividualEvent_result = NotifyIndividualEvent_result{
  notifyIndividualEvent_result_e = P.Nothing}
data NotifyInstalled_args = NotifyInstalled_args  { notifyInstalled_args_udidHash :: LT.Text
  , notifyInstalled_args_applicationTypeWithExtensions :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyInstalled_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyInstalled_args_udidHash record   `H.hashWithSalt` notifyInstalled_args_applicationTypeWithExtensions record  
instance QC.Arbitrary NotifyInstalled_args where 
  arbitrary = M.liftM NotifyInstalled_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyInstalled_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyInstalled_args{notifyInstalled_args_udidHash = notifyInstalled_args_udidHash obj} then P.Nothing else P.Just $ default_NotifyInstalled_args{notifyInstalled_args_udidHash = notifyInstalled_args_udidHash obj}
    , if obj == default_NotifyInstalled_args{notifyInstalled_args_applicationTypeWithExtensions = notifyInstalled_args_applicationTypeWithExtensions obj} then P.Nothing else P.Just $ default_NotifyInstalled_args{notifyInstalled_args_applicationTypeWithExtensions = notifyInstalled_args_applicationTypeWithExtensions obj}
    ]
from_NotifyInstalled_args :: NotifyInstalled_args -> T.ThriftVal
from_NotifyInstalled_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8004 -> P.Just (2, ("udidHash",T.TString $ E.encodeUtf8 _v8004))) $ notifyInstalled_args_udidHash record
  , (\_v8004 -> P.Just (3, ("applicationTypeWithExtensions",T.TString $ E.encodeUtf8 _v8004))) $ notifyInstalled_args_applicationTypeWithExtensions record
  ]
write_NotifyInstalled_args :: T.Protocol p => p -> NotifyInstalled_args -> P.IO ()
write_NotifyInstalled_args oprot record = T.writeVal oprot $ from_NotifyInstalled_args record
encode_NotifyInstalled_args :: T.StatelessProtocol p => p -> NotifyInstalled_args -> LBS.ByteString
encode_NotifyInstalled_args oprot record = T.serializeVal oprot $ from_NotifyInstalled_args record
to_NotifyInstalled_args :: T.ThriftVal -> NotifyInstalled_args
to_NotifyInstalled_args (T.TStruct fields) = NotifyInstalled_args{
  notifyInstalled_args_udidHash = P.maybe (notifyInstalled_args_udidHash default_NotifyInstalled_args) (\(_,_val8006) -> (case _val8006 of {T.TString _val8007 -> E.decodeUtf8 _val8007; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyInstalled_args_applicationTypeWithExtensions = P.maybe (notifyInstalled_args_applicationTypeWithExtensions default_NotifyInstalled_args) (\(_,_val8006) -> (case _val8006 of {T.TString _val8008 -> E.decodeUtf8 _val8008; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyInstalled_args _ = P.error "not a struct"
read_NotifyInstalled_args :: T.Protocol p => p -> P.IO NotifyInstalled_args
read_NotifyInstalled_args iprot = to_NotifyInstalled_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyInstalled_args)
decode_NotifyInstalled_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyInstalled_args
decode_NotifyInstalled_args iprot bs = to_NotifyInstalled_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyInstalled_args) bs
typemap_NotifyInstalled_args :: T.TypeMap
typemap_NotifyInstalled_args = Map.fromList [(2,("udidHash",T.T_STRING)),(3,("applicationTypeWithExtensions",T.T_STRING))]
default_NotifyInstalled_args :: NotifyInstalled_args
default_NotifyInstalled_args = NotifyInstalled_args{
  notifyInstalled_args_udidHash = "",
  notifyInstalled_args_applicationTypeWithExtensions = ""}
data NotifyInstalled_result = NotifyInstalled_result  { notifyInstalled_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyInstalled_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyInstalled_result_e record  
instance QC.Arbitrary NotifyInstalled_result where 
  arbitrary = M.liftM NotifyInstalled_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyInstalled_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyInstalled_result{notifyInstalled_result_e = notifyInstalled_result_e obj} then P.Nothing else P.Just $ default_NotifyInstalled_result{notifyInstalled_result_e = notifyInstalled_result_e obj}
    ]
from_NotifyInstalled_result :: NotifyInstalled_result -> T.ThriftVal
from_NotifyInstalled_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8011 -> (1, ("e",from_TalkException _v8011))) <$> notifyInstalled_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8011 -> (1, ("e",from_TalkException _v8011))) <$> notifyInstalled_result_e record
    ]
    )
write_NotifyInstalled_result :: T.Protocol p => p -> NotifyInstalled_result -> P.IO ()
write_NotifyInstalled_result oprot record = T.writeVal oprot $ from_NotifyInstalled_result record
encode_NotifyInstalled_result :: T.StatelessProtocol p => p -> NotifyInstalled_result -> LBS.ByteString
encode_NotifyInstalled_result oprot record = T.serializeVal oprot $ from_NotifyInstalled_result record
to_NotifyInstalled_result :: T.ThriftVal -> NotifyInstalled_result
to_NotifyInstalled_result (T.TStruct fields) = NotifyInstalled_result{
  notifyInstalled_result_e = P.maybe (P.Nothing) (\(_,_val8013) -> P.Just (case _val8013 of {T.TStruct _val8014 -> (to_TalkException (T.TStruct _val8014)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyInstalled_result _ = P.error "not a struct"
read_NotifyInstalled_result :: T.Protocol p => p -> P.IO NotifyInstalled_result
read_NotifyInstalled_result iprot = to_NotifyInstalled_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyInstalled_result)
decode_NotifyInstalled_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyInstalled_result
decode_NotifyInstalled_result iprot bs = to_NotifyInstalled_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyInstalled_result) bs
typemap_NotifyInstalled_result :: T.TypeMap
typemap_NotifyInstalled_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyInstalled_result :: NotifyInstalled_result
default_NotifyInstalled_result = NotifyInstalled_result{
  notifyInstalled_result_e = P.Nothing}
data NotifyRegistrationComplete_args = NotifyRegistrationComplete_args  { notifyRegistrationComplete_args_udidHash :: LT.Text
  , notifyRegistrationComplete_args_applicationTypeWithExtensions :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyRegistrationComplete_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyRegistrationComplete_args_udidHash record   `H.hashWithSalt` notifyRegistrationComplete_args_applicationTypeWithExtensions record  
instance QC.Arbitrary NotifyRegistrationComplete_args where 
  arbitrary = M.liftM NotifyRegistrationComplete_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyRegistrationComplete_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_udidHash = notifyRegistrationComplete_args_udidHash obj} then P.Nothing else P.Just $ default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_udidHash = notifyRegistrationComplete_args_udidHash obj}
    , if obj == default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_applicationTypeWithExtensions = notifyRegistrationComplete_args_applicationTypeWithExtensions obj} then P.Nothing else P.Just $ default_NotifyRegistrationComplete_args{notifyRegistrationComplete_args_applicationTypeWithExtensions = notifyRegistrationComplete_args_applicationTypeWithExtensions obj}
    ]
from_NotifyRegistrationComplete_args :: NotifyRegistrationComplete_args -> T.ThriftVal
from_NotifyRegistrationComplete_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8017 -> P.Just (2, ("udidHash",T.TString $ E.encodeUtf8 _v8017))) $ notifyRegistrationComplete_args_udidHash record
  , (\_v8017 -> P.Just (3, ("applicationTypeWithExtensions",T.TString $ E.encodeUtf8 _v8017))) $ notifyRegistrationComplete_args_applicationTypeWithExtensions record
  ]
write_NotifyRegistrationComplete_args :: T.Protocol p => p -> NotifyRegistrationComplete_args -> P.IO ()
write_NotifyRegistrationComplete_args oprot record = T.writeVal oprot $ from_NotifyRegistrationComplete_args record
encode_NotifyRegistrationComplete_args :: T.StatelessProtocol p => p -> NotifyRegistrationComplete_args -> LBS.ByteString
encode_NotifyRegistrationComplete_args oprot record = T.serializeVal oprot $ from_NotifyRegistrationComplete_args record
to_NotifyRegistrationComplete_args :: T.ThriftVal -> NotifyRegistrationComplete_args
to_NotifyRegistrationComplete_args (T.TStruct fields) = NotifyRegistrationComplete_args{
  notifyRegistrationComplete_args_udidHash = P.maybe (notifyRegistrationComplete_args_udidHash default_NotifyRegistrationComplete_args) (\(_,_val8019) -> (case _val8019 of {T.TString _val8020 -> E.decodeUtf8 _val8020; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyRegistrationComplete_args_applicationTypeWithExtensions = P.maybe (notifyRegistrationComplete_args_applicationTypeWithExtensions default_NotifyRegistrationComplete_args) (\(_,_val8019) -> (case _val8019 of {T.TString _val8021 -> E.decodeUtf8 _val8021; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyRegistrationComplete_args _ = P.error "not a struct"
read_NotifyRegistrationComplete_args :: T.Protocol p => p -> P.IO NotifyRegistrationComplete_args
read_NotifyRegistrationComplete_args iprot = to_NotifyRegistrationComplete_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_args)
decode_NotifyRegistrationComplete_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyRegistrationComplete_args
decode_NotifyRegistrationComplete_args iprot bs = to_NotifyRegistrationComplete_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_args) bs
typemap_NotifyRegistrationComplete_args :: T.TypeMap
typemap_NotifyRegistrationComplete_args = Map.fromList [(2,("udidHash",T.T_STRING)),(3,("applicationTypeWithExtensions",T.T_STRING))]
default_NotifyRegistrationComplete_args :: NotifyRegistrationComplete_args
default_NotifyRegistrationComplete_args = NotifyRegistrationComplete_args{
  notifyRegistrationComplete_args_udidHash = "",
  notifyRegistrationComplete_args_applicationTypeWithExtensions = ""}
data NotifyRegistrationComplete_result = NotifyRegistrationComplete_result  { notifyRegistrationComplete_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyRegistrationComplete_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyRegistrationComplete_result_e record  
instance QC.Arbitrary NotifyRegistrationComplete_result where 
  arbitrary = M.liftM NotifyRegistrationComplete_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyRegistrationComplete_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyRegistrationComplete_result{notifyRegistrationComplete_result_e = notifyRegistrationComplete_result_e obj} then P.Nothing else P.Just $ default_NotifyRegistrationComplete_result{notifyRegistrationComplete_result_e = notifyRegistrationComplete_result_e obj}
    ]
from_NotifyRegistrationComplete_result :: NotifyRegistrationComplete_result -> T.ThriftVal
from_NotifyRegistrationComplete_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8024 -> (1, ("e",from_TalkException _v8024))) <$> notifyRegistrationComplete_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8024 -> (1, ("e",from_TalkException _v8024))) <$> notifyRegistrationComplete_result_e record
    ]
    )
write_NotifyRegistrationComplete_result :: T.Protocol p => p -> NotifyRegistrationComplete_result -> P.IO ()
write_NotifyRegistrationComplete_result oprot record = T.writeVal oprot $ from_NotifyRegistrationComplete_result record
encode_NotifyRegistrationComplete_result :: T.StatelessProtocol p => p -> NotifyRegistrationComplete_result -> LBS.ByteString
encode_NotifyRegistrationComplete_result oprot record = T.serializeVal oprot $ from_NotifyRegistrationComplete_result record
to_NotifyRegistrationComplete_result :: T.ThriftVal -> NotifyRegistrationComplete_result
to_NotifyRegistrationComplete_result (T.TStruct fields) = NotifyRegistrationComplete_result{
  notifyRegistrationComplete_result_e = P.maybe (P.Nothing) (\(_,_val8026) -> P.Just (case _val8026 of {T.TStruct _val8027 -> (to_TalkException (T.TStruct _val8027)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyRegistrationComplete_result _ = P.error "not a struct"
read_NotifyRegistrationComplete_result :: T.Protocol p => p -> P.IO NotifyRegistrationComplete_result
read_NotifyRegistrationComplete_result iprot = to_NotifyRegistrationComplete_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_result)
decode_NotifyRegistrationComplete_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyRegistrationComplete_result
decode_NotifyRegistrationComplete_result iprot bs = to_NotifyRegistrationComplete_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyRegistrationComplete_result) bs
typemap_NotifyRegistrationComplete_result :: T.TypeMap
typemap_NotifyRegistrationComplete_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyRegistrationComplete_result :: NotifyRegistrationComplete_result
default_NotifyRegistrationComplete_result = NotifyRegistrationComplete_result{
  notifyRegistrationComplete_result_e = P.Nothing}
data NotifySleep_args = NotifySleep_args  { notifySleep_args_lastRev :: I.Int64
  , notifySleep_args_badge :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifySleep_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifySleep_args_lastRev record   `H.hashWithSalt` notifySleep_args_badge record  
instance QC.Arbitrary NotifySleep_args where 
  arbitrary = M.liftM NotifySleep_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifySleep_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifySleep_args{notifySleep_args_lastRev = notifySleep_args_lastRev obj} then P.Nothing else P.Just $ default_NotifySleep_args{notifySleep_args_lastRev = notifySleep_args_lastRev obj}
    , if obj == default_NotifySleep_args{notifySleep_args_badge = notifySleep_args_badge obj} then P.Nothing else P.Just $ default_NotifySleep_args{notifySleep_args_badge = notifySleep_args_badge obj}
    ]
from_NotifySleep_args :: NotifySleep_args -> T.ThriftVal
from_NotifySleep_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8030 -> P.Just (2, ("lastRev",T.TI64 _v8030))) $ notifySleep_args_lastRev record
  , (\_v8030 -> P.Just (3, ("badge",T.TI32 _v8030))) $ notifySleep_args_badge record
  ]
write_NotifySleep_args :: T.Protocol p => p -> NotifySleep_args -> P.IO ()
write_NotifySleep_args oprot record = T.writeVal oprot $ from_NotifySleep_args record
encode_NotifySleep_args :: T.StatelessProtocol p => p -> NotifySleep_args -> LBS.ByteString
encode_NotifySleep_args oprot record = T.serializeVal oprot $ from_NotifySleep_args record
to_NotifySleep_args :: T.ThriftVal -> NotifySleep_args
to_NotifySleep_args (T.TStruct fields) = NotifySleep_args{
  notifySleep_args_lastRev = P.maybe (notifySleep_args_lastRev default_NotifySleep_args) (\(_,_val8032) -> (case _val8032 of {T.TI64 _val8033 -> _val8033; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifySleep_args_badge = P.maybe (notifySleep_args_badge default_NotifySleep_args) (\(_,_val8032) -> (case _val8032 of {T.TI32 _val8034 -> _val8034; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifySleep_args _ = P.error "not a struct"
read_NotifySleep_args :: T.Protocol p => p -> P.IO NotifySleep_args
read_NotifySleep_args iprot = to_NotifySleep_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifySleep_args)
decode_NotifySleep_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifySleep_args
decode_NotifySleep_args iprot bs = to_NotifySleep_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifySleep_args) bs
typemap_NotifySleep_args :: T.TypeMap
typemap_NotifySleep_args = Map.fromList [(2,("lastRev",T.T_I64)),(3,("badge",T.T_I32))]
default_NotifySleep_args :: NotifySleep_args
default_NotifySleep_args = NotifySleep_args{
  notifySleep_args_lastRev = 0,
  notifySleep_args_badge = 0}
data NotifySleep_result = NotifySleep_result  { notifySleep_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifySleep_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifySleep_result_e record  
instance QC.Arbitrary NotifySleep_result where 
  arbitrary = M.liftM NotifySleep_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifySleep_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifySleep_result{notifySleep_result_e = notifySleep_result_e obj} then P.Nothing else P.Just $ default_NotifySleep_result{notifySleep_result_e = notifySleep_result_e obj}
    ]
from_NotifySleep_result :: NotifySleep_result -> T.ThriftVal
from_NotifySleep_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8037 -> (1, ("e",from_TalkException _v8037))) <$> notifySleep_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8037 -> (1, ("e",from_TalkException _v8037))) <$> notifySleep_result_e record
    ]
    )
write_NotifySleep_result :: T.Protocol p => p -> NotifySleep_result -> P.IO ()
write_NotifySleep_result oprot record = T.writeVal oprot $ from_NotifySleep_result record
encode_NotifySleep_result :: T.StatelessProtocol p => p -> NotifySleep_result -> LBS.ByteString
encode_NotifySleep_result oprot record = T.serializeVal oprot $ from_NotifySleep_result record
to_NotifySleep_result :: T.ThriftVal -> NotifySleep_result
to_NotifySleep_result (T.TStruct fields) = NotifySleep_result{
  notifySleep_result_e = P.maybe (P.Nothing) (\(_,_val8039) -> P.Just (case _val8039 of {T.TStruct _val8040 -> (to_TalkException (T.TStruct _val8040)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifySleep_result _ = P.error "not a struct"
read_NotifySleep_result :: T.Protocol p => p -> P.IO NotifySleep_result
read_NotifySleep_result iprot = to_NotifySleep_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifySleep_result)
decode_NotifySleep_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifySleep_result
decode_NotifySleep_result iprot bs = to_NotifySleep_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifySleep_result) bs
typemap_NotifySleep_result :: T.TypeMap
typemap_NotifySleep_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifySleep_result :: NotifySleep_result
default_NotifySleep_result = NotifySleep_result{
  notifySleep_result_e = P.Nothing}
data NotifyUpdated_args = NotifyUpdated_args  { notifyUpdated_args_lastRev :: I.Int64
  , notifyUpdated_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyUpdated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyUpdated_args_lastRev record   `H.hashWithSalt` notifyUpdated_args_deviceInfo record  
instance QC.Arbitrary NotifyUpdated_args where 
  arbitrary = M.liftM NotifyUpdated_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyUpdated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyUpdated_args{notifyUpdated_args_lastRev = notifyUpdated_args_lastRev obj} then P.Nothing else P.Just $ default_NotifyUpdated_args{notifyUpdated_args_lastRev = notifyUpdated_args_lastRev obj}
    , if obj == default_NotifyUpdated_args{notifyUpdated_args_deviceInfo = notifyUpdated_args_deviceInfo obj} then P.Nothing else P.Just $ default_NotifyUpdated_args{notifyUpdated_args_deviceInfo = notifyUpdated_args_deviceInfo obj}
    ]
from_NotifyUpdated_args :: NotifyUpdated_args -> T.ThriftVal
from_NotifyUpdated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8043 -> P.Just (2, ("lastRev",T.TI64 _v8043))) $ notifyUpdated_args_lastRev record
  , (\_v8043 -> P.Just (3, ("deviceInfo",from_DeviceInfo _v8043))) $ notifyUpdated_args_deviceInfo record
  ]
write_NotifyUpdated_args :: T.Protocol p => p -> NotifyUpdated_args -> P.IO ()
write_NotifyUpdated_args oprot record = T.writeVal oprot $ from_NotifyUpdated_args record
encode_NotifyUpdated_args :: T.StatelessProtocol p => p -> NotifyUpdated_args -> LBS.ByteString
encode_NotifyUpdated_args oprot record = T.serializeVal oprot $ from_NotifyUpdated_args record
to_NotifyUpdated_args :: T.ThriftVal -> NotifyUpdated_args
to_NotifyUpdated_args (T.TStruct fields) = NotifyUpdated_args{
  notifyUpdated_args_lastRev = P.maybe (notifyUpdated_args_lastRev default_NotifyUpdated_args) (\(_,_val8045) -> (case _val8045 of {T.TI64 _val8046 -> _val8046; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyUpdated_args_deviceInfo = P.maybe (notifyUpdated_args_deviceInfo default_NotifyUpdated_args) (\(_,_val8045) -> (case _val8045 of {T.TStruct _val8047 -> (to_DeviceInfo (T.TStruct _val8047)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyUpdated_args _ = P.error "not a struct"
read_NotifyUpdated_args :: T.Protocol p => p -> P.IO NotifyUpdated_args
read_NotifyUpdated_args iprot = to_NotifyUpdated_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyUpdated_args)
decode_NotifyUpdated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyUpdated_args
decode_NotifyUpdated_args iprot bs = to_NotifyUpdated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyUpdated_args) bs
typemap_NotifyUpdated_args :: T.TypeMap
typemap_NotifyUpdated_args = Map.fromList [(2,("lastRev",T.T_I64)),(3,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_NotifyUpdated_args :: NotifyUpdated_args
default_NotifyUpdated_args = NotifyUpdated_args{
  notifyUpdated_args_lastRev = 0,
  notifyUpdated_args_deviceInfo = default_DeviceInfo}
data NotifyUpdated_result = NotifyUpdated_result  { notifyUpdated_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyUpdated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyUpdated_result_e record  
instance QC.Arbitrary NotifyUpdated_result where 
  arbitrary = M.liftM NotifyUpdated_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyUpdated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyUpdated_result{notifyUpdated_result_e = notifyUpdated_result_e obj} then P.Nothing else P.Just $ default_NotifyUpdated_result{notifyUpdated_result_e = notifyUpdated_result_e obj}
    ]
from_NotifyUpdated_result :: NotifyUpdated_result -> T.ThriftVal
from_NotifyUpdated_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8050 -> (1, ("e",from_TalkException _v8050))) <$> notifyUpdated_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8050 -> (1, ("e",from_TalkException _v8050))) <$> notifyUpdated_result_e record
    ]
    )
write_NotifyUpdated_result :: T.Protocol p => p -> NotifyUpdated_result -> P.IO ()
write_NotifyUpdated_result oprot record = T.writeVal oprot $ from_NotifyUpdated_result record
encode_NotifyUpdated_result :: T.StatelessProtocol p => p -> NotifyUpdated_result -> LBS.ByteString
encode_NotifyUpdated_result oprot record = T.serializeVal oprot $ from_NotifyUpdated_result record
to_NotifyUpdated_result :: T.ThriftVal -> NotifyUpdated_result
to_NotifyUpdated_result (T.TStruct fields) = NotifyUpdated_result{
  notifyUpdated_result_e = P.maybe (P.Nothing) (\(_,_val8052) -> P.Just (case _val8052 of {T.TStruct _val8053 -> (to_TalkException (T.TStruct _val8053)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyUpdated_result _ = P.error "not a struct"
read_NotifyUpdated_result :: T.Protocol p => p -> P.IO NotifyUpdated_result
read_NotifyUpdated_result iprot = to_NotifyUpdated_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyUpdated_result)
decode_NotifyUpdated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyUpdated_result
decode_NotifyUpdated_result iprot bs = to_NotifyUpdated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyUpdated_result) bs
typemap_NotifyUpdated_result :: T.TypeMap
typemap_NotifyUpdated_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyUpdated_result :: NotifyUpdated_result
default_NotifyUpdated_result = NotifyUpdated_result{
  notifyUpdated_result_e = P.Nothing}
data OpenProximityMatch_args = OpenProximityMatch_args  { openProximityMatch_args_location :: Location
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenProximityMatch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` openProximityMatch_args_location record  
instance QC.Arbitrary OpenProximityMatch_args where 
  arbitrary = M.liftM OpenProximityMatch_args (QC.arbitrary)
  shrink obj | obj == default_OpenProximityMatch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenProximityMatch_args{openProximityMatch_args_location = openProximityMatch_args_location obj} then P.Nothing else P.Just $ default_OpenProximityMatch_args{openProximityMatch_args_location = openProximityMatch_args_location obj}
    ]
from_OpenProximityMatch_args :: OpenProximityMatch_args -> T.ThriftVal
from_OpenProximityMatch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8056 -> P.Just (2, ("location",from_Location _v8056))) $ openProximityMatch_args_location record
  ]
write_OpenProximityMatch_args :: T.Protocol p => p -> OpenProximityMatch_args -> P.IO ()
write_OpenProximityMatch_args oprot record = T.writeVal oprot $ from_OpenProximityMatch_args record
encode_OpenProximityMatch_args :: T.StatelessProtocol p => p -> OpenProximityMatch_args -> LBS.ByteString
encode_OpenProximityMatch_args oprot record = T.serializeVal oprot $ from_OpenProximityMatch_args record
to_OpenProximityMatch_args :: T.ThriftVal -> OpenProximityMatch_args
to_OpenProximityMatch_args (T.TStruct fields) = OpenProximityMatch_args{
  openProximityMatch_args_location = P.maybe (openProximityMatch_args_location default_OpenProximityMatch_args) (\(_,_val8058) -> (case _val8058 of {T.TStruct _val8059 -> (to_Location (T.TStruct _val8059)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_OpenProximityMatch_args _ = P.error "not a struct"
read_OpenProximityMatch_args :: T.Protocol p => p -> P.IO OpenProximityMatch_args
read_OpenProximityMatch_args iprot = to_OpenProximityMatch_args <$> T.readVal iprot (T.T_STRUCT typemap_OpenProximityMatch_args)
decode_OpenProximityMatch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenProximityMatch_args
decode_OpenProximityMatch_args iprot bs = to_OpenProximityMatch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenProximityMatch_args) bs
typemap_OpenProximityMatch_args :: T.TypeMap
typemap_OpenProximityMatch_args = Map.fromList [(2,("location",(T.T_STRUCT typemap_Location)))]
default_OpenProximityMatch_args :: OpenProximityMatch_args
default_OpenProximityMatch_args = OpenProximityMatch_args{
  openProximityMatch_args_location = default_Location}
data OpenProximityMatch_result = OpenProximityMatch_result  { openProximityMatch_result_success :: LT.Text
  , openProximityMatch_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable OpenProximityMatch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` openProximityMatch_result_success record   `H.hashWithSalt` openProximityMatch_result_e record  
instance QC.Arbitrary OpenProximityMatch_result where 
  arbitrary = M.liftM OpenProximityMatch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_OpenProximityMatch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_OpenProximityMatch_result{openProximityMatch_result_success = openProximityMatch_result_success obj} then P.Nothing else P.Just $ default_OpenProximityMatch_result{openProximityMatch_result_success = openProximityMatch_result_success obj}
    , if obj == default_OpenProximityMatch_result{openProximityMatch_result_e = openProximityMatch_result_e obj} then P.Nothing else P.Just $ default_OpenProximityMatch_result{openProximityMatch_result_e = openProximityMatch_result_e obj}
    ]
from_OpenProximityMatch_result :: OpenProximityMatch_result -> T.ThriftVal
from_OpenProximityMatch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8062 -> (1, ("e",from_TalkException _v8062))) <$> openProximityMatch_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8062 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8062))) $ openProximityMatch_result_success record
    , (\_v8062 -> (1, ("e",from_TalkException _v8062))) <$> openProximityMatch_result_e record
    ]
    )
write_OpenProximityMatch_result :: T.Protocol p => p -> OpenProximityMatch_result -> P.IO ()
write_OpenProximityMatch_result oprot record = T.writeVal oprot $ from_OpenProximityMatch_result record
encode_OpenProximityMatch_result :: T.StatelessProtocol p => p -> OpenProximityMatch_result -> LBS.ByteString
encode_OpenProximityMatch_result oprot record = T.serializeVal oprot $ from_OpenProximityMatch_result record
to_OpenProximityMatch_result :: T.ThriftVal -> OpenProximityMatch_result
to_OpenProximityMatch_result (T.TStruct fields) = OpenProximityMatch_result{
  openProximityMatch_result_success = P.maybe (openProximityMatch_result_success default_OpenProximityMatch_result) (\(_,_val8064) -> (case _val8064 of {T.TString _val8065 -> E.decodeUtf8 _val8065; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  openProximityMatch_result_e = P.maybe (P.Nothing) (\(_,_val8064) -> P.Just (case _val8064 of {T.TStruct _val8066 -> (to_TalkException (T.TStruct _val8066)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_OpenProximityMatch_result _ = P.error "not a struct"
read_OpenProximityMatch_result :: T.Protocol p => p -> P.IO OpenProximityMatch_result
read_OpenProximityMatch_result iprot = to_OpenProximityMatch_result <$> T.readVal iprot (T.T_STRUCT typemap_OpenProximityMatch_result)
decode_OpenProximityMatch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> OpenProximityMatch_result
decode_OpenProximityMatch_result iprot bs = to_OpenProximityMatch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_OpenProximityMatch_result) bs
typemap_OpenProximityMatch_result :: T.TypeMap
typemap_OpenProximityMatch_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_OpenProximityMatch_result :: OpenProximityMatch_result
default_OpenProximityMatch_result = OpenProximityMatch_result{
  openProximityMatch_result_success = "",
  openProximityMatch_result_e = P.Nothing}
data RegisterBuddyUser_args = RegisterBuddyUser_args  { registerBuddyUser_args_buddyId :: LT.Text
  , registerBuddyUser_args_registrarPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUser_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUser_args_buddyId record   `H.hashWithSalt` registerBuddyUser_args_registrarPassword record  
instance QC.Arbitrary RegisterBuddyUser_args where 
  arbitrary = M.liftM RegisterBuddyUser_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUser_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUser_args{registerBuddyUser_args_buddyId = registerBuddyUser_args_buddyId obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_args{registerBuddyUser_args_buddyId = registerBuddyUser_args_buddyId obj}
    , if obj == default_RegisterBuddyUser_args{registerBuddyUser_args_registrarPassword = registerBuddyUser_args_registrarPassword obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_args{registerBuddyUser_args_registrarPassword = registerBuddyUser_args_registrarPassword obj}
    ]
from_RegisterBuddyUser_args :: RegisterBuddyUser_args -> T.ThriftVal
from_RegisterBuddyUser_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8069 -> P.Just (2, ("buddyId",T.TString $ E.encodeUtf8 _v8069))) $ registerBuddyUser_args_buddyId record
  , (\_v8069 -> P.Just (3, ("registrarPassword",T.TString $ E.encodeUtf8 _v8069))) $ registerBuddyUser_args_registrarPassword record
  ]
write_RegisterBuddyUser_args :: T.Protocol p => p -> RegisterBuddyUser_args -> P.IO ()
write_RegisterBuddyUser_args oprot record = T.writeVal oprot $ from_RegisterBuddyUser_args record
encode_RegisterBuddyUser_args :: T.StatelessProtocol p => p -> RegisterBuddyUser_args -> LBS.ByteString
encode_RegisterBuddyUser_args oprot record = T.serializeVal oprot $ from_RegisterBuddyUser_args record
to_RegisterBuddyUser_args :: T.ThriftVal -> RegisterBuddyUser_args
to_RegisterBuddyUser_args (T.TStruct fields) = RegisterBuddyUser_args{
  registerBuddyUser_args_buddyId = P.maybe (registerBuddyUser_args_buddyId default_RegisterBuddyUser_args) (\(_,_val8071) -> (case _val8071 of {T.TString _val8072 -> E.decodeUtf8 _val8072; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerBuddyUser_args_registrarPassword = P.maybe (registerBuddyUser_args_registrarPassword default_RegisterBuddyUser_args) (\(_,_val8071) -> (case _val8071 of {T.TString _val8073 -> E.decodeUtf8 _val8073; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterBuddyUser_args _ = P.error "not a struct"
read_RegisterBuddyUser_args :: T.Protocol p => p -> P.IO RegisterBuddyUser_args
read_RegisterBuddyUser_args iprot = to_RegisterBuddyUser_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_args)
decode_RegisterBuddyUser_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUser_args
decode_RegisterBuddyUser_args iprot bs = to_RegisterBuddyUser_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_args) bs
typemap_RegisterBuddyUser_args :: T.TypeMap
typemap_RegisterBuddyUser_args = Map.fromList [(2,("buddyId",T.T_STRING)),(3,("registrarPassword",T.T_STRING))]
default_RegisterBuddyUser_args :: RegisterBuddyUser_args
default_RegisterBuddyUser_args = RegisterBuddyUser_args{
  registerBuddyUser_args_buddyId = "",
  registerBuddyUser_args_registrarPassword = ""}
data RegisterBuddyUser_result = RegisterBuddyUser_result  { registerBuddyUser_result_success :: LT.Text
  , registerBuddyUser_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUser_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUser_result_success record   `H.hashWithSalt` registerBuddyUser_result_e record  
instance QC.Arbitrary RegisterBuddyUser_result where 
  arbitrary = M.liftM RegisterBuddyUser_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUser_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUser_result{registerBuddyUser_result_success = registerBuddyUser_result_success obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_result{registerBuddyUser_result_success = registerBuddyUser_result_success obj}
    , if obj == default_RegisterBuddyUser_result{registerBuddyUser_result_e = registerBuddyUser_result_e obj} then P.Nothing else P.Just $ default_RegisterBuddyUser_result{registerBuddyUser_result_e = registerBuddyUser_result_e obj}
    ]
from_RegisterBuddyUser_result :: RegisterBuddyUser_result -> T.ThriftVal
from_RegisterBuddyUser_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8076 -> (1, ("e",from_TalkException _v8076))) <$> registerBuddyUser_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8076 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8076))) $ registerBuddyUser_result_success record
    , (\_v8076 -> (1, ("e",from_TalkException _v8076))) <$> registerBuddyUser_result_e record
    ]
    )
write_RegisterBuddyUser_result :: T.Protocol p => p -> RegisterBuddyUser_result -> P.IO ()
write_RegisterBuddyUser_result oprot record = T.writeVal oprot $ from_RegisterBuddyUser_result record
encode_RegisterBuddyUser_result :: T.StatelessProtocol p => p -> RegisterBuddyUser_result -> LBS.ByteString
encode_RegisterBuddyUser_result oprot record = T.serializeVal oprot $ from_RegisterBuddyUser_result record
to_RegisterBuddyUser_result :: T.ThriftVal -> RegisterBuddyUser_result
to_RegisterBuddyUser_result (T.TStruct fields) = RegisterBuddyUser_result{
  registerBuddyUser_result_success = P.maybe (registerBuddyUser_result_success default_RegisterBuddyUser_result) (\(_,_val8078) -> (case _val8078 of {T.TString _val8079 -> E.decodeUtf8 _val8079; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerBuddyUser_result_e = P.maybe (P.Nothing) (\(_,_val8078) -> P.Just (case _val8078 of {T.TStruct _val8080 -> (to_TalkException (T.TStruct _val8080)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterBuddyUser_result _ = P.error "not a struct"
read_RegisterBuddyUser_result :: T.Protocol p => p -> P.IO RegisterBuddyUser_result
read_RegisterBuddyUser_result iprot = to_RegisterBuddyUser_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_result)
decode_RegisterBuddyUser_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUser_result
decode_RegisterBuddyUser_result iprot bs = to_RegisterBuddyUser_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUser_result) bs
typemap_RegisterBuddyUser_result :: T.TypeMap
typemap_RegisterBuddyUser_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterBuddyUser_result :: RegisterBuddyUser_result
default_RegisterBuddyUser_result = RegisterBuddyUser_result{
  registerBuddyUser_result_success = "",
  registerBuddyUser_result_e = P.Nothing}
data RegisterBuddyUserid_args = RegisterBuddyUserid_args  { registerBuddyUserid_args_seq :: I.Int32
  , registerBuddyUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUserid_args_seq record   `H.hashWithSalt` registerBuddyUserid_args_userid record  
instance QC.Arbitrary RegisterBuddyUserid_args where 
  arbitrary = M.liftM RegisterBuddyUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUserid_args{registerBuddyUserid_args_seq = registerBuddyUserid_args_seq obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_args{registerBuddyUserid_args_seq = registerBuddyUserid_args_seq obj}
    , if obj == default_RegisterBuddyUserid_args{registerBuddyUserid_args_userid = registerBuddyUserid_args_userid obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_args{registerBuddyUserid_args_userid = registerBuddyUserid_args_userid obj}
    ]
from_RegisterBuddyUserid_args :: RegisterBuddyUserid_args -> T.ThriftVal
from_RegisterBuddyUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8083 -> P.Just (2, ("seq",T.TI32 _v8083))) $ registerBuddyUserid_args_seq record
  , (\_v8083 -> P.Just (3, ("userid",T.TString $ E.encodeUtf8 _v8083))) $ registerBuddyUserid_args_userid record
  ]
write_RegisterBuddyUserid_args :: T.Protocol p => p -> RegisterBuddyUserid_args -> P.IO ()
write_RegisterBuddyUserid_args oprot record = T.writeVal oprot $ from_RegisterBuddyUserid_args record
encode_RegisterBuddyUserid_args :: T.StatelessProtocol p => p -> RegisterBuddyUserid_args -> LBS.ByteString
encode_RegisterBuddyUserid_args oprot record = T.serializeVal oprot $ from_RegisterBuddyUserid_args record
to_RegisterBuddyUserid_args :: T.ThriftVal -> RegisterBuddyUserid_args
to_RegisterBuddyUserid_args (T.TStruct fields) = RegisterBuddyUserid_args{
  registerBuddyUserid_args_seq = P.maybe (registerBuddyUserid_args_seq default_RegisterBuddyUserid_args) (\(_,_val8085) -> (case _val8085 of {T.TI32 _val8086 -> _val8086; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerBuddyUserid_args_userid = P.maybe (registerBuddyUserid_args_userid default_RegisterBuddyUserid_args) (\(_,_val8085) -> (case _val8085 of {T.TString _val8087 -> E.decodeUtf8 _val8087; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterBuddyUserid_args _ = P.error "not a struct"
read_RegisterBuddyUserid_args :: T.Protocol p => p -> P.IO RegisterBuddyUserid_args
read_RegisterBuddyUserid_args iprot = to_RegisterBuddyUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_args)
decode_RegisterBuddyUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUserid_args
decode_RegisterBuddyUserid_args iprot bs = to_RegisterBuddyUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_args) bs
typemap_RegisterBuddyUserid_args :: T.TypeMap
typemap_RegisterBuddyUserid_args = Map.fromList [(2,("seq",T.T_I32)),(3,("userid",T.T_STRING))]
default_RegisterBuddyUserid_args :: RegisterBuddyUserid_args
default_RegisterBuddyUserid_args = RegisterBuddyUserid_args{
  registerBuddyUserid_args_seq = 0,
  registerBuddyUserid_args_userid = ""}
data RegisterBuddyUserid_result = RegisterBuddyUserid_result  { registerBuddyUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterBuddyUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerBuddyUserid_result_e record  
instance QC.Arbitrary RegisterBuddyUserid_result where 
  arbitrary = M.liftM RegisterBuddyUserid_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterBuddyUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = registerBuddyUserid_result_e obj} then P.Nothing else P.Just $ default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = registerBuddyUserid_result_e obj}
    ]
from_RegisterBuddyUserid_result :: RegisterBuddyUserid_result -> T.ThriftVal
from_RegisterBuddyUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8090 -> (1, ("e",from_TalkException _v8090))) <$> registerBuddyUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8090 -> (1, ("e",from_TalkException _v8090))) <$> registerBuddyUserid_result_e record
    ]
    )
write_RegisterBuddyUserid_result :: T.Protocol p => p -> RegisterBuddyUserid_result -> P.IO ()
write_RegisterBuddyUserid_result oprot record = T.writeVal oprot $ from_RegisterBuddyUserid_result record
encode_RegisterBuddyUserid_result :: T.StatelessProtocol p => p -> RegisterBuddyUserid_result -> LBS.ByteString
encode_RegisterBuddyUserid_result oprot record = T.serializeVal oprot $ from_RegisterBuddyUserid_result record
to_RegisterBuddyUserid_result :: T.ThriftVal -> RegisterBuddyUserid_result
to_RegisterBuddyUserid_result (T.TStruct fields) = RegisterBuddyUserid_result{
  registerBuddyUserid_result_e = P.maybe (P.Nothing) (\(_,_val8092) -> P.Just (case _val8092 of {T.TStruct _val8093 -> (to_TalkException (T.TStruct _val8093)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterBuddyUserid_result _ = P.error "not a struct"
read_RegisterBuddyUserid_result :: T.Protocol p => p -> P.IO RegisterBuddyUserid_result
read_RegisterBuddyUserid_result iprot = to_RegisterBuddyUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_result)
decode_RegisterBuddyUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterBuddyUserid_result
decode_RegisterBuddyUserid_result iprot bs = to_RegisterBuddyUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterBuddyUserid_result) bs
typemap_RegisterBuddyUserid_result :: T.TypeMap
typemap_RegisterBuddyUserid_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterBuddyUserid_result :: RegisterBuddyUserid_result
default_RegisterBuddyUserid_result = RegisterBuddyUserid_result{
  registerBuddyUserid_result_e = P.Nothing}
data RegisterDevice_args = RegisterDevice_args  { registerDevice_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDevice_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDevice_args_sessionId record  
instance QC.Arbitrary RegisterDevice_args where 
  arbitrary = M.liftM RegisterDevice_args (QC.arbitrary)
  shrink obj | obj == default_RegisterDevice_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDevice_args{registerDevice_args_sessionId = registerDevice_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterDevice_args{registerDevice_args_sessionId = registerDevice_args_sessionId obj}
    ]
from_RegisterDevice_args :: RegisterDevice_args -> T.ThriftVal
from_RegisterDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8096 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v8096))) $ registerDevice_args_sessionId record
  ]
write_RegisterDevice_args :: T.Protocol p => p -> RegisterDevice_args -> P.IO ()
write_RegisterDevice_args oprot record = T.writeVal oprot $ from_RegisterDevice_args record
encode_RegisterDevice_args :: T.StatelessProtocol p => p -> RegisterDevice_args -> LBS.ByteString
encode_RegisterDevice_args oprot record = T.serializeVal oprot $ from_RegisterDevice_args record
to_RegisterDevice_args :: T.ThriftVal -> RegisterDevice_args
to_RegisterDevice_args (T.TStruct fields) = RegisterDevice_args{
  registerDevice_args_sessionId = P.maybe (registerDevice_args_sessionId default_RegisterDevice_args) (\(_,_val8098) -> (case _val8098 of {T.TString _val8099 -> E.decodeUtf8 _val8099; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterDevice_args _ = P.error "not a struct"
read_RegisterDevice_args :: T.Protocol p => p -> P.IO RegisterDevice_args
read_RegisterDevice_args iprot = to_RegisterDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDevice_args)
decode_RegisterDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDevice_args
decode_RegisterDevice_args iprot bs = to_RegisterDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDevice_args) bs
typemap_RegisterDevice_args :: T.TypeMap
typemap_RegisterDevice_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_RegisterDevice_args :: RegisterDevice_args
default_RegisterDevice_args = RegisterDevice_args{
  registerDevice_args_sessionId = ""}
data RegisterDevice_result = RegisterDevice_result  { registerDevice_result_success :: LT.Text
  , registerDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDevice_result_success record   `H.hashWithSalt` registerDevice_result_e record  
instance QC.Arbitrary RegisterDevice_result where 
  arbitrary = M.liftM RegisterDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDevice_result{registerDevice_result_success = registerDevice_result_success obj} then P.Nothing else P.Just $ default_RegisterDevice_result{registerDevice_result_success = registerDevice_result_success obj}
    , if obj == default_RegisterDevice_result{registerDevice_result_e = registerDevice_result_e obj} then P.Nothing else P.Just $ default_RegisterDevice_result{registerDevice_result_e = registerDevice_result_e obj}
    ]
from_RegisterDevice_result :: RegisterDevice_result -> T.ThriftVal
from_RegisterDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8102 -> (1, ("e",from_TalkException _v8102))) <$> registerDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8102 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8102))) $ registerDevice_result_success record
    , (\_v8102 -> (1, ("e",from_TalkException _v8102))) <$> registerDevice_result_e record
    ]
    )
write_RegisterDevice_result :: T.Protocol p => p -> RegisterDevice_result -> P.IO ()
write_RegisterDevice_result oprot record = T.writeVal oprot $ from_RegisterDevice_result record
encode_RegisterDevice_result :: T.StatelessProtocol p => p -> RegisterDevice_result -> LBS.ByteString
encode_RegisterDevice_result oprot record = T.serializeVal oprot $ from_RegisterDevice_result record
to_RegisterDevice_result :: T.ThriftVal -> RegisterDevice_result
to_RegisterDevice_result (T.TStruct fields) = RegisterDevice_result{
  registerDevice_result_success = P.maybe (registerDevice_result_success default_RegisterDevice_result) (\(_,_val8104) -> (case _val8104 of {T.TString _val8105 -> E.decodeUtf8 _val8105; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDevice_result_e = P.maybe (P.Nothing) (\(_,_val8104) -> P.Just (case _val8104 of {T.TStruct _val8106 -> (to_TalkException (T.TStruct _val8106)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDevice_result _ = P.error "not a struct"
read_RegisterDevice_result :: T.Protocol p => p -> P.IO RegisterDevice_result
read_RegisterDevice_result iprot = to_RegisterDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDevice_result)
decode_RegisterDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDevice_result
decode_RegisterDevice_result iprot bs = to_RegisterDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDevice_result) bs
typemap_RegisterDevice_result :: T.TypeMap
typemap_RegisterDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDevice_result :: RegisterDevice_result
default_RegisterDevice_result = RegisterDevice_result{
  registerDevice_result_success = "",
  registerDevice_result_e = P.Nothing}
data RegisterDeviceWithIdentityCredential_args = RegisterDeviceWithIdentityCredential_args  { registerDeviceWithIdentityCredential_args_sessionId :: LT.Text
  , registerDeviceWithIdentityCredential_args_provider :: IdentityProvider
  , registerDeviceWithIdentityCredential_args_identifier :: LT.Text
  , registerDeviceWithIdentityCredential_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_sessionId record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_provider record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_identifier record   `H.hashWithSalt` registerDeviceWithIdentityCredential_args_verifier record  
instance QC.Arbitrary RegisterDeviceWithIdentityCredential_args where 
  arbitrary = M.liftM RegisterDeviceWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_sessionId = registerDeviceWithIdentityCredential_args_sessionId obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_sessionId = registerDeviceWithIdentityCredential_args_sessionId obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_provider = registerDeviceWithIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_provider = registerDeviceWithIdentityCredential_args_provider obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_identifier = registerDeviceWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_identifier = registerDeviceWithIdentityCredential_args_identifier obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_verifier = registerDeviceWithIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_args{registerDeviceWithIdentityCredential_args_verifier = registerDeviceWithIdentityCredential_args_verifier obj}
    ]
from_RegisterDeviceWithIdentityCredential_args :: RegisterDeviceWithIdentityCredential_args -> T.ThriftVal
from_RegisterDeviceWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8109 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v8109))) $ registerDeviceWithIdentityCredential_args_sessionId record
  , (\_v8109 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v8109))) $ registerDeviceWithIdentityCredential_args_identifier record
  , (\_v8109 -> P.Just (4, ("verifier",T.TString $ E.encodeUtf8 _v8109))) $ registerDeviceWithIdentityCredential_args_verifier record
  , (\_v8109 -> P.Just (5, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v8109))) $ registerDeviceWithIdentityCredential_args_provider record
  ]
write_RegisterDeviceWithIdentityCredential_args :: T.Protocol p => p -> RegisterDeviceWithIdentityCredential_args -> P.IO ()
write_RegisterDeviceWithIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithIdentityCredential_args record
encode_RegisterDeviceWithIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterDeviceWithIdentityCredential_args -> LBS.ByteString
encode_RegisterDeviceWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithIdentityCredential_args record
to_RegisterDeviceWithIdentityCredential_args :: T.ThriftVal -> RegisterDeviceWithIdentityCredential_args
to_RegisterDeviceWithIdentityCredential_args (T.TStruct fields) = RegisterDeviceWithIdentityCredential_args{
  registerDeviceWithIdentityCredential_args_sessionId = P.maybe (registerDeviceWithIdentityCredential_args_sessionId default_RegisterDeviceWithIdentityCredential_args) (\(_,_val8111) -> (case _val8111 of {T.TString _val8112 -> E.decodeUtf8 _val8112; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithIdentityCredential_args_provider = P.maybe (registerDeviceWithIdentityCredential_args_provider default_RegisterDeviceWithIdentityCredential_args) (\(_,_val8111) -> (case _val8111 of {T.TI32 _val8113 -> P.toEnum $ P.fromIntegral _val8113; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerDeviceWithIdentityCredential_args_identifier = P.maybe (registerDeviceWithIdentityCredential_args_identifier default_RegisterDeviceWithIdentityCredential_args) (\(_,_val8111) -> (case _val8111 of {T.TString _val8114 -> E.decodeUtf8 _val8114; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithIdentityCredential_args_verifier = P.maybe (registerDeviceWithIdentityCredential_args_verifier default_RegisterDeviceWithIdentityCredential_args) (\(_,_val8111) -> (case _val8111 of {T.TString _val8115 -> E.decodeUtf8 _val8115; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterDeviceWithIdentityCredential_args _ = P.error "not a struct"
read_RegisterDeviceWithIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterDeviceWithIdentityCredential_args
read_RegisterDeviceWithIdentityCredential_args iprot = to_RegisterDeviceWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_args)
decode_RegisterDeviceWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithIdentityCredential_args
decode_RegisterDeviceWithIdentityCredential_args iprot bs = to_RegisterDeviceWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_args) bs
typemap_RegisterDeviceWithIdentityCredential_args :: T.TypeMap
typemap_RegisterDeviceWithIdentityCredential_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("identifier",T.T_STRING)),(4,("verifier",T.T_STRING)),(5,("provider",T.T_I32))]
default_RegisterDeviceWithIdentityCredential_args :: RegisterDeviceWithIdentityCredential_args
default_RegisterDeviceWithIdentityCredential_args = RegisterDeviceWithIdentityCredential_args{
  registerDeviceWithIdentityCredential_args_sessionId = "",
  registerDeviceWithIdentityCredential_args_identifier = "",
  registerDeviceWithIdentityCredential_args_verifier = "",
  registerDeviceWithIdentityCredential_args_provider = (P.toEnum 0)}
data RegisterDeviceWithIdentityCredential_result = RegisterDeviceWithIdentityCredential_result  { registerDeviceWithIdentityCredential_result_success :: LT.Text
  , registerDeviceWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithIdentityCredential_result_success record   `H.hashWithSalt` registerDeviceWithIdentityCredential_result_e record  
instance QC.Arbitrary RegisterDeviceWithIdentityCredential_result where 
  arbitrary = M.liftM RegisterDeviceWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = registerDeviceWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = registerDeviceWithIdentityCredential_result_success obj}
    , if obj == default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = registerDeviceWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = registerDeviceWithIdentityCredential_result_e obj}
    ]
from_RegisterDeviceWithIdentityCredential_result :: RegisterDeviceWithIdentityCredential_result -> T.ThriftVal
from_RegisterDeviceWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8118 -> (1, ("e",from_TalkException _v8118))) <$> registerDeviceWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8118 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8118))) $ registerDeviceWithIdentityCredential_result_success record
    , (\_v8118 -> (1, ("e",from_TalkException _v8118))) <$> registerDeviceWithIdentityCredential_result_e record
    ]
    )
write_RegisterDeviceWithIdentityCredential_result :: T.Protocol p => p -> RegisterDeviceWithIdentityCredential_result -> P.IO ()
write_RegisterDeviceWithIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithIdentityCredential_result record
encode_RegisterDeviceWithIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterDeviceWithIdentityCredential_result -> LBS.ByteString
encode_RegisterDeviceWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithIdentityCredential_result record
to_RegisterDeviceWithIdentityCredential_result :: T.ThriftVal -> RegisterDeviceWithIdentityCredential_result
to_RegisterDeviceWithIdentityCredential_result (T.TStruct fields) = RegisterDeviceWithIdentityCredential_result{
  registerDeviceWithIdentityCredential_result_success = P.maybe (registerDeviceWithIdentityCredential_result_success default_RegisterDeviceWithIdentityCredential_result) (\(_,_val8120) -> (case _val8120 of {T.TString _val8121 -> E.decodeUtf8 _val8121; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val8120) -> P.Just (case _val8120 of {T.TStruct _val8122 -> (to_TalkException (T.TStruct _val8122)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithIdentityCredential_result _ = P.error "not a struct"
read_RegisterDeviceWithIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterDeviceWithIdentityCredential_result
read_RegisterDeviceWithIdentityCredential_result iprot = to_RegisterDeviceWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_result)
decode_RegisterDeviceWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithIdentityCredential_result
decode_RegisterDeviceWithIdentityCredential_result iprot bs = to_RegisterDeviceWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithIdentityCredential_result) bs
typemap_RegisterDeviceWithIdentityCredential_result :: T.TypeMap
typemap_RegisterDeviceWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithIdentityCredential_result :: RegisterDeviceWithIdentityCredential_result
default_RegisterDeviceWithIdentityCredential_result = RegisterDeviceWithIdentityCredential_result{
  registerDeviceWithIdentityCredential_result_success = "",
  registerDeviceWithIdentityCredential_result_e = P.Nothing}
data RegisterDeviceWithoutPhoneNumber_args = RegisterDeviceWithoutPhoneNumber_args  { registerDeviceWithoutPhoneNumber_args_region :: LT.Text
  , registerDeviceWithoutPhoneNumber_args_udidHash :: LT.Text
  , registerDeviceWithoutPhoneNumber_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_region record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_udidHash record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_args_deviceInfo record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumber_args where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_region = registerDeviceWithoutPhoneNumber_args_region obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_region = registerDeviceWithoutPhoneNumber_args_region obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_udidHash = registerDeviceWithoutPhoneNumber_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_udidHash = registerDeviceWithoutPhoneNumber_args_udidHash obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_deviceInfo = registerDeviceWithoutPhoneNumber_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_args{registerDeviceWithoutPhoneNumber_args_deviceInfo = registerDeviceWithoutPhoneNumber_args_deviceInfo obj}
    ]
from_RegisterDeviceWithoutPhoneNumber_args :: RegisterDeviceWithoutPhoneNumber_args -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8125 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v8125))) $ registerDeviceWithoutPhoneNumber_args_region record
  , (\_v8125 -> P.Just (3, ("udidHash",T.TString $ E.encodeUtf8 _v8125))) $ registerDeviceWithoutPhoneNumber_args_udidHash record
  , (\_v8125 -> P.Just (4, ("deviceInfo",from_DeviceInfo _v8125))) $ registerDeviceWithoutPhoneNumber_args_deviceInfo record
  ]
write_RegisterDeviceWithoutPhoneNumber_args :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumber_args -> P.IO ()
write_RegisterDeviceWithoutPhoneNumber_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_args record
encode_RegisterDeviceWithoutPhoneNumber_args :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumber_args -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumber_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_args record
to_RegisterDeviceWithoutPhoneNumber_args :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumber_args
to_RegisterDeviceWithoutPhoneNumber_args (T.TStruct fields) = RegisterDeviceWithoutPhoneNumber_args{
  registerDeviceWithoutPhoneNumber_args_region = P.maybe (registerDeviceWithoutPhoneNumber_args_region default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val8127) -> (case _val8127 of {T.TString _val8128 -> E.decodeUtf8 _val8128; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithoutPhoneNumber_args_udidHash = P.maybe (registerDeviceWithoutPhoneNumber_args_udidHash default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val8127) -> (case _val8127 of {T.TString _val8129 -> E.decodeUtf8 _val8129; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithoutPhoneNumber_args_deviceInfo = P.maybe (registerDeviceWithoutPhoneNumber_args_deviceInfo default_RegisterDeviceWithoutPhoneNumber_args) (\(_,_val8127) -> (case _val8127 of {T.TStruct _val8130 -> (to_DeviceInfo (T.TStruct _val8130)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RegisterDeviceWithoutPhoneNumber_args _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumber_args :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumber_args
read_RegisterDeviceWithoutPhoneNumber_args iprot = to_RegisterDeviceWithoutPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_args)
decode_RegisterDeviceWithoutPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumber_args
decode_RegisterDeviceWithoutPhoneNumber_args iprot bs = to_RegisterDeviceWithoutPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_args) bs
typemap_RegisterDeviceWithoutPhoneNumber_args :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumber_args = Map.fromList [(2,("region",T.T_STRING)),(3,("udidHash",T.T_STRING)),(4,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterDeviceWithoutPhoneNumber_args :: RegisterDeviceWithoutPhoneNumber_args
default_RegisterDeviceWithoutPhoneNumber_args = RegisterDeviceWithoutPhoneNumber_args{
  registerDeviceWithoutPhoneNumber_args_region = "",
  registerDeviceWithoutPhoneNumber_args_udidHash = "",
  registerDeviceWithoutPhoneNumber_args_deviceInfo = default_DeviceInfo}
data RegisterDeviceWithoutPhoneNumber_result = RegisterDeviceWithoutPhoneNumber_result  { registerDeviceWithoutPhoneNumber_result_success :: LT.Text
  , registerDeviceWithoutPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_result_success record   `H.hashWithSalt` registerDeviceWithoutPhoneNumber_result_e record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumber_result where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = registerDeviceWithoutPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = registerDeviceWithoutPhoneNumber_result_success obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = registerDeviceWithoutPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = registerDeviceWithoutPhoneNumber_result_e obj}
    ]
from_RegisterDeviceWithoutPhoneNumber_result :: RegisterDeviceWithoutPhoneNumber_result -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8133 -> (1, ("e",from_TalkException _v8133))) <$> registerDeviceWithoutPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8133 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8133))) $ registerDeviceWithoutPhoneNumber_result_success record
    , (\_v8133 -> (1, ("e",from_TalkException _v8133))) <$> registerDeviceWithoutPhoneNumber_result_e record
    ]
    )
write_RegisterDeviceWithoutPhoneNumber_result :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumber_result -> P.IO ()
write_RegisterDeviceWithoutPhoneNumber_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_result record
encode_RegisterDeviceWithoutPhoneNumber_result :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumber_result -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumber_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumber_result record
to_RegisterDeviceWithoutPhoneNumber_result :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumber_result
to_RegisterDeviceWithoutPhoneNumber_result (T.TStruct fields) = RegisterDeviceWithoutPhoneNumber_result{
  registerDeviceWithoutPhoneNumber_result_success = P.maybe (registerDeviceWithoutPhoneNumber_result_success default_RegisterDeviceWithoutPhoneNumber_result) (\(_,_val8135) -> (case _val8135 of {T.TString _val8136 -> E.decodeUtf8 _val8136; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithoutPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val8135) -> P.Just (case _val8135 of {T.TStruct _val8137 -> (to_TalkException (T.TStruct _val8137)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithoutPhoneNumber_result _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumber_result :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumber_result
read_RegisterDeviceWithoutPhoneNumber_result iprot = to_RegisterDeviceWithoutPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_result)
decode_RegisterDeviceWithoutPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumber_result
decode_RegisterDeviceWithoutPhoneNumber_result iprot bs = to_RegisterDeviceWithoutPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumber_result) bs
typemap_RegisterDeviceWithoutPhoneNumber_result :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumber_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithoutPhoneNumber_result :: RegisterDeviceWithoutPhoneNumber_result
default_RegisterDeviceWithoutPhoneNumber_result = RegisterDeviceWithoutPhoneNumber_result{
  registerDeviceWithoutPhoneNumber_result_success = "",
  registerDeviceWithoutPhoneNumber_result_e = P.Nothing}
data RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args  { registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo :: DeviceInfo
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider :: IdentityProvider
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId = registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId obj}
    ]
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8140 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region record
  , (\_v8140 -> P.Just (3, ("udidHash",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash record
  , (\_v8140 -> P.Just (4, ("deviceInfo",from_DeviceInfo _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo record
  , (\_v8140 -> P.Just (5, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider record
  , (\_v8140 -> P.Just (6, ("identifier",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier record
  , (\_v8140 -> P.Just (7, ("verifier",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier record
  , (\_v8140 -> P.Just (8, ("mid",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid record
  , (\_v8140 -> P.Just (9, ("migrationPincodeSessionId",T.TString $ E.encodeUtf8 _v8140))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId record
  ]
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> P.IO ()
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args record
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args (T.TStruct fields) = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8143 -> E.decodeUtf8 _val8143; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8144 -> E.decodeUtf8 _val8144; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TStruct _val8145 -> (to_DeviceInfo (T.TStruct _val8145)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TI32 _val8146 -> P.toEnum $ P.fromIntegral _val8146; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8147 -> E.decodeUtf8 _val8147; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8148 -> E.decodeUtf8 _val8148; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8149 -> E.decodeUtf8 _val8149; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) (\(_,_val8142) -> (case _val8142 of {T.TString _val8150 -> E.decodeUtf8 _val8150; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args)
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot bs = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args) bs
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = Map.fromList [(2,("region",T.T_STRING)),(3,("udidHash",T.T_STRING)),(4,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(5,("provider",T.T_I32)),(6,("identifier",T.T_STRING)),(7,("verifier",T.T_STRING)),(8,("mid",T.T_STRING)),(9,("migrationPincodeSessionId",T.T_STRING))]
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo = default_DeviceInfo,
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider = (P.toEnum 0),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId = ""}
data RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result  { registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success :: LT.Text
  , registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success record   `H.hashWithSalt` registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record  
instance QC.Arbitrary RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result where 
  arbitrary = M.liftM RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success obj}
    , if obj == default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e obj}
    ]
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> T.ThriftVal
from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8153 -> (1, ("e",from_TalkException _v8153))) <$> registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8153 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8153))) $ registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success record
    , (\_v8153 -> (1, ("e",from_TalkException _v8153))) <$> registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e record
    ]
    )
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.Protocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> P.IO ()
write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result -> LBS.ByteString
encode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result record
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.ThriftVal -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result (T.TStruct fields) = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = P.maybe (registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result) (\(_,_val8155) -> (case _val8155 of {T.TString _val8156 -> E.decodeUtf8 _val8156; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val8155) -> P.Just (case _val8155 of {T.TStruct _val8157 -> (to_TalkException (T.TStruct _val8157)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result _ = P.error "not a struct"
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result iprot = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result)
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
decode_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result iprot bs = to_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result) bs
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: T.TypeMap
typemap_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result :: RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result
default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result = RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = "",
  registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.Nothing}
data RegisterUserid_args = RegisterUserid_args  { registerUserid_args_reqSeq :: I.Int32
  , registerUserid_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterUserid_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerUserid_args_reqSeq record   `H.hashWithSalt` registerUserid_args_userid record  
instance QC.Arbitrary RegisterUserid_args where 
  arbitrary = M.liftM RegisterUserid_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterUserid_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterUserid_args{registerUserid_args_reqSeq = registerUserid_args_reqSeq obj} then P.Nothing else P.Just $ default_RegisterUserid_args{registerUserid_args_reqSeq = registerUserid_args_reqSeq obj}
    , if obj == default_RegisterUserid_args{registerUserid_args_userid = registerUserid_args_userid obj} then P.Nothing else P.Just $ default_RegisterUserid_args{registerUserid_args_userid = registerUserid_args_userid obj}
    ]
from_RegisterUserid_args :: RegisterUserid_args -> T.ThriftVal
from_RegisterUserid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8160 -> P.Just (1, ("reqSeq",T.TI32 _v8160))) $ registerUserid_args_reqSeq record
  , (\_v8160 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v8160))) $ registerUserid_args_userid record
  ]
write_RegisterUserid_args :: T.Protocol p => p -> RegisterUserid_args -> P.IO ()
write_RegisterUserid_args oprot record = T.writeVal oprot $ from_RegisterUserid_args record
encode_RegisterUserid_args :: T.StatelessProtocol p => p -> RegisterUserid_args -> LBS.ByteString
encode_RegisterUserid_args oprot record = T.serializeVal oprot $ from_RegisterUserid_args record
to_RegisterUserid_args :: T.ThriftVal -> RegisterUserid_args
to_RegisterUserid_args (T.TStruct fields) = RegisterUserid_args{
  registerUserid_args_reqSeq = P.maybe (registerUserid_args_reqSeq default_RegisterUserid_args) (\(_,_val8162) -> (case _val8162 of {T.TI32 _val8163 -> _val8163; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerUserid_args_userid = P.maybe (registerUserid_args_userid default_RegisterUserid_args) (\(_,_val8162) -> (case _val8162 of {T.TString _val8164 -> E.decodeUtf8 _val8164; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterUserid_args _ = P.error "not a struct"
read_RegisterUserid_args :: T.Protocol p => p -> P.IO RegisterUserid_args
read_RegisterUserid_args iprot = to_RegisterUserid_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterUserid_args)
decode_RegisterUserid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterUserid_args
decode_RegisterUserid_args iprot bs = to_RegisterUserid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterUserid_args) bs
typemap_RegisterUserid_args :: T.TypeMap
typemap_RegisterUserid_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("userid",T.T_STRING))]
default_RegisterUserid_args :: RegisterUserid_args
default_RegisterUserid_args = RegisterUserid_args{
  registerUserid_args_reqSeq = 0,
  registerUserid_args_userid = ""}
data RegisterUserid_result = RegisterUserid_result  { registerUserid_result_success :: P.Bool
  , registerUserid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterUserid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerUserid_result_success record   `H.hashWithSalt` registerUserid_result_e record  
instance QC.Arbitrary RegisterUserid_result where 
  arbitrary = M.liftM RegisterUserid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterUserid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterUserid_result{registerUserid_result_success = registerUserid_result_success obj} then P.Nothing else P.Just $ default_RegisterUserid_result{registerUserid_result_success = registerUserid_result_success obj}
    , if obj == default_RegisterUserid_result{registerUserid_result_e = registerUserid_result_e obj} then P.Nothing else P.Just $ default_RegisterUserid_result{registerUserid_result_e = registerUserid_result_e obj}
    ]
from_RegisterUserid_result :: RegisterUserid_result -> T.ThriftVal
from_RegisterUserid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8167 -> (1, ("e",from_TalkException _v8167))) <$> registerUserid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8167 -> P.Just (0, ("success",T.TBool _v8167))) $ registerUserid_result_success record
    , (\_v8167 -> (1, ("e",from_TalkException _v8167))) <$> registerUserid_result_e record
    ]
    )
write_RegisterUserid_result :: T.Protocol p => p -> RegisterUserid_result -> P.IO ()
write_RegisterUserid_result oprot record = T.writeVal oprot $ from_RegisterUserid_result record
encode_RegisterUserid_result :: T.StatelessProtocol p => p -> RegisterUserid_result -> LBS.ByteString
encode_RegisterUserid_result oprot record = T.serializeVal oprot $ from_RegisterUserid_result record
to_RegisterUserid_result :: T.ThriftVal -> RegisterUserid_result
to_RegisterUserid_result (T.TStruct fields) = RegisterUserid_result{
  registerUserid_result_success = P.maybe (registerUserid_result_success default_RegisterUserid_result) (\(_,_val8169) -> (case _val8169 of {T.TBool _val8170 -> _val8170; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerUserid_result_e = P.maybe (P.Nothing) (\(_,_val8169) -> P.Just (case _val8169 of {T.TStruct _val8171 -> (to_TalkException (T.TStruct _val8171)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterUserid_result _ = P.error "not a struct"
read_RegisterUserid_result :: T.Protocol p => p -> P.IO RegisterUserid_result
read_RegisterUserid_result iprot = to_RegisterUserid_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterUserid_result)
decode_RegisterUserid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterUserid_result
decode_RegisterUserid_result iprot bs = to_RegisterUserid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterUserid_result) bs
typemap_RegisterUserid_result :: T.TypeMap
typemap_RegisterUserid_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterUserid_result :: RegisterUserid_result
default_RegisterUserid_result = RegisterUserid_result{
  registerUserid_result_success = P.False,
  registerUserid_result_e = P.Nothing}
data RegisterWapDevice_args = RegisterWapDevice_args  { registerWapDevice_args_invitationHash :: LT.Text
  , registerWapDevice_args_guidHash :: LT.Text
  , registerWapDevice_args_email :: LT.Text
  , registerWapDevice_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWapDevice_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWapDevice_args_invitationHash record   `H.hashWithSalt` registerWapDevice_args_guidHash record   `H.hashWithSalt` registerWapDevice_args_email record   `H.hashWithSalt` registerWapDevice_args_deviceInfo record  
instance QC.Arbitrary RegisterWapDevice_args where 
  arbitrary = M.liftM RegisterWapDevice_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWapDevice_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWapDevice_args{registerWapDevice_args_invitationHash = registerWapDevice_args_invitationHash obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_invitationHash = registerWapDevice_args_invitationHash obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_guidHash = registerWapDevice_args_guidHash obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_guidHash = registerWapDevice_args_guidHash obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_email = registerWapDevice_args_email obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_email = registerWapDevice_args_email obj}
    , if obj == default_RegisterWapDevice_args{registerWapDevice_args_deviceInfo = registerWapDevice_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWapDevice_args{registerWapDevice_args_deviceInfo = registerWapDevice_args_deviceInfo obj}
    ]
from_RegisterWapDevice_args :: RegisterWapDevice_args -> T.ThriftVal
from_RegisterWapDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8174 -> P.Just (2, ("invitationHash",T.TString $ E.encodeUtf8 _v8174))) $ registerWapDevice_args_invitationHash record
  , (\_v8174 -> P.Just (3, ("guidHash",T.TString $ E.encodeUtf8 _v8174))) $ registerWapDevice_args_guidHash record
  , (\_v8174 -> P.Just (4, ("email",T.TString $ E.encodeUtf8 _v8174))) $ registerWapDevice_args_email record
  , (\_v8174 -> P.Just (5, ("deviceInfo",from_DeviceInfo _v8174))) $ registerWapDevice_args_deviceInfo record
  ]
write_RegisterWapDevice_args :: T.Protocol p => p -> RegisterWapDevice_args -> P.IO ()
write_RegisterWapDevice_args oprot record = T.writeVal oprot $ from_RegisterWapDevice_args record
encode_RegisterWapDevice_args :: T.StatelessProtocol p => p -> RegisterWapDevice_args -> LBS.ByteString
encode_RegisterWapDevice_args oprot record = T.serializeVal oprot $ from_RegisterWapDevice_args record
to_RegisterWapDevice_args :: T.ThriftVal -> RegisterWapDevice_args
to_RegisterWapDevice_args (T.TStruct fields) = RegisterWapDevice_args{
  registerWapDevice_args_invitationHash = P.maybe (registerWapDevice_args_invitationHash default_RegisterWapDevice_args) (\(_,_val8176) -> (case _val8176 of {T.TString _val8177 -> E.decodeUtf8 _val8177; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWapDevice_args_guidHash = P.maybe (registerWapDevice_args_guidHash default_RegisterWapDevice_args) (\(_,_val8176) -> (case _val8176 of {T.TString _val8178 -> E.decodeUtf8 _val8178; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWapDevice_args_email = P.maybe (registerWapDevice_args_email default_RegisterWapDevice_args) (\(_,_val8176) -> (case _val8176 of {T.TString _val8179 -> E.decodeUtf8 _val8179; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWapDevice_args_deviceInfo = P.maybe (registerWapDevice_args_deviceInfo default_RegisterWapDevice_args) (\(_,_val8176) -> (case _val8176 of {T.TStruct _val8180 -> (to_DeviceInfo (T.TStruct _val8180)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RegisterWapDevice_args _ = P.error "not a struct"
read_RegisterWapDevice_args :: T.Protocol p => p -> P.IO RegisterWapDevice_args
read_RegisterWapDevice_args iprot = to_RegisterWapDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWapDevice_args)
decode_RegisterWapDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWapDevice_args
decode_RegisterWapDevice_args iprot bs = to_RegisterWapDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWapDevice_args) bs
typemap_RegisterWapDevice_args :: T.TypeMap
typemap_RegisterWapDevice_args = Map.fromList [(2,("invitationHash",T.T_STRING)),(3,("guidHash",T.T_STRING)),(4,("email",T.T_STRING)),(5,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWapDevice_args :: RegisterWapDevice_args
default_RegisterWapDevice_args = RegisterWapDevice_args{
  registerWapDevice_args_invitationHash = "",
  registerWapDevice_args_guidHash = "",
  registerWapDevice_args_email = "",
  registerWapDevice_args_deviceInfo = default_DeviceInfo}
data RegisterWapDevice_result = RegisterWapDevice_result  { registerWapDevice_result_success :: LT.Text
  , registerWapDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWapDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWapDevice_result_success record   `H.hashWithSalt` registerWapDevice_result_e record  
instance QC.Arbitrary RegisterWapDevice_result where 
  arbitrary = M.liftM RegisterWapDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWapDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWapDevice_result{registerWapDevice_result_success = registerWapDevice_result_success obj} then P.Nothing else P.Just $ default_RegisterWapDevice_result{registerWapDevice_result_success = registerWapDevice_result_success obj}
    , if obj == default_RegisterWapDevice_result{registerWapDevice_result_e = registerWapDevice_result_e obj} then P.Nothing else P.Just $ default_RegisterWapDevice_result{registerWapDevice_result_e = registerWapDevice_result_e obj}
    ]
from_RegisterWapDevice_result :: RegisterWapDevice_result -> T.ThriftVal
from_RegisterWapDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8183 -> (1, ("e",from_TalkException _v8183))) <$> registerWapDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8183 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8183))) $ registerWapDevice_result_success record
    , (\_v8183 -> (1, ("e",from_TalkException _v8183))) <$> registerWapDevice_result_e record
    ]
    )
write_RegisterWapDevice_result :: T.Protocol p => p -> RegisterWapDevice_result -> P.IO ()
write_RegisterWapDevice_result oprot record = T.writeVal oprot $ from_RegisterWapDevice_result record
encode_RegisterWapDevice_result :: T.StatelessProtocol p => p -> RegisterWapDevice_result -> LBS.ByteString
encode_RegisterWapDevice_result oprot record = T.serializeVal oprot $ from_RegisterWapDevice_result record
to_RegisterWapDevice_result :: T.ThriftVal -> RegisterWapDevice_result
to_RegisterWapDevice_result (T.TStruct fields) = RegisterWapDevice_result{
  registerWapDevice_result_success = P.maybe (registerWapDevice_result_success default_RegisterWapDevice_result) (\(_,_val8185) -> (case _val8185 of {T.TString _val8186 -> E.decodeUtf8 _val8186; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWapDevice_result_e = P.maybe (P.Nothing) (\(_,_val8185) -> P.Just (case _val8185 of {T.TStruct _val8187 -> (to_TalkException (T.TStruct _val8187)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWapDevice_result _ = P.error "not a struct"
read_RegisterWapDevice_result :: T.Protocol p => p -> P.IO RegisterWapDevice_result
read_RegisterWapDevice_result iprot = to_RegisterWapDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWapDevice_result)
decode_RegisterWapDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWapDevice_result
decode_RegisterWapDevice_result iprot bs = to_RegisterWapDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWapDevice_result) bs
typemap_RegisterWapDevice_result :: T.TypeMap
typemap_RegisterWapDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWapDevice_result :: RegisterWapDevice_result
default_RegisterWapDevice_result = RegisterWapDevice_result{
  registerWapDevice_result_success = "",
  registerWapDevice_result_e = P.Nothing}
data RegisterWithExistingSnsIdAndIdentityCredential_args = RegisterWithExistingSnsIdAndIdentityCredential_args  { registerWithExistingSnsIdAndIdentityCredential_args_identityCredential :: IdentityCredential
  , registerWithExistingSnsIdAndIdentityCredential_args_region :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_args_udidHash :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithExistingSnsIdAndIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_identityCredential record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_region record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_udidHash record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo record  
instance QC.Arbitrary RegisterWithExistingSnsIdAndIdentityCredential_args where 
  arbitrary = M.liftM RegisterWithExistingSnsIdAndIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = registerWithExistingSnsIdAndIdentityCredential_args_identityCredential obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = registerWithExistingSnsIdAndIdentityCredential_args_identityCredential obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_region = registerWithExistingSnsIdAndIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_region = registerWithExistingSnsIdAndIdentityCredential_args_region obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_udidHash = registerWithExistingSnsIdAndIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_udidHash = registerWithExistingSnsIdAndIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_args{registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo obj}
    ]
from_RegisterWithExistingSnsIdAndIdentityCredential_args :: RegisterWithExistingSnsIdAndIdentityCredential_args -> T.ThriftVal
from_RegisterWithExistingSnsIdAndIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8190 -> P.Just (2, ("identityCredential",from_IdentityCredential _v8190))) $ registerWithExistingSnsIdAndIdentityCredential_args_identityCredential record
  , (\_v8190 -> P.Just (3, ("region",T.TString $ E.encodeUtf8 _v8190))) $ registerWithExistingSnsIdAndIdentityCredential_args_region record
  , (\_v8190 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v8190))) $ registerWithExistingSnsIdAndIdentityCredential_args_udidHash record
  , (\_v8190 -> P.Just (5, ("deviceInfo",from_DeviceInfo _v8190))) $ registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo record
  ]
write_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.Protocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_args -> P.IO ()
write_RegisterWithExistingSnsIdAndIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_args record
encode_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_args -> LBS.ByteString
encode_RegisterWithExistingSnsIdAndIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_args record
to_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.ThriftVal -> RegisterWithExistingSnsIdAndIdentityCredential_args
to_RegisterWithExistingSnsIdAndIdentityCredential_args (T.TStruct fields) = RegisterWithExistingSnsIdAndIdentityCredential_args{
  registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_identityCredential default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val8192) -> (case _val8192 of {T.TStruct _val8193 -> (to_IdentityCredential (T.TStruct _val8193)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_region = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_region default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val8192) -> (case _val8192 of {T.TString _val8194 -> E.decodeUtf8 _val8194; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_udidHash = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_udidHash default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val8192) -> (case _val8192 of {T.TString _val8195 -> E.decodeUtf8 _val8195; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = P.maybe (registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo default_RegisterWithExistingSnsIdAndIdentityCredential_args) (\(_,_val8192) -> (case _val8192 of {T.TStruct _val8196 -> (to_DeviceInfo (T.TStruct _val8196)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RegisterWithExistingSnsIdAndIdentityCredential_args _ = P.error "not a struct"
read_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterWithExistingSnsIdAndIdentityCredential_args
read_RegisterWithExistingSnsIdAndIdentityCredential_args iprot = to_RegisterWithExistingSnsIdAndIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_args)
decode_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithExistingSnsIdAndIdentityCredential_args
decode_RegisterWithExistingSnsIdAndIdentityCredential_args iprot bs = to_RegisterWithExistingSnsIdAndIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_args) bs
typemap_RegisterWithExistingSnsIdAndIdentityCredential_args :: T.TypeMap
typemap_RegisterWithExistingSnsIdAndIdentityCredential_args = Map.fromList [(2,("identityCredential",(T.T_STRUCT typemap_IdentityCredential))),(3,("region",T.T_STRING)),(4,("udidHash",T.T_STRING)),(5,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWithExistingSnsIdAndIdentityCredential_args :: RegisterWithExistingSnsIdAndIdentityCredential_args
default_RegisterWithExistingSnsIdAndIdentityCredential_args = RegisterWithExistingSnsIdAndIdentityCredential_args{
  registerWithExistingSnsIdAndIdentityCredential_args_identityCredential = default_IdentityCredential,
  registerWithExistingSnsIdAndIdentityCredential_args_region = "",
  registerWithExistingSnsIdAndIdentityCredential_args_udidHash = "",
  registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo = default_DeviceInfo}
data RegisterWithExistingSnsIdAndIdentityCredential_result = RegisterWithExistingSnsIdAndIdentityCredential_result  { registerWithExistingSnsIdAndIdentityCredential_result_success :: LT.Text
  , registerWithExistingSnsIdAndIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithExistingSnsIdAndIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_result_success record   `H.hashWithSalt` registerWithExistingSnsIdAndIdentityCredential_result_e record  
instance QC.Arbitrary RegisterWithExistingSnsIdAndIdentityCredential_result where 
  arbitrary = M.liftM RegisterWithExistingSnsIdAndIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = registerWithExistingSnsIdAndIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = registerWithExistingSnsIdAndIdentityCredential_result_success obj}
    , if obj == default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = registerWithExistingSnsIdAndIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = registerWithExistingSnsIdAndIdentityCredential_result_e obj}
    ]
from_RegisterWithExistingSnsIdAndIdentityCredential_result :: RegisterWithExistingSnsIdAndIdentityCredential_result -> T.ThriftVal
from_RegisterWithExistingSnsIdAndIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8199 -> (1, ("e",from_TalkException _v8199))) <$> registerWithExistingSnsIdAndIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8199 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8199))) $ registerWithExistingSnsIdAndIdentityCredential_result_success record
    , (\_v8199 -> (1, ("e",from_TalkException _v8199))) <$> registerWithExistingSnsIdAndIdentityCredential_result_e record
    ]
    )
write_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.Protocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_result -> P.IO ()
write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_result record
encode_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterWithExistingSnsIdAndIdentityCredential_result -> LBS.ByteString
encode_RegisterWithExistingSnsIdAndIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterWithExistingSnsIdAndIdentityCredential_result record
to_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.ThriftVal -> RegisterWithExistingSnsIdAndIdentityCredential_result
to_RegisterWithExistingSnsIdAndIdentityCredential_result (T.TStruct fields) = RegisterWithExistingSnsIdAndIdentityCredential_result{
  registerWithExistingSnsIdAndIdentityCredential_result_success = P.maybe (registerWithExistingSnsIdAndIdentityCredential_result_success default_RegisterWithExistingSnsIdAndIdentityCredential_result) (\(_,_val8201) -> (case _val8201 of {T.TString _val8202 -> E.decodeUtf8 _val8202; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithExistingSnsIdAndIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val8201) -> P.Just (case _val8201 of {T.TStruct _val8203 -> (to_TalkException (T.TStruct _val8203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithExistingSnsIdAndIdentityCredential_result _ = P.error "not a struct"
read_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterWithExistingSnsIdAndIdentityCredential_result
read_RegisterWithExistingSnsIdAndIdentityCredential_result iprot = to_RegisterWithExistingSnsIdAndIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_result)
decode_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithExistingSnsIdAndIdentityCredential_result
decode_RegisterWithExistingSnsIdAndIdentityCredential_result iprot bs = to_RegisterWithExistingSnsIdAndIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithExistingSnsIdAndIdentityCredential_result) bs
typemap_RegisterWithExistingSnsIdAndIdentityCredential_result :: T.TypeMap
typemap_RegisterWithExistingSnsIdAndIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithExistingSnsIdAndIdentityCredential_result :: RegisterWithExistingSnsIdAndIdentityCredential_result
default_RegisterWithExistingSnsIdAndIdentityCredential_result = RegisterWithExistingSnsIdAndIdentityCredential_result{
  registerWithExistingSnsIdAndIdentityCredential_result_success = "",
  registerWithExistingSnsIdAndIdentityCredential_result_e = P.Nothing}
data RegisterWithSnsId_args = RegisterWithSnsId_args  { registerWithSnsId_args_snsIdType :: SnsIdType
  , registerWithSnsId_args_snsAccessToken :: LT.Text
  , registerWithSnsId_args_region :: LT.Text
  , registerWithSnsId_args_udidHash :: LT.Text
  , registerWithSnsId_args_deviceInfo :: DeviceInfo
  , registerWithSnsId_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsId_args_snsIdType record   `H.hashWithSalt` registerWithSnsId_args_snsAccessToken record   `H.hashWithSalt` registerWithSnsId_args_region record   `H.hashWithSalt` registerWithSnsId_args_udidHash record   `H.hashWithSalt` registerWithSnsId_args_deviceInfo record   `H.hashWithSalt` registerWithSnsId_args_mid record  
instance QC.Arbitrary RegisterWithSnsId_args where 
  arbitrary = M.liftM RegisterWithSnsId_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_snsIdType = registerWithSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_snsIdType = registerWithSnsId_args_snsIdType obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_snsAccessToken = registerWithSnsId_args_snsAccessToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_snsAccessToken = registerWithSnsId_args_snsAccessToken obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_region = registerWithSnsId_args_region obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_region = registerWithSnsId_args_region obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_udidHash = registerWithSnsId_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_udidHash = registerWithSnsId_args_udidHash obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_deviceInfo = registerWithSnsId_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_deviceInfo = registerWithSnsId_args_deviceInfo obj}
    , if obj == default_RegisterWithSnsId_args{registerWithSnsId_args_mid = registerWithSnsId_args_mid obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_args{registerWithSnsId_args_mid = registerWithSnsId_args_mid obj}
    ]
from_RegisterWithSnsId_args :: RegisterWithSnsId_args -> T.ThriftVal
from_RegisterWithSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8206 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v8206))) $ registerWithSnsId_args_snsIdType record
  , (\_v8206 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v8206))) $ registerWithSnsId_args_snsAccessToken record
  , (\_v8206 -> P.Just (4, ("region",T.TString $ E.encodeUtf8 _v8206))) $ registerWithSnsId_args_region record
  , (\_v8206 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v8206))) $ registerWithSnsId_args_udidHash record
  , (\_v8206 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v8206))) $ registerWithSnsId_args_deviceInfo record
  , (\_v8206 -> P.Just (7, ("mid",T.TString $ E.encodeUtf8 _v8206))) $ registerWithSnsId_args_mid record
  ]
write_RegisterWithSnsId_args :: T.Protocol p => p -> RegisterWithSnsId_args -> P.IO ()
write_RegisterWithSnsId_args oprot record = T.writeVal oprot $ from_RegisterWithSnsId_args record
encode_RegisterWithSnsId_args :: T.StatelessProtocol p => p -> RegisterWithSnsId_args -> LBS.ByteString
encode_RegisterWithSnsId_args oprot record = T.serializeVal oprot $ from_RegisterWithSnsId_args record
to_RegisterWithSnsId_args :: T.ThriftVal -> RegisterWithSnsId_args
to_RegisterWithSnsId_args (T.TStruct fields) = RegisterWithSnsId_args{
  registerWithSnsId_args_snsIdType = P.maybe (registerWithSnsId_args_snsIdType default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TI32 _val8209 -> P.toEnum $ P.fromIntegral _val8209; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithSnsId_args_snsAccessToken = P.maybe (registerWithSnsId_args_snsAccessToken default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TString _val8210 -> E.decodeUtf8 _val8210; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithSnsId_args_region = P.maybe (registerWithSnsId_args_region default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TString _val8211 -> E.decodeUtf8 _val8211; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithSnsId_args_udidHash = P.maybe (registerWithSnsId_args_udidHash default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TString _val8212 -> E.decodeUtf8 _val8212; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerWithSnsId_args_deviceInfo = P.maybe (registerWithSnsId_args_deviceInfo default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TStruct _val8213 -> (to_DeviceInfo (T.TStruct _val8213)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerWithSnsId_args_mid = P.maybe (registerWithSnsId_args_mid default_RegisterWithSnsId_args) (\(_,_val8208) -> (case _val8208 of {T.TString _val8214 -> E.decodeUtf8 _val8214; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_RegisterWithSnsId_args _ = P.error "not a struct"
read_RegisterWithSnsId_args :: T.Protocol p => p -> P.IO RegisterWithSnsId_args
read_RegisterWithSnsId_args iprot = to_RegisterWithSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_args)
decode_RegisterWithSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsId_args
decode_RegisterWithSnsId_args iprot bs = to_RegisterWithSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_args) bs
typemap_RegisterWithSnsId_args :: T.TypeMap
typemap_RegisterWithSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("region",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("mid",T.T_STRING))]
default_RegisterWithSnsId_args :: RegisterWithSnsId_args
default_RegisterWithSnsId_args = RegisterWithSnsId_args{
  registerWithSnsId_args_snsIdType = (P.toEnum 0),
  registerWithSnsId_args_snsAccessToken = "",
  registerWithSnsId_args_region = "",
  registerWithSnsId_args_udidHash = "",
  registerWithSnsId_args_deviceInfo = default_DeviceInfo,
  registerWithSnsId_args_mid = ""}
data RegisterWithSnsId_result = RegisterWithSnsId_result  { registerWithSnsId_result_success :: RegisterWithSnsIdResult
  , registerWithSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsId_result_success record   `H.hashWithSalt` registerWithSnsId_result_e record  
instance QC.Arbitrary RegisterWithSnsId_result where 
  arbitrary = M.liftM RegisterWithSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsId_result{registerWithSnsId_result_success = registerWithSnsId_result_success obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_result{registerWithSnsId_result_success = registerWithSnsId_result_success obj}
    , if obj == default_RegisterWithSnsId_result{registerWithSnsId_result_e = registerWithSnsId_result_e obj} then P.Nothing else P.Just $ default_RegisterWithSnsId_result{registerWithSnsId_result_e = registerWithSnsId_result_e obj}
    ]
from_RegisterWithSnsId_result :: RegisterWithSnsId_result -> T.ThriftVal
from_RegisterWithSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8217 -> (1, ("e",from_TalkException _v8217))) <$> registerWithSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8217 -> P.Just (0, ("success",from_RegisterWithSnsIdResult _v8217))) $ registerWithSnsId_result_success record
    , (\_v8217 -> (1, ("e",from_TalkException _v8217))) <$> registerWithSnsId_result_e record
    ]
    )
write_RegisterWithSnsId_result :: T.Protocol p => p -> RegisterWithSnsId_result -> P.IO ()
write_RegisterWithSnsId_result oprot record = T.writeVal oprot $ from_RegisterWithSnsId_result record
encode_RegisterWithSnsId_result :: T.StatelessProtocol p => p -> RegisterWithSnsId_result -> LBS.ByteString
encode_RegisterWithSnsId_result oprot record = T.serializeVal oprot $ from_RegisterWithSnsId_result record
to_RegisterWithSnsId_result :: T.ThriftVal -> RegisterWithSnsId_result
to_RegisterWithSnsId_result (T.TStruct fields) = RegisterWithSnsId_result{
  registerWithSnsId_result_success = P.maybe (registerWithSnsId_result_success default_RegisterWithSnsId_result) (\(_,_val8219) -> (case _val8219 of {T.TStruct _val8220 -> (to_RegisterWithSnsIdResult (T.TStruct _val8220)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithSnsId_result_e = P.maybe (P.Nothing) (\(_,_val8219) -> P.Just (case _val8219 of {T.TStruct _val8221 -> (to_TalkException (T.TStruct _val8221)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithSnsId_result _ = P.error "not a struct"
read_RegisterWithSnsId_result :: T.Protocol p => p -> P.IO RegisterWithSnsId_result
read_RegisterWithSnsId_result iprot = to_RegisterWithSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_result)
decode_RegisterWithSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsId_result
decode_RegisterWithSnsId_result iprot bs = to_RegisterWithSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsId_result) bs
typemap_RegisterWithSnsId_result :: T.TypeMap
typemap_RegisterWithSnsId_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RegisterWithSnsIdResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithSnsId_result :: RegisterWithSnsId_result
default_RegisterWithSnsId_result = RegisterWithSnsId_result{
  registerWithSnsId_result_success = default_RegisterWithSnsIdResult,
  registerWithSnsId_result_e = P.Nothing}
data RegisterWithSnsIdAndIdentityCredential_args = RegisterWithSnsIdAndIdentityCredential_args  { registerWithSnsIdAndIdentityCredential_args_snsIdType :: SnsIdType
  , registerWithSnsIdAndIdentityCredential_args_snsAccessToken :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_identityCredential :: IdentityCredential
  , registerWithSnsIdAndIdentityCredential_args_region :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_udidHash :: LT.Text
  , registerWithSnsIdAndIdentityCredential_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdAndIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_snsIdType record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_snsAccessToken record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_identityCredential record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_region record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_udidHash record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_args_deviceInfo record  
instance QC.Arbitrary RegisterWithSnsIdAndIdentityCredential_args where 
  arbitrary = M.liftM RegisterWithSnsIdAndIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdAndIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsIdType = registerWithSnsIdAndIdentityCredential_args_snsIdType obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsIdType = registerWithSnsIdAndIdentityCredential_args_snsIdType obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsAccessToken = registerWithSnsIdAndIdentityCredential_args_snsAccessToken obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_snsAccessToken = registerWithSnsIdAndIdentityCredential_args_snsAccessToken obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_identityCredential = registerWithSnsIdAndIdentityCredential_args_identityCredential obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_identityCredential = registerWithSnsIdAndIdentityCredential_args_identityCredential obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_region = registerWithSnsIdAndIdentityCredential_args_region obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_region = registerWithSnsIdAndIdentityCredential_args_region obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_udidHash = registerWithSnsIdAndIdentityCredential_args_udidHash obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_udidHash = registerWithSnsIdAndIdentityCredential_args_udidHash obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_deviceInfo = registerWithSnsIdAndIdentityCredential_args_deviceInfo obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_args{registerWithSnsIdAndIdentityCredential_args_deviceInfo = registerWithSnsIdAndIdentityCredential_args_deviceInfo obj}
    ]
from_RegisterWithSnsIdAndIdentityCredential_args :: RegisterWithSnsIdAndIdentityCredential_args -> T.ThriftVal
from_RegisterWithSnsIdAndIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8224 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v8224))) $ registerWithSnsIdAndIdentityCredential_args_snsIdType record
  , (\_v8224 -> P.Just (3, ("snsAccessToken",T.TString $ E.encodeUtf8 _v8224))) $ registerWithSnsIdAndIdentityCredential_args_snsAccessToken record
  , (\_v8224 -> P.Just (4, ("identityCredential",from_IdentityCredential _v8224))) $ registerWithSnsIdAndIdentityCredential_args_identityCredential record
  , (\_v8224 -> P.Just (5, ("region",T.TString $ E.encodeUtf8 _v8224))) $ registerWithSnsIdAndIdentityCredential_args_region record
  , (\_v8224 -> P.Just (6, ("udidHash",T.TString $ E.encodeUtf8 _v8224))) $ registerWithSnsIdAndIdentityCredential_args_udidHash record
  , (\_v8224 -> P.Just (7, ("deviceInfo",from_DeviceInfo _v8224))) $ registerWithSnsIdAndIdentityCredential_args_deviceInfo record
  ]
write_RegisterWithSnsIdAndIdentityCredential_args :: T.Protocol p => p -> RegisterWithSnsIdAndIdentityCredential_args -> P.IO ()
write_RegisterWithSnsIdAndIdentityCredential_args oprot record = T.writeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_args record
encode_RegisterWithSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> RegisterWithSnsIdAndIdentityCredential_args -> LBS.ByteString
encode_RegisterWithSnsIdAndIdentityCredential_args oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_args record
to_RegisterWithSnsIdAndIdentityCredential_args :: T.ThriftVal -> RegisterWithSnsIdAndIdentityCredential_args
to_RegisterWithSnsIdAndIdentityCredential_args (T.TStruct fields) = RegisterWithSnsIdAndIdentityCredential_args{
  registerWithSnsIdAndIdentityCredential_args_snsIdType = P.maybe (registerWithSnsIdAndIdentityCredential_args_snsIdType default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TI32 _val8227 -> P.toEnum $ P.fromIntegral _val8227; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerWithSnsIdAndIdentityCredential_args_snsAccessToken = P.maybe (registerWithSnsIdAndIdentityCredential_args_snsAccessToken default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TString _val8228 -> E.decodeUtf8 _val8228; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  registerWithSnsIdAndIdentityCredential_args_identityCredential = P.maybe (registerWithSnsIdAndIdentityCredential_args_identityCredential default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TStruct _val8229 -> (to_IdentityCredential (T.TStruct _val8229)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  registerWithSnsIdAndIdentityCredential_args_region = P.maybe (registerWithSnsIdAndIdentityCredential_args_region default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TString _val8230 -> E.decodeUtf8 _val8230; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  registerWithSnsIdAndIdentityCredential_args_udidHash = P.maybe (registerWithSnsIdAndIdentityCredential_args_udidHash default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TString _val8231 -> E.decodeUtf8 _val8231; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  registerWithSnsIdAndIdentityCredential_args_deviceInfo = P.maybe (registerWithSnsIdAndIdentityCredential_args_deviceInfo default_RegisterWithSnsIdAndIdentityCredential_args) (\(_,_val8226) -> (case _val8226 of {T.TStruct _val8232 -> (to_DeviceInfo (T.TStruct _val8232)); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_RegisterWithSnsIdAndIdentityCredential_args _ = P.error "not a struct"
read_RegisterWithSnsIdAndIdentityCredential_args :: T.Protocol p => p -> P.IO RegisterWithSnsIdAndIdentityCredential_args
read_RegisterWithSnsIdAndIdentityCredential_args iprot = to_RegisterWithSnsIdAndIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_args)
decode_RegisterWithSnsIdAndIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdAndIdentityCredential_args
decode_RegisterWithSnsIdAndIdentityCredential_args iprot bs = to_RegisterWithSnsIdAndIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_args) bs
typemap_RegisterWithSnsIdAndIdentityCredential_args :: T.TypeMap
typemap_RegisterWithSnsIdAndIdentityCredential_args = Map.fromList [(2,("snsIdType",T.T_I32)),(3,("snsAccessToken",T.T_STRING)),(4,("identityCredential",(T.T_STRUCT typemap_IdentityCredential))),(5,("region",T.T_STRING)),(6,("udidHash",T.T_STRING)),(7,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_RegisterWithSnsIdAndIdentityCredential_args :: RegisterWithSnsIdAndIdentityCredential_args
default_RegisterWithSnsIdAndIdentityCredential_args = RegisterWithSnsIdAndIdentityCredential_args{
  registerWithSnsIdAndIdentityCredential_args_snsIdType = (P.toEnum 0),
  registerWithSnsIdAndIdentityCredential_args_snsAccessToken = "",
  registerWithSnsIdAndIdentityCredential_args_identityCredential = default_IdentityCredential,
  registerWithSnsIdAndIdentityCredential_args_region = "",
  registerWithSnsIdAndIdentityCredential_args_udidHash = "",
  registerWithSnsIdAndIdentityCredential_args_deviceInfo = default_DeviceInfo}
data RegisterWithSnsIdAndIdentityCredential_result = RegisterWithSnsIdAndIdentityCredential_result  { registerWithSnsIdAndIdentityCredential_result_success :: LT.Text
  , registerWithSnsIdAndIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterWithSnsIdAndIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_result_success record   `H.hashWithSalt` registerWithSnsIdAndIdentityCredential_result_e record  
instance QC.Arbitrary RegisterWithSnsIdAndIdentityCredential_result where 
  arbitrary = M.liftM RegisterWithSnsIdAndIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterWithSnsIdAndIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = registerWithSnsIdAndIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = registerWithSnsIdAndIdentityCredential_result_success obj}
    , if obj == default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = registerWithSnsIdAndIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = registerWithSnsIdAndIdentityCredential_result_e obj}
    ]
from_RegisterWithSnsIdAndIdentityCredential_result :: RegisterWithSnsIdAndIdentityCredential_result -> T.ThriftVal
from_RegisterWithSnsIdAndIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8235 -> (1, ("e",from_TalkException _v8235))) <$> registerWithSnsIdAndIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8235 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8235))) $ registerWithSnsIdAndIdentityCredential_result_success record
    , (\_v8235 -> (1, ("e",from_TalkException _v8235))) <$> registerWithSnsIdAndIdentityCredential_result_e record
    ]
    )
write_RegisterWithSnsIdAndIdentityCredential_result :: T.Protocol p => p -> RegisterWithSnsIdAndIdentityCredential_result -> P.IO ()
write_RegisterWithSnsIdAndIdentityCredential_result oprot record = T.writeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_result record
encode_RegisterWithSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> RegisterWithSnsIdAndIdentityCredential_result -> LBS.ByteString
encode_RegisterWithSnsIdAndIdentityCredential_result oprot record = T.serializeVal oprot $ from_RegisterWithSnsIdAndIdentityCredential_result record
to_RegisterWithSnsIdAndIdentityCredential_result :: T.ThriftVal -> RegisterWithSnsIdAndIdentityCredential_result
to_RegisterWithSnsIdAndIdentityCredential_result (T.TStruct fields) = RegisterWithSnsIdAndIdentityCredential_result{
  registerWithSnsIdAndIdentityCredential_result_success = P.maybe (registerWithSnsIdAndIdentityCredential_result_success default_RegisterWithSnsIdAndIdentityCredential_result) (\(_,_val8237) -> (case _val8237 of {T.TString _val8238 -> E.decodeUtf8 _val8238; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerWithSnsIdAndIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val8237) -> P.Just (case _val8237 of {T.TStruct _val8239 -> (to_TalkException (T.TStruct _val8239)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterWithSnsIdAndIdentityCredential_result _ = P.error "not a struct"
read_RegisterWithSnsIdAndIdentityCredential_result :: T.Protocol p => p -> P.IO RegisterWithSnsIdAndIdentityCredential_result
read_RegisterWithSnsIdAndIdentityCredential_result iprot = to_RegisterWithSnsIdAndIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_result)
decode_RegisterWithSnsIdAndIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterWithSnsIdAndIdentityCredential_result
decode_RegisterWithSnsIdAndIdentityCredential_result iprot bs = to_RegisterWithSnsIdAndIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterWithSnsIdAndIdentityCredential_result) bs
typemap_RegisterWithSnsIdAndIdentityCredential_result :: T.TypeMap
typemap_RegisterWithSnsIdAndIdentityCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterWithSnsIdAndIdentityCredential_result :: RegisterWithSnsIdAndIdentityCredential_result
default_RegisterWithSnsIdAndIdentityCredential_result = RegisterWithSnsIdAndIdentityCredential_result{
  registerWithSnsIdAndIdentityCredential_result_success = "",
  registerWithSnsIdAndIdentityCredential_result_e = P.Nothing}
data ReissueDeviceCredential_args = ReissueDeviceCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueDeviceCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReissueDeviceCredential_args where 
  arbitrary = QC.elements [ReissueDeviceCredential_args]
from_ReissueDeviceCredential_args :: ReissueDeviceCredential_args -> T.ThriftVal
from_ReissueDeviceCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReissueDeviceCredential_args :: T.Protocol p => p -> ReissueDeviceCredential_args -> P.IO ()
write_ReissueDeviceCredential_args oprot record = T.writeVal oprot $ from_ReissueDeviceCredential_args record
encode_ReissueDeviceCredential_args :: T.StatelessProtocol p => p -> ReissueDeviceCredential_args -> LBS.ByteString
encode_ReissueDeviceCredential_args oprot record = T.serializeVal oprot $ from_ReissueDeviceCredential_args record
to_ReissueDeviceCredential_args :: T.ThriftVal -> ReissueDeviceCredential_args
to_ReissueDeviceCredential_args (T.TStruct fields) = ReissueDeviceCredential_args{

  }
to_ReissueDeviceCredential_args _ = P.error "not a struct"
read_ReissueDeviceCredential_args :: T.Protocol p => p -> P.IO ReissueDeviceCredential_args
read_ReissueDeviceCredential_args iprot = to_ReissueDeviceCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_args)
decode_ReissueDeviceCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueDeviceCredential_args
decode_ReissueDeviceCredential_args iprot bs = to_ReissueDeviceCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_args) bs
typemap_ReissueDeviceCredential_args :: T.TypeMap
typemap_ReissueDeviceCredential_args = Map.fromList []
default_ReissueDeviceCredential_args :: ReissueDeviceCredential_args
default_ReissueDeviceCredential_args = ReissueDeviceCredential_args{
}
data ReissueDeviceCredential_result = ReissueDeviceCredential_result  { reissueDeviceCredential_result_success :: LT.Text
  , reissueDeviceCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueDeviceCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueDeviceCredential_result_success record   `H.hashWithSalt` reissueDeviceCredential_result_e record  
instance QC.Arbitrary ReissueDeviceCredential_result where 
  arbitrary = M.liftM ReissueDeviceCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReissueDeviceCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = reissueDeviceCredential_result_success obj} then P.Nothing else P.Just $ default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = reissueDeviceCredential_result_success obj}
    , if obj == default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = reissueDeviceCredential_result_e obj} then P.Nothing else P.Just $ default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = reissueDeviceCredential_result_e obj}
    ]
from_ReissueDeviceCredential_result :: ReissueDeviceCredential_result -> T.ThriftVal
from_ReissueDeviceCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8247 -> (1, ("e",from_TalkException _v8247))) <$> reissueDeviceCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8247 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8247))) $ reissueDeviceCredential_result_success record
    , (\_v8247 -> (1, ("e",from_TalkException _v8247))) <$> reissueDeviceCredential_result_e record
    ]
    )
write_ReissueDeviceCredential_result :: T.Protocol p => p -> ReissueDeviceCredential_result -> P.IO ()
write_ReissueDeviceCredential_result oprot record = T.writeVal oprot $ from_ReissueDeviceCredential_result record
encode_ReissueDeviceCredential_result :: T.StatelessProtocol p => p -> ReissueDeviceCredential_result -> LBS.ByteString
encode_ReissueDeviceCredential_result oprot record = T.serializeVal oprot $ from_ReissueDeviceCredential_result record
to_ReissueDeviceCredential_result :: T.ThriftVal -> ReissueDeviceCredential_result
to_ReissueDeviceCredential_result (T.TStruct fields) = ReissueDeviceCredential_result{
  reissueDeviceCredential_result_success = P.maybe (reissueDeviceCredential_result_success default_ReissueDeviceCredential_result) (\(_,_val8249) -> (case _val8249 of {T.TString _val8250 -> E.decodeUtf8 _val8250; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reissueDeviceCredential_result_e = P.maybe (P.Nothing) (\(_,_val8249) -> P.Just (case _val8249 of {T.TStruct _val8251 -> (to_TalkException (T.TStruct _val8251)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueDeviceCredential_result _ = P.error "not a struct"
read_ReissueDeviceCredential_result :: T.Protocol p => p -> P.IO ReissueDeviceCredential_result
read_ReissueDeviceCredential_result iprot = to_ReissueDeviceCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_result)
decode_ReissueDeviceCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueDeviceCredential_result
decode_ReissueDeviceCredential_result iprot bs = to_ReissueDeviceCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueDeviceCredential_result) bs
typemap_ReissueDeviceCredential_result :: T.TypeMap
typemap_ReissueDeviceCredential_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReissueDeviceCredential_result :: ReissueDeviceCredential_result
default_ReissueDeviceCredential_result = ReissueDeviceCredential_result{
  reissueDeviceCredential_result_success = "",
  reissueDeviceCredential_result_e = P.Nothing}
data ReissueUserTicket_args = ReissueUserTicket_args  { reissueUserTicket_args_expirationTime :: I.Int64
  , reissueUserTicket_args_maxUseCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueUserTicket_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueUserTicket_args_expirationTime record   `H.hashWithSalt` reissueUserTicket_args_maxUseCount record  
instance QC.Arbitrary ReissueUserTicket_args where 
  arbitrary = M.liftM ReissueUserTicket_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReissueUserTicket_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueUserTicket_args{reissueUserTicket_args_expirationTime = reissueUserTicket_args_expirationTime obj} then P.Nothing else P.Just $ default_ReissueUserTicket_args{reissueUserTicket_args_expirationTime = reissueUserTicket_args_expirationTime obj}
    , if obj == default_ReissueUserTicket_args{reissueUserTicket_args_maxUseCount = reissueUserTicket_args_maxUseCount obj} then P.Nothing else P.Just $ default_ReissueUserTicket_args{reissueUserTicket_args_maxUseCount = reissueUserTicket_args_maxUseCount obj}
    ]
from_ReissueUserTicket_args :: ReissueUserTicket_args -> T.ThriftVal
from_ReissueUserTicket_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8254 -> P.Just (3, ("expirationTime",T.TI64 _v8254))) $ reissueUserTicket_args_expirationTime record
  , (\_v8254 -> P.Just (4, ("maxUseCount",T.TI32 _v8254))) $ reissueUserTicket_args_maxUseCount record
  ]
write_ReissueUserTicket_args :: T.Protocol p => p -> ReissueUserTicket_args -> P.IO ()
write_ReissueUserTicket_args oprot record = T.writeVal oprot $ from_ReissueUserTicket_args record
encode_ReissueUserTicket_args :: T.StatelessProtocol p => p -> ReissueUserTicket_args -> LBS.ByteString
encode_ReissueUserTicket_args oprot record = T.serializeVal oprot $ from_ReissueUserTicket_args record
to_ReissueUserTicket_args :: T.ThriftVal -> ReissueUserTicket_args
to_ReissueUserTicket_args (T.TStruct fields) = ReissueUserTicket_args{
  reissueUserTicket_args_expirationTime = P.maybe (reissueUserTicket_args_expirationTime default_ReissueUserTicket_args) (\(_,_val8256) -> (case _val8256 of {T.TI64 _val8257 -> _val8257; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reissueUserTicket_args_maxUseCount = P.maybe (reissueUserTicket_args_maxUseCount default_ReissueUserTicket_args) (\(_,_val8256) -> (case _val8256 of {T.TI32 _val8258 -> _val8258; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ReissueUserTicket_args _ = P.error "not a struct"
read_ReissueUserTicket_args :: T.Protocol p => p -> P.IO ReissueUserTicket_args
read_ReissueUserTicket_args iprot = to_ReissueUserTicket_args <$> T.readVal iprot (T.T_STRUCT typemap_ReissueUserTicket_args)
decode_ReissueUserTicket_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueUserTicket_args
decode_ReissueUserTicket_args iprot bs = to_ReissueUserTicket_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueUserTicket_args) bs
typemap_ReissueUserTicket_args :: T.TypeMap
typemap_ReissueUserTicket_args = Map.fromList [(3,("expirationTime",T.T_I64)),(4,("maxUseCount",T.T_I32))]
default_ReissueUserTicket_args :: ReissueUserTicket_args
default_ReissueUserTicket_args = ReissueUserTicket_args{
  reissueUserTicket_args_expirationTime = 0,
  reissueUserTicket_args_maxUseCount = 0}
data ReissueUserTicket_result = ReissueUserTicket_result  { reissueUserTicket_result_success :: LT.Text
  , reissueUserTicket_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReissueUserTicket_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reissueUserTicket_result_success record   `H.hashWithSalt` reissueUserTicket_result_e record  
instance QC.Arbitrary ReissueUserTicket_result where 
  arbitrary = M.liftM ReissueUserTicket_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReissueUserTicket_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReissueUserTicket_result{reissueUserTicket_result_success = reissueUserTicket_result_success obj} then P.Nothing else P.Just $ default_ReissueUserTicket_result{reissueUserTicket_result_success = reissueUserTicket_result_success obj}
    , if obj == default_ReissueUserTicket_result{reissueUserTicket_result_e = reissueUserTicket_result_e obj} then P.Nothing else P.Just $ default_ReissueUserTicket_result{reissueUserTicket_result_e = reissueUserTicket_result_e obj}
    ]
from_ReissueUserTicket_result :: ReissueUserTicket_result -> T.ThriftVal
from_ReissueUserTicket_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8261 -> (1, ("e",from_TalkException _v8261))) <$> reissueUserTicket_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8261 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8261))) $ reissueUserTicket_result_success record
    , (\_v8261 -> (1, ("e",from_TalkException _v8261))) <$> reissueUserTicket_result_e record
    ]
    )
write_ReissueUserTicket_result :: T.Protocol p => p -> ReissueUserTicket_result -> P.IO ()
write_ReissueUserTicket_result oprot record = T.writeVal oprot $ from_ReissueUserTicket_result record
encode_ReissueUserTicket_result :: T.StatelessProtocol p => p -> ReissueUserTicket_result -> LBS.ByteString
encode_ReissueUserTicket_result oprot record = T.serializeVal oprot $ from_ReissueUserTicket_result record
to_ReissueUserTicket_result :: T.ThriftVal -> ReissueUserTicket_result
to_ReissueUserTicket_result (T.TStruct fields) = ReissueUserTicket_result{
  reissueUserTicket_result_success = P.maybe (reissueUserTicket_result_success default_ReissueUserTicket_result) (\(_,_val8263) -> (case _val8263 of {T.TString _val8264 -> E.decodeUtf8 _val8264; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reissueUserTicket_result_e = P.maybe (P.Nothing) (\(_,_val8263) -> P.Just (case _val8263 of {T.TStruct _val8265 -> (to_TalkException (T.TStruct _val8265)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReissueUserTicket_result _ = P.error "not a struct"
read_ReissueUserTicket_result :: T.Protocol p => p -> P.IO ReissueUserTicket_result
read_ReissueUserTicket_result iprot = to_ReissueUserTicket_result <$> T.readVal iprot (T.T_STRUCT typemap_ReissueUserTicket_result)
decode_ReissueUserTicket_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReissueUserTicket_result
decode_ReissueUserTicket_result iprot bs = to_ReissueUserTicket_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReissueUserTicket_result) bs
typemap_ReissueUserTicket_result :: T.TypeMap
typemap_ReissueUserTicket_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReissueUserTicket_result :: ReissueUserTicket_result
default_ReissueUserTicket_result = ReissueUserTicket_result{
  reissueUserTicket_result_success = "",
  reissueUserTicket_result_e = P.Nothing}
data GetMessageReadRange_args = GetMessageReadRange_args  { getMessageReadRange_args_chatIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageReadRange_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageReadRange_args_chatIds record  
instance QC.Arbitrary GetMessageReadRange_args where 
  arbitrary = M.liftM GetMessageReadRange_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageReadRange_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageReadRange_args{getMessageReadRange_args_chatIds = getMessageReadRange_args_chatIds obj} then P.Nothing else P.Just $ default_GetMessageReadRange_args{getMessageReadRange_args_chatIds = getMessageReadRange_args_chatIds obj}
    ]
from_GetMessageReadRange_args :: GetMessageReadRange_args -> T.ThriftVal
from_GetMessageReadRange_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8268 -> P.Just (2, ("chatIds",T.TList T.T_STRING $ P.map (\_v8270 -> T.TString $ E.encodeUtf8 _v8270) $ Vector.toList _v8268))) $ getMessageReadRange_args_chatIds record
  ]
write_GetMessageReadRange_args :: T.Protocol p => p -> GetMessageReadRange_args -> P.IO ()
write_GetMessageReadRange_args oprot record = T.writeVal oprot $ from_GetMessageReadRange_args record
encode_GetMessageReadRange_args :: T.StatelessProtocol p => p -> GetMessageReadRange_args -> LBS.ByteString
encode_GetMessageReadRange_args oprot record = T.serializeVal oprot $ from_GetMessageReadRange_args record
to_GetMessageReadRange_args :: T.ThriftVal -> GetMessageReadRange_args
to_GetMessageReadRange_args (T.TStruct fields) = GetMessageReadRange_args{
  getMessageReadRange_args_chatIds = P.maybe (getMessageReadRange_args_chatIds default_GetMessageReadRange_args) (\(_,_val8272) -> (case _val8272 of {T.TList _ _val8273 -> (Vector.fromList $ P.map (\_v8274 -> (case _v8274 of {T.TString _val8275 -> E.decodeUtf8 _val8275; _ -> P.error "wrong type"})) _val8273); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageReadRange_args _ = P.error "not a struct"
read_GetMessageReadRange_args :: T.Protocol p => p -> P.IO GetMessageReadRange_args
read_GetMessageReadRange_args iprot = to_GetMessageReadRange_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageReadRange_args)
decode_GetMessageReadRange_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageReadRange_args
decode_GetMessageReadRange_args iprot bs = to_GetMessageReadRange_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageReadRange_args) bs
typemap_GetMessageReadRange_args :: T.TypeMap
typemap_GetMessageReadRange_args = Map.fromList [(2,("chatIds",(T.T_LIST T.T_STRING)))]
default_GetMessageReadRange_args :: GetMessageReadRange_args
default_GetMessageReadRange_args = GetMessageReadRange_args{
  getMessageReadRange_args_chatIds = Vector.empty}
data GetMessageReadRange_result = GetMessageReadRange_result  { getMessageReadRange_result_success :: (Vector.Vector TMessageReadRange)
  , getMessageReadRange_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageReadRange_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageReadRange_result_success record   `H.hashWithSalt` getMessageReadRange_result_e record  
instance QC.Arbitrary GetMessageReadRange_result where 
  arbitrary = M.liftM GetMessageReadRange_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageReadRange_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageReadRange_result{getMessageReadRange_result_success = getMessageReadRange_result_success obj} then P.Nothing else P.Just $ default_GetMessageReadRange_result{getMessageReadRange_result_success = getMessageReadRange_result_success obj}
    , if obj == default_GetMessageReadRange_result{getMessageReadRange_result_e = getMessageReadRange_result_e obj} then P.Nothing else P.Just $ default_GetMessageReadRange_result{getMessageReadRange_result_e = getMessageReadRange_result_e obj}
    ]
from_GetMessageReadRange_result :: GetMessageReadRange_result -> T.ThriftVal
from_GetMessageReadRange_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8278 -> (1, ("e",from_TalkException _v8278))) <$> getMessageReadRange_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8278 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_TMessageReadRange) $ P.map (\_v8280 -> from_TMessageReadRange _v8280) $ Vector.toList _v8278))) $ getMessageReadRange_result_success record
    , (\_v8278 -> (1, ("e",from_TalkException _v8278))) <$> getMessageReadRange_result_e record
    ]
    )
write_GetMessageReadRange_result :: T.Protocol p => p -> GetMessageReadRange_result -> P.IO ()
write_GetMessageReadRange_result oprot record = T.writeVal oprot $ from_GetMessageReadRange_result record
encode_GetMessageReadRange_result :: T.StatelessProtocol p => p -> GetMessageReadRange_result -> LBS.ByteString
encode_GetMessageReadRange_result oprot record = T.serializeVal oprot $ from_GetMessageReadRange_result record
to_GetMessageReadRange_result :: T.ThriftVal -> GetMessageReadRange_result
to_GetMessageReadRange_result (T.TStruct fields) = GetMessageReadRange_result{
  getMessageReadRange_result_success = P.maybe (getMessageReadRange_result_success default_GetMessageReadRange_result) (\(_,_val8282) -> (case _val8282 of {T.TList _ _val8283 -> (Vector.fromList $ P.map (\_v8284 -> (case _v8284 of {T.TStruct _val8285 -> (to_TMessageReadRange (T.TStruct _val8285)); _ -> P.error "wrong type"})) _val8283); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageReadRange_result_e = P.maybe (P.Nothing) (\(_,_val8282) -> P.Just (case _val8282 of {T.TStruct _val8286 -> (to_TalkException (T.TStruct _val8286)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageReadRange_result _ = P.error "not a struct"
read_GetMessageReadRange_result :: T.Protocol p => p -> P.IO GetMessageReadRange_result
read_GetMessageReadRange_result iprot = to_GetMessageReadRange_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageReadRange_result)
decode_GetMessageReadRange_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageReadRange_result
decode_GetMessageReadRange_result iprot bs = to_GetMessageReadRange_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageReadRange_result) bs
typemap_GetMessageReadRange_result :: T.TypeMap
typemap_GetMessageReadRange_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_TMessageReadRange)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageReadRange_result :: GetMessageReadRange_result
default_GetMessageReadRange_result = GetMessageReadRange_result{
  getMessageReadRange_result_success = Vector.empty,
  getMessageReadRange_result_e = P.Nothing}
data RejectGroupInvitation_args = RejectGroupInvitation_args  { rejectGroupInvitation_args_reqSeq :: I.Int32
  , rejectGroupInvitation_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectGroupInvitation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectGroupInvitation_args_reqSeq record   `H.hashWithSalt` rejectGroupInvitation_args_groupId record  
instance QC.Arbitrary RejectGroupInvitation_args where 
  arbitrary = M.liftM RejectGroupInvitation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RejectGroupInvitation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectGroupInvitation_args{rejectGroupInvitation_args_reqSeq = rejectGroupInvitation_args_reqSeq obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_args{rejectGroupInvitation_args_reqSeq = rejectGroupInvitation_args_reqSeq obj}
    , if obj == default_RejectGroupInvitation_args{rejectGroupInvitation_args_groupId = rejectGroupInvitation_args_groupId obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_args{rejectGroupInvitation_args_groupId = rejectGroupInvitation_args_groupId obj}
    ]
from_RejectGroupInvitation_args :: RejectGroupInvitation_args -> T.ThriftVal
from_RejectGroupInvitation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8289 -> P.Just (1, ("reqSeq",T.TI32 _v8289))) $ rejectGroupInvitation_args_reqSeq record
  , (\_v8289 -> P.Just (2, ("groupId",T.TString $ E.encodeUtf8 _v8289))) $ rejectGroupInvitation_args_groupId record
  ]
write_RejectGroupInvitation_args :: T.Protocol p => p -> RejectGroupInvitation_args -> P.IO ()
write_RejectGroupInvitation_args oprot record = T.writeVal oprot $ from_RejectGroupInvitation_args record
encode_RejectGroupInvitation_args :: T.StatelessProtocol p => p -> RejectGroupInvitation_args -> LBS.ByteString
encode_RejectGroupInvitation_args oprot record = T.serializeVal oprot $ from_RejectGroupInvitation_args record
to_RejectGroupInvitation_args :: T.ThriftVal -> RejectGroupInvitation_args
to_RejectGroupInvitation_args (T.TStruct fields) = RejectGroupInvitation_args{
  rejectGroupInvitation_args_reqSeq = P.maybe (rejectGroupInvitation_args_reqSeq default_RejectGroupInvitation_args) (\(_,_val8291) -> (case _val8291 of {T.TI32 _val8292 -> _val8292; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  rejectGroupInvitation_args_groupId = P.maybe (rejectGroupInvitation_args_groupId default_RejectGroupInvitation_args) (\(_,_val8291) -> (case _val8291 of {T.TString _val8293 -> E.decodeUtf8 _val8293; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RejectGroupInvitation_args _ = P.error "not a struct"
read_RejectGroupInvitation_args :: T.Protocol p => p -> P.IO RejectGroupInvitation_args
read_RejectGroupInvitation_args iprot = to_RejectGroupInvitation_args <$> T.readVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_args)
decode_RejectGroupInvitation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectGroupInvitation_args
decode_RejectGroupInvitation_args iprot bs = to_RejectGroupInvitation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_args) bs
typemap_RejectGroupInvitation_args :: T.TypeMap
typemap_RejectGroupInvitation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupId",T.T_STRING))]
default_RejectGroupInvitation_args :: RejectGroupInvitation_args
default_RejectGroupInvitation_args = RejectGroupInvitation_args{
  rejectGroupInvitation_args_reqSeq = 0,
  rejectGroupInvitation_args_groupId = ""}
data RejectGroupInvitation_result = RejectGroupInvitation_result  { rejectGroupInvitation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RejectGroupInvitation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` rejectGroupInvitation_result_e record  
instance QC.Arbitrary RejectGroupInvitation_result where 
  arbitrary = M.liftM RejectGroupInvitation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RejectGroupInvitation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = rejectGroupInvitation_result_e obj} then P.Nothing else P.Just $ default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = rejectGroupInvitation_result_e obj}
    ]
from_RejectGroupInvitation_result :: RejectGroupInvitation_result -> T.ThriftVal
from_RejectGroupInvitation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8296 -> (1, ("e",from_TalkException _v8296))) <$> rejectGroupInvitation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8296 -> (1, ("e",from_TalkException _v8296))) <$> rejectGroupInvitation_result_e record
    ]
    )
write_RejectGroupInvitation_result :: T.Protocol p => p -> RejectGroupInvitation_result -> P.IO ()
write_RejectGroupInvitation_result oprot record = T.writeVal oprot $ from_RejectGroupInvitation_result record
encode_RejectGroupInvitation_result :: T.StatelessProtocol p => p -> RejectGroupInvitation_result -> LBS.ByteString
encode_RejectGroupInvitation_result oprot record = T.serializeVal oprot $ from_RejectGroupInvitation_result record
to_RejectGroupInvitation_result :: T.ThriftVal -> RejectGroupInvitation_result
to_RejectGroupInvitation_result (T.TStruct fields) = RejectGroupInvitation_result{
  rejectGroupInvitation_result_e = P.maybe (P.Nothing) (\(_,_val8298) -> P.Just (case _val8298 of {T.TStruct _val8299 -> (to_TalkException (T.TStruct _val8299)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RejectGroupInvitation_result _ = P.error "not a struct"
read_RejectGroupInvitation_result :: T.Protocol p => p -> P.IO RejectGroupInvitation_result
read_RejectGroupInvitation_result iprot = to_RejectGroupInvitation_result <$> T.readVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_result)
decode_RejectGroupInvitation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RejectGroupInvitation_result
decode_RejectGroupInvitation_result iprot bs = to_RejectGroupInvitation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RejectGroupInvitation_result) bs
typemap_RejectGroupInvitation_result :: T.TypeMap
typemap_RejectGroupInvitation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RejectGroupInvitation_result :: RejectGroupInvitation_result
default_RejectGroupInvitation_result = RejectGroupInvitation_result{
  rejectGroupInvitation_result_e = P.Nothing}
data ReleaseSession_args = ReleaseSession_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReleaseSession_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ReleaseSession_args where 
  arbitrary = QC.elements [ReleaseSession_args]
from_ReleaseSession_args :: ReleaseSession_args -> T.ThriftVal
from_ReleaseSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ReleaseSession_args :: T.Protocol p => p -> ReleaseSession_args -> P.IO ()
write_ReleaseSession_args oprot record = T.writeVal oprot $ from_ReleaseSession_args record
encode_ReleaseSession_args :: T.StatelessProtocol p => p -> ReleaseSession_args -> LBS.ByteString
encode_ReleaseSession_args oprot record = T.serializeVal oprot $ from_ReleaseSession_args record
to_ReleaseSession_args :: T.ThriftVal -> ReleaseSession_args
to_ReleaseSession_args (T.TStruct fields) = ReleaseSession_args{

  }
to_ReleaseSession_args _ = P.error "not a struct"
read_ReleaseSession_args :: T.Protocol p => p -> P.IO ReleaseSession_args
read_ReleaseSession_args iprot = to_ReleaseSession_args <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseSession_args)
decode_ReleaseSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReleaseSession_args
decode_ReleaseSession_args iprot bs = to_ReleaseSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseSession_args) bs
typemap_ReleaseSession_args :: T.TypeMap
typemap_ReleaseSession_args = Map.fromList []
default_ReleaseSession_args :: ReleaseSession_args
default_ReleaseSession_args = ReleaseSession_args{
}
data ReleaseSession_result = ReleaseSession_result  { releaseSession_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReleaseSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` releaseSession_result_e record  
instance QC.Arbitrary ReleaseSession_result where 
  arbitrary = M.liftM ReleaseSession_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReleaseSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReleaseSession_result{releaseSession_result_e = releaseSession_result_e obj} then P.Nothing else P.Just $ default_ReleaseSession_result{releaseSession_result_e = releaseSession_result_e obj}
    ]
from_ReleaseSession_result :: ReleaseSession_result -> T.ThriftVal
from_ReleaseSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8307 -> (1, ("e",from_TalkException _v8307))) <$> releaseSession_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8307 -> (1, ("e",from_TalkException _v8307))) <$> releaseSession_result_e record
    ]
    )
write_ReleaseSession_result :: T.Protocol p => p -> ReleaseSession_result -> P.IO ()
write_ReleaseSession_result oprot record = T.writeVal oprot $ from_ReleaseSession_result record
encode_ReleaseSession_result :: T.StatelessProtocol p => p -> ReleaseSession_result -> LBS.ByteString
encode_ReleaseSession_result oprot record = T.serializeVal oprot $ from_ReleaseSession_result record
to_ReleaseSession_result :: T.ThriftVal -> ReleaseSession_result
to_ReleaseSession_result (T.TStruct fields) = ReleaseSession_result{
  releaseSession_result_e = P.maybe (P.Nothing) (\(_,_val8309) -> P.Just (case _val8309 of {T.TStruct _val8310 -> (to_TalkException (T.TStruct _val8310)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReleaseSession_result _ = P.error "not a struct"
read_ReleaseSession_result :: T.Protocol p => p -> P.IO ReleaseSession_result
read_ReleaseSession_result iprot = to_ReleaseSession_result <$> T.readVal iprot (T.T_STRUCT typemap_ReleaseSession_result)
decode_ReleaseSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReleaseSession_result
decode_ReleaseSession_result iprot bs = to_ReleaseSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReleaseSession_result) bs
typemap_ReleaseSession_result :: T.TypeMap
typemap_ReleaseSession_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReleaseSession_result :: ReleaseSession_result
default_ReleaseSession_result = ReleaseSession_result{
  releaseSession_result_e = P.Nothing}
data RemoveAllMessages_args = RemoveAllMessages_args  { removeAllMessages_args_seq :: I.Int32
  , removeAllMessages_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveAllMessages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeAllMessages_args_seq record   `H.hashWithSalt` removeAllMessages_args_lastMessageId record  
instance QC.Arbitrary RemoveAllMessages_args where 
  arbitrary = M.liftM RemoveAllMessages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveAllMessages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveAllMessages_args{removeAllMessages_args_seq = removeAllMessages_args_seq obj} then P.Nothing else P.Just $ default_RemoveAllMessages_args{removeAllMessages_args_seq = removeAllMessages_args_seq obj}
    , if obj == default_RemoveAllMessages_args{removeAllMessages_args_lastMessageId = removeAllMessages_args_lastMessageId obj} then P.Nothing else P.Just $ default_RemoveAllMessages_args{removeAllMessages_args_lastMessageId = removeAllMessages_args_lastMessageId obj}
    ]
from_RemoveAllMessages_args :: RemoveAllMessages_args -> T.ThriftVal
from_RemoveAllMessages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8313 -> P.Just (1, ("seq",T.TI32 _v8313))) $ removeAllMessages_args_seq record
  , (\_v8313 -> P.Just (2, ("lastMessageId",T.TString $ E.encodeUtf8 _v8313))) $ removeAllMessages_args_lastMessageId record
  ]
write_RemoveAllMessages_args :: T.Protocol p => p -> RemoveAllMessages_args -> P.IO ()
write_RemoveAllMessages_args oprot record = T.writeVal oprot $ from_RemoveAllMessages_args record
encode_RemoveAllMessages_args :: T.StatelessProtocol p => p -> RemoveAllMessages_args -> LBS.ByteString
encode_RemoveAllMessages_args oprot record = T.serializeVal oprot $ from_RemoveAllMessages_args record
to_RemoveAllMessages_args :: T.ThriftVal -> RemoveAllMessages_args
to_RemoveAllMessages_args (T.TStruct fields) = RemoveAllMessages_args{
  removeAllMessages_args_seq = P.maybe (removeAllMessages_args_seq default_RemoveAllMessages_args) (\(_,_val8315) -> (case _val8315 of {T.TI32 _val8316 -> _val8316; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeAllMessages_args_lastMessageId = P.maybe (removeAllMessages_args_lastMessageId default_RemoveAllMessages_args) (\(_,_val8315) -> (case _val8315 of {T.TString _val8317 -> E.decodeUtf8 _val8317; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveAllMessages_args _ = P.error "not a struct"
read_RemoveAllMessages_args :: T.Protocol p => p -> P.IO RemoveAllMessages_args
read_RemoveAllMessages_args iprot = to_RemoveAllMessages_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveAllMessages_args)
decode_RemoveAllMessages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveAllMessages_args
decode_RemoveAllMessages_args iprot bs = to_RemoveAllMessages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveAllMessages_args) bs
typemap_RemoveAllMessages_args :: T.TypeMap
typemap_RemoveAllMessages_args = Map.fromList [(1,("seq",T.T_I32)),(2,("lastMessageId",T.T_STRING))]
default_RemoveAllMessages_args :: RemoveAllMessages_args
default_RemoveAllMessages_args = RemoveAllMessages_args{
  removeAllMessages_args_seq = 0,
  removeAllMessages_args_lastMessageId = ""}
data RemoveAllMessages_result = RemoveAllMessages_result  { removeAllMessages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveAllMessages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeAllMessages_result_e record  
instance QC.Arbitrary RemoveAllMessages_result where 
  arbitrary = M.liftM RemoveAllMessages_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveAllMessages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveAllMessages_result{removeAllMessages_result_e = removeAllMessages_result_e obj} then P.Nothing else P.Just $ default_RemoveAllMessages_result{removeAllMessages_result_e = removeAllMessages_result_e obj}
    ]
from_RemoveAllMessages_result :: RemoveAllMessages_result -> T.ThriftVal
from_RemoveAllMessages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8320 -> (1, ("e",from_TalkException _v8320))) <$> removeAllMessages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8320 -> (1, ("e",from_TalkException _v8320))) <$> removeAllMessages_result_e record
    ]
    )
write_RemoveAllMessages_result :: T.Protocol p => p -> RemoveAllMessages_result -> P.IO ()
write_RemoveAllMessages_result oprot record = T.writeVal oprot $ from_RemoveAllMessages_result record
encode_RemoveAllMessages_result :: T.StatelessProtocol p => p -> RemoveAllMessages_result -> LBS.ByteString
encode_RemoveAllMessages_result oprot record = T.serializeVal oprot $ from_RemoveAllMessages_result record
to_RemoveAllMessages_result :: T.ThriftVal -> RemoveAllMessages_result
to_RemoveAllMessages_result (T.TStruct fields) = RemoveAllMessages_result{
  removeAllMessages_result_e = P.maybe (P.Nothing) (\(_,_val8322) -> P.Just (case _val8322 of {T.TStruct _val8323 -> (to_TalkException (T.TStruct _val8323)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveAllMessages_result _ = P.error "not a struct"
read_RemoveAllMessages_result :: T.Protocol p => p -> P.IO RemoveAllMessages_result
read_RemoveAllMessages_result iprot = to_RemoveAllMessages_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveAllMessages_result)
decode_RemoveAllMessages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveAllMessages_result
decode_RemoveAllMessages_result iprot bs = to_RemoveAllMessages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveAllMessages_result) bs
typemap_RemoveAllMessages_result :: T.TypeMap
typemap_RemoveAllMessages_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveAllMessages_result :: RemoveAllMessages_result
default_RemoveAllMessages_result = RemoveAllMessages_result{
  removeAllMessages_result_e = P.Nothing}
data RemoveBuddyLocation_args = RemoveBuddyLocation_args  { removeBuddyLocation_args_mid :: LT.Text
  , removeBuddyLocation_args_index :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeBuddyLocation_args_mid record   `H.hashWithSalt` removeBuddyLocation_args_index record  
instance QC.Arbitrary RemoveBuddyLocation_args where 
  arbitrary = M.liftM RemoveBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveBuddyLocation_args{removeBuddyLocation_args_mid = removeBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_args{removeBuddyLocation_args_mid = removeBuddyLocation_args_mid obj}
    , if obj == default_RemoveBuddyLocation_args{removeBuddyLocation_args_index = removeBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_args{removeBuddyLocation_args_index = removeBuddyLocation_args_index obj}
    ]
from_RemoveBuddyLocation_args :: RemoveBuddyLocation_args -> T.ThriftVal
from_RemoveBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8326 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v8326))) $ removeBuddyLocation_args_mid record
  , (\_v8326 -> P.Just (3, ("index",T.TI32 _v8326))) $ removeBuddyLocation_args_index record
  ]
write_RemoveBuddyLocation_args :: T.Protocol p => p -> RemoveBuddyLocation_args -> P.IO ()
write_RemoveBuddyLocation_args oprot record = T.writeVal oprot $ from_RemoveBuddyLocation_args record
encode_RemoveBuddyLocation_args :: T.StatelessProtocol p => p -> RemoveBuddyLocation_args -> LBS.ByteString
encode_RemoveBuddyLocation_args oprot record = T.serializeVal oprot $ from_RemoveBuddyLocation_args record
to_RemoveBuddyLocation_args :: T.ThriftVal -> RemoveBuddyLocation_args
to_RemoveBuddyLocation_args (T.TStruct fields) = RemoveBuddyLocation_args{
  removeBuddyLocation_args_mid = P.maybe (removeBuddyLocation_args_mid default_RemoveBuddyLocation_args) (\(_,_val8328) -> (case _val8328 of {T.TString _val8329 -> E.decodeUtf8 _val8329; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  removeBuddyLocation_args_index = P.maybe (removeBuddyLocation_args_index default_RemoveBuddyLocation_args) (\(_,_val8328) -> (case _val8328 of {T.TI32 _val8330 -> _val8330; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RemoveBuddyLocation_args _ = P.error "not a struct"
read_RemoveBuddyLocation_args :: T.Protocol p => p -> P.IO RemoveBuddyLocation_args
read_RemoveBuddyLocation_args iprot = to_RemoveBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_args)
decode_RemoveBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveBuddyLocation_args
decode_RemoveBuddyLocation_args iprot bs = to_RemoveBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_args) bs
typemap_RemoveBuddyLocation_args :: T.TypeMap
typemap_RemoveBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32))]
default_RemoveBuddyLocation_args :: RemoveBuddyLocation_args
default_RemoveBuddyLocation_args = RemoveBuddyLocation_args{
  removeBuddyLocation_args_mid = "",
  removeBuddyLocation_args_index = 0}
data RemoveBuddyLocation_result = RemoveBuddyLocation_result  { removeBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeBuddyLocation_result_e record  
instance QC.Arbitrary RemoveBuddyLocation_result where 
  arbitrary = M.liftM RemoveBuddyLocation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = removeBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = removeBuddyLocation_result_e obj}
    ]
from_RemoveBuddyLocation_result :: RemoveBuddyLocation_result -> T.ThriftVal
from_RemoveBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8333 -> (1, ("e",from_TalkException _v8333))) <$> removeBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8333 -> (1, ("e",from_TalkException _v8333))) <$> removeBuddyLocation_result_e record
    ]
    )
write_RemoveBuddyLocation_result :: T.Protocol p => p -> RemoveBuddyLocation_result -> P.IO ()
write_RemoveBuddyLocation_result oprot record = T.writeVal oprot $ from_RemoveBuddyLocation_result record
encode_RemoveBuddyLocation_result :: T.StatelessProtocol p => p -> RemoveBuddyLocation_result -> LBS.ByteString
encode_RemoveBuddyLocation_result oprot record = T.serializeVal oprot $ from_RemoveBuddyLocation_result record
to_RemoveBuddyLocation_result :: T.ThriftVal -> RemoveBuddyLocation_result
to_RemoveBuddyLocation_result (T.TStruct fields) = RemoveBuddyLocation_result{
  removeBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val8335) -> P.Just (case _val8335 of {T.TStruct _val8336 -> (to_TalkException (T.TStruct _val8336)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveBuddyLocation_result _ = P.error "not a struct"
read_RemoveBuddyLocation_result :: T.Protocol p => p -> P.IO RemoveBuddyLocation_result
read_RemoveBuddyLocation_result iprot = to_RemoveBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_result)
decode_RemoveBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveBuddyLocation_result
decode_RemoveBuddyLocation_result iprot bs = to_RemoveBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveBuddyLocation_result) bs
typemap_RemoveBuddyLocation_result :: T.TypeMap
typemap_RemoveBuddyLocation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveBuddyLocation_result :: RemoveBuddyLocation_result
default_RemoveBuddyLocation_result = RemoveBuddyLocation_result{
  removeBuddyLocation_result_e = P.Nothing}
data RemoveMessage_args = RemoveMessage_args  { removeMessage_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessage_args_messageId record  
instance QC.Arbitrary RemoveMessage_args where 
  arbitrary = M.liftM RemoveMessage_args (QC.arbitrary)
  shrink obj | obj == default_RemoveMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessage_args{removeMessage_args_messageId = removeMessage_args_messageId obj} then P.Nothing else P.Just $ default_RemoveMessage_args{removeMessage_args_messageId = removeMessage_args_messageId obj}
    ]
from_RemoveMessage_args :: RemoveMessage_args -> T.ThriftVal
from_RemoveMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8339 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v8339))) $ removeMessage_args_messageId record
  ]
write_RemoveMessage_args :: T.Protocol p => p -> RemoveMessage_args -> P.IO ()
write_RemoveMessage_args oprot record = T.writeVal oprot $ from_RemoveMessage_args record
encode_RemoveMessage_args :: T.StatelessProtocol p => p -> RemoveMessage_args -> LBS.ByteString
encode_RemoveMessage_args oprot record = T.serializeVal oprot $ from_RemoveMessage_args record
to_RemoveMessage_args :: T.ThriftVal -> RemoveMessage_args
to_RemoveMessage_args (T.TStruct fields) = RemoveMessage_args{
  removeMessage_args_messageId = P.maybe (removeMessage_args_messageId default_RemoveMessage_args) (\(_,_val8341) -> (case _val8341 of {T.TString _val8342 -> E.decodeUtf8 _val8342; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveMessage_args _ = P.error "not a struct"
read_RemoveMessage_args :: T.Protocol p => p -> P.IO RemoveMessage_args
read_RemoveMessage_args iprot = to_RemoveMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessage_args)
decode_RemoveMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessage_args
decode_RemoveMessage_args iprot bs = to_RemoveMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessage_args) bs
typemap_RemoveMessage_args :: T.TypeMap
typemap_RemoveMessage_args = Map.fromList [(2,("messageId",T.T_STRING))]
default_RemoveMessage_args :: RemoveMessage_args
default_RemoveMessage_args = RemoveMessage_args{
  removeMessage_args_messageId = ""}
data RemoveMessage_result = RemoveMessage_result  { removeMessage_result_success :: P.Bool
  , removeMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessage_result_success record   `H.hashWithSalt` removeMessage_result_e record  
instance QC.Arbitrary RemoveMessage_result where 
  arbitrary = M.liftM RemoveMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessage_result{removeMessage_result_success = removeMessage_result_success obj} then P.Nothing else P.Just $ default_RemoveMessage_result{removeMessage_result_success = removeMessage_result_success obj}
    , if obj == default_RemoveMessage_result{removeMessage_result_e = removeMessage_result_e obj} then P.Nothing else P.Just $ default_RemoveMessage_result{removeMessage_result_e = removeMessage_result_e obj}
    ]
from_RemoveMessage_result :: RemoveMessage_result -> T.ThriftVal
from_RemoveMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8345 -> (1, ("e",from_TalkException _v8345))) <$> removeMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8345 -> P.Just (0, ("success",T.TBool _v8345))) $ removeMessage_result_success record
    , (\_v8345 -> (1, ("e",from_TalkException _v8345))) <$> removeMessage_result_e record
    ]
    )
write_RemoveMessage_result :: T.Protocol p => p -> RemoveMessage_result -> P.IO ()
write_RemoveMessage_result oprot record = T.writeVal oprot $ from_RemoveMessage_result record
encode_RemoveMessage_result :: T.StatelessProtocol p => p -> RemoveMessage_result -> LBS.ByteString
encode_RemoveMessage_result oprot record = T.serializeVal oprot $ from_RemoveMessage_result record
to_RemoveMessage_result :: T.ThriftVal -> RemoveMessage_result
to_RemoveMessage_result (T.TStruct fields) = RemoveMessage_result{
  removeMessage_result_success = P.maybe (removeMessage_result_success default_RemoveMessage_result) (\(_,_val8347) -> (case _val8347 of {T.TBool _val8348 -> _val8348; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeMessage_result_e = P.maybe (P.Nothing) (\(_,_val8347) -> P.Just (case _val8347 of {T.TStruct _val8349 -> (to_TalkException (T.TStruct _val8349)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMessage_result _ = P.error "not a struct"
read_RemoveMessage_result :: T.Protocol p => p -> P.IO RemoveMessage_result
read_RemoveMessage_result iprot = to_RemoveMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessage_result)
decode_RemoveMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessage_result
decode_RemoveMessage_result iprot bs = to_RemoveMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessage_result) bs
typemap_RemoveMessage_result :: T.TypeMap
typemap_RemoveMessage_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveMessage_result :: RemoveMessage_result
default_RemoveMessage_result = RemoveMessage_result{
  removeMessage_result_success = P.False,
  removeMessage_result_e = P.Nothing}
data MakeUserAddMyselfAsContact_args = MakeUserAddMyselfAsContact_args  { makeUserAddMyselfAsContact_args_contactOwnerMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MakeUserAddMyselfAsContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` makeUserAddMyselfAsContact_args_contactOwnerMid record  
instance QC.Arbitrary MakeUserAddMyselfAsContact_args where 
  arbitrary = M.liftM MakeUserAddMyselfAsContact_args (QC.arbitrary)
  shrink obj | obj == default_MakeUserAddMyselfAsContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MakeUserAddMyselfAsContact_args{makeUserAddMyselfAsContact_args_contactOwnerMid = makeUserAddMyselfAsContact_args_contactOwnerMid obj} then P.Nothing else P.Just $ default_MakeUserAddMyselfAsContact_args{makeUserAddMyselfAsContact_args_contactOwnerMid = makeUserAddMyselfAsContact_args_contactOwnerMid obj}
    ]
from_MakeUserAddMyselfAsContact_args :: MakeUserAddMyselfAsContact_args -> T.ThriftVal
from_MakeUserAddMyselfAsContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8352 -> P.Just (1, ("contactOwnerMid",T.TString $ E.encodeUtf8 _v8352))) $ makeUserAddMyselfAsContact_args_contactOwnerMid record
  ]
write_MakeUserAddMyselfAsContact_args :: T.Protocol p => p -> MakeUserAddMyselfAsContact_args -> P.IO ()
write_MakeUserAddMyselfAsContact_args oprot record = T.writeVal oprot $ from_MakeUserAddMyselfAsContact_args record
encode_MakeUserAddMyselfAsContact_args :: T.StatelessProtocol p => p -> MakeUserAddMyselfAsContact_args -> LBS.ByteString
encode_MakeUserAddMyselfAsContact_args oprot record = T.serializeVal oprot $ from_MakeUserAddMyselfAsContact_args record
to_MakeUserAddMyselfAsContact_args :: T.ThriftVal -> MakeUserAddMyselfAsContact_args
to_MakeUserAddMyselfAsContact_args (T.TStruct fields) = MakeUserAddMyselfAsContact_args{
  makeUserAddMyselfAsContact_args_contactOwnerMid = P.maybe (makeUserAddMyselfAsContact_args_contactOwnerMid default_MakeUserAddMyselfAsContact_args) (\(_,_val8354) -> (case _val8354 of {T.TString _val8355 -> E.decodeUtf8 _val8355; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MakeUserAddMyselfAsContact_args _ = P.error "not a struct"
read_MakeUserAddMyselfAsContact_args :: T.Protocol p => p -> P.IO MakeUserAddMyselfAsContact_args
read_MakeUserAddMyselfAsContact_args iprot = to_MakeUserAddMyselfAsContact_args <$> T.readVal iprot (T.T_STRUCT typemap_MakeUserAddMyselfAsContact_args)
decode_MakeUserAddMyselfAsContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> MakeUserAddMyselfAsContact_args
decode_MakeUserAddMyselfAsContact_args iprot bs = to_MakeUserAddMyselfAsContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MakeUserAddMyselfAsContact_args) bs
typemap_MakeUserAddMyselfAsContact_args :: T.TypeMap
typemap_MakeUserAddMyselfAsContact_args = Map.fromList [(1,("contactOwnerMid",T.T_STRING))]
default_MakeUserAddMyselfAsContact_args :: MakeUserAddMyselfAsContact_args
default_MakeUserAddMyselfAsContact_args = MakeUserAddMyselfAsContact_args{
  makeUserAddMyselfAsContact_args_contactOwnerMid = ""}
data MakeUserAddMyselfAsContact_result = MakeUserAddMyselfAsContact_result  { makeUserAddMyselfAsContact_result_success :: ContactTransition
  , makeUserAddMyselfAsContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MakeUserAddMyselfAsContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` makeUserAddMyselfAsContact_result_success record   `H.hashWithSalt` makeUserAddMyselfAsContact_result_e record  
instance QC.Arbitrary MakeUserAddMyselfAsContact_result where 
  arbitrary = M.liftM MakeUserAddMyselfAsContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MakeUserAddMyselfAsContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_success = makeUserAddMyselfAsContact_result_success obj} then P.Nothing else P.Just $ default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_success = makeUserAddMyselfAsContact_result_success obj}
    , if obj == default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_e = makeUserAddMyselfAsContact_result_e obj} then P.Nothing else P.Just $ default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_e = makeUserAddMyselfAsContact_result_e obj}
    ]
from_MakeUserAddMyselfAsContact_result :: MakeUserAddMyselfAsContact_result -> T.ThriftVal
from_MakeUserAddMyselfAsContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8358 -> (1, ("e",from_TalkException _v8358))) <$> makeUserAddMyselfAsContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8358 -> P.Just (0, ("success",from_ContactTransition _v8358))) $ makeUserAddMyselfAsContact_result_success record
    , (\_v8358 -> (1, ("e",from_TalkException _v8358))) <$> makeUserAddMyselfAsContact_result_e record
    ]
    )
write_MakeUserAddMyselfAsContact_result :: T.Protocol p => p -> MakeUserAddMyselfAsContact_result -> P.IO ()
write_MakeUserAddMyselfAsContact_result oprot record = T.writeVal oprot $ from_MakeUserAddMyselfAsContact_result record
encode_MakeUserAddMyselfAsContact_result :: T.StatelessProtocol p => p -> MakeUserAddMyselfAsContact_result -> LBS.ByteString
encode_MakeUserAddMyselfAsContact_result oprot record = T.serializeVal oprot $ from_MakeUserAddMyselfAsContact_result record
to_MakeUserAddMyselfAsContact_result :: T.ThriftVal -> MakeUserAddMyselfAsContact_result
to_MakeUserAddMyselfAsContact_result (T.TStruct fields) = MakeUserAddMyselfAsContact_result{
  makeUserAddMyselfAsContact_result_success = P.maybe (makeUserAddMyselfAsContact_result_success default_MakeUserAddMyselfAsContact_result) (\(_,_val8360) -> (case _val8360 of {T.TStruct _val8361 -> (to_ContactTransition (T.TStruct _val8361)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  makeUserAddMyselfAsContact_result_e = P.maybe (P.Nothing) (\(_,_val8360) -> P.Just (case _val8360 of {T.TStruct _val8362 -> (to_TalkException (T.TStruct _val8362)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MakeUserAddMyselfAsContact_result _ = P.error "not a struct"
read_MakeUserAddMyselfAsContact_result :: T.Protocol p => p -> P.IO MakeUserAddMyselfAsContact_result
read_MakeUserAddMyselfAsContact_result iprot = to_MakeUserAddMyselfAsContact_result <$> T.readVal iprot (T.T_STRUCT typemap_MakeUserAddMyselfAsContact_result)
decode_MakeUserAddMyselfAsContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> MakeUserAddMyselfAsContact_result
decode_MakeUserAddMyselfAsContact_result iprot bs = to_MakeUserAddMyselfAsContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MakeUserAddMyselfAsContact_result) bs
typemap_MakeUserAddMyselfAsContact_result :: T.TypeMap
typemap_MakeUserAddMyselfAsContact_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ContactTransition))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_MakeUserAddMyselfAsContact_result :: MakeUserAddMyselfAsContact_result
default_MakeUserAddMyselfAsContact_result = MakeUserAddMyselfAsContact_result{
  makeUserAddMyselfAsContact_result_success = default_ContactTransition,
  makeUserAddMyselfAsContact_result_e = P.Nothing}
data RemoveMessageFromMyHome_args = RemoveMessageFromMyHome_args  { removeMessageFromMyHome_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessageFromMyHome_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessageFromMyHome_args_messageId record  
instance QC.Arbitrary RemoveMessageFromMyHome_args where 
  arbitrary = M.liftM RemoveMessageFromMyHome_args (QC.arbitrary)
  shrink obj | obj == default_RemoveMessageFromMyHome_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessageFromMyHome_args{removeMessageFromMyHome_args_messageId = removeMessageFromMyHome_args_messageId obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_args{removeMessageFromMyHome_args_messageId = removeMessageFromMyHome_args_messageId obj}
    ]
from_RemoveMessageFromMyHome_args :: RemoveMessageFromMyHome_args -> T.ThriftVal
from_RemoveMessageFromMyHome_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8365 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v8365))) $ removeMessageFromMyHome_args_messageId record
  ]
write_RemoveMessageFromMyHome_args :: T.Protocol p => p -> RemoveMessageFromMyHome_args -> P.IO ()
write_RemoveMessageFromMyHome_args oprot record = T.writeVal oprot $ from_RemoveMessageFromMyHome_args record
encode_RemoveMessageFromMyHome_args :: T.StatelessProtocol p => p -> RemoveMessageFromMyHome_args -> LBS.ByteString
encode_RemoveMessageFromMyHome_args oprot record = T.serializeVal oprot $ from_RemoveMessageFromMyHome_args record
to_RemoveMessageFromMyHome_args :: T.ThriftVal -> RemoveMessageFromMyHome_args
to_RemoveMessageFromMyHome_args (T.TStruct fields) = RemoveMessageFromMyHome_args{
  removeMessageFromMyHome_args_messageId = P.maybe (removeMessageFromMyHome_args_messageId default_RemoveMessageFromMyHome_args) (\(_,_val8367) -> (case _val8367 of {T.TString _val8368 -> E.decodeUtf8 _val8368; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveMessageFromMyHome_args _ = P.error "not a struct"
read_RemoveMessageFromMyHome_args :: T.Protocol p => p -> P.IO RemoveMessageFromMyHome_args
read_RemoveMessageFromMyHome_args iprot = to_RemoveMessageFromMyHome_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_args)
decode_RemoveMessageFromMyHome_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessageFromMyHome_args
decode_RemoveMessageFromMyHome_args iprot bs = to_RemoveMessageFromMyHome_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_args) bs
typemap_RemoveMessageFromMyHome_args :: T.TypeMap
typemap_RemoveMessageFromMyHome_args = Map.fromList [(2,("messageId",T.T_STRING))]
default_RemoveMessageFromMyHome_args :: RemoveMessageFromMyHome_args
default_RemoveMessageFromMyHome_args = RemoveMessageFromMyHome_args{
  removeMessageFromMyHome_args_messageId = ""}
data RemoveMessageFromMyHome_result = RemoveMessageFromMyHome_result  { removeMessageFromMyHome_result_success :: P.Bool
  , removeMessageFromMyHome_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveMessageFromMyHome_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeMessageFromMyHome_result_success record   `H.hashWithSalt` removeMessageFromMyHome_result_e record  
instance QC.Arbitrary RemoveMessageFromMyHome_result where 
  arbitrary = M.liftM RemoveMessageFromMyHome_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveMessageFromMyHome_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = removeMessageFromMyHome_result_success obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = removeMessageFromMyHome_result_success obj}
    , if obj == default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = removeMessageFromMyHome_result_e obj} then P.Nothing else P.Just $ default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = removeMessageFromMyHome_result_e obj}
    ]
from_RemoveMessageFromMyHome_result :: RemoveMessageFromMyHome_result -> T.ThriftVal
from_RemoveMessageFromMyHome_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8371 -> (1, ("e",from_TalkException _v8371))) <$> removeMessageFromMyHome_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8371 -> P.Just (0, ("success",T.TBool _v8371))) $ removeMessageFromMyHome_result_success record
    , (\_v8371 -> (1, ("e",from_TalkException _v8371))) <$> removeMessageFromMyHome_result_e record
    ]
    )
write_RemoveMessageFromMyHome_result :: T.Protocol p => p -> RemoveMessageFromMyHome_result -> P.IO ()
write_RemoveMessageFromMyHome_result oprot record = T.writeVal oprot $ from_RemoveMessageFromMyHome_result record
encode_RemoveMessageFromMyHome_result :: T.StatelessProtocol p => p -> RemoveMessageFromMyHome_result -> LBS.ByteString
encode_RemoveMessageFromMyHome_result oprot record = T.serializeVal oprot $ from_RemoveMessageFromMyHome_result record
to_RemoveMessageFromMyHome_result :: T.ThriftVal -> RemoveMessageFromMyHome_result
to_RemoveMessageFromMyHome_result (T.TStruct fields) = RemoveMessageFromMyHome_result{
  removeMessageFromMyHome_result_success = P.maybe (removeMessageFromMyHome_result_success default_RemoveMessageFromMyHome_result) (\(_,_val8373) -> (case _val8373 of {T.TBool _val8374 -> _val8374; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeMessageFromMyHome_result_e = P.maybe (P.Nothing) (\(_,_val8373) -> P.Just (case _val8373 of {T.TStruct _val8375 -> (to_TalkException (T.TStruct _val8375)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveMessageFromMyHome_result _ = P.error "not a struct"
read_RemoveMessageFromMyHome_result :: T.Protocol p => p -> P.IO RemoveMessageFromMyHome_result
read_RemoveMessageFromMyHome_result iprot = to_RemoveMessageFromMyHome_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_result)
decode_RemoveMessageFromMyHome_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveMessageFromMyHome_result
decode_RemoveMessageFromMyHome_result iprot bs = to_RemoveMessageFromMyHome_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveMessageFromMyHome_result) bs
typemap_RemoveMessageFromMyHome_result :: T.TypeMap
typemap_RemoveMessageFromMyHome_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveMessageFromMyHome_result :: RemoveMessageFromMyHome_result
default_RemoveMessageFromMyHome_result = RemoveMessageFromMyHome_result{
  removeMessageFromMyHome_result_success = P.False,
  removeMessageFromMyHome_result_e = P.Nothing}
data RemoveSnsId_args = RemoveSnsId_args  { removeSnsId_args_snsIdType :: SnsIdType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSnsId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSnsId_args_snsIdType record  
instance QC.Arbitrary RemoveSnsId_args where 
  arbitrary = M.liftM RemoveSnsId_args (QC.arbitrary)
  shrink obj | obj == default_RemoveSnsId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSnsId_args{removeSnsId_args_snsIdType = removeSnsId_args_snsIdType obj} then P.Nothing else P.Just $ default_RemoveSnsId_args{removeSnsId_args_snsIdType = removeSnsId_args_snsIdType obj}
    ]
from_RemoveSnsId_args :: RemoveSnsId_args -> T.ThriftVal
from_RemoveSnsId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8378 -> P.Just (2, ("snsIdType",T.TI32 $ P.fromIntegral $ P.fromEnum _v8378))) $ removeSnsId_args_snsIdType record
  ]
write_RemoveSnsId_args :: T.Protocol p => p -> RemoveSnsId_args -> P.IO ()
write_RemoveSnsId_args oprot record = T.writeVal oprot $ from_RemoveSnsId_args record
encode_RemoveSnsId_args :: T.StatelessProtocol p => p -> RemoveSnsId_args -> LBS.ByteString
encode_RemoveSnsId_args oprot record = T.serializeVal oprot $ from_RemoveSnsId_args record
to_RemoveSnsId_args :: T.ThriftVal -> RemoveSnsId_args
to_RemoveSnsId_args (T.TStruct fields) = RemoveSnsId_args{
  removeSnsId_args_snsIdType = P.maybe (removeSnsId_args_snsIdType default_RemoveSnsId_args) (\(_,_val8380) -> (case _val8380 of {T.TI32 _val8381 -> P.toEnum $ P.fromIntegral _val8381; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveSnsId_args _ = P.error "not a struct"
read_RemoveSnsId_args :: T.Protocol p => p -> P.IO RemoveSnsId_args
read_RemoveSnsId_args iprot = to_RemoveSnsId_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSnsId_args)
decode_RemoveSnsId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSnsId_args
decode_RemoveSnsId_args iprot bs = to_RemoveSnsId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSnsId_args) bs
typemap_RemoveSnsId_args :: T.TypeMap
typemap_RemoveSnsId_args = Map.fromList [(2,("snsIdType",T.T_I32))]
default_RemoveSnsId_args :: RemoveSnsId_args
default_RemoveSnsId_args = RemoveSnsId_args{
  removeSnsId_args_snsIdType = (P.toEnum 0)}
data RemoveSnsId_result = RemoveSnsId_result  { removeSnsId_result_success :: LT.Text
  , removeSnsId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveSnsId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeSnsId_result_success record   `H.hashWithSalt` removeSnsId_result_e record  
instance QC.Arbitrary RemoveSnsId_result where 
  arbitrary = M.liftM RemoveSnsId_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveSnsId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveSnsId_result{removeSnsId_result_success = removeSnsId_result_success obj} then P.Nothing else P.Just $ default_RemoveSnsId_result{removeSnsId_result_success = removeSnsId_result_success obj}
    , if obj == default_RemoveSnsId_result{removeSnsId_result_e = removeSnsId_result_e obj} then P.Nothing else P.Just $ default_RemoveSnsId_result{removeSnsId_result_e = removeSnsId_result_e obj}
    ]
from_RemoveSnsId_result :: RemoveSnsId_result -> T.ThriftVal
from_RemoveSnsId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8384 -> (1, ("e",from_TalkException _v8384))) <$> removeSnsId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8384 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v8384))) $ removeSnsId_result_success record
    , (\_v8384 -> (1, ("e",from_TalkException _v8384))) <$> removeSnsId_result_e record
    ]
    )
write_RemoveSnsId_result :: T.Protocol p => p -> RemoveSnsId_result -> P.IO ()
write_RemoveSnsId_result oprot record = T.writeVal oprot $ from_RemoveSnsId_result record
encode_RemoveSnsId_result :: T.StatelessProtocol p => p -> RemoveSnsId_result -> LBS.ByteString
encode_RemoveSnsId_result oprot record = T.serializeVal oprot $ from_RemoveSnsId_result record
to_RemoveSnsId_result :: T.ThriftVal -> RemoveSnsId_result
to_RemoveSnsId_result (T.TStruct fields) = RemoveSnsId_result{
  removeSnsId_result_success = P.maybe (removeSnsId_result_success default_RemoveSnsId_result) (\(_,_val8386) -> (case _val8386 of {T.TString _val8387 -> E.decodeUtf8 _val8387; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  removeSnsId_result_e = P.maybe (P.Nothing) (\(_,_val8386) -> P.Just (case _val8386 of {T.TStruct _val8388 -> (to_TalkException (T.TStruct _val8388)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveSnsId_result _ = P.error "not a struct"
read_RemoveSnsId_result :: T.Protocol p => p -> P.IO RemoveSnsId_result
read_RemoveSnsId_result iprot = to_RemoveSnsId_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveSnsId_result)
decode_RemoveSnsId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveSnsId_result
decode_RemoveSnsId_result iprot bs = to_RemoveSnsId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveSnsId_result) bs
typemap_RemoveSnsId_result :: T.TypeMap
typemap_RemoveSnsId_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveSnsId_result :: RemoveSnsId_result
default_RemoveSnsId_result = RemoveSnsId_result{
  removeSnsId_result_success = "",
  removeSnsId_result_e = P.Nothing}
data Report_args = Report_args  { report_args_syncOpRevision :: I.Int64
  , report_args_category :: SyncCategory
  , report_args_report :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Report_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` report_args_syncOpRevision record   `H.hashWithSalt` report_args_category record   `H.hashWithSalt` report_args_report record  
instance QC.Arbitrary Report_args where 
  arbitrary = M.liftM Report_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_Report_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Report_args{report_args_syncOpRevision = report_args_syncOpRevision obj} then P.Nothing else P.Just $ default_Report_args{report_args_syncOpRevision = report_args_syncOpRevision obj}
    , if obj == default_Report_args{report_args_category = report_args_category obj} then P.Nothing else P.Just $ default_Report_args{report_args_category = report_args_category obj}
    , if obj == default_Report_args{report_args_report = report_args_report obj} then P.Nothing else P.Just $ default_Report_args{report_args_report = report_args_report obj}
    ]
from_Report_args :: Report_args -> T.ThriftVal
from_Report_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8391 -> P.Just (2, ("syncOpRevision",T.TI64 _v8391))) $ report_args_syncOpRevision record
  , (\_v8391 -> P.Just (3, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v8391))) $ report_args_category record
  , (\_v8391 -> P.Just (4, ("report",T.TString $ E.encodeUtf8 _v8391))) $ report_args_report record
  ]
write_Report_args :: T.Protocol p => p -> Report_args -> P.IO ()
write_Report_args oprot record = T.writeVal oprot $ from_Report_args record
encode_Report_args :: T.StatelessProtocol p => p -> Report_args -> LBS.ByteString
encode_Report_args oprot record = T.serializeVal oprot $ from_Report_args record
to_Report_args :: T.ThriftVal -> Report_args
to_Report_args (T.TStruct fields) = Report_args{
  report_args_syncOpRevision = P.maybe (report_args_syncOpRevision default_Report_args) (\(_,_val8393) -> (case _val8393 of {T.TI64 _val8394 -> _val8394; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  report_args_category = P.maybe (report_args_category default_Report_args) (\(_,_val8393) -> (case _val8393 of {T.TI32 _val8395 -> P.toEnum $ P.fromIntegral _val8395; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  report_args_report = P.maybe (report_args_report default_Report_args) (\(_,_val8393) -> (case _val8393 of {T.TString _val8396 -> E.decodeUtf8 _val8396; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Report_args _ = P.error "not a struct"
read_Report_args :: T.Protocol p => p -> P.IO Report_args
read_Report_args iprot = to_Report_args <$> T.readVal iprot (T.T_STRUCT typemap_Report_args)
decode_Report_args :: T.StatelessProtocol p => p -> LBS.ByteString -> Report_args
decode_Report_args iprot bs = to_Report_args $ T.deserializeVal iprot (T.T_STRUCT typemap_Report_args) bs
typemap_Report_args :: T.TypeMap
typemap_Report_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("category",T.T_I32)),(4,("report",T.T_STRING))]
default_Report_args :: Report_args
default_Report_args = Report_args{
  report_args_syncOpRevision = 0,
  report_args_category = (P.toEnum 0),
  report_args_report = ""}
data Report_result = Report_result  { report_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Report_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` report_result_e record  
instance QC.Arbitrary Report_result where 
  arbitrary = M.liftM Report_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Report_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Report_result{report_result_e = report_result_e obj} then P.Nothing else P.Just $ default_Report_result{report_result_e = report_result_e obj}
    ]
from_Report_result :: Report_result -> T.ThriftVal
from_Report_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8399 -> (1, ("e",from_TalkException _v8399))) <$> report_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8399 -> (1, ("e",from_TalkException _v8399))) <$> report_result_e record
    ]
    )
write_Report_result :: T.Protocol p => p -> Report_result -> P.IO ()
write_Report_result oprot record = T.writeVal oprot $ from_Report_result record
encode_Report_result :: T.StatelessProtocol p => p -> Report_result -> LBS.ByteString
encode_Report_result oprot record = T.serializeVal oprot $ from_Report_result record
to_Report_result :: T.ThriftVal -> Report_result
to_Report_result (T.TStruct fields) = Report_result{
  report_result_e = P.maybe (P.Nothing) (\(_,_val8401) -> P.Just (case _val8401 of {T.TStruct _val8402 -> (to_TalkException (T.TStruct _val8402)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_Report_result _ = P.error "not a struct"
read_Report_result :: T.Protocol p => p -> P.IO Report_result
read_Report_result iprot = to_Report_result <$> T.readVal iprot (T.T_STRUCT typemap_Report_result)
decode_Report_result :: T.StatelessProtocol p => p -> LBS.ByteString -> Report_result
decode_Report_result iprot bs = to_Report_result $ T.deserializeVal iprot (T.T_STRUCT typemap_Report_result) bs
typemap_Report_result :: T.TypeMap
typemap_Report_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_Report_result :: Report_result
default_Report_result = Report_result{
  report_result_e = P.Nothing}
data ReportContacts_args = ReportContacts_args  { reportContacts_args_syncOpRevision :: I.Int64
  , reportContacts_args_category :: SyncCategory
  , reportContacts_args_contactReports :: (Vector.Vector ContactReport)
  , reportContacts_args_actionType :: SyncActionType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportContacts_args_syncOpRevision record   `H.hashWithSalt` reportContacts_args_category record   `H.hashWithSalt` reportContacts_args_contactReports record   `H.hashWithSalt` reportContacts_args_actionType record  
instance QC.Arbitrary ReportContacts_args where 
  arbitrary = M.liftM ReportContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportContacts_args{reportContacts_args_syncOpRevision = reportContacts_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_syncOpRevision = reportContacts_args_syncOpRevision obj}
    , if obj == default_ReportContacts_args{reportContacts_args_category = reportContacts_args_category obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_category = reportContacts_args_category obj}
    , if obj == default_ReportContacts_args{reportContacts_args_contactReports = reportContacts_args_contactReports obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_contactReports = reportContacts_args_contactReports obj}
    , if obj == default_ReportContacts_args{reportContacts_args_actionType = reportContacts_args_actionType obj} then P.Nothing else P.Just $ default_ReportContacts_args{reportContacts_args_actionType = reportContacts_args_actionType obj}
    ]
from_ReportContacts_args :: ReportContacts_args -> T.ThriftVal
from_ReportContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8405 -> P.Just (2, ("syncOpRevision",T.TI64 _v8405))) $ reportContacts_args_syncOpRevision record
  , (\_v8405 -> P.Just (3, ("category",T.TI32 $ P.fromIntegral $ P.fromEnum _v8405))) $ reportContacts_args_category record
  , (\_v8405 -> P.Just (4, ("contactReports",T.TList (T.T_STRUCT typemap_ContactReport) $ P.map (\_v8407 -> from_ContactReport _v8407) $ Vector.toList _v8405))) $ reportContacts_args_contactReports record
  , (\_v8405 -> P.Just (5, ("actionType",T.TI32 $ P.fromIntegral $ P.fromEnum _v8405))) $ reportContacts_args_actionType record
  ]
write_ReportContacts_args :: T.Protocol p => p -> ReportContacts_args -> P.IO ()
write_ReportContacts_args oprot record = T.writeVal oprot $ from_ReportContacts_args record
encode_ReportContacts_args :: T.StatelessProtocol p => p -> ReportContacts_args -> LBS.ByteString
encode_ReportContacts_args oprot record = T.serializeVal oprot $ from_ReportContacts_args record
to_ReportContacts_args :: T.ThriftVal -> ReportContacts_args
to_ReportContacts_args (T.TStruct fields) = ReportContacts_args{
  reportContacts_args_syncOpRevision = P.maybe (reportContacts_args_syncOpRevision default_ReportContacts_args) (\(_,_val8409) -> (case _val8409 of {T.TI64 _val8410 -> _val8410; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportContacts_args_category = P.maybe (reportContacts_args_category default_ReportContacts_args) (\(_,_val8409) -> (case _val8409 of {T.TI32 _val8411 -> P.toEnum $ P.fromIntegral _val8411; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportContacts_args_contactReports = P.maybe (reportContacts_args_contactReports default_ReportContacts_args) (\(_,_val8409) -> (case _val8409 of {T.TList _ _val8412 -> (Vector.fromList $ P.map (\_v8413 -> (case _v8413 of {T.TStruct _val8414 -> (to_ContactReport (T.TStruct _val8414)); _ -> P.error "wrong type"})) _val8412); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  reportContacts_args_actionType = P.maybe (reportContacts_args_actionType default_ReportContacts_args) (\(_,_val8409) -> (case _val8409 of {T.TI32 _val8415 -> P.toEnum $ P.fromIntegral _val8415; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ReportContacts_args _ = P.error "not a struct"
read_ReportContacts_args :: T.Protocol p => p -> P.IO ReportContacts_args
read_ReportContacts_args iprot = to_ReportContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportContacts_args)
decode_ReportContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportContacts_args
decode_ReportContacts_args iprot bs = to_ReportContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportContacts_args) bs
typemap_ReportContacts_args :: T.TypeMap
typemap_ReportContacts_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("category",T.T_I32)),(4,("contactReports",(T.T_LIST (T.T_STRUCT typemap_ContactReport)))),(5,("actionType",T.T_I32))]
default_ReportContacts_args :: ReportContacts_args
default_ReportContacts_args = ReportContacts_args{
  reportContacts_args_syncOpRevision = 0,
  reportContacts_args_category = (P.toEnum 0),
  reportContacts_args_contactReports = Vector.empty,
  reportContacts_args_actionType = (P.toEnum 0)}
data ReportContacts_result = ReportContacts_result  { reportContacts_result_success :: (Vector.Vector ContactReportResult)
  , reportContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportContacts_result_success record   `H.hashWithSalt` reportContacts_result_e record  
instance QC.Arbitrary ReportContacts_result where 
  arbitrary = M.liftM ReportContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportContacts_result{reportContacts_result_success = reportContacts_result_success obj} then P.Nothing else P.Just $ default_ReportContacts_result{reportContacts_result_success = reportContacts_result_success obj}
    , if obj == default_ReportContacts_result{reportContacts_result_e = reportContacts_result_e obj} then P.Nothing else P.Just $ default_ReportContacts_result{reportContacts_result_e = reportContacts_result_e obj}
    ]
from_ReportContacts_result :: ReportContacts_result -> T.ThriftVal
from_ReportContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8418 -> (1, ("e",from_TalkException _v8418))) <$> reportContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8418 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_ContactReportResult) $ P.map (\_v8420 -> from_ContactReportResult _v8420) $ Vector.toList _v8418))) $ reportContacts_result_success record
    , (\_v8418 -> (1, ("e",from_TalkException _v8418))) <$> reportContacts_result_e record
    ]
    )
write_ReportContacts_result :: T.Protocol p => p -> ReportContacts_result -> P.IO ()
write_ReportContacts_result oprot record = T.writeVal oprot $ from_ReportContacts_result record
encode_ReportContacts_result :: T.StatelessProtocol p => p -> ReportContacts_result -> LBS.ByteString
encode_ReportContacts_result oprot record = T.serializeVal oprot $ from_ReportContacts_result record
to_ReportContacts_result :: T.ThriftVal -> ReportContacts_result
to_ReportContacts_result (T.TStruct fields) = ReportContacts_result{
  reportContacts_result_success = P.maybe (reportContacts_result_success default_ReportContacts_result) (\(_,_val8422) -> (case _val8422 of {T.TList _ _val8423 -> (Vector.fromList $ P.map (\_v8424 -> (case _v8424 of {T.TStruct _val8425 -> (to_ContactReportResult (T.TStruct _val8425)); _ -> P.error "wrong type"})) _val8423); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reportContacts_result_e = P.maybe (P.Nothing) (\(_,_val8422) -> P.Just (case _val8422 of {T.TStruct _val8426 -> (to_TalkException (T.TStruct _val8426)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportContacts_result _ = P.error "not a struct"
read_ReportContacts_result :: T.Protocol p => p -> P.IO ReportContacts_result
read_ReportContacts_result iprot = to_ReportContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportContacts_result)
decode_ReportContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportContacts_result
decode_ReportContacts_result iprot bs = to_ReportContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportContacts_result) bs
typemap_ReportContacts_result :: T.TypeMap
typemap_ReportContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_ContactReportResult)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportContacts_result :: ReportContacts_result
default_ReportContacts_result = ReportContacts_result{
  reportContacts_result_success = Vector.empty,
  reportContacts_result_e = P.Nothing}
data ReportGroups_args = ReportGroups_args  { reportGroups_args_syncOpRevision :: I.Int64
  , reportGroups_args_groups :: (Vector.Vector Group)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportGroups_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportGroups_args_syncOpRevision record   `H.hashWithSalt` reportGroups_args_groups record  
instance QC.Arbitrary ReportGroups_args where 
  arbitrary = M.liftM ReportGroups_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportGroups_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportGroups_args{reportGroups_args_syncOpRevision = reportGroups_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportGroups_args{reportGroups_args_syncOpRevision = reportGroups_args_syncOpRevision obj}
    , if obj == default_ReportGroups_args{reportGroups_args_groups = reportGroups_args_groups obj} then P.Nothing else P.Just $ default_ReportGroups_args{reportGroups_args_groups = reportGroups_args_groups obj}
    ]
from_ReportGroups_args :: ReportGroups_args -> T.ThriftVal
from_ReportGroups_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8429 -> P.Just (2, ("syncOpRevision",T.TI64 _v8429))) $ reportGroups_args_syncOpRevision record
  , (\_v8429 -> P.Just (3, ("groups",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v8431 -> from_Group _v8431) $ Vector.toList _v8429))) $ reportGroups_args_groups record
  ]
write_ReportGroups_args :: T.Protocol p => p -> ReportGroups_args -> P.IO ()
write_ReportGroups_args oprot record = T.writeVal oprot $ from_ReportGroups_args record
encode_ReportGroups_args :: T.StatelessProtocol p => p -> ReportGroups_args -> LBS.ByteString
encode_ReportGroups_args oprot record = T.serializeVal oprot $ from_ReportGroups_args record
to_ReportGroups_args :: T.ThriftVal -> ReportGroups_args
to_ReportGroups_args (T.TStruct fields) = ReportGroups_args{
  reportGroups_args_syncOpRevision = P.maybe (reportGroups_args_syncOpRevision default_ReportGroups_args) (\(_,_val8433) -> (case _val8433 of {T.TI64 _val8434 -> _val8434; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportGroups_args_groups = P.maybe (reportGroups_args_groups default_ReportGroups_args) (\(_,_val8433) -> (case _val8433 of {T.TList _ _val8435 -> (Vector.fromList $ P.map (\_v8436 -> (case _v8436 of {T.TStruct _val8437 -> (to_Group (T.TStruct _val8437)); _ -> P.error "wrong type"})) _val8435); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportGroups_args _ = P.error "not a struct"
read_ReportGroups_args :: T.Protocol p => p -> P.IO ReportGroups_args
read_ReportGroups_args iprot = to_ReportGroups_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportGroups_args)
decode_ReportGroups_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportGroups_args
decode_ReportGroups_args iprot bs = to_ReportGroups_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportGroups_args) bs
typemap_ReportGroups_args :: T.TypeMap
typemap_ReportGroups_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("groups",(T.T_LIST (T.T_STRUCT typemap_Group))))]
default_ReportGroups_args :: ReportGroups_args
default_ReportGroups_args = ReportGroups_args{
  reportGroups_args_syncOpRevision = 0,
  reportGroups_args_groups = Vector.empty}
data ReportGroups_result = ReportGroups_result  { reportGroups_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportGroups_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportGroups_result_e record  
instance QC.Arbitrary ReportGroups_result where 
  arbitrary = M.liftM ReportGroups_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportGroups_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportGroups_result{reportGroups_result_e = reportGroups_result_e obj} then P.Nothing else P.Just $ default_ReportGroups_result{reportGroups_result_e = reportGroups_result_e obj}
    ]
from_ReportGroups_result :: ReportGroups_result -> T.ThriftVal
from_ReportGroups_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8440 -> (1, ("e",from_TalkException _v8440))) <$> reportGroups_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8440 -> (1, ("e",from_TalkException _v8440))) <$> reportGroups_result_e record
    ]
    )
write_ReportGroups_result :: T.Protocol p => p -> ReportGroups_result -> P.IO ()
write_ReportGroups_result oprot record = T.writeVal oprot $ from_ReportGroups_result record
encode_ReportGroups_result :: T.StatelessProtocol p => p -> ReportGroups_result -> LBS.ByteString
encode_ReportGroups_result oprot record = T.serializeVal oprot $ from_ReportGroups_result record
to_ReportGroups_result :: T.ThriftVal -> ReportGroups_result
to_ReportGroups_result (T.TStruct fields) = ReportGroups_result{
  reportGroups_result_e = P.maybe (P.Nothing) (\(_,_val8442) -> P.Just (case _val8442 of {T.TStruct _val8443 -> (to_TalkException (T.TStruct _val8443)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportGroups_result _ = P.error "not a struct"
read_ReportGroups_result :: T.Protocol p => p -> P.IO ReportGroups_result
read_ReportGroups_result iprot = to_ReportGroups_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportGroups_result)
decode_ReportGroups_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportGroups_result
decode_ReportGroups_result iprot bs = to_ReportGroups_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportGroups_result) bs
typemap_ReportGroups_result :: T.TypeMap
typemap_ReportGroups_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportGroups_result :: ReportGroups_result
default_ReportGroups_result = ReportGroups_result{
  reportGroups_result_e = P.Nothing}
data ReportProfile_args = ReportProfile_args  { reportProfile_args_syncOpRevision :: I.Int64
  , reportProfile_args_profile :: Profile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportProfile_args_syncOpRevision record   `H.hashWithSalt` reportProfile_args_profile record  
instance QC.Arbitrary ReportProfile_args where 
  arbitrary = M.liftM ReportProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportProfile_args{reportProfile_args_syncOpRevision = reportProfile_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportProfile_args{reportProfile_args_syncOpRevision = reportProfile_args_syncOpRevision obj}
    , if obj == default_ReportProfile_args{reportProfile_args_profile = reportProfile_args_profile obj} then P.Nothing else P.Just $ default_ReportProfile_args{reportProfile_args_profile = reportProfile_args_profile obj}
    ]
from_ReportProfile_args :: ReportProfile_args -> T.ThriftVal
from_ReportProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8446 -> P.Just (2, ("syncOpRevision",T.TI64 _v8446))) $ reportProfile_args_syncOpRevision record
  , (\_v8446 -> P.Just (3, ("profile",from_Profile _v8446))) $ reportProfile_args_profile record
  ]
write_ReportProfile_args :: T.Protocol p => p -> ReportProfile_args -> P.IO ()
write_ReportProfile_args oprot record = T.writeVal oprot $ from_ReportProfile_args record
encode_ReportProfile_args :: T.StatelessProtocol p => p -> ReportProfile_args -> LBS.ByteString
encode_ReportProfile_args oprot record = T.serializeVal oprot $ from_ReportProfile_args record
to_ReportProfile_args :: T.ThriftVal -> ReportProfile_args
to_ReportProfile_args (T.TStruct fields) = ReportProfile_args{
  reportProfile_args_syncOpRevision = P.maybe (reportProfile_args_syncOpRevision default_ReportProfile_args) (\(_,_val8448) -> (case _val8448 of {T.TI64 _val8449 -> _val8449; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportProfile_args_profile = P.maybe (reportProfile_args_profile default_ReportProfile_args) (\(_,_val8448) -> (case _val8448 of {T.TStruct _val8450 -> (to_Profile (T.TStruct _val8450)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportProfile_args _ = P.error "not a struct"
read_ReportProfile_args :: T.Protocol p => p -> P.IO ReportProfile_args
read_ReportProfile_args iprot = to_ReportProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportProfile_args)
decode_ReportProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportProfile_args
decode_ReportProfile_args iprot bs = to_ReportProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportProfile_args) bs
typemap_ReportProfile_args :: T.TypeMap
typemap_ReportProfile_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("profile",(T.T_STRUCT typemap_Profile)))]
default_ReportProfile_args :: ReportProfile_args
default_ReportProfile_args = ReportProfile_args{
  reportProfile_args_syncOpRevision = 0,
  reportProfile_args_profile = default_Profile}
data ReportProfile_result = ReportProfile_result  { reportProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportProfile_result_e record  
instance QC.Arbitrary ReportProfile_result where 
  arbitrary = M.liftM ReportProfile_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportProfile_result{reportProfile_result_e = reportProfile_result_e obj} then P.Nothing else P.Just $ default_ReportProfile_result{reportProfile_result_e = reportProfile_result_e obj}
    ]
from_ReportProfile_result :: ReportProfile_result -> T.ThriftVal
from_ReportProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8453 -> (1, ("e",from_TalkException _v8453))) <$> reportProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8453 -> (1, ("e",from_TalkException _v8453))) <$> reportProfile_result_e record
    ]
    )
write_ReportProfile_result :: T.Protocol p => p -> ReportProfile_result -> P.IO ()
write_ReportProfile_result oprot record = T.writeVal oprot $ from_ReportProfile_result record
encode_ReportProfile_result :: T.StatelessProtocol p => p -> ReportProfile_result -> LBS.ByteString
encode_ReportProfile_result oprot record = T.serializeVal oprot $ from_ReportProfile_result record
to_ReportProfile_result :: T.ThriftVal -> ReportProfile_result
to_ReportProfile_result (T.TStruct fields) = ReportProfile_result{
  reportProfile_result_e = P.maybe (P.Nothing) (\(_,_val8455) -> P.Just (case _val8455 of {T.TStruct _val8456 -> (to_TalkException (T.TStruct _val8456)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportProfile_result _ = P.error "not a struct"
read_ReportProfile_result :: T.Protocol p => p -> P.IO ReportProfile_result
read_ReportProfile_result iprot = to_ReportProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportProfile_result)
decode_ReportProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportProfile_result
decode_ReportProfile_result iprot bs = to_ReportProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportProfile_result) bs
typemap_ReportProfile_result :: T.TypeMap
typemap_ReportProfile_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportProfile_result :: ReportProfile_result
default_ReportProfile_result = ReportProfile_result{
  reportProfile_result_e = P.Nothing}
data ReportRooms_args = ReportRooms_args  { reportRooms_args_syncOpRevision :: I.Int64
  , reportRooms_args_rooms :: (Vector.Vector Room)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportRooms_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportRooms_args_syncOpRevision record   `H.hashWithSalt` reportRooms_args_rooms record  
instance QC.Arbitrary ReportRooms_args where 
  arbitrary = M.liftM ReportRooms_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportRooms_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportRooms_args{reportRooms_args_syncOpRevision = reportRooms_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportRooms_args{reportRooms_args_syncOpRevision = reportRooms_args_syncOpRevision obj}
    , if obj == default_ReportRooms_args{reportRooms_args_rooms = reportRooms_args_rooms obj} then P.Nothing else P.Just $ default_ReportRooms_args{reportRooms_args_rooms = reportRooms_args_rooms obj}
    ]
from_ReportRooms_args :: ReportRooms_args -> T.ThriftVal
from_ReportRooms_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8459 -> P.Just (2, ("syncOpRevision",T.TI64 _v8459))) $ reportRooms_args_syncOpRevision record
  , (\_v8459 -> P.Just (3, ("rooms",T.TList (T.T_STRUCT typemap_Room) $ P.map (\_v8461 -> from_Room _v8461) $ Vector.toList _v8459))) $ reportRooms_args_rooms record
  ]
write_ReportRooms_args :: T.Protocol p => p -> ReportRooms_args -> P.IO ()
write_ReportRooms_args oprot record = T.writeVal oprot $ from_ReportRooms_args record
encode_ReportRooms_args :: T.StatelessProtocol p => p -> ReportRooms_args -> LBS.ByteString
encode_ReportRooms_args oprot record = T.serializeVal oprot $ from_ReportRooms_args record
to_ReportRooms_args :: T.ThriftVal -> ReportRooms_args
to_ReportRooms_args (T.TStruct fields) = ReportRooms_args{
  reportRooms_args_syncOpRevision = P.maybe (reportRooms_args_syncOpRevision default_ReportRooms_args) (\(_,_val8463) -> (case _val8463 of {T.TI64 _val8464 -> _val8464; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportRooms_args_rooms = P.maybe (reportRooms_args_rooms default_ReportRooms_args) (\(_,_val8463) -> (case _val8463 of {T.TList _ _val8465 -> (Vector.fromList $ P.map (\_v8466 -> (case _v8466 of {T.TStruct _val8467 -> (to_Room (T.TStruct _val8467)); _ -> P.error "wrong type"})) _val8465); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportRooms_args _ = P.error "not a struct"
read_ReportRooms_args :: T.Protocol p => p -> P.IO ReportRooms_args
read_ReportRooms_args iprot = to_ReportRooms_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportRooms_args)
decode_ReportRooms_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportRooms_args
decode_ReportRooms_args iprot bs = to_ReportRooms_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportRooms_args) bs
typemap_ReportRooms_args :: T.TypeMap
typemap_ReportRooms_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("rooms",(T.T_LIST (T.T_STRUCT typemap_Room))))]
default_ReportRooms_args :: ReportRooms_args
default_ReportRooms_args = ReportRooms_args{
  reportRooms_args_syncOpRevision = 0,
  reportRooms_args_rooms = Vector.empty}
data ReportRooms_result = ReportRooms_result  { reportRooms_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportRooms_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportRooms_result_e record  
instance QC.Arbitrary ReportRooms_result where 
  arbitrary = M.liftM ReportRooms_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportRooms_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportRooms_result{reportRooms_result_e = reportRooms_result_e obj} then P.Nothing else P.Just $ default_ReportRooms_result{reportRooms_result_e = reportRooms_result_e obj}
    ]
from_ReportRooms_result :: ReportRooms_result -> T.ThriftVal
from_ReportRooms_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8470 -> (1, ("e",from_TalkException _v8470))) <$> reportRooms_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8470 -> (1, ("e",from_TalkException _v8470))) <$> reportRooms_result_e record
    ]
    )
write_ReportRooms_result :: T.Protocol p => p -> ReportRooms_result -> P.IO ()
write_ReportRooms_result oprot record = T.writeVal oprot $ from_ReportRooms_result record
encode_ReportRooms_result :: T.StatelessProtocol p => p -> ReportRooms_result -> LBS.ByteString
encode_ReportRooms_result oprot record = T.serializeVal oprot $ from_ReportRooms_result record
to_ReportRooms_result :: T.ThriftVal -> ReportRooms_result
to_ReportRooms_result (T.TStruct fields) = ReportRooms_result{
  reportRooms_result_e = P.maybe (P.Nothing) (\(_,_val8472) -> P.Just (case _val8472 of {T.TStruct _val8473 -> (to_TalkException (T.TStruct _val8473)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportRooms_result _ = P.error "not a struct"
read_ReportRooms_result :: T.Protocol p => p -> P.IO ReportRooms_result
read_ReportRooms_result iprot = to_ReportRooms_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportRooms_result)
decode_ReportRooms_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportRooms_result
decode_ReportRooms_result iprot bs = to_ReportRooms_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportRooms_result) bs
typemap_ReportRooms_result :: T.TypeMap
typemap_ReportRooms_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportRooms_result :: ReportRooms_result
default_ReportRooms_result = ReportRooms_result{
  reportRooms_result_e = P.Nothing}
data FindAndAddContactByMetaTag_args = FindAndAddContactByMetaTag_args  { findAndAddContactByMetaTag_args_reqSeq :: I.Int32
  , findAndAddContactByMetaTag_args_userid :: LT.Text
  , findAndAddContactByMetaTag_args_reference :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactByMetaTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactByMetaTag_args_reqSeq record   `H.hashWithSalt` findAndAddContactByMetaTag_args_userid record   `H.hashWithSalt` findAndAddContactByMetaTag_args_reference record  
instance QC.Arbitrary FindAndAddContactByMetaTag_args where 
  arbitrary = M.liftM FindAndAddContactByMetaTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactByMetaTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_reqSeq = findAndAddContactByMetaTag_args_reqSeq obj} then P.Nothing else P.Just $ default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_reqSeq = findAndAddContactByMetaTag_args_reqSeq obj}
    , if obj == default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_userid = findAndAddContactByMetaTag_args_userid obj} then P.Nothing else P.Just $ default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_userid = findAndAddContactByMetaTag_args_userid obj}
    , if obj == default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_reference = findAndAddContactByMetaTag_args_reference obj} then P.Nothing else P.Just $ default_FindAndAddContactByMetaTag_args{findAndAddContactByMetaTag_args_reference = findAndAddContactByMetaTag_args_reference obj}
    ]
from_FindAndAddContactByMetaTag_args :: FindAndAddContactByMetaTag_args -> T.ThriftVal
from_FindAndAddContactByMetaTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8476 -> P.Just (1, ("reqSeq",T.TI32 _v8476))) $ findAndAddContactByMetaTag_args_reqSeq record
  , (\_v8476 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v8476))) $ findAndAddContactByMetaTag_args_userid record
  , (\_v8476 -> P.Just (3, ("reference",T.TString $ E.encodeUtf8 _v8476))) $ findAndAddContactByMetaTag_args_reference record
  ]
write_FindAndAddContactByMetaTag_args :: T.Protocol p => p -> FindAndAddContactByMetaTag_args -> P.IO ()
write_FindAndAddContactByMetaTag_args oprot record = T.writeVal oprot $ from_FindAndAddContactByMetaTag_args record
encode_FindAndAddContactByMetaTag_args :: T.StatelessProtocol p => p -> FindAndAddContactByMetaTag_args -> LBS.ByteString
encode_FindAndAddContactByMetaTag_args oprot record = T.serializeVal oprot $ from_FindAndAddContactByMetaTag_args record
to_FindAndAddContactByMetaTag_args :: T.ThriftVal -> FindAndAddContactByMetaTag_args
to_FindAndAddContactByMetaTag_args (T.TStruct fields) = FindAndAddContactByMetaTag_args{
  findAndAddContactByMetaTag_args_reqSeq = P.maybe (findAndAddContactByMetaTag_args_reqSeq default_FindAndAddContactByMetaTag_args) (\(_,_val8478) -> (case _val8478 of {T.TI32 _val8479 -> _val8479; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findAndAddContactByMetaTag_args_userid = P.maybe (findAndAddContactByMetaTag_args_userid default_FindAndAddContactByMetaTag_args) (\(_,_val8478) -> (case _val8478 of {T.TString _val8480 -> E.decodeUtf8 _val8480; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findAndAddContactByMetaTag_args_reference = P.maybe (findAndAddContactByMetaTag_args_reference default_FindAndAddContactByMetaTag_args) (\(_,_val8478) -> (case _val8478 of {T.TString _val8481 -> E.decodeUtf8 _val8481; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindAndAddContactByMetaTag_args _ = P.error "not a struct"
read_FindAndAddContactByMetaTag_args :: T.Protocol p => p -> P.IO FindAndAddContactByMetaTag_args
read_FindAndAddContactByMetaTag_args iprot = to_FindAndAddContactByMetaTag_args <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactByMetaTag_args)
decode_FindAndAddContactByMetaTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactByMetaTag_args
decode_FindAndAddContactByMetaTag_args iprot bs = to_FindAndAddContactByMetaTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactByMetaTag_args) bs
typemap_FindAndAddContactByMetaTag_args :: T.TypeMap
typemap_FindAndAddContactByMetaTag_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("userid",T.T_STRING)),(3,("reference",T.T_STRING))]
default_FindAndAddContactByMetaTag_args :: FindAndAddContactByMetaTag_args
default_FindAndAddContactByMetaTag_args = FindAndAddContactByMetaTag_args{
  findAndAddContactByMetaTag_args_reqSeq = 0,
  findAndAddContactByMetaTag_args_userid = "",
  findAndAddContactByMetaTag_args_reference = ""}
data FindAndAddContactByMetaTag_result = FindAndAddContactByMetaTag_result  { findAndAddContactByMetaTag_result_success :: Contact
  , findAndAddContactByMetaTag_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindAndAddContactByMetaTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findAndAddContactByMetaTag_result_success record   `H.hashWithSalt` findAndAddContactByMetaTag_result_e record  
instance QC.Arbitrary FindAndAddContactByMetaTag_result where 
  arbitrary = M.liftM FindAndAddContactByMetaTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindAndAddContactByMetaTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_success = findAndAddContactByMetaTag_result_success obj} then P.Nothing else P.Just $ default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_success = findAndAddContactByMetaTag_result_success obj}
    , if obj == default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_e = findAndAddContactByMetaTag_result_e obj} then P.Nothing else P.Just $ default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_e = findAndAddContactByMetaTag_result_e obj}
    ]
from_FindAndAddContactByMetaTag_result :: FindAndAddContactByMetaTag_result -> T.ThriftVal
from_FindAndAddContactByMetaTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8484 -> (1, ("e",from_TalkException _v8484))) <$> findAndAddContactByMetaTag_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8484 -> P.Just (0, ("success",from_Contact _v8484))) $ findAndAddContactByMetaTag_result_success record
    , (\_v8484 -> (1, ("e",from_TalkException _v8484))) <$> findAndAddContactByMetaTag_result_e record
    ]
    )
write_FindAndAddContactByMetaTag_result :: T.Protocol p => p -> FindAndAddContactByMetaTag_result -> P.IO ()
write_FindAndAddContactByMetaTag_result oprot record = T.writeVal oprot $ from_FindAndAddContactByMetaTag_result record
encode_FindAndAddContactByMetaTag_result :: T.StatelessProtocol p => p -> FindAndAddContactByMetaTag_result -> LBS.ByteString
encode_FindAndAddContactByMetaTag_result oprot record = T.serializeVal oprot $ from_FindAndAddContactByMetaTag_result record
to_FindAndAddContactByMetaTag_result :: T.ThriftVal -> FindAndAddContactByMetaTag_result
to_FindAndAddContactByMetaTag_result (T.TStruct fields) = FindAndAddContactByMetaTag_result{
  findAndAddContactByMetaTag_result_success = P.maybe (findAndAddContactByMetaTag_result_success default_FindAndAddContactByMetaTag_result) (\(_,_val8486) -> (case _val8486 of {T.TStruct _val8487 -> (to_Contact (T.TStruct _val8487)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findAndAddContactByMetaTag_result_e = P.maybe (P.Nothing) (\(_,_val8486) -> P.Just (case _val8486 of {T.TStruct _val8488 -> (to_TalkException (T.TStruct _val8488)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindAndAddContactByMetaTag_result _ = P.error "not a struct"
read_FindAndAddContactByMetaTag_result :: T.Protocol p => p -> P.IO FindAndAddContactByMetaTag_result
read_FindAndAddContactByMetaTag_result iprot = to_FindAndAddContactByMetaTag_result <$> T.readVal iprot (T.T_STRUCT typemap_FindAndAddContactByMetaTag_result)
decode_FindAndAddContactByMetaTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindAndAddContactByMetaTag_result
decode_FindAndAddContactByMetaTag_result iprot bs = to_FindAndAddContactByMetaTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindAndAddContactByMetaTag_result) bs
typemap_FindAndAddContactByMetaTag_result :: T.TypeMap
typemap_FindAndAddContactByMetaTag_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindAndAddContactByMetaTag_result :: FindAndAddContactByMetaTag_result
default_FindAndAddContactByMetaTag_result = FindAndAddContactByMetaTag_result{
  findAndAddContactByMetaTag_result_success = default_Contact,
  findAndAddContactByMetaTag_result_e = P.Nothing}
data ReportSettings_args = ReportSettings_args  { reportSettings_args_syncOpRevision :: I.Int64
  , reportSettings_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSettings_args_syncOpRevision record   `H.hashWithSalt` reportSettings_args_settings record  
instance QC.Arbitrary ReportSettings_args where 
  arbitrary = M.liftM ReportSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSettings_args{reportSettings_args_syncOpRevision = reportSettings_args_syncOpRevision obj} then P.Nothing else P.Just $ default_ReportSettings_args{reportSettings_args_syncOpRevision = reportSettings_args_syncOpRevision obj}
    , if obj == default_ReportSettings_args{reportSettings_args_settings = reportSettings_args_settings obj} then P.Nothing else P.Just $ default_ReportSettings_args{reportSettings_args_settings = reportSettings_args_settings obj}
    ]
from_ReportSettings_args :: ReportSettings_args -> T.ThriftVal
from_ReportSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8491 -> P.Just (2, ("syncOpRevision",T.TI64 _v8491))) $ reportSettings_args_syncOpRevision record
  , (\_v8491 -> P.Just (3, ("settings",from_Settings _v8491))) $ reportSettings_args_settings record
  ]
write_ReportSettings_args :: T.Protocol p => p -> ReportSettings_args -> P.IO ()
write_ReportSettings_args oprot record = T.writeVal oprot $ from_ReportSettings_args record
encode_ReportSettings_args :: T.StatelessProtocol p => p -> ReportSettings_args -> LBS.ByteString
encode_ReportSettings_args oprot record = T.serializeVal oprot $ from_ReportSettings_args record
to_ReportSettings_args :: T.ThriftVal -> ReportSettings_args
to_ReportSettings_args (T.TStruct fields) = ReportSettings_args{
  reportSettings_args_syncOpRevision = P.maybe (reportSettings_args_syncOpRevision default_ReportSettings_args) (\(_,_val8493) -> (case _val8493 of {T.TI64 _val8494 -> _val8494; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSettings_args_settings = P.maybe (reportSettings_args_settings default_ReportSettings_args) (\(_,_val8493) -> (case _val8493 of {T.TStruct _val8495 -> (to_Settings (T.TStruct _val8495)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ReportSettings_args _ = P.error "not a struct"
read_ReportSettings_args :: T.Protocol p => p -> P.IO ReportSettings_args
read_ReportSettings_args iprot = to_ReportSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSettings_args)
decode_ReportSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSettings_args
decode_ReportSettings_args iprot bs = to_ReportSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSettings_args) bs
typemap_ReportSettings_args :: T.TypeMap
typemap_ReportSettings_args = Map.fromList [(2,("syncOpRevision",T.T_I64)),(3,("settings",(T.T_STRUCT typemap_Settings)))]
default_ReportSettings_args :: ReportSettings_args
default_ReportSettings_args = ReportSettings_args{
  reportSettings_args_syncOpRevision = 0,
  reportSettings_args_settings = default_Settings}
data ReportSettings_result = ReportSettings_result  { reportSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSettings_result_e record  
instance QC.Arbitrary ReportSettings_result where 
  arbitrary = M.liftM ReportSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSettings_result{reportSettings_result_e = reportSettings_result_e obj} then P.Nothing else P.Just $ default_ReportSettings_result{reportSettings_result_e = reportSettings_result_e obj}
    ]
from_ReportSettings_result :: ReportSettings_result -> T.ThriftVal
from_ReportSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8498 -> (1, ("e",from_TalkException _v8498))) <$> reportSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8498 -> (1, ("e",from_TalkException _v8498))) <$> reportSettings_result_e record
    ]
    )
write_ReportSettings_result :: T.Protocol p => p -> ReportSettings_result -> P.IO ()
write_ReportSettings_result oprot record = T.writeVal oprot $ from_ReportSettings_result record
encode_ReportSettings_result :: T.StatelessProtocol p => p -> ReportSettings_result -> LBS.ByteString
encode_ReportSettings_result oprot record = T.serializeVal oprot $ from_ReportSettings_result record
to_ReportSettings_result :: T.ThriftVal -> ReportSettings_result
to_ReportSettings_result (T.TStruct fields) = ReportSettings_result{
  reportSettings_result_e = P.maybe (P.Nothing) (\(_,_val8500) -> P.Just (case _val8500 of {T.TStruct _val8501 -> (to_TalkException (T.TStruct _val8501)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSettings_result _ = P.error "not a struct"
read_ReportSettings_result :: T.Protocol p => p -> P.IO ReportSettings_result
read_ReportSettings_result iprot = to_ReportSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSettings_result)
decode_ReportSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSettings_result
decode_ReportSettings_result iprot bs = to_ReportSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSettings_result) bs
typemap_ReportSettings_result :: T.TypeMap
typemap_ReportSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportSettings_result :: ReportSettings_result
default_ReportSettings_result = ReportSettings_result{
  reportSettings_result_e = P.Nothing}
data ReportSpam_args = ReportSpam_args  { reportSpam_args_chatMid :: LT.Text
  , reportSpam_args_memberMids :: (Vector.Vector LT.Text)
  , reportSpam_args_spammerReasons :: (Vector.Vector SpammerReason)
  , reportSpam_args_senderMids :: (Vector.Vector LT.Text)
  , reportSpam_args_spamMessageIds :: (Vector.Vector LT.Text)
  , reportSpam_args_spamMessages :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpam_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpam_args_chatMid record   `H.hashWithSalt` reportSpam_args_memberMids record   `H.hashWithSalt` reportSpam_args_spammerReasons record   `H.hashWithSalt` reportSpam_args_senderMids record   `H.hashWithSalt` reportSpam_args_spamMessageIds record   `H.hashWithSalt` reportSpam_args_spamMessages record  
instance QC.Arbitrary ReportSpam_args where 
  arbitrary = M.liftM ReportSpam_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSpam_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpam_args{reportSpam_args_chatMid = reportSpam_args_chatMid obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_chatMid = reportSpam_args_chatMid obj}
    , if obj == default_ReportSpam_args{reportSpam_args_memberMids = reportSpam_args_memberMids obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_memberMids = reportSpam_args_memberMids obj}
    , if obj == default_ReportSpam_args{reportSpam_args_spammerReasons = reportSpam_args_spammerReasons obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_spammerReasons = reportSpam_args_spammerReasons obj}
    , if obj == default_ReportSpam_args{reportSpam_args_senderMids = reportSpam_args_senderMids obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_senderMids = reportSpam_args_senderMids obj}
    , if obj == default_ReportSpam_args{reportSpam_args_spamMessageIds = reportSpam_args_spamMessageIds obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_spamMessageIds = reportSpam_args_spamMessageIds obj}
    , if obj == default_ReportSpam_args{reportSpam_args_spamMessages = reportSpam_args_spamMessages obj} then P.Nothing else P.Just $ default_ReportSpam_args{reportSpam_args_spamMessages = reportSpam_args_spamMessages obj}
    ]
from_ReportSpam_args :: ReportSpam_args -> T.ThriftVal
from_ReportSpam_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8504 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v8504))) $ reportSpam_args_chatMid record
  , (\_v8504 -> P.Just (3, ("memberMids",T.TList T.T_STRING $ P.map (\_v8506 -> T.TString $ E.encodeUtf8 _v8506) $ Vector.toList _v8504))) $ reportSpam_args_memberMids record
  , (\_v8504 -> P.Just (4, ("spammerReasons",T.TList T.T_I32 $ P.map (\_v8508 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v8508) $ Vector.toList _v8504))) $ reportSpam_args_spammerReasons record
  , (\_v8504 -> P.Just (5, ("senderMids",T.TList T.T_STRING $ P.map (\_v8510 -> T.TString $ E.encodeUtf8 _v8510) $ Vector.toList _v8504))) $ reportSpam_args_senderMids record
  , (\_v8504 -> P.Just (6, ("spamMessageIds",T.TList T.T_STRING $ P.map (\_v8512 -> T.TString $ E.encodeUtf8 _v8512) $ Vector.toList _v8504))) $ reportSpam_args_spamMessageIds record
  , (\_v8504 -> P.Just (7, ("spamMessages",T.TList T.T_STRING $ P.map (\_v8514 -> T.TString $ E.encodeUtf8 _v8514) $ Vector.toList _v8504))) $ reportSpam_args_spamMessages record
  ]
write_ReportSpam_args :: T.Protocol p => p -> ReportSpam_args -> P.IO ()
write_ReportSpam_args oprot record = T.writeVal oprot $ from_ReportSpam_args record
encode_ReportSpam_args :: T.StatelessProtocol p => p -> ReportSpam_args -> LBS.ByteString
encode_ReportSpam_args oprot record = T.serializeVal oprot $ from_ReportSpam_args record
to_ReportSpam_args :: T.ThriftVal -> ReportSpam_args
to_ReportSpam_args (T.TStruct fields) = ReportSpam_args{
  reportSpam_args_chatMid = P.maybe (reportSpam_args_chatMid default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TString _val8517 -> E.decodeUtf8 _val8517; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSpam_args_memberMids = P.maybe (reportSpam_args_memberMids default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TList _ _val8518 -> (Vector.fromList $ P.map (\_v8519 -> (case _v8519 of {T.TString _val8520 -> E.decodeUtf8 _val8520; _ -> P.error "wrong type"})) _val8518); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSpam_args_spammerReasons = P.maybe (reportSpam_args_spammerReasons default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TList _ _val8521 -> (Vector.fromList $ P.map (\_v8522 -> (case _v8522 of {T.TI32 _val8523 -> P.toEnum $ P.fromIntegral _val8523; _ -> P.error "wrong type"})) _val8521); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  reportSpam_args_senderMids = P.maybe (reportSpam_args_senderMids default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TList _ _val8524 -> (Vector.fromList $ P.map (\_v8525 -> (case _v8525 of {T.TString _val8526 -> E.decodeUtf8 _val8526; _ -> P.error "wrong type"})) _val8524); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  reportSpam_args_spamMessageIds = P.maybe (reportSpam_args_spamMessageIds default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TList _ _val8527 -> (Vector.fromList $ P.map (\_v8528 -> (case _v8528 of {T.TString _val8529 -> E.decodeUtf8 _val8529; _ -> P.error "wrong type"})) _val8527); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  reportSpam_args_spamMessages = P.maybe (reportSpam_args_spamMessages default_ReportSpam_args) (\(_,_val8516) -> (case _val8516 of {T.TList _ _val8530 -> (Vector.fromList $ P.map (\_v8531 -> (case _v8531 of {T.TString _val8532 -> E.decodeUtf8 _val8532; _ -> P.error "wrong type"})) _val8530); _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_ReportSpam_args _ = P.error "not a struct"
read_ReportSpam_args :: T.Protocol p => p -> P.IO ReportSpam_args
read_ReportSpam_args iprot = to_ReportSpam_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpam_args)
decode_ReportSpam_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpam_args
decode_ReportSpam_args iprot bs = to_ReportSpam_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpam_args) bs
typemap_ReportSpam_args :: T.TypeMap
typemap_ReportSpam_args = Map.fromList [(2,("chatMid",T.T_STRING)),(3,("memberMids",(T.T_LIST T.T_STRING))),(4,("spammerReasons",(T.T_LIST T.T_I32))),(5,("senderMids",(T.T_LIST T.T_STRING))),(6,("spamMessageIds",(T.T_LIST T.T_STRING))),(7,("spamMessages",(T.T_LIST T.T_STRING)))]
default_ReportSpam_args :: ReportSpam_args
default_ReportSpam_args = ReportSpam_args{
  reportSpam_args_chatMid = "",
  reportSpam_args_memberMids = Vector.empty,
  reportSpam_args_spammerReasons = Vector.empty,
  reportSpam_args_senderMids = Vector.empty,
  reportSpam_args_spamMessageIds = Vector.empty,
  reportSpam_args_spamMessages = Vector.empty}
data ReportSpam_result = ReportSpam_result  { reportSpam_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpam_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpam_result_e record  
instance QC.Arbitrary ReportSpam_result where 
  arbitrary = M.liftM ReportSpam_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSpam_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpam_result{reportSpam_result_e = reportSpam_result_e obj} then P.Nothing else P.Just $ default_ReportSpam_result{reportSpam_result_e = reportSpam_result_e obj}
    ]
from_ReportSpam_result :: ReportSpam_result -> T.ThriftVal
from_ReportSpam_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8535 -> (1, ("e",from_TalkException _v8535))) <$> reportSpam_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8535 -> (1, ("e",from_TalkException _v8535))) <$> reportSpam_result_e record
    ]
    )
write_ReportSpam_result :: T.Protocol p => p -> ReportSpam_result -> P.IO ()
write_ReportSpam_result oprot record = T.writeVal oprot $ from_ReportSpam_result record
encode_ReportSpam_result :: T.StatelessProtocol p => p -> ReportSpam_result -> LBS.ByteString
encode_ReportSpam_result oprot record = T.serializeVal oprot $ from_ReportSpam_result record
to_ReportSpam_result :: T.ThriftVal -> ReportSpam_result
to_ReportSpam_result (T.TStruct fields) = ReportSpam_result{
  reportSpam_result_e = P.maybe (P.Nothing) (\(_,_val8537) -> P.Just (case _val8537 of {T.TStruct _val8538 -> (to_TalkException (T.TStruct _val8538)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSpam_result _ = P.error "not a struct"
read_ReportSpam_result :: T.Protocol p => p -> P.IO ReportSpam_result
read_ReportSpam_result iprot = to_ReportSpam_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpam_result)
decode_ReportSpam_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpam_result
decode_ReportSpam_result iprot bs = to_ReportSpam_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpam_result) bs
typemap_ReportSpam_result :: T.TypeMap
typemap_ReportSpam_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportSpam_result :: ReportSpam_result
default_ReportSpam_result = ReportSpam_result{
  reportSpam_result_e = P.Nothing}
data ReportSpammer_args = ReportSpammer_args  { reportSpammer_args_spammerMid :: LT.Text
  , reportSpammer_args_spammerReasons :: (Vector.Vector SpammerReason)
  , reportSpammer_args_spamMessageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpammer_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpammer_args_spammerMid record   `H.hashWithSalt` reportSpammer_args_spammerReasons record   `H.hashWithSalt` reportSpammer_args_spamMessageIds record  
instance QC.Arbitrary ReportSpammer_args where 
  arbitrary = M.liftM ReportSpammer_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ReportSpammer_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpammer_args{reportSpammer_args_spammerMid = reportSpammer_args_spammerMid obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spammerMid = reportSpammer_args_spammerMid obj}
    , if obj == default_ReportSpammer_args{reportSpammer_args_spammerReasons = reportSpammer_args_spammerReasons obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spammerReasons = reportSpammer_args_spammerReasons obj}
    , if obj == default_ReportSpammer_args{reportSpammer_args_spamMessageIds = reportSpammer_args_spamMessageIds obj} then P.Nothing else P.Just $ default_ReportSpammer_args{reportSpammer_args_spamMessageIds = reportSpammer_args_spamMessageIds obj}
    ]
from_ReportSpammer_args :: ReportSpammer_args -> T.ThriftVal
from_ReportSpammer_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8541 -> P.Just (2, ("spammerMid",T.TString $ E.encodeUtf8 _v8541))) $ reportSpammer_args_spammerMid record
  , (\_v8541 -> P.Just (3, ("spammerReasons",T.TList T.T_I32 $ P.map (\_v8543 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v8543) $ Vector.toList _v8541))) $ reportSpammer_args_spammerReasons record
  , (\_v8541 -> P.Just (4, ("spamMessageIds",T.TList T.T_STRING $ P.map (\_v8545 -> T.TString $ E.encodeUtf8 _v8545) $ Vector.toList _v8541))) $ reportSpammer_args_spamMessageIds record
  ]
write_ReportSpammer_args :: T.Protocol p => p -> ReportSpammer_args -> P.IO ()
write_ReportSpammer_args oprot record = T.writeVal oprot $ from_ReportSpammer_args record
encode_ReportSpammer_args :: T.StatelessProtocol p => p -> ReportSpammer_args -> LBS.ByteString
encode_ReportSpammer_args oprot record = T.serializeVal oprot $ from_ReportSpammer_args record
to_ReportSpammer_args :: T.ThriftVal -> ReportSpammer_args
to_ReportSpammer_args (T.TStruct fields) = ReportSpammer_args{
  reportSpammer_args_spammerMid = P.maybe (reportSpammer_args_spammerMid default_ReportSpammer_args) (\(_,_val8547) -> (case _val8547 of {T.TString _val8548 -> E.decodeUtf8 _val8548; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  reportSpammer_args_spammerReasons = P.maybe (reportSpammer_args_spammerReasons default_ReportSpammer_args) (\(_,_val8547) -> (case _val8547 of {T.TList _ _val8549 -> (Vector.fromList $ P.map (\_v8550 -> (case _v8550 of {T.TI32 _val8551 -> P.toEnum $ P.fromIntegral _val8551; _ -> P.error "wrong type"})) _val8549); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  reportSpammer_args_spamMessageIds = P.maybe (reportSpammer_args_spamMessageIds default_ReportSpammer_args) (\(_,_val8547) -> (case _val8547 of {T.TList _ _val8552 -> (Vector.fromList $ P.map (\_v8553 -> (case _v8553 of {T.TString _val8554 -> E.decodeUtf8 _val8554; _ -> P.error "wrong type"})) _val8552); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ReportSpammer_args _ = P.error "not a struct"
read_ReportSpammer_args :: T.Protocol p => p -> P.IO ReportSpammer_args
read_ReportSpammer_args iprot = to_ReportSpammer_args <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpammer_args)
decode_ReportSpammer_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpammer_args
decode_ReportSpammer_args iprot bs = to_ReportSpammer_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpammer_args) bs
typemap_ReportSpammer_args :: T.TypeMap
typemap_ReportSpammer_args = Map.fromList [(2,("spammerMid",T.T_STRING)),(3,("spammerReasons",(T.T_LIST T.T_I32))),(4,("spamMessageIds",(T.T_LIST T.T_STRING)))]
default_ReportSpammer_args :: ReportSpammer_args
default_ReportSpammer_args = ReportSpammer_args{
  reportSpammer_args_spammerMid = "",
  reportSpammer_args_spammerReasons = Vector.empty,
  reportSpammer_args_spamMessageIds = Vector.empty}
data ReportSpammer_result = ReportSpammer_result  { reportSpammer_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReportSpammer_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reportSpammer_result_e record  
instance QC.Arbitrary ReportSpammer_result where 
  arbitrary = M.liftM ReportSpammer_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReportSpammer_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReportSpammer_result{reportSpammer_result_e = reportSpammer_result_e obj} then P.Nothing else P.Just $ default_ReportSpammer_result{reportSpammer_result_e = reportSpammer_result_e obj}
    ]
from_ReportSpammer_result :: ReportSpammer_result -> T.ThriftVal
from_ReportSpammer_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8557 -> (1, ("e",from_TalkException _v8557))) <$> reportSpammer_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8557 -> (1, ("e",from_TalkException _v8557))) <$> reportSpammer_result_e record
    ]
    )
write_ReportSpammer_result :: T.Protocol p => p -> ReportSpammer_result -> P.IO ()
write_ReportSpammer_result oprot record = T.writeVal oprot $ from_ReportSpammer_result record
encode_ReportSpammer_result :: T.StatelessProtocol p => p -> ReportSpammer_result -> LBS.ByteString
encode_ReportSpammer_result oprot record = T.serializeVal oprot $ from_ReportSpammer_result record
to_ReportSpammer_result :: T.ThriftVal -> ReportSpammer_result
to_ReportSpammer_result (T.TStruct fields) = ReportSpammer_result{
  reportSpammer_result_e = P.maybe (P.Nothing) (\(_,_val8559) -> P.Just (case _val8559 of {T.TStruct _val8560 -> (to_TalkException (T.TStruct _val8560)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReportSpammer_result _ = P.error "not a struct"
read_ReportSpammer_result :: T.Protocol p => p -> P.IO ReportSpammer_result
read_ReportSpammer_result iprot = to_ReportSpammer_result <$> T.readVal iprot (T.T_STRUCT typemap_ReportSpammer_result)
decode_ReportSpammer_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReportSpammer_result
decode_ReportSpammer_result iprot bs = to_ReportSpammer_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReportSpammer_result) bs
typemap_ReportSpammer_result :: T.TypeMap
typemap_ReportSpammer_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReportSpammer_result :: ReportSpammer_result
default_ReportSpammer_result = ReportSpammer_result{
  reportSpammer_result_e = P.Nothing}
data RequestAccountPasswordReset_args = RequestAccountPasswordReset_args  { requestAccountPasswordReset_args_provider :: IdentityProvider
  , requestAccountPasswordReset_args_identifier :: LT.Text
  , requestAccountPasswordReset_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestAccountPasswordReset_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestAccountPasswordReset_args_provider record   `H.hashWithSalt` requestAccountPasswordReset_args_identifier record   `H.hashWithSalt` requestAccountPasswordReset_args_locale record  
instance QC.Arbitrary RequestAccountPasswordReset_args where 
  arbitrary = M.liftM RequestAccountPasswordReset_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestAccountPasswordReset_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_provider = requestAccountPasswordReset_args_provider obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_provider = requestAccountPasswordReset_args_provider obj}
    , if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_identifier = requestAccountPasswordReset_args_identifier obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_identifier = requestAccountPasswordReset_args_identifier obj}
    , if obj == default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_locale = requestAccountPasswordReset_args_locale obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_args{requestAccountPasswordReset_args_locale = requestAccountPasswordReset_args_locale obj}
    ]
from_RequestAccountPasswordReset_args :: RequestAccountPasswordReset_args -> T.ThriftVal
from_RequestAccountPasswordReset_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8563 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v8563))) $ requestAccountPasswordReset_args_identifier record
  , (\_v8563 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v8563))) $ requestAccountPasswordReset_args_provider record
  , (\_v8563 -> P.Just (5, ("locale",T.TString $ E.encodeUtf8 _v8563))) $ requestAccountPasswordReset_args_locale record
  ]
write_RequestAccountPasswordReset_args :: T.Protocol p => p -> RequestAccountPasswordReset_args -> P.IO ()
write_RequestAccountPasswordReset_args oprot record = T.writeVal oprot $ from_RequestAccountPasswordReset_args record
encode_RequestAccountPasswordReset_args :: T.StatelessProtocol p => p -> RequestAccountPasswordReset_args -> LBS.ByteString
encode_RequestAccountPasswordReset_args oprot record = T.serializeVal oprot $ from_RequestAccountPasswordReset_args record
to_RequestAccountPasswordReset_args :: T.ThriftVal -> RequestAccountPasswordReset_args
to_RequestAccountPasswordReset_args (T.TStruct fields) = RequestAccountPasswordReset_args{
  requestAccountPasswordReset_args_provider = P.maybe (requestAccountPasswordReset_args_provider default_RequestAccountPasswordReset_args) (\(_,_val8565) -> (case _val8565 of {T.TI32 _val8566 -> P.toEnum $ P.fromIntegral _val8566; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  requestAccountPasswordReset_args_identifier = P.maybe (requestAccountPasswordReset_args_identifier default_RequestAccountPasswordReset_args) (\(_,_val8565) -> (case _val8565 of {T.TString _val8567 -> E.decodeUtf8 _val8567; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestAccountPasswordReset_args_locale = P.maybe (requestAccountPasswordReset_args_locale default_RequestAccountPasswordReset_args) (\(_,_val8565) -> (case _val8565 of {T.TString _val8568 -> E.decodeUtf8 _val8568; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RequestAccountPasswordReset_args _ = P.error "not a struct"
read_RequestAccountPasswordReset_args :: T.Protocol p => p -> P.IO RequestAccountPasswordReset_args
read_RequestAccountPasswordReset_args iprot = to_RequestAccountPasswordReset_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_args)
decode_RequestAccountPasswordReset_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestAccountPasswordReset_args
decode_RequestAccountPasswordReset_args iprot bs = to_RequestAccountPasswordReset_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_args) bs
typemap_RequestAccountPasswordReset_args :: T.TypeMap
typemap_RequestAccountPasswordReset_args = Map.fromList [(2,("identifier",T.T_STRING)),(4,("provider",T.T_I32)),(5,("locale",T.T_STRING))]
default_RequestAccountPasswordReset_args :: RequestAccountPasswordReset_args
default_RequestAccountPasswordReset_args = RequestAccountPasswordReset_args{
  requestAccountPasswordReset_args_identifier = "",
  requestAccountPasswordReset_args_provider = (P.toEnum 0),
  requestAccountPasswordReset_args_locale = ""}
data RequestAccountPasswordReset_result = RequestAccountPasswordReset_result  { requestAccountPasswordReset_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestAccountPasswordReset_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestAccountPasswordReset_result_e record  
instance QC.Arbitrary RequestAccountPasswordReset_result where 
  arbitrary = M.liftM RequestAccountPasswordReset_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestAccountPasswordReset_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = requestAccountPasswordReset_result_e obj} then P.Nothing else P.Just $ default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = requestAccountPasswordReset_result_e obj}
    ]
from_RequestAccountPasswordReset_result :: RequestAccountPasswordReset_result -> T.ThriftVal
from_RequestAccountPasswordReset_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8571 -> (1, ("e",from_TalkException _v8571))) <$> requestAccountPasswordReset_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8571 -> (1, ("e",from_TalkException _v8571))) <$> requestAccountPasswordReset_result_e record
    ]
    )
write_RequestAccountPasswordReset_result :: T.Protocol p => p -> RequestAccountPasswordReset_result -> P.IO ()
write_RequestAccountPasswordReset_result oprot record = T.writeVal oprot $ from_RequestAccountPasswordReset_result record
encode_RequestAccountPasswordReset_result :: T.StatelessProtocol p => p -> RequestAccountPasswordReset_result -> LBS.ByteString
encode_RequestAccountPasswordReset_result oprot record = T.serializeVal oprot $ from_RequestAccountPasswordReset_result record
to_RequestAccountPasswordReset_result :: T.ThriftVal -> RequestAccountPasswordReset_result
to_RequestAccountPasswordReset_result (T.TStruct fields) = RequestAccountPasswordReset_result{
  requestAccountPasswordReset_result_e = P.maybe (P.Nothing) (\(_,_val8573) -> P.Just (case _val8573 of {T.TStruct _val8574 -> (to_TalkException (T.TStruct _val8574)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestAccountPasswordReset_result _ = P.error "not a struct"
read_RequestAccountPasswordReset_result :: T.Protocol p => p -> P.IO RequestAccountPasswordReset_result
read_RequestAccountPasswordReset_result iprot = to_RequestAccountPasswordReset_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_result)
decode_RequestAccountPasswordReset_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestAccountPasswordReset_result
decode_RequestAccountPasswordReset_result iprot bs = to_RequestAccountPasswordReset_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestAccountPasswordReset_result) bs
typemap_RequestAccountPasswordReset_result :: T.TypeMap
typemap_RequestAccountPasswordReset_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestAccountPasswordReset_result :: RequestAccountPasswordReset_result
default_RequestAccountPasswordReset_result = RequestAccountPasswordReset_result{
  requestAccountPasswordReset_result_e = P.Nothing}
data RequestEmailConfirmation_args = RequestEmailConfirmation_args  { requestEmailConfirmation_args_emailConfirmation :: EmailConfirmation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestEmailConfirmation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestEmailConfirmation_args_emailConfirmation record  
instance QC.Arbitrary RequestEmailConfirmation_args where 
  arbitrary = M.liftM RequestEmailConfirmation_args (QC.arbitrary)
  shrink obj | obj == default_RequestEmailConfirmation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestEmailConfirmation_args{requestEmailConfirmation_args_emailConfirmation = requestEmailConfirmation_args_emailConfirmation obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_args{requestEmailConfirmation_args_emailConfirmation = requestEmailConfirmation_args_emailConfirmation obj}
    ]
from_RequestEmailConfirmation_args :: RequestEmailConfirmation_args -> T.ThriftVal
from_RequestEmailConfirmation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8577 -> P.Just (2, ("emailConfirmation",from_EmailConfirmation _v8577))) $ requestEmailConfirmation_args_emailConfirmation record
  ]
write_RequestEmailConfirmation_args :: T.Protocol p => p -> RequestEmailConfirmation_args -> P.IO ()
write_RequestEmailConfirmation_args oprot record = T.writeVal oprot $ from_RequestEmailConfirmation_args record
encode_RequestEmailConfirmation_args :: T.StatelessProtocol p => p -> RequestEmailConfirmation_args -> LBS.ByteString
encode_RequestEmailConfirmation_args oprot record = T.serializeVal oprot $ from_RequestEmailConfirmation_args record
to_RequestEmailConfirmation_args :: T.ThriftVal -> RequestEmailConfirmation_args
to_RequestEmailConfirmation_args (T.TStruct fields) = RequestEmailConfirmation_args{
  requestEmailConfirmation_args_emailConfirmation = P.maybe (requestEmailConfirmation_args_emailConfirmation default_RequestEmailConfirmation_args) (\(_,_val8579) -> (case _val8579 of {T.TStruct _val8580 -> (to_EmailConfirmation (T.TStruct _val8580)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestEmailConfirmation_args _ = P.error "not a struct"
read_RequestEmailConfirmation_args :: T.Protocol p => p -> P.IO RequestEmailConfirmation_args
read_RequestEmailConfirmation_args iprot = to_RequestEmailConfirmation_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_args)
decode_RequestEmailConfirmation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestEmailConfirmation_args
decode_RequestEmailConfirmation_args iprot bs = to_RequestEmailConfirmation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_args) bs
typemap_RequestEmailConfirmation_args :: T.TypeMap
typemap_RequestEmailConfirmation_args = Map.fromList [(2,("emailConfirmation",(T.T_STRUCT typemap_EmailConfirmation)))]
default_RequestEmailConfirmation_args :: RequestEmailConfirmation_args
default_RequestEmailConfirmation_args = RequestEmailConfirmation_args{
  requestEmailConfirmation_args_emailConfirmation = default_EmailConfirmation}
data RequestEmailConfirmation_result = RequestEmailConfirmation_result  { requestEmailConfirmation_result_success :: EmailConfirmationSession
  , requestEmailConfirmation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestEmailConfirmation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestEmailConfirmation_result_success record   `H.hashWithSalt` requestEmailConfirmation_result_e record  
instance QC.Arbitrary RequestEmailConfirmation_result where 
  arbitrary = M.liftM RequestEmailConfirmation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestEmailConfirmation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = requestEmailConfirmation_result_success obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = requestEmailConfirmation_result_success obj}
    , if obj == default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = requestEmailConfirmation_result_e obj} then P.Nothing else P.Just $ default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = requestEmailConfirmation_result_e obj}
    ]
from_RequestEmailConfirmation_result :: RequestEmailConfirmation_result -> T.ThriftVal
from_RequestEmailConfirmation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8583 -> (1, ("e",from_TalkException _v8583))) <$> requestEmailConfirmation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8583 -> P.Just (0, ("success",from_EmailConfirmationSession _v8583))) $ requestEmailConfirmation_result_success record
    , (\_v8583 -> (1, ("e",from_TalkException _v8583))) <$> requestEmailConfirmation_result_e record
    ]
    )
write_RequestEmailConfirmation_result :: T.Protocol p => p -> RequestEmailConfirmation_result -> P.IO ()
write_RequestEmailConfirmation_result oprot record = T.writeVal oprot $ from_RequestEmailConfirmation_result record
encode_RequestEmailConfirmation_result :: T.StatelessProtocol p => p -> RequestEmailConfirmation_result -> LBS.ByteString
encode_RequestEmailConfirmation_result oprot record = T.serializeVal oprot $ from_RequestEmailConfirmation_result record
to_RequestEmailConfirmation_result :: T.ThriftVal -> RequestEmailConfirmation_result
to_RequestEmailConfirmation_result (T.TStruct fields) = RequestEmailConfirmation_result{
  requestEmailConfirmation_result_success = P.maybe (requestEmailConfirmation_result_success default_RequestEmailConfirmation_result) (\(_,_val8585) -> (case _val8585 of {T.TStruct _val8586 -> (to_EmailConfirmationSession (T.TStruct _val8586)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  requestEmailConfirmation_result_e = P.maybe (P.Nothing) (\(_,_val8585) -> P.Just (case _val8585 of {T.TStruct _val8587 -> (to_TalkException (T.TStruct _val8587)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestEmailConfirmation_result _ = P.error "not a struct"
read_RequestEmailConfirmation_result :: T.Protocol p => p -> P.IO RequestEmailConfirmation_result
read_RequestEmailConfirmation_result iprot = to_RequestEmailConfirmation_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_result)
decode_RequestEmailConfirmation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestEmailConfirmation_result
decode_RequestEmailConfirmation_result iprot bs = to_RequestEmailConfirmation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestEmailConfirmation_result) bs
typemap_RequestEmailConfirmation_result :: T.TypeMap
typemap_RequestEmailConfirmation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_EmailConfirmationSession))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestEmailConfirmation_result :: RequestEmailConfirmation_result
default_RequestEmailConfirmation_result = RequestEmailConfirmation_result{
  requestEmailConfirmation_result_success = default_EmailConfirmationSession,
  requestEmailConfirmation_result_e = P.Nothing}
data RequestIdentityUnbind_args = RequestIdentityUnbind_args  { requestIdentityUnbind_args_provider :: IdentityProvider
  , requestIdentityUnbind_args_identifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestIdentityUnbind_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestIdentityUnbind_args_provider record   `H.hashWithSalt` requestIdentityUnbind_args_identifier record  
instance QC.Arbitrary RequestIdentityUnbind_args where 
  arbitrary = M.liftM RequestIdentityUnbind_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestIdentityUnbind_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestIdentityUnbind_args{requestIdentityUnbind_args_provider = requestIdentityUnbind_args_provider obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_args{requestIdentityUnbind_args_provider = requestIdentityUnbind_args_provider obj}
    , if obj == default_RequestIdentityUnbind_args{requestIdentityUnbind_args_identifier = requestIdentityUnbind_args_identifier obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_args{requestIdentityUnbind_args_identifier = requestIdentityUnbind_args_identifier obj}
    ]
from_RequestIdentityUnbind_args :: RequestIdentityUnbind_args -> T.ThriftVal
from_RequestIdentityUnbind_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8590 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v8590))) $ requestIdentityUnbind_args_identifier record
  , (\_v8590 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v8590))) $ requestIdentityUnbind_args_provider record
  ]
write_RequestIdentityUnbind_args :: T.Protocol p => p -> RequestIdentityUnbind_args -> P.IO ()
write_RequestIdentityUnbind_args oprot record = T.writeVal oprot $ from_RequestIdentityUnbind_args record
encode_RequestIdentityUnbind_args :: T.StatelessProtocol p => p -> RequestIdentityUnbind_args -> LBS.ByteString
encode_RequestIdentityUnbind_args oprot record = T.serializeVal oprot $ from_RequestIdentityUnbind_args record
to_RequestIdentityUnbind_args :: T.ThriftVal -> RequestIdentityUnbind_args
to_RequestIdentityUnbind_args (T.TStruct fields) = RequestIdentityUnbind_args{
  requestIdentityUnbind_args_provider = P.maybe (requestIdentityUnbind_args_provider default_RequestIdentityUnbind_args) (\(_,_val8592) -> (case _val8592 of {T.TI32 _val8593 -> P.toEnum $ P.fromIntegral _val8593; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  requestIdentityUnbind_args_identifier = P.maybe (requestIdentityUnbind_args_identifier default_RequestIdentityUnbind_args) (\(_,_val8592) -> (case _val8592 of {T.TString _val8594 -> E.decodeUtf8 _val8594; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RequestIdentityUnbind_args _ = P.error "not a struct"
read_RequestIdentityUnbind_args :: T.Protocol p => p -> P.IO RequestIdentityUnbind_args
read_RequestIdentityUnbind_args iprot = to_RequestIdentityUnbind_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_args)
decode_RequestIdentityUnbind_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestIdentityUnbind_args
decode_RequestIdentityUnbind_args iprot bs = to_RequestIdentityUnbind_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_args) bs
typemap_RequestIdentityUnbind_args :: T.TypeMap
typemap_RequestIdentityUnbind_args = Map.fromList [(2,("identifier",T.T_STRING)),(4,("provider",T.T_I32))]
default_RequestIdentityUnbind_args :: RequestIdentityUnbind_args
default_RequestIdentityUnbind_args = RequestIdentityUnbind_args{
  requestIdentityUnbind_args_identifier = "",
  requestIdentityUnbind_args_provider = (P.toEnum 0)}
data RequestIdentityUnbind_result = RequestIdentityUnbind_result  { requestIdentityUnbind_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestIdentityUnbind_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestIdentityUnbind_result_e record  
instance QC.Arbitrary RequestIdentityUnbind_result where 
  arbitrary = M.liftM RequestIdentityUnbind_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestIdentityUnbind_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = requestIdentityUnbind_result_e obj} then P.Nothing else P.Just $ default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = requestIdentityUnbind_result_e obj}
    ]
from_RequestIdentityUnbind_result :: RequestIdentityUnbind_result -> T.ThriftVal
from_RequestIdentityUnbind_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8597 -> (1, ("e",from_TalkException _v8597))) <$> requestIdentityUnbind_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8597 -> (1, ("e",from_TalkException _v8597))) <$> requestIdentityUnbind_result_e record
    ]
    )
write_RequestIdentityUnbind_result :: T.Protocol p => p -> RequestIdentityUnbind_result -> P.IO ()
write_RequestIdentityUnbind_result oprot record = T.writeVal oprot $ from_RequestIdentityUnbind_result record
encode_RequestIdentityUnbind_result :: T.StatelessProtocol p => p -> RequestIdentityUnbind_result -> LBS.ByteString
encode_RequestIdentityUnbind_result oprot record = T.serializeVal oprot $ from_RequestIdentityUnbind_result record
to_RequestIdentityUnbind_result :: T.ThriftVal -> RequestIdentityUnbind_result
to_RequestIdentityUnbind_result (T.TStruct fields) = RequestIdentityUnbind_result{
  requestIdentityUnbind_result_e = P.maybe (P.Nothing) (\(_,_val8599) -> P.Just (case _val8599 of {T.TStruct _val8600 -> (to_TalkException (T.TStruct _val8600)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestIdentityUnbind_result _ = P.error "not a struct"
read_RequestIdentityUnbind_result :: T.Protocol p => p -> P.IO RequestIdentityUnbind_result
read_RequestIdentityUnbind_result iprot = to_RequestIdentityUnbind_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_result)
decode_RequestIdentityUnbind_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestIdentityUnbind_result
decode_RequestIdentityUnbind_result iprot bs = to_RequestIdentityUnbind_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestIdentityUnbind_result) bs
typemap_RequestIdentityUnbind_result :: T.TypeMap
typemap_RequestIdentityUnbind_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestIdentityUnbind_result :: RequestIdentityUnbind_result
default_RequestIdentityUnbind_result = RequestIdentityUnbind_result{
  requestIdentityUnbind_result_e = P.Nothing}
data ResendEmailConfirmation_args = ResendEmailConfirmation_args  { resendEmailConfirmation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendEmailConfirmation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendEmailConfirmation_args_verifier record  
instance QC.Arbitrary ResendEmailConfirmation_args where 
  arbitrary = M.liftM ResendEmailConfirmation_args (QC.arbitrary)
  shrink obj | obj == default_ResendEmailConfirmation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendEmailConfirmation_args{resendEmailConfirmation_args_verifier = resendEmailConfirmation_args_verifier obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_args{resendEmailConfirmation_args_verifier = resendEmailConfirmation_args_verifier obj}
    ]
from_ResendEmailConfirmation_args :: ResendEmailConfirmation_args -> T.ThriftVal
from_ResendEmailConfirmation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8603 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v8603))) $ resendEmailConfirmation_args_verifier record
  ]
write_ResendEmailConfirmation_args :: T.Protocol p => p -> ResendEmailConfirmation_args -> P.IO ()
write_ResendEmailConfirmation_args oprot record = T.writeVal oprot $ from_ResendEmailConfirmation_args record
encode_ResendEmailConfirmation_args :: T.StatelessProtocol p => p -> ResendEmailConfirmation_args -> LBS.ByteString
encode_ResendEmailConfirmation_args oprot record = T.serializeVal oprot $ from_ResendEmailConfirmation_args record
to_ResendEmailConfirmation_args :: T.ThriftVal -> ResendEmailConfirmation_args
to_ResendEmailConfirmation_args (T.TStruct fields) = ResendEmailConfirmation_args{
  resendEmailConfirmation_args_verifier = P.maybe (resendEmailConfirmation_args_verifier default_ResendEmailConfirmation_args) (\(_,_val8605) -> (case _val8605 of {T.TString _val8606 -> E.decodeUtf8 _val8606; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendEmailConfirmation_args _ = P.error "not a struct"
read_ResendEmailConfirmation_args :: T.Protocol p => p -> P.IO ResendEmailConfirmation_args
read_ResendEmailConfirmation_args iprot = to_ResendEmailConfirmation_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_args)
decode_ResendEmailConfirmation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendEmailConfirmation_args
decode_ResendEmailConfirmation_args iprot bs = to_ResendEmailConfirmation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_args) bs
typemap_ResendEmailConfirmation_args :: T.TypeMap
typemap_ResendEmailConfirmation_args = Map.fromList [(2,("verifier",T.T_STRING))]
default_ResendEmailConfirmation_args :: ResendEmailConfirmation_args
default_ResendEmailConfirmation_args = ResendEmailConfirmation_args{
  resendEmailConfirmation_args_verifier = ""}
data ResendEmailConfirmation_result = ResendEmailConfirmation_result  { resendEmailConfirmation_result_success :: EmailConfirmationSession
  , resendEmailConfirmation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendEmailConfirmation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendEmailConfirmation_result_success record   `H.hashWithSalt` resendEmailConfirmation_result_e record  
instance QC.Arbitrary ResendEmailConfirmation_result where 
  arbitrary = M.liftM ResendEmailConfirmation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendEmailConfirmation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = resendEmailConfirmation_result_success obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = resendEmailConfirmation_result_success obj}
    , if obj == default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = resendEmailConfirmation_result_e obj} then P.Nothing else P.Just $ default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = resendEmailConfirmation_result_e obj}
    ]
from_ResendEmailConfirmation_result :: ResendEmailConfirmation_result -> T.ThriftVal
from_ResendEmailConfirmation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8609 -> (1, ("e",from_TalkException _v8609))) <$> resendEmailConfirmation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8609 -> P.Just (0, ("success",from_EmailConfirmationSession _v8609))) $ resendEmailConfirmation_result_success record
    , (\_v8609 -> (1, ("e",from_TalkException _v8609))) <$> resendEmailConfirmation_result_e record
    ]
    )
write_ResendEmailConfirmation_result :: T.Protocol p => p -> ResendEmailConfirmation_result -> P.IO ()
write_ResendEmailConfirmation_result oprot record = T.writeVal oprot $ from_ResendEmailConfirmation_result record
encode_ResendEmailConfirmation_result :: T.StatelessProtocol p => p -> ResendEmailConfirmation_result -> LBS.ByteString
encode_ResendEmailConfirmation_result oprot record = T.serializeVal oprot $ from_ResendEmailConfirmation_result record
to_ResendEmailConfirmation_result :: T.ThriftVal -> ResendEmailConfirmation_result
to_ResendEmailConfirmation_result (T.TStruct fields) = ResendEmailConfirmation_result{
  resendEmailConfirmation_result_success = P.maybe (resendEmailConfirmation_result_success default_ResendEmailConfirmation_result) (\(_,_val8611) -> (case _val8611 of {T.TStruct _val8612 -> (to_EmailConfirmationSession (T.TStruct _val8612)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  resendEmailConfirmation_result_e = P.maybe (P.Nothing) (\(_,_val8611) -> P.Just (case _val8611 of {T.TStruct _val8613 -> (to_TalkException (T.TStruct _val8613)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendEmailConfirmation_result _ = P.error "not a struct"
read_ResendEmailConfirmation_result :: T.Protocol p => p -> P.IO ResendEmailConfirmation_result
read_ResendEmailConfirmation_result iprot = to_ResendEmailConfirmation_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_result)
decode_ResendEmailConfirmation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendEmailConfirmation_result
decode_ResendEmailConfirmation_result iprot bs = to_ResendEmailConfirmation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendEmailConfirmation_result) bs
typemap_ResendEmailConfirmation_result :: T.TypeMap
typemap_ResendEmailConfirmation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_EmailConfirmationSession))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendEmailConfirmation_result :: ResendEmailConfirmation_result
default_ResendEmailConfirmation_result = ResendEmailConfirmation_result{
  resendEmailConfirmation_result_success = default_EmailConfirmationSession,
  resendEmailConfirmation_result_e = P.Nothing}
data ResendPinCode_args = ResendPinCode_args  { resendPinCode_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCode_args_sessionId record  
instance QC.Arbitrary ResendPinCode_args where 
  arbitrary = M.liftM ResendPinCode_args (QC.arbitrary)
  shrink obj | obj == default_ResendPinCode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCode_args{resendPinCode_args_sessionId = resendPinCode_args_sessionId obj} then P.Nothing else P.Just $ default_ResendPinCode_args{resendPinCode_args_sessionId = resendPinCode_args_sessionId obj}
    ]
from_ResendPinCode_args :: ResendPinCode_args -> T.ThriftVal
from_ResendPinCode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8616 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v8616))) $ resendPinCode_args_sessionId record
  ]
write_ResendPinCode_args :: T.Protocol p => p -> ResendPinCode_args -> P.IO ()
write_ResendPinCode_args oprot record = T.writeVal oprot $ from_ResendPinCode_args record
encode_ResendPinCode_args :: T.StatelessProtocol p => p -> ResendPinCode_args -> LBS.ByteString
encode_ResendPinCode_args oprot record = T.serializeVal oprot $ from_ResendPinCode_args record
to_ResendPinCode_args :: T.ThriftVal -> ResendPinCode_args
to_ResendPinCode_args (T.TStruct fields) = ResendPinCode_args{
  resendPinCode_args_sessionId = P.maybe (resendPinCode_args_sessionId default_ResendPinCode_args) (\(_,_val8618) -> (case _val8618 of {T.TString _val8619 -> E.decodeUtf8 _val8619; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendPinCode_args _ = P.error "not a struct"
read_ResendPinCode_args :: T.Protocol p => p -> P.IO ResendPinCode_args
read_ResendPinCode_args iprot = to_ResendPinCode_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCode_args)
decode_ResendPinCode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCode_args
decode_ResendPinCode_args iprot bs = to_ResendPinCode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCode_args) bs
typemap_ResendPinCode_args :: T.TypeMap
typemap_ResendPinCode_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_ResendPinCode_args :: ResendPinCode_args
default_ResendPinCode_args = ResendPinCode_args{
  resendPinCode_args_sessionId = ""}
data ResendPinCode_result = ResendPinCode_result  { resendPinCode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCode_result_e record  
instance QC.Arbitrary ResendPinCode_result where 
  arbitrary = M.liftM ResendPinCode_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendPinCode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCode_result{resendPinCode_result_e = resendPinCode_result_e obj} then P.Nothing else P.Just $ default_ResendPinCode_result{resendPinCode_result_e = resendPinCode_result_e obj}
    ]
from_ResendPinCode_result :: ResendPinCode_result -> T.ThriftVal
from_ResendPinCode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8622 -> (1, ("e",from_TalkException _v8622))) <$> resendPinCode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8622 -> (1, ("e",from_TalkException _v8622))) <$> resendPinCode_result_e record
    ]
    )
write_ResendPinCode_result :: T.Protocol p => p -> ResendPinCode_result -> P.IO ()
write_ResendPinCode_result oprot record = T.writeVal oprot $ from_ResendPinCode_result record
encode_ResendPinCode_result :: T.StatelessProtocol p => p -> ResendPinCode_result -> LBS.ByteString
encode_ResendPinCode_result oprot record = T.serializeVal oprot $ from_ResendPinCode_result record
to_ResendPinCode_result :: T.ThriftVal -> ResendPinCode_result
to_ResendPinCode_result (T.TStruct fields) = ResendPinCode_result{
  resendPinCode_result_e = P.maybe (P.Nothing) (\(_,_val8624) -> P.Just (case _val8624 of {T.TStruct _val8625 -> (to_TalkException (T.TStruct _val8625)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendPinCode_result _ = P.error "not a struct"
read_ResendPinCode_result :: T.Protocol p => p -> P.IO ResendPinCode_result
read_ResendPinCode_result iprot = to_ResendPinCode_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCode_result)
decode_ResendPinCode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCode_result
decode_ResendPinCode_result iprot bs = to_ResendPinCode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCode_result) bs
typemap_ResendPinCode_result :: T.TypeMap
typemap_ResendPinCode_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendPinCode_result :: ResendPinCode_result
default_ResendPinCode_result = ResendPinCode_result{
  resendPinCode_result_e = P.Nothing}
data ResendPinCodeBySMS_args = ResendPinCodeBySMS_args  { resendPinCodeBySMS_args_sessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCodeBySMS_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCodeBySMS_args_sessionId record  
instance QC.Arbitrary ResendPinCodeBySMS_args where 
  arbitrary = M.liftM ResendPinCodeBySMS_args (QC.arbitrary)
  shrink obj | obj == default_ResendPinCodeBySMS_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCodeBySMS_args{resendPinCodeBySMS_args_sessionId = resendPinCodeBySMS_args_sessionId obj} then P.Nothing else P.Just $ default_ResendPinCodeBySMS_args{resendPinCodeBySMS_args_sessionId = resendPinCodeBySMS_args_sessionId obj}
    ]
from_ResendPinCodeBySMS_args :: ResendPinCodeBySMS_args -> T.ThriftVal
from_ResendPinCodeBySMS_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8628 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v8628))) $ resendPinCodeBySMS_args_sessionId record
  ]
write_ResendPinCodeBySMS_args :: T.Protocol p => p -> ResendPinCodeBySMS_args -> P.IO ()
write_ResendPinCodeBySMS_args oprot record = T.writeVal oprot $ from_ResendPinCodeBySMS_args record
encode_ResendPinCodeBySMS_args :: T.StatelessProtocol p => p -> ResendPinCodeBySMS_args -> LBS.ByteString
encode_ResendPinCodeBySMS_args oprot record = T.serializeVal oprot $ from_ResendPinCodeBySMS_args record
to_ResendPinCodeBySMS_args :: T.ThriftVal -> ResendPinCodeBySMS_args
to_ResendPinCodeBySMS_args (T.TStruct fields) = ResendPinCodeBySMS_args{
  resendPinCodeBySMS_args_sessionId = P.maybe (resendPinCodeBySMS_args_sessionId default_ResendPinCodeBySMS_args) (\(_,_val8630) -> (case _val8630 of {T.TString _val8631 -> E.decodeUtf8 _val8631; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ResendPinCodeBySMS_args _ = P.error "not a struct"
read_ResendPinCodeBySMS_args :: T.Protocol p => p -> P.IO ResendPinCodeBySMS_args
read_ResendPinCodeBySMS_args iprot = to_ResendPinCodeBySMS_args <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_args)
decode_ResendPinCodeBySMS_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCodeBySMS_args
decode_ResendPinCodeBySMS_args iprot bs = to_ResendPinCodeBySMS_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_args) bs
typemap_ResendPinCodeBySMS_args :: T.TypeMap
typemap_ResendPinCodeBySMS_args = Map.fromList [(2,("sessionId",T.T_STRING))]
default_ResendPinCodeBySMS_args :: ResendPinCodeBySMS_args
default_ResendPinCodeBySMS_args = ResendPinCodeBySMS_args{
  resendPinCodeBySMS_args_sessionId = ""}
data ResendPinCodeBySMS_result = ResendPinCodeBySMS_result  { resendPinCodeBySMS_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResendPinCodeBySMS_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` resendPinCodeBySMS_result_e record  
instance QC.Arbitrary ResendPinCodeBySMS_result where 
  arbitrary = M.liftM ResendPinCodeBySMS_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResendPinCodeBySMS_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = resendPinCodeBySMS_result_e obj} then P.Nothing else P.Just $ default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = resendPinCodeBySMS_result_e obj}
    ]
from_ResendPinCodeBySMS_result :: ResendPinCodeBySMS_result -> T.ThriftVal
from_ResendPinCodeBySMS_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8634 -> (1, ("e",from_TalkException _v8634))) <$> resendPinCodeBySMS_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8634 -> (1, ("e",from_TalkException _v8634))) <$> resendPinCodeBySMS_result_e record
    ]
    )
write_ResendPinCodeBySMS_result :: T.Protocol p => p -> ResendPinCodeBySMS_result -> P.IO ()
write_ResendPinCodeBySMS_result oprot record = T.writeVal oprot $ from_ResendPinCodeBySMS_result record
encode_ResendPinCodeBySMS_result :: T.StatelessProtocol p => p -> ResendPinCodeBySMS_result -> LBS.ByteString
encode_ResendPinCodeBySMS_result oprot record = T.serializeVal oprot $ from_ResendPinCodeBySMS_result record
to_ResendPinCodeBySMS_result :: T.ThriftVal -> ResendPinCodeBySMS_result
to_ResendPinCodeBySMS_result (T.TStruct fields) = ResendPinCodeBySMS_result{
  resendPinCodeBySMS_result_e = P.maybe (P.Nothing) (\(_,_val8636) -> P.Just (case _val8636 of {T.TStruct _val8637 -> (to_TalkException (T.TStruct _val8637)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ResendPinCodeBySMS_result _ = P.error "not a struct"
read_ResendPinCodeBySMS_result :: T.Protocol p => p -> P.IO ResendPinCodeBySMS_result
read_ResendPinCodeBySMS_result iprot = to_ResendPinCodeBySMS_result <$> T.readVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_result)
decode_ResendPinCodeBySMS_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ResendPinCodeBySMS_result
decode_ResendPinCodeBySMS_result iprot bs = to_ResendPinCodeBySMS_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ResendPinCodeBySMS_result) bs
typemap_ResendPinCodeBySMS_result :: T.TypeMap
typemap_ResendPinCodeBySMS_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ResendPinCodeBySMS_result :: ResendPinCodeBySMS_result
default_ResendPinCodeBySMS_result = ResendPinCodeBySMS_result{
  resendPinCodeBySMS_result_e = P.Nothing}
data SendChatChecked_args = SendChatChecked_args  { sendChatChecked_args_seq :: I.Int32
  , sendChatChecked_args_consumer :: LT.Text
  , sendChatChecked_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatChecked_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatChecked_args_seq record   `H.hashWithSalt` sendChatChecked_args_consumer record   `H.hashWithSalt` sendChatChecked_args_lastMessageId record  
instance QC.Arbitrary SendChatChecked_args where 
  arbitrary = M.liftM SendChatChecked_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendChatChecked_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatChecked_args{sendChatChecked_args_seq = sendChatChecked_args_seq obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_seq = sendChatChecked_args_seq obj}
    , if obj == default_SendChatChecked_args{sendChatChecked_args_consumer = sendChatChecked_args_consumer obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_consumer = sendChatChecked_args_consumer obj}
    , if obj == default_SendChatChecked_args{sendChatChecked_args_lastMessageId = sendChatChecked_args_lastMessageId obj} then P.Nothing else P.Just $ default_SendChatChecked_args{sendChatChecked_args_lastMessageId = sendChatChecked_args_lastMessageId obj}
    ]
from_SendChatChecked_args :: SendChatChecked_args -> T.ThriftVal
from_SendChatChecked_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8640 -> P.Just (1, ("seq",T.TI32 _v8640))) $ sendChatChecked_args_seq record
  , (\_v8640 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v8640))) $ sendChatChecked_args_consumer record
  , (\_v8640 -> P.Just (3, ("lastMessageId",T.TString $ E.encodeUtf8 _v8640))) $ sendChatChecked_args_lastMessageId record
  ]
write_SendChatChecked_args :: T.Protocol p => p -> SendChatChecked_args -> P.IO ()
write_SendChatChecked_args oprot record = T.writeVal oprot $ from_SendChatChecked_args record
encode_SendChatChecked_args :: T.StatelessProtocol p => p -> SendChatChecked_args -> LBS.ByteString
encode_SendChatChecked_args oprot record = T.serializeVal oprot $ from_SendChatChecked_args record
to_SendChatChecked_args :: T.ThriftVal -> SendChatChecked_args
to_SendChatChecked_args (T.TStruct fields) = SendChatChecked_args{
  sendChatChecked_args_seq = P.maybe (sendChatChecked_args_seq default_SendChatChecked_args) (\(_,_val8642) -> (case _val8642 of {T.TI32 _val8643 -> _val8643; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendChatChecked_args_consumer = P.maybe (sendChatChecked_args_consumer default_SendChatChecked_args) (\(_,_val8642) -> (case _val8642 of {T.TString _val8644 -> E.decodeUtf8 _val8644; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendChatChecked_args_lastMessageId = P.maybe (sendChatChecked_args_lastMessageId default_SendChatChecked_args) (\(_,_val8642) -> (case _val8642 of {T.TString _val8645 -> E.decodeUtf8 _val8645; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendChatChecked_args _ = P.error "not a struct"
read_SendChatChecked_args :: T.Protocol p => p -> P.IO SendChatChecked_args
read_SendChatChecked_args iprot = to_SendChatChecked_args <$> T.readVal iprot (T.T_STRUCT typemap_SendChatChecked_args)
decode_SendChatChecked_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatChecked_args
decode_SendChatChecked_args iprot bs = to_SendChatChecked_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatChecked_args) bs
typemap_SendChatChecked_args :: T.TypeMap
typemap_SendChatChecked_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("lastMessageId",T.T_STRING))]
default_SendChatChecked_args :: SendChatChecked_args
default_SendChatChecked_args = SendChatChecked_args{
  sendChatChecked_args_seq = 0,
  sendChatChecked_args_consumer = "",
  sendChatChecked_args_lastMessageId = ""}
data SendChatChecked_result = SendChatChecked_result  { sendChatChecked_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatChecked_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatChecked_result_e record  
instance QC.Arbitrary SendChatChecked_result where 
  arbitrary = M.liftM SendChatChecked_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendChatChecked_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatChecked_result{sendChatChecked_result_e = sendChatChecked_result_e obj} then P.Nothing else P.Just $ default_SendChatChecked_result{sendChatChecked_result_e = sendChatChecked_result_e obj}
    ]
from_SendChatChecked_result :: SendChatChecked_result -> T.ThriftVal
from_SendChatChecked_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8648 -> (1, ("e",from_TalkException _v8648))) <$> sendChatChecked_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8648 -> (1, ("e",from_TalkException _v8648))) <$> sendChatChecked_result_e record
    ]
    )
write_SendChatChecked_result :: T.Protocol p => p -> SendChatChecked_result -> P.IO ()
write_SendChatChecked_result oprot record = T.writeVal oprot $ from_SendChatChecked_result record
encode_SendChatChecked_result :: T.StatelessProtocol p => p -> SendChatChecked_result -> LBS.ByteString
encode_SendChatChecked_result oprot record = T.serializeVal oprot $ from_SendChatChecked_result record
to_SendChatChecked_result :: T.ThriftVal -> SendChatChecked_result
to_SendChatChecked_result (T.TStruct fields) = SendChatChecked_result{
  sendChatChecked_result_e = P.maybe (P.Nothing) (\(_,_val8650) -> P.Just (case _val8650 of {T.TStruct _val8651 -> (to_TalkException (T.TStruct _val8651)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendChatChecked_result _ = P.error "not a struct"
read_SendChatChecked_result :: T.Protocol p => p -> P.IO SendChatChecked_result
read_SendChatChecked_result iprot = to_SendChatChecked_result <$> T.readVal iprot (T.T_STRUCT typemap_SendChatChecked_result)
decode_SendChatChecked_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatChecked_result
decode_SendChatChecked_result iprot bs = to_SendChatChecked_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatChecked_result) bs
typemap_SendChatChecked_result :: T.TypeMap
typemap_SendChatChecked_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendChatChecked_result :: SendChatChecked_result
default_SendChatChecked_result = SendChatChecked_result{
  sendChatChecked_result_e = P.Nothing}
data SendMessageAwaitCommit_args = SendMessageAwaitCommit_args  { sendMessageAwaitCommit_args_seq :: I.Int32
  , sendMessageAwaitCommit_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageAwaitCommit_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageAwaitCommit_args_seq record   `H.hashWithSalt` sendMessageAwaitCommit_args_message record  
instance QC.Arbitrary SendMessageAwaitCommit_args where 
  arbitrary = M.liftM SendMessageAwaitCommit_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageAwaitCommit_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageAwaitCommit_args{sendMessageAwaitCommit_args_seq = sendMessageAwaitCommit_args_seq obj} then P.Nothing else P.Just $ default_SendMessageAwaitCommit_args{sendMessageAwaitCommit_args_seq = sendMessageAwaitCommit_args_seq obj}
    , if obj == default_SendMessageAwaitCommit_args{sendMessageAwaitCommit_args_message = sendMessageAwaitCommit_args_message obj} then P.Nothing else P.Just $ default_SendMessageAwaitCommit_args{sendMessageAwaitCommit_args_message = sendMessageAwaitCommit_args_message obj}
    ]
from_SendMessageAwaitCommit_args :: SendMessageAwaitCommit_args -> T.ThriftVal
from_SendMessageAwaitCommit_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8654 -> P.Just (1, ("seq",T.TI32 _v8654))) $ sendMessageAwaitCommit_args_seq record
  , (\_v8654 -> P.Just (2, ("message",from_Message _v8654))) $ sendMessageAwaitCommit_args_message record
  ]
write_SendMessageAwaitCommit_args :: T.Protocol p => p -> SendMessageAwaitCommit_args -> P.IO ()
write_SendMessageAwaitCommit_args oprot record = T.writeVal oprot $ from_SendMessageAwaitCommit_args record
encode_SendMessageAwaitCommit_args :: T.StatelessProtocol p => p -> SendMessageAwaitCommit_args -> LBS.ByteString
encode_SendMessageAwaitCommit_args oprot record = T.serializeVal oprot $ from_SendMessageAwaitCommit_args record
to_SendMessageAwaitCommit_args :: T.ThriftVal -> SendMessageAwaitCommit_args
to_SendMessageAwaitCommit_args (T.TStruct fields) = SendMessageAwaitCommit_args{
  sendMessageAwaitCommit_args_seq = P.maybe (sendMessageAwaitCommit_args_seq default_SendMessageAwaitCommit_args) (\(_,_val8656) -> (case _val8656 of {T.TI32 _val8657 -> _val8657; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageAwaitCommit_args_message = P.maybe (sendMessageAwaitCommit_args_message default_SendMessageAwaitCommit_args) (\(_,_val8656) -> (case _val8656 of {T.TStruct _val8658 -> (to_Message (T.TStruct _val8658)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageAwaitCommit_args _ = P.error "not a struct"
read_SendMessageAwaitCommit_args :: T.Protocol p => p -> P.IO SendMessageAwaitCommit_args
read_SendMessageAwaitCommit_args iprot = to_SendMessageAwaitCommit_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageAwaitCommit_args)
decode_SendMessageAwaitCommit_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageAwaitCommit_args
decode_SendMessageAwaitCommit_args iprot bs = to_SendMessageAwaitCommit_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageAwaitCommit_args) bs
typemap_SendMessageAwaitCommit_args :: T.TypeMap
typemap_SendMessageAwaitCommit_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageAwaitCommit_args :: SendMessageAwaitCommit_args
default_SendMessageAwaitCommit_args = SendMessageAwaitCommit_args{
  sendMessageAwaitCommit_args_seq = 0,
  sendMessageAwaitCommit_args_message = default_Message}
data SendMessageAwaitCommit_result = SendMessageAwaitCommit_result  { sendMessageAwaitCommit_result_success :: CommitMessageResult
  , sendMessageAwaitCommit_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageAwaitCommit_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageAwaitCommit_result_success record   `H.hashWithSalt` sendMessageAwaitCommit_result_e record  
instance QC.Arbitrary SendMessageAwaitCommit_result where 
  arbitrary = M.liftM SendMessageAwaitCommit_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageAwaitCommit_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_success = sendMessageAwaitCommit_result_success obj} then P.Nothing else P.Just $ default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_success = sendMessageAwaitCommit_result_success obj}
    , if obj == default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_e = sendMessageAwaitCommit_result_e obj} then P.Nothing else P.Just $ default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_e = sendMessageAwaitCommit_result_e obj}
    ]
from_SendMessageAwaitCommit_result :: SendMessageAwaitCommit_result -> T.ThriftVal
from_SendMessageAwaitCommit_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8661 -> (1, ("e",from_TalkException _v8661))) <$> sendMessageAwaitCommit_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8661 -> P.Just (0, ("success",from_CommitMessageResult _v8661))) $ sendMessageAwaitCommit_result_success record
    , (\_v8661 -> (1, ("e",from_TalkException _v8661))) <$> sendMessageAwaitCommit_result_e record
    ]
    )
write_SendMessageAwaitCommit_result :: T.Protocol p => p -> SendMessageAwaitCommit_result -> P.IO ()
write_SendMessageAwaitCommit_result oprot record = T.writeVal oprot $ from_SendMessageAwaitCommit_result record
encode_SendMessageAwaitCommit_result :: T.StatelessProtocol p => p -> SendMessageAwaitCommit_result -> LBS.ByteString
encode_SendMessageAwaitCommit_result oprot record = T.serializeVal oprot $ from_SendMessageAwaitCommit_result record
to_SendMessageAwaitCommit_result :: T.ThriftVal -> SendMessageAwaitCommit_result
to_SendMessageAwaitCommit_result (T.TStruct fields) = SendMessageAwaitCommit_result{
  sendMessageAwaitCommit_result_success = P.maybe (sendMessageAwaitCommit_result_success default_SendMessageAwaitCommit_result) (\(_,_val8663) -> (case _val8663 of {T.TStruct _val8664 -> (to_CommitMessageResult (T.TStruct _val8664)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageAwaitCommit_result_e = P.maybe (P.Nothing) (\(_,_val8663) -> P.Just (case _val8663 of {T.TStruct _val8665 -> (to_TalkException (T.TStruct _val8665)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageAwaitCommit_result _ = P.error "not a struct"
read_SendMessageAwaitCommit_result :: T.Protocol p => p -> P.IO SendMessageAwaitCommit_result
read_SendMessageAwaitCommit_result iprot = to_SendMessageAwaitCommit_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageAwaitCommit_result)
decode_SendMessageAwaitCommit_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageAwaitCommit_result
decode_SendMessageAwaitCommit_result iprot bs = to_SendMessageAwaitCommit_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageAwaitCommit_result) bs
typemap_SendMessageAwaitCommit_result :: T.TypeMap
typemap_SendMessageAwaitCommit_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CommitMessageResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageAwaitCommit_result :: SendMessageAwaitCommit_result
default_SendMessageAwaitCommit_result = SendMessageAwaitCommit_result{
  sendMessageAwaitCommit_result_success = default_CommitMessageResult,
  sendMessageAwaitCommit_result_e = P.Nothing}
data SendChatRemoved_args = SendChatRemoved_args  { sendChatRemoved_args_seq :: I.Int32
  , sendChatRemoved_args_consumer :: LT.Text
  , sendChatRemoved_args_lastMessageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatRemoved_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatRemoved_args_seq record   `H.hashWithSalt` sendChatRemoved_args_consumer record   `H.hashWithSalt` sendChatRemoved_args_lastMessageId record  
instance QC.Arbitrary SendChatRemoved_args where 
  arbitrary = M.liftM SendChatRemoved_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendChatRemoved_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatRemoved_args{sendChatRemoved_args_seq = sendChatRemoved_args_seq obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_seq = sendChatRemoved_args_seq obj}
    , if obj == default_SendChatRemoved_args{sendChatRemoved_args_consumer = sendChatRemoved_args_consumer obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_consumer = sendChatRemoved_args_consumer obj}
    , if obj == default_SendChatRemoved_args{sendChatRemoved_args_lastMessageId = sendChatRemoved_args_lastMessageId obj} then P.Nothing else P.Just $ default_SendChatRemoved_args{sendChatRemoved_args_lastMessageId = sendChatRemoved_args_lastMessageId obj}
    ]
from_SendChatRemoved_args :: SendChatRemoved_args -> T.ThriftVal
from_SendChatRemoved_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8668 -> P.Just (1, ("seq",T.TI32 _v8668))) $ sendChatRemoved_args_seq record
  , (\_v8668 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v8668))) $ sendChatRemoved_args_consumer record
  , (\_v8668 -> P.Just (3, ("lastMessageId",T.TString $ E.encodeUtf8 _v8668))) $ sendChatRemoved_args_lastMessageId record
  ]
write_SendChatRemoved_args :: T.Protocol p => p -> SendChatRemoved_args -> P.IO ()
write_SendChatRemoved_args oprot record = T.writeVal oprot $ from_SendChatRemoved_args record
encode_SendChatRemoved_args :: T.StatelessProtocol p => p -> SendChatRemoved_args -> LBS.ByteString
encode_SendChatRemoved_args oprot record = T.serializeVal oprot $ from_SendChatRemoved_args record
to_SendChatRemoved_args :: T.ThriftVal -> SendChatRemoved_args
to_SendChatRemoved_args (T.TStruct fields) = SendChatRemoved_args{
  sendChatRemoved_args_seq = P.maybe (sendChatRemoved_args_seq default_SendChatRemoved_args) (\(_,_val8670) -> (case _val8670 of {T.TI32 _val8671 -> _val8671; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendChatRemoved_args_consumer = P.maybe (sendChatRemoved_args_consumer default_SendChatRemoved_args) (\(_,_val8670) -> (case _val8670 of {T.TString _val8672 -> E.decodeUtf8 _val8672; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendChatRemoved_args_lastMessageId = P.maybe (sendChatRemoved_args_lastMessageId default_SendChatRemoved_args) (\(_,_val8670) -> (case _val8670 of {T.TString _val8673 -> E.decodeUtf8 _val8673; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendChatRemoved_args _ = P.error "not a struct"
read_SendChatRemoved_args :: T.Protocol p => p -> P.IO SendChatRemoved_args
read_SendChatRemoved_args iprot = to_SendChatRemoved_args <$> T.readVal iprot (T.T_STRUCT typemap_SendChatRemoved_args)
decode_SendChatRemoved_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatRemoved_args
decode_SendChatRemoved_args iprot bs = to_SendChatRemoved_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatRemoved_args) bs
typemap_SendChatRemoved_args :: T.TypeMap
typemap_SendChatRemoved_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("lastMessageId",T.T_STRING))]
default_SendChatRemoved_args :: SendChatRemoved_args
default_SendChatRemoved_args = SendChatRemoved_args{
  sendChatRemoved_args_seq = 0,
  sendChatRemoved_args_consumer = "",
  sendChatRemoved_args_lastMessageId = ""}
data SendChatRemoved_result = SendChatRemoved_result  { sendChatRemoved_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendChatRemoved_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendChatRemoved_result_e record  
instance QC.Arbitrary SendChatRemoved_result where 
  arbitrary = M.liftM SendChatRemoved_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendChatRemoved_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendChatRemoved_result{sendChatRemoved_result_e = sendChatRemoved_result_e obj} then P.Nothing else P.Just $ default_SendChatRemoved_result{sendChatRemoved_result_e = sendChatRemoved_result_e obj}
    ]
from_SendChatRemoved_result :: SendChatRemoved_result -> T.ThriftVal
from_SendChatRemoved_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8676 -> (1, ("e",from_TalkException _v8676))) <$> sendChatRemoved_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8676 -> (1, ("e",from_TalkException _v8676))) <$> sendChatRemoved_result_e record
    ]
    )
write_SendChatRemoved_result :: T.Protocol p => p -> SendChatRemoved_result -> P.IO ()
write_SendChatRemoved_result oprot record = T.writeVal oprot $ from_SendChatRemoved_result record
encode_SendChatRemoved_result :: T.StatelessProtocol p => p -> SendChatRemoved_result -> LBS.ByteString
encode_SendChatRemoved_result oprot record = T.serializeVal oprot $ from_SendChatRemoved_result record
to_SendChatRemoved_result :: T.ThriftVal -> SendChatRemoved_result
to_SendChatRemoved_result (T.TStruct fields) = SendChatRemoved_result{
  sendChatRemoved_result_e = P.maybe (P.Nothing) (\(_,_val8678) -> P.Just (case _val8678 of {T.TStruct _val8679 -> (to_TalkException (T.TStruct _val8679)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendChatRemoved_result _ = P.error "not a struct"
read_SendChatRemoved_result :: T.Protocol p => p -> P.IO SendChatRemoved_result
read_SendChatRemoved_result iprot = to_SendChatRemoved_result <$> T.readVal iprot (T.T_STRUCT typemap_SendChatRemoved_result)
decode_SendChatRemoved_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendChatRemoved_result
decode_SendChatRemoved_result iprot bs = to_SendChatRemoved_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendChatRemoved_result) bs
typemap_SendChatRemoved_result :: T.TypeMap
typemap_SendChatRemoved_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendChatRemoved_result :: SendChatRemoved_result
default_SendChatRemoved_result = SendChatRemoved_result{
  sendChatRemoved_result_e = P.Nothing}
data SendContentPreviewUpdated_args = SendContentPreviewUpdated_args  { sendContentPreviewUpdated_args_esq :: I.Int32
  , sendContentPreviewUpdated_args_messageId :: LT.Text
  , sendContentPreviewUpdated_args_receiverMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentPreviewUpdated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentPreviewUpdated_args_esq record   `H.hashWithSalt` sendContentPreviewUpdated_args_messageId record   `H.hashWithSalt` sendContentPreviewUpdated_args_receiverMids record  
instance QC.Arbitrary SendContentPreviewUpdated_args where 
  arbitrary = M.liftM SendContentPreviewUpdated_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendContentPreviewUpdated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_esq = sendContentPreviewUpdated_args_esq obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_esq = sendContentPreviewUpdated_args_esq obj}
    , if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_messageId = sendContentPreviewUpdated_args_messageId obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_messageId = sendContentPreviewUpdated_args_messageId obj}
    , if obj == default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_receiverMids = sendContentPreviewUpdated_args_receiverMids obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_args{sendContentPreviewUpdated_args_receiverMids = sendContentPreviewUpdated_args_receiverMids obj}
    ]
from_SendContentPreviewUpdated_args :: SendContentPreviewUpdated_args -> T.ThriftVal
from_SendContentPreviewUpdated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8682 -> P.Just (1, ("esq",T.TI32 _v8682))) $ sendContentPreviewUpdated_args_esq record
  , (\_v8682 -> P.Just (2, ("messageId",T.TString $ E.encodeUtf8 _v8682))) $ sendContentPreviewUpdated_args_messageId record
  , (\_v8682 -> P.Just (3, ("receiverMids",T.TList T.T_STRING $ P.map (\_v8684 -> T.TString $ E.encodeUtf8 _v8684) $ Vector.toList _v8682))) $ sendContentPreviewUpdated_args_receiverMids record
  ]
write_SendContentPreviewUpdated_args :: T.Protocol p => p -> SendContentPreviewUpdated_args -> P.IO ()
write_SendContentPreviewUpdated_args oprot record = T.writeVal oprot $ from_SendContentPreviewUpdated_args record
encode_SendContentPreviewUpdated_args :: T.StatelessProtocol p => p -> SendContentPreviewUpdated_args -> LBS.ByteString
encode_SendContentPreviewUpdated_args oprot record = T.serializeVal oprot $ from_SendContentPreviewUpdated_args record
to_SendContentPreviewUpdated_args :: T.ThriftVal -> SendContentPreviewUpdated_args
to_SendContentPreviewUpdated_args (T.TStruct fields) = SendContentPreviewUpdated_args{
  sendContentPreviewUpdated_args_esq = P.maybe (sendContentPreviewUpdated_args_esq default_SendContentPreviewUpdated_args) (\(_,_val8686) -> (case _val8686 of {T.TI32 _val8687 -> _val8687; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendContentPreviewUpdated_args_messageId = P.maybe (sendContentPreviewUpdated_args_messageId default_SendContentPreviewUpdated_args) (\(_,_val8686) -> (case _val8686 of {T.TString _val8688 -> E.decodeUtf8 _val8688; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendContentPreviewUpdated_args_receiverMids = P.maybe (sendContentPreviewUpdated_args_receiverMids default_SendContentPreviewUpdated_args) (\(_,_val8686) -> (case _val8686 of {T.TList _ _val8689 -> (Vector.fromList $ P.map (\_v8690 -> (case _v8690 of {T.TString _val8691 -> E.decodeUtf8 _val8691; _ -> P.error "wrong type"})) _val8689); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendContentPreviewUpdated_args _ = P.error "not a struct"
read_SendContentPreviewUpdated_args :: T.Protocol p => p -> P.IO SendContentPreviewUpdated_args
read_SendContentPreviewUpdated_args iprot = to_SendContentPreviewUpdated_args <$> T.readVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_args)
decode_SendContentPreviewUpdated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentPreviewUpdated_args
decode_SendContentPreviewUpdated_args iprot bs = to_SendContentPreviewUpdated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_args) bs
typemap_SendContentPreviewUpdated_args :: T.TypeMap
typemap_SendContentPreviewUpdated_args = Map.fromList [(1,("esq",T.T_I32)),(2,("messageId",T.T_STRING)),(3,("receiverMids",(T.T_LIST T.T_STRING)))]
default_SendContentPreviewUpdated_args :: SendContentPreviewUpdated_args
default_SendContentPreviewUpdated_args = SendContentPreviewUpdated_args{
  sendContentPreviewUpdated_args_esq = 0,
  sendContentPreviewUpdated_args_messageId = "",
  sendContentPreviewUpdated_args_receiverMids = Vector.empty}
data SendContentPreviewUpdated_result = SendContentPreviewUpdated_result  { sendContentPreviewUpdated_result_success :: (Map.HashMap LT.Text LT.Text)
  , sendContentPreviewUpdated_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentPreviewUpdated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentPreviewUpdated_result_success record   `H.hashWithSalt` sendContentPreviewUpdated_result_e record  
instance QC.Arbitrary SendContentPreviewUpdated_result where 
  arbitrary = M.liftM SendContentPreviewUpdated_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendContentPreviewUpdated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = sendContentPreviewUpdated_result_success obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = sendContentPreviewUpdated_result_success obj}
    , if obj == default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = sendContentPreviewUpdated_result_e obj} then P.Nothing else P.Just $ default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = sendContentPreviewUpdated_result_e obj}
    ]
from_SendContentPreviewUpdated_result :: SendContentPreviewUpdated_result -> T.ThriftVal
from_SendContentPreviewUpdated_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8694 -> (1, ("e",from_TalkException _v8694))) <$> sendContentPreviewUpdated_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8694 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k8695,_v8696) -> (T.TString $ E.encodeUtf8 _k8695, T.TString $ E.encodeUtf8 _v8696)) $ Map.toList _v8694))) $ sendContentPreviewUpdated_result_success record
    , (\_v8694 -> (1, ("e",from_TalkException _v8694))) <$> sendContentPreviewUpdated_result_e record
    ]
    )
write_SendContentPreviewUpdated_result :: T.Protocol p => p -> SendContentPreviewUpdated_result -> P.IO ()
write_SendContentPreviewUpdated_result oprot record = T.writeVal oprot $ from_SendContentPreviewUpdated_result record
encode_SendContentPreviewUpdated_result :: T.StatelessProtocol p => p -> SendContentPreviewUpdated_result -> LBS.ByteString
encode_SendContentPreviewUpdated_result oprot record = T.serializeVal oprot $ from_SendContentPreviewUpdated_result record
to_SendContentPreviewUpdated_result :: T.ThriftVal -> SendContentPreviewUpdated_result
to_SendContentPreviewUpdated_result (T.TStruct fields) = SendContentPreviewUpdated_result{
  sendContentPreviewUpdated_result_success = P.maybe (sendContentPreviewUpdated_result_success default_SendContentPreviewUpdated_result) (\(_,_val8698) -> (case _val8698 of {T.TMap _ _ _val8699 -> (Map.fromList $ P.map (\(_k8701,_v8700) -> ((case _k8701 of {T.TString _val8702 -> E.decodeUtf8 _val8702; _ -> P.error "wrong type"}),(case _v8700 of {T.TString _val8703 -> E.decodeUtf8 _val8703; _ -> P.error "wrong type"}))) _val8699); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendContentPreviewUpdated_result_e = P.maybe (P.Nothing) (\(_,_val8698) -> P.Just (case _val8698 of {T.TStruct _val8704 -> (to_TalkException (T.TStruct _val8704)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendContentPreviewUpdated_result _ = P.error "not a struct"
read_SendContentPreviewUpdated_result :: T.Protocol p => p -> P.IO SendContentPreviewUpdated_result
read_SendContentPreviewUpdated_result iprot = to_SendContentPreviewUpdated_result <$> T.readVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_result)
decode_SendContentPreviewUpdated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentPreviewUpdated_result
decode_SendContentPreviewUpdated_result iprot bs = to_SendContentPreviewUpdated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentPreviewUpdated_result) bs
typemap_SendContentPreviewUpdated_result :: T.TypeMap
typemap_SendContentPreviewUpdated_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendContentPreviewUpdated_result :: SendContentPreviewUpdated_result
default_SendContentPreviewUpdated_result = SendContentPreviewUpdated_result{
  sendContentPreviewUpdated_result_success = Map.empty,
  sendContentPreviewUpdated_result_e = P.Nothing}
data SendContentReceipt_args = SendContentReceipt_args  { sendContentReceipt_args_seq :: I.Int32
  , sendContentReceipt_args_consumer :: LT.Text
  , sendContentReceipt_args_messageId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentReceipt_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentReceipt_args_seq record   `H.hashWithSalt` sendContentReceipt_args_consumer record   `H.hashWithSalt` sendContentReceipt_args_messageId record  
instance QC.Arbitrary SendContentReceipt_args where 
  arbitrary = M.liftM SendContentReceipt_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendContentReceipt_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentReceipt_args{sendContentReceipt_args_seq = sendContentReceipt_args_seq obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_seq = sendContentReceipt_args_seq obj}
    , if obj == default_SendContentReceipt_args{sendContentReceipt_args_consumer = sendContentReceipt_args_consumer obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_consumer = sendContentReceipt_args_consumer obj}
    , if obj == default_SendContentReceipt_args{sendContentReceipt_args_messageId = sendContentReceipt_args_messageId obj} then P.Nothing else P.Just $ default_SendContentReceipt_args{sendContentReceipt_args_messageId = sendContentReceipt_args_messageId obj}
    ]
from_SendContentReceipt_args :: SendContentReceipt_args -> T.ThriftVal
from_SendContentReceipt_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8707 -> P.Just (1, ("seq",T.TI32 _v8707))) $ sendContentReceipt_args_seq record
  , (\_v8707 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v8707))) $ sendContentReceipt_args_consumer record
  , (\_v8707 -> P.Just (3, ("messageId",T.TString $ E.encodeUtf8 _v8707))) $ sendContentReceipt_args_messageId record
  ]
write_SendContentReceipt_args :: T.Protocol p => p -> SendContentReceipt_args -> P.IO ()
write_SendContentReceipt_args oprot record = T.writeVal oprot $ from_SendContentReceipt_args record
encode_SendContentReceipt_args :: T.StatelessProtocol p => p -> SendContentReceipt_args -> LBS.ByteString
encode_SendContentReceipt_args oprot record = T.serializeVal oprot $ from_SendContentReceipt_args record
to_SendContentReceipt_args :: T.ThriftVal -> SendContentReceipt_args
to_SendContentReceipt_args (T.TStruct fields) = SendContentReceipt_args{
  sendContentReceipt_args_seq = P.maybe (sendContentReceipt_args_seq default_SendContentReceipt_args) (\(_,_val8709) -> (case _val8709 of {T.TI32 _val8710 -> _val8710; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendContentReceipt_args_consumer = P.maybe (sendContentReceipt_args_consumer default_SendContentReceipt_args) (\(_,_val8709) -> (case _val8709 of {T.TString _val8711 -> E.decodeUtf8 _val8711; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendContentReceipt_args_messageId = P.maybe (sendContentReceipt_args_messageId default_SendContentReceipt_args) (\(_,_val8709) -> (case _val8709 of {T.TString _val8712 -> E.decodeUtf8 _val8712; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendContentReceipt_args _ = P.error "not a struct"
read_SendContentReceipt_args :: T.Protocol p => p -> P.IO SendContentReceipt_args
read_SendContentReceipt_args iprot = to_SendContentReceipt_args <$> T.readVal iprot (T.T_STRUCT typemap_SendContentReceipt_args)
decode_SendContentReceipt_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentReceipt_args
decode_SendContentReceipt_args iprot bs = to_SendContentReceipt_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentReceipt_args) bs
typemap_SendContentReceipt_args :: T.TypeMap
typemap_SendContentReceipt_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageId",T.T_STRING))]
default_SendContentReceipt_args :: SendContentReceipt_args
default_SendContentReceipt_args = SendContentReceipt_args{
  sendContentReceipt_args_seq = 0,
  sendContentReceipt_args_consumer = "",
  sendContentReceipt_args_messageId = ""}
data SendContentReceipt_result = SendContentReceipt_result  { sendContentReceipt_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendContentReceipt_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendContentReceipt_result_e record  
instance QC.Arbitrary SendContentReceipt_result where 
  arbitrary = M.liftM SendContentReceipt_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendContentReceipt_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendContentReceipt_result{sendContentReceipt_result_e = sendContentReceipt_result_e obj} then P.Nothing else P.Just $ default_SendContentReceipt_result{sendContentReceipt_result_e = sendContentReceipt_result_e obj}
    ]
from_SendContentReceipt_result :: SendContentReceipt_result -> T.ThriftVal
from_SendContentReceipt_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8715 -> (1, ("e",from_TalkException _v8715))) <$> sendContentReceipt_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8715 -> (1, ("e",from_TalkException _v8715))) <$> sendContentReceipt_result_e record
    ]
    )
write_SendContentReceipt_result :: T.Protocol p => p -> SendContentReceipt_result -> P.IO ()
write_SendContentReceipt_result oprot record = T.writeVal oprot $ from_SendContentReceipt_result record
encode_SendContentReceipt_result :: T.StatelessProtocol p => p -> SendContentReceipt_result -> LBS.ByteString
encode_SendContentReceipt_result oprot record = T.serializeVal oprot $ from_SendContentReceipt_result record
to_SendContentReceipt_result :: T.ThriftVal -> SendContentReceipt_result
to_SendContentReceipt_result (T.TStruct fields) = SendContentReceipt_result{
  sendContentReceipt_result_e = P.maybe (P.Nothing) (\(_,_val8717) -> P.Just (case _val8717 of {T.TStruct _val8718 -> (to_TalkException (T.TStruct _val8718)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendContentReceipt_result _ = P.error "not a struct"
read_SendContentReceipt_result :: T.Protocol p => p -> P.IO SendContentReceipt_result
read_SendContentReceipt_result iprot = to_SendContentReceipt_result <$> T.readVal iprot (T.T_STRUCT typemap_SendContentReceipt_result)
decode_SendContentReceipt_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendContentReceipt_result
decode_SendContentReceipt_result iprot bs = to_SendContentReceipt_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendContentReceipt_result) bs
typemap_SendContentReceipt_result :: T.TypeMap
typemap_SendContentReceipt_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendContentReceipt_result :: SendContentReceipt_result
default_SendContentReceipt_result = SendContentReceipt_result{
  sendContentReceipt_result_e = P.Nothing}
data SendDummyPush_args = SendDummyPush_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendDummyPush_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary SendDummyPush_args where 
  arbitrary = QC.elements [SendDummyPush_args]
from_SendDummyPush_args :: SendDummyPush_args -> T.ThriftVal
from_SendDummyPush_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_SendDummyPush_args :: T.Protocol p => p -> SendDummyPush_args -> P.IO ()
write_SendDummyPush_args oprot record = T.writeVal oprot $ from_SendDummyPush_args record
encode_SendDummyPush_args :: T.StatelessProtocol p => p -> SendDummyPush_args -> LBS.ByteString
encode_SendDummyPush_args oprot record = T.serializeVal oprot $ from_SendDummyPush_args record
to_SendDummyPush_args :: T.ThriftVal -> SendDummyPush_args
to_SendDummyPush_args (T.TStruct fields) = SendDummyPush_args{

  }
to_SendDummyPush_args _ = P.error "not a struct"
read_SendDummyPush_args :: T.Protocol p => p -> P.IO SendDummyPush_args
read_SendDummyPush_args iprot = to_SendDummyPush_args <$> T.readVal iprot (T.T_STRUCT typemap_SendDummyPush_args)
decode_SendDummyPush_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendDummyPush_args
decode_SendDummyPush_args iprot bs = to_SendDummyPush_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendDummyPush_args) bs
typemap_SendDummyPush_args :: T.TypeMap
typemap_SendDummyPush_args = Map.fromList []
default_SendDummyPush_args :: SendDummyPush_args
default_SendDummyPush_args = SendDummyPush_args{
}
data SendDummyPush_result = SendDummyPush_result  { sendDummyPush_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendDummyPush_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendDummyPush_result_e record  
instance QC.Arbitrary SendDummyPush_result where 
  arbitrary = M.liftM SendDummyPush_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendDummyPush_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendDummyPush_result{sendDummyPush_result_e = sendDummyPush_result_e obj} then P.Nothing else P.Just $ default_SendDummyPush_result{sendDummyPush_result_e = sendDummyPush_result_e obj}
    ]
from_SendDummyPush_result :: SendDummyPush_result -> T.ThriftVal
from_SendDummyPush_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8726 -> (1, ("e",from_TalkException _v8726))) <$> sendDummyPush_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8726 -> (1, ("e",from_TalkException _v8726))) <$> sendDummyPush_result_e record
    ]
    )
write_SendDummyPush_result :: T.Protocol p => p -> SendDummyPush_result -> P.IO ()
write_SendDummyPush_result oprot record = T.writeVal oprot $ from_SendDummyPush_result record
encode_SendDummyPush_result :: T.StatelessProtocol p => p -> SendDummyPush_result -> LBS.ByteString
encode_SendDummyPush_result oprot record = T.serializeVal oprot $ from_SendDummyPush_result record
to_SendDummyPush_result :: T.ThriftVal -> SendDummyPush_result
to_SendDummyPush_result (T.TStruct fields) = SendDummyPush_result{
  sendDummyPush_result_e = P.maybe (P.Nothing) (\(_,_val8728) -> P.Just (case _val8728 of {T.TStruct _val8729 -> (to_TalkException (T.TStruct _val8729)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendDummyPush_result _ = P.error "not a struct"
read_SendDummyPush_result :: T.Protocol p => p -> P.IO SendDummyPush_result
read_SendDummyPush_result iprot = to_SendDummyPush_result <$> T.readVal iprot (T.T_STRUCT typemap_SendDummyPush_result)
decode_SendDummyPush_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendDummyPush_result
decode_SendDummyPush_result iprot bs = to_SendDummyPush_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendDummyPush_result) bs
typemap_SendDummyPush_result :: T.TypeMap
typemap_SendDummyPush_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendDummyPush_result :: SendDummyPush_result
default_SendDummyPush_result = SendDummyPush_result{
  sendDummyPush_result_e = P.Nothing}
data RemoveE2EEPublicKey_args = RemoveE2EEPublicKey_args  { removeE2EEPublicKey_args_publicKey :: E2EEPublicKey
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveE2EEPublicKey_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeE2EEPublicKey_args_publicKey record  
instance QC.Arbitrary RemoveE2EEPublicKey_args where 
  arbitrary = M.liftM RemoveE2EEPublicKey_args (QC.arbitrary)
  shrink obj | obj == default_RemoveE2EEPublicKey_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveE2EEPublicKey_args{removeE2EEPublicKey_args_publicKey = removeE2EEPublicKey_args_publicKey obj} then P.Nothing else P.Just $ default_RemoveE2EEPublicKey_args{removeE2EEPublicKey_args_publicKey = removeE2EEPublicKey_args_publicKey obj}
    ]
from_RemoveE2EEPublicKey_args :: RemoveE2EEPublicKey_args -> T.ThriftVal
from_RemoveE2EEPublicKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8732 -> P.Just (2, ("publicKey",from_E2EEPublicKey _v8732))) $ removeE2EEPublicKey_args_publicKey record
  ]
write_RemoveE2EEPublicKey_args :: T.Protocol p => p -> RemoveE2EEPublicKey_args -> P.IO ()
write_RemoveE2EEPublicKey_args oprot record = T.writeVal oprot $ from_RemoveE2EEPublicKey_args record
encode_RemoveE2EEPublicKey_args :: T.StatelessProtocol p => p -> RemoveE2EEPublicKey_args -> LBS.ByteString
encode_RemoveE2EEPublicKey_args oprot record = T.serializeVal oprot $ from_RemoveE2EEPublicKey_args record
to_RemoveE2EEPublicKey_args :: T.ThriftVal -> RemoveE2EEPublicKey_args
to_RemoveE2EEPublicKey_args (T.TStruct fields) = RemoveE2EEPublicKey_args{
  removeE2EEPublicKey_args_publicKey = P.maybe (removeE2EEPublicKey_args_publicKey default_RemoveE2EEPublicKey_args) (\(_,_val8734) -> (case _val8734 of {T.TStruct _val8735 -> (to_E2EEPublicKey (T.TStruct _val8735)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveE2EEPublicKey_args _ = P.error "not a struct"
read_RemoveE2EEPublicKey_args :: T.Protocol p => p -> P.IO RemoveE2EEPublicKey_args
read_RemoveE2EEPublicKey_args iprot = to_RemoveE2EEPublicKey_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveE2EEPublicKey_args)
decode_RemoveE2EEPublicKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveE2EEPublicKey_args
decode_RemoveE2EEPublicKey_args iprot bs = to_RemoveE2EEPublicKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveE2EEPublicKey_args) bs
typemap_RemoveE2EEPublicKey_args :: T.TypeMap
typemap_RemoveE2EEPublicKey_args = Map.fromList [(2,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey)))]
default_RemoveE2EEPublicKey_args :: RemoveE2EEPublicKey_args
default_RemoveE2EEPublicKey_args = RemoveE2EEPublicKey_args{
  removeE2EEPublicKey_args_publicKey = default_E2EEPublicKey}
data RemoveE2EEPublicKey_result = RemoveE2EEPublicKey_result  { removeE2EEPublicKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveE2EEPublicKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeE2EEPublicKey_result_e record  
instance QC.Arbitrary RemoveE2EEPublicKey_result where 
  arbitrary = M.liftM RemoveE2EEPublicKey_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveE2EEPublicKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveE2EEPublicKey_result{removeE2EEPublicKey_result_e = removeE2EEPublicKey_result_e obj} then P.Nothing else P.Just $ default_RemoveE2EEPublicKey_result{removeE2EEPublicKey_result_e = removeE2EEPublicKey_result_e obj}
    ]
from_RemoveE2EEPublicKey_result :: RemoveE2EEPublicKey_result -> T.ThriftVal
from_RemoveE2EEPublicKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8738 -> (1, ("e",from_TalkException _v8738))) <$> removeE2EEPublicKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8738 -> (1, ("e",from_TalkException _v8738))) <$> removeE2EEPublicKey_result_e record
    ]
    )
write_RemoveE2EEPublicKey_result :: T.Protocol p => p -> RemoveE2EEPublicKey_result -> P.IO ()
write_RemoveE2EEPublicKey_result oprot record = T.writeVal oprot $ from_RemoveE2EEPublicKey_result record
encode_RemoveE2EEPublicKey_result :: T.StatelessProtocol p => p -> RemoveE2EEPublicKey_result -> LBS.ByteString
encode_RemoveE2EEPublicKey_result oprot record = T.serializeVal oprot $ from_RemoveE2EEPublicKey_result record
to_RemoveE2EEPublicKey_result :: T.ThriftVal -> RemoveE2EEPublicKey_result
to_RemoveE2EEPublicKey_result (T.TStruct fields) = RemoveE2EEPublicKey_result{
  removeE2EEPublicKey_result_e = P.maybe (P.Nothing) (\(_,_val8740) -> P.Just (case _val8740 of {T.TStruct _val8741 -> (to_TalkException (T.TStruct _val8741)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveE2EEPublicKey_result _ = P.error "not a struct"
read_RemoveE2EEPublicKey_result :: T.Protocol p => p -> P.IO RemoveE2EEPublicKey_result
read_RemoveE2EEPublicKey_result iprot = to_RemoveE2EEPublicKey_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveE2EEPublicKey_result)
decode_RemoveE2EEPublicKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveE2EEPublicKey_result
decode_RemoveE2EEPublicKey_result iprot bs = to_RemoveE2EEPublicKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveE2EEPublicKey_result) bs
typemap_RemoveE2EEPublicKey_result :: T.TypeMap
typemap_RemoveE2EEPublicKey_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveE2EEPublicKey_result :: RemoveE2EEPublicKey_result
default_RemoveE2EEPublicKey_result = RemoveE2EEPublicKey_result{
  removeE2EEPublicKey_result_e = P.Nothing}
data NegotiateE2EEPublicKey_args = NegotiateE2EEPublicKey_args  { negotiateE2EEPublicKey_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NegotiateE2EEPublicKey_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` negotiateE2EEPublicKey_args_mid record  
instance QC.Arbitrary NegotiateE2EEPublicKey_args where 
  arbitrary = M.liftM NegotiateE2EEPublicKey_args (QC.arbitrary)
  shrink obj | obj == default_NegotiateE2EEPublicKey_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NegotiateE2EEPublicKey_args{negotiateE2EEPublicKey_args_mid = negotiateE2EEPublicKey_args_mid obj} then P.Nothing else P.Just $ default_NegotiateE2EEPublicKey_args{negotiateE2EEPublicKey_args_mid = negotiateE2EEPublicKey_args_mid obj}
    ]
from_NegotiateE2EEPublicKey_args :: NegotiateE2EEPublicKey_args -> T.ThriftVal
from_NegotiateE2EEPublicKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8744 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v8744))) $ negotiateE2EEPublicKey_args_mid record
  ]
write_NegotiateE2EEPublicKey_args :: T.Protocol p => p -> NegotiateE2EEPublicKey_args -> P.IO ()
write_NegotiateE2EEPublicKey_args oprot record = T.writeVal oprot $ from_NegotiateE2EEPublicKey_args record
encode_NegotiateE2EEPublicKey_args :: T.StatelessProtocol p => p -> NegotiateE2EEPublicKey_args -> LBS.ByteString
encode_NegotiateE2EEPublicKey_args oprot record = T.serializeVal oprot $ from_NegotiateE2EEPublicKey_args record
to_NegotiateE2EEPublicKey_args :: T.ThriftVal -> NegotiateE2EEPublicKey_args
to_NegotiateE2EEPublicKey_args (T.TStruct fields) = NegotiateE2EEPublicKey_args{
  negotiateE2EEPublicKey_args_mid = P.maybe (negotiateE2EEPublicKey_args_mid default_NegotiateE2EEPublicKey_args) (\(_,_val8746) -> (case _val8746 of {T.TString _val8747 -> E.decodeUtf8 _val8747; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_NegotiateE2EEPublicKey_args _ = P.error "not a struct"
read_NegotiateE2EEPublicKey_args :: T.Protocol p => p -> P.IO NegotiateE2EEPublicKey_args
read_NegotiateE2EEPublicKey_args iprot = to_NegotiateE2EEPublicKey_args <$> T.readVal iprot (T.T_STRUCT typemap_NegotiateE2EEPublicKey_args)
decode_NegotiateE2EEPublicKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NegotiateE2EEPublicKey_args
decode_NegotiateE2EEPublicKey_args iprot bs = to_NegotiateE2EEPublicKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NegotiateE2EEPublicKey_args) bs
typemap_NegotiateE2EEPublicKey_args :: T.TypeMap
typemap_NegotiateE2EEPublicKey_args = Map.fromList [(2,("mid",T.T_STRING))]
default_NegotiateE2EEPublicKey_args :: NegotiateE2EEPublicKey_args
default_NegotiateE2EEPublicKey_args = NegotiateE2EEPublicKey_args{
  negotiateE2EEPublicKey_args_mid = ""}
data NegotiateE2EEPublicKey_result = NegotiateE2EEPublicKey_result  { negotiateE2EEPublicKey_result_success :: E2EENegotiationResult
  , negotiateE2EEPublicKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NegotiateE2EEPublicKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` negotiateE2EEPublicKey_result_success record   `H.hashWithSalt` negotiateE2EEPublicKey_result_e record  
instance QC.Arbitrary NegotiateE2EEPublicKey_result where 
  arbitrary = M.liftM NegotiateE2EEPublicKey_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NegotiateE2EEPublicKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_success = negotiateE2EEPublicKey_result_success obj} then P.Nothing else P.Just $ default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_success = negotiateE2EEPublicKey_result_success obj}
    , if obj == default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_e = negotiateE2EEPublicKey_result_e obj} then P.Nothing else P.Just $ default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_e = negotiateE2EEPublicKey_result_e obj}
    ]
from_NegotiateE2EEPublicKey_result :: NegotiateE2EEPublicKey_result -> T.ThriftVal
from_NegotiateE2EEPublicKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8750 -> (1, ("e",from_TalkException _v8750))) <$> negotiateE2EEPublicKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8750 -> P.Just (0, ("success",from_E2EENegotiationResult _v8750))) $ negotiateE2EEPublicKey_result_success record
    , (\_v8750 -> (1, ("e",from_TalkException _v8750))) <$> negotiateE2EEPublicKey_result_e record
    ]
    )
write_NegotiateE2EEPublicKey_result :: T.Protocol p => p -> NegotiateE2EEPublicKey_result -> P.IO ()
write_NegotiateE2EEPublicKey_result oprot record = T.writeVal oprot $ from_NegotiateE2EEPublicKey_result record
encode_NegotiateE2EEPublicKey_result :: T.StatelessProtocol p => p -> NegotiateE2EEPublicKey_result -> LBS.ByteString
encode_NegotiateE2EEPublicKey_result oprot record = T.serializeVal oprot $ from_NegotiateE2EEPublicKey_result record
to_NegotiateE2EEPublicKey_result :: T.ThriftVal -> NegotiateE2EEPublicKey_result
to_NegotiateE2EEPublicKey_result (T.TStruct fields) = NegotiateE2EEPublicKey_result{
  negotiateE2EEPublicKey_result_success = P.maybe (negotiateE2EEPublicKey_result_success default_NegotiateE2EEPublicKey_result) (\(_,_val8752) -> (case _val8752 of {T.TStruct _val8753 -> (to_E2EENegotiationResult (T.TStruct _val8753)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  negotiateE2EEPublicKey_result_e = P.maybe (P.Nothing) (\(_,_val8752) -> P.Just (case _val8752 of {T.TStruct _val8754 -> (to_TalkException (T.TStruct _val8754)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NegotiateE2EEPublicKey_result _ = P.error "not a struct"
read_NegotiateE2EEPublicKey_result :: T.Protocol p => p -> P.IO NegotiateE2EEPublicKey_result
read_NegotiateE2EEPublicKey_result iprot = to_NegotiateE2EEPublicKey_result <$> T.readVal iprot (T.T_STRUCT typemap_NegotiateE2EEPublicKey_result)
decode_NegotiateE2EEPublicKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NegotiateE2EEPublicKey_result
decode_NegotiateE2EEPublicKey_result iprot bs = to_NegotiateE2EEPublicKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NegotiateE2EEPublicKey_result) bs
typemap_NegotiateE2EEPublicKey_result :: T.TypeMap
typemap_NegotiateE2EEPublicKey_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_E2EENegotiationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NegotiateE2EEPublicKey_result :: NegotiateE2EEPublicKey_result
default_NegotiateE2EEPublicKey_result = NegotiateE2EEPublicKey_result{
  negotiateE2EEPublicKey_result_success = default_E2EENegotiationResult,
  negotiateE2EEPublicKey_result_e = P.Nothing}
data GetE2EEPublicKey_args = GetE2EEPublicKey_args  { getE2EEPublicKey_args_mid :: LT.Text
  , getE2EEPublicKey_args_version :: I.Int32
  , getE2EEPublicKey_args_keyId :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKey_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getE2EEPublicKey_args_mid record   `H.hashWithSalt` getE2EEPublicKey_args_version record   `H.hashWithSalt` getE2EEPublicKey_args_keyId record  
instance QC.Arbitrary GetE2EEPublicKey_args where 
  arbitrary = M.liftM GetE2EEPublicKey_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetE2EEPublicKey_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetE2EEPublicKey_args{getE2EEPublicKey_args_mid = getE2EEPublicKey_args_mid obj} then P.Nothing else P.Just $ default_GetE2EEPublicKey_args{getE2EEPublicKey_args_mid = getE2EEPublicKey_args_mid obj}
    , if obj == default_GetE2EEPublicKey_args{getE2EEPublicKey_args_version = getE2EEPublicKey_args_version obj} then P.Nothing else P.Just $ default_GetE2EEPublicKey_args{getE2EEPublicKey_args_version = getE2EEPublicKey_args_version obj}
    , if obj == default_GetE2EEPublicKey_args{getE2EEPublicKey_args_keyId = getE2EEPublicKey_args_keyId obj} then P.Nothing else P.Just $ default_GetE2EEPublicKey_args{getE2EEPublicKey_args_keyId = getE2EEPublicKey_args_keyId obj}
    ]
from_GetE2EEPublicKey_args :: GetE2EEPublicKey_args -> T.ThriftVal
from_GetE2EEPublicKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8757 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v8757))) $ getE2EEPublicKey_args_mid record
  , (\_v8757 -> P.Just (3, ("version",T.TI32 _v8757))) $ getE2EEPublicKey_args_version record
  , (\_v8757 -> P.Just (4, ("keyId",T.TI32 _v8757))) $ getE2EEPublicKey_args_keyId record
  ]
write_GetE2EEPublicKey_args :: T.Protocol p => p -> GetE2EEPublicKey_args -> P.IO ()
write_GetE2EEPublicKey_args oprot record = T.writeVal oprot $ from_GetE2EEPublicKey_args record
encode_GetE2EEPublicKey_args :: T.StatelessProtocol p => p -> GetE2EEPublicKey_args -> LBS.ByteString
encode_GetE2EEPublicKey_args oprot record = T.serializeVal oprot $ from_GetE2EEPublicKey_args record
to_GetE2EEPublicKey_args :: T.ThriftVal -> GetE2EEPublicKey_args
to_GetE2EEPublicKey_args (T.TStruct fields) = GetE2EEPublicKey_args{
  getE2EEPublicKey_args_mid = P.maybe (getE2EEPublicKey_args_mid default_GetE2EEPublicKey_args) (\(_,_val8759) -> (case _val8759 of {T.TString _val8760 -> E.decodeUtf8 _val8760; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getE2EEPublicKey_args_version = P.maybe (getE2EEPublicKey_args_version default_GetE2EEPublicKey_args) (\(_,_val8759) -> (case _val8759 of {T.TI32 _val8761 -> _val8761; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getE2EEPublicKey_args_keyId = P.maybe (getE2EEPublicKey_args_keyId default_GetE2EEPublicKey_args) (\(_,_val8759) -> (case _val8759 of {T.TI32 _val8762 -> _val8762; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetE2EEPublicKey_args _ = P.error "not a struct"
read_GetE2EEPublicKey_args :: T.Protocol p => p -> P.IO GetE2EEPublicKey_args
read_GetE2EEPublicKey_args iprot = to_GetE2EEPublicKey_args <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKey_args)
decode_GetE2EEPublicKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKey_args
decode_GetE2EEPublicKey_args iprot bs = to_GetE2EEPublicKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKey_args) bs
typemap_GetE2EEPublicKey_args :: T.TypeMap
typemap_GetE2EEPublicKey_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("version",T.T_I32)),(4,("keyId",T.T_I32))]
default_GetE2EEPublicKey_args :: GetE2EEPublicKey_args
default_GetE2EEPublicKey_args = GetE2EEPublicKey_args{
  getE2EEPublicKey_args_mid = "",
  getE2EEPublicKey_args_version = 0,
  getE2EEPublicKey_args_keyId = 0}
data GetE2EEPublicKey_result = GetE2EEPublicKey_result  { getE2EEPublicKey_result_success :: E2EEPublicKey
  , getE2EEPublicKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getE2EEPublicKey_result_success record   `H.hashWithSalt` getE2EEPublicKey_result_e record  
instance QC.Arbitrary GetE2EEPublicKey_result where 
  arbitrary = M.liftM GetE2EEPublicKey_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetE2EEPublicKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetE2EEPublicKey_result{getE2EEPublicKey_result_success = getE2EEPublicKey_result_success obj} then P.Nothing else P.Just $ default_GetE2EEPublicKey_result{getE2EEPublicKey_result_success = getE2EEPublicKey_result_success obj}
    , if obj == default_GetE2EEPublicKey_result{getE2EEPublicKey_result_e = getE2EEPublicKey_result_e obj} then P.Nothing else P.Just $ default_GetE2EEPublicKey_result{getE2EEPublicKey_result_e = getE2EEPublicKey_result_e obj}
    ]
from_GetE2EEPublicKey_result :: GetE2EEPublicKey_result -> T.ThriftVal
from_GetE2EEPublicKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8765 -> (1, ("e",from_TalkException _v8765))) <$> getE2EEPublicKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8765 -> P.Just (0, ("success",from_E2EEPublicKey _v8765))) $ getE2EEPublicKey_result_success record
    , (\_v8765 -> (1, ("e",from_TalkException _v8765))) <$> getE2EEPublicKey_result_e record
    ]
    )
write_GetE2EEPublicKey_result :: T.Protocol p => p -> GetE2EEPublicKey_result -> P.IO ()
write_GetE2EEPublicKey_result oprot record = T.writeVal oprot $ from_GetE2EEPublicKey_result record
encode_GetE2EEPublicKey_result :: T.StatelessProtocol p => p -> GetE2EEPublicKey_result -> LBS.ByteString
encode_GetE2EEPublicKey_result oprot record = T.serializeVal oprot $ from_GetE2EEPublicKey_result record
to_GetE2EEPublicKey_result :: T.ThriftVal -> GetE2EEPublicKey_result
to_GetE2EEPublicKey_result (T.TStruct fields) = GetE2EEPublicKey_result{
  getE2EEPublicKey_result_success = P.maybe (getE2EEPublicKey_result_success default_GetE2EEPublicKey_result) (\(_,_val8767) -> (case _val8767 of {T.TStruct _val8768 -> (to_E2EEPublicKey (T.TStruct _val8768)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getE2EEPublicKey_result_e = P.maybe (P.Nothing) (\(_,_val8767) -> P.Just (case _val8767 of {T.TStruct _val8769 -> (to_TalkException (T.TStruct _val8769)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetE2EEPublicKey_result _ = P.error "not a struct"
read_GetE2EEPublicKey_result :: T.Protocol p => p -> P.IO GetE2EEPublicKey_result
read_GetE2EEPublicKey_result iprot = to_GetE2EEPublicKey_result <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKey_result)
decode_GetE2EEPublicKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKey_result
decode_GetE2EEPublicKey_result iprot bs = to_GetE2EEPublicKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKey_result) bs
typemap_GetE2EEPublicKey_result :: T.TypeMap
typemap_GetE2EEPublicKey_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_E2EEPublicKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetE2EEPublicKey_result :: GetE2EEPublicKey_result
default_GetE2EEPublicKey_result = GetE2EEPublicKey_result{
  getE2EEPublicKey_result_success = default_E2EEPublicKey,
  getE2EEPublicKey_result_e = P.Nothing}
data RequestE2EEKeyExchange_args = RequestE2EEKeyExchange_args  { requestE2EEKeyExchange_args_reqSeq :: I.Int32
  , requestE2EEKeyExchange_args_temporalPublicKey :: LBS.ByteString
  , requestE2EEKeyExchange_args_publicKey :: E2EEPublicKey
  , requestE2EEKeyExchange_args_verifier :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestE2EEKeyExchange_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestE2EEKeyExchange_args_reqSeq record   `H.hashWithSalt` requestE2EEKeyExchange_args_temporalPublicKey record   `H.hashWithSalt` requestE2EEKeyExchange_args_publicKey record   `H.hashWithSalt` requestE2EEKeyExchange_args_verifier record  
instance QC.Arbitrary RequestE2EEKeyExchange_args where 
  arbitrary = M.liftM RequestE2EEKeyExchange_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RequestE2EEKeyExchange_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_reqSeq = requestE2EEKeyExchange_args_reqSeq obj} then P.Nothing else P.Just $ default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_reqSeq = requestE2EEKeyExchange_args_reqSeq obj}
    , if obj == default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_temporalPublicKey = requestE2EEKeyExchange_args_temporalPublicKey obj} then P.Nothing else P.Just $ default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_temporalPublicKey = requestE2EEKeyExchange_args_temporalPublicKey obj}
    , if obj == default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_publicKey = requestE2EEKeyExchange_args_publicKey obj} then P.Nothing else P.Just $ default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_publicKey = requestE2EEKeyExchange_args_publicKey obj}
    , if obj == default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_verifier = requestE2EEKeyExchange_args_verifier obj} then P.Nothing else P.Just $ default_RequestE2EEKeyExchange_args{requestE2EEKeyExchange_args_verifier = requestE2EEKeyExchange_args_verifier obj}
    ]
from_RequestE2EEKeyExchange_args :: RequestE2EEKeyExchange_args -> T.ThriftVal
from_RequestE2EEKeyExchange_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8772 -> P.Just (1, ("reqSeq",T.TI32 _v8772))) $ requestE2EEKeyExchange_args_reqSeq record
  , (\_v8772 -> P.Just (2, ("temporalPublicKey",T.TBinary _v8772))) $ requestE2EEKeyExchange_args_temporalPublicKey record
  , (\_v8772 -> P.Just (3, ("publicKey",from_E2EEPublicKey _v8772))) $ requestE2EEKeyExchange_args_publicKey record
  , (\_v8772 -> P.Just (4, ("verifier",T.TBinary _v8772))) $ requestE2EEKeyExchange_args_verifier record
  ]
write_RequestE2EEKeyExchange_args :: T.Protocol p => p -> RequestE2EEKeyExchange_args -> P.IO ()
write_RequestE2EEKeyExchange_args oprot record = T.writeVal oprot $ from_RequestE2EEKeyExchange_args record
encode_RequestE2EEKeyExchange_args :: T.StatelessProtocol p => p -> RequestE2EEKeyExchange_args -> LBS.ByteString
encode_RequestE2EEKeyExchange_args oprot record = T.serializeVal oprot $ from_RequestE2EEKeyExchange_args record
to_RequestE2EEKeyExchange_args :: T.ThriftVal -> RequestE2EEKeyExchange_args
to_RequestE2EEKeyExchange_args (T.TStruct fields) = RequestE2EEKeyExchange_args{
  requestE2EEKeyExchange_args_reqSeq = P.maybe (requestE2EEKeyExchange_args_reqSeq default_RequestE2EEKeyExchange_args) (\(_,_val8774) -> (case _val8774 of {T.TI32 _val8775 -> _val8775; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  requestE2EEKeyExchange_args_temporalPublicKey = P.maybe (requestE2EEKeyExchange_args_temporalPublicKey default_RequestE2EEKeyExchange_args) (\(_,_val8774) -> (case _val8774 of {T.TBinary _val8776 -> _val8776; T.TString _val8776 -> _val8776; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  requestE2EEKeyExchange_args_publicKey = P.maybe (requestE2EEKeyExchange_args_publicKey default_RequestE2EEKeyExchange_args) (\(_,_val8774) -> (case _val8774 of {T.TStruct _val8777 -> (to_E2EEPublicKey (T.TStruct _val8777)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  requestE2EEKeyExchange_args_verifier = P.maybe (requestE2EEKeyExchange_args_verifier default_RequestE2EEKeyExchange_args) (\(_,_val8774) -> (case _val8774 of {T.TBinary _val8778 -> _val8778; T.TString _val8778 -> _val8778; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_RequestE2EEKeyExchange_args _ = P.error "not a struct"
read_RequestE2EEKeyExchange_args :: T.Protocol p => p -> P.IO RequestE2EEKeyExchange_args
read_RequestE2EEKeyExchange_args iprot = to_RequestE2EEKeyExchange_args <$> T.readVal iprot (T.T_STRUCT typemap_RequestE2EEKeyExchange_args)
decode_RequestE2EEKeyExchange_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestE2EEKeyExchange_args
decode_RequestE2EEKeyExchange_args iprot bs = to_RequestE2EEKeyExchange_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestE2EEKeyExchange_args) bs
typemap_RequestE2EEKeyExchange_args :: T.TypeMap
typemap_RequestE2EEKeyExchange_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("temporalPublicKey",T.T_BINARY)),(3,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey))),(4,("verifier",T.T_BINARY))]
default_RequestE2EEKeyExchange_args :: RequestE2EEKeyExchange_args
default_RequestE2EEKeyExchange_args = RequestE2EEKeyExchange_args{
  requestE2EEKeyExchange_args_reqSeq = 0,
  requestE2EEKeyExchange_args_temporalPublicKey = "",
  requestE2EEKeyExchange_args_publicKey = default_E2EEPublicKey,
  requestE2EEKeyExchange_args_verifier = ""}
data RequestE2EEKeyExchange_result = RequestE2EEKeyExchange_result  { requestE2EEKeyExchange_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RequestE2EEKeyExchange_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` requestE2EEKeyExchange_result_e record  
instance QC.Arbitrary RequestE2EEKeyExchange_result where 
  arbitrary = M.liftM RequestE2EEKeyExchange_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RequestE2EEKeyExchange_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RequestE2EEKeyExchange_result{requestE2EEKeyExchange_result_e = requestE2EEKeyExchange_result_e obj} then P.Nothing else P.Just $ default_RequestE2EEKeyExchange_result{requestE2EEKeyExchange_result_e = requestE2EEKeyExchange_result_e obj}
    ]
from_RequestE2EEKeyExchange_result :: RequestE2EEKeyExchange_result -> T.ThriftVal
from_RequestE2EEKeyExchange_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8781 -> (1, ("e",from_TalkException _v8781))) <$> requestE2EEKeyExchange_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8781 -> (1, ("e",from_TalkException _v8781))) <$> requestE2EEKeyExchange_result_e record
    ]
    )
write_RequestE2EEKeyExchange_result :: T.Protocol p => p -> RequestE2EEKeyExchange_result -> P.IO ()
write_RequestE2EEKeyExchange_result oprot record = T.writeVal oprot $ from_RequestE2EEKeyExchange_result record
encode_RequestE2EEKeyExchange_result :: T.StatelessProtocol p => p -> RequestE2EEKeyExchange_result -> LBS.ByteString
encode_RequestE2EEKeyExchange_result oprot record = T.serializeVal oprot $ from_RequestE2EEKeyExchange_result record
to_RequestE2EEKeyExchange_result :: T.ThriftVal -> RequestE2EEKeyExchange_result
to_RequestE2EEKeyExchange_result (T.TStruct fields) = RequestE2EEKeyExchange_result{
  requestE2EEKeyExchange_result_e = P.maybe (P.Nothing) (\(_,_val8783) -> P.Just (case _val8783 of {T.TStruct _val8784 -> (to_TalkException (T.TStruct _val8784)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RequestE2EEKeyExchange_result _ = P.error "not a struct"
read_RequestE2EEKeyExchange_result :: T.Protocol p => p -> P.IO RequestE2EEKeyExchange_result
read_RequestE2EEKeyExchange_result iprot = to_RequestE2EEKeyExchange_result <$> T.readVal iprot (T.T_STRUCT typemap_RequestE2EEKeyExchange_result)
decode_RequestE2EEKeyExchange_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RequestE2EEKeyExchange_result
decode_RequestE2EEKeyExchange_result iprot bs = to_RequestE2EEKeyExchange_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RequestE2EEKeyExchange_result) bs
typemap_RequestE2EEKeyExchange_result :: T.TypeMap
typemap_RequestE2EEKeyExchange_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RequestE2EEKeyExchange_result :: RequestE2EEKeyExchange_result
default_RequestE2EEKeyExchange_result = RequestE2EEKeyExchange_result{
  requestE2EEKeyExchange_result_e = P.Nothing}
data GetLastE2EEPublicKeys_args = GetLastE2EEPublicKeys_args  { getLastE2EEPublicKeys_args_chatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastE2EEPublicKeys_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastE2EEPublicKeys_args_chatMid record  
instance QC.Arbitrary GetLastE2EEPublicKeys_args where 
  arbitrary = M.liftM GetLastE2EEPublicKeys_args (QC.arbitrary)
  shrink obj | obj == default_GetLastE2EEPublicKeys_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastE2EEPublicKeys_args{getLastE2EEPublicKeys_args_chatMid = getLastE2EEPublicKeys_args_chatMid obj} then P.Nothing else P.Just $ default_GetLastE2EEPublicKeys_args{getLastE2EEPublicKeys_args_chatMid = getLastE2EEPublicKeys_args_chatMid obj}
    ]
from_GetLastE2EEPublicKeys_args :: GetLastE2EEPublicKeys_args -> T.ThriftVal
from_GetLastE2EEPublicKeys_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8787 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v8787))) $ getLastE2EEPublicKeys_args_chatMid record
  ]
write_GetLastE2EEPublicKeys_args :: T.Protocol p => p -> GetLastE2EEPublicKeys_args -> P.IO ()
write_GetLastE2EEPublicKeys_args oprot record = T.writeVal oprot $ from_GetLastE2EEPublicKeys_args record
encode_GetLastE2EEPublicKeys_args :: T.StatelessProtocol p => p -> GetLastE2EEPublicKeys_args -> LBS.ByteString
encode_GetLastE2EEPublicKeys_args oprot record = T.serializeVal oprot $ from_GetLastE2EEPublicKeys_args record
to_GetLastE2EEPublicKeys_args :: T.ThriftVal -> GetLastE2EEPublicKeys_args
to_GetLastE2EEPublicKeys_args (T.TStruct fields) = GetLastE2EEPublicKeys_args{
  getLastE2EEPublicKeys_args_chatMid = P.maybe (getLastE2EEPublicKeys_args_chatMid default_GetLastE2EEPublicKeys_args) (\(_,_val8789) -> (case _val8789 of {T.TString _val8790 -> E.decodeUtf8 _val8790; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetLastE2EEPublicKeys_args _ = P.error "not a struct"
read_GetLastE2EEPublicKeys_args :: T.Protocol p => p -> P.IO GetLastE2EEPublicKeys_args
read_GetLastE2EEPublicKeys_args iprot = to_GetLastE2EEPublicKeys_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLastE2EEPublicKeys_args)
decode_GetLastE2EEPublicKeys_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastE2EEPublicKeys_args
decode_GetLastE2EEPublicKeys_args iprot bs = to_GetLastE2EEPublicKeys_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastE2EEPublicKeys_args) bs
typemap_GetLastE2EEPublicKeys_args :: T.TypeMap
typemap_GetLastE2EEPublicKeys_args = Map.fromList [(2,("chatMid",T.T_STRING))]
default_GetLastE2EEPublicKeys_args :: GetLastE2EEPublicKeys_args
default_GetLastE2EEPublicKeys_args = GetLastE2EEPublicKeys_args{
  getLastE2EEPublicKeys_args_chatMid = ""}
data GetLastE2EEPublicKeys_result = GetLastE2EEPublicKeys_result  { getLastE2EEPublicKeys_result_success :: (Map.HashMap LT.Text E2EEPublicKey)
  , getLastE2EEPublicKeys_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLastE2EEPublicKeys_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLastE2EEPublicKeys_result_success record   `H.hashWithSalt` getLastE2EEPublicKeys_result_e record  
instance QC.Arbitrary GetLastE2EEPublicKeys_result where 
  arbitrary = M.liftM GetLastE2EEPublicKeys_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLastE2EEPublicKeys_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_success = getLastE2EEPublicKeys_result_success obj} then P.Nothing else P.Just $ default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_success = getLastE2EEPublicKeys_result_success obj}
    , if obj == default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_e = getLastE2EEPublicKeys_result_e obj} then P.Nothing else P.Just $ default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_e = getLastE2EEPublicKeys_result_e obj}
    ]
from_GetLastE2EEPublicKeys_result :: GetLastE2EEPublicKeys_result -> T.ThriftVal
from_GetLastE2EEPublicKeys_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8793 -> (1, ("e",from_TalkException _v8793))) <$> getLastE2EEPublicKeys_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8793 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_E2EEPublicKey) $ P.map (\(_k8794,_v8795) -> (T.TString $ E.encodeUtf8 _k8794, from_E2EEPublicKey _v8795)) $ Map.toList _v8793))) $ getLastE2EEPublicKeys_result_success record
    , (\_v8793 -> (1, ("e",from_TalkException _v8793))) <$> getLastE2EEPublicKeys_result_e record
    ]
    )
write_GetLastE2EEPublicKeys_result :: T.Protocol p => p -> GetLastE2EEPublicKeys_result -> P.IO ()
write_GetLastE2EEPublicKeys_result oprot record = T.writeVal oprot $ from_GetLastE2EEPublicKeys_result record
encode_GetLastE2EEPublicKeys_result :: T.StatelessProtocol p => p -> GetLastE2EEPublicKeys_result -> LBS.ByteString
encode_GetLastE2EEPublicKeys_result oprot record = T.serializeVal oprot $ from_GetLastE2EEPublicKeys_result record
to_GetLastE2EEPublicKeys_result :: T.ThriftVal -> GetLastE2EEPublicKeys_result
to_GetLastE2EEPublicKeys_result (T.TStruct fields) = GetLastE2EEPublicKeys_result{
  getLastE2EEPublicKeys_result_success = P.maybe (getLastE2EEPublicKeys_result_success default_GetLastE2EEPublicKeys_result) (\(_,_val8797) -> (case _val8797 of {T.TMap _ _ _val8798 -> (Map.fromList $ P.map (\(_k8800,_v8799) -> ((case _k8800 of {T.TString _val8801 -> E.decodeUtf8 _val8801; _ -> P.error "wrong type"}),(case _v8799 of {T.TStruct _val8802 -> (to_E2EEPublicKey (T.TStruct _val8802)); _ -> P.error "wrong type"}))) _val8798); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLastE2EEPublicKeys_result_e = P.maybe (P.Nothing) (\(_,_val8797) -> P.Just (case _val8797 of {T.TStruct _val8803 -> (to_TalkException (T.TStruct _val8803)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetLastE2EEPublicKeys_result _ = P.error "not a struct"
read_GetLastE2EEPublicKeys_result :: T.Protocol p => p -> P.IO GetLastE2EEPublicKeys_result
read_GetLastE2EEPublicKeys_result iprot = to_GetLastE2EEPublicKeys_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLastE2EEPublicKeys_result)
decode_GetLastE2EEPublicKeys_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLastE2EEPublicKeys_result
decode_GetLastE2EEPublicKeys_result iprot bs = to_GetLastE2EEPublicKeys_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLastE2EEPublicKeys_result) bs
typemap_GetLastE2EEPublicKeys_result :: T.TypeMap
typemap_GetLastE2EEPublicKeys_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_E2EEPublicKey)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetLastE2EEPublicKeys_result :: GetLastE2EEPublicKeys_result
default_GetLastE2EEPublicKeys_result = GetLastE2EEPublicKeys_result{
  getLastE2EEPublicKeys_result_success = Map.empty,
  getLastE2EEPublicKeys_result_e = P.Nothing}
data RegisterE2EEPublicKey_args = RegisterE2EEPublicKey_args  { registerE2EEPublicKey_args_reqSeq :: I.Int32
  , registerE2EEPublicKey_args_publicKey :: E2EEPublicKey
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterE2EEPublicKey_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerE2EEPublicKey_args_reqSeq record   `H.hashWithSalt` registerE2EEPublicKey_args_publicKey record  
instance QC.Arbitrary RegisterE2EEPublicKey_args where 
  arbitrary = M.liftM RegisterE2EEPublicKey_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterE2EEPublicKey_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterE2EEPublicKey_args{registerE2EEPublicKey_args_reqSeq = registerE2EEPublicKey_args_reqSeq obj} then P.Nothing else P.Just $ default_RegisterE2EEPublicKey_args{registerE2EEPublicKey_args_reqSeq = registerE2EEPublicKey_args_reqSeq obj}
    , if obj == default_RegisterE2EEPublicKey_args{registerE2EEPublicKey_args_publicKey = registerE2EEPublicKey_args_publicKey obj} then P.Nothing else P.Just $ default_RegisterE2EEPublicKey_args{registerE2EEPublicKey_args_publicKey = registerE2EEPublicKey_args_publicKey obj}
    ]
from_RegisterE2EEPublicKey_args :: RegisterE2EEPublicKey_args -> T.ThriftVal
from_RegisterE2EEPublicKey_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8806 -> P.Just (1, ("reqSeq",T.TI32 _v8806))) $ registerE2EEPublicKey_args_reqSeq record
  , (\_v8806 -> P.Just (2, ("publicKey",from_E2EEPublicKey _v8806))) $ registerE2EEPublicKey_args_publicKey record
  ]
write_RegisterE2EEPublicKey_args :: T.Protocol p => p -> RegisterE2EEPublicKey_args -> P.IO ()
write_RegisterE2EEPublicKey_args oprot record = T.writeVal oprot $ from_RegisterE2EEPublicKey_args record
encode_RegisterE2EEPublicKey_args :: T.StatelessProtocol p => p -> RegisterE2EEPublicKey_args -> LBS.ByteString
encode_RegisterE2EEPublicKey_args oprot record = T.serializeVal oprot $ from_RegisterE2EEPublicKey_args record
to_RegisterE2EEPublicKey_args :: T.ThriftVal -> RegisterE2EEPublicKey_args
to_RegisterE2EEPublicKey_args (T.TStruct fields) = RegisterE2EEPublicKey_args{
  registerE2EEPublicKey_args_reqSeq = P.maybe (registerE2EEPublicKey_args_reqSeq default_RegisterE2EEPublicKey_args) (\(_,_val8808) -> (case _val8808 of {T.TI32 _val8809 -> _val8809; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  registerE2EEPublicKey_args_publicKey = P.maybe (registerE2EEPublicKey_args_publicKey default_RegisterE2EEPublicKey_args) (\(_,_val8808) -> (case _val8808 of {T.TStruct _val8810 -> (to_E2EEPublicKey (T.TStruct _val8810)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RegisterE2EEPublicKey_args _ = P.error "not a struct"
read_RegisterE2EEPublicKey_args :: T.Protocol p => p -> P.IO RegisterE2EEPublicKey_args
read_RegisterE2EEPublicKey_args iprot = to_RegisterE2EEPublicKey_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterE2EEPublicKey_args)
decode_RegisterE2EEPublicKey_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterE2EEPublicKey_args
decode_RegisterE2EEPublicKey_args iprot bs = to_RegisterE2EEPublicKey_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterE2EEPublicKey_args) bs
typemap_RegisterE2EEPublicKey_args :: T.TypeMap
typemap_RegisterE2EEPublicKey_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("publicKey",(T.T_STRUCT typemap_E2EEPublicKey)))]
default_RegisterE2EEPublicKey_args :: RegisterE2EEPublicKey_args
default_RegisterE2EEPublicKey_args = RegisterE2EEPublicKey_args{
  registerE2EEPublicKey_args_reqSeq = 0,
  registerE2EEPublicKey_args_publicKey = default_E2EEPublicKey}
data RegisterE2EEPublicKey_result = RegisterE2EEPublicKey_result  { registerE2EEPublicKey_result_success :: E2EEPublicKey
  , registerE2EEPublicKey_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterE2EEPublicKey_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerE2EEPublicKey_result_success record   `H.hashWithSalt` registerE2EEPublicKey_result_e record  
instance QC.Arbitrary RegisterE2EEPublicKey_result where 
  arbitrary = M.liftM RegisterE2EEPublicKey_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterE2EEPublicKey_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_success = registerE2EEPublicKey_result_success obj} then P.Nothing else P.Just $ default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_success = registerE2EEPublicKey_result_success obj}
    , if obj == default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_e = registerE2EEPublicKey_result_e obj} then P.Nothing else P.Just $ default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_e = registerE2EEPublicKey_result_e obj}
    ]
from_RegisterE2EEPublicKey_result :: RegisterE2EEPublicKey_result -> T.ThriftVal
from_RegisterE2EEPublicKey_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8813 -> (1, ("e",from_TalkException _v8813))) <$> registerE2EEPublicKey_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8813 -> P.Just (0, ("success",from_E2EEPublicKey _v8813))) $ registerE2EEPublicKey_result_success record
    , (\_v8813 -> (1, ("e",from_TalkException _v8813))) <$> registerE2EEPublicKey_result_e record
    ]
    )
write_RegisterE2EEPublicKey_result :: T.Protocol p => p -> RegisterE2EEPublicKey_result -> P.IO ()
write_RegisterE2EEPublicKey_result oprot record = T.writeVal oprot $ from_RegisterE2EEPublicKey_result record
encode_RegisterE2EEPublicKey_result :: T.StatelessProtocol p => p -> RegisterE2EEPublicKey_result -> LBS.ByteString
encode_RegisterE2EEPublicKey_result oprot record = T.serializeVal oprot $ from_RegisterE2EEPublicKey_result record
to_RegisterE2EEPublicKey_result :: T.ThriftVal -> RegisterE2EEPublicKey_result
to_RegisterE2EEPublicKey_result (T.TStruct fields) = RegisterE2EEPublicKey_result{
  registerE2EEPublicKey_result_success = P.maybe (registerE2EEPublicKey_result_success default_RegisterE2EEPublicKey_result) (\(_,_val8815) -> (case _val8815 of {T.TStruct _val8816 -> (to_E2EEPublicKey (T.TStruct _val8816)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerE2EEPublicKey_result_e = P.maybe (P.Nothing) (\(_,_val8815) -> P.Just (case _val8815 of {T.TStruct _val8817 -> (to_TalkException (T.TStruct _val8817)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterE2EEPublicKey_result _ = P.error "not a struct"
read_RegisterE2EEPublicKey_result :: T.Protocol p => p -> P.IO RegisterE2EEPublicKey_result
read_RegisterE2EEPublicKey_result iprot = to_RegisterE2EEPublicKey_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterE2EEPublicKey_result)
decode_RegisterE2EEPublicKey_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterE2EEPublicKey_result
decode_RegisterE2EEPublicKey_result iprot bs = to_RegisterE2EEPublicKey_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterE2EEPublicKey_result) bs
typemap_RegisterE2EEPublicKey_result :: T.TypeMap
typemap_RegisterE2EEPublicKey_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_E2EEPublicKey))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterE2EEPublicKey_result :: RegisterE2EEPublicKey_result
default_RegisterE2EEPublicKey_result = RegisterE2EEPublicKey_result{
  registerE2EEPublicKey_result_success = default_E2EEPublicKey,
  registerE2EEPublicKey_result_e = P.Nothing}
data GetE2EEPublicKeys_args = GetE2EEPublicKeys_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKeys_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetE2EEPublicKeys_args where 
  arbitrary = QC.elements [GetE2EEPublicKeys_args]
from_GetE2EEPublicKeys_args :: GetE2EEPublicKeys_args -> T.ThriftVal
from_GetE2EEPublicKeys_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetE2EEPublicKeys_args :: T.Protocol p => p -> GetE2EEPublicKeys_args -> P.IO ()
write_GetE2EEPublicKeys_args oprot record = T.writeVal oprot $ from_GetE2EEPublicKeys_args record
encode_GetE2EEPublicKeys_args :: T.StatelessProtocol p => p -> GetE2EEPublicKeys_args -> LBS.ByteString
encode_GetE2EEPublicKeys_args oprot record = T.serializeVal oprot $ from_GetE2EEPublicKeys_args record
to_GetE2EEPublicKeys_args :: T.ThriftVal -> GetE2EEPublicKeys_args
to_GetE2EEPublicKeys_args (T.TStruct fields) = GetE2EEPublicKeys_args{

  }
to_GetE2EEPublicKeys_args _ = P.error "not a struct"
read_GetE2EEPublicKeys_args :: T.Protocol p => p -> P.IO GetE2EEPublicKeys_args
read_GetE2EEPublicKeys_args iprot = to_GetE2EEPublicKeys_args <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeys_args)
decode_GetE2EEPublicKeys_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKeys_args
decode_GetE2EEPublicKeys_args iprot bs = to_GetE2EEPublicKeys_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeys_args) bs
typemap_GetE2EEPublicKeys_args :: T.TypeMap
typemap_GetE2EEPublicKeys_args = Map.fromList []
default_GetE2EEPublicKeys_args :: GetE2EEPublicKeys_args
default_GetE2EEPublicKeys_args = GetE2EEPublicKeys_args{
}
data GetE2EEPublicKeys_result = GetE2EEPublicKeys_result  { getE2EEPublicKeys_result_success :: (Vector.Vector E2EEPublicKey)
  , getE2EEPublicKeys_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKeys_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getE2EEPublicKeys_result_success record   `H.hashWithSalt` getE2EEPublicKeys_result_e record  
instance QC.Arbitrary GetE2EEPublicKeys_result where 
  arbitrary = M.liftM GetE2EEPublicKeys_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetE2EEPublicKeys_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_success = getE2EEPublicKeys_result_success obj} then P.Nothing else P.Just $ default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_success = getE2EEPublicKeys_result_success obj}
    , if obj == default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_e = getE2EEPublicKeys_result_e obj} then P.Nothing else P.Just $ default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_e = getE2EEPublicKeys_result_e obj}
    ]
from_GetE2EEPublicKeys_result :: GetE2EEPublicKeys_result -> T.ThriftVal
from_GetE2EEPublicKeys_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8825 -> (1, ("e",from_TalkException _v8825))) <$> getE2EEPublicKeys_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8825 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_E2EEPublicKey) $ P.map (\_v8827 -> from_E2EEPublicKey _v8827) $ Vector.toList _v8825))) $ getE2EEPublicKeys_result_success record
    , (\_v8825 -> (1, ("e",from_TalkException _v8825))) <$> getE2EEPublicKeys_result_e record
    ]
    )
write_GetE2EEPublicKeys_result :: T.Protocol p => p -> GetE2EEPublicKeys_result -> P.IO ()
write_GetE2EEPublicKeys_result oprot record = T.writeVal oprot $ from_GetE2EEPublicKeys_result record
encode_GetE2EEPublicKeys_result :: T.StatelessProtocol p => p -> GetE2EEPublicKeys_result -> LBS.ByteString
encode_GetE2EEPublicKeys_result oprot record = T.serializeVal oprot $ from_GetE2EEPublicKeys_result record
to_GetE2EEPublicKeys_result :: T.ThriftVal -> GetE2EEPublicKeys_result
to_GetE2EEPublicKeys_result (T.TStruct fields) = GetE2EEPublicKeys_result{
  getE2EEPublicKeys_result_success = P.maybe (getE2EEPublicKeys_result_success default_GetE2EEPublicKeys_result) (\(_,_val8829) -> (case _val8829 of {T.TList _ _val8830 -> (Vector.fromList $ P.map (\_v8831 -> (case _v8831 of {T.TStruct _val8832 -> (to_E2EEPublicKey (T.TStruct _val8832)); _ -> P.error "wrong type"})) _val8830); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getE2EEPublicKeys_result_e = P.maybe (P.Nothing) (\(_,_val8829) -> P.Just (case _val8829 of {T.TStruct _val8833 -> (to_TalkException (T.TStruct _val8833)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetE2EEPublicKeys_result _ = P.error "not a struct"
read_GetE2EEPublicKeys_result :: T.Protocol p => p -> P.IO GetE2EEPublicKeys_result
read_GetE2EEPublicKeys_result iprot = to_GetE2EEPublicKeys_result <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeys_result)
decode_GetE2EEPublicKeys_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKeys_result
decode_GetE2EEPublicKeys_result iprot bs = to_GetE2EEPublicKeys_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeys_result) bs
typemap_GetE2EEPublicKeys_result :: T.TypeMap
typemap_GetE2EEPublicKeys_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_E2EEPublicKey)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetE2EEPublicKeys_result :: GetE2EEPublicKeys_result
default_GetE2EEPublicKeys_result = GetE2EEPublicKeys_result{
  getE2EEPublicKeys_result_success = Vector.empty,
  getE2EEPublicKeys_result_e = P.Nothing}
data GetE2EEPublicKeysEx_args = GetE2EEPublicKeysEx_args  { getE2EEPublicKeysEx_args_ignoreE2EEStatus :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKeysEx_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getE2EEPublicKeysEx_args_ignoreE2EEStatus record  
instance QC.Arbitrary GetE2EEPublicKeysEx_args where 
  arbitrary = M.liftM GetE2EEPublicKeysEx_args (QC.arbitrary)
  shrink obj | obj == default_GetE2EEPublicKeysEx_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetE2EEPublicKeysEx_args{getE2EEPublicKeysEx_args_ignoreE2EEStatus = getE2EEPublicKeysEx_args_ignoreE2EEStatus obj} then P.Nothing else P.Just $ default_GetE2EEPublicKeysEx_args{getE2EEPublicKeysEx_args_ignoreE2EEStatus = getE2EEPublicKeysEx_args_ignoreE2EEStatus obj}
    ]
from_GetE2EEPublicKeysEx_args :: GetE2EEPublicKeysEx_args -> T.ThriftVal
from_GetE2EEPublicKeysEx_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8836 -> P.Just (2, ("ignoreE2EEStatus",T.TBool _v8836))) $ getE2EEPublicKeysEx_args_ignoreE2EEStatus record
  ]
write_GetE2EEPublicKeysEx_args :: T.Protocol p => p -> GetE2EEPublicKeysEx_args -> P.IO ()
write_GetE2EEPublicKeysEx_args oprot record = T.writeVal oprot $ from_GetE2EEPublicKeysEx_args record
encode_GetE2EEPublicKeysEx_args :: T.StatelessProtocol p => p -> GetE2EEPublicKeysEx_args -> LBS.ByteString
encode_GetE2EEPublicKeysEx_args oprot record = T.serializeVal oprot $ from_GetE2EEPublicKeysEx_args record
to_GetE2EEPublicKeysEx_args :: T.ThriftVal -> GetE2EEPublicKeysEx_args
to_GetE2EEPublicKeysEx_args (T.TStruct fields) = GetE2EEPublicKeysEx_args{
  getE2EEPublicKeysEx_args_ignoreE2EEStatus = P.maybe (getE2EEPublicKeysEx_args_ignoreE2EEStatus default_GetE2EEPublicKeysEx_args) (\(_,_val8838) -> (case _val8838 of {T.TBool _val8839 -> _val8839; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetE2EEPublicKeysEx_args _ = P.error "not a struct"
read_GetE2EEPublicKeysEx_args :: T.Protocol p => p -> P.IO GetE2EEPublicKeysEx_args
read_GetE2EEPublicKeysEx_args iprot = to_GetE2EEPublicKeysEx_args <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeysEx_args)
decode_GetE2EEPublicKeysEx_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKeysEx_args
decode_GetE2EEPublicKeysEx_args iprot bs = to_GetE2EEPublicKeysEx_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeysEx_args) bs
typemap_GetE2EEPublicKeysEx_args :: T.TypeMap
typemap_GetE2EEPublicKeysEx_args = Map.fromList [(2,("ignoreE2EEStatus",T.T_BOOL))]
default_GetE2EEPublicKeysEx_args :: GetE2EEPublicKeysEx_args
default_GetE2EEPublicKeysEx_args = GetE2EEPublicKeysEx_args{
  getE2EEPublicKeysEx_args_ignoreE2EEStatus = P.False}
data GetE2EEPublicKeysEx_result = GetE2EEPublicKeysEx_result  { getE2EEPublicKeysEx_result_success :: (Vector.Vector E2EEPublicKey)
  , getE2EEPublicKeysEx_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetE2EEPublicKeysEx_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getE2EEPublicKeysEx_result_success record   `H.hashWithSalt` getE2EEPublicKeysEx_result_e record  
instance QC.Arbitrary GetE2EEPublicKeysEx_result where 
  arbitrary = M.liftM GetE2EEPublicKeysEx_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetE2EEPublicKeysEx_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_success = getE2EEPublicKeysEx_result_success obj} then P.Nothing else P.Just $ default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_success = getE2EEPublicKeysEx_result_success obj}
    , if obj == default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_e = getE2EEPublicKeysEx_result_e obj} then P.Nothing else P.Just $ default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_e = getE2EEPublicKeysEx_result_e obj}
    ]
from_GetE2EEPublicKeysEx_result :: GetE2EEPublicKeysEx_result -> T.ThriftVal
from_GetE2EEPublicKeysEx_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8842 -> (1, ("e",from_TalkException _v8842))) <$> getE2EEPublicKeysEx_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8842 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_E2EEPublicKey) $ P.map (\_v8844 -> from_E2EEPublicKey _v8844) $ Vector.toList _v8842))) $ getE2EEPublicKeysEx_result_success record
    , (\_v8842 -> (1, ("e",from_TalkException _v8842))) <$> getE2EEPublicKeysEx_result_e record
    ]
    )
write_GetE2EEPublicKeysEx_result :: T.Protocol p => p -> GetE2EEPublicKeysEx_result -> P.IO ()
write_GetE2EEPublicKeysEx_result oprot record = T.writeVal oprot $ from_GetE2EEPublicKeysEx_result record
encode_GetE2EEPublicKeysEx_result :: T.StatelessProtocol p => p -> GetE2EEPublicKeysEx_result -> LBS.ByteString
encode_GetE2EEPublicKeysEx_result oprot record = T.serializeVal oprot $ from_GetE2EEPublicKeysEx_result record
to_GetE2EEPublicKeysEx_result :: T.ThriftVal -> GetE2EEPublicKeysEx_result
to_GetE2EEPublicKeysEx_result (T.TStruct fields) = GetE2EEPublicKeysEx_result{
  getE2EEPublicKeysEx_result_success = P.maybe (getE2EEPublicKeysEx_result_success default_GetE2EEPublicKeysEx_result) (\(_,_val8846) -> (case _val8846 of {T.TList _ _val8847 -> (Vector.fromList $ P.map (\_v8848 -> (case _v8848 of {T.TStruct _val8849 -> (to_E2EEPublicKey (T.TStruct _val8849)); _ -> P.error "wrong type"})) _val8847); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getE2EEPublicKeysEx_result_e = P.maybe (P.Nothing) (\(_,_val8846) -> P.Just (case _val8846 of {T.TStruct _val8850 -> (to_TalkException (T.TStruct _val8850)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetE2EEPublicKeysEx_result _ = P.error "not a struct"
read_GetE2EEPublicKeysEx_result :: T.Protocol p => p -> P.IO GetE2EEPublicKeysEx_result
read_GetE2EEPublicKeysEx_result iprot = to_GetE2EEPublicKeysEx_result <$> T.readVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeysEx_result)
decode_GetE2EEPublicKeysEx_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetE2EEPublicKeysEx_result
decode_GetE2EEPublicKeysEx_result iprot bs = to_GetE2EEPublicKeysEx_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetE2EEPublicKeysEx_result) bs
typemap_GetE2EEPublicKeysEx_result :: T.TypeMap
typemap_GetE2EEPublicKeysEx_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_E2EEPublicKey)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetE2EEPublicKeysEx_result :: GetE2EEPublicKeysEx_result
default_GetE2EEPublicKeysEx_result = GetE2EEPublicKeysEx_result{
  getE2EEPublicKeysEx_result_success = Vector.empty,
  getE2EEPublicKeysEx_result_e = P.Nothing}
data GetReadMessageOpsInBulk_args = GetReadMessageOpsInBulk_args  { getReadMessageOpsInBulk_args_chatIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReadMessageOpsInBulk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReadMessageOpsInBulk_args_chatIds record  
instance QC.Arbitrary GetReadMessageOpsInBulk_args where 
  arbitrary = M.liftM GetReadMessageOpsInBulk_args (QC.arbitrary)
  shrink obj | obj == default_GetReadMessageOpsInBulk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReadMessageOpsInBulk_args{getReadMessageOpsInBulk_args_chatIds = getReadMessageOpsInBulk_args_chatIds obj} then P.Nothing else P.Just $ default_GetReadMessageOpsInBulk_args{getReadMessageOpsInBulk_args_chatIds = getReadMessageOpsInBulk_args_chatIds obj}
    ]
from_GetReadMessageOpsInBulk_args :: GetReadMessageOpsInBulk_args -> T.ThriftVal
from_GetReadMessageOpsInBulk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8853 -> P.Just (2, ("chatIds",T.TList T.T_STRING $ P.map (\_v8855 -> T.TString $ E.encodeUtf8 _v8855) $ Vector.toList _v8853))) $ getReadMessageOpsInBulk_args_chatIds record
  ]
write_GetReadMessageOpsInBulk_args :: T.Protocol p => p -> GetReadMessageOpsInBulk_args -> P.IO ()
write_GetReadMessageOpsInBulk_args oprot record = T.writeVal oprot $ from_GetReadMessageOpsInBulk_args record
encode_GetReadMessageOpsInBulk_args :: T.StatelessProtocol p => p -> GetReadMessageOpsInBulk_args -> LBS.ByteString
encode_GetReadMessageOpsInBulk_args oprot record = T.serializeVal oprot $ from_GetReadMessageOpsInBulk_args record
to_GetReadMessageOpsInBulk_args :: T.ThriftVal -> GetReadMessageOpsInBulk_args
to_GetReadMessageOpsInBulk_args (T.TStruct fields) = GetReadMessageOpsInBulk_args{
  getReadMessageOpsInBulk_args_chatIds = P.maybe (getReadMessageOpsInBulk_args_chatIds default_GetReadMessageOpsInBulk_args) (\(_,_val8857) -> (case _val8857 of {T.TList _ _val8858 -> (Vector.fromList $ P.map (\_v8859 -> (case _v8859 of {T.TString _val8860 -> E.decodeUtf8 _val8860; _ -> P.error "wrong type"})) _val8858); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetReadMessageOpsInBulk_args _ = P.error "not a struct"
read_GetReadMessageOpsInBulk_args :: T.Protocol p => p -> P.IO GetReadMessageOpsInBulk_args
read_GetReadMessageOpsInBulk_args iprot = to_GetReadMessageOpsInBulk_args <$> T.readVal iprot (T.T_STRUCT typemap_GetReadMessageOpsInBulk_args)
decode_GetReadMessageOpsInBulk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReadMessageOpsInBulk_args
decode_GetReadMessageOpsInBulk_args iprot bs = to_GetReadMessageOpsInBulk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReadMessageOpsInBulk_args) bs
typemap_GetReadMessageOpsInBulk_args :: T.TypeMap
typemap_GetReadMessageOpsInBulk_args = Map.fromList [(2,("chatIds",(T.T_LIST T.T_STRING)))]
default_GetReadMessageOpsInBulk_args :: GetReadMessageOpsInBulk_args
default_GetReadMessageOpsInBulk_args = GetReadMessageOpsInBulk_args{
  getReadMessageOpsInBulk_args_chatIds = Vector.empty}
data GetReadMessageOpsInBulk_result = GetReadMessageOpsInBulk_result  { getReadMessageOpsInBulk_result_success :: (Vector.Vector Operation)
  , getReadMessageOpsInBulk_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReadMessageOpsInBulk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReadMessageOpsInBulk_result_success record   `H.hashWithSalt` getReadMessageOpsInBulk_result_e record  
instance QC.Arbitrary GetReadMessageOpsInBulk_result where 
  arbitrary = M.liftM GetReadMessageOpsInBulk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetReadMessageOpsInBulk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_success = getReadMessageOpsInBulk_result_success obj} then P.Nothing else P.Just $ default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_success = getReadMessageOpsInBulk_result_success obj}
    , if obj == default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_e = getReadMessageOpsInBulk_result_e obj} then P.Nothing else P.Just $ default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_e = getReadMessageOpsInBulk_result_e obj}
    ]
from_GetReadMessageOpsInBulk_result :: GetReadMessageOpsInBulk_result -> T.ThriftVal
from_GetReadMessageOpsInBulk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8863 -> (1, ("e",from_TalkException _v8863))) <$> getReadMessageOpsInBulk_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8863 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Operation) $ P.map (\_v8865 -> from_Operation _v8865) $ Vector.toList _v8863))) $ getReadMessageOpsInBulk_result_success record
    , (\_v8863 -> (1, ("e",from_TalkException _v8863))) <$> getReadMessageOpsInBulk_result_e record
    ]
    )
write_GetReadMessageOpsInBulk_result :: T.Protocol p => p -> GetReadMessageOpsInBulk_result -> P.IO ()
write_GetReadMessageOpsInBulk_result oprot record = T.writeVal oprot $ from_GetReadMessageOpsInBulk_result record
encode_GetReadMessageOpsInBulk_result :: T.StatelessProtocol p => p -> GetReadMessageOpsInBulk_result -> LBS.ByteString
encode_GetReadMessageOpsInBulk_result oprot record = T.serializeVal oprot $ from_GetReadMessageOpsInBulk_result record
to_GetReadMessageOpsInBulk_result :: T.ThriftVal -> GetReadMessageOpsInBulk_result
to_GetReadMessageOpsInBulk_result (T.TStruct fields) = GetReadMessageOpsInBulk_result{
  getReadMessageOpsInBulk_result_success = P.maybe (getReadMessageOpsInBulk_result_success default_GetReadMessageOpsInBulk_result) (\(_,_val8867) -> (case _val8867 of {T.TList _ _val8868 -> (Vector.fromList $ P.map (\_v8869 -> (case _v8869 of {T.TStruct _val8870 -> (to_Operation (T.TStruct _val8870)); _ -> P.error "wrong type"})) _val8868); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getReadMessageOpsInBulk_result_e = P.maybe (P.Nothing) (\(_,_val8867) -> P.Just (case _val8867 of {T.TStruct _val8871 -> (to_TalkException (T.TStruct _val8871)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetReadMessageOpsInBulk_result _ = P.error "not a struct"
read_GetReadMessageOpsInBulk_result :: T.Protocol p => p -> P.IO GetReadMessageOpsInBulk_result
read_GetReadMessageOpsInBulk_result iprot = to_GetReadMessageOpsInBulk_result <$> T.readVal iprot (T.T_STRUCT typemap_GetReadMessageOpsInBulk_result)
decode_GetReadMessageOpsInBulk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReadMessageOpsInBulk_result
decode_GetReadMessageOpsInBulk_result iprot bs = to_GetReadMessageOpsInBulk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReadMessageOpsInBulk_result) bs
typemap_GetReadMessageOpsInBulk_result :: T.TypeMap
typemap_GetReadMessageOpsInBulk_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Operation)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetReadMessageOpsInBulk_result :: GetReadMessageOpsInBulk_result
default_GetReadMessageOpsInBulk_result = GetReadMessageOpsInBulk_result{
  getReadMessageOpsInBulk_result_success = Vector.empty,
  getReadMessageOpsInBulk_result_e = P.Nothing}
data SendEvent_args = SendEvent_args  { sendEvent_args_seq :: I.Int32
  , sendEvent_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendEvent_args_seq record   `H.hashWithSalt` sendEvent_args_message record  
instance QC.Arbitrary SendEvent_args where 
  arbitrary = M.liftM SendEvent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendEvent_args{sendEvent_args_seq = sendEvent_args_seq obj} then P.Nothing else P.Just $ default_SendEvent_args{sendEvent_args_seq = sendEvent_args_seq obj}
    , if obj == default_SendEvent_args{sendEvent_args_message = sendEvent_args_message obj} then P.Nothing else P.Just $ default_SendEvent_args{sendEvent_args_message = sendEvent_args_message obj}
    ]
from_SendEvent_args :: SendEvent_args -> T.ThriftVal
from_SendEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8874 -> P.Just (1, ("seq",T.TI32 _v8874))) $ sendEvent_args_seq record
  , (\_v8874 -> P.Just (2, ("message",from_Message _v8874))) $ sendEvent_args_message record
  ]
write_SendEvent_args :: T.Protocol p => p -> SendEvent_args -> P.IO ()
write_SendEvent_args oprot record = T.writeVal oprot $ from_SendEvent_args record
encode_SendEvent_args :: T.StatelessProtocol p => p -> SendEvent_args -> LBS.ByteString
encode_SendEvent_args oprot record = T.serializeVal oprot $ from_SendEvent_args record
to_SendEvent_args :: T.ThriftVal -> SendEvent_args
to_SendEvent_args (T.TStruct fields) = SendEvent_args{
  sendEvent_args_seq = P.maybe (sendEvent_args_seq default_SendEvent_args) (\(_,_val8876) -> (case _val8876 of {T.TI32 _val8877 -> _val8877; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendEvent_args_message = P.maybe (sendEvent_args_message default_SendEvent_args) (\(_,_val8876) -> (case _val8876 of {T.TStruct _val8878 -> (to_Message (T.TStruct _val8878)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendEvent_args _ = P.error "not a struct"
read_SendEvent_args :: T.Protocol p => p -> P.IO SendEvent_args
read_SendEvent_args iprot = to_SendEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_SendEvent_args)
decode_SendEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendEvent_args
decode_SendEvent_args iprot bs = to_SendEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendEvent_args) bs
typemap_SendEvent_args :: T.TypeMap
typemap_SendEvent_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendEvent_args :: SendEvent_args
default_SendEvent_args = SendEvent_args{
  sendEvent_args_seq = 0,
  sendEvent_args_message = default_Message}
data SendEvent_result = SendEvent_result  { sendEvent_result_success :: Message
  , sendEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendEvent_result_success record   `H.hashWithSalt` sendEvent_result_e record  
instance QC.Arbitrary SendEvent_result where 
  arbitrary = M.liftM SendEvent_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendEvent_result{sendEvent_result_success = sendEvent_result_success obj} then P.Nothing else P.Just $ default_SendEvent_result{sendEvent_result_success = sendEvent_result_success obj}
    , if obj == default_SendEvent_result{sendEvent_result_e = sendEvent_result_e obj} then P.Nothing else P.Just $ default_SendEvent_result{sendEvent_result_e = sendEvent_result_e obj}
    ]
from_SendEvent_result :: SendEvent_result -> T.ThriftVal
from_SendEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8881 -> (1, ("e",from_TalkException _v8881))) <$> sendEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8881 -> P.Just (0, ("success",from_Message _v8881))) $ sendEvent_result_success record
    , (\_v8881 -> (1, ("e",from_TalkException _v8881))) <$> sendEvent_result_e record
    ]
    )
write_SendEvent_result :: T.Protocol p => p -> SendEvent_result -> P.IO ()
write_SendEvent_result oprot record = T.writeVal oprot $ from_SendEvent_result record
encode_SendEvent_result :: T.StatelessProtocol p => p -> SendEvent_result -> LBS.ByteString
encode_SendEvent_result oprot record = T.serializeVal oprot $ from_SendEvent_result record
to_SendEvent_result :: T.ThriftVal -> SendEvent_result
to_SendEvent_result (T.TStruct fields) = SendEvent_result{
  sendEvent_result_success = P.maybe (sendEvent_result_success default_SendEvent_result) (\(_,_val8883) -> (case _val8883 of {T.TStruct _val8884 -> (to_Message (T.TStruct _val8884)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendEvent_result_e = P.maybe (P.Nothing) (\(_,_val8883) -> P.Just (case _val8883 of {T.TStruct _val8885 -> (to_TalkException (T.TStruct _val8885)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendEvent_result _ = P.error "not a struct"
read_SendEvent_result :: T.Protocol p => p -> P.IO SendEvent_result
read_SendEvent_result iprot = to_SendEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_SendEvent_result)
decode_SendEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendEvent_result
decode_SendEvent_result iprot bs = to_SendEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendEvent_result) bs
typemap_SendEvent_result :: T.TypeMap
typemap_SendEvent_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendEvent_result :: SendEvent_result
default_SendEvent_result = SendEvent_result{
  sendEvent_result_success = default_Message,
  sendEvent_result_e = P.Nothing}
data SendMessage_args = SendMessage_args  { sendMessage_args_seq :: I.Int32
  , sendMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_args_seq record   `H.hashWithSalt` sendMessage_args_message record  
instance QC.Arbitrary SendMessage_args where 
  arbitrary = M.liftM SendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_args{sendMessage_args_seq = sendMessage_args_seq obj} then P.Nothing else P.Just $ default_SendMessage_args{sendMessage_args_seq = sendMessage_args_seq obj}
    , if obj == default_SendMessage_args{sendMessage_args_message = sendMessage_args_message obj} then P.Nothing else P.Just $ default_SendMessage_args{sendMessage_args_message = sendMessage_args_message obj}
    ]
from_SendMessage_args :: SendMessage_args -> T.ThriftVal
from_SendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8888 -> P.Just (1, ("seq",T.TI32 _v8888))) $ sendMessage_args_seq record
  , (\_v8888 -> P.Just (2, ("message",from_Message _v8888))) $ sendMessage_args_message record
  ]
write_SendMessage_args :: T.Protocol p => p -> SendMessage_args -> P.IO ()
write_SendMessage_args oprot record = T.writeVal oprot $ from_SendMessage_args record
encode_SendMessage_args :: T.StatelessProtocol p => p -> SendMessage_args -> LBS.ByteString
encode_SendMessage_args oprot record = T.serializeVal oprot $ from_SendMessage_args record
to_SendMessage_args :: T.ThriftVal -> SendMessage_args
to_SendMessage_args (T.TStruct fields) = SendMessage_args{
  sendMessage_args_seq = P.maybe (sendMessage_args_seq default_SendMessage_args) (\(_,_val8890) -> (case _val8890 of {T.TI32 _val8891 -> _val8891; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessage_args_message = P.maybe (sendMessage_args_message default_SendMessage_args) (\(_,_val8890) -> (case _val8890 of {T.TStruct _val8892 -> (to_Message (T.TStruct _val8892)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessage_args _ = P.error "not a struct"
read_SendMessage_args :: T.Protocol p => p -> P.IO SendMessage_args
read_SendMessage_args iprot = to_SendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_args)
decode_SendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_args
decode_SendMessage_args iprot bs = to_SendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_args) bs
typemap_SendMessage_args :: T.TypeMap
typemap_SendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessage_args :: SendMessage_args
default_SendMessage_args = SendMessage_args{
  sendMessage_args_seq = 0,
  sendMessage_args_message = default_Message}
data SendMessage_result = SendMessage_result  { sendMessage_result_success :: Message
  , sendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessage_result_success record   `H.hashWithSalt` sendMessage_result_e record  
instance QC.Arbitrary SendMessage_result where 
  arbitrary = M.liftM SendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_success = sendMessage_result_success obj}
    , if obj == default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj} then P.Nothing else P.Just $ default_SendMessage_result{sendMessage_result_e = sendMessage_result_e obj}
    ]
from_SendMessage_result :: SendMessage_result -> T.ThriftVal
from_SendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8895 -> (1, ("e",from_TalkException _v8895))) <$> sendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8895 -> P.Just (0, ("success",from_Message _v8895))) $ sendMessage_result_success record
    , (\_v8895 -> (1, ("e",from_TalkException _v8895))) <$> sendMessage_result_e record
    ]
    )
write_SendMessage_result :: T.Protocol p => p -> SendMessage_result -> P.IO ()
write_SendMessage_result oprot record = T.writeVal oprot $ from_SendMessage_result record
encode_SendMessage_result :: T.StatelessProtocol p => p -> SendMessage_result -> LBS.ByteString
encode_SendMessage_result oprot record = T.serializeVal oprot $ from_SendMessage_result record
to_SendMessage_result :: T.ThriftVal -> SendMessage_result
to_SendMessage_result (T.TStruct fields) = SendMessage_result{
  sendMessage_result_success = P.maybe (sendMessage_result_success default_SendMessage_result) (\(_,_val8897) -> (case _val8897 of {T.TStruct _val8898 -> (to_Message (T.TStruct _val8898)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessage_result_e = P.maybe (P.Nothing) (\(_,_val8897) -> P.Just (case _val8897 of {T.TStruct _val8899 -> (to_TalkException (T.TStruct _val8899)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessage_result _ = P.error "not a struct"
read_SendMessage_result :: T.Protocol p => p -> P.IO SendMessage_result
read_SendMessage_result iprot = to_SendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessage_result)
decode_SendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessage_result
decode_SendMessage_result iprot bs = to_SendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessage_result) bs
typemap_SendMessage_result :: T.TypeMap
typemap_SendMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessage_result :: SendMessage_result
default_SendMessage_result = SendMessage_result{
  sendMessage_result_success = default_Message,
  sendMessage_result_e = P.Nothing}
data SendMessageIgnored_args = SendMessageIgnored_args  { sendMessageIgnored_args_seq :: I.Int32
  , sendMessageIgnored_args_consumer :: LT.Text
  , sendMessageIgnored_args_messageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageIgnored_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageIgnored_args_seq record   `H.hashWithSalt` sendMessageIgnored_args_consumer record   `H.hashWithSalt` sendMessageIgnored_args_messageIds record  
instance QC.Arbitrary SendMessageIgnored_args where 
  arbitrary = M.liftM SendMessageIgnored_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageIgnored_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_seq = sendMessageIgnored_args_seq obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_seq = sendMessageIgnored_args_seq obj}
    , if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_consumer = sendMessageIgnored_args_consumer obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_consumer = sendMessageIgnored_args_consumer obj}
    , if obj == default_SendMessageIgnored_args{sendMessageIgnored_args_messageIds = sendMessageIgnored_args_messageIds obj} then P.Nothing else P.Just $ default_SendMessageIgnored_args{sendMessageIgnored_args_messageIds = sendMessageIgnored_args_messageIds obj}
    ]
from_SendMessageIgnored_args :: SendMessageIgnored_args -> T.ThriftVal
from_SendMessageIgnored_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8902 -> P.Just (1, ("seq",T.TI32 _v8902))) $ sendMessageIgnored_args_seq record
  , (\_v8902 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v8902))) $ sendMessageIgnored_args_consumer record
  , (\_v8902 -> P.Just (3, ("messageIds",T.TList T.T_STRING $ P.map (\_v8904 -> T.TString $ E.encodeUtf8 _v8904) $ Vector.toList _v8902))) $ sendMessageIgnored_args_messageIds record
  ]
write_SendMessageIgnored_args :: T.Protocol p => p -> SendMessageIgnored_args -> P.IO ()
write_SendMessageIgnored_args oprot record = T.writeVal oprot $ from_SendMessageIgnored_args record
encode_SendMessageIgnored_args :: T.StatelessProtocol p => p -> SendMessageIgnored_args -> LBS.ByteString
encode_SendMessageIgnored_args oprot record = T.serializeVal oprot $ from_SendMessageIgnored_args record
to_SendMessageIgnored_args :: T.ThriftVal -> SendMessageIgnored_args
to_SendMessageIgnored_args (T.TStruct fields) = SendMessageIgnored_args{
  sendMessageIgnored_args_seq = P.maybe (sendMessageIgnored_args_seq default_SendMessageIgnored_args) (\(_,_val8906) -> (case _val8906 of {T.TI32 _val8907 -> _val8907; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageIgnored_args_consumer = P.maybe (sendMessageIgnored_args_consumer default_SendMessageIgnored_args) (\(_,_val8906) -> (case _val8906 of {T.TString _val8908 -> E.decodeUtf8 _val8908; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendMessageIgnored_args_messageIds = P.maybe (sendMessageIgnored_args_messageIds default_SendMessageIgnored_args) (\(_,_val8906) -> (case _val8906 of {T.TList _ _val8909 -> (Vector.fromList $ P.map (\_v8910 -> (case _v8910 of {T.TString _val8911 -> E.decodeUtf8 _val8911; _ -> P.error "wrong type"})) _val8909); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendMessageIgnored_args _ = P.error "not a struct"
read_SendMessageIgnored_args :: T.Protocol p => p -> P.IO SendMessageIgnored_args
read_SendMessageIgnored_args iprot = to_SendMessageIgnored_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageIgnored_args)
decode_SendMessageIgnored_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageIgnored_args
decode_SendMessageIgnored_args iprot bs = to_SendMessageIgnored_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageIgnored_args) bs
typemap_SendMessageIgnored_args :: T.TypeMap
typemap_SendMessageIgnored_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageIds",(T.T_LIST T.T_STRING)))]
default_SendMessageIgnored_args :: SendMessageIgnored_args
default_SendMessageIgnored_args = SendMessageIgnored_args{
  sendMessageIgnored_args_seq = 0,
  sendMessageIgnored_args_consumer = "",
  sendMessageIgnored_args_messageIds = Vector.empty}
data SendMessageIgnored_result = SendMessageIgnored_result  { sendMessageIgnored_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageIgnored_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageIgnored_result_e record  
instance QC.Arbitrary SendMessageIgnored_result where 
  arbitrary = M.liftM SendMessageIgnored_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageIgnored_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageIgnored_result{sendMessageIgnored_result_e = sendMessageIgnored_result_e obj} then P.Nothing else P.Just $ default_SendMessageIgnored_result{sendMessageIgnored_result_e = sendMessageIgnored_result_e obj}
    ]
from_SendMessageIgnored_result :: SendMessageIgnored_result -> T.ThriftVal
from_SendMessageIgnored_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8914 -> (1, ("e",from_TalkException _v8914))) <$> sendMessageIgnored_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8914 -> (1, ("e",from_TalkException _v8914))) <$> sendMessageIgnored_result_e record
    ]
    )
write_SendMessageIgnored_result :: T.Protocol p => p -> SendMessageIgnored_result -> P.IO ()
write_SendMessageIgnored_result oprot record = T.writeVal oprot $ from_SendMessageIgnored_result record
encode_SendMessageIgnored_result :: T.StatelessProtocol p => p -> SendMessageIgnored_result -> LBS.ByteString
encode_SendMessageIgnored_result oprot record = T.serializeVal oprot $ from_SendMessageIgnored_result record
to_SendMessageIgnored_result :: T.ThriftVal -> SendMessageIgnored_result
to_SendMessageIgnored_result (T.TStruct fields) = SendMessageIgnored_result{
  sendMessageIgnored_result_e = P.maybe (P.Nothing) (\(_,_val8916) -> P.Just (case _val8916 of {T.TStruct _val8917 -> (to_TalkException (T.TStruct _val8917)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageIgnored_result _ = P.error "not a struct"
read_SendMessageIgnored_result :: T.Protocol p => p -> P.IO SendMessageIgnored_result
read_SendMessageIgnored_result iprot = to_SendMessageIgnored_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageIgnored_result)
decode_SendMessageIgnored_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageIgnored_result
decode_SendMessageIgnored_result iprot bs = to_SendMessageIgnored_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageIgnored_result) bs
typemap_SendMessageIgnored_result :: T.TypeMap
typemap_SendMessageIgnored_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageIgnored_result :: SendMessageIgnored_result
default_SendMessageIgnored_result = SendMessageIgnored_result{
  sendMessageIgnored_result_e = P.Nothing}
data SendMessageReceipt_args = SendMessageReceipt_args  { sendMessageReceipt_args_seq :: I.Int32
  , sendMessageReceipt_args_consumer :: LT.Text
  , sendMessageReceipt_args_messageIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageReceipt_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageReceipt_args_seq record   `H.hashWithSalt` sendMessageReceipt_args_consumer record   `H.hashWithSalt` sendMessageReceipt_args_messageIds record  
instance QC.Arbitrary SendMessageReceipt_args where 
  arbitrary = M.liftM SendMessageReceipt_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageReceipt_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_seq = sendMessageReceipt_args_seq obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_seq = sendMessageReceipt_args_seq obj}
    , if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_consumer = sendMessageReceipt_args_consumer obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_consumer = sendMessageReceipt_args_consumer obj}
    , if obj == default_SendMessageReceipt_args{sendMessageReceipt_args_messageIds = sendMessageReceipt_args_messageIds obj} then P.Nothing else P.Just $ default_SendMessageReceipt_args{sendMessageReceipt_args_messageIds = sendMessageReceipt_args_messageIds obj}
    ]
from_SendMessageReceipt_args :: SendMessageReceipt_args -> T.ThriftVal
from_SendMessageReceipt_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8920 -> P.Just (1, ("seq",T.TI32 _v8920))) $ sendMessageReceipt_args_seq record
  , (\_v8920 -> P.Just (2, ("consumer",T.TString $ E.encodeUtf8 _v8920))) $ sendMessageReceipt_args_consumer record
  , (\_v8920 -> P.Just (3, ("messageIds",T.TList T.T_STRING $ P.map (\_v8922 -> T.TString $ E.encodeUtf8 _v8922) $ Vector.toList _v8920))) $ sendMessageReceipt_args_messageIds record
  ]
write_SendMessageReceipt_args :: T.Protocol p => p -> SendMessageReceipt_args -> P.IO ()
write_SendMessageReceipt_args oprot record = T.writeVal oprot $ from_SendMessageReceipt_args record
encode_SendMessageReceipt_args :: T.StatelessProtocol p => p -> SendMessageReceipt_args -> LBS.ByteString
encode_SendMessageReceipt_args oprot record = T.serializeVal oprot $ from_SendMessageReceipt_args record
to_SendMessageReceipt_args :: T.ThriftVal -> SendMessageReceipt_args
to_SendMessageReceipt_args (T.TStruct fields) = SendMessageReceipt_args{
  sendMessageReceipt_args_seq = P.maybe (sendMessageReceipt_args_seq default_SendMessageReceipt_args) (\(_,_val8924) -> (case _val8924 of {T.TI32 _val8925 -> _val8925; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageReceipt_args_consumer = P.maybe (sendMessageReceipt_args_consumer default_SendMessageReceipt_args) (\(_,_val8924) -> (case _val8924 of {T.TString _val8926 -> E.decodeUtf8 _val8926; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sendMessageReceipt_args_messageIds = P.maybe (sendMessageReceipt_args_messageIds default_SendMessageReceipt_args) (\(_,_val8924) -> (case _val8924 of {T.TList _ _val8927 -> (Vector.fromList $ P.map (\_v8928 -> (case _v8928 of {T.TString _val8929 -> E.decodeUtf8 _val8929; _ -> P.error "wrong type"})) _val8927); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SendMessageReceipt_args _ = P.error "not a struct"
read_SendMessageReceipt_args :: T.Protocol p => p -> P.IO SendMessageReceipt_args
read_SendMessageReceipt_args iprot = to_SendMessageReceipt_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageReceipt_args)
decode_SendMessageReceipt_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageReceipt_args
decode_SendMessageReceipt_args iprot bs = to_SendMessageReceipt_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageReceipt_args) bs
typemap_SendMessageReceipt_args :: T.TypeMap
typemap_SendMessageReceipt_args = Map.fromList [(1,("seq",T.T_I32)),(2,("consumer",T.T_STRING)),(3,("messageIds",(T.T_LIST T.T_STRING)))]
default_SendMessageReceipt_args :: SendMessageReceipt_args
default_SendMessageReceipt_args = SendMessageReceipt_args{
  sendMessageReceipt_args_seq = 0,
  sendMessageReceipt_args_consumer = "",
  sendMessageReceipt_args_messageIds = Vector.empty}
data SendMessageReceipt_result = SendMessageReceipt_result  { sendMessageReceipt_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageReceipt_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageReceipt_result_e record  
instance QC.Arbitrary SendMessageReceipt_result where 
  arbitrary = M.liftM SendMessageReceipt_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageReceipt_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageReceipt_result{sendMessageReceipt_result_e = sendMessageReceipt_result_e obj} then P.Nothing else P.Just $ default_SendMessageReceipt_result{sendMessageReceipt_result_e = sendMessageReceipt_result_e obj}
    ]
from_SendMessageReceipt_result :: SendMessageReceipt_result -> T.ThriftVal
from_SendMessageReceipt_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8932 -> (1, ("e",from_TalkException _v8932))) <$> sendMessageReceipt_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8932 -> (1, ("e",from_TalkException _v8932))) <$> sendMessageReceipt_result_e record
    ]
    )
write_SendMessageReceipt_result :: T.Protocol p => p -> SendMessageReceipt_result -> P.IO ()
write_SendMessageReceipt_result oprot record = T.writeVal oprot $ from_SendMessageReceipt_result record
encode_SendMessageReceipt_result :: T.StatelessProtocol p => p -> SendMessageReceipt_result -> LBS.ByteString
encode_SendMessageReceipt_result oprot record = T.serializeVal oprot $ from_SendMessageReceipt_result record
to_SendMessageReceipt_result :: T.ThriftVal -> SendMessageReceipt_result
to_SendMessageReceipt_result (T.TStruct fields) = SendMessageReceipt_result{
  sendMessageReceipt_result_e = P.maybe (P.Nothing) (\(_,_val8934) -> P.Just (case _val8934 of {T.TStruct _val8935 -> (to_TalkException (T.TStruct _val8935)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageReceipt_result _ = P.error "not a struct"
read_SendMessageReceipt_result :: T.Protocol p => p -> P.IO SendMessageReceipt_result
read_SendMessageReceipt_result iprot = to_SendMessageReceipt_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageReceipt_result)
decode_SendMessageReceipt_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageReceipt_result
decode_SendMessageReceipt_result iprot bs = to_SendMessageReceipt_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageReceipt_result) bs
typemap_SendMessageReceipt_result :: T.TypeMap
typemap_SendMessageReceipt_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageReceipt_result :: SendMessageReceipt_result
default_SendMessageReceipt_result = SendMessageReceipt_result{
  sendMessageReceipt_result_e = P.Nothing}
data FindContactByMetaTag_args = FindContactByMetaTag_args  { findContactByMetaTag_args_userid :: LT.Text
  , findContactByMetaTag_args_reference :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByMetaTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByMetaTag_args_userid record   `H.hashWithSalt` findContactByMetaTag_args_reference record  
instance QC.Arbitrary FindContactByMetaTag_args where 
  arbitrary = M.liftM FindContactByMetaTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindContactByMetaTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByMetaTag_args{findContactByMetaTag_args_userid = findContactByMetaTag_args_userid obj} then P.Nothing else P.Just $ default_FindContactByMetaTag_args{findContactByMetaTag_args_userid = findContactByMetaTag_args_userid obj}
    , if obj == default_FindContactByMetaTag_args{findContactByMetaTag_args_reference = findContactByMetaTag_args_reference obj} then P.Nothing else P.Just $ default_FindContactByMetaTag_args{findContactByMetaTag_args_reference = findContactByMetaTag_args_reference obj}
    ]
from_FindContactByMetaTag_args :: FindContactByMetaTag_args -> T.ThriftVal
from_FindContactByMetaTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8938 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v8938))) $ findContactByMetaTag_args_userid record
  , (\_v8938 -> P.Just (3, ("reference",T.TString $ E.encodeUtf8 _v8938))) $ findContactByMetaTag_args_reference record
  ]
write_FindContactByMetaTag_args :: T.Protocol p => p -> FindContactByMetaTag_args -> P.IO ()
write_FindContactByMetaTag_args oprot record = T.writeVal oprot $ from_FindContactByMetaTag_args record
encode_FindContactByMetaTag_args :: T.StatelessProtocol p => p -> FindContactByMetaTag_args -> LBS.ByteString
encode_FindContactByMetaTag_args oprot record = T.serializeVal oprot $ from_FindContactByMetaTag_args record
to_FindContactByMetaTag_args :: T.ThriftVal -> FindContactByMetaTag_args
to_FindContactByMetaTag_args (T.TStruct fields) = FindContactByMetaTag_args{
  findContactByMetaTag_args_userid = P.maybe (findContactByMetaTag_args_userid default_FindContactByMetaTag_args) (\(_,_val8940) -> (case _val8940 of {T.TString _val8941 -> E.decodeUtf8 _val8941; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findContactByMetaTag_args_reference = P.maybe (findContactByMetaTag_args_reference default_FindContactByMetaTag_args) (\(_,_val8940) -> (case _val8940 of {T.TString _val8942 -> E.decodeUtf8 _val8942; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindContactByMetaTag_args _ = P.error "not a struct"
read_FindContactByMetaTag_args :: T.Protocol p => p -> P.IO FindContactByMetaTag_args
read_FindContactByMetaTag_args iprot = to_FindContactByMetaTag_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByMetaTag_args)
decode_FindContactByMetaTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByMetaTag_args
decode_FindContactByMetaTag_args iprot bs = to_FindContactByMetaTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByMetaTag_args) bs
typemap_FindContactByMetaTag_args :: T.TypeMap
typemap_FindContactByMetaTag_args = Map.fromList [(2,("userid",T.T_STRING)),(3,("reference",T.T_STRING))]
default_FindContactByMetaTag_args :: FindContactByMetaTag_args
default_FindContactByMetaTag_args = FindContactByMetaTag_args{
  findContactByMetaTag_args_userid = "",
  findContactByMetaTag_args_reference = ""}
data FindContactByMetaTag_result = FindContactByMetaTag_result  { findContactByMetaTag_result_success :: Contact
  , findContactByMetaTag_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByMetaTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByMetaTag_result_success record   `H.hashWithSalt` findContactByMetaTag_result_e record  
instance QC.Arbitrary FindContactByMetaTag_result where 
  arbitrary = M.liftM FindContactByMetaTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByMetaTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByMetaTag_result{findContactByMetaTag_result_success = findContactByMetaTag_result_success obj} then P.Nothing else P.Just $ default_FindContactByMetaTag_result{findContactByMetaTag_result_success = findContactByMetaTag_result_success obj}
    , if obj == default_FindContactByMetaTag_result{findContactByMetaTag_result_e = findContactByMetaTag_result_e obj} then P.Nothing else P.Just $ default_FindContactByMetaTag_result{findContactByMetaTag_result_e = findContactByMetaTag_result_e obj}
    ]
from_FindContactByMetaTag_result :: FindContactByMetaTag_result -> T.ThriftVal
from_FindContactByMetaTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8945 -> (1, ("e",from_TalkException _v8945))) <$> findContactByMetaTag_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8945 -> P.Just (0, ("success",from_Contact _v8945))) $ findContactByMetaTag_result_success record
    , (\_v8945 -> (1, ("e",from_TalkException _v8945))) <$> findContactByMetaTag_result_e record
    ]
    )
write_FindContactByMetaTag_result :: T.Protocol p => p -> FindContactByMetaTag_result -> P.IO ()
write_FindContactByMetaTag_result oprot record = T.writeVal oprot $ from_FindContactByMetaTag_result record
encode_FindContactByMetaTag_result :: T.StatelessProtocol p => p -> FindContactByMetaTag_result -> LBS.ByteString
encode_FindContactByMetaTag_result oprot record = T.serializeVal oprot $ from_FindContactByMetaTag_result record
to_FindContactByMetaTag_result :: T.ThriftVal -> FindContactByMetaTag_result
to_FindContactByMetaTag_result (T.TStruct fields) = FindContactByMetaTag_result{
  findContactByMetaTag_result_success = P.maybe (findContactByMetaTag_result_success default_FindContactByMetaTag_result) (\(_,_val8947) -> (case _val8947 of {T.TStruct _val8948 -> (to_Contact (T.TStruct _val8948)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByMetaTag_result_e = P.maybe (P.Nothing) (\(_,_val8947) -> P.Just (case _val8947 of {T.TStruct _val8949 -> (to_TalkException (T.TStruct _val8949)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByMetaTag_result _ = P.error "not a struct"
read_FindContactByMetaTag_result :: T.Protocol p => p -> P.IO FindContactByMetaTag_result
read_FindContactByMetaTag_result iprot = to_FindContactByMetaTag_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByMetaTag_result)
decode_FindContactByMetaTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByMetaTag_result
decode_FindContactByMetaTag_result iprot bs = to_FindContactByMetaTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByMetaTag_result) bs
typemap_FindContactByMetaTag_result :: T.TypeMap
typemap_FindContactByMetaTag_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByMetaTag_result :: FindContactByMetaTag_result
default_FindContactByMetaTag_result = FindContactByMetaTag_result{
  findContactByMetaTag_result_success = default_Contact,
  findContactByMetaTag_result_e = P.Nothing}
data SendMessageToMyHome_args = SendMessageToMyHome_args  { sendMessageToMyHome_args_seq :: I.Int32
  , sendMessageToMyHome_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageToMyHome_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageToMyHome_args_seq record   `H.hashWithSalt` sendMessageToMyHome_args_message record  
instance QC.Arbitrary SendMessageToMyHome_args where 
  arbitrary = M.liftM SendMessageToMyHome_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SendMessageToMyHome_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageToMyHome_args{sendMessageToMyHome_args_seq = sendMessageToMyHome_args_seq obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_args{sendMessageToMyHome_args_seq = sendMessageToMyHome_args_seq obj}
    , if obj == default_SendMessageToMyHome_args{sendMessageToMyHome_args_message = sendMessageToMyHome_args_message obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_args{sendMessageToMyHome_args_message = sendMessageToMyHome_args_message obj}
    ]
from_SendMessageToMyHome_args :: SendMessageToMyHome_args -> T.ThriftVal
from_SendMessageToMyHome_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8952 -> P.Just (1, ("seq",T.TI32 _v8952))) $ sendMessageToMyHome_args_seq record
  , (\_v8952 -> P.Just (2, ("message",from_Message _v8952))) $ sendMessageToMyHome_args_message record
  ]
write_SendMessageToMyHome_args :: T.Protocol p => p -> SendMessageToMyHome_args -> P.IO ()
write_SendMessageToMyHome_args oprot record = T.writeVal oprot $ from_SendMessageToMyHome_args record
encode_SendMessageToMyHome_args :: T.StatelessProtocol p => p -> SendMessageToMyHome_args -> LBS.ByteString
encode_SendMessageToMyHome_args oprot record = T.serializeVal oprot $ from_SendMessageToMyHome_args record
to_SendMessageToMyHome_args :: T.ThriftVal -> SendMessageToMyHome_args
to_SendMessageToMyHome_args (T.TStruct fields) = SendMessageToMyHome_args{
  sendMessageToMyHome_args_seq = P.maybe (sendMessageToMyHome_args_seq default_SendMessageToMyHome_args) (\(_,_val8954) -> (case _val8954 of {T.TI32 _val8955 -> _val8955; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sendMessageToMyHome_args_message = P.maybe (sendMessageToMyHome_args_message default_SendMessageToMyHome_args) (\(_,_val8954) -> (case _val8954 of {T.TStruct _val8956 -> (to_Message (T.TStruct _val8956)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageToMyHome_args _ = P.error "not a struct"
read_SendMessageToMyHome_args :: T.Protocol p => p -> P.IO SendMessageToMyHome_args
read_SendMessageToMyHome_args iprot = to_SendMessageToMyHome_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_args)
decode_SendMessageToMyHome_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageToMyHome_args
decode_SendMessageToMyHome_args iprot bs = to_SendMessageToMyHome_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_args) bs
typemap_SendMessageToMyHome_args :: T.TypeMap
typemap_SendMessageToMyHome_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageToMyHome_args :: SendMessageToMyHome_args
default_SendMessageToMyHome_args = SendMessageToMyHome_args{
  sendMessageToMyHome_args_seq = 0,
  sendMessageToMyHome_args_message = default_Message}
data SendMessageToMyHome_result = SendMessageToMyHome_result  { sendMessageToMyHome_result_success :: Message
  , sendMessageToMyHome_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageToMyHome_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageToMyHome_result_success record   `H.hashWithSalt` sendMessageToMyHome_result_e record  
instance QC.Arbitrary SendMessageToMyHome_result where 
  arbitrary = M.liftM SendMessageToMyHome_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageToMyHome_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = sendMessageToMyHome_result_success obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = sendMessageToMyHome_result_success obj}
    , if obj == default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = sendMessageToMyHome_result_e obj} then P.Nothing else P.Just $ default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = sendMessageToMyHome_result_e obj}
    ]
from_SendMessageToMyHome_result :: SendMessageToMyHome_result -> T.ThriftVal
from_SendMessageToMyHome_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8959 -> (1, ("e",from_TalkException _v8959))) <$> sendMessageToMyHome_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8959 -> P.Just (0, ("success",from_Message _v8959))) $ sendMessageToMyHome_result_success record
    , (\_v8959 -> (1, ("e",from_TalkException _v8959))) <$> sendMessageToMyHome_result_e record
    ]
    )
write_SendMessageToMyHome_result :: T.Protocol p => p -> SendMessageToMyHome_result -> P.IO ()
write_SendMessageToMyHome_result oprot record = T.writeVal oprot $ from_SendMessageToMyHome_result record
encode_SendMessageToMyHome_result :: T.StatelessProtocol p => p -> SendMessageToMyHome_result -> LBS.ByteString
encode_SendMessageToMyHome_result oprot record = T.serializeVal oprot $ from_SendMessageToMyHome_result record
to_SendMessageToMyHome_result :: T.ThriftVal -> SendMessageToMyHome_result
to_SendMessageToMyHome_result (T.TStruct fields) = SendMessageToMyHome_result{
  sendMessageToMyHome_result_success = P.maybe (sendMessageToMyHome_result_success default_SendMessageToMyHome_result) (\(_,_val8961) -> (case _val8961 of {T.TStruct _val8962 -> (to_Message (T.TStruct _val8962)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageToMyHome_result_e = P.maybe (P.Nothing) (\(_,_val8961) -> P.Just (case _val8961 of {T.TStruct _val8963 -> (to_TalkException (T.TStruct _val8963)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageToMyHome_result _ = P.error "not a struct"
read_SendMessageToMyHome_result :: T.Protocol p => p -> P.IO SendMessageToMyHome_result
read_SendMessageToMyHome_result iprot = to_SendMessageToMyHome_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_result)
decode_SendMessageToMyHome_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageToMyHome_result
decode_SendMessageToMyHome_result iprot bs = to_SendMessageToMyHome_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageToMyHome_result) bs
typemap_SendMessageToMyHome_result :: T.TypeMap
typemap_SendMessageToMyHome_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageToMyHome_result :: SendMessageToMyHome_result
default_SendMessageToMyHome_result = SendMessageToMyHome_result{
  sendMessageToMyHome_result_success = default_Message,
  sendMessageToMyHome_result_e = P.Nothing}
data SetBuddyLocation_args = SetBuddyLocation_args  { setBuddyLocation_args_mid :: LT.Text
  , setBuddyLocation_args_index :: I.Int32
  , setBuddyLocation_args_location :: Geolocation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyLocation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyLocation_args_mid record   `H.hashWithSalt` setBuddyLocation_args_index record   `H.hashWithSalt` setBuddyLocation_args_location record  
instance QC.Arbitrary SetBuddyLocation_args where 
  arbitrary = M.liftM SetBuddyLocation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetBuddyLocation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyLocation_args{setBuddyLocation_args_mid = setBuddyLocation_args_mid obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_mid = setBuddyLocation_args_mid obj}
    , if obj == default_SetBuddyLocation_args{setBuddyLocation_args_index = setBuddyLocation_args_index obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_index = setBuddyLocation_args_index obj}
    , if obj == default_SetBuddyLocation_args{setBuddyLocation_args_location = setBuddyLocation_args_location obj} then P.Nothing else P.Just $ default_SetBuddyLocation_args{setBuddyLocation_args_location = setBuddyLocation_args_location obj}
    ]
from_SetBuddyLocation_args :: SetBuddyLocation_args -> T.ThriftVal
from_SetBuddyLocation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8966 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v8966))) $ setBuddyLocation_args_mid record
  , (\_v8966 -> P.Just (3, ("index",T.TI32 _v8966))) $ setBuddyLocation_args_index record
  , (\_v8966 -> P.Just (4, ("location",from_Geolocation _v8966))) $ setBuddyLocation_args_location record
  ]
write_SetBuddyLocation_args :: T.Protocol p => p -> SetBuddyLocation_args -> P.IO ()
write_SetBuddyLocation_args oprot record = T.writeVal oprot $ from_SetBuddyLocation_args record
encode_SetBuddyLocation_args :: T.StatelessProtocol p => p -> SetBuddyLocation_args -> LBS.ByteString
encode_SetBuddyLocation_args oprot record = T.serializeVal oprot $ from_SetBuddyLocation_args record
to_SetBuddyLocation_args :: T.ThriftVal -> SetBuddyLocation_args
to_SetBuddyLocation_args (T.TStruct fields) = SetBuddyLocation_args{
  setBuddyLocation_args_mid = P.maybe (setBuddyLocation_args_mid default_SetBuddyLocation_args) (\(_,_val8968) -> (case _val8968 of {T.TString _val8969 -> E.decodeUtf8 _val8969; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setBuddyLocation_args_index = P.maybe (setBuddyLocation_args_index default_SetBuddyLocation_args) (\(_,_val8968) -> (case _val8968 of {T.TI32 _val8970 -> _val8970; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setBuddyLocation_args_location = P.maybe (setBuddyLocation_args_location default_SetBuddyLocation_args) (\(_,_val8968) -> (case _val8968 of {T.TStruct _val8971 -> (to_Geolocation (T.TStruct _val8971)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetBuddyLocation_args _ = P.error "not a struct"
read_SetBuddyLocation_args :: T.Protocol p => p -> P.IO SetBuddyLocation_args
read_SetBuddyLocation_args iprot = to_SetBuddyLocation_args <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyLocation_args)
decode_SetBuddyLocation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyLocation_args
decode_SetBuddyLocation_args iprot bs = to_SetBuddyLocation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyLocation_args) bs
typemap_SetBuddyLocation_args :: T.TypeMap
typemap_SetBuddyLocation_args = Map.fromList [(2,("mid",T.T_STRING)),(3,("index",T.T_I32)),(4,("location",(T.T_STRUCT typemap_Geolocation)))]
default_SetBuddyLocation_args :: SetBuddyLocation_args
default_SetBuddyLocation_args = SetBuddyLocation_args{
  setBuddyLocation_args_mid = "",
  setBuddyLocation_args_index = 0,
  setBuddyLocation_args_location = default_Geolocation}
data SetBuddyLocation_result = SetBuddyLocation_result  { setBuddyLocation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetBuddyLocation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setBuddyLocation_result_e record  
instance QC.Arbitrary SetBuddyLocation_result where 
  arbitrary = M.liftM SetBuddyLocation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetBuddyLocation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetBuddyLocation_result{setBuddyLocation_result_e = setBuddyLocation_result_e obj} then P.Nothing else P.Just $ default_SetBuddyLocation_result{setBuddyLocation_result_e = setBuddyLocation_result_e obj}
    ]
from_SetBuddyLocation_result :: SetBuddyLocation_result -> T.ThriftVal
from_SetBuddyLocation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8974 -> (1, ("e",from_TalkException _v8974))) <$> setBuddyLocation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8974 -> (1, ("e",from_TalkException _v8974))) <$> setBuddyLocation_result_e record
    ]
    )
write_SetBuddyLocation_result :: T.Protocol p => p -> SetBuddyLocation_result -> P.IO ()
write_SetBuddyLocation_result oprot record = T.writeVal oprot $ from_SetBuddyLocation_result record
encode_SetBuddyLocation_result :: T.StatelessProtocol p => p -> SetBuddyLocation_result -> LBS.ByteString
encode_SetBuddyLocation_result oprot record = T.serializeVal oprot $ from_SetBuddyLocation_result record
to_SetBuddyLocation_result :: T.ThriftVal -> SetBuddyLocation_result
to_SetBuddyLocation_result (T.TStruct fields) = SetBuddyLocation_result{
  setBuddyLocation_result_e = P.maybe (P.Nothing) (\(_,_val8976) -> P.Just (case _val8976 of {T.TStruct _val8977 -> (to_TalkException (T.TStruct _val8977)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetBuddyLocation_result _ = P.error "not a struct"
read_SetBuddyLocation_result :: T.Protocol p => p -> P.IO SetBuddyLocation_result
read_SetBuddyLocation_result iprot = to_SetBuddyLocation_result <$> T.readVal iprot (T.T_STRUCT typemap_SetBuddyLocation_result)
decode_SetBuddyLocation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetBuddyLocation_result
decode_SetBuddyLocation_result iprot bs = to_SetBuddyLocation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetBuddyLocation_result) bs
typemap_SetBuddyLocation_result :: T.TypeMap
typemap_SetBuddyLocation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetBuddyLocation_result :: SetBuddyLocation_result
default_SetBuddyLocation_result = SetBuddyLocation_result{
  setBuddyLocation_result_e = P.Nothing}
data SetIdentityCredential_args = SetIdentityCredential_args  { setIdentityCredential_args_identifier :: LT.Text
  , setIdentityCredential_args_verifier :: LT.Text
  , setIdentityCredential_args_provider :: IdentityProvider
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setIdentityCredential_args_identifier record   `H.hashWithSalt` setIdentityCredential_args_verifier record   `H.hashWithSalt` setIdentityCredential_args_provider record  
instance QC.Arbitrary SetIdentityCredential_args where 
  arbitrary = M.liftM SetIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetIdentityCredential_args{setIdentityCredential_args_identifier = setIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_identifier = setIdentityCredential_args_identifier obj}
    , if obj == default_SetIdentityCredential_args{setIdentityCredential_args_verifier = setIdentityCredential_args_verifier obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_verifier = setIdentityCredential_args_verifier obj}
    , if obj == default_SetIdentityCredential_args{setIdentityCredential_args_provider = setIdentityCredential_args_provider obj} then P.Nothing else P.Just $ default_SetIdentityCredential_args{setIdentityCredential_args_provider = setIdentityCredential_args_provider obj}
    ]
from_SetIdentityCredential_args :: SetIdentityCredential_args -> T.ThriftVal
from_SetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8980 -> P.Just (2, ("identifier",T.TString $ E.encodeUtf8 _v8980))) $ setIdentityCredential_args_identifier record
  , (\_v8980 -> P.Just (3, ("verifier",T.TString $ E.encodeUtf8 _v8980))) $ setIdentityCredential_args_verifier record
  , (\_v8980 -> P.Just (4, ("provider",T.TI32 $ P.fromIntegral $ P.fromEnum _v8980))) $ setIdentityCredential_args_provider record
  ]
write_SetIdentityCredential_args :: T.Protocol p => p -> SetIdentityCredential_args -> P.IO ()
write_SetIdentityCredential_args oprot record = T.writeVal oprot $ from_SetIdentityCredential_args record
encode_SetIdentityCredential_args :: T.StatelessProtocol p => p -> SetIdentityCredential_args -> LBS.ByteString
encode_SetIdentityCredential_args oprot record = T.serializeVal oprot $ from_SetIdentityCredential_args record
to_SetIdentityCredential_args :: T.ThriftVal -> SetIdentityCredential_args
to_SetIdentityCredential_args (T.TStruct fields) = SetIdentityCredential_args{
  setIdentityCredential_args_identifier = P.maybe (setIdentityCredential_args_identifier default_SetIdentityCredential_args) (\(_,_val8982) -> (case _val8982 of {T.TString _val8983 -> E.decodeUtf8 _val8983; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setIdentityCredential_args_verifier = P.maybe (setIdentityCredential_args_verifier default_SetIdentityCredential_args) (\(_,_val8982) -> (case _val8982 of {T.TString _val8984 -> E.decodeUtf8 _val8984; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setIdentityCredential_args_provider = P.maybe (setIdentityCredential_args_provider default_SetIdentityCredential_args) (\(_,_val8982) -> (case _val8982 of {T.TI32 _val8985 -> P.toEnum $ P.fromIntegral _val8985; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetIdentityCredential_args _ = P.error "not a struct"
read_SetIdentityCredential_args :: T.Protocol p => p -> P.IO SetIdentityCredential_args
read_SetIdentityCredential_args iprot = to_SetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_SetIdentityCredential_args)
decode_SetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetIdentityCredential_args
decode_SetIdentityCredential_args iprot bs = to_SetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetIdentityCredential_args) bs
typemap_SetIdentityCredential_args :: T.TypeMap
typemap_SetIdentityCredential_args = Map.fromList [(2,("identifier",T.T_STRING)),(3,("verifier",T.T_STRING)),(4,("provider",T.T_I32))]
default_SetIdentityCredential_args :: SetIdentityCredential_args
default_SetIdentityCredential_args = SetIdentityCredential_args{
  setIdentityCredential_args_identifier = "",
  setIdentityCredential_args_verifier = "",
  setIdentityCredential_args_provider = (P.toEnum 0)}
data SetIdentityCredential_result = SetIdentityCredential_result  { setIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setIdentityCredential_result_e record  
instance QC.Arbitrary SetIdentityCredential_result where 
  arbitrary = M.liftM SetIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetIdentityCredential_result{setIdentityCredential_result_e = setIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_SetIdentityCredential_result{setIdentityCredential_result_e = setIdentityCredential_result_e obj}
    ]
from_SetIdentityCredential_result :: SetIdentityCredential_result -> T.ThriftVal
from_SetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v8988 -> (1, ("e",from_TalkException _v8988))) <$> setIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v8988 -> (1, ("e",from_TalkException _v8988))) <$> setIdentityCredential_result_e record
    ]
    )
write_SetIdentityCredential_result :: T.Protocol p => p -> SetIdentityCredential_result -> P.IO ()
write_SetIdentityCredential_result oprot record = T.writeVal oprot $ from_SetIdentityCredential_result record
encode_SetIdentityCredential_result :: T.StatelessProtocol p => p -> SetIdentityCredential_result -> LBS.ByteString
encode_SetIdentityCredential_result oprot record = T.serializeVal oprot $ from_SetIdentityCredential_result record
to_SetIdentityCredential_result :: T.ThriftVal -> SetIdentityCredential_result
to_SetIdentityCredential_result (T.TStruct fields) = SetIdentityCredential_result{
  setIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val8990) -> P.Just (case _val8990 of {T.TStruct _val8991 -> (to_TalkException (T.TStruct _val8991)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetIdentityCredential_result _ = P.error "not a struct"
read_SetIdentityCredential_result :: T.Protocol p => p -> P.IO SetIdentityCredential_result
read_SetIdentityCredential_result iprot = to_SetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_SetIdentityCredential_result)
decode_SetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetIdentityCredential_result
decode_SetIdentityCredential_result iprot bs = to_SetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetIdentityCredential_result) bs
typemap_SetIdentityCredential_result :: T.TypeMap
typemap_SetIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetIdentityCredential_result :: SetIdentityCredential_result
default_SetIdentityCredential_result = SetIdentityCredential_result{
  setIdentityCredential_result_e = P.Nothing}
data SetNotificationsEnabled_args = SetNotificationsEnabled_args  { setNotificationsEnabled_args_reqSeq :: I.Int32
  , setNotificationsEnabled_args_type :: MIDType
  , setNotificationsEnabled_args_target :: LT.Text
  , setNotificationsEnabled_args_enablement :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotificationsEnabled_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotificationsEnabled_args_reqSeq record   `H.hashWithSalt` setNotificationsEnabled_args_type record   `H.hashWithSalt` setNotificationsEnabled_args_target record   `H.hashWithSalt` setNotificationsEnabled_args_enablement record  
instance QC.Arbitrary SetNotificationsEnabled_args where 
  arbitrary = M.liftM SetNotificationsEnabled_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetNotificationsEnabled_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_reqSeq = setNotificationsEnabled_args_reqSeq obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_reqSeq = setNotificationsEnabled_args_reqSeq obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_type = setNotificationsEnabled_args_type obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_type = setNotificationsEnabled_args_type obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_target = setNotificationsEnabled_args_target obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_target = setNotificationsEnabled_args_target obj}
    , if obj == default_SetNotificationsEnabled_args{setNotificationsEnabled_args_enablement = setNotificationsEnabled_args_enablement obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_args{setNotificationsEnabled_args_enablement = setNotificationsEnabled_args_enablement obj}
    ]
from_SetNotificationsEnabled_args :: SetNotificationsEnabled_args -> T.ThriftVal
from_SetNotificationsEnabled_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v8994 -> P.Just (1, ("reqSeq",T.TI32 _v8994))) $ setNotificationsEnabled_args_reqSeq record
  , (\_v8994 -> P.Just (2, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v8994))) $ setNotificationsEnabled_args_type record
  , (\_v8994 -> P.Just (3, ("target",T.TString $ E.encodeUtf8 _v8994))) $ setNotificationsEnabled_args_target record
  , (\_v8994 -> P.Just (4, ("enablement",T.TBool _v8994))) $ setNotificationsEnabled_args_enablement record
  ]
write_SetNotificationsEnabled_args :: T.Protocol p => p -> SetNotificationsEnabled_args -> P.IO ()
write_SetNotificationsEnabled_args oprot record = T.writeVal oprot $ from_SetNotificationsEnabled_args record
encode_SetNotificationsEnabled_args :: T.StatelessProtocol p => p -> SetNotificationsEnabled_args -> LBS.ByteString
encode_SetNotificationsEnabled_args oprot record = T.serializeVal oprot $ from_SetNotificationsEnabled_args record
to_SetNotificationsEnabled_args :: T.ThriftVal -> SetNotificationsEnabled_args
to_SetNotificationsEnabled_args (T.TStruct fields) = SetNotificationsEnabled_args{
  setNotificationsEnabled_args_reqSeq = P.maybe (setNotificationsEnabled_args_reqSeq default_SetNotificationsEnabled_args) (\(_,_val8996) -> (case _val8996 of {T.TI32 _val8997 -> _val8997; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNotificationsEnabled_args_type = P.maybe (setNotificationsEnabled_args_type default_SetNotificationsEnabled_args) (\(_,_val8996) -> (case _val8996 of {T.TI32 _val8998 -> P.toEnum $ P.fromIntegral _val8998; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNotificationsEnabled_args_target = P.maybe (setNotificationsEnabled_args_target default_SetNotificationsEnabled_args) (\(_,_val8996) -> (case _val8996 of {T.TString _val8999 -> E.decodeUtf8 _val8999; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setNotificationsEnabled_args_enablement = P.maybe (setNotificationsEnabled_args_enablement default_SetNotificationsEnabled_args) (\(_,_val8996) -> (case _val8996 of {T.TBool _val9000 -> _val9000; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetNotificationsEnabled_args _ = P.error "not a struct"
read_SetNotificationsEnabled_args :: T.Protocol p => p -> P.IO SetNotificationsEnabled_args
read_SetNotificationsEnabled_args iprot = to_SetNotificationsEnabled_args <$> T.readVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_args)
decode_SetNotificationsEnabled_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotificationsEnabled_args
decode_SetNotificationsEnabled_args iprot bs = to_SetNotificationsEnabled_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_args) bs
typemap_SetNotificationsEnabled_args :: T.TypeMap
typemap_SetNotificationsEnabled_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("type",T.T_I32)),(3,("target",T.T_STRING)),(4,("enablement",T.T_BOOL))]
default_SetNotificationsEnabled_args :: SetNotificationsEnabled_args
default_SetNotificationsEnabled_args = SetNotificationsEnabled_args{
  setNotificationsEnabled_args_reqSeq = 0,
  setNotificationsEnabled_args_type = (P.toEnum 0),
  setNotificationsEnabled_args_target = "",
  setNotificationsEnabled_args_enablement = P.False}
data SetNotificationsEnabled_result = SetNotificationsEnabled_result  { setNotificationsEnabled_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotificationsEnabled_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotificationsEnabled_result_e record  
instance QC.Arbitrary SetNotificationsEnabled_result where 
  arbitrary = M.liftM SetNotificationsEnabled_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetNotificationsEnabled_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = setNotificationsEnabled_result_e obj} then P.Nothing else P.Just $ default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = setNotificationsEnabled_result_e obj}
    ]
from_SetNotificationsEnabled_result :: SetNotificationsEnabled_result -> T.ThriftVal
from_SetNotificationsEnabled_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9003 -> (1, ("e",from_TalkException _v9003))) <$> setNotificationsEnabled_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9003 -> (1, ("e",from_TalkException _v9003))) <$> setNotificationsEnabled_result_e record
    ]
    )
write_SetNotificationsEnabled_result :: T.Protocol p => p -> SetNotificationsEnabled_result -> P.IO ()
write_SetNotificationsEnabled_result oprot record = T.writeVal oprot $ from_SetNotificationsEnabled_result record
encode_SetNotificationsEnabled_result :: T.StatelessProtocol p => p -> SetNotificationsEnabled_result -> LBS.ByteString
encode_SetNotificationsEnabled_result oprot record = T.serializeVal oprot $ from_SetNotificationsEnabled_result record
to_SetNotificationsEnabled_result :: T.ThriftVal -> SetNotificationsEnabled_result
to_SetNotificationsEnabled_result (T.TStruct fields) = SetNotificationsEnabled_result{
  setNotificationsEnabled_result_e = P.maybe (P.Nothing) (\(_,_val9005) -> P.Just (case _val9005 of {T.TStruct _val9006 -> (to_TalkException (T.TStruct _val9006)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SetNotificationsEnabled_result _ = P.error "not a struct"
read_SetNotificationsEnabled_result :: T.Protocol p => p -> P.IO SetNotificationsEnabled_result
read_SetNotificationsEnabled_result iprot = to_SetNotificationsEnabled_result <$> T.readVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_result)
decode_SetNotificationsEnabled_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotificationsEnabled_result
decode_SetNotificationsEnabled_result iprot bs = to_SetNotificationsEnabled_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotificationsEnabled_result) bs
typemap_SetNotificationsEnabled_result :: T.TypeMap
typemap_SetNotificationsEnabled_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SetNotificationsEnabled_result :: SetNotificationsEnabled_result
default_SetNotificationsEnabled_result = SetNotificationsEnabled_result{
  setNotificationsEnabled_result_e = P.Nothing}
data StartUpdateVerification_args = StartUpdateVerification_args  { startUpdateVerification_args_region :: LT.Text
  , startUpdateVerification_args_carrier :: CarrierCode
  , startUpdateVerification_args_phone :: LT.Text
  , startUpdateVerification_args_udidHash :: LT.Text
  , startUpdateVerification_args_deviceInfo :: DeviceInfo
  , startUpdateVerification_args_networkCode :: LT.Text
  , startUpdateVerification_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartUpdateVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startUpdateVerification_args_region record   `H.hashWithSalt` startUpdateVerification_args_carrier record   `H.hashWithSalt` startUpdateVerification_args_phone record   `H.hashWithSalt` startUpdateVerification_args_udidHash record   `H.hashWithSalt` startUpdateVerification_args_deviceInfo record   `H.hashWithSalt` startUpdateVerification_args_networkCode record   `H.hashWithSalt` startUpdateVerification_args_locale record  
instance QC.Arbitrary StartUpdateVerification_args where 
  arbitrary = M.liftM StartUpdateVerification_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartUpdateVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartUpdateVerification_args{startUpdateVerification_args_region = startUpdateVerification_args_region obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_region = startUpdateVerification_args_region obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_carrier = startUpdateVerification_args_carrier obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_carrier = startUpdateVerification_args_carrier obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_phone = startUpdateVerification_args_phone obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_phone = startUpdateVerification_args_phone obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_udidHash = startUpdateVerification_args_udidHash obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_udidHash = startUpdateVerification_args_udidHash obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_deviceInfo = startUpdateVerification_args_deviceInfo obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_deviceInfo = startUpdateVerification_args_deviceInfo obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_networkCode = startUpdateVerification_args_networkCode obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_networkCode = startUpdateVerification_args_networkCode obj}
    , if obj == default_StartUpdateVerification_args{startUpdateVerification_args_locale = startUpdateVerification_args_locale obj} then P.Nothing else P.Just $ default_StartUpdateVerification_args{startUpdateVerification_args_locale = startUpdateVerification_args_locale obj}
    ]
from_StartUpdateVerification_args :: StartUpdateVerification_args -> T.ThriftVal
from_StartUpdateVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9009 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v9009))) $ startUpdateVerification_args_region record
  , (\_v9009 -> P.Just (3, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v9009))) $ startUpdateVerification_args_carrier record
  , (\_v9009 -> P.Just (4, ("phone",T.TString $ E.encodeUtf8 _v9009))) $ startUpdateVerification_args_phone record
  , (\_v9009 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v9009))) $ startUpdateVerification_args_udidHash record
  , (\_v9009 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v9009))) $ startUpdateVerification_args_deviceInfo record
  , (\_v9009 -> P.Just (7, ("networkCode",T.TString $ E.encodeUtf8 _v9009))) $ startUpdateVerification_args_networkCode record
  , (\_v9009 -> P.Just (8, ("locale",T.TString $ E.encodeUtf8 _v9009))) $ startUpdateVerification_args_locale record
  ]
write_StartUpdateVerification_args :: T.Protocol p => p -> StartUpdateVerification_args -> P.IO ()
write_StartUpdateVerification_args oprot record = T.writeVal oprot $ from_StartUpdateVerification_args record
encode_StartUpdateVerification_args :: T.StatelessProtocol p => p -> StartUpdateVerification_args -> LBS.ByteString
encode_StartUpdateVerification_args oprot record = T.serializeVal oprot $ from_StartUpdateVerification_args record
to_StartUpdateVerification_args :: T.ThriftVal -> StartUpdateVerification_args
to_StartUpdateVerification_args (T.TStruct fields) = StartUpdateVerification_args{
  startUpdateVerification_args_region = P.maybe (startUpdateVerification_args_region default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TString _val9012 -> E.decodeUtf8 _val9012; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  startUpdateVerification_args_carrier = P.maybe (startUpdateVerification_args_carrier default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TI32 _val9013 -> P.toEnum $ P.fromIntegral _val9013; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  startUpdateVerification_args_phone = P.maybe (startUpdateVerification_args_phone default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TString _val9014 -> E.decodeUtf8 _val9014; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  startUpdateVerification_args_udidHash = P.maybe (startUpdateVerification_args_udidHash default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TString _val9015 -> E.decodeUtf8 _val9015; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  startUpdateVerification_args_deviceInfo = P.maybe (startUpdateVerification_args_deviceInfo default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TStruct _val9016 -> (to_DeviceInfo (T.TStruct _val9016)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  startUpdateVerification_args_networkCode = P.maybe (startUpdateVerification_args_networkCode default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TString _val9017 -> E.decodeUtf8 _val9017; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  startUpdateVerification_args_locale = P.maybe (startUpdateVerification_args_locale default_StartUpdateVerification_args) (\(_,_val9011) -> (case _val9011 of {T.TString _val9018 -> E.decodeUtf8 _val9018; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_StartUpdateVerification_args _ = P.error "not a struct"
read_StartUpdateVerification_args :: T.Protocol p => p -> P.IO StartUpdateVerification_args
read_StartUpdateVerification_args iprot = to_StartUpdateVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_StartUpdateVerification_args)
decode_StartUpdateVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StartUpdateVerification_args
decode_StartUpdateVerification_args iprot bs = to_StartUpdateVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartUpdateVerification_args) bs
typemap_StartUpdateVerification_args :: T.TypeMap
typemap_StartUpdateVerification_args = Map.fromList [(2,("region",T.T_STRING)),(3,("carrier",T.T_I32)),(4,("phone",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("networkCode",T.T_STRING)),(8,("locale",T.T_STRING))]
default_StartUpdateVerification_args :: StartUpdateVerification_args
default_StartUpdateVerification_args = StartUpdateVerification_args{
  startUpdateVerification_args_region = "",
  startUpdateVerification_args_carrier = (P.toEnum 0),
  startUpdateVerification_args_phone = "",
  startUpdateVerification_args_udidHash = "",
  startUpdateVerification_args_deviceInfo = default_DeviceInfo,
  startUpdateVerification_args_networkCode = "",
  startUpdateVerification_args_locale = ""}
data StartUpdateVerification_result = StartUpdateVerification_result  { startUpdateVerification_result_success :: VerificationSessionData
  , startUpdateVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartUpdateVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startUpdateVerification_result_success record   `H.hashWithSalt` startUpdateVerification_result_e record  
instance QC.Arbitrary StartUpdateVerification_result where 
  arbitrary = M.liftM StartUpdateVerification_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StartUpdateVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartUpdateVerification_result{startUpdateVerification_result_success = startUpdateVerification_result_success obj} then P.Nothing else P.Just $ default_StartUpdateVerification_result{startUpdateVerification_result_success = startUpdateVerification_result_success obj}
    , if obj == default_StartUpdateVerification_result{startUpdateVerification_result_e = startUpdateVerification_result_e obj} then P.Nothing else P.Just $ default_StartUpdateVerification_result{startUpdateVerification_result_e = startUpdateVerification_result_e obj}
    ]
from_StartUpdateVerification_result :: StartUpdateVerification_result -> T.ThriftVal
from_StartUpdateVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9021 -> (1, ("e",from_TalkException _v9021))) <$> startUpdateVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9021 -> P.Just (0, ("success",from_VerificationSessionData _v9021))) $ startUpdateVerification_result_success record
    , (\_v9021 -> (1, ("e",from_TalkException _v9021))) <$> startUpdateVerification_result_e record
    ]
    )
write_StartUpdateVerification_result :: T.Protocol p => p -> StartUpdateVerification_result -> P.IO ()
write_StartUpdateVerification_result oprot record = T.writeVal oprot $ from_StartUpdateVerification_result record
encode_StartUpdateVerification_result :: T.StatelessProtocol p => p -> StartUpdateVerification_result -> LBS.ByteString
encode_StartUpdateVerification_result oprot record = T.serializeVal oprot $ from_StartUpdateVerification_result record
to_StartUpdateVerification_result :: T.ThriftVal -> StartUpdateVerification_result
to_StartUpdateVerification_result (T.TStruct fields) = StartUpdateVerification_result{
  startUpdateVerification_result_success = P.maybe (startUpdateVerification_result_success default_StartUpdateVerification_result) (\(_,_val9023) -> (case _val9023 of {T.TStruct _val9024 -> (to_VerificationSessionData (T.TStruct _val9024)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  startUpdateVerification_result_e = P.maybe (P.Nothing) (\(_,_val9023) -> P.Just (case _val9023 of {T.TStruct _val9025 -> (to_TalkException (T.TStruct _val9025)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartUpdateVerification_result _ = P.error "not a struct"
read_StartUpdateVerification_result :: T.Protocol p => p -> P.IO StartUpdateVerification_result
read_StartUpdateVerification_result iprot = to_StartUpdateVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_StartUpdateVerification_result)
decode_StartUpdateVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StartUpdateVerification_result
decode_StartUpdateVerification_result iprot bs = to_StartUpdateVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartUpdateVerification_result) bs
typemap_StartUpdateVerification_result :: T.TypeMap
typemap_StartUpdateVerification_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StartUpdateVerification_result :: StartUpdateVerification_result
default_StartUpdateVerification_result = StartUpdateVerification_result{
  startUpdateVerification_result_success = default_VerificationSessionData,
  startUpdateVerification_result_e = P.Nothing}
data StartVerification_args = StartVerification_args  { startVerification_args_region :: LT.Text
  , startVerification_args_carrier :: CarrierCode
  , startVerification_args_phone :: LT.Text
  , startVerification_args_udidHash :: LT.Text
  , startVerification_args_deviceInfo :: DeviceInfo
  , startVerification_args_networkCode :: LT.Text
  , startVerification_args_mid :: LT.Text
  , startVerification_args_locale :: LT.Text
  , startVerification_args_simInfo :: SIMInfo
  , startVerification_args_oldUdidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartVerification_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` startVerification_args_region record   `H.hashWithSalt` startVerification_args_carrier record   `H.hashWithSalt` startVerification_args_phone record   `H.hashWithSalt` startVerification_args_udidHash record   `H.hashWithSalt` startVerification_args_deviceInfo record   `H.hashWithSalt` startVerification_args_networkCode record   `H.hashWithSalt` startVerification_args_mid record   `H.hashWithSalt` startVerification_args_locale record   `H.hashWithSalt` startVerification_args_simInfo record   `H.hashWithSalt` startVerification_args_oldUdidHash record  
instance QC.Arbitrary StartVerification_args where 
  arbitrary = M.liftM StartVerification_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StartVerification_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartVerification_args{startVerification_args_region = startVerification_args_region obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_region = startVerification_args_region obj}
    , if obj == default_StartVerification_args{startVerification_args_carrier = startVerification_args_carrier obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_carrier = startVerification_args_carrier obj}
    , if obj == default_StartVerification_args{startVerification_args_phone = startVerification_args_phone obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_phone = startVerification_args_phone obj}
    , if obj == default_StartVerification_args{startVerification_args_udidHash = startVerification_args_udidHash obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_udidHash = startVerification_args_udidHash obj}
    , if obj == default_StartVerification_args{startVerification_args_deviceInfo = startVerification_args_deviceInfo obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_deviceInfo = startVerification_args_deviceInfo obj}
    , if obj == default_StartVerification_args{startVerification_args_networkCode = startVerification_args_networkCode obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_networkCode = startVerification_args_networkCode obj}
    , if obj == default_StartVerification_args{startVerification_args_mid = startVerification_args_mid obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_mid = startVerification_args_mid obj}
    , if obj == default_StartVerification_args{startVerification_args_locale = startVerification_args_locale obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_locale = startVerification_args_locale obj}
    , if obj == default_StartVerification_args{startVerification_args_simInfo = startVerification_args_simInfo obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_simInfo = startVerification_args_simInfo obj}
    , if obj == default_StartVerification_args{startVerification_args_oldUdidHash = startVerification_args_oldUdidHash obj} then P.Nothing else P.Just $ default_StartVerification_args{startVerification_args_oldUdidHash = startVerification_args_oldUdidHash obj}
    ]
from_StartVerification_args :: StartVerification_args -> T.ThriftVal
from_StartVerification_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9028 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_region record
  , (\_v9028 -> P.Just (3, ("carrier",T.TI32 $ P.fromIntegral $ P.fromEnum _v9028))) $ startVerification_args_carrier record
  , (\_v9028 -> P.Just (4, ("phone",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_phone record
  , (\_v9028 -> P.Just (5, ("udidHash",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_udidHash record
  , (\_v9028 -> P.Just (6, ("deviceInfo",from_DeviceInfo _v9028))) $ startVerification_args_deviceInfo record
  , (\_v9028 -> P.Just (7, ("networkCode",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_networkCode record
  , (\_v9028 -> P.Just (8, ("mid",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_mid record
  , (\_v9028 -> P.Just (9, ("locale",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_locale record
  , (\_v9028 -> P.Just (10, ("simInfo",from_SIMInfo _v9028))) $ startVerification_args_simInfo record
  , (\_v9028 -> P.Just (11, ("oldUdidHash",T.TString $ E.encodeUtf8 _v9028))) $ startVerification_args_oldUdidHash record
  ]
write_StartVerification_args :: T.Protocol p => p -> StartVerification_args -> P.IO ()
write_StartVerification_args oprot record = T.writeVal oprot $ from_StartVerification_args record
encode_StartVerification_args :: T.StatelessProtocol p => p -> StartVerification_args -> LBS.ByteString
encode_StartVerification_args oprot record = T.serializeVal oprot $ from_StartVerification_args record
to_StartVerification_args :: T.ThriftVal -> StartVerification_args
to_StartVerification_args (T.TStruct fields) = StartVerification_args{
  startVerification_args_region = P.maybe (startVerification_args_region default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9031 -> E.decodeUtf8 _val9031; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  startVerification_args_carrier = P.maybe (startVerification_args_carrier default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TI32 _val9032 -> P.toEnum $ P.fromIntegral _val9032; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  startVerification_args_phone = P.maybe (startVerification_args_phone default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9033 -> E.decodeUtf8 _val9033; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  startVerification_args_udidHash = P.maybe (startVerification_args_udidHash default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9034 -> E.decodeUtf8 _val9034; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  startVerification_args_deviceInfo = P.maybe (startVerification_args_deviceInfo default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TStruct _val9035 -> (to_DeviceInfo (T.TStruct _val9035)); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  startVerification_args_networkCode = P.maybe (startVerification_args_networkCode default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9036 -> E.decodeUtf8 _val9036; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  startVerification_args_mid = P.maybe (startVerification_args_mid default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9037 -> E.decodeUtf8 _val9037; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  startVerification_args_locale = P.maybe (startVerification_args_locale default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9038 -> E.decodeUtf8 _val9038; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  startVerification_args_simInfo = P.maybe (startVerification_args_simInfo default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TStruct _val9039 -> (to_SIMInfo (T.TStruct _val9039)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  startVerification_args_oldUdidHash = P.maybe (startVerification_args_oldUdidHash default_StartVerification_args) (\(_,_val9030) -> (case _val9030 of {T.TString _val9040 -> E.decodeUtf8 _val9040; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_StartVerification_args _ = P.error "not a struct"
read_StartVerification_args :: T.Protocol p => p -> P.IO StartVerification_args
read_StartVerification_args iprot = to_StartVerification_args <$> T.readVal iprot (T.T_STRUCT typemap_StartVerification_args)
decode_StartVerification_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StartVerification_args
decode_StartVerification_args iprot bs = to_StartVerification_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StartVerification_args) bs
typemap_StartVerification_args :: T.TypeMap
typemap_StartVerification_args = Map.fromList [(2,("region",T.T_STRING)),(3,("carrier",T.T_I32)),(4,("phone",T.T_STRING)),(5,("udidHash",T.T_STRING)),(6,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo))),(7,("networkCode",T.T_STRING)),(8,("mid",T.T_STRING)),(9,("locale",T.T_STRING)),(10,("simInfo",(T.T_STRUCT typemap_SIMInfo))),(11,("oldUdidHash",T.T_STRING))]
default_StartVerification_args :: StartVerification_args
default_StartVerification_args = StartVerification_args{
  startVerification_args_region = "",
  startVerification_args_carrier = (P.toEnum 0),
  startVerification_args_phone = "",
  startVerification_args_udidHash = "",
  startVerification_args_deviceInfo = default_DeviceInfo,
  startVerification_args_networkCode = "",
  startVerification_args_mid = "",
  startVerification_args_locale = "",
  startVerification_args_simInfo = default_SIMInfo,
  startVerification_args_oldUdidHash = ""}
data StartVerification_result = StartVerification_result  { startVerification_result_success :: VerificationSessionData
  , startVerification_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StartVerification_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` startVerification_result_success record   `H.hashWithSalt` startVerification_result_e record  
instance QC.Arbitrary StartVerification_result where 
  arbitrary = M.liftM StartVerification_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StartVerification_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StartVerification_result{startVerification_result_success = startVerification_result_success obj} then P.Nothing else P.Just $ default_StartVerification_result{startVerification_result_success = startVerification_result_success obj}
    , if obj == default_StartVerification_result{startVerification_result_e = startVerification_result_e obj} then P.Nothing else P.Just $ default_StartVerification_result{startVerification_result_e = startVerification_result_e obj}
    ]
from_StartVerification_result :: StartVerification_result -> T.ThriftVal
from_StartVerification_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9043 -> (1, ("e",from_TalkException _v9043))) <$> startVerification_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9043 -> P.Just (0, ("success",from_VerificationSessionData _v9043))) $ startVerification_result_success record
    , (\_v9043 -> (1, ("e",from_TalkException _v9043))) <$> startVerification_result_e record
    ]
    )
write_StartVerification_result :: T.Protocol p => p -> StartVerification_result -> P.IO ()
write_StartVerification_result oprot record = T.writeVal oprot $ from_StartVerification_result record
encode_StartVerification_result :: T.StatelessProtocol p => p -> StartVerification_result -> LBS.ByteString
encode_StartVerification_result oprot record = T.serializeVal oprot $ from_StartVerification_result record
to_StartVerification_result :: T.ThriftVal -> StartVerification_result
to_StartVerification_result (T.TStruct fields) = StartVerification_result{
  startVerification_result_success = P.maybe (startVerification_result_success default_StartVerification_result) (\(_,_val9045) -> (case _val9045 of {T.TStruct _val9046 -> (to_VerificationSessionData (T.TStruct _val9046)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  startVerification_result_e = P.maybe (P.Nothing) (\(_,_val9045) -> P.Just (case _val9045 of {T.TStruct _val9047 -> (to_TalkException (T.TStruct _val9047)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StartVerification_result _ = P.error "not a struct"
read_StartVerification_result :: T.Protocol p => p -> P.IO StartVerification_result
read_StartVerification_result iprot = to_StartVerification_result <$> T.readVal iprot (T.T_STRUCT typemap_StartVerification_result)
decode_StartVerification_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StartVerification_result
decode_StartVerification_result iprot bs = to_StartVerification_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StartVerification_result) bs
typemap_StartVerification_result :: T.TypeMap
typemap_StartVerification_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_VerificationSessionData))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StartVerification_result :: StartVerification_result
default_StartVerification_result = StartVerification_result{
  startVerification_result_success = default_VerificationSessionData,
  startVerification_result_e = P.Nothing}
data UpdateGroupPreferenceAttribute_args = UpdateGroupPreferenceAttribute_args  { updateGroupPreferenceAttribute_args_reqSeq :: I.Int32
  , updateGroupPreferenceAttribute_args_groupMid :: LT.Text
  , updateGroupPreferenceAttribute_args_updatedAttrs :: (Map.HashMap GroupPreferenceAttribute LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroupPreferenceAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroupPreferenceAttribute_args_reqSeq record   `H.hashWithSalt` updateGroupPreferenceAttribute_args_groupMid record   `H.hashWithSalt` updateGroupPreferenceAttribute_args_updatedAttrs record  
instance QC.Arbitrary UpdateGroupPreferenceAttribute_args where 
  arbitrary = M.liftM UpdateGroupPreferenceAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateGroupPreferenceAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_reqSeq = updateGroupPreferenceAttribute_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_reqSeq = updateGroupPreferenceAttribute_args_reqSeq obj}
    , if obj == default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_groupMid = updateGroupPreferenceAttribute_args_groupMid obj} then P.Nothing else P.Just $ default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_groupMid = updateGroupPreferenceAttribute_args_groupMid obj}
    , if obj == default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_updatedAttrs = updateGroupPreferenceAttribute_args_updatedAttrs obj} then P.Nothing else P.Just $ default_UpdateGroupPreferenceAttribute_args{updateGroupPreferenceAttribute_args_updatedAttrs = updateGroupPreferenceAttribute_args_updatedAttrs obj}
    ]
from_UpdateGroupPreferenceAttribute_args :: UpdateGroupPreferenceAttribute_args -> T.ThriftVal
from_UpdateGroupPreferenceAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9050 -> P.Just (1, ("reqSeq",T.TI32 _v9050))) $ updateGroupPreferenceAttribute_args_reqSeq record
  , (\_v9050 -> P.Just (2, ("groupMid",T.TString $ E.encodeUtf8 _v9050))) $ updateGroupPreferenceAttribute_args_groupMid record
  , (\_v9050 -> P.Just (3, ("updatedAttrs",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k9051,_v9052) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k9051, T.TString $ E.encodeUtf8 _v9052)) $ Map.toList _v9050))) $ updateGroupPreferenceAttribute_args_updatedAttrs record
  ]
write_UpdateGroupPreferenceAttribute_args :: T.Protocol p => p -> UpdateGroupPreferenceAttribute_args -> P.IO ()
write_UpdateGroupPreferenceAttribute_args oprot record = T.writeVal oprot $ from_UpdateGroupPreferenceAttribute_args record
encode_UpdateGroupPreferenceAttribute_args :: T.StatelessProtocol p => p -> UpdateGroupPreferenceAttribute_args -> LBS.ByteString
encode_UpdateGroupPreferenceAttribute_args oprot record = T.serializeVal oprot $ from_UpdateGroupPreferenceAttribute_args record
to_UpdateGroupPreferenceAttribute_args :: T.ThriftVal -> UpdateGroupPreferenceAttribute_args
to_UpdateGroupPreferenceAttribute_args (T.TStruct fields) = UpdateGroupPreferenceAttribute_args{
  updateGroupPreferenceAttribute_args_reqSeq = P.maybe (updateGroupPreferenceAttribute_args_reqSeq default_UpdateGroupPreferenceAttribute_args) (\(_,_val9054) -> (case _val9054 of {T.TI32 _val9055 -> _val9055; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateGroupPreferenceAttribute_args_groupMid = P.maybe (updateGroupPreferenceAttribute_args_groupMid default_UpdateGroupPreferenceAttribute_args) (\(_,_val9054) -> (case _val9054 of {T.TString _val9056 -> E.decodeUtf8 _val9056; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateGroupPreferenceAttribute_args_updatedAttrs = P.maybe (updateGroupPreferenceAttribute_args_updatedAttrs default_UpdateGroupPreferenceAttribute_args) (\(_,_val9054) -> (case _val9054 of {T.TMap _ _ _val9057 -> (Map.fromList $ P.map (\(_k9059,_v9058) -> ((case _k9059 of {T.TI32 _val9060 -> P.toEnum $ P.fromIntegral _val9060; _ -> P.error "wrong type"}),(case _v9058 of {T.TString _val9061 -> E.decodeUtf8 _val9061; _ -> P.error "wrong type"}))) _val9057); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateGroupPreferenceAttribute_args _ = P.error "not a struct"
read_UpdateGroupPreferenceAttribute_args :: T.Protocol p => p -> P.IO UpdateGroupPreferenceAttribute_args
read_UpdateGroupPreferenceAttribute_args iprot = to_UpdateGroupPreferenceAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroupPreferenceAttribute_args)
decode_UpdateGroupPreferenceAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroupPreferenceAttribute_args
decode_UpdateGroupPreferenceAttribute_args iprot bs = to_UpdateGroupPreferenceAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroupPreferenceAttribute_args) bs
typemap_UpdateGroupPreferenceAttribute_args :: T.TypeMap
typemap_UpdateGroupPreferenceAttribute_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("groupMid",T.T_STRING)),(3,("updatedAttrs",(T.T_MAP T.T_I32 T.T_STRING)))]
default_UpdateGroupPreferenceAttribute_args :: UpdateGroupPreferenceAttribute_args
default_UpdateGroupPreferenceAttribute_args = UpdateGroupPreferenceAttribute_args{
  updateGroupPreferenceAttribute_args_reqSeq = 0,
  updateGroupPreferenceAttribute_args_groupMid = "",
  updateGroupPreferenceAttribute_args_updatedAttrs = Map.empty}
data UpdateGroupPreferenceAttribute_result = UpdateGroupPreferenceAttribute_result  { updateGroupPreferenceAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroupPreferenceAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroupPreferenceAttribute_result_e record  
instance QC.Arbitrary UpdateGroupPreferenceAttribute_result where 
  arbitrary = M.liftM UpdateGroupPreferenceAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateGroupPreferenceAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroupPreferenceAttribute_result{updateGroupPreferenceAttribute_result_e = updateGroupPreferenceAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateGroupPreferenceAttribute_result{updateGroupPreferenceAttribute_result_e = updateGroupPreferenceAttribute_result_e obj}
    ]
from_UpdateGroupPreferenceAttribute_result :: UpdateGroupPreferenceAttribute_result -> T.ThriftVal
from_UpdateGroupPreferenceAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9064 -> (1, ("e",from_TalkException _v9064))) <$> updateGroupPreferenceAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9064 -> (1, ("e",from_TalkException _v9064))) <$> updateGroupPreferenceAttribute_result_e record
    ]
    )
write_UpdateGroupPreferenceAttribute_result :: T.Protocol p => p -> UpdateGroupPreferenceAttribute_result -> P.IO ()
write_UpdateGroupPreferenceAttribute_result oprot record = T.writeVal oprot $ from_UpdateGroupPreferenceAttribute_result record
encode_UpdateGroupPreferenceAttribute_result :: T.StatelessProtocol p => p -> UpdateGroupPreferenceAttribute_result -> LBS.ByteString
encode_UpdateGroupPreferenceAttribute_result oprot record = T.serializeVal oprot $ from_UpdateGroupPreferenceAttribute_result record
to_UpdateGroupPreferenceAttribute_result :: T.ThriftVal -> UpdateGroupPreferenceAttribute_result
to_UpdateGroupPreferenceAttribute_result (T.TStruct fields) = UpdateGroupPreferenceAttribute_result{
  updateGroupPreferenceAttribute_result_e = P.maybe (P.Nothing) (\(_,_val9066) -> P.Just (case _val9066 of {T.TStruct _val9067 -> (to_TalkException (T.TStruct _val9067)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateGroupPreferenceAttribute_result _ = P.error "not a struct"
read_UpdateGroupPreferenceAttribute_result :: T.Protocol p => p -> P.IO UpdateGroupPreferenceAttribute_result
read_UpdateGroupPreferenceAttribute_result iprot = to_UpdateGroupPreferenceAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroupPreferenceAttribute_result)
decode_UpdateGroupPreferenceAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroupPreferenceAttribute_result
decode_UpdateGroupPreferenceAttribute_result iprot bs = to_UpdateGroupPreferenceAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroupPreferenceAttribute_result) bs
typemap_UpdateGroupPreferenceAttribute_result :: T.TypeMap
typemap_UpdateGroupPreferenceAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateGroupPreferenceAttribute_result :: UpdateGroupPreferenceAttribute_result
default_UpdateGroupPreferenceAttribute_result = UpdateGroupPreferenceAttribute_result{
  updateGroupPreferenceAttribute_result_e = P.Nothing}
data CreateRoomV2_args = CreateRoomV2_args  { createRoomV2_args_reqSeq :: I.Int32
  , createRoomV2_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomV2_args_reqSeq record   `H.hashWithSalt` createRoomV2_args_contactIds record  
instance QC.Arbitrary CreateRoomV2_args where 
  arbitrary = M.liftM CreateRoomV2_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateRoomV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomV2_args{createRoomV2_args_reqSeq = createRoomV2_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateRoomV2_args{createRoomV2_args_reqSeq = createRoomV2_args_reqSeq obj}
    , if obj == default_CreateRoomV2_args{createRoomV2_args_contactIds = createRoomV2_args_contactIds obj} then P.Nothing else P.Just $ default_CreateRoomV2_args{createRoomV2_args_contactIds = createRoomV2_args_contactIds obj}
    ]
from_CreateRoomV2_args :: CreateRoomV2_args -> T.ThriftVal
from_CreateRoomV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9070 -> P.Just (1, ("reqSeq",T.TI32 _v9070))) $ createRoomV2_args_reqSeq record
  , (\_v9070 -> P.Just (2, ("contactIds",T.TList T.T_STRING $ P.map (\_v9072 -> T.TString $ E.encodeUtf8 _v9072) $ Vector.toList _v9070))) $ createRoomV2_args_contactIds record
  ]
write_CreateRoomV2_args :: T.Protocol p => p -> CreateRoomV2_args -> P.IO ()
write_CreateRoomV2_args oprot record = T.writeVal oprot $ from_CreateRoomV2_args record
encode_CreateRoomV2_args :: T.StatelessProtocol p => p -> CreateRoomV2_args -> LBS.ByteString
encode_CreateRoomV2_args oprot record = T.serializeVal oprot $ from_CreateRoomV2_args record
to_CreateRoomV2_args :: T.ThriftVal -> CreateRoomV2_args
to_CreateRoomV2_args (T.TStruct fields) = CreateRoomV2_args{
  createRoomV2_args_reqSeq = P.maybe (createRoomV2_args_reqSeq default_CreateRoomV2_args) (\(_,_val9074) -> (case _val9074 of {T.TI32 _val9075 -> _val9075; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createRoomV2_args_contactIds = P.maybe (createRoomV2_args_contactIds default_CreateRoomV2_args) (\(_,_val9074) -> (case _val9074 of {T.TList _ _val9076 -> (Vector.fromList $ P.map (\_v9077 -> (case _v9077 of {T.TString _val9078 -> E.decodeUtf8 _val9078; _ -> P.error "wrong type"})) _val9076); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateRoomV2_args _ = P.error "not a struct"
read_CreateRoomV2_args :: T.Protocol p => p -> P.IO CreateRoomV2_args
read_CreateRoomV2_args iprot = to_CreateRoomV2_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomV2_args)
decode_CreateRoomV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomV2_args
decode_CreateRoomV2_args iprot bs = to_CreateRoomV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomV2_args) bs
typemap_CreateRoomV2_args :: T.TypeMap
typemap_CreateRoomV2_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateRoomV2_args :: CreateRoomV2_args
default_CreateRoomV2_args = CreateRoomV2_args{
  createRoomV2_args_reqSeq = 0,
  createRoomV2_args_contactIds = Vector.empty}
data CreateRoomV2_result = CreateRoomV2_result  { createRoomV2_result_success :: Room
  , createRoomV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomV2_result_success record   `H.hashWithSalt` createRoomV2_result_e record  
instance QC.Arbitrary CreateRoomV2_result where 
  arbitrary = M.liftM CreateRoomV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateRoomV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomV2_result{createRoomV2_result_success = createRoomV2_result_success obj} then P.Nothing else P.Just $ default_CreateRoomV2_result{createRoomV2_result_success = createRoomV2_result_success obj}
    , if obj == default_CreateRoomV2_result{createRoomV2_result_e = createRoomV2_result_e obj} then P.Nothing else P.Just $ default_CreateRoomV2_result{createRoomV2_result_e = createRoomV2_result_e obj}
    ]
from_CreateRoomV2_result :: CreateRoomV2_result -> T.ThriftVal
from_CreateRoomV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9081 -> (1, ("e",from_TalkException _v9081))) <$> createRoomV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9081 -> P.Just (0, ("success",from_Room _v9081))) $ createRoomV2_result_success record
    , (\_v9081 -> (1, ("e",from_TalkException _v9081))) <$> createRoomV2_result_e record
    ]
    )
write_CreateRoomV2_result :: T.Protocol p => p -> CreateRoomV2_result -> P.IO ()
write_CreateRoomV2_result oprot record = T.writeVal oprot $ from_CreateRoomV2_result record
encode_CreateRoomV2_result :: T.StatelessProtocol p => p -> CreateRoomV2_result -> LBS.ByteString
encode_CreateRoomV2_result oprot record = T.serializeVal oprot $ from_CreateRoomV2_result record
to_CreateRoomV2_result :: T.ThriftVal -> CreateRoomV2_result
to_CreateRoomV2_result (T.TStruct fields) = CreateRoomV2_result{
  createRoomV2_result_success = P.maybe (createRoomV2_result_success default_CreateRoomV2_result) (\(_,_val9083) -> (case _val9083 of {T.TStruct _val9084 -> (to_Room (T.TStruct _val9084)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createRoomV2_result_e = P.maybe (P.Nothing) (\(_,_val9083) -> P.Just (case _val9083 of {T.TStruct _val9085 -> (to_TalkException (T.TStruct _val9085)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateRoomV2_result _ = P.error "not a struct"
read_CreateRoomV2_result :: T.Protocol p => p -> P.IO CreateRoomV2_result
read_CreateRoomV2_result iprot = to_CreateRoomV2_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomV2_result)
decode_CreateRoomV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomV2_result
decode_CreateRoomV2_result iprot bs = to_CreateRoomV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomV2_result) bs
typemap_CreateRoomV2_result :: T.TypeMap
typemap_CreateRoomV2_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateRoomV2_result :: CreateRoomV2_result
default_CreateRoomV2_result = CreateRoomV2_result{
  createRoomV2_result_success = default_Room,
  createRoomV2_result_e = P.Nothing}
data StoreUpdateProfileAttribute_args = StoreUpdateProfileAttribute_args  { storeUpdateProfileAttribute_args_seq :: I.Int32
  , storeUpdateProfileAttribute_args_profileAttribute :: ProfileAttribute
  , storeUpdateProfileAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StoreUpdateProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` storeUpdateProfileAttribute_args_seq record   `H.hashWithSalt` storeUpdateProfileAttribute_args_profileAttribute record   `H.hashWithSalt` storeUpdateProfileAttribute_args_value record  
instance QC.Arbitrary StoreUpdateProfileAttribute_args where 
  arbitrary = M.liftM StoreUpdateProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StoreUpdateProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_seq = storeUpdateProfileAttribute_args_seq obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_seq = storeUpdateProfileAttribute_args_seq obj}
    , if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_profileAttribute = storeUpdateProfileAttribute_args_profileAttribute obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_profileAttribute = storeUpdateProfileAttribute_args_profileAttribute obj}
    , if obj == default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_value = storeUpdateProfileAttribute_args_value obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_args{storeUpdateProfileAttribute_args_value = storeUpdateProfileAttribute_args_value obj}
    ]
from_StoreUpdateProfileAttribute_args :: StoreUpdateProfileAttribute_args -> T.ThriftVal
from_StoreUpdateProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9088 -> P.Just (1, ("seq",T.TI32 _v9088))) $ storeUpdateProfileAttribute_args_seq record
  , (\_v9088 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v9088))) $ storeUpdateProfileAttribute_args_profileAttribute record
  , (\_v9088 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v9088))) $ storeUpdateProfileAttribute_args_value record
  ]
write_StoreUpdateProfileAttribute_args :: T.Protocol p => p -> StoreUpdateProfileAttribute_args -> P.IO ()
write_StoreUpdateProfileAttribute_args oprot record = T.writeVal oprot $ from_StoreUpdateProfileAttribute_args record
encode_StoreUpdateProfileAttribute_args :: T.StatelessProtocol p => p -> StoreUpdateProfileAttribute_args -> LBS.ByteString
encode_StoreUpdateProfileAttribute_args oprot record = T.serializeVal oprot $ from_StoreUpdateProfileAttribute_args record
to_StoreUpdateProfileAttribute_args :: T.ThriftVal -> StoreUpdateProfileAttribute_args
to_StoreUpdateProfileAttribute_args (T.TStruct fields) = StoreUpdateProfileAttribute_args{
  storeUpdateProfileAttribute_args_seq = P.maybe (storeUpdateProfileAttribute_args_seq default_StoreUpdateProfileAttribute_args) (\(_,_val9090) -> (case _val9090 of {T.TI32 _val9091 -> _val9091; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  storeUpdateProfileAttribute_args_profileAttribute = P.maybe (storeUpdateProfileAttribute_args_profileAttribute default_StoreUpdateProfileAttribute_args) (\(_,_val9090) -> (case _val9090 of {T.TI32 _val9092 -> P.toEnum $ P.fromIntegral _val9092; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  storeUpdateProfileAttribute_args_value = P.maybe (storeUpdateProfileAttribute_args_value default_StoreUpdateProfileAttribute_args) (\(_,_val9090) -> (case _val9090 of {T.TString _val9093 -> E.decodeUtf8 _val9093; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_StoreUpdateProfileAttribute_args _ = P.error "not a struct"
read_StoreUpdateProfileAttribute_args :: T.Protocol p => p -> P.IO StoreUpdateProfileAttribute_args
read_StoreUpdateProfileAttribute_args iprot = to_StoreUpdateProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_args)
decode_StoreUpdateProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StoreUpdateProfileAttribute_args
decode_StoreUpdateProfileAttribute_args iprot bs = to_StoreUpdateProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_args) bs
typemap_StoreUpdateProfileAttribute_args :: T.TypeMap
typemap_StoreUpdateProfileAttribute_args = Map.fromList [(1,("seq",T.T_I32)),(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_StoreUpdateProfileAttribute_args :: StoreUpdateProfileAttribute_args
default_StoreUpdateProfileAttribute_args = StoreUpdateProfileAttribute_args{
  storeUpdateProfileAttribute_args_seq = 0,
  storeUpdateProfileAttribute_args_profileAttribute = (P.toEnum 0),
  storeUpdateProfileAttribute_args_value = ""}
data StoreUpdateProfileAttribute_result = StoreUpdateProfileAttribute_result  { storeUpdateProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StoreUpdateProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` storeUpdateProfileAttribute_result_e record  
instance QC.Arbitrary StoreUpdateProfileAttribute_result where 
  arbitrary = M.liftM StoreUpdateProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StoreUpdateProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = storeUpdateProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = storeUpdateProfileAttribute_result_e obj}
    ]
from_StoreUpdateProfileAttribute_result :: StoreUpdateProfileAttribute_result -> T.ThriftVal
from_StoreUpdateProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9096 -> (1, ("e",from_TalkException _v9096))) <$> storeUpdateProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9096 -> (1, ("e",from_TalkException _v9096))) <$> storeUpdateProfileAttribute_result_e record
    ]
    )
write_StoreUpdateProfileAttribute_result :: T.Protocol p => p -> StoreUpdateProfileAttribute_result -> P.IO ()
write_StoreUpdateProfileAttribute_result oprot record = T.writeVal oprot $ from_StoreUpdateProfileAttribute_result record
encode_StoreUpdateProfileAttribute_result :: T.StatelessProtocol p => p -> StoreUpdateProfileAttribute_result -> LBS.ByteString
encode_StoreUpdateProfileAttribute_result oprot record = T.serializeVal oprot $ from_StoreUpdateProfileAttribute_result record
to_StoreUpdateProfileAttribute_result :: T.ThriftVal -> StoreUpdateProfileAttribute_result
to_StoreUpdateProfileAttribute_result (T.TStruct fields) = StoreUpdateProfileAttribute_result{
  storeUpdateProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val9098) -> P.Just (case _val9098 of {T.TStruct _val9099 -> (to_TalkException (T.TStruct _val9099)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_StoreUpdateProfileAttribute_result _ = P.error "not a struct"
read_StoreUpdateProfileAttribute_result :: T.Protocol p => p -> P.IO StoreUpdateProfileAttribute_result
read_StoreUpdateProfileAttribute_result iprot = to_StoreUpdateProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_result)
decode_StoreUpdateProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StoreUpdateProfileAttribute_result
decode_StoreUpdateProfileAttribute_result iprot bs = to_StoreUpdateProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StoreUpdateProfileAttribute_result) bs
typemap_StoreUpdateProfileAttribute_result :: T.TypeMap
typemap_StoreUpdateProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_StoreUpdateProfileAttribute_result :: StoreUpdateProfileAttribute_result
default_StoreUpdateProfileAttribute_result = StoreUpdateProfileAttribute_result{
  storeUpdateProfileAttribute_result_e = P.Nothing}
data SyncContactBySnsIds_args = SyncContactBySnsIds_args  { syncContactBySnsIds_args_reqSeq :: I.Int32
  , syncContactBySnsIds_args_modifications :: (Vector.Vector SnsFriendModification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContactBySnsIds_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContactBySnsIds_args_reqSeq record   `H.hashWithSalt` syncContactBySnsIds_args_modifications record  
instance QC.Arbitrary SyncContactBySnsIds_args where 
  arbitrary = M.liftM SyncContactBySnsIds_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncContactBySnsIds_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContactBySnsIds_args{syncContactBySnsIds_args_reqSeq = syncContactBySnsIds_args_reqSeq obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_args{syncContactBySnsIds_args_reqSeq = syncContactBySnsIds_args_reqSeq obj}
    , if obj == default_SyncContactBySnsIds_args{syncContactBySnsIds_args_modifications = syncContactBySnsIds_args_modifications obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_args{syncContactBySnsIds_args_modifications = syncContactBySnsIds_args_modifications obj}
    ]
from_SyncContactBySnsIds_args :: SyncContactBySnsIds_args -> T.ThriftVal
from_SyncContactBySnsIds_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9102 -> P.Just (1, ("reqSeq",T.TI32 _v9102))) $ syncContactBySnsIds_args_reqSeq record
  , (\_v9102 -> P.Just (2, ("modifications",T.TList (T.T_STRUCT typemap_SnsFriendModification) $ P.map (\_v9104 -> from_SnsFriendModification _v9104) $ Vector.toList _v9102))) $ syncContactBySnsIds_args_modifications record
  ]
write_SyncContactBySnsIds_args :: T.Protocol p => p -> SyncContactBySnsIds_args -> P.IO ()
write_SyncContactBySnsIds_args oprot record = T.writeVal oprot $ from_SyncContactBySnsIds_args record
encode_SyncContactBySnsIds_args :: T.StatelessProtocol p => p -> SyncContactBySnsIds_args -> LBS.ByteString
encode_SyncContactBySnsIds_args oprot record = T.serializeVal oprot $ from_SyncContactBySnsIds_args record
to_SyncContactBySnsIds_args :: T.ThriftVal -> SyncContactBySnsIds_args
to_SyncContactBySnsIds_args (T.TStruct fields) = SyncContactBySnsIds_args{
  syncContactBySnsIds_args_reqSeq = P.maybe (syncContactBySnsIds_args_reqSeq default_SyncContactBySnsIds_args) (\(_,_val9106) -> (case _val9106 of {T.TI32 _val9107 -> _val9107; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncContactBySnsIds_args_modifications = P.maybe (syncContactBySnsIds_args_modifications default_SyncContactBySnsIds_args) (\(_,_val9106) -> (case _val9106 of {T.TList _ _val9108 -> (Vector.fromList $ P.map (\_v9109 -> (case _v9109 of {T.TStruct _val9110 -> (to_SnsFriendModification (T.TStruct _val9110)); _ -> P.error "wrong type"})) _val9108); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SyncContactBySnsIds_args _ = P.error "not a struct"
read_SyncContactBySnsIds_args :: T.Protocol p => p -> P.IO SyncContactBySnsIds_args
read_SyncContactBySnsIds_args iprot = to_SyncContactBySnsIds_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_args)
decode_SyncContactBySnsIds_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContactBySnsIds_args
decode_SyncContactBySnsIds_args iprot bs = to_SyncContactBySnsIds_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_args) bs
typemap_SyncContactBySnsIds_args :: T.TypeMap
typemap_SyncContactBySnsIds_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("modifications",(T.T_LIST (T.T_STRUCT typemap_SnsFriendModification))))]
default_SyncContactBySnsIds_args :: SyncContactBySnsIds_args
default_SyncContactBySnsIds_args = SyncContactBySnsIds_args{
  syncContactBySnsIds_args_reqSeq = 0,
  syncContactBySnsIds_args_modifications = Vector.empty}
data SyncContactBySnsIds_result = SyncContactBySnsIds_result  { syncContactBySnsIds_result_success :: (Vector.Vector SnsFriendContactRegistration)
  , syncContactBySnsIds_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContactBySnsIds_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContactBySnsIds_result_success record   `H.hashWithSalt` syncContactBySnsIds_result_e record  
instance QC.Arbitrary SyncContactBySnsIds_result where 
  arbitrary = M.liftM SyncContactBySnsIds_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncContactBySnsIds_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = syncContactBySnsIds_result_success obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = syncContactBySnsIds_result_success obj}
    , if obj == default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = syncContactBySnsIds_result_e obj} then P.Nothing else P.Just $ default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = syncContactBySnsIds_result_e obj}
    ]
from_SyncContactBySnsIds_result :: SyncContactBySnsIds_result -> T.ThriftVal
from_SyncContactBySnsIds_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9113 -> (1, ("e",from_TalkException _v9113))) <$> syncContactBySnsIds_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9113 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SnsFriendContactRegistration) $ P.map (\_v9115 -> from_SnsFriendContactRegistration _v9115) $ Vector.toList _v9113))) $ syncContactBySnsIds_result_success record
    , (\_v9113 -> (1, ("e",from_TalkException _v9113))) <$> syncContactBySnsIds_result_e record
    ]
    )
write_SyncContactBySnsIds_result :: T.Protocol p => p -> SyncContactBySnsIds_result -> P.IO ()
write_SyncContactBySnsIds_result oprot record = T.writeVal oprot $ from_SyncContactBySnsIds_result record
encode_SyncContactBySnsIds_result :: T.StatelessProtocol p => p -> SyncContactBySnsIds_result -> LBS.ByteString
encode_SyncContactBySnsIds_result oprot record = T.serializeVal oprot $ from_SyncContactBySnsIds_result record
to_SyncContactBySnsIds_result :: T.ThriftVal -> SyncContactBySnsIds_result
to_SyncContactBySnsIds_result (T.TStruct fields) = SyncContactBySnsIds_result{
  syncContactBySnsIds_result_success = P.maybe (syncContactBySnsIds_result_success default_SyncContactBySnsIds_result) (\(_,_val9117) -> (case _val9117 of {T.TList _ _val9118 -> (Vector.fromList $ P.map (\_v9119 -> (case _v9119 of {T.TStruct _val9120 -> (to_SnsFriendContactRegistration (T.TStruct _val9120)); _ -> P.error "wrong type"})) _val9118); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncContactBySnsIds_result_e = P.maybe (P.Nothing) (\(_,_val9117) -> P.Just (case _val9117 of {T.TStruct _val9121 -> (to_TalkException (T.TStruct _val9121)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncContactBySnsIds_result _ = P.error "not a struct"
read_SyncContactBySnsIds_result :: T.Protocol p => p -> P.IO SyncContactBySnsIds_result
read_SyncContactBySnsIds_result iprot = to_SyncContactBySnsIds_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_result)
decode_SyncContactBySnsIds_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContactBySnsIds_result
decode_SyncContactBySnsIds_result iprot bs = to_SyncContactBySnsIds_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContactBySnsIds_result) bs
typemap_SyncContactBySnsIds_result :: T.TypeMap
typemap_SyncContactBySnsIds_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SnsFriendContactRegistration)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SyncContactBySnsIds_result :: SyncContactBySnsIds_result
default_SyncContactBySnsIds_result = SyncContactBySnsIds_result{
  syncContactBySnsIds_result_success = Vector.empty,
  syncContactBySnsIds_result_e = P.Nothing}
data SyncContacts_args = SyncContacts_args  { syncContacts_args_reqSeq :: I.Int32
  , syncContacts_args_localContacts :: (Vector.Vector ContactModification)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContacts_args_reqSeq record   `H.hashWithSalt` syncContacts_args_localContacts record  
instance QC.Arbitrary SyncContacts_args where 
  arbitrary = M.liftM SyncContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SyncContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContacts_args{syncContacts_args_reqSeq = syncContacts_args_reqSeq obj} then P.Nothing else P.Just $ default_SyncContacts_args{syncContacts_args_reqSeq = syncContacts_args_reqSeq obj}
    , if obj == default_SyncContacts_args{syncContacts_args_localContacts = syncContacts_args_localContacts obj} then P.Nothing else P.Just $ default_SyncContacts_args{syncContacts_args_localContacts = syncContacts_args_localContacts obj}
    ]
from_SyncContacts_args :: SyncContacts_args -> T.ThriftVal
from_SyncContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9124 -> P.Just (1, ("reqSeq",T.TI32 _v9124))) $ syncContacts_args_reqSeq record
  , (\_v9124 -> P.Just (2, ("localContacts",T.TList (T.T_STRUCT typemap_ContactModification) $ P.map (\_v9126 -> from_ContactModification _v9126) $ Vector.toList _v9124))) $ syncContacts_args_localContacts record
  ]
write_SyncContacts_args :: T.Protocol p => p -> SyncContacts_args -> P.IO ()
write_SyncContacts_args oprot record = T.writeVal oprot $ from_SyncContacts_args record
encode_SyncContacts_args :: T.StatelessProtocol p => p -> SyncContacts_args -> LBS.ByteString
encode_SyncContacts_args oprot record = T.serializeVal oprot $ from_SyncContacts_args record
to_SyncContacts_args :: T.ThriftVal -> SyncContacts_args
to_SyncContacts_args (T.TStruct fields) = SyncContacts_args{
  syncContacts_args_reqSeq = P.maybe (syncContacts_args_reqSeq default_SyncContacts_args) (\(_,_val9128) -> (case _val9128 of {T.TI32 _val9129 -> _val9129; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncContacts_args_localContacts = P.maybe (syncContacts_args_localContacts default_SyncContacts_args) (\(_,_val9128) -> (case _val9128 of {T.TList _ _val9130 -> (Vector.fromList $ P.map (\_v9131 -> (case _v9131 of {T.TStruct _val9132 -> (to_ContactModification (T.TStruct _val9132)); _ -> P.error "wrong type"})) _val9130); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SyncContacts_args _ = P.error "not a struct"
read_SyncContacts_args :: T.Protocol p => p -> P.IO SyncContacts_args
read_SyncContacts_args iprot = to_SyncContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_SyncContacts_args)
decode_SyncContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContacts_args
decode_SyncContacts_args iprot bs = to_SyncContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContacts_args) bs
typemap_SyncContacts_args :: T.TypeMap
typemap_SyncContacts_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("localContacts",(T.T_LIST (T.T_STRUCT typemap_ContactModification))))]
default_SyncContacts_args :: SyncContacts_args
default_SyncContacts_args = SyncContacts_args{
  syncContacts_args_reqSeq = 0,
  syncContacts_args_localContacts = Vector.empty}
data SyncContacts_result = SyncContacts_result  { syncContacts_result_success :: (Map.HashMap LT.Text ContactRegistration)
  , syncContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncContacts_result_success record   `H.hashWithSalt` syncContacts_result_e record  
instance QC.Arbitrary SyncContacts_result where 
  arbitrary = M.liftM SyncContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncContacts_result{syncContacts_result_success = syncContacts_result_success obj} then P.Nothing else P.Just $ default_SyncContacts_result{syncContacts_result_success = syncContacts_result_success obj}
    , if obj == default_SyncContacts_result{syncContacts_result_e = syncContacts_result_e obj} then P.Nothing else P.Just $ default_SyncContacts_result{syncContacts_result_e = syncContacts_result_e obj}
    ]
from_SyncContacts_result :: SyncContacts_result -> T.ThriftVal
from_SyncContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9135 -> (1, ("e",from_TalkException _v9135))) <$> syncContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9135 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_ContactRegistration) $ P.map (\(_k9136,_v9137) -> (T.TString $ E.encodeUtf8 _k9136, from_ContactRegistration _v9137)) $ Map.toList _v9135))) $ syncContacts_result_success record
    , (\_v9135 -> (1, ("e",from_TalkException _v9135))) <$> syncContacts_result_e record
    ]
    )
write_SyncContacts_result :: T.Protocol p => p -> SyncContacts_result -> P.IO ()
write_SyncContacts_result oprot record = T.writeVal oprot $ from_SyncContacts_result record
encode_SyncContacts_result :: T.StatelessProtocol p => p -> SyncContacts_result -> LBS.ByteString
encode_SyncContacts_result oprot record = T.serializeVal oprot $ from_SyncContacts_result record
to_SyncContacts_result :: T.ThriftVal -> SyncContacts_result
to_SyncContacts_result (T.TStruct fields) = SyncContacts_result{
  syncContacts_result_success = P.maybe (syncContacts_result_success default_SyncContacts_result) (\(_,_val9139) -> (case _val9139 of {T.TMap _ _ _val9140 -> (Map.fromList $ P.map (\(_k9142,_v9141) -> ((case _k9142 of {T.TString _val9143 -> E.decodeUtf8 _val9143; _ -> P.error "wrong type"}),(case _v9141 of {T.TStruct _val9144 -> (to_ContactRegistration (T.TStruct _val9144)); _ -> P.error "wrong type"}))) _val9140); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  syncContacts_result_e = P.maybe (P.Nothing) (\(_,_val9139) -> P.Just (case _val9139 of {T.TStruct _val9145 -> (to_TalkException (T.TStruct _val9145)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SyncContacts_result _ = P.error "not a struct"
read_SyncContacts_result :: T.Protocol p => p -> P.IO SyncContacts_result
read_SyncContacts_result iprot = to_SyncContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_SyncContacts_result)
decode_SyncContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncContacts_result
decode_SyncContacts_result iprot bs = to_SyncContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncContacts_result) bs
typemap_SyncContacts_result :: T.TypeMap
typemap_SyncContacts_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_ContactRegistration)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SyncContacts_result :: SyncContacts_result
default_SyncContacts_result = SyncContacts_result{
  syncContacts_result_success = Map.empty,
  syncContacts_result_e = P.Nothing}
data TrySendMessage_args = TrySendMessage_args  { trySendMessage_args_seq :: I.Int32
  , trySendMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TrySendMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` trySendMessage_args_seq record   `H.hashWithSalt` trySendMessage_args_message record  
instance QC.Arbitrary TrySendMessage_args where 
  arbitrary = M.liftM TrySendMessage_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TrySendMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TrySendMessage_args{trySendMessage_args_seq = trySendMessage_args_seq obj} then P.Nothing else P.Just $ default_TrySendMessage_args{trySendMessage_args_seq = trySendMessage_args_seq obj}
    , if obj == default_TrySendMessage_args{trySendMessage_args_message = trySendMessage_args_message obj} then P.Nothing else P.Just $ default_TrySendMessage_args{trySendMessage_args_message = trySendMessage_args_message obj}
    ]
from_TrySendMessage_args :: TrySendMessage_args -> T.ThriftVal
from_TrySendMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9148 -> P.Just (1, ("seq",T.TI32 _v9148))) $ trySendMessage_args_seq record
  , (\_v9148 -> P.Just (2, ("message",from_Message _v9148))) $ trySendMessage_args_message record
  ]
write_TrySendMessage_args :: T.Protocol p => p -> TrySendMessage_args -> P.IO ()
write_TrySendMessage_args oprot record = T.writeVal oprot $ from_TrySendMessage_args record
encode_TrySendMessage_args :: T.StatelessProtocol p => p -> TrySendMessage_args -> LBS.ByteString
encode_TrySendMessage_args oprot record = T.serializeVal oprot $ from_TrySendMessage_args record
to_TrySendMessage_args :: T.ThriftVal -> TrySendMessage_args
to_TrySendMessage_args (T.TStruct fields) = TrySendMessage_args{
  trySendMessage_args_seq = P.maybe (trySendMessage_args_seq default_TrySendMessage_args) (\(_,_val9150) -> (case _val9150 of {T.TI32 _val9151 -> _val9151; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  trySendMessage_args_message = P.maybe (trySendMessage_args_message default_TrySendMessage_args) (\(_,_val9150) -> (case _val9150 of {T.TStruct _val9152 -> (to_Message (T.TStruct _val9152)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_TrySendMessage_args _ = P.error "not a struct"
read_TrySendMessage_args :: T.Protocol p => p -> P.IO TrySendMessage_args
read_TrySendMessage_args iprot = to_TrySendMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_TrySendMessage_args)
decode_TrySendMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> TrySendMessage_args
decode_TrySendMessage_args iprot bs = to_TrySendMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TrySendMessage_args) bs
typemap_TrySendMessage_args :: T.TypeMap
typemap_TrySendMessage_args = Map.fromList [(1,("seq",T.T_I32)),(2,("message",(T.T_STRUCT typemap_Message)))]
default_TrySendMessage_args :: TrySendMessage_args
default_TrySendMessage_args = TrySendMessage_args{
  trySendMessage_args_seq = 0,
  trySendMessage_args_message = default_Message}
data TrySendMessage_result = TrySendMessage_result  { trySendMessage_result_success :: Message
  , trySendMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TrySendMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` trySendMessage_result_success record   `H.hashWithSalt` trySendMessage_result_e record  
instance QC.Arbitrary TrySendMessage_result where 
  arbitrary = M.liftM TrySendMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TrySendMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TrySendMessage_result{trySendMessage_result_success = trySendMessage_result_success obj} then P.Nothing else P.Just $ default_TrySendMessage_result{trySendMessage_result_success = trySendMessage_result_success obj}
    , if obj == default_TrySendMessage_result{trySendMessage_result_e = trySendMessage_result_e obj} then P.Nothing else P.Just $ default_TrySendMessage_result{trySendMessage_result_e = trySendMessage_result_e obj}
    ]
from_TrySendMessage_result :: TrySendMessage_result -> T.ThriftVal
from_TrySendMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9155 -> (1, ("e",from_TalkException _v9155))) <$> trySendMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9155 -> P.Just (0, ("success",from_Message _v9155))) $ trySendMessage_result_success record
    , (\_v9155 -> (1, ("e",from_TalkException _v9155))) <$> trySendMessage_result_e record
    ]
    )
write_TrySendMessage_result :: T.Protocol p => p -> TrySendMessage_result -> P.IO ()
write_TrySendMessage_result oprot record = T.writeVal oprot $ from_TrySendMessage_result record
encode_TrySendMessage_result :: T.StatelessProtocol p => p -> TrySendMessage_result -> LBS.ByteString
encode_TrySendMessage_result oprot record = T.serializeVal oprot $ from_TrySendMessage_result record
to_TrySendMessage_result :: T.ThriftVal -> TrySendMessage_result
to_TrySendMessage_result (T.TStruct fields) = TrySendMessage_result{
  trySendMessage_result_success = P.maybe (trySendMessage_result_success default_TrySendMessage_result) (\(_,_val9157) -> (case _val9157 of {T.TStruct _val9158 -> (to_Message (T.TStruct _val9158)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  trySendMessage_result_e = P.maybe (P.Nothing) (\(_,_val9157) -> P.Just (case _val9157 of {T.TStruct _val9159 -> (to_TalkException (T.TStruct _val9159)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TrySendMessage_result _ = P.error "not a struct"
read_TrySendMessage_result :: T.Protocol p => p -> P.IO TrySendMessage_result
read_TrySendMessage_result iprot = to_TrySendMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_TrySendMessage_result)
decode_TrySendMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> TrySendMessage_result
decode_TrySendMessage_result iprot bs = to_TrySendMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TrySendMessage_result) bs
typemap_TrySendMessage_result :: T.TypeMap
typemap_TrySendMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_TrySendMessage_result :: TrySendMessage_result
default_TrySendMessage_result = TrySendMessage_result{
  trySendMessage_result_success = default_Message,
  trySendMessage_result_e = P.Nothing}
data GetNextMessagesV2_args = GetNextMessagesV2_args  { getNextMessagesV2_args_messageBoxId :: LT.Text
  , getNextMessagesV2_args_startMessageId :: MessageBoxV2MessageId
  , getNextMessagesV2_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessagesV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessagesV2_args_messageBoxId record   `H.hashWithSalt` getNextMessagesV2_args_startMessageId record   `H.hashWithSalt` getNextMessagesV2_args_messagesCount record  
instance QC.Arbitrary GetNextMessagesV2_args where 
  arbitrary = M.liftM GetNextMessagesV2_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNextMessagesV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessagesV2_args{getNextMessagesV2_args_messageBoxId = getNextMessagesV2_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetNextMessagesV2_args{getNextMessagesV2_args_messageBoxId = getNextMessagesV2_args_messageBoxId obj}
    , if obj == default_GetNextMessagesV2_args{getNextMessagesV2_args_startMessageId = getNextMessagesV2_args_startMessageId obj} then P.Nothing else P.Just $ default_GetNextMessagesV2_args{getNextMessagesV2_args_startMessageId = getNextMessagesV2_args_startMessageId obj}
    , if obj == default_GetNextMessagesV2_args{getNextMessagesV2_args_messagesCount = getNextMessagesV2_args_messagesCount obj} then P.Nothing else P.Just $ default_GetNextMessagesV2_args{getNextMessagesV2_args_messagesCount = getNextMessagesV2_args_messagesCount obj}
    ]
from_GetNextMessagesV2_args :: GetNextMessagesV2_args -> T.ThriftVal
from_GetNextMessagesV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9162 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v9162))) $ getNextMessagesV2_args_messageBoxId record
  , (\_v9162 -> P.Just (3, ("startMessageId",from_MessageBoxV2MessageId _v9162))) $ getNextMessagesV2_args_startMessageId record
  , (\_v9162 -> P.Just (4, ("messagesCount",T.TI32 _v9162))) $ getNextMessagesV2_args_messagesCount record
  ]
write_GetNextMessagesV2_args :: T.Protocol p => p -> GetNextMessagesV2_args -> P.IO ()
write_GetNextMessagesV2_args oprot record = T.writeVal oprot $ from_GetNextMessagesV2_args record
encode_GetNextMessagesV2_args :: T.StatelessProtocol p => p -> GetNextMessagesV2_args -> LBS.ByteString
encode_GetNextMessagesV2_args oprot record = T.serializeVal oprot $ from_GetNextMessagesV2_args record
to_GetNextMessagesV2_args :: T.ThriftVal -> GetNextMessagesV2_args
to_GetNextMessagesV2_args (T.TStruct fields) = GetNextMessagesV2_args{
  getNextMessagesV2_args_messageBoxId = P.maybe (getNextMessagesV2_args_messageBoxId default_GetNextMessagesV2_args) (\(_,_val9164) -> (case _val9164 of {T.TString _val9165 -> E.decodeUtf8 _val9165; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNextMessagesV2_args_startMessageId = P.maybe (getNextMessagesV2_args_startMessageId default_GetNextMessagesV2_args) (\(_,_val9164) -> (case _val9164 of {T.TStruct _val9166 -> (to_MessageBoxV2MessageId (T.TStruct _val9166)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNextMessagesV2_args_messagesCount = P.maybe (getNextMessagesV2_args_messagesCount default_GetNextMessagesV2_args) (\(_,_val9164) -> (case _val9164 of {T.TI32 _val9167 -> _val9167; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetNextMessagesV2_args _ = P.error "not a struct"
read_GetNextMessagesV2_args :: T.Protocol p => p -> P.IO GetNextMessagesV2_args
read_GetNextMessagesV2_args iprot = to_GetNextMessagesV2_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessagesV2_args)
decode_GetNextMessagesV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessagesV2_args
decode_GetNextMessagesV2_args iprot bs = to_GetNextMessagesV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessagesV2_args) bs
typemap_GetNextMessagesV2_args :: T.TypeMap
typemap_GetNextMessagesV2_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("startMessageId",(T.T_STRUCT typemap_MessageBoxV2MessageId))),(4,("messagesCount",T.T_I32))]
default_GetNextMessagesV2_args :: GetNextMessagesV2_args
default_GetNextMessagesV2_args = GetNextMessagesV2_args{
  getNextMessagesV2_args_messageBoxId = "",
  getNextMessagesV2_args_startMessageId = default_MessageBoxV2MessageId,
  getNextMessagesV2_args_messagesCount = 0}
data GetNextMessagesV2_result = GetNextMessagesV2_result  { getNextMessagesV2_result_success :: (Vector.Vector Message)
  , getNextMessagesV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNextMessagesV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNextMessagesV2_result_success record   `H.hashWithSalt` getNextMessagesV2_result_e record  
instance QC.Arbitrary GetNextMessagesV2_result where 
  arbitrary = M.liftM GetNextMessagesV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNextMessagesV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNextMessagesV2_result{getNextMessagesV2_result_success = getNextMessagesV2_result_success obj} then P.Nothing else P.Just $ default_GetNextMessagesV2_result{getNextMessagesV2_result_success = getNextMessagesV2_result_success obj}
    , if obj == default_GetNextMessagesV2_result{getNextMessagesV2_result_e = getNextMessagesV2_result_e obj} then P.Nothing else P.Just $ default_GetNextMessagesV2_result{getNextMessagesV2_result_e = getNextMessagesV2_result_e obj}
    ]
from_GetNextMessagesV2_result :: GetNextMessagesV2_result -> T.ThriftVal
from_GetNextMessagesV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9170 -> (1, ("e",from_TalkException _v9170))) <$> getNextMessagesV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9170 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v9172 -> from_Message _v9172) $ Vector.toList _v9170))) $ getNextMessagesV2_result_success record
    , (\_v9170 -> (1, ("e",from_TalkException _v9170))) <$> getNextMessagesV2_result_e record
    ]
    )
write_GetNextMessagesV2_result :: T.Protocol p => p -> GetNextMessagesV2_result -> P.IO ()
write_GetNextMessagesV2_result oprot record = T.writeVal oprot $ from_GetNextMessagesV2_result record
encode_GetNextMessagesV2_result :: T.StatelessProtocol p => p -> GetNextMessagesV2_result -> LBS.ByteString
encode_GetNextMessagesV2_result oprot record = T.serializeVal oprot $ from_GetNextMessagesV2_result record
to_GetNextMessagesV2_result :: T.ThriftVal -> GetNextMessagesV2_result
to_GetNextMessagesV2_result (T.TStruct fields) = GetNextMessagesV2_result{
  getNextMessagesV2_result_success = P.maybe (getNextMessagesV2_result_success default_GetNextMessagesV2_result) (\(_,_val9174) -> (case _val9174 of {T.TList _ _val9175 -> (Vector.fromList $ P.map (\_v9176 -> (case _v9176 of {T.TStruct _val9177 -> (to_Message (T.TStruct _val9177)); _ -> P.error "wrong type"})) _val9175); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNextMessagesV2_result_e = P.maybe (P.Nothing) (\(_,_val9174) -> P.Just (case _val9174 of {T.TStruct _val9178 -> (to_TalkException (T.TStruct _val9178)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNextMessagesV2_result _ = P.error "not a struct"
read_GetNextMessagesV2_result :: T.Protocol p => p -> P.IO GetNextMessagesV2_result
read_GetNextMessagesV2_result iprot = to_GetNextMessagesV2_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNextMessagesV2_result)
decode_GetNextMessagesV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNextMessagesV2_result
decode_GetNextMessagesV2_result iprot bs = to_GetNextMessagesV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNextMessagesV2_result) bs
typemap_GetNextMessagesV2_result :: T.TypeMap
typemap_GetNextMessagesV2_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNextMessagesV2_result :: GetNextMessagesV2_result
default_GetNextMessagesV2_result = GetNextMessagesV2_result{
  getNextMessagesV2_result_success = Vector.empty,
  getNextMessagesV2_result_e = P.Nothing}
data GetMessageBoxCompactWrapUpV2_args = GetMessageBoxCompactWrapUpV2_args  { getMessageBoxCompactWrapUpV2_args_messageBoxId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpV2_args_messageBoxId record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpV2_args where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpV2_args (QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpV2_args{getMessageBoxCompactWrapUpV2_args_messageBoxId = getMessageBoxCompactWrapUpV2_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpV2_args{getMessageBoxCompactWrapUpV2_args_messageBoxId = getMessageBoxCompactWrapUpV2_args_messageBoxId obj}
    ]
from_GetMessageBoxCompactWrapUpV2_args :: GetMessageBoxCompactWrapUpV2_args -> T.ThriftVal
from_GetMessageBoxCompactWrapUpV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9181 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v9181))) $ getMessageBoxCompactWrapUpV2_args_messageBoxId record
  ]
write_GetMessageBoxCompactWrapUpV2_args :: T.Protocol p => p -> GetMessageBoxCompactWrapUpV2_args -> P.IO ()
write_GetMessageBoxCompactWrapUpV2_args oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpV2_args record
encode_GetMessageBoxCompactWrapUpV2_args :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpV2_args -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpV2_args oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpV2_args record
to_GetMessageBoxCompactWrapUpV2_args :: T.ThriftVal -> GetMessageBoxCompactWrapUpV2_args
to_GetMessageBoxCompactWrapUpV2_args (T.TStruct fields) = GetMessageBoxCompactWrapUpV2_args{
  getMessageBoxCompactWrapUpV2_args_messageBoxId = P.maybe (getMessageBoxCompactWrapUpV2_args_messageBoxId default_GetMessageBoxCompactWrapUpV2_args) (\(_,_val9183) -> (case _val9183 of {T.TString _val9184 -> E.decodeUtf8 _val9184; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetMessageBoxCompactWrapUpV2_args _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpV2_args :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpV2_args
read_GetMessageBoxCompactWrapUpV2_args iprot = to_GetMessageBoxCompactWrapUpV2_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpV2_args)
decode_GetMessageBoxCompactWrapUpV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpV2_args
decode_GetMessageBoxCompactWrapUpV2_args iprot bs = to_GetMessageBoxCompactWrapUpV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpV2_args) bs
typemap_GetMessageBoxCompactWrapUpV2_args :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpV2_args = Map.fromList [(2,("messageBoxId",T.T_STRING))]
default_GetMessageBoxCompactWrapUpV2_args :: GetMessageBoxCompactWrapUpV2_args
default_GetMessageBoxCompactWrapUpV2_args = GetMessageBoxCompactWrapUpV2_args{
  getMessageBoxCompactWrapUpV2_args_messageBoxId = ""}
data GetMessageBoxCompactWrapUpV2_result = GetMessageBoxCompactWrapUpV2_result  { getMessageBoxCompactWrapUpV2_result_success :: TMessageBoxWrapUp
  , getMessageBoxCompactWrapUpV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMessageBoxCompactWrapUpV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMessageBoxCompactWrapUpV2_result_success record   `H.hashWithSalt` getMessageBoxCompactWrapUpV2_result_e record  
instance QC.Arbitrary GetMessageBoxCompactWrapUpV2_result where 
  arbitrary = M.liftM GetMessageBoxCompactWrapUpV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMessageBoxCompactWrapUpV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_success = getMessageBoxCompactWrapUpV2_result_success obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_success = getMessageBoxCompactWrapUpV2_result_success obj}
    , if obj == default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_e = getMessageBoxCompactWrapUpV2_result_e obj} then P.Nothing else P.Just $ default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_e = getMessageBoxCompactWrapUpV2_result_e obj}
    ]
from_GetMessageBoxCompactWrapUpV2_result :: GetMessageBoxCompactWrapUpV2_result -> T.ThriftVal
from_GetMessageBoxCompactWrapUpV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9187 -> (1, ("e",from_TalkException _v9187))) <$> getMessageBoxCompactWrapUpV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9187 -> P.Just (0, ("success",from_TMessageBoxWrapUp _v9187))) $ getMessageBoxCompactWrapUpV2_result_success record
    , (\_v9187 -> (1, ("e",from_TalkException _v9187))) <$> getMessageBoxCompactWrapUpV2_result_e record
    ]
    )
write_GetMessageBoxCompactWrapUpV2_result :: T.Protocol p => p -> GetMessageBoxCompactWrapUpV2_result -> P.IO ()
write_GetMessageBoxCompactWrapUpV2_result oprot record = T.writeVal oprot $ from_GetMessageBoxCompactWrapUpV2_result record
encode_GetMessageBoxCompactWrapUpV2_result :: T.StatelessProtocol p => p -> GetMessageBoxCompactWrapUpV2_result -> LBS.ByteString
encode_GetMessageBoxCompactWrapUpV2_result oprot record = T.serializeVal oprot $ from_GetMessageBoxCompactWrapUpV2_result record
to_GetMessageBoxCompactWrapUpV2_result :: T.ThriftVal -> GetMessageBoxCompactWrapUpV2_result
to_GetMessageBoxCompactWrapUpV2_result (T.TStruct fields) = GetMessageBoxCompactWrapUpV2_result{
  getMessageBoxCompactWrapUpV2_result_success = P.maybe (getMessageBoxCompactWrapUpV2_result_success default_GetMessageBoxCompactWrapUpV2_result) (\(_,_val9189) -> (case _val9189 of {T.TStruct _val9190 -> (to_TMessageBoxWrapUp (T.TStruct _val9190)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMessageBoxCompactWrapUpV2_result_e = P.maybe (P.Nothing) (\(_,_val9189) -> P.Just (case _val9189 of {T.TStruct _val9191 -> (to_TalkException (T.TStruct _val9191)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMessageBoxCompactWrapUpV2_result _ = P.error "not a struct"
read_GetMessageBoxCompactWrapUpV2_result :: T.Protocol p => p -> P.IO GetMessageBoxCompactWrapUpV2_result
read_GetMessageBoxCompactWrapUpV2_result iprot = to_GetMessageBoxCompactWrapUpV2_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpV2_result)
decode_GetMessageBoxCompactWrapUpV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMessageBoxCompactWrapUpV2_result
decode_GetMessageBoxCompactWrapUpV2_result iprot bs = to_GetMessageBoxCompactWrapUpV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMessageBoxCompactWrapUpV2_result) bs
typemap_GetMessageBoxCompactWrapUpV2_result :: T.TypeMap
typemap_GetMessageBoxCompactWrapUpV2_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_TMessageBoxWrapUp))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMessageBoxCompactWrapUpV2_result :: GetMessageBoxCompactWrapUpV2_result
default_GetMessageBoxCompactWrapUpV2_result = GetMessageBoxCompactWrapUpV2_result{
  getMessageBoxCompactWrapUpV2_result_success = default_TMessageBoxWrapUp,
  getMessageBoxCompactWrapUpV2_result_e = P.Nothing}
data GetRecentMessagesV2_args = GetRecentMessagesV2_args  { getRecentMessagesV2_args_messageBoxId :: LT.Text
  , getRecentMessagesV2_args_messagesCount :: I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessagesV2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessagesV2_args_messageBoxId record   `H.hashWithSalt` getRecentMessagesV2_args_messagesCount record  
instance QC.Arbitrary GetRecentMessagesV2_args where 
  arbitrary = M.liftM GetRecentMessagesV2_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetRecentMessagesV2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessagesV2_args{getRecentMessagesV2_args_messageBoxId = getRecentMessagesV2_args_messageBoxId obj} then P.Nothing else P.Just $ default_GetRecentMessagesV2_args{getRecentMessagesV2_args_messageBoxId = getRecentMessagesV2_args_messageBoxId obj}
    , if obj == default_GetRecentMessagesV2_args{getRecentMessagesV2_args_messagesCount = getRecentMessagesV2_args_messagesCount obj} then P.Nothing else P.Just $ default_GetRecentMessagesV2_args{getRecentMessagesV2_args_messagesCount = getRecentMessagesV2_args_messagesCount obj}
    ]
from_GetRecentMessagesV2_args :: GetRecentMessagesV2_args -> T.ThriftVal
from_GetRecentMessagesV2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9194 -> P.Just (2, ("messageBoxId",T.TString $ E.encodeUtf8 _v9194))) $ getRecentMessagesV2_args_messageBoxId record
  , (\_v9194 -> P.Just (3, ("messagesCount",T.TI32 _v9194))) $ getRecentMessagesV2_args_messagesCount record
  ]
write_GetRecentMessagesV2_args :: T.Protocol p => p -> GetRecentMessagesV2_args -> P.IO ()
write_GetRecentMessagesV2_args oprot record = T.writeVal oprot $ from_GetRecentMessagesV2_args record
encode_GetRecentMessagesV2_args :: T.StatelessProtocol p => p -> GetRecentMessagesV2_args -> LBS.ByteString
encode_GetRecentMessagesV2_args oprot record = T.serializeVal oprot $ from_GetRecentMessagesV2_args record
to_GetRecentMessagesV2_args :: T.ThriftVal -> GetRecentMessagesV2_args
to_GetRecentMessagesV2_args (T.TStruct fields) = GetRecentMessagesV2_args{
  getRecentMessagesV2_args_messageBoxId = P.maybe (getRecentMessagesV2_args_messageBoxId default_GetRecentMessagesV2_args) (\(_,_val9196) -> (case _val9196 of {T.TString _val9197 -> E.decodeUtf8 _val9197; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getRecentMessagesV2_args_messagesCount = P.maybe (getRecentMessagesV2_args_messagesCount default_GetRecentMessagesV2_args) (\(_,_val9196) -> (case _val9196 of {T.TI32 _val9198 -> _val9198; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetRecentMessagesV2_args _ = P.error "not a struct"
read_GetRecentMessagesV2_args :: T.Protocol p => p -> P.IO GetRecentMessagesV2_args
read_GetRecentMessagesV2_args iprot = to_GetRecentMessagesV2_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessagesV2_args)
decode_GetRecentMessagesV2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessagesV2_args
decode_GetRecentMessagesV2_args iprot bs = to_GetRecentMessagesV2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessagesV2_args) bs
typemap_GetRecentMessagesV2_args :: T.TypeMap
typemap_GetRecentMessagesV2_args = Map.fromList [(2,("messageBoxId",T.T_STRING)),(3,("messagesCount",T.T_I32))]
default_GetRecentMessagesV2_args :: GetRecentMessagesV2_args
default_GetRecentMessagesV2_args = GetRecentMessagesV2_args{
  getRecentMessagesV2_args_messageBoxId = "",
  getRecentMessagesV2_args_messagesCount = 0}
data GetRecentMessagesV2_result = GetRecentMessagesV2_result  { getRecentMessagesV2_result_success :: (Vector.Vector Message)
  , getRecentMessagesV2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRecentMessagesV2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRecentMessagesV2_result_success record   `H.hashWithSalt` getRecentMessagesV2_result_e record  
instance QC.Arbitrary GetRecentMessagesV2_result where 
  arbitrary = M.liftM GetRecentMessagesV2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRecentMessagesV2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRecentMessagesV2_result{getRecentMessagesV2_result_success = getRecentMessagesV2_result_success obj} then P.Nothing else P.Just $ default_GetRecentMessagesV2_result{getRecentMessagesV2_result_success = getRecentMessagesV2_result_success obj}
    , if obj == default_GetRecentMessagesV2_result{getRecentMessagesV2_result_e = getRecentMessagesV2_result_e obj} then P.Nothing else P.Just $ default_GetRecentMessagesV2_result{getRecentMessagesV2_result_e = getRecentMessagesV2_result_e obj}
    ]
from_GetRecentMessagesV2_result :: GetRecentMessagesV2_result -> T.ThriftVal
from_GetRecentMessagesV2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9201 -> (1, ("e",from_TalkException _v9201))) <$> getRecentMessagesV2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9201 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Message) $ P.map (\_v9203 -> from_Message _v9203) $ Vector.toList _v9201))) $ getRecentMessagesV2_result_success record
    , (\_v9201 -> (1, ("e",from_TalkException _v9201))) <$> getRecentMessagesV2_result_e record
    ]
    )
write_GetRecentMessagesV2_result :: T.Protocol p => p -> GetRecentMessagesV2_result -> P.IO ()
write_GetRecentMessagesV2_result oprot record = T.writeVal oprot $ from_GetRecentMessagesV2_result record
encode_GetRecentMessagesV2_result :: T.StatelessProtocol p => p -> GetRecentMessagesV2_result -> LBS.ByteString
encode_GetRecentMessagesV2_result oprot record = T.serializeVal oprot $ from_GetRecentMessagesV2_result record
to_GetRecentMessagesV2_result :: T.ThriftVal -> GetRecentMessagesV2_result
to_GetRecentMessagesV2_result (T.TStruct fields) = GetRecentMessagesV2_result{
  getRecentMessagesV2_result_success = P.maybe (getRecentMessagesV2_result_success default_GetRecentMessagesV2_result) (\(_,_val9205) -> (case _val9205 of {T.TList _ _val9206 -> (Vector.fromList $ P.map (\_v9207 -> (case _v9207 of {T.TStruct _val9208 -> (to_Message (T.TStruct _val9208)); _ -> P.error "wrong type"})) _val9206); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRecentMessagesV2_result_e = P.maybe (P.Nothing) (\(_,_val9205) -> P.Just (case _val9205 of {T.TStruct _val9209 -> (to_TalkException (T.TStruct _val9209)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRecentMessagesV2_result _ = P.error "not a struct"
read_GetRecentMessagesV2_result :: T.Protocol p => p -> P.IO GetRecentMessagesV2_result
read_GetRecentMessagesV2_result iprot = to_GetRecentMessagesV2_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRecentMessagesV2_result)
decode_GetRecentMessagesV2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRecentMessagesV2_result
decode_GetRecentMessagesV2_result iprot bs = to_GetRecentMessagesV2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRecentMessagesV2_result) bs
typemap_GetRecentMessagesV2_result :: T.TypeMap
typemap_GetRecentMessagesV2_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Message)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRecentMessagesV2_result :: GetRecentMessagesV2_result
default_GetRecentMessagesV2_result = GetRecentMessagesV2_result{
  getRecentMessagesV2_result_success = Vector.empty,
  getRecentMessagesV2_result_e = P.Nothing}
data ValidateContactsOnBot_args = ValidateContactsOnBot_args  { validateContactsOnBot_args_contacts :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ValidateContactsOnBot_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` validateContactsOnBot_args_contacts record  
instance QC.Arbitrary ValidateContactsOnBot_args where 
  arbitrary = M.liftM ValidateContactsOnBot_args (QC.arbitrary)
  shrink obj | obj == default_ValidateContactsOnBot_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ValidateContactsOnBot_args{validateContactsOnBot_args_contacts = validateContactsOnBot_args_contacts obj} then P.Nothing else P.Just $ default_ValidateContactsOnBot_args{validateContactsOnBot_args_contacts = validateContactsOnBot_args_contacts obj}
    ]
from_ValidateContactsOnBot_args :: ValidateContactsOnBot_args -> T.ThriftVal
from_ValidateContactsOnBot_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9212 -> P.Just (2, ("contacts",T.TList T.T_STRING $ P.map (\_v9214 -> T.TString $ E.encodeUtf8 _v9214) $ Vector.toList _v9212))) $ validateContactsOnBot_args_contacts record
  ]
write_ValidateContactsOnBot_args :: T.Protocol p => p -> ValidateContactsOnBot_args -> P.IO ()
write_ValidateContactsOnBot_args oprot record = T.writeVal oprot $ from_ValidateContactsOnBot_args record
encode_ValidateContactsOnBot_args :: T.StatelessProtocol p => p -> ValidateContactsOnBot_args -> LBS.ByteString
encode_ValidateContactsOnBot_args oprot record = T.serializeVal oprot $ from_ValidateContactsOnBot_args record
to_ValidateContactsOnBot_args :: T.ThriftVal -> ValidateContactsOnBot_args
to_ValidateContactsOnBot_args (T.TStruct fields) = ValidateContactsOnBot_args{
  validateContactsOnBot_args_contacts = P.maybe (validateContactsOnBot_args_contacts default_ValidateContactsOnBot_args) (\(_,_val9216) -> (case _val9216 of {T.TList _ _val9217 -> (Vector.fromList $ P.map (\_v9218 -> (case _v9218 of {T.TString _val9219 -> E.decodeUtf8 _val9219; _ -> P.error "wrong type"})) _val9217); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ValidateContactsOnBot_args _ = P.error "not a struct"
read_ValidateContactsOnBot_args :: T.Protocol p => p -> P.IO ValidateContactsOnBot_args
read_ValidateContactsOnBot_args iprot = to_ValidateContactsOnBot_args <$> T.readVal iprot (T.T_STRUCT typemap_ValidateContactsOnBot_args)
decode_ValidateContactsOnBot_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ValidateContactsOnBot_args
decode_ValidateContactsOnBot_args iprot bs = to_ValidateContactsOnBot_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ValidateContactsOnBot_args) bs
typemap_ValidateContactsOnBot_args :: T.TypeMap
typemap_ValidateContactsOnBot_args = Map.fromList [(2,("contacts",(T.T_LIST T.T_STRING)))]
default_ValidateContactsOnBot_args :: ValidateContactsOnBot_args
default_ValidateContactsOnBot_args = ValidateContactsOnBot_args{
  validateContactsOnBot_args_contacts = Vector.empty}
data ValidateContactsOnBot_result = ValidateContactsOnBot_result  { validateContactsOnBot_result_success :: (Map.HashMap LT.Text LT.Text)
  , validateContactsOnBot_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ValidateContactsOnBot_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` validateContactsOnBot_result_success record   `H.hashWithSalt` validateContactsOnBot_result_e record  
instance QC.Arbitrary ValidateContactsOnBot_result where 
  arbitrary = M.liftM ValidateContactsOnBot_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ValidateContactsOnBot_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ValidateContactsOnBot_result{validateContactsOnBot_result_success = validateContactsOnBot_result_success obj} then P.Nothing else P.Just $ default_ValidateContactsOnBot_result{validateContactsOnBot_result_success = validateContactsOnBot_result_success obj}
    , if obj == default_ValidateContactsOnBot_result{validateContactsOnBot_result_e = validateContactsOnBot_result_e obj} then P.Nothing else P.Just $ default_ValidateContactsOnBot_result{validateContactsOnBot_result_e = validateContactsOnBot_result_e obj}
    ]
from_ValidateContactsOnBot_result :: ValidateContactsOnBot_result -> T.ThriftVal
from_ValidateContactsOnBot_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9222 -> (1, ("e",from_TalkException _v9222))) <$> validateContactsOnBot_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9222 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k9223,_v9224) -> (T.TString $ E.encodeUtf8 _k9223, T.TString $ E.encodeUtf8 _v9224)) $ Map.toList _v9222))) $ validateContactsOnBot_result_success record
    , (\_v9222 -> (1, ("e",from_TalkException _v9222))) <$> validateContactsOnBot_result_e record
    ]
    )
write_ValidateContactsOnBot_result :: T.Protocol p => p -> ValidateContactsOnBot_result -> P.IO ()
write_ValidateContactsOnBot_result oprot record = T.writeVal oprot $ from_ValidateContactsOnBot_result record
encode_ValidateContactsOnBot_result :: T.StatelessProtocol p => p -> ValidateContactsOnBot_result -> LBS.ByteString
encode_ValidateContactsOnBot_result oprot record = T.serializeVal oprot $ from_ValidateContactsOnBot_result record
to_ValidateContactsOnBot_result :: T.ThriftVal -> ValidateContactsOnBot_result
to_ValidateContactsOnBot_result (T.TStruct fields) = ValidateContactsOnBot_result{
  validateContactsOnBot_result_success = P.maybe (validateContactsOnBot_result_success default_ValidateContactsOnBot_result) (\(_,_val9226) -> (case _val9226 of {T.TMap _ _ _val9227 -> (Map.fromList $ P.map (\(_k9229,_v9228) -> ((case _k9229 of {T.TString _val9230 -> E.decodeUtf8 _val9230; _ -> P.error "wrong type"}),(case _v9228 of {T.TString _val9231 -> E.decodeUtf8 _val9231; _ -> P.error "wrong type"}))) _val9227); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  validateContactsOnBot_result_e = P.maybe (P.Nothing) (\(_,_val9226) -> P.Just (case _val9226 of {T.TStruct _val9232 -> (to_TalkException (T.TStruct _val9232)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ValidateContactsOnBot_result _ = P.error "not a struct"
read_ValidateContactsOnBot_result :: T.Protocol p => p -> P.IO ValidateContactsOnBot_result
read_ValidateContactsOnBot_result iprot = to_ValidateContactsOnBot_result <$> T.readVal iprot (T.T_STRUCT typemap_ValidateContactsOnBot_result)
decode_ValidateContactsOnBot_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ValidateContactsOnBot_result
decode_ValidateContactsOnBot_result iprot bs = to_ValidateContactsOnBot_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ValidateContactsOnBot_result) bs
typemap_ValidateContactsOnBot_result :: T.TypeMap
typemap_ValidateContactsOnBot_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ValidateContactsOnBot_result :: ValidateContactsOnBot_result
default_ValidateContactsOnBot_result = ValidateContactsOnBot_result{
  validateContactsOnBot_result_success = Map.empty,
  validateContactsOnBot_result_e = P.Nothing}
data TryFriendRequest_args = TryFriendRequest_args  { tryFriendRequest_args_midOrEMid :: LT.Text
  , tryFriendRequest_args_method :: FriendRequestMethod
  , tryFriendRequest_args_friendRequestParams :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TryFriendRequest_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` tryFriendRequest_args_midOrEMid record   `H.hashWithSalt` tryFriendRequest_args_method record   `H.hashWithSalt` tryFriendRequest_args_friendRequestParams record  
instance QC.Arbitrary TryFriendRequest_args where 
  arbitrary = M.liftM TryFriendRequest_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_TryFriendRequest_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TryFriendRequest_args{tryFriendRequest_args_midOrEMid = tryFriendRequest_args_midOrEMid obj} then P.Nothing else P.Just $ default_TryFriendRequest_args{tryFriendRequest_args_midOrEMid = tryFriendRequest_args_midOrEMid obj}
    , if obj == default_TryFriendRequest_args{tryFriendRequest_args_method = tryFriendRequest_args_method obj} then P.Nothing else P.Just $ default_TryFriendRequest_args{tryFriendRequest_args_method = tryFriendRequest_args_method obj}
    , if obj == default_TryFriendRequest_args{tryFriendRequest_args_friendRequestParams = tryFriendRequest_args_friendRequestParams obj} then P.Nothing else P.Just $ default_TryFriendRequest_args{tryFriendRequest_args_friendRequestParams = tryFriendRequest_args_friendRequestParams obj}
    ]
from_TryFriendRequest_args :: TryFriendRequest_args -> T.ThriftVal
from_TryFriendRequest_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9235 -> P.Just (1, ("midOrEMid",T.TString $ E.encodeUtf8 _v9235))) $ tryFriendRequest_args_midOrEMid record
  , (\_v9235 -> P.Just (2, ("method",T.TI32 $ P.fromIntegral $ P.fromEnum _v9235))) $ tryFriendRequest_args_method record
  , (\_v9235 -> P.Just (3, ("friendRequestParams",T.TString $ E.encodeUtf8 _v9235))) $ tryFriendRequest_args_friendRequestParams record
  ]
write_TryFriendRequest_args :: T.Protocol p => p -> TryFriendRequest_args -> P.IO ()
write_TryFriendRequest_args oprot record = T.writeVal oprot $ from_TryFriendRequest_args record
encode_TryFriendRequest_args :: T.StatelessProtocol p => p -> TryFriendRequest_args -> LBS.ByteString
encode_TryFriendRequest_args oprot record = T.serializeVal oprot $ from_TryFriendRequest_args record
to_TryFriendRequest_args :: T.ThriftVal -> TryFriendRequest_args
to_TryFriendRequest_args (T.TStruct fields) = TryFriendRequest_args{
  tryFriendRequest_args_midOrEMid = P.maybe (tryFriendRequest_args_midOrEMid default_TryFriendRequest_args) (\(_,_val9237) -> (case _val9237 of {T.TString _val9238 -> E.decodeUtf8 _val9238; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tryFriendRequest_args_method = P.maybe (tryFriendRequest_args_method default_TryFriendRequest_args) (\(_,_val9237) -> (case _val9237 of {T.TI32 _val9239 -> P.toEnum $ P.fromIntegral _val9239; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tryFriendRequest_args_friendRequestParams = P.maybe (tryFriendRequest_args_friendRequestParams default_TryFriendRequest_args) (\(_,_val9237) -> (case _val9237 of {T.TString _val9240 -> E.decodeUtf8 _val9240; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_TryFriendRequest_args _ = P.error "not a struct"
read_TryFriendRequest_args :: T.Protocol p => p -> P.IO TryFriendRequest_args
read_TryFriendRequest_args iprot = to_TryFriendRequest_args <$> T.readVal iprot (T.T_STRUCT typemap_TryFriendRequest_args)
decode_TryFriendRequest_args :: T.StatelessProtocol p => p -> LBS.ByteString -> TryFriendRequest_args
decode_TryFriendRequest_args iprot bs = to_TryFriendRequest_args $ T.deserializeVal iprot (T.T_STRUCT typemap_TryFriendRequest_args) bs
typemap_TryFriendRequest_args :: T.TypeMap
typemap_TryFriendRequest_args = Map.fromList [(1,("midOrEMid",T.T_STRING)),(2,("method",T.T_I32)),(3,("friendRequestParams",T.T_STRING))]
default_TryFriendRequest_args :: TryFriendRequest_args
default_TryFriendRequest_args = TryFriendRequest_args{
  tryFriendRequest_args_midOrEMid = "",
  tryFriendRequest_args_method = (P.toEnum 0),
  tryFriendRequest_args_friendRequestParams = ""}
data TryFriendRequest_result = TryFriendRequest_result  { tryFriendRequest_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable TryFriendRequest_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` tryFriendRequest_result_e record  
instance QC.Arbitrary TryFriendRequest_result where 
  arbitrary = M.liftM TryFriendRequest_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_TryFriendRequest_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_TryFriendRequest_result{tryFriendRequest_result_e = tryFriendRequest_result_e obj} then P.Nothing else P.Just $ default_TryFriendRequest_result{tryFriendRequest_result_e = tryFriendRequest_result_e obj}
    ]
from_TryFriendRequest_result :: TryFriendRequest_result -> T.ThriftVal
from_TryFriendRequest_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9243 -> (1, ("e",from_TalkException _v9243))) <$> tryFriendRequest_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9243 -> (1, ("e",from_TalkException _v9243))) <$> tryFriendRequest_result_e record
    ]
    )
write_TryFriendRequest_result :: T.Protocol p => p -> TryFriendRequest_result -> P.IO ()
write_TryFriendRequest_result oprot record = T.writeVal oprot $ from_TryFriendRequest_result record
encode_TryFriendRequest_result :: T.StatelessProtocol p => p -> TryFriendRequest_result -> LBS.ByteString
encode_TryFriendRequest_result oprot record = T.serializeVal oprot $ from_TryFriendRequest_result record
to_TryFriendRequest_result :: T.ThriftVal -> TryFriendRequest_result
to_TryFriendRequest_result (T.TStruct fields) = TryFriendRequest_result{
  tryFriendRequest_result_e = P.maybe (P.Nothing) (\(_,_val9245) -> P.Just (case _val9245 of {T.TStruct _val9246 -> (to_TalkException (T.TStruct _val9246)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_TryFriendRequest_result _ = P.error "not a struct"
read_TryFriendRequest_result :: T.Protocol p => p -> P.IO TryFriendRequest_result
read_TryFriendRequest_result iprot = to_TryFriendRequest_result <$> T.readVal iprot (T.T_STRUCT typemap_TryFriendRequest_result)
decode_TryFriendRequest_result :: T.StatelessProtocol p => p -> LBS.ByteString -> TryFriendRequest_result
decode_TryFriendRequest_result iprot bs = to_TryFriendRequest_result $ T.deserializeVal iprot (T.T_STRUCT typemap_TryFriendRequest_result) bs
typemap_TryFriendRequest_result :: T.TypeMap
typemap_TryFriendRequest_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_TryFriendRequest_result :: TryFriendRequest_result
default_TryFriendRequest_result = TryFriendRequest_result{
  tryFriendRequest_result_e = P.Nothing}
data UnblockContact_args = UnblockContact_args  { unblockContact_args_reqSeq :: I.Int32
  , unblockContact_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockContact_args_reqSeq record   `H.hashWithSalt` unblockContact_args_id record  
instance QC.Arbitrary UnblockContact_args where 
  arbitrary = M.liftM UnblockContact_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnblockContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockContact_args{unblockContact_args_reqSeq = unblockContact_args_reqSeq obj} then P.Nothing else P.Just $ default_UnblockContact_args{unblockContact_args_reqSeq = unblockContact_args_reqSeq obj}
    , if obj == default_UnblockContact_args{unblockContact_args_id = unblockContact_args_id obj} then P.Nothing else P.Just $ default_UnblockContact_args{unblockContact_args_id = unblockContact_args_id obj}
    ]
from_UnblockContact_args :: UnblockContact_args -> T.ThriftVal
from_UnblockContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9249 -> P.Just (1, ("reqSeq",T.TI32 _v9249))) $ unblockContact_args_reqSeq record
  , (\_v9249 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v9249))) $ unblockContact_args_id record
  ]
write_UnblockContact_args :: T.Protocol p => p -> UnblockContact_args -> P.IO ()
write_UnblockContact_args oprot record = T.writeVal oprot $ from_UnblockContact_args record
encode_UnblockContact_args :: T.StatelessProtocol p => p -> UnblockContact_args -> LBS.ByteString
encode_UnblockContact_args oprot record = T.serializeVal oprot $ from_UnblockContact_args record
to_UnblockContact_args :: T.ThriftVal -> UnblockContact_args
to_UnblockContact_args (T.TStruct fields) = UnblockContact_args{
  unblockContact_args_reqSeq = P.maybe (unblockContact_args_reqSeq default_UnblockContact_args) (\(_,_val9251) -> (case _val9251 of {T.TI32 _val9252 -> _val9252; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unblockContact_args_id = P.maybe (unblockContact_args_id default_UnblockContact_args) (\(_,_val9251) -> (case _val9251 of {T.TString _val9253 -> E.decodeUtf8 _val9253; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnblockContact_args _ = P.error "not a struct"
read_UnblockContact_args :: T.Protocol p => p -> P.IO UnblockContact_args
read_UnblockContact_args iprot = to_UnblockContact_args <$> T.readVal iprot (T.T_STRUCT typemap_UnblockContact_args)
decode_UnblockContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockContact_args
decode_UnblockContact_args iprot bs = to_UnblockContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockContact_args) bs
typemap_UnblockContact_args :: T.TypeMap
typemap_UnblockContact_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_UnblockContact_args :: UnblockContact_args
default_UnblockContact_args = UnblockContact_args{
  unblockContact_args_reqSeq = 0,
  unblockContact_args_id = ""}
data UnblockContact_result = UnblockContact_result  { unblockContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockContact_result_e record  
instance QC.Arbitrary UnblockContact_result where 
  arbitrary = M.liftM UnblockContact_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnblockContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockContact_result{unblockContact_result_e = unblockContact_result_e obj} then P.Nothing else P.Just $ default_UnblockContact_result{unblockContact_result_e = unblockContact_result_e obj}
    ]
from_UnblockContact_result :: UnblockContact_result -> T.ThriftVal
from_UnblockContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9256 -> (1, ("e",from_TalkException _v9256))) <$> unblockContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9256 -> (1, ("e",from_TalkException _v9256))) <$> unblockContact_result_e record
    ]
    )
write_UnblockContact_result :: T.Protocol p => p -> UnblockContact_result -> P.IO ()
write_UnblockContact_result oprot record = T.writeVal oprot $ from_UnblockContact_result record
encode_UnblockContact_result :: T.StatelessProtocol p => p -> UnblockContact_result -> LBS.ByteString
encode_UnblockContact_result oprot record = T.serializeVal oprot $ from_UnblockContact_result record
to_UnblockContact_result :: T.ThriftVal -> UnblockContact_result
to_UnblockContact_result (T.TStruct fields) = UnblockContact_result{
  unblockContact_result_e = P.maybe (P.Nothing) (\(_,_val9258) -> P.Just (case _val9258 of {T.TStruct _val9259 -> (to_TalkException (T.TStruct _val9259)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnblockContact_result _ = P.error "not a struct"
read_UnblockContact_result :: T.Protocol p => p -> P.IO UnblockContact_result
read_UnblockContact_result iprot = to_UnblockContact_result <$> T.readVal iprot (T.T_STRUCT typemap_UnblockContact_result)
decode_UnblockContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockContact_result
decode_UnblockContact_result iprot bs = to_UnblockContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockContact_result) bs
typemap_UnblockContact_result :: T.TypeMap
typemap_UnblockContact_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnblockContact_result :: UnblockContact_result
default_UnblockContact_result = UnblockContact_result{
  unblockContact_result_e = P.Nothing}
data UnblockRecommendation_args = UnblockRecommendation_args  { unblockRecommendation_args_reqSeq :: I.Int32
  , unblockRecommendation_args_id :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockRecommendation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockRecommendation_args_reqSeq record   `H.hashWithSalt` unblockRecommendation_args_id record  
instance QC.Arbitrary UnblockRecommendation_args where 
  arbitrary = M.liftM UnblockRecommendation_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnblockRecommendation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockRecommendation_args{unblockRecommendation_args_reqSeq = unblockRecommendation_args_reqSeq obj} then P.Nothing else P.Just $ default_UnblockRecommendation_args{unblockRecommendation_args_reqSeq = unblockRecommendation_args_reqSeq obj}
    , if obj == default_UnblockRecommendation_args{unblockRecommendation_args_id = unblockRecommendation_args_id obj} then P.Nothing else P.Just $ default_UnblockRecommendation_args{unblockRecommendation_args_id = unblockRecommendation_args_id obj}
    ]
from_UnblockRecommendation_args :: UnblockRecommendation_args -> T.ThriftVal
from_UnblockRecommendation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9262 -> P.Just (1, ("reqSeq",T.TI32 _v9262))) $ unblockRecommendation_args_reqSeq record
  , (\_v9262 -> P.Just (2, ("id",T.TString $ E.encodeUtf8 _v9262))) $ unblockRecommendation_args_id record
  ]
write_UnblockRecommendation_args :: T.Protocol p => p -> UnblockRecommendation_args -> P.IO ()
write_UnblockRecommendation_args oprot record = T.writeVal oprot $ from_UnblockRecommendation_args record
encode_UnblockRecommendation_args :: T.StatelessProtocol p => p -> UnblockRecommendation_args -> LBS.ByteString
encode_UnblockRecommendation_args oprot record = T.serializeVal oprot $ from_UnblockRecommendation_args record
to_UnblockRecommendation_args :: T.ThriftVal -> UnblockRecommendation_args
to_UnblockRecommendation_args (T.TStruct fields) = UnblockRecommendation_args{
  unblockRecommendation_args_reqSeq = P.maybe (unblockRecommendation_args_reqSeq default_UnblockRecommendation_args) (\(_,_val9264) -> (case _val9264 of {T.TI32 _val9265 -> _val9265; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unblockRecommendation_args_id = P.maybe (unblockRecommendation_args_id default_UnblockRecommendation_args) (\(_,_val9264) -> (case _val9264 of {T.TString _val9266 -> E.decodeUtf8 _val9266; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UnblockRecommendation_args _ = P.error "not a struct"
read_UnblockRecommendation_args :: T.Protocol p => p -> P.IO UnblockRecommendation_args
read_UnblockRecommendation_args iprot = to_UnblockRecommendation_args <$> T.readVal iprot (T.T_STRUCT typemap_UnblockRecommendation_args)
decode_UnblockRecommendation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockRecommendation_args
decode_UnblockRecommendation_args iprot bs = to_UnblockRecommendation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockRecommendation_args) bs
typemap_UnblockRecommendation_args :: T.TypeMap
typemap_UnblockRecommendation_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("id",T.T_STRING))]
default_UnblockRecommendation_args :: UnblockRecommendation_args
default_UnblockRecommendation_args = UnblockRecommendation_args{
  unblockRecommendation_args_reqSeq = 0,
  unblockRecommendation_args_id = ""}
data UnblockRecommendation_result = UnblockRecommendation_result  { unblockRecommendation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnblockRecommendation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unblockRecommendation_result_e record  
instance QC.Arbitrary UnblockRecommendation_result where 
  arbitrary = M.liftM UnblockRecommendation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnblockRecommendation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnblockRecommendation_result{unblockRecommendation_result_e = unblockRecommendation_result_e obj} then P.Nothing else P.Just $ default_UnblockRecommendation_result{unblockRecommendation_result_e = unblockRecommendation_result_e obj}
    ]
from_UnblockRecommendation_result :: UnblockRecommendation_result -> T.ThriftVal
from_UnblockRecommendation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9269 -> (1, ("e",from_TalkException _v9269))) <$> unblockRecommendation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9269 -> (1, ("e",from_TalkException _v9269))) <$> unblockRecommendation_result_e record
    ]
    )
write_UnblockRecommendation_result :: T.Protocol p => p -> UnblockRecommendation_result -> P.IO ()
write_UnblockRecommendation_result oprot record = T.writeVal oprot $ from_UnblockRecommendation_result record
encode_UnblockRecommendation_result :: T.StatelessProtocol p => p -> UnblockRecommendation_result -> LBS.ByteString
encode_UnblockRecommendation_result oprot record = T.serializeVal oprot $ from_UnblockRecommendation_result record
to_UnblockRecommendation_result :: T.ThriftVal -> UnblockRecommendation_result
to_UnblockRecommendation_result (T.TStruct fields) = UnblockRecommendation_result{
  unblockRecommendation_result_e = P.maybe (P.Nothing) (\(_,_val9271) -> P.Just (case _val9271 of {T.TStruct _val9272 -> (to_TalkException (T.TStruct _val9272)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnblockRecommendation_result _ = P.error "not a struct"
read_UnblockRecommendation_result :: T.Protocol p => p -> P.IO UnblockRecommendation_result
read_UnblockRecommendation_result iprot = to_UnblockRecommendation_result <$> T.readVal iprot (T.T_STRUCT typemap_UnblockRecommendation_result)
decode_UnblockRecommendation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnblockRecommendation_result
decode_UnblockRecommendation_result iprot bs = to_UnblockRecommendation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnblockRecommendation_result) bs
typemap_UnblockRecommendation_result :: T.TypeMap
typemap_UnblockRecommendation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnblockRecommendation_result :: UnblockRecommendation_result
default_UnblockRecommendation_result = UnblockRecommendation_result{
  unblockRecommendation_result_e = P.Nothing}
data UnregisterUserAndDevice_args = UnregisterUserAndDevice_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterUserAndDevice_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary UnregisterUserAndDevice_args where 
  arbitrary = QC.elements [UnregisterUserAndDevice_args]
from_UnregisterUserAndDevice_args :: UnregisterUserAndDevice_args -> T.ThriftVal
from_UnregisterUserAndDevice_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_UnregisterUserAndDevice_args :: T.Protocol p => p -> UnregisterUserAndDevice_args -> P.IO ()
write_UnregisterUserAndDevice_args oprot record = T.writeVal oprot $ from_UnregisterUserAndDevice_args record
encode_UnregisterUserAndDevice_args :: T.StatelessProtocol p => p -> UnregisterUserAndDevice_args -> LBS.ByteString
encode_UnregisterUserAndDevice_args oprot record = T.serializeVal oprot $ from_UnregisterUserAndDevice_args record
to_UnregisterUserAndDevice_args :: T.ThriftVal -> UnregisterUserAndDevice_args
to_UnregisterUserAndDevice_args (T.TStruct fields) = UnregisterUserAndDevice_args{

  }
to_UnregisterUserAndDevice_args _ = P.error "not a struct"
read_UnregisterUserAndDevice_args :: T.Protocol p => p -> P.IO UnregisterUserAndDevice_args
read_UnregisterUserAndDevice_args iprot = to_UnregisterUserAndDevice_args <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_args)
decode_UnregisterUserAndDevice_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterUserAndDevice_args
decode_UnregisterUserAndDevice_args iprot bs = to_UnregisterUserAndDevice_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_args) bs
typemap_UnregisterUserAndDevice_args :: T.TypeMap
typemap_UnregisterUserAndDevice_args = Map.fromList []
default_UnregisterUserAndDevice_args :: UnregisterUserAndDevice_args
default_UnregisterUserAndDevice_args = UnregisterUserAndDevice_args{
}
data UnregisterUserAndDevice_result = UnregisterUserAndDevice_result  { unregisterUserAndDevice_result_success :: LT.Text
  , unregisterUserAndDevice_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnregisterUserAndDevice_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unregisterUserAndDevice_result_success record   `H.hashWithSalt` unregisterUserAndDevice_result_e record  
instance QC.Arbitrary UnregisterUserAndDevice_result where 
  arbitrary = M.liftM UnregisterUserAndDevice_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnregisterUserAndDevice_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = unregisterUserAndDevice_result_success obj} then P.Nothing else P.Just $ default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = unregisterUserAndDevice_result_success obj}
    , if obj == default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = unregisterUserAndDevice_result_e obj} then P.Nothing else P.Just $ default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = unregisterUserAndDevice_result_e obj}
    ]
from_UnregisterUserAndDevice_result :: UnregisterUserAndDevice_result -> T.ThriftVal
from_UnregisterUserAndDevice_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9280 -> (1, ("e",from_TalkException _v9280))) <$> unregisterUserAndDevice_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9280 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v9280))) $ unregisterUserAndDevice_result_success record
    , (\_v9280 -> (1, ("e",from_TalkException _v9280))) <$> unregisterUserAndDevice_result_e record
    ]
    )
write_UnregisterUserAndDevice_result :: T.Protocol p => p -> UnregisterUserAndDevice_result -> P.IO ()
write_UnregisterUserAndDevice_result oprot record = T.writeVal oprot $ from_UnregisterUserAndDevice_result record
encode_UnregisterUserAndDevice_result :: T.StatelessProtocol p => p -> UnregisterUserAndDevice_result -> LBS.ByteString
encode_UnregisterUserAndDevice_result oprot record = T.serializeVal oprot $ from_UnregisterUserAndDevice_result record
to_UnregisterUserAndDevice_result :: T.ThriftVal -> UnregisterUserAndDevice_result
to_UnregisterUserAndDevice_result (T.TStruct fields) = UnregisterUserAndDevice_result{
  unregisterUserAndDevice_result_success = P.maybe (unregisterUserAndDevice_result_success default_UnregisterUserAndDevice_result) (\(_,_val9282) -> (case _val9282 of {T.TString _val9283 -> E.decodeUtf8 _val9283; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  unregisterUserAndDevice_result_e = P.maybe (P.Nothing) (\(_,_val9282) -> P.Just (case _val9282 of {T.TStruct _val9284 -> (to_TalkException (T.TStruct _val9284)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UnregisterUserAndDevice_result _ = P.error "not a struct"
read_UnregisterUserAndDevice_result :: T.Protocol p => p -> P.IO UnregisterUserAndDevice_result
read_UnregisterUserAndDevice_result iprot = to_UnregisterUserAndDevice_result <$> T.readVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_result)
decode_UnregisterUserAndDevice_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnregisterUserAndDevice_result
decode_UnregisterUserAndDevice_result iprot bs = to_UnregisterUserAndDevice_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnregisterUserAndDevice_result) bs
typemap_UnregisterUserAndDevice_result :: T.TypeMap
typemap_UnregisterUserAndDevice_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UnregisterUserAndDevice_result :: UnregisterUserAndDevice_result
default_UnregisterUserAndDevice_result = UnregisterUserAndDevice_result{
  unregisterUserAndDevice_result_success = "",
  unregisterUserAndDevice_result_e = P.Nothing}
data UpdateApnsDeviceToken_args = UpdateApnsDeviceToken_args  { updateApnsDeviceToken_args_apnsDeviceToken :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateApnsDeviceToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateApnsDeviceToken_args_apnsDeviceToken record  
instance QC.Arbitrary UpdateApnsDeviceToken_args where 
  arbitrary = M.liftM UpdateApnsDeviceToken_args (QC.arbitrary)
  shrink obj | obj == default_UpdateApnsDeviceToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateApnsDeviceToken_args{updateApnsDeviceToken_args_apnsDeviceToken = updateApnsDeviceToken_args_apnsDeviceToken obj} then P.Nothing else P.Just $ default_UpdateApnsDeviceToken_args{updateApnsDeviceToken_args_apnsDeviceToken = updateApnsDeviceToken_args_apnsDeviceToken obj}
    ]
from_UpdateApnsDeviceToken_args :: UpdateApnsDeviceToken_args -> T.ThriftVal
from_UpdateApnsDeviceToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9287 -> P.Just (2, ("apnsDeviceToken",T.TBinary _v9287))) $ updateApnsDeviceToken_args_apnsDeviceToken record
  ]
write_UpdateApnsDeviceToken_args :: T.Protocol p => p -> UpdateApnsDeviceToken_args -> P.IO ()
write_UpdateApnsDeviceToken_args oprot record = T.writeVal oprot $ from_UpdateApnsDeviceToken_args record
encode_UpdateApnsDeviceToken_args :: T.StatelessProtocol p => p -> UpdateApnsDeviceToken_args -> LBS.ByteString
encode_UpdateApnsDeviceToken_args oprot record = T.serializeVal oprot $ from_UpdateApnsDeviceToken_args record
to_UpdateApnsDeviceToken_args :: T.ThriftVal -> UpdateApnsDeviceToken_args
to_UpdateApnsDeviceToken_args (T.TStruct fields) = UpdateApnsDeviceToken_args{
  updateApnsDeviceToken_args_apnsDeviceToken = P.maybe (updateApnsDeviceToken_args_apnsDeviceToken default_UpdateApnsDeviceToken_args) (\(_,_val9289) -> (case _val9289 of {T.TBinary _val9290 -> _val9290; T.TString _val9290 -> _val9290; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateApnsDeviceToken_args _ = P.error "not a struct"
read_UpdateApnsDeviceToken_args :: T.Protocol p => p -> P.IO UpdateApnsDeviceToken_args
read_UpdateApnsDeviceToken_args iprot = to_UpdateApnsDeviceToken_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_args)
decode_UpdateApnsDeviceToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateApnsDeviceToken_args
decode_UpdateApnsDeviceToken_args iprot bs = to_UpdateApnsDeviceToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_args) bs
typemap_UpdateApnsDeviceToken_args :: T.TypeMap
typemap_UpdateApnsDeviceToken_args = Map.fromList [(2,("apnsDeviceToken",T.T_BINARY))]
default_UpdateApnsDeviceToken_args :: UpdateApnsDeviceToken_args
default_UpdateApnsDeviceToken_args = UpdateApnsDeviceToken_args{
  updateApnsDeviceToken_args_apnsDeviceToken = ""}
data UpdateApnsDeviceToken_result = UpdateApnsDeviceToken_result  { updateApnsDeviceToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateApnsDeviceToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateApnsDeviceToken_result_e record  
instance QC.Arbitrary UpdateApnsDeviceToken_result where 
  arbitrary = M.liftM UpdateApnsDeviceToken_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateApnsDeviceToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = updateApnsDeviceToken_result_e obj} then P.Nothing else P.Just $ default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = updateApnsDeviceToken_result_e obj}
    ]
from_UpdateApnsDeviceToken_result :: UpdateApnsDeviceToken_result -> T.ThriftVal
from_UpdateApnsDeviceToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9293 -> (1, ("e",from_TalkException _v9293))) <$> updateApnsDeviceToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9293 -> (1, ("e",from_TalkException _v9293))) <$> updateApnsDeviceToken_result_e record
    ]
    )
write_UpdateApnsDeviceToken_result :: T.Protocol p => p -> UpdateApnsDeviceToken_result -> P.IO ()
write_UpdateApnsDeviceToken_result oprot record = T.writeVal oprot $ from_UpdateApnsDeviceToken_result record
encode_UpdateApnsDeviceToken_result :: T.StatelessProtocol p => p -> UpdateApnsDeviceToken_result -> LBS.ByteString
encode_UpdateApnsDeviceToken_result oprot record = T.serializeVal oprot $ from_UpdateApnsDeviceToken_result record
to_UpdateApnsDeviceToken_result :: T.ThriftVal -> UpdateApnsDeviceToken_result
to_UpdateApnsDeviceToken_result (T.TStruct fields) = UpdateApnsDeviceToken_result{
  updateApnsDeviceToken_result_e = P.maybe (P.Nothing) (\(_,_val9295) -> P.Just (case _val9295 of {T.TStruct _val9296 -> (to_TalkException (T.TStruct _val9296)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateApnsDeviceToken_result _ = P.error "not a struct"
read_UpdateApnsDeviceToken_result :: T.Protocol p => p -> P.IO UpdateApnsDeviceToken_result
read_UpdateApnsDeviceToken_result iprot = to_UpdateApnsDeviceToken_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_result)
decode_UpdateApnsDeviceToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateApnsDeviceToken_result
decode_UpdateApnsDeviceToken_result iprot bs = to_UpdateApnsDeviceToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateApnsDeviceToken_result) bs
typemap_UpdateApnsDeviceToken_result :: T.TypeMap
typemap_UpdateApnsDeviceToken_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateApnsDeviceToken_result :: UpdateApnsDeviceToken_result
default_UpdateApnsDeviceToken_result = UpdateApnsDeviceToken_result{
  updateApnsDeviceToken_result_e = P.Nothing}
data UpdateBuddySetting_args = UpdateBuddySetting_args  { updateBuddySetting_args_key :: LT.Text
  , updateBuddySetting_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddySetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddySetting_args_key record   `H.hashWithSalt` updateBuddySetting_args_value record  
instance QC.Arbitrary UpdateBuddySetting_args where 
  arbitrary = M.liftM UpdateBuddySetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateBuddySetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddySetting_args{updateBuddySetting_args_key = updateBuddySetting_args_key obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_args{updateBuddySetting_args_key = updateBuddySetting_args_key obj}
    , if obj == default_UpdateBuddySetting_args{updateBuddySetting_args_value = updateBuddySetting_args_value obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_args{updateBuddySetting_args_value = updateBuddySetting_args_value obj}
    ]
from_UpdateBuddySetting_args :: UpdateBuddySetting_args -> T.ThriftVal
from_UpdateBuddySetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9299 -> P.Just (2, ("key",T.TString $ E.encodeUtf8 _v9299))) $ updateBuddySetting_args_key record
  , (\_v9299 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v9299))) $ updateBuddySetting_args_value record
  ]
write_UpdateBuddySetting_args :: T.Protocol p => p -> UpdateBuddySetting_args -> P.IO ()
write_UpdateBuddySetting_args oprot record = T.writeVal oprot $ from_UpdateBuddySetting_args record
encode_UpdateBuddySetting_args :: T.StatelessProtocol p => p -> UpdateBuddySetting_args -> LBS.ByteString
encode_UpdateBuddySetting_args oprot record = T.serializeVal oprot $ from_UpdateBuddySetting_args record
to_UpdateBuddySetting_args :: T.ThriftVal -> UpdateBuddySetting_args
to_UpdateBuddySetting_args (T.TStruct fields) = UpdateBuddySetting_args{
  updateBuddySetting_args_key = P.maybe (updateBuddySetting_args_key default_UpdateBuddySetting_args) (\(_,_val9301) -> (case _val9301 of {T.TString _val9302 -> E.decodeUtf8 _val9302; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBuddySetting_args_value = P.maybe (updateBuddySetting_args_value default_UpdateBuddySetting_args) (\(_,_val9301) -> (case _val9301 of {T.TString _val9303 -> E.decodeUtf8 _val9303; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateBuddySetting_args _ = P.error "not a struct"
read_UpdateBuddySetting_args :: T.Protocol p => p -> P.IO UpdateBuddySetting_args
read_UpdateBuddySetting_args iprot = to_UpdateBuddySetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_args)
decode_UpdateBuddySetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddySetting_args
decode_UpdateBuddySetting_args iprot bs = to_UpdateBuddySetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_args) bs
typemap_UpdateBuddySetting_args :: T.TypeMap
typemap_UpdateBuddySetting_args = Map.fromList [(2,("key",T.T_STRING)),(3,("value",T.T_STRING))]
default_UpdateBuddySetting_args :: UpdateBuddySetting_args
default_UpdateBuddySetting_args = UpdateBuddySetting_args{
  updateBuddySetting_args_key = "",
  updateBuddySetting_args_value = ""}
data UpdateBuddySetting_result = UpdateBuddySetting_result  { updateBuddySetting_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBuddySetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBuddySetting_result_e record  
instance QC.Arbitrary UpdateBuddySetting_result where 
  arbitrary = M.liftM UpdateBuddySetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateBuddySetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBuddySetting_result{updateBuddySetting_result_e = updateBuddySetting_result_e obj} then P.Nothing else P.Just $ default_UpdateBuddySetting_result{updateBuddySetting_result_e = updateBuddySetting_result_e obj}
    ]
from_UpdateBuddySetting_result :: UpdateBuddySetting_result -> T.ThriftVal
from_UpdateBuddySetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9306 -> (1, ("e",from_TalkException _v9306))) <$> updateBuddySetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9306 -> (1, ("e",from_TalkException _v9306))) <$> updateBuddySetting_result_e record
    ]
    )
write_UpdateBuddySetting_result :: T.Protocol p => p -> UpdateBuddySetting_result -> P.IO ()
write_UpdateBuddySetting_result oprot record = T.writeVal oprot $ from_UpdateBuddySetting_result record
encode_UpdateBuddySetting_result :: T.StatelessProtocol p => p -> UpdateBuddySetting_result -> LBS.ByteString
encode_UpdateBuddySetting_result oprot record = T.serializeVal oprot $ from_UpdateBuddySetting_result record
to_UpdateBuddySetting_result :: T.ThriftVal -> UpdateBuddySetting_result
to_UpdateBuddySetting_result (T.TStruct fields) = UpdateBuddySetting_result{
  updateBuddySetting_result_e = P.maybe (P.Nothing) (\(_,_val9308) -> P.Just (case _val9308 of {T.TStruct _val9309 -> (to_TalkException (T.TStruct _val9309)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateBuddySetting_result _ = P.error "not a struct"
read_UpdateBuddySetting_result :: T.Protocol p => p -> P.IO UpdateBuddySetting_result
read_UpdateBuddySetting_result iprot = to_UpdateBuddySetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_result)
decode_UpdateBuddySetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBuddySetting_result
decode_UpdateBuddySetting_result iprot bs = to_UpdateBuddySetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBuddySetting_result) bs
typemap_UpdateBuddySetting_result :: T.TypeMap
typemap_UpdateBuddySetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateBuddySetting_result :: UpdateBuddySetting_result
default_UpdateBuddySetting_result = UpdateBuddySetting_result{
  updateBuddySetting_result_e = P.Nothing}
data UpdateC2DMRegistrationId_args = UpdateC2DMRegistrationId_args  { updateC2DMRegistrationId_args_registrationId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateC2DMRegistrationId_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateC2DMRegistrationId_args_registrationId record  
instance QC.Arbitrary UpdateC2DMRegistrationId_args where 
  arbitrary = M.liftM UpdateC2DMRegistrationId_args (QC.arbitrary)
  shrink obj | obj == default_UpdateC2DMRegistrationId_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateC2DMRegistrationId_args{updateC2DMRegistrationId_args_registrationId = updateC2DMRegistrationId_args_registrationId obj} then P.Nothing else P.Just $ default_UpdateC2DMRegistrationId_args{updateC2DMRegistrationId_args_registrationId = updateC2DMRegistrationId_args_registrationId obj}
    ]
from_UpdateC2DMRegistrationId_args :: UpdateC2DMRegistrationId_args -> T.ThriftVal
from_UpdateC2DMRegistrationId_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9312 -> P.Just (2, ("registrationId",T.TString $ E.encodeUtf8 _v9312))) $ updateC2DMRegistrationId_args_registrationId record
  ]
write_UpdateC2DMRegistrationId_args :: T.Protocol p => p -> UpdateC2DMRegistrationId_args -> P.IO ()
write_UpdateC2DMRegistrationId_args oprot record = T.writeVal oprot $ from_UpdateC2DMRegistrationId_args record
encode_UpdateC2DMRegistrationId_args :: T.StatelessProtocol p => p -> UpdateC2DMRegistrationId_args -> LBS.ByteString
encode_UpdateC2DMRegistrationId_args oprot record = T.serializeVal oprot $ from_UpdateC2DMRegistrationId_args record
to_UpdateC2DMRegistrationId_args :: T.ThriftVal -> UpdateC2DMRegistrationId_args
to_UpdateC2DMRegistrationId_args (T.TStruct fields) = UpdateC2DMRegistrationId_args{
  updateC2DMRegistrationId_args_registrationId = P.maybe (updateC2DMRegistrationId_args_registrationId default_UpdateC2DMRegistrationId_args) (\(_,_val9314) -> (case _val9314 of {T.TString _val9315 -> E.decodeUtf8 _val9315; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateC2DMRegistrationId_args _ = P.error "not a struct"
read_UpdateC2DMRegistrationId_args :: T.Protocol p => p -> P.IO UpdateC2DMRegistrationId_args
read_UpdateC2DMRegistrationId_args iprot = to_UpdateC2DMRegistrationId_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_args)
decode_UpdateC2DMRegistrationId_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateC2DMRegistrationId_args
decode_UpdateC2DMRegistrationId_args iprot bs = to_UpdateC2DMRegistrationId_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_args) bs
typemap_UpdateC2DMRegistrationId_args :: T.TypeMap
typemap_UpdateC2DMRegistrationId_args = Map.fromList [(2,("registrationId",T.T_STRING))]
default_UpdateC2DMRegistrationId_args :: UpdateC2DMRegistrationId_args
default_UpdateC2DMRegistrationId_args = UpdateC2DMRegistrationId_args{
  updateC2DMRegistrationId_args_registrationId = ""}
data UpdateC2DMRegistrationId_result = UpdateC2DMRegistrationId_result  { updateC2DMRegistrationId_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateC2DMRegistrationId_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateC2DMRegistrationId_result_e record  
instance QC.Arbitrary UpdateC2DMRegistrationId_result where 
  arbitrary = M.liftM UpdateC2DMRegistrationId_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateC2DMRegistrationId_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = updateC2DMRegistrationId_result_e obj} then P.Nothing else P.Just $ default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = updateC2DMRegistrationId_result_e obj}
    ]
from_UpdateC2DMRegistrationId_result :: UpdateC2DMRegistrationId_result -> T.ThriftVal
from_UpdateC2DMRegistrationId_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9318 -> (1, ("e",from_TalkException _v9318))) <$> updateC2DMRegistrationId_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9318 -> (1, ("e",from_TalkException _v9318))) <$> updateC2DMRegistrationId_result_e record
    ]
    )
write_UpdateC2DMRegistrationId_result :: T.Protocol p => p -> UpdateC2DMRegistrationId_result -> P.IO ()
write_UpdateC2DMRegistrationId_result oprot record = T.writeVal oprot $ from_UpdateC2DMRegistrationId_result record
encode_UpdateC2DMRegistrationId_result :: T.StatelessProtocol p => p -> UpdateC2DMRegistrationId_result -> LBS.ByteString
encode_UpdateC2DMRegistrationId_result oprot record = T.serializeVal oprot $ from_UpdateC2DMRegistrationId_result record
to_UpdateC2DMRegistrationId_result :: T.ThriftVal -> UpdateC2DMRegistrationId_result
to_UpdateC2DMRegistrationId_result (T.TStruct fields) = UpdateC2DMRegistrationId_result{
  updateC2DMRegistrationId_result_e = P.maybe (P.Nothing) (\(_,_val9320) -> P.Just (case _val9320 of {T.TStruct _val9321 -> (to_TalkException (T.TStruct _val9321)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateC2DMRegistrationId_result _ = P.error "not a struct"
read_UpdateC2DMRegistrationId_result :: T.Protocol p => p -> P.IO UpdateC2DMRegistrationId_result
read_UpdateC2DMRegistrationId_result iprot = to_UpdateC2DMRegistrationId_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_result)
decode_UpdateC2DMRegistrationId_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateC2DMRegistrationId_result
decode_UpdateC2DMRegistrationId_result iprot bs = to_UpdateC2DMRegistrationId_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateC2DMRegistrationId_result) bs
typemap_UpdateC2DMRegistrationId_result :: T.TypeMap
typemap_UpdateC2DMRegistrationId_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateC2DMRegistrationId_result :: UpdateC2DMRegistrationId_result
default_UpdateC2DMRegistrationId_result = UpdateC2DMRegistrationId_result{
  updateC2DMRegistrationId_result_e = P.Nothing}
data UpdateContactSetting_args = UpdateContactSetting_args  { updateContactSetting_args_reqSeq :: I.Int32
  , updateContactSetting_args_mid :: LT.Text
  , updateContactSetting_args_flag :: ContactSetting
  , updateContactSetting_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateContactSetting_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateContactSetting_args_reqSeq record   `H.hashWithSalt` updateContactSetting_args_mid record   `H.hashWithSalt` updateContactSetting_args_flag record   `H.hashWithSalt` updateContactSetting_args_value record  
instance QC.Arbitrary UpdateContactSetting_args where 
  arbitrary = M.liftM UpdateContactSetting_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateContactSetting_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateContactSetting_args{updateContactSetting_args_reqSeq = updateContactSetting_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_reqSeq = updateContactSetting_args_reqSeq obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_mid = updateContactSetting_args_mid obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_mid = updateContactSetting_args_mid obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_flag = updateContactSetting_args_flag obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_flag = updateContactSetting_args_flag obj}
    , if obj == default_UpdateContactSetting_args{updateContactSetting_args_value = updateContactSetting_args_value obj} then P.Nothing else P.Just $ default_UpdateContactSetting_args{updateContactSetting_args_value = updateContactSetting_args_value obj}
    ]
from_UpdateContactSetting_args :: UpdateContactSetting_args -> T.ThriftVal
from_UpdateContactSetting_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9324 -> P.Just (1, ("reqSeq",T.TI32 _v9324))) $ updateContactSetting_args_reqSeq record
  , (\_v9324 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v9324))) $ updateContactSetting_args_mid record
  , (\_v9324 -> P.Just (3, ("flag",T.TI32 $ P.fromIntegral $ P.fromEnum _v9324))) $ updateContactSetting_args_flag record
  , (\_v9324 -> P.Just (4, ("value",T.TString $ E.encodeUtf8 _v9324))) $ updateContactSetting_args_value record
  ]
write_UpdateContactSetting_args :: T.Protocol p => p -> UpdateContactSetting_args -> P.IO ()
write_UpdateContactSetting_args oprot record = T.writeVal oprot $ from_UpdateContactSetting_args record
encode_UpdateContactSetting_args :: T.StatelessProtocol p => p -> UpdateContactSetting_args -> LBS.ByteString
encode_UpdateContactSetting_args oprot record = T.serializeVal oprot $ from_UpdateContactSetting_args record
to_UpdateContactSetting_args :: T.ThriftVal -> UpdateContactSetting_args
to_UpdateContactSetting_args (T.TStruct fields) = UpdateContactSetting_args{
  updateContactSetting_args_reqSeq = P.maybe (updateContactSetting_args_reqSeq default_UpdateContactSetting_args) (\(_,_val9326) -> (case _val9326 of {T.TI32 _val9327 -> _val9327; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateContactSetting_args_mid = P.maybe (updateContactSetting_args_mid default_UpdateContactSetting_args) (\(_,_val9326) -> (case _val9326 of {T.TString _val9328 -> E.decodeUtf8 _val9328; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateContactSetting_args_flag = P.maybe (updateContactSetting_args_flag default_UpdateContactSetting_args) (\(_,_val9326) -> (case _val9326 of {T.TI32 _val9329 -> P.toEnum $ P.fromIntegral _val9329; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateContactSetting_args_value = P.maybe (updateContactSetting_args_value default_UpdateContactSetting_args) (\(_,_val9326) -> (case _val9326 of {T.TString _val9330 -> E.decodeUtf8 _val9330; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_UpdateContactSetting_args _ = P.error "not a struct"
read_UpdateContactSetting_args :: T.Protocol p => p -> P.IO UpdateContactSetting_args
read_UpdateContactSetting_args iprot = to_UpdateContactSetting_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateContactSetting_args)
decode_UpdateContactSetting_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateContactSetting_args
decode_UpdateContactSetting_args iprot bs = to_UpdateContactSetting_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateContactSetting_args) bs
typemap_UpdateContactSetting_args :: T.TypeMap
typemap_UpdateContactSetting_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("mid",T.T_STRING)),(3,("flag",T.T_I32)),(4,("value",T.T_STRING))]
default_UpdateContactSetting_args :: UpdateContactSetting_args
default_UpdateContactSetting_args = UpdateContactSetting_args{
  updateContactSetting_args_reqSeq = 0,
  updateContactSetting_args_mid = "",
  updateContactSetting_args_flag = (P.toEnum 0),
  updateContactSetting_args_value = ""}
data UpdateContactSetting_result = UpdateContactSetting_result  { updateContactSetting_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateContactSetting_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateContactSetting_result_e record  
instance QC.Arbitrary UpdateContactSetting_result where 
  arbitrary = M.liftM UpdateContactSetting_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateContactSetting_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateContactSetting_result{updateContactSetting_result_e = updateContactSetting_result_e obj} then P.Nothing else P.Just $ default_UpdateContactSetting_result{updateContactSetting_result_e = updateContactSetting_result_e obj}
    ]
from_UpdateContactSetting_result :: UpdateContactSetting_result -> T.ThriftVal
from_UpdateContactSetting_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9333 -> (1, ("e",from_TalkException _v9333))) <$> updateContactSetting_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9333 -> (1, ("e",from_TalkException _v9333))) <$> updateContactSetting_result_e record
    ]
    )
write_UpdateContactSetting_result :: T.Protocol p => p -> UpdateContactSetting_result -> P.IO ()
write_UpdateContactSetting_result oprot record = T.writeVal oprot $ from_UpdateContactSetting_result record
encode_UpdateContactSetting_result :: T.StatelessProtocol p => p -> UpdateContactSetting_result -> LBS.ByteString
encode_UpdateContactSetting_result oprot record = T.serializeVal oprot $ from_UpdateContactSetting_result record
to_UpdateContactSetting_result :: T.ThriftVal -> UpdateContactSetting_result
to_UpdateContactSetting_result (T.TStruct fields) = UpdateContactSetting_result{
  updateContactSetting_result_e = P.maybe (P.Nothing) (\(_,_val9335) -> P.Just (case _val9335 of {T.TStruct _val9336 -> (to_TalkException (T.TStruct _val9336)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateContactSetting_result _ = P.error "not a struct"
read_UpdateContactSetting_result :: T.Protocol p => p -> P.IO UpdateContactSetting_result
read_UpdateContactSetting_result iprot = to_UpdateContactSetting_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateContactSetting_result)
decode_UpdateContactSetting_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateContactSetting_result
decode_UpdateContactSetting_result iprot bs = to_UpdateContactSetting_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateContactSetting_result) bs
typemap_UpdateContactSetting_result :: T.TypeMap
typemap_UpdateContactSetting_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateContactSetting_result :: UpdateContactSetting_result
default_UpdateContactSetting_result = UpdateContactSetting_result{
  updateContactSetting_result_e = P.Nothing}
data UpdateCustomModeSettings_args = UpdateCustomModeSettings_args  { updateCustomModeSettings_args_customMode :: CustomMode
  , updateCustomModeSettings_args_paramMap :: (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateCustomModeSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateCustomModeSettings_args_customMode record   `H.hashWithSalt` updateCustomModeSettings_args_paramMap record  
instance QC.Arbitrary UpdateCustomModeSettings_args where 
  arbitrary = M.liftM UpdateCustomModeSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateCustomModeSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_customMode = updateCustomModeSettings_args_customMode obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_customMode = updateCustomModeSettings_args_customMode obj}
    , if obj == default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_paramMap = updateCustomModeSettings_args_paramMap obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_args{updateCustomModeSettings_args_paramMap = updateCustomModeSettings_args_paramMap obj}
    ]
from_UpdateCustomModeSettings_args :: UpdateCustomModeSettings_args -> T.ThriftVal
from_UpdateCustomModeSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9339 -> P.Just (2, ("customMode",T.TI32 $ P.fromIntegral $ P.fromEnum _v9339))) $ updateCustomModeSettings_args_customMode record
  , (\_v9339 -> P.Just (3, ("paramMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k9340,_v9341) -> (T.TString $ E.encodeUtf8 _k9340, T.TString $ E.encodeUtf8 _v9341)) $ Map.toList _v9339))) $ updateCustomModeSettings_args_paramMap record
  ]
write_UpdateCustomModeSettings_args :: T.Protocol p => p -> UpdateCustomModeSettings_args -> P.IO ()
write_UpdateCustomModeSettings_args oprot record = T.writeVal oprot $ from_UpdateCustomModeSettings_args record
encode_UpdateCustomModeSettings_args :: T.StatelessProtocol p => p -> UpdateCustomModeSettings_args -> LBS.ByteString
encode_UpdateCustomModeSettings_args oprot record = T.serializeVal oprot $ from_UpdateCustomModeSettings_args record
to_UpdateCustomModeSettings_args :: T.ThriftVal -> UpdateCustomModeSettings_args
to_UpdateCustomModeSettings_args (T.TStruct fields) = UpdateCustomModeSettings_args{
  updateCustomModeSettings_args_customMode = P.maybe (updateCustomModeSettings_args_customMode default_UpdateCustomModeSettings_args) (\(_,_val9343) -> (case _val9343 of {T.TI32 _val9344 -> P.toEnum $ P.fromIntegral _val9344; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateCustomModeSettings_args_paramMap = P.maybe (updateCustomModeSettings_args_paramMap default_UpdateCustomModeSettings_args) (\(_,_val9343) -> (case _val9343 of {T.TMap _ _ _val9345 -> (Map.fromList $ P.map (\(_k9347,_v9346) -> ((case _k9347 of {T.TString _val9348 -> E.decodeUtf8 _val9348; _ -> P.error "wrong type"}),(case _v9346 of {T.TString _val9349 -> E.decodeUtf8 _val9349; _ -> P.error "wrong type"}))) _val9345); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateCustomModeSettings_args _ = P.error "not a struct"
read_UpdateCustomModeSettings_args :: T.Protocol p => p -> P.IO UpdateCustomModeSettings_args
read_UpdateCustomModeSettings_args iprot = to_UpdateCustomModeSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_args)
decode_UpdateCustomModeSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateCustomModeSettings_args
decode_UpdateCustomModeSettings_args iprot bs = to_UpdateCustomModeSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_args) bs
typemap_UpdateCustomModeSettings_args :: T.TypeMap
typemap_UpdateCustomModeSettings_args = Map.fromList [(2,("customMode",T.T_I32)),(3,("paramMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_UpdateCustomModeSettings_args :: UpdateCustomModeSettings_args
default_UpdateCustomModeSettings_args = UpdateCustomModeSettings_args{
  updateCustomModeSettings_args_customMode = (P.toEnum 0),
  updateCustomModeSettings_args_paramMap = Map.empty}
data UpdateCustomModeSettings_result = UpdateCustomModeSettings_result  { updateCustomModeSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateCustomModeSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateCustomModeSettings_result_e record  
instance QC.Arbitrary UpdateCustomModeSettings_result where 
  arbitrary = M.liftM UpdateCustomModeSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateCustomModeSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = updateCustomModeSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = updateCustomModeSettings_result_e obj}
    ]
from_UpdateCustomModeSettings_result :: UpdateCustomModeSettings_result -> T.ThriftVal
from_UpdateCustomModeSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9352 -> (1, ("e",from_TalkException _v9352))) <$> updateCustomModeSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9352 -> (1, ("e",from_TalkException _v9352))) <$> updateCustomModeSettings_result_e record
    ]
    )
write_UpdateCustomModeSettings_result :: T.Protocol p => p -> UpdateCustomModeSettings_result -> P.IO ()
write_UpdateCustomModeSettings_result oprot record = T.writeVal oprot $ from_UpdateCustomModeSettings_result record
encode_UpdateCustomModeSettings_result :: T.StatelessProtocol p => p -> UpdateCustomModeSettings_result -> LBS.ByteString
encode_UpdateCustomModeSettings_result oprot record = T.serializeVal oprot $ from_UpdateCustomModeSettings_result record
to_UpdateCustomModeSettings_result :: T.ThriftVal -> UpdateCustomModeSettings_result
to_UpdateCustomModeSettings_result (T.TStruct fields) = UpdateCustomModeSettings_result{
  updateCustomModeSettings_result_e = P.maybe (P.Nothing) (\(_,_val9354) -> P.Just (case _val9354 of {T.TStruct _val9355 -> (to_TalkException (T.TStruct _val9355)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateCustomModeSettings_result _ = P.error "not a struct"
read_UpdateCustomModeSettings_result :: T.Protocol p => p -> P.IO UpdateCustomModeSettings_result
read_UpdateCustomModeSettings_result iprot = to_UpdateCustomModeSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_result)
decode_UpdateCustomModeSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateCustomModeSettings_result
decode_UpdateCustomModeSettings_result iprot bs = to_UpdateCustomModeSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateCustomModeSettings_result) bs
typemap_UpdateCustomModeSettings_result :: T.TypeMap
typemap_UpdateCustomModeSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateCustomModeSettings_result :: UpdateCustomModeSettings_result
default_UpdateCustomModeSettings_result = UpdateCustomModeSettings_result{
  updateCustomModeSettings_result_e = P.Nothing}
data UpdateDeviceInfo_args = UpdateDeviceInfo_args  { updateDeviceInfo_args_deviceUid :: LT.Text
  , updateDeviceInfo_args_deviceInfo :: DeviceInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateDeviceInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateDeviceInfo_args_deviceUid record   `H.hashWithSalt` updateDeviceInfo_args_deviceInfo record  
instance QC.Arbitrary UpdateDeviceInfo_args where 
  arbitrary = M.liftM UpdateDeviceInfo_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateDeviceInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceUid = updateDeviceInfo_args_deviceUid obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceUid = updateDeviceInfo_args_deviceUid obj}
    , if obj == default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceInfo = updateDeviceInfo_args_deviceInfo obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_args{updateDeviceInfo_args_deviceInfo = updateDeviceInfo_args_deviceInfo obj}
    ]
from_UpdateDeviceInfo_args :: UpdateDeviceInfo_args -> T.ThriftVal
from_UpdateDeviceInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9358 -> P.Just (2, ("deviceUid",T.TString $ E.encodeUtf8 _v9358))) $ updateDeviceInfo_args_deviceUid record
  , (\_v9358 -> P.Just (3, ("deviceInfo",from_DeviceInfo _v9358))) $ updateDeviceInfo_args_deviceInfo record
  ]
write_UpdateDeviceInfo_args :: T.Protocol p => p -> UpdateDeviceInfo_args -> P.IO ()
write_UpdateDeviceInfo_args oprot record = T.writeVal oprot $ from_UpdateDeviceInfo_args record
encode_UpdateDeviceInfo_args :: T.StatelessProtocol p => p -> UpdateDeviceInfo_args -> LBS.ByteString
encode_UpdateDeviceInfo_args oprot record = T.serializeVal oprot $ from_UpdateDeviceInfo_args record
to_UpdateDeviceInfo_args :: T.ThriftVal -> UpdateDeviceInfo_args
to_UpdateDeviceInfo_args (T.TStruct fields) = UpdateDeviceInfo_args{
  updateDeviceInfo_args_deviceUid = P.maybe (updateDeviceInfo_args_deviceUid default_UpdateDeviceInfo_args) (\(_,_val9360) -> (case _val9360 of {T.TString _val9361 -> E.decodeUtf8 _val9361; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateDeviceInfo_args_deviceInfo = P.maybe (updateDeviceInfo_args_deviceInfo default_UpdateDeviceInfo_args) (\(_,_val9360) -> (case _val9360 of {T.TStruct _val9362 -> (to_DeviceInfo (T.TStruct _val9362)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateDeviceInfo_args _ = P.error "not a struct"
read_UpdateDeviceInfo_args :: T.Protocol p => p -> P.IO UpdateDeviceInfo_args
read_UpdateDeviceInfo_args iprot = to_UpdateDeviceInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_args)
decode_UpdateDeviceInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateDeviceInfo_args
decode_UpdateDeviceInfo_args iprot bs = to_UpdateDeviceInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_args) bs
typemap_UpdateDeviceInfo_args :: T.TypeMap
typemap_UpdateDeviceInfo_args = Map.fromList [(2,("deviceUid",T.T_STRING)),(3,("deviceInfo",(T.T_STRUCT typemap_DeviceInfo)))]
default_UpdateDeviceInfo_args :: UpdateDeviceInfo_args
default_UpdateDeviceInfo_args = UpdateDeviceInfo_args{
  updateDeviceInfo_args_deviceUid = "",
  updateDeviceInfo_args_deviceInfo = default_DeviceInfo}
data UpdateDeviceInfo_result = UpdateDeviceInfo_result  { updateDeviceInfo_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateDeviceInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateDeviceInfo_result_e record  
instance QC.Arbitrary UpdateDeviceInfo_result where 
  arbitrary = M.liftM UpdateDeviceInfo_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateDeviceInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = updateDeviceInfo_result_e obj} then P.Nothing else P.Just $ default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = updateDeviceInfo_result_e obj}
    ]
from_UpdateDeviceInfo_result :: UpdateDeviceInfo_result -> T.ThriftVal
from_UpdateDeviceInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9365 -> (1, ("e",from_TalkException _v9365))) <$> updateDeviceInfo_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9365 -> (1, ("e",from_TalkException _v9365))) <$> updateDeviceInfo_result_e record
    ]
    )
write_UpdateDeviceInfo_result :: T.Protocol p => p -> UpdateDeviceInfo_result -> P.IO ()
write_UpdateDeviceInfo_result oprot record = T.writeVal oprot $ from_UpdateDeviceInfo_result record
encode_UpdateDeviceInfo_result :: T.StatelessProtocol p => p -> UpdateDeviceInfo_result -> LBS.ByteString
encode_UpdateDeviceInfo_result oprot record = T.serializeVal oprot $ from_UpdateDeviceInfo_result record
to_UpdateDeviceInfo_result :: T.ThriftVal -> UpdateDeviceInfo_result
to_UpdateDeviceInfo_result (T.TStruct fields) = UpdateDeviceInfo_result{
  updateDeviceInfo_result_e = P.maybe (P.Nothing) (\(_,_val9367) -> P.Just (case _val9367 of {T.TStruct _val9368 -> (to_TalkException (T.TStruct _val9368)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateDeviceInfo_result _ = P.error "not a struct"
read_UpdateDeviceInfo_result :: T.Protocol p => p -> P.IO UpdateDeviceInfo_result
read_UpdateDeviceInfo_result iprot = to_UpdateDeviceInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_result)
decode_UpdateDeviceInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateDeviceInfo_result
decode_UpdateDeviceInfo_result iprot bs = to_UpdateDeviceInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateDeviceInfo_result) bs
typemap_UpdateDeviceInfo_result :: T.TypeMap
typemap_UpdateDeviceInfo_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateDeviceInfo_result :: UpdateDeviceInfo_result
default_UpdateDeviceInfo_result = UpdateDeviceInfo_result{
  updateDeviceInfo_result_e = P.Nothing}
data UpdateGroup_args = UpdateGroup_args  { updateGroup_args_reqSeq :: I.Int32
  , updateGroup_args_group :: Group
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroup_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroup_args_reqSeq record   `H.hashWithSalt` updateGroup_args_group record  
instance QC.Arbitrary UpdateGroup_args where 
  arbitrary = M.liftM UpdateGroup_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateGroup_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroup_args{updateGroup_args_reqSeq = updateGroup_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateGroup_args{updateGroup_args_reqSeq = updateGroup_args_reqSeq obj}
    , if obj == default_UpdateGroup_args{updateGroup_args_group = updateGroup_args_group obj} then P.Nothing else P.Just $ default_UpdateGroup_args{updateGroup_args_group = updateGroup_args_group obj}
    ]
from_UpdateGroup_args :: UpdateGroup_args -> T.ThriftVal
from_UpdateGroup_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9371 -> P.Just (1, ("reqSeq",T.TI32 _v9371))) $ updateGroup_args_reqSeq record
  , (\_v9371 -> P.Just (2, ("group",from_Group _v9371))) $ updateGroup_args_group record
  ]
write_UpdateGroup_args :: T.Protocol p => p -> UpdateGroup_args -> P.IO ()
write_UpdateGroup_args oprot record = T.writeVal oprot $ from_UpdateGroup_args record
encode_UpdateGroup_args :: T.StatelessProtocol p => p -> UpdateGroup_args -> LBS.ByteString
encode_UpdateGroup_args oprot record = T.serializeVal oprot $ from_UpdateGroup_args record
to_UpdateGroup_args :: T.ThriftVal -> UpdateGroup_args
to_UpdateGroup_args (T.TStruct fields) = UpdateGroup_args{
  updateGroup_args_reqSeq = P.maybe (updateGroup_args_reqSeq default_UpdateGroup_args) (\(_,_val9373) -> (case _val9373 of {T.TI32 _val9374 -> _val9374; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateGroup_args_group = P.maybe (updateGroup_args_group default_UpdateGroup_args) (\(_,_val9373) -> (case _val9373 of {T.TStruct _val9375 -> (to_Group (T.TStruct _val9375)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateGroup_args _ = P.error "not a struct"
read_UpdateGroup_args :: T.Protocol p => p -> P.IO UpdateGroup_args
read_UpdateGroup_args iprot = to_UpdateGroup_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroup_args)
decode_UpdateGroup_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroup_args
decode_UpdateGroup_args iprot bs = to_UpdateGroup_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroup_args) bs
typemap_UpdateGroup_args :: T.TypeMap
typemap_UpdateGroup_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("group",(T.T_STRUCT typemap_Group)))]
default_UpdateGroup_args :: UpdateGroup_args
default_UpdateGroup_args = UpdateGroup_args{
  updateGroup_args_reqSeq = 0,
  updateGroup_args_group = default_Group}
data UpdateGroup_result = UpdateGroup_result  { updateGroup_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateGroup_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateGroup_result_e record  
instance QC.Arbitrary UpdateGroup_result where 
  arbitrary = M.liftM UpdateGroup_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateGroup_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateGroup_result{updateGroup_result_e = updateGroup_result_e obj} then P.Nothing else P.Just $ default_UpdateGroup_result{updateGroup_result_e = updateGroup_result_e obj}
    ]
from_UpdateGroup_result :: UpdateGroup_result -> T.ThriftVal
from_UpdateGroup_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9378 -> (1, ("e",from_TalkException _v9378))) <$> updateGroup_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9378 -> (1, ("e",from_TalkException _v9378))) <$> updateGroup_result_e record
    ]
    )
write_UpdateGroup_result :: T.Protocol p => p -> UpdateGroup_result -> P.IO ()
write_UpdateGroup_result oprot record = T.writeVal oprot $ from_UpdateGroup_result record
encode_UpdateGroup_result :: T.StatelessProtocol p => p -> UpdateGroup_result -> LBS.ByteString
encode_UpdateGroup_result oprot record = T.serializeVal oprot $ from_UpdateGroup_result record
to_UpdateGroup_result :: T.ThriftVal -> UpdateGroup_result
to_UpdateGroup_result (T.TStruct fields) = UpdateGroup_result{
  updateGroup_result_e = P.maybe (P.Nothing) (\(_,_val9380) -> P.Just (case _val9380 of {T.TStruct _val9381 -> (to_TalkException (T.TStruct _val9381)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateGroup_result _ = P.error "not a struct"
read_UpdateGroup_result :: T.Protocol p => p -> P.IO UpdateGroup_result
read_UpdateGroup_result iprot = to_UpdateGroup_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateGroup_result)
decode_UpdateGroup_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateGroup_result
decode_UpdateGroup_result iprot bs = to_UpdateGroup_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateGroup_result) bs
typemap_UpdateGroup_result :: T.TypeMap
typemap_UpdateGroup_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateGroup_result :: UpdateGroup_result
default_UpdateGroup_result = UpdateGroup_result{
  updateGroup_result_e = P.Nothing}
data UpdateNotificationToken_args = UpdateNotificationToken_args  { updateNotificationToken_args_type :: NotificationType
  , updateNotificationToken_args_token :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationToken_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationToken_args_type record   `H.hashWithSalt` updateNotificationToken_args_token record  
instance QC.Arbitrary UpdateNotificationToken_args where 
  arbitrary = M.liftM UpdateNotificationToken_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationToken_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationToken_args{updateNotificationToken_args_type = updateNotificationToken_args_type obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_args{updateNotificationToken_args_type = updateNotificationToken_args_type obj}
    , if obj == default_UpdateNotificationToken_args{updateNotificationToken_args_token = updateNotificationToken_args_token obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_args{updateNotificationToken_args_token = updateNotificationToken_args_token obj}
    ]
from_UpdateNotificationToken_args :: UpdateNotificationToken_args -> T.ThriftVal
from_UpdateNotificationToken_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9384 -> P.Just (2, ("token",T.TString $ E.encodeUtf8 _v9384))) $ updateNotificationToken_args_token record
  , (\_v9384 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v9384))) $ updateNotificationToken_args_type record
  ]
write_UpdateNotificationToken_args :: T.Protocol p => p -> UpdateNotificationToken_args -> P.IO ()
write_UpdateNotificationToken_args oprot record = T.writeVal oprot $ from_UpdateNotificationToken_args record
encode_UpdateNotificationToken_args :: T.StatelessProtocol p => p -> UpdateNotificationToken_args -> LBS.ByteString
encode_UpdateNotificationToken_args oprot record = T.serializeVal oprot $ from_UpdateNotificationToken_args record
to_UpdateNotificationToken_args :: T.ThriftVal -> UpdateNotificationToken_args
to_UpdateNotificationToken_args (T.TStruct fields) = UpdateNotificationToken_args{
  updateNotificationToken_args_type = P.maybe (updateNotificationToken_args_type default_UpdateNotificationToken_args) (\(_,_val9386) -> (case _val9386 of {T.TI32 _val9387 -> P.toEnum $ P.fromIntegral _val9387; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateNotificationToken_args_token = P.maybe (updateNotificationToken_args_token default_UpdateNotificationToken_args) (\(_,_val9386) -> (case _val9386 of {T.TString _val9388 -> E.decodeUtf8 _val9388; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNotificationToken_args _ = P.error "not a struct"
read_UpdateNotificationToken_args :: T.Protocol p => p -> P.IO UpdateNotificationToken_args
read_UpdateNotificationToken_args iprot = to_UpdateNotificationToken_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_args)
decode_UpdateNotificationToken_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationToken_args
decode_UpdateNotificationToken_args iprot bs = to_UpdateNotificationToken_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_args) bs
typemap_UpdateNotificationToken_args :: T.TypeMap
typemap_UpdateNotificationToken_args = Map.fromList [(2,("token",T.T_STRING)),(3,("type",T.T_I32))]
default_UpdateNotificationToken_args :: UpdateNotificationToken_args
default_UpdateNotificationToken_args = UpdateNotificationToken_args{
  updateNotificationToken_args_token = "",
  updateNotificationToken_args_type = (P.toEnum 0)}
data UpdateNotificationToken_result = UpdateNotificationToken_result  { updateNotificationToken_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationToken_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationToken_result_e record  
instance QC.Arbitrary UpdateNotificationToken_result where 
  arbitrary = M.liftM UpdateNotificationToken_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationToken_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationToken_result{updateNotificationToken_result_e = updateNotificationToken_result_e obj} then P.Nothing else P.Just $ default_UpdateNotificationToken_result{updateNotificationToken_result_e = updateNotificationToken_result_e obj}
    ]
from_UpdateNotificationToken_result :: UpdateNotificationToken_result -> T.ThriftVal
from_UpdateNotificationToken_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9391 -> (1, ("e",from_TalkException _v9391))) <$> updateNotificationToken_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9391 -> (1, ("e",from_TalkException _v9391))) <$> updateNotificationToken_result_e record
    ]
    )
write_UpdateNotificationToken_result :: T.Protocol p => p -> UpdateNotificationToken_result -> P.IO ()
write_UpdateNotificationToken_result oprot record = T.writeVal oprot $ from_UpdateNotificationToken_result record
encode_UpdateNotificationToken_result :: T.StatelessProtocol p => p -> UpdateNotificationToken_result -> LBS.ByteString
encode_UpdateNotificationToken_result oprot record = T.serializeVal oprot $ from_UpdateNotificationToken_result record
to_UpdateNotificationToken_result :: T.ThriftVal -> UpdateNotificationToken_result
to_UpdateNotificationToken_result (T.TStruct fields) = UpdateNotificationToken_result{
  updateNotificationToken_result_e = P.maybe (P.Nothing) (\(_,_val9393) -> P.Just (case _val9393 of {T.TStruct _val9394 -> (to_TalkException (T.TStruct _val9394)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNotificationToken_result _ = P.error "not a struct"
read_UpdateNotificationToken_result :: T.Protocol p => p -> P.IO UpdateNotificationToken_result
read_UpdateNotificationToken_result iprot = to_UpdateNotificationToken_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_result)
decode_UpdateNotificationToken_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationToken_result
decode_UpdateNotificationToken_result iprot bs = to_UpdateNotificationToken_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationToken_result) bs
typemap_UpdateNotificationToken_result :: T.TypeMap
typemap_UpdateNotificationToken_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateNotificationToken_result :: UpdateNotificationToken_result
default_UpdateNotificationToken_result = UpdateNotificationToken_result{
  updateNotificationToken_result_e = P.Nothing}
data UpdateNotificationTokenWithBytes_args = UpdateNotificationTokenWithBytes_args  { updateNotificationTokenWithBytes_args_type :: NotificationType
  , updateNotificationTokenWithBytes_args_token :: LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationTokenWithBytes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationTokenWithBytes_args_type record   `H.hashWithSalt` updateNotificationTokenWithBytes_args_token record  
instance QC.Arbitrary UpdateNotificationTokenWithBytes_args where 
  arbitrary = M.liftM UpdateNotificationTokenWithBytes_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationTokenWithBytes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_type = updateNotificationTokenWithBytes_args_type obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_type = updateNotificationTokenWithBytes_args_type obj}
    , if obj == default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_token = updateNotificationTokenWithBytes_args_token obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_args{updateNotificationTokenWithBytes_args_token = updateNotificationTokenWithBytes_args_token obj}
    ]
from_UpdateNotificationTokenWithBytes_args :: UpdateNotificationTokenWithBytes_args -> T.ThriftVal
from_UpdateNotificationTokenWithBytes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9397 -> P.Just (2, ("token",T.TBinary _v9397))) $ updateNotificationTokenWithBytes_args_token record
  , (\_v9397 -> P.Just (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v9397))) $ updateNotificationTokenWithBytes_args_type record
  ]
write_UpdateNotificationTokenWithBytes_args :: T.Protocol p => p -> UpdateNotificationTokenWithBytes_args -> P.IO ()
write_UpdateNotificationTokenWithBytes_args oprot record = T.writeVal oprot $ from_UpdateNotificationTokenWithBytes_args record
encode_UpdateNotificationTokenWithBytes_args :: T.StatelessProtocol p => p -> UpdateNotificationTokenWithBytes_args -> LBS.ByteString
encode_UpdateNotificationTokenWithBytes_args oprot record = T.serializeVal oprot $ from_UpdateNotificationTokenWithBytes_args record
to_UpdateNotificationTokenWithBytes_args :: T.ThriftVal -> UpdateNotificationTokenWithBytes_args
to_UpdateNotificationTokenWithBytes_args (T.TStruct fields) = UpdateNotificationTokenWithBytes_args{
  updateNotificationTokenWithBytes_args_type = P.maybe (updateNotificationTokenWithBytes_args_type default_UpdateNotificationTokenWithBytes_args) (\(_,_val9399) -> (case _val9399 of {T.TI32 _val9400 -> P.toEnum $ P.fromIntegral _val9400; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  updateNotificationTokenWithBytes_args_token = P.maybe (updateNotificationTokenWithBytes_args_token default_UpdateNotificationTokenWithBytes_args) (\(_,_val9399) -> (case _val9399 of {T.TBinary _val9401 -> _val9401; T.TString _val9401 -> _val9401; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNotificationTokenWithBytes_args _ = P.error "not a struct"
read_UpdateNotificationTokenWithBytes_args :: T.Protocol p => p -> P.IO UpdateNotificationTokenWithBytes_args
read_UpdateNotificationTokenWithBytes_args iprot = to_UpdateNotificationTokenWithBytes_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_args)
decode_UpdateNotificationTokenWithBytes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationTokenWithBytes_args
decode_UpdateNotificationTokenWithBytes_args iprot bs = to_UpdateNotificationTokenWithBytes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_args) bs
typemap_UpdateNotificationTokenWithBytes_args :: T.TypeMap
typemap_UpdateNotificationTokenWithBytes_args = Map.fromList [(2,("token",T.T_BINARY)),(3,("type",T.T_I32))]
default_UpdateNotificationTokenWithBytes_args :: UpdateNotificationTokenWithBytes_args
default_UpdateNotificationTokenWithBytes_args = UpdateNotificationTokenWithBytes_args{
  updateNotificationTokenWithBytes_args_token = "",
  updateNotificationTokenWithBytes_args_type = (P.toEnum 0)}
data UpdateNotificationTokenWithBytes_result = UpdateNotificationTokenWithBytes_result  { updateNotificationTokenWithBytes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotificationTokenWithBytes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotificationTokenWithBytes_result_e record  
instance QC.Arbitrary UpdateNotificationTokenWithBytes_result where 
  arbitrary = M.liftM UpdateNotificationTokenWithBytes_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNotificationTokenWithBytes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = updateNotificationTokenWithBytes_result_e obj} then P.Nothing else P.Just $ default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = updateNotificationTokenWithBytes_result_e obj}
    ]
from_UpdateNotificationTokenWithBytes_result :: UpdateNotificationTokenWithBytes_result -> T.ThriftVal
from_UpdateNotificationTokenWithBytes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9404 -> (1, ("e",from_TalkException _v9404))) <$> updateNotificationTokenWithBytes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9404 -> (1, ("e",from_TalkException _v9404))) <$> updateNotificationTokenWithBytes_result_e record
    ]
    )
write_UpdateNotificationTokenWithBytes_result :: T.Protocol p => p -> UpdateNotificationTokenWithBytes_result -> P.IO ()
write_UpdateNotificationTokenWithBytes_result oprot record = T.writeVal oprot $ from_UpdateNotificationTokenWithBytes_result record
encode_UpdateNotificationTokenWithBytes_result :: T.StatelessProtocol p => p -> UpdateNotificationTokenWithBytes_result -> LBS.ByteString
encode_UpdateNotificationTokenWithBytes_result oprot record = T.serializeVal oprot $ from_UpdateNotificationTokenWithBytes_result record
to_UpdateNotificationTokenWithBytes_result :: T.ThriftVal -> UpdateNotificationTokenWithBytes_result
to_UpdateNotificationTokenWithBytes_result (T.TStruct fields) = UpdateNotificationTokenWithBytes_result{
  updateNotificationTokenWithBytes_result_e = P.maybe (P.Nothing) (\(_,_val9406) -> P.Just (case _val9406 of {T.TStruct _val9407 -> (to_TalkException (T.TStruct _val9407)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateNotificationTokenWithBytes_result _ = P.error "not a struct"
read_UpdateNotificationTokenWithBytes_result :: T.Protocol p => p -> P.IO UpdateNotificationTokenWithBytes_result
read_UpdateNotificationTokenWithBytes_result iprot = to_UpdateNotificationTokenWithBytes_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_result)
decode_UpdateNotificationTokenWithBytes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotificationTokenWithBytes_result
decode_UpdateNotificationTokenWithBytes_result iprot bs = to_UpdateNotificationTokenWithBytes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotificationTokenWithBytes_result) bs
typemap_UpdateNotificationTokenWithBytes_result :: T.TypeMap
typemap_UpdateNotificationTokenWithBytes_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateNotificationTokenWithBytes_result :: UpdateNotificationTokenWithBytes_result
default_UpdateNotificationTokenWithBytes_result = UpdateNotificationTokenWithBytes_result{
  updateNotificationTokenWithBytes_result_e = P.Nothing}
data UpdateProfile_args = UpdateProfile_args  { updateProfile_args_reqSeq :: I.Int32
  , updateProfile_args_profile :: Profile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfile_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfile_args_reqSeq record   `H.hashWithSalt` updateProfile_args_profile record  
instance QC.Arbitrary UpdateProfile_args where 
  arbitrary = M.liftM UpdateProfile_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfile_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfile_args{updateProfile_args_reqSeq = updateProfile_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateProfile_args{updateProfile_args_reqSeq = updateProfile_args_reqSeq obj}
    , if obj == default_UpdateProfile_args{updateProfile_args_profile = updateProfile_args_profile obj} then P.Nothing else P.Just $ default_UpdateProfile_args{updateProfile_args_profile = updateProfile_args_profile obj}
    ]
from_UpdateProfile_args :: UpdateProfile_args -> T.ThriftVal
from_UpdateProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9410 -> P.Just (1, ("reqSeq",T.TI32 _v9410))) $ updateProfile_args_reqSeq record
  , (\_v9410 -> P.Just (2, ("profile",from_Profile _v9410))) $ updateProfile_args_profile record
  ]
write_UpdateProfile_args :: T.Protocol p => p -> UpdateProfile_args -> P.IO ()
write_UpdateProfile_args oprot record = T.writeVal oprot $ from_UpdateProfile_args record
encode_UpdateProfile_args :: T.StatelessProtocol p => p -> UpdateProfile_args -> LBS.ByteString
encode_UpdateProfile_args oprot record = T.serializeVal oprot $ from_UpdateProfile_args record
to_UpdateProfile_args :: T.ThriftVal -> UpdateProfile_args
to_UpdateProfile_args (T.TStruct fields) = UpdateProfile_args{
  updateProfile_args_reqSeq = P.maybe (updateProfile_args_reqSeq default_UpdateProfile_args) (\(_,_val9412) -> (case _val9412 of {T.TI32 _val9413 -> _val9413; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateProfile_args_profile = P.maybe (updateProfile_args_profile default_UpdateProfile_args) (\(_,_val9412) -> (case _val9412 of {T.TStruct _val9414 -> (to_Profile (T.TStruct _val9414)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateProfile_args _ = P.error "not a struct"
read_UpdateProfile_args :: T.Protocol p => p -> P.IO UpdateProfile_args
read_UpdateProfile_args iprot = to_UpdateProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfile_args)
decode_UpdateProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfile_args
decode_UpdateProfile_args iprot bs = to_UpdateProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfile_args) bs
typemap_UpdateProfile_args :: T.TypeMap
typemap_UpdateProfile_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("profile",(T.T_STRUCT typemap_Profile)))]
default_UpdateProfile_args :: UpdateProfile_args
default_UpdateProfile_args = UpdateProfile_args{
  updateProfile_args_reqSeq = 0,
  updateProfile_args_profile = default_Profile}
data UpdateProfile_result = UpdateProfile_result  { updateProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfile_result_e record  
instance QC.Arbitrary UpdateProfile_result where 
  arbitrary = M.liftM UpdateProfile_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfile_result{updateProfile_result_e = updateProfile_result_e obj} then P.Nothing else P.Just $ default_UpdateProfile_result{updateProfile_result_e = updateProfile_result_e obj}
    ]
from_UpdateProfile_result :: UpdateProfile_result -> T.ThriftVal
from_UpdateProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9417 -> (1, ("e",from_TalkException _v9417))) <$> updateProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9417 -> (1, ("e",from_TalkException _v9417))) <$> updateProfile_result_e record
    ]
    )
write_UpdateProfile_result :: T.Protocol p => p -> UpdateProfile_result -> P.IO ()
write_UpdateProfile_result oprot record = T.writeVal oprot $ from_UpdateProfile_result record
encode_UpdateProfile_result :: T.StatelessProtocol p => p -> UpdateProfile_result -> LBS.ByteString
encode_UpdateProfile_result oprot record = T.serializeVal oprot $ from_UpdateProfile_result record
to_UpdateProfile_result :: T.ThriftVal -> UpdateProfile_result
to_UpdateProfile_result (T.TStruct fields) = UpdateProfile_result{
  updateProfile_result_e = P.maybe (P.Nothing) (\(_,_val9419) -> P.Just (case _val9419 of {T.TStruct _val9420 -> (to_TalkException (T.TStruct _val9420)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfile_result _ = P.error "not a struct"
read_UpdateProfile_result :: T.Protocol p => p -> P.IO UpdateProfile_result
read_UpdateProfile_result iprot = to_UpdateProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfile_result)
decode_UpdateProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfile_result
decode_UpdateProfile_result iprot bs = to_UpdateProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfile_result) bs
typemap_UpdateProfile_result :: T.TypeMap
typemap_UpdateProfile_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfile_result :: UpdateProfile_result
default_UpdateProfile_result = UpdateProfile_result{
  updateProfile_result_e = P.Nothing}
data UpdateProfileAttribute_args = UpdateProfileAttribute_args  { updateProfileAttribute_args_reqSeq :: I.Int32
  , updateProfileAttribute_args_attr :: ProfileAttribute
  , updateProfileAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttribute_args_reqSeq record   `H.hashWithSalt` updateProfileAttribute_args_attr record   `H.hashWithSalt` updateProfileAttribute_args_value record  
instance QC.Arbitrary UpdateProfileAttribute_args where 
  arbitrary = M.liftM UpdateProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_reqSeq = updateProfileAttribute_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_reqSeq = updateProfileAttribute_args_reqSeq obj}
    , if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_attr = updateProfileAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_attr = updateProfileAttribute_args_attr obj}
    , if obj == default_UpdateProfileAttribute_args{updateProfileAttribute_args_value = updateProfileAttribute_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_args{updateProfileAttribute_args_value = updateProfileAttribute_args_value obj}
    ]
from_UpdateProfileAttribute_args :: UpdateProfileAttribute_args -> T.ThriftVal
from_UpdateProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9423 -> P.Just (1, ("reqSeq",T.TI32 _v9423))) $ updateProfileAttribute_args_reqSeq record
  , (\_v9423 -> P.Just (2, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v9423))) $ updateProfileAttribute_args_attr record
  , (\_v9423 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v9423))) $ updateProfileAttribute_args_value record
  ]
write_UpdateProfileAttribute_args :: T.Protocol p => p -> UpdateProfileAttribute_args -> P.IO ()
write_UpdateProfileAttribute_args oprot record = T.writeVal oprot $ from_UpdateProfileAttribute_args record
encode_UpdateProfileAttribute_args :: T.StatelessProtocol p => p -> UpdateProfileAttribute_args -> LBS.ByteString
encode_UpdateProfileAttribute_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttribute_args record
to_UpdateProfileAttribute_args :: T.ThriftVal -> UpdateProfileAttribute_args
to_UpdateProfileAttribute_args (T.TStruct fields) = UpdateProfileAttribute_args{
  updateProfileAttribute_args_reqSeq = P.maybe (updateProfileAttribute_args_reqSeq default_UpdateProfileAttribute_args) (\(_,_val9425) -> (case _val9425 of {T.TI32 _val9426 -> _val9426; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateProfileAttribute_args_attr = P.maybe (updateProfileAttribute_args_attr default_UpdateProfileAttribute_args) (\(_,_val9425) -> (case _val9425 of {T.TI32 _val9427 -> P.toEnum $ P.fromIntegral _val9427; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttribute_args_value = P.maybe (updateProfileAttribute_args_value default_UpdateProfileAttribute_args) (\(_,_val9425) -> (case _val9425 of {T.TString _val9428 -> E.decodeUtf8 _val9428; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttribute_args _ = P.error "not a struct"
read_UpdateProfileAttribute_args :: T.Protocol p => p -> P.IO UpdateProfileAttribute_args
read_UpdateProfileAttribute_args iprot = to_UpdateProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_args)
decode_UpdateProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttribute_args
decode_UpdateProfileAttribute_args iprot bs = to_UpdateProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_args) bs
typemap_UpdateProfileAttribute_args :: T.TypeMap
typemap_UpdateProfileAttribute_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attr",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttribute_args :: UpdateProfileAttribute_args
default_UpdateProfileAttribute_args = UpdateProfileAttribute_args{
  updateProfileAttribute_args_reqSeq = 0,
  updateProfileAttribute_args_attr = (P.toEnum 0),
  updateProfileAttribute_args_value = ""}
data UpdateProfileAttribute_result = UpdateProfileAttribute_result  { updateProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttribute_result_e record  
instance QC.Arbitrary UpdateProfileAttribute_result where 
  arbitrary = M.liftM UpdateProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = updateProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = updateProfileAttribute_result_e obj}
    ]
from_UpdateProfileAttribute_result :: UpdateProfileAttribute_result -> T.ThriftVal
from_UpdateProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9431 -> (1, ("e",from_TalkException _v9431))) <$> updateProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9431 -> (1, ("e",from_TalkException _v9431))) <$> updateProfileAttribute_result_e record
    ]
    )
write_UpdateProfileAttribute_result :: T.Protocol p => p -> UpdateProfileAttribute_result -> P.IO ()
write_UpdateProfileAttribute_result oprot record = T.writeVal oprot $ from_UpdateProfileAttribute_result record
encode_UpdateProfileAttribute_result :: T.StatelessProtocol p => p -> UpdateProfileAttribute_result -> LBS.ByteString
encode_UpdateProfileAttribute_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttribute_result record
to_UpdateProfileAttribute_result :: T.ThriftVal -> UpdateProfileAttribute_result
to_UpdateProfileAttribute_result (T.TStruct fields) = UpdateProfileAttribute_result{
  updateProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val9433) -> P.Just (case _val9433 of {T.TStruct _val9434 -> (to_TalkException (T.TStruct _val9434)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttribute_result _ = P.error "not a struct"
read_UpdateProfileAttribute_result :: T.Protocol p => p -> P.IO UpdateProfileAttribute_result
read_UpdateProfileAttribute_result iprot = to_UpdateProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_result)
decode_UpdateProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttribute_result
decode_UpdateProfileAttribute_result iprot bs = to_UpdateProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttribute_result) bs
typemap_UpdateProfileAttribute_result :: T.TypeMap
typemap_UpdateProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttribute_result :: UpdateProfileAttribute_result
default_UpdateProfileAttribute_result = UpdateProfileAttribute_result{
  updateProfileAttribute_result_e = P.Nothing}
data UpdateRegion_args = UpdateRegion_args  { updateRegion_args_region :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateRegion_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateRegion_args_region record  
instance QC.Arbitrary UpdateRegion_args where 
  arbitrary = M.liftM UpdateRegion_args (QC.arbitrary)
  shrink obj | obj == default_UpdateRegion_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateRegion_args{updateRegion_args_region = updateRegion_args_region obj} then P.Nothing else P.Just $ default_UpdateRegion_args{updateRegion_args_region = updateRegion_args_region obj}
    ]
from_UpdateRegion_args :: UpdateRegion_args -> T.ThriftVal
from_UpdateRegion_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9437 -> P.Just (2, ("region",T.TString $ E.encodeUtf8 _v9437))) $ updateRegion_args_region record
  ]
write_UpdateRegion_args :: T.Protocol p => p -> UpdateRegion_args -> P.IO ()
write_UpdateRegion_args oprot record = T.writeVal oprot $ from_UpdateRegion_args record
encode_UpdateRegion_args :: T.StatelessProtocol p => p -> UpdateRegion_args -> LBS.ByteString
encode_UpdateRegion_args oprot record = T.serializeVal oprot $ from_UpdateRegion_args record
to_UpdateRegion_args :: T.ThriftVal -> UpdateRegion_args
to_UpdateRegion_args (T.TStruct fields) = UpdateRegion_args{
  updateRegion_args_region = P.maybe (updateRegion_args_region default_UpdateRegion_args) (\(_,_val9439) -> (case _val9439 of {T.TString _val9440 -> E.decodeUtf8 _val9440; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateRegion_args _ = P.error "not a struct"
read_UpdateRegion_args :: T.Protocol p => p -> P.IO UpdateRegion_args
read_UpdateRegion_args iprot = to_UpdateRegion_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateRegion_args)
decode_UpdateRegion_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateRegion_args
decode_UpdateRegion_args iprot bs = to_UpdateRegion_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateRegion_args) bs
typemap_UpdateRegion_args :: T.TypeMap
typemap_UpdateRegion_args = Map.fromList [(2,("region",T.T_STRING))]
default_UpdateRegion_args :: UpdateRegion_args
default_UpdateRegion_args = UpdateRegion_args{
  updateRegion_args_region = ""}
data UpdateRegion_result = UpdateRegion_result  { updateRegion_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateRegion_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateRegion_result_e record  
instance QC.Arbitrary UpdateRegion_result where 
  arbitrary = M.liftM UpdateRegion_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateRegion_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateRegion_result{updateRegion_result_e = updateRegion_result_e obj} then P.Nothing else P.Just $ default_UpdateRegion_result{updateRegion_result_e = updateRegion_result_e obj}
    ]
from_UpdateRegion_result :: UpdateRegion_result -> T.ThriftVal
from_UpdateRegion_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9443 -> (1, ("e",from_TalkException _v9443))) <$> updateRegion_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9443 -> (1, ("e",from_TalkException _v9443))) <$> updateRegion_result_e record
    ]
    )
write_UpdateRegion_result :: T.Protocol p => p -> UpdateRegion_result -> P.IO ()
write_UpdateRegion_result oprot record = T.writeVal oprot $ from_UpdateRegion_result record
encode_UpdateRegion_result :: T.StatelessProtocol p => p -> UpdateRegion_result -> LBS.ByteString
encode_UpdateRegion_result oprot record = T.serializeVal oprot $ from_UpdateRegion_result record
to_UpdateRegion_result :: T.ThriftVal -> UpdateRegion_result
to_UpdateRegion_result (T.TStruct fields) = UpdateRegion_result{
  updateRegion_result_e = P.maybe (P.Nothing) (\(_,_val9445) -> P.Just (case _val9445 of {T.TStruct _val9446 -> (to_TalkException (T.TStruct _val9446)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateRegion_result _ = P.error "not a struct"
read_UpdateRegion_result :: T.Protocol p => p -> P.IO UpdateRegion_result
read_UpdateRegion_result iprot = to_UpdateRegion_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateRegion_result)
decode_UpdateRegion_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateRegion_result
decode_UpdateRegion_result iprot bs = to_UpdateRegion_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateRegion_result) bs
typemap_UpdateRegion_result :: T.TypeMap
typemap_UpdateRegion_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateRegion_result :: UpdateRegion_result
default_UpdateRegion_result = UpdateRegion_result{
  updateRegion_result_e = P.Nothing}
data UpdateSettings_args = UpdateSettings_args  { updateSettings_args_reqSeq :: I.Int32
  , updateSettings_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings_args_reqSeq record   `H.hashWithSalt` updateSettings_args_settings record  
instance QC.Arbitrary UpdateSettings_args where 
  arbitrary = M.liftM UpdateSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings_args{updateSettings_args_reqSeq = updateSettings_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettings_args{updateSettings_args_reqSeq = updateSettings_args_reqSeq obj}
    , if obj == default_UpdateSettings_args{updateSettings_args_settings = updateSettings_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettings_args{updateSettings_args_settings = updateSettings_args_settings obj}
    ]
from_UpdateSettings_args :: UpdateSettings_args -> T.ThriftVal
from_UpdateSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9449 -> P.Just (1, ("reqSeq",T.TI32 _v9449))) $ updateSettings_args_reqSeq record
  , (\_v9449 -> P.Just (2, ("settings",from_Settings _v9449))) $ updateSettings_args_settings record
  ]
write_UpdateSettings_args :: T.Protocol p => p -> UpdateSettings_args -> P.IO ()
write_UpdateSettings_args oprot record = T.writeVal oprot $ from_UpdateSettings_args record
encode_UpdateSettings_args :: T.StatelessProtocol p => p -> UpdateSettings_args -> LBS.ByteString
encode_UpdateSettings_args oprot record = T.serializeVal oprot $ from_UpdateSettings_args record
to_UpdateSettings_args :: T.ThriftVal -> UpdateSettings_args
to_UpdateSettings_args (T.TStruct fields) = UpdateSettings_args{
  updateSettings_args_reqSeq = P.maybe (updateSettings_args_reqSeq default_UpdateSettings_args) (\(_,_val9451) -> (case _val9451 of {T.TI32 _val9452 -> _val9452; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettings_args_settings = P.maybe (updateSettings_args_settings default_UpdateSettings_args) (\(_,_val9451) -> (case _val9451 of {T.TStruct _val9453 -> (to_Settings (T.TStruct _val9453)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSettings_args _ = P.error "not a struct"
read_UpdateSettings_args :: T.Protocol p => p -> P.IO UpdateSettings_args
read_UpdateSettings_args iprot = to_UpdateSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings_args)
decode_UpdateSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings_args
decode_UpdateSettings_args iprot bs = to_UpdateSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings_args) bs
typemap_UpdateSettings_args :: T.TypeMap
typemap_UpdateSettings_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettings_args :: UpdateSettings_args
default_UpdateSettings_args = UpdateSettings_args{
  updateSettings_args_reqSeq = 0,
  updateSettings_args_settings = default_Settings}
data UpdateSettings_result = UpdateSettings_result  { updateSettings_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings_result_e record  
instance QC.Arbitrary UpdateSettings_result where 
  arbitrary = M.liftM UpdateSettings_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings_result{updateSettings_result_e = updateSettings_result_e obj} then P.Nothing else P.Just $ default_UpdateSettings_result{updateSettings_result_e = updateSettings_result_e obj}
    ]
from_UpdateSettings_result :: UpdateSettings_result -> T.ThriftVal
from_UpdateSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9456 -> (1, ("e",from_TalkException _v9456))) <$> updateSettings_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9456 -> (1, ("e",from_TalkException _v9456))) <$> updateSettings_result_e record
    ]
    )
write_UpdateSettings_result :: T.Protocol p => p -> UpdateSettings_result -> P.IO ()
write_UpdateSettings_result oprot record = T.writeVal oprot $ from_UpdateSettings_result record
encode_UpdateSettings_result :: T.StatelessProtocol p => p -> UpdateSettings_result -> LBS.ByteString
encode_UpdateSettings_result oprot record = T.serializeVal oprot $ from_UpdateSettings_result record
to_UpdateSettings_result :: T.ThriftVal -> UpdateSettings_result
to_UpdateSettings_result (T.TStruct fields) = UpdateSettings_result{
  updateSettings_result_e = P.maybe (P.Nothing) (\(_,_val9458) -> P.Just (case _val9458 of {T.TStruct _val9459 -> (to_TalkException (T.TStruct _val9459)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettings_result _ = P.error "not a struct"
read_UpdateSettings_result :: T.Protocol p => p -> P.IO UpdateSettings_result
read_UpdateSettings_result iprot = to_UpdateSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings_result)
decode_UpdateSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings_result
decode_UpdateSettings_result iprot bs = to_UpdateSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings_result) bs
typemap_UpdateSettings_result :: T.TypeMap
typemap_UpdateSettings_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettings_result :: UpdateSettings_result
default_UpdateSettings_result = UpdateSettings_result{
  updateSettings_result_e = P.Nothing}
data UpdateSettings2_args = UpdateSettings2_args  { updateSettings2_args_reqSeq :: I.Int32
  , updateSettings2_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings2_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings2_args_reqSeq record   `H.hashWithSalt` updateSettings2_args_settings record  
instance QC.Arbitrary UpdateSettings2_args where 
  arbitrary = M.liftM UpdateSettings2_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettings2_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings2_args{updateSettings2_args_reqSeq = updateSettings2_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettings2_args{updateSettings2_args_reqSeq = updateSettings2_args_reqSeq obj}
    , if obj == default_UpdateSettings2_args{updateSettings2_args_settings = updateSettings2_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettings2_args{updateSettings2_args_settings = updateSettings2_args_settings obj}
    ]
from_UpdateSettings2_args :: UpdateSettings2_args -> T.ThriftVal
from_UpdateSettings2_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9462 -> P.Just (1, ("reqSeq",T.TI32 _v9462))) $ updateSettings2_args_reqSeq record
  , (\_v9462 -> P.Just (2, ("settings",from_Settings _v9462))) $ updateSettings2_args_settings record
  ]
write_UpdateSettings2_args :: T.Protocol p => p -> UpdateSettings2_args -> P.IO ()
write_UpdateSettings2_args oprot record = T.writeVal oprot $ from_UpdateSettings2_args record
encode_UpdateSettings2_args :: T.StatelessProtocol p => p -> UpdateSettings2_args -> LBS.ByteString
encode_UpdateSettings2_args oprot record = T.serializeVal oprot $ from_UpdateSettings2_args record
to_UpdateSettings2_args :: T.ThriftVal -> UpdateSettings2_args
to_UpdateSettings2_args (T.TStruct fields) = UpdateSettings2_args{
  updateSettings2_args_reqSeq = P.maybe (updateSettings2_args_reqSeq default_UpdateSettings2_args) (\(_,_val9464) -> (case _val9464 of {T.TI32 _val9465 -> _val9465; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettings2_args_settings = P.maybe (updateSettings2_args_settings default_UpdateSettings2_args) (\(_,_val9464) -> (case _val9464 of {T.TStruct _val9466 -> (to_Settings (T.TStruct _val9466)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSettings2_args _ = P.error "not a struct"
read_UpdateSettings2_args :: T.Protocol p => p -> P.IO UpdateSettings2_args
read_UpdateSettings2_args iprot = to_UpdateSettings2_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings2_args)
decode_UpdateSettings2_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings2_args
decode_UpdateSettings2_args iprot bs = to_UpdateSettings2_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings2_args) bs
typemap_UpdateSettings2_args :: T.TypeMap
typemap_UpdateSettings2_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettings2_args :: UpdateSettings2_args
default_UpdateSettings2_args = UpdateSettings2_args{
  updateSettings2_args_reqSeq = 0,
  updateSettings2_args_settings = default_Settings}
data UpdateSettings2_result = UpdateSettings2_result  { updateSettings2_result_success :: I.Int32
  , updateSettings2_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettings2_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettings2_result_success record   `H.hashWithSalt` updateSettings2_result_e record  
instance QC.Arbitrary UpdateSettings2_result where 
  arbitrary = M.liftM UpdateSettings2_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettings2_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettings2_result{updateSettings2_result_success = updateSettings2_result_success obj} then P.Nothing else P.Just $ default_UpdateSettings2_result{updateSettings2_result_success = updateSettings2_result_success obj}
    , if obj == default_UpdateSettings2_result{updateSettings2_result_e = updateSettings2_result_e obj} then P.Nothing else P.Just $ default_UpdateSettings2_result{updateSettings2_result_e = updateSettings2_result_e obj}
    ]
from_UpdateSettings2_result :: UpdateSettings2_result -> T.ThriftVal
from_UpdateSettings2_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9469 -> (1, ("e",from_TalkException _v9469))) <$> updateSettings2_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9469 -> P.Just (0, ("success",T.TI32 _v9469))) $ updateSettings2_result_success record
    , (\_v9469 -> (1, ("e",from_TalkException _v9469))) <$> updateSettings2_result_e record
    ]
    )
write_UpdateSettings2_result :: T.Protocol p => p -> UpdateSettings2_result -> P.IO ()
write_UpdateSettings2_result oprot record = T.writeVal oprot $ from_UpdateSettings2_result record
encode_UpdateSettings2_result :: T.StatelessProtocol p => p -> UpdateSettings2_result -> LBS.ByteString
encode_UpdateSettings2_result oprot record = T.serializeVal oprot $ from_UpdateSettings2_result record
to_UpdateSettings2_result :: T.ThriftVal -> UpdateSettings2_result
to_UpdateSettings2_result (T.TStruct fields) = UpdateSettings2_result{
  updateSettings2_result_success = P.maybe (updateSettings2_result_success default_UpdateSettings2_result) (\(_,_val9471) -> (case _val9471 of {T.TI32 _val9472 -> _val9472; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSettings2_result_e = P.maybe (P.Nothing) (\(_,_val9471) -> P.Just (case _val9471 of {T.TStruct _val9473 -> (to_TalkException (T.TStruct _val9473)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettings2_result _ = P.error "not a struct"
read_UpdateSettings2_result :: T.Protocol p => p -> P.IO UpdateSettings2_result
read_UpdateSettings2_result iprot = to_UpdateSettings2_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettings2_result)
decode_UpdateSettings2_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettings2_result
decode_UpdateSettings2_result iprot bs = to_UpdateSettings2_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettings2_result) bs
typemap_UpdateSettings2_result :: T.TypeMap
typemap_UpdateSettings2_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettings2_result :: UpdateSettings2_result
default_UpdateSettings2_result = UpdateSettings2_result{
  updateSettings2_result_success = 0,
  updateSettings2_result_e = P.Nothing}
data UpdateSettingsAttribute_args = UpdateSettingsAttribute_args  { updateSettingsAttribute_args_reqSeq :: I.Int32
  , updateSettingsAttribute_args_attr :: SettingsAttribute
  , updateSettingsAttribute_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttribute_args_reqSeq record   `H.hashWithSalt` updateSettingsAttribute_args_attr record   `H.hashWithSalt` updateSettingsAttribute_args_value record  
instance QC.Arbitrary UpdateSettingsAttribute_args where 
  arbitrary = M.liftM UpdateSettingsAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_reqSeq = updateSettingsAttribute_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_reqSeq = updateSettingsAttribute_args_reqSeq obj}
    , if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_attr = updateSettingsAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_attr = updateSettingsAttribute_args_attr obj}
    , if obj == default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_value = updateSettingsAttribute_args_value obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_args{updateSettingsAttribute_args_value = updateSettingsAttribute_args_value obj}
    ]
from_UpdateSettingsAttribute_args :: UpdateSettingsAttribute_args -> T.ThriftVal
from_UpdateSettingsAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9476 -> P.Just (1, ("reqSeq",T.TI32 _v9476))) $ updateSettingsAttribute_args_reqSeq record
  , (\_v9476 -> P.Just (2, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v9476))) $ updateSettingsAttribute_args_attr record
  , (\_v9476 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v9476))) $ updateSettingsAttribute_args_value record
  ]
write_UpdateSettingsAttribute_args :: T.Protocol p => p -> UpdateSettingsAttribute_args -> P.IO ()
write_UpdateSettingsAttribute_args oprot record = T.writeVal oprot $ from_UpdateSettingsAttribute_args record
encode_UpdateSettingsAttribute_args :: T.StatelessProtocol p => p -> UpdateSettingsAttribute_args -> LBS.ByteString
encode_UpdateSettingsAttribute_args oprot record = T.serializeVal oprot $ from_UpdateSettingsAttribute_args record
to_UpdateSettingsAttribute_args :: T.ThriftVal -> UpdateSettingsAttribute_args
to_UpdateSettingsAttribute_args (T.TStruct fields) = UpdateSettingsAttribute_args{
  updateSettingsAttribute_args_reqSeq = P.maybe (updateSettingsAttribute_args_reqSeq default_UpdateSettingsAttribute_args) (\(_,_val9478) -> (case _val9478 of {T.TI32 _val9479 -> _val9479; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettingsAttribute_args_attr = P.maybe (updateSettingsAttribute_args_attr default_UpdateSettingsAttribute_args) (\(_,_val9478) -> (case _val9478 of {T.TI32 _val9480 -> P.toEnum $ P.fromIntegral _val9480; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSettingsAttribute_args_value = P.maybe (updateSettingsAttribute_args_value default_UpdateSettingsAttribute_args) (\(_,_val9478) -> (case _val9478 of {T.TString _val9481 -> E.decodeUtf8 _val9481; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSettingsAttribute_args _ = P.error "not a struct"
read_UpdateSettingsAttribute_args :: T.Protocol p => p -> P.IO UpdateSettingsAttribute_args
read_UpdateSettingsAttribute_args iprot = to_UpdateSettingsAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_args)
decode_UpdateSettingsAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttribute_args
decode_UpdateSettingsAttribute_args iprot bs = to_UpdateSettingsAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_args) bs
typemap_UpdateSettingsAttribute_args :: T.TypeMap
typemap_UpdateSettingsAttribute_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attr",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateSettingsAttribute_args :: UpdateSettingsAttribute_args
default_UpdateSettingsAttribute_args = UpdateSettingsAttribute_args{
  updateSettingsAttribute_args_reqSeq = 0,
  updateSettingsAttribute_args_attr = (P.toEnum 0),
  updateSettingsAttribute_args_value = ""}
data UpdateSettingsAttribute_result = UpdateSettingsAttribute_result  { updateSettingsAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttribute_result_e record  
instance QC.Arbitrary UpdateSettingsAttribute_result where 
  arbitrary = M.liftM UpdateSettingsAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = updateSettingsAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = updateSettingsAttribute_result_e obj}
    ]
from_UpdateSettingsAttribute_result :: UpdateSettingsAttribute_result -> T.ThriftVal
from_UpdateSettingsAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9484 -> (1, ("e",from_TalkException _v9484))) <$> updateSettingsAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9484 -> (1, ("e",from_TalkException _v9484))) <$> updateSettingsAttribute_result_e record
    ]
    )
write_UpdateSettingsAttribute_result :: T.Protocol p => p -> UpdateSettingsAttribute_result -> P.IO ()
write_UpdateSettingsAttribute_result oprot record = T.writeVal oprot $ from_UpdateSettingsAttribute_result record
encode_UpdateSettingsAttribute_result :: T.StatelessProtocol p => p -> UpdateSettingsAttribute_result -> LBS.ByteString
encode_UpdateSettingsAttribute_result oprot record = T.serializeVal oprot $ from_UpdateSettingsAttribute_result record
to_UpdateSettingsAttribute_result :: T.ThriftVal -> UpdateSettingsAttribute_result
to_UpdateSettingsAttribute_result (T.TStruct fields) = UpdateSettingsAttribute_result{
  updateSettingsAttribute_result_e = P.maybe (P.Nothing) (\(_,_val9486) -> P.Just (case _val9486 of {T.TStruct _val9487 -> (to_TalkException (T.TStruct _val9487)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettingsAttribute_result _ = P.error "not a struct"
read_UpdateSettingsAttribute_result :: T.Protocol p => p -> P.IO UpdateSettingsAttribute_result
read_UpdateSettingsAttribute_result iprot = to_UpdateSettingsAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_result)
decode_UpdateSettingsAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttribute_result
decode_UpdateSettingsAttribute_result iprot bs = to_UpdateSettingsAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttribute_result) bs
typemap_UpdateSettingsAttribute_result :: T.TypeMap
typemap_UpdateSettingsAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettingsAttribute_result :: UpdateSettingsAttribute_result
default_UpdateSettingsAttribute_result = UpdateSettingsAttribute_result{
  updateSettingsAttribute_result_e = P.Nothing}
data UpdateSettingsAttributes_args = UpdateSettingsAttributes_args  { updateSettingsAttributes_args_reqSeq :: I.Int32
  , updateSettingsAttributes_args_attrBitset :: I.Int32
  , updateSettingsAttributes_args_settings :: Settings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttributes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttributes_args_reqSeq record   `H.hashWithSalt` updateSettingsAttributes_args_attrBitset record   `H.hashWithSalt` updateSettingsAttributes_args_settings record  
instance QC.Arbitrary UpdateSettingsAttributes_args where 
  arbitrary = M.liftM UpdateSettingsAttributes_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttributes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_reqSeq = updateSettingsAttributes_args_reqSeq obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_reqSeq = updateSettingsAttributes_args_reqSeq obj}
    , if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_attrBitset = updateSettingsAttributes_args_attrBitset obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_attrBitset = updateSettingsAttributes_args_attrBitset obj}
    , if obj == default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_settings = updateSettingsAttributes_args_settings obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_args{updateSettingsAttributes_args_settings = updateSettingsAttributes_args_settings obj}
    ]
from_UpdateSettingsAttributes_args :: UpdateSettingsAttributes_args -> T.ThriftVal
from_UpdateSettingsAttributes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9490 -> P.Just (1, ("reqSeq",T.TI32 _v9490))) $ updateSettingsAttributes_args_reqSeq record
  , (\_v9490 -> P.Just (2, ("attrBitset",T.TI32 _v9490))) $ updateSettingsAttributes_args_attrBitset record
  , (\_v9490 -> P.Just (3, ("settings",from_Settings _v9490))) $ updateSettingsAttributes_args_settings record
  ]
write_UpdateSettingsAttributes_args :: T.Protocol p => p -> UpdateSettingsAttributes_args -> P.IO ()
write_UpdateSettingsAttributes_args oprot record = T.writeVal oprot $ from_UpdateSettingsAttributes_args record
encode_UpdateSettingsAttributes_args :: T.StatelessProtocol p => p -> UpdateSettingsAttributes_args -> LBS.ByteString
encode_UpdateSettingsAttributes_args oprot record = T.serializeVal oprot $ from_UpdateSettingsAttributes_args record
to_UpdateSettingsAttributes_args :: T.ThriftVal -> UpdateSettingsAttributes_args
to_UpdateSettingsAttributes_args (T.TStruct fields) = UpdateSettingsAttributes_args{
  updateSettingsAttributes_args_reqSeq = P.maybe (updateSettingsAttributes_args_reqSeq default_UpdateSettingsAttributes_args) (\(_,_val9492) -> (case _val9492 of {T.TI32 _val9493 -> _val9493; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSettingsAttributes_args_attrBitset = P.maybe (updateSettingsAttributes_args_attrBitset default_UpdateSettingsAttributes_args) (\(_,_val9492) -> (case _val9492 of {T.TI32 _val9494 -> _val9494; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSettingsAttributes_args_settings = P.maybe (updateSettingsAttributes_args_settings default_UpdateSettingsAttributes_args) (\(_,_val9492) -> (case _val9492 of {T.TStruct _val9495 -> (to_Settings (T.TStruct _val9495)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSettingsAttributes_args _ = P.error "not a struct"
read_UpdateSettingsAttributes_args :: T.Protocol p => p -> P.IO UpdateSettingsAttributes_args
read_UpdateSettingsAttributes_args iprot = to_UpdateSettingsAttributes_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_args)
decode_UpdateSettingsAttributes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttributes_args
decode_UpdateSettingsAttributes_args iprot bs = to_UpdateSettingsAttributes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_args) bs
typemap_UpdateSettingsAttributes_args :: T.TypeMap
typemap_UpdateSettingsAttributes_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("attrBitset",T.T_I32)),(3,("settings",(T.T_STRUCT typemap_Settings)))]
default_UpdateSettingsAttributes_args :: UpdateSettingsAttributes_args
default_UpdateSettingsAttributes_args = UpdateSettingsAttributes_args{
  updateSettingsAttributes_args_reqSeq = 0,
  updateSettingsAttributes_args_attrBitset = 0,
  updateSettingsAttributes_args_settings = default_Settings}
data UpdateSettingsAttributes_result = UpdateSettingsAttributes_result  { updateSettingsAttributes_result_success :: I.Int32
  , updateSettingsAttributes_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSettingsAttributes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSettingsAttributes_result_success record   `H.hashWithSalt` updateSettingsAttributes_result_e record  
instance QC.Arbitrary UpdateSettingsAttributes_result where 
  arbitrary = M.liftM UpdateSettingsAttributes_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSettingsAttributes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = updateSettingsAttributes_result_success obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = updateSettingsAttributes_result_success obj}
    , if obj == default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = updateSettingsAttributes_result_e obj} then P.Nothing else P.Just $ default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = updateSettingsAttributes_result_e obj}
    ]
from_UpdateSettingsAttributes_result :: UpdateSettingsAttributes_result -> T.ThriftVal
from_UpdateSettingsAttributes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9498 -> (1, ("e",from_TalkException _v9498))) <$> updateSettingsAttributes_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9498 -> P.Just (0, ("success",T.TI32 _v9498))) $ updateSettingsAttributes_result_success record
    , (\_v9498 -> (1, ("e",from_TalkException _v9498))) <$> updateSettingsAttributes_result_e record
    ]
    )
write_UpdateSettingsAttributes_result :: T.Protocol p => p -> UpdateSettingsAttributes_result -> P.IO ()
write_UpdateSettingsAttributes_result oprot record = T.writeVal oprot $ from_UpdateSettingsAttributes_result record
encode_UpdateSettingsAttributes_result :: T.StatelessProtocol p => p -> UpdateSettingsAttributes_result -> LBS.ByteString
encode_UpdateSettingsAttributes_result oprot record = T.serializeVal oprot $ from_UpdateSettingsAttributes_result record
to_UpdateSettingsAttributes_result :: T.ThriftVal -> UpdateSettingsAttributes_result
to_UpdateSettingsAttributes_result (T.TStruct fields) = UpdateSettingsAttributes_result{
  updateSettingsAttributes_result_success = P.maybe (updateSettingsAttributes_result_success default_UpdateSettingsAttributes_result) (\(_,_val9500) -> (case _val9500 of {T.TI32 _val9501 -> _val9501; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSettingsAttributes_result_e = P.maybe (P.Nothing) (\(_,_val9500) -> P.Just (case _val9500 of {T.TStruct _val9502 -> (to_TalkException (T.TStruct _val9502)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateSettingsAttributes_result _ = P.error "not a struct"
read_UpdateSettingsAttributes_result :: T.Protocol p => p -> P.IO UpdateSettingsAttributes_result
read_UpdateSettingsAttributes_result iprot = to_UpdateSettingsAttributes_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_result)
decode_UpdateSettingsAttributes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSettingsAttributes_result
decode_UpdateSettingsAttributes_result iprot bs = to_UpdateSettingsAttributes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSettingsAttributes_result) bs
typemap_UpdateSettingsAttributes_result :: T.TypeMap
typemap_UpdateSettingsAttributes_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateSettingsAttributes_result :: UpdateSettingsAttributes_result
default_UpdateSettingsAttributes_result = UpdateSettingsAttributes_result{
  updateSettingsAttributes_result_success = 0,
  updateSettingsAttributes_result_e = P.Nothing}
data VerifyIdentityCredential_args = VerifyIdentityCredential_args  { verifyIdentityCredential_args_identityProvider :: IdentityProvider
  , verifyIdentityCredential_args_identifier :: LT.Text
  , verifyIdentityCredential_args_password :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredential_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredential_args_identityProvider record   `H.hashWithSalt` verifyIdentityCredential_args_identifier record   `H.hashWithSalt` verifyIdentityCredential_args_password record  
instance QC.Arbitrary VerifyIdentityCredential_args where 
  arbitrary = M.liftM VerifyIdentityCredential_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredential_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identityProvider = verifyIdentityCredential_args_identityProvider obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identityProvider = verifyIdentityCredential_args_identityProvider obj}
    , if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identifier = verifyIdentityCredential_args_identifier obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_identifier = verifyIdentityCredential_args_identifier obj}
    , if obj == default_VerifyIdentityCredential_args{verifyIdentityCredential_args_password = verifyIdentityCredential_args_password obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_args{verifyIdentityCredential_args_password = verifyIdentityCredential_args_password obj}
    ]
from_VerifyIdentityCredential_args :: VerifyIdentityCredential_args -> T.ThriftVal
from_VerifyIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9505 -> P.Just (3, ("identifier",T.TString $ E.encodeUtf8 _v9505))) $ verifyIdentityCredential_args_identifier record
  , (\_v9505 -> P.Just (4, ("password",T.TString $ E.encodeUtf8 _v9505))) $ verifyIdentityCredential_args_password record
  , (\_v9505 -> P.Just (8, ("identityProvider",T.TI32 $ P.fromIntegral $ P.fromEnum _v9505))) $ verifyIdentityCredential_args_identityProvider record
  ]
write_VerifyIdentityCredential_args :: T.Protocol p => p -> VerifyIdentityCredential_args -> P.IO ()
write_VerifyIdentityCredential_args oprot record = T.writeVal oprot $ from_VerifyIdentityCredential_args record
encode_VerifyIdentityCredential_args :: T.StatelessProtocol p => p -> VerifyIdentityCredential_args -> LBS.ByteString
encode_VerifyIdentityCredential_args oprot record = T.serializeVal oprot $ from_VerifyIdentityCredential_args record
to_VerifyIdentityCredential_args :: T.ThriftVal -> VerifyIdentityCredential_args
to_VerifyIdentityCredential_args (T.TStruct fields) = VerifyIdentityCredential_args{
  verifyIdentityCredential_args_identityProvider = P.maybe (verifyIdentityCredential_args_identityProvider default_VerifyIdentityCredential_args) (\(_,_val9507) -> (case _val9507 of {T.TI32 _val9508 -> P.toEnum $ P.fromIntegral _val9508; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  verifyIdentityCredential_args_identifier = P.maybe (verifyIdentityCredential_args_identifier default_VerifyIdentityCredential_args) (\(_,_val9507) -> (case _val9507 of {T.TString _val9509 -> E.decodeUtf8 _val9509; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyIdentityCredential_args_password = P.maybe (verifyIdentityCredential_args_password default_VerifyIdentityCredential_args) (\(_,_val9507) -> (case _val9507 of {T.TString _val9510 -> E.decodeUtf8 _val9510; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_VerifyIdentityCredential_args _ = P.error "not a struct"
read_VerifyIdentityCredential_args :: T.Protocol p => p -> P.IO VerifyIdentityCredential_args
read_VerifyIdentityCredential_args iprot = to_VerifyIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_args)
decode_VerifyIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredential_args
decode_VerifyIdentityCredential_args iprot bs = to_VerifyIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_args) bs
typemap_VerifyIdentityCredential_args :: T.TypeMap
typemap_VerifyIdentityCredential_args = Map.fromList [(3,("identifier",T.T_STRING)),(4,("password",T.T_STRING)),(8,("identityProvider",T.T_I32))]
default_VerifyIdentityCredential_args :: VerifyIdentityCredential_args
default_VerifyIdentityCredential_args = VerifyIdentityCredential_args{
  verifyIdentityCredential_args_identifier = "",
  verifyIdentityCredential_args_password = "",
  verifyIdentityCredential_args_identityProvider = (P.toEnum 0)}
data VerifyIdentityCredential_result = VerifyIdentityCredential_result  { verifyIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredential_result_e record  
instance QC.Arbitrary VerifyIdentityCredential_result where 
  arbitrary = M.liftM VerifyIdentityCredential_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = verifyIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = verifyIdentityCredential_result_e obj}
    ]
from_VerifyIdentityCredential_result :: VerifyIdentityCredential_result -> T.ThriftVal
from_VerifyIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9513 -> (1, ("e",from_TalkException _v9513))) <$> verifyIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9513 -> (1, ("e",from_TalkException _v9513))) <$> verifyIdentityCredential_result_e record
    ]
    )
write_VerifyIdentityCredential_result :: T.Protocol p => p -> VerifyIdentityCredential_result -> P.IO ()
write_VerifyIdentityCredential_result oprot record = T.writeVal oprot $ from_VerifyIdentityCredential_result record
encode_VerifyIdentityCredential_result :: T.StatelessProtocol p => p -> VerifyIdentityCredential_result -> LBS.ByteString
encode_VerifyIdentityCredential_result oprot record = T.serializeVal oprot $ from_VerifyIdentityCredential_result record
to_VerifyIdentityCredential_result :: T.ThriftVal -> VerifyIdentityCredential_result
to_VerifyIdentityCredential_result (T.TStruct fields) = VerifyIdentityCredential_result{
  verifyIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val9515) -> P.Just (case _val9515 of {T.TStruct _val9516 -> (to_TalkException (T.TStruct _val9516)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyIdentityCredential_result _ = P.error "not a struct"
read_VerifyIdentityCredential_result :: T.Protocol p => p -> P.IO VerifyIdentityCredential_result
read_VerifyIdentityCredential_result iprot = to_VerifyIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_result)
decode_VerifyIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredential_result
decode_VerifyIdentityCredential_result iprot bs = to_VerifyIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredential_result) bs
typemap_VerifyIdentityCredential_result :: T.TypeMap
typemap_VerifyIdentityCredential_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyIdentityCredential_result :: VerifyIdentityCredential_result
default_VerifyIdentityCredential_result = VerifyIdentityCredential_result{
  verifyIdentityCredential_result_e = P.Nothing}
data VerifyIdentityCredentialWithResult_args = VerifyIdentityCredentialWithResult_args  { verifyIdentityCredentialWithResult_args_identityCredential :: IdentityCredential
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredentialWithResult_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredentialWithResult_args_identityCredential record  
instance QC.Arbitrary VerifyIdentityCredentialWithResult_args where 
  arbitrary = M.liftM VerifyIdentityCredentialWithResult_args (QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredentialWithResult_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredentialWithResult_args{verifyIdentityCredentialWithResult_args_identityCredential = verifyIdentityCredentialWithResult_args_identityCredential obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_args{verifyIdentityCredentialWithResult_args_identityCredential = verifyIdentityCredentialWithResult_args_identityCredential obj}
    ]
from_VerifyIdentityCredentialWithResult_args :: VerifyIdentityCredentialWithResult_args -> T.ThriftVal
from_VerifyIdentityCredentialWithResult_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9519 -> P.Just (2, ("identityCredential",from_IdentityCredential _v9519))) $ verifyIdentityCredentialWithResult_args_identityCredential record
  ]
write_VerifyIdentityCredentialWithResult_args :: T.Protocol p => p -> VerifyIdentityCredentialWithResult_args -> P.IO ()
write_VerifyIdentityCredentialWithResult_args oprot record = T.writeVal oprot $ from_VerifyIdentityCredentialWithResult_args record
encode_VerifyIdentityCredentialWithResult_args :: T.StatelessProtocol p => p -> VerifyIdentityCredentialWithResult_args -> LBS.ByteString
encode_VerifyIdentityCredentialWithResult_args oprot record = T.serializeVal oprot $ from_VerifyIdentityCredentialWithResult_args record
to_VerifyIdentityCredentialWithResult_args :: T.ThriftVal -> VerifyIdentityCredentialWithResult_args
to_VerifyIdentityCredentialWithResult_args (T.TStruct fields) = VerifyIdentityCredentialWithResult_args{
  verifyIdentityCredentialWithResult_args_identityCredential = P.maybe (verifyIdentityCredentialWithResult_args_identityCredential default_VerifyIdentityCredentialWithResult_args) (\(_,_val9521) -> (case _val9521 of {T.TStruct _val9522 -> (to_IdentityCredential (T.TStruct _val9522)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_VerifyIdentityCredentialWithResult_args _ = P.error "not a struct"
read_VerifyIdentityCredentialWithResult_args :: T.Protocol p => p -> P.IO VerifyIdentityCredentialWithResult_args
read_VerifyIdentityCredentialWithResult_args iprot = to_VerifyIdentityCredentialWithResult_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_args)
decode_VerifyIdentityCredentialWithResult_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredentialWithResult_args
decode_VerifyIdentityCredentialWithResult_args iprot bs = to_VerifyIdentityCredentialWithResult_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_args) bs
typemap_VerifyIdentityCredentialWithResult_args :: T.TypeMap
typemap_VerifyIdentityCredentialWithResult_args = Map.fromList [(2,("identityCredential",(T.T_STRUCT typemap_IdentityCredential)))]
default_VerifyIdentityCredentialWithResult_args :: VerifyIdentityCredentialWithResult_args
default_VerifyIdentityCredentialWithResult_args = VerifyIdentityCredentialWithResult_args{
  verifyIdentityCredentialWithResult_args_identityCredential = default_IdentityCredential}
data VerifyIdentityCredentialWithResult_result = VerifyIdentityCredentialWithResult_result  { verifyIdentityCredentialWithResult_result_success :: UserAuthStatus
  , verifyIdentityCredentialWithResult_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyIdentityCredentialWithResult_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyIdentityCredentialWithResult_result_success record   `H.hashWithSalt` verifyIdentityCredentialWithResult_result_e record  
instance QC.Arbitrary VerifyIdentityCredentialWithResult_result where 
  arbitrary = M.liftM VerifyIdentityCredentialWithResult_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyIdentityCredentialWithResult_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = verifyIdentityCredentialWithResult_result_success obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = verifyIdentityCredentialWithResult_result_success obj}
    , if obj == default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = verifyIdentityCredentialWithResult_result_e obj} then P.Nothing else P.Just $ default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = verifyIdentityCredentialWithResult_result_e obj}
    ]
from_VerifyIdentityCredentialWithResult_result :: VerifyIdentityCredentialWithResult_result -> T.ThriftVal
from_VerifyIdentityCredentialWithResult_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9525 -> (1, ("e",from_TalkException _v9525))) <$> verifyIdentityCredentialWithResult_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9525 -> P.Just (0, ("success",from_UserAuthStatus _v9525))) $ verifyIdentityCredentialWithResult_result_success record
    , (\_v9525 -> (1, ("e",from_TalkException _v9525))) <$> verifyIdentityCredentialWithResult_result_e record
    ]
    )
write_VerifyIdentityCredentialWithResult_result :: T.Protocol p => p -> VerifyIdentityCredentialWithResult_result -> P.IO ()
write_VerifyIdentityCredentialWithResult_result oprot record = T.writeVal oprot $ from_VerifyIdentityCredentialWithResult_result record
encode_VerifyIdentityCredentialWithResult_result :: T.StatelessProtocol p => p -> VerifyIdentityCredentialWithResult_result -> LBS.ByteString
encode_VerifyIdentityCredentialWithResult_result oprot record = T.serializeVal oprot $ from_VerifyIdentityCredentialWithResult_result record
to_VerifyIdentityCredentialWithResult_result :: T.ThriftVal -> VerifyIdentityCredentialWithResult_result
to_VerifyIdentityCredentialWithResult_result (T.TStruct fields) = VerifyIdentityCredentialWithResult_result{
  verifyIdentityCredentialWithResult_result_success = P.maybe (verifyIdentityCredentialWithResult_result_success default_VerifyIdentityCredentialWithResult_result) (\(_,_val9527) -> (case _val9527 of {T.TStruct _val9528 -> (to_UserAuthStatus (T.TStruct _val9528)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyIdentityCredentialWithResult_result_e = P.maybe (P.Nothing) (\(_,_val9527) -> P.Just (case _val9527 of {T.TStruct _val9529 -> (to_TalkException (T.TStruct _val9529)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyIdentityCredentialWithResult_result _ = P.error "not a struct"
read_VerifyIdentityCredentialWithResult_result :: T.Protocol p => p -> P.IO VerifyIdentityCredentialWithResult_result
read_VerifyIdentityCredentialWithResult_result iprot = to_VerifyIdentityCredentialWithResult_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_result)
decode_VerifyIdentityCredentialWithResult_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyIdentityCredentialWithResult_result
decode_VerifyIdentityCredentialWithResult_result iprot bs = to_VerifyIdentityCredentialWithResult_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyIdentityCredentialWithResult_result) bs
typemap_VerifyIdentityCredentialWithResult_result :: T.TypeMap
typemap_VerifyIdentityCredentialWithResult_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UserAuthStatus))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyIdentityCredentialWithResult_result :: VerifyIdentityCredentialWithResult_result
default_VerifyIdentityCredentialWithResult_result = VerifyIdentityCredentialWithResult_result{
  verifyIdentityCredentialWithResult_result_success = default_UserAuthStatus,
  verifyIdentityCredentialWithResult_result_e = P.Nothing}
data VerifyPhone_args = VerifyPhone_args  { verifyPhone_args_sessionId :: LT.Text
  , verifyPhone_args_pinCode :: LT.Text
  , verifyPhone_args_udidHash :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhone_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhone_args_sessionId record   `H.hashWithSalt` verifyPhone_args_pinCode record   `H.hashWithSalt` verifyPhone_args_udidHash record  
instance QC.Arbitrary VerifyPhone_args where 
  arbitrary = M.liftM VerifyPhone_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyPhone_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhone_args{verifyPhone_args_sessionId = verifyPhone_args_sessionId obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_sessionId = verifyPhone_args_sessionId obj}
    , if obj == default_VerifyPhone_args{verifyPhone_args_pinCode = verifyPhone_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_pinCode = verifyPhone_args_pinCode obj}
    , if obj == default_VerifyPhone_args{verifyPhone_args_udidHash = verifyPhone_args_udidHash obj} then P.Nothing else P.Just $ default_VerifyPhone_args{verifyPhone_args_udidHash = verifyPhone_args_udidHash obj}
    ]
from_VerifyPhone_args :: VerifyPhone_args -> T.ThriftVal
from_VerifyPhone_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9532 -> P.Just (2, ("sessionId",T.TString $ E.encodeUtf8 _v9532))) $ verifyPhone_args_sessionId record
  , (\_v9532 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v9532))) $ verifyPhone_args_pinCode record
  , (\_v9532 -> P.Just (4, ("udidHash",T.TString $ E.encodeUtf8 _v9532))) $ verifyPhone_args_udidHash record
  ]
write_VerifyPhone_args :: T.Protocol p => p -> VerifyPhone_args -> P.IO ()
write_VerifyPhone_args oprot record = T.writeVal oprot $ from_VerifyPhone_args record
encode_VerifyPhone_args :: T.StatelessProtocol p => p -> VerifyPhone_args -> LBS.ByteString
encode_VerifyPhone_args oprot record = T.serializeVal oprot $ from_VerifyPhone_args record
to_VerifyPhone_args :: T.ThriftVal -> VerifyPhone_args
to_VerifyPhone_args (T.TStruct fields) = VerifyPhone_args{
  verifyPhone_args_sessionId = P.maybe (verifyPhone_args_sessionId default_VerifyPhone_args) (\(_,_val9534) -> (case _val9534 of {T.TString _val9535 -> E.decodeUtf8 _val9535; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyPhone_args_pinCode = P.maybe (verifyPhone_args_pinCode default_VerifyPhone_args) (\(_,_val9534) -> (case _val9534 of {T.TString _val9536 -> E.decodeUtf8 _val9536; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  verifyPhone_args_udidHash = P.maybe (verifyPhone_args_udidHash default_VerifyPhone_args) (\(_,_val9534) -> (case _val9534 of {T.TString _val9537 -> E.decodeUtf8 _val9537; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_VerifyPhone_args _ = P.error "not a struct"
read_VerifyPhone_args :: T.Protocol p => p -> P.IO VerifyPhone_args
read_VerifyPhone_args iprot = to_VerifyPhone_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhone_args)
decode_VerifyPhone_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhone_args
decode_VerifyPhone_args iprot bs = to_VerifyPhone_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhone_args) bs
typemap_VerifyPhone_args :: T.TypeMap
typemap_VerifyPhone_args = Map.fromList [(2,("sessionId",T.T_STRING)),(3,("pinCode",T.T_STRING)),(4,("udidHash",T.T_STRING))]
default_VerifyPhone_args :: VerifyPhone_args
default_VerifyPhone_args = VerifyPhone_args{
  verifyPhone_args_sessionId = "",
  verifyPhone_args_pinCode = "",
  verifyPhone_args_udidHash = ""}
data VerifyPhone_result = VerifyPhone_result  { verifyPhone_result_success :: VerificationResult
  , verifyPhone_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyPhone_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyPhone_result_success record   `H.hashWithSalt` verifyPhone_result_e record  
instance QC.Arbitrary VerifyPhone_result where 
  arbitrary = M.liftM VerifyPhone_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyPhone_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyPhone_result{verifyPhone_result_success = verifyPhone_result_success obj} then P.Nothing else P.Just $ default_VerifyPhone_result{verifyPhone_result_success = verifyPhone_result_success obj}
    , if obj == default_VerifyPhone_result{verifyPhone_result_e = verifyPhone_result_e obj} then P.Nothing else P.Just $ default_VerifyPhone_result{verifyPhone_result_e = verifyPhone_result_e obj}
    ]
from_VerifyPhone_result :: VerifyPhone_result -> T.ThriftVal
from_VerifyPhone_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9540 -> (1, ("e",from_TalkException _v9540))) <$> verifyPhone_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9540 -> P.Just (0, ("success",T.TI32 $ P.fromIntegral $ P.fromEnum _v9540))) $ verifyPhone_result_success record
    , (\_v9540 -> (1, ("e",from_TalkException _v9540))) <$> verifyPhone_result_e record
    ]
    )
write_VerifyPhone_result :: T.Protocol p => p -> VerifyPhone_result -> P.IO ()
write_VerifyPhone_result oprot record = T.writeVal oprot $ from_VerifyPhone_result record
encode_VerifyPhone_result :: T.StatelessProtocol p => p -> VerifyPhone_result -> LBS.ByteString
encode_VerifyPhone_result oprot record = T.serializeVal oprot $ from_VerifyPhone_result record
to_VerifyPhone_result :: T.ThriftVal -> VerifyPhone_result
to_VerifyPhone_result (T.TStruct fields) = VerifyPhone_result{
  verifyPhone_result_success = P.maybe (verifyPhone_result_success default_VerifyPhone_result) (\(_,_val9542) -> (case _val9542 of {T.TI32 _val9543 -> P.toEnum $ P.fromIntegral _val9543; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyPhone_result_e = P.maybe (P.Nothing) (\(_,_val9542) -> P.Just (case _val9542 of {T.TStruct _val9544 -> (to_TalkException (T.TStruct _val9544)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyPhone_result _ = P.error "not a struct"
read_VerifyPhone_result :: T.Protocol p => p -> P.IO VerifyPhone_result
read_VerifyPhone_result iprot = to_VerifyPhone_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyPhone_result)
decode_VerifyPhone_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyPhone_result
decode_VerifyPhone_result iprot bs = to_VerifyPhone_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyPhone_result) bs
typemap_VerifyPhone_result :: T.TypeMap
typemap_VerifyPhone_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyPhone_result :: VerifyPhone_result
default_VerifyPhone_result = VerifyPhone_result{
  verifyPhone_result_success = (P.toEnum 0),
  verifyPhone_result_e = P.Nothing}
data VerifyQrcode_args = VerifyQrcode_args  { verifyQrcode_args_verifier :: LT.Text
  , verifyQrcode_args_pinCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcode_args_verifier record   `H.hashWithSalt` verifyQrcode_args_pinCode record  
instance QC.Arbitrary VerifyQrcode_args where 
  arbitrary = M.liftM VerifyQrcode_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_VerifyQrcode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcode_args{verifyQrcode_args_verifier = verifyQrcode_args_verifier obj} then P.Nothing else P.Just $ default_VerifyQrcode_args{verifyQrcode_args_verifier = verifyQrcode_args_verifier obj}
    , if obj == default_VerifyQrcode_args{verifyQrcode_args_pinCode = verifyQrcode_args_pinCode obj} then P.Nothing else P.Just $ default_VerifyQrcode_args{verifyQrcode_args_pinCode = verifyQrcode_args_pinCode obj}
    ]
from_VerifyQrcode_args :: VerifyQrcode_args -> T.ThriftVal
from_VerifyQrcode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9547 -> P.Just (2, ("verifier",T.TString $ E.encodeUtf8 _v9547))) $ verifyQrcode_args_verifier record
  , (\_v9547 -> P.Just (3, ("pinCode",T.TString $ E.encodeUtf8 _v9547))) $ verifyQrcode_args_pinCode record
  ]
write_VerifyQrcode_args :: T.Protocol p => p -> VerifyQrcode_args -> P.IO ()
write_VerifyQrcode_args oprot record = T.writeVal oprot $ from_VerifyQrcode_args record
encode_VerifyQrcode_args :: T.StatelessProtocol p => p -> VerifyQrcode_args -> LBS.ByteString
encode_VerifyQrcode_args oprot record = T.serializeVal oprot $ from_VerifyQrcode_args record
to_VerifyQrcode_args :: T.ThriftVal -> VerifyQrcode_args
to_VerifyQrcode_args (T.TStruct fields) = VerifyQrcode_args{
  verifyQrcode_args_verifier = P.maybe (verifyQrcode_args_verifier default_VerifyQrcode_args) (\(_,_val9549) -> (case _val9549 of {T.TString _val9550 -> E.decodeUtf8 _val9550; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  verifyQrcode_args_pinCode = P.maybe (verifyQrcode_args_pinCode default_VerifyQrcode_args) (\(_,_val9549) -> (case _val9549 of {T.TString _val9551 -> E.decodeUtf8 _val9551; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_VerifyQrcode_args _ = P.error "not a struct"
read_VerifyQrcode_args :: T.Protocol p => p -> P.IO VerifyQrcode_args
read_VerifyQrcode_args iprot = to_VerifyQrcode_args <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcode_args)
decode_VerifyQrcode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcode_args
decode_VerifyQrcode_args iprot bs = to_VerifyQrcode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcode_args) bs
typemap_VerifyQrcode_args :: T.TypeMap
typemap_VerifyQrcode_args = Map.fromList [(2,("verifier",T.T_STRING)),(3,("pinCode",T.T_STRING))]
default_VerifyQrcode_args :: VerifyQrcode_args
default_VerifyQrcode_args = VerifyQrcode_args{
  verifyQrcode_args_verifier = "",
  verifyQrcode_args_pinCode = ""}
data VerifyQrcode_result = VerifyQrcode_result  { verifyQrcode_result_success :: LT.Text
  , verifyQrcode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable VerifyQrcode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` verifyQrcode_result_success record   `H.hashWithSalt` verifyQrcode_result_e record  
instance QC.Arbitrary VerifyQrcode_result where 
  arbitrary = M.liftM VerifyQrcode_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_VerifyQrcode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_VerifyQrcode_result{verifyQrcode_result_success = verifyQrcode_result_success obj} then P.Nothing else P.Just $ default_VerifyQrcode_result{verifyQrcode_result_success = verifyQrcode_result_success obj}
    , if obj == default_VerifyQrcode_result{verifyQrcode_result_e = verifyQrcode_result_e obj} then P.Nothing else P.Just $ default_VerifyQrcode_result{verifyQrcode_result_e = verifyQrcode_result_e obj}
    ]
from_VerifyQrcode_result :: VerifyQrcode_result -> T.ThriftVal
from_VerifyQrcode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9554 -> (1, ("e",from_TalkException _v9554))) <$> verifyQrcode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9554 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v9554))) $ verifyQrcode_result_success record
    , (\_v9554 -> (1, ("e",from_TalkException _v9554))) <$> verifyQrcode_result_e record
    ]
    )
write_VerifyQrcode_result :: T.Protocol p => p -> VerifyQrcode_result -> P.IO ()
write_VerifyQrcode_result oprot record = T.writeVal oprot $ from_VerifyQrcode_result record
encode_VerifyQrcode_result :: T.StatelessProtocol p => p -> VerifyQrcode_result -> LBS.ByteString
encode_VerifyQrcode_result oprot record = T.serializeVal oprot $ from_VerifyQrcode_result record
to_VerifyQrcode_result :: T.ThriftVal -> VerifyQrcode_result
to_VerifyQrcode_result (T.TStruct fields) = VerifyQrcode_result{
  verifyQrcode_result_success = P.maybe (verifyQrcode_result_success default_VerifyQrcode_result) (\(_,_val9556) -> (case _val9556 of {T.TString _val9557 -> E.decodeUtf8 _val9557; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  verifyQrcode_result_e = P.maybe (P.Nothing) (\(_,_val9556) -> P.Just (case _val9556 of {T.TStruct _val9558 -> (to_TalkException (T.TStruct _val9558)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_VerifyQrcode_result _ = P.error "not a struct"
read_VerifyQrcode_result :: T.Protocol p => p -> P.IO VerifyQrcode_result
read_VerifyQrcode_result iprot = to_VerifyQrcode_result <$> T.readVal iprot (T.T_STRUCT typemap_VerifyQrcode_result)
decode_VerifyQrcode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> VerifyQrcode_result
decode_VerifyQrcode_result iprot bs = to_VerifyQrcode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_VerifyQrcode_result) bs
typemap_VerifyQrcode_result :: T.TypeMap
typemap_VerifyQrcode_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_VerifyQrcode_result :: VerifyQrcode_result
default_VerifyQrcode_result = VerifyQrcode_result{
  verifyQrcode_result_success = "",
  verifyQrcode_result_e = P.Nothing}
process_getChatRoomAnnouncementsBulk (seqid, iprot, oprot, handler) = do
  args <- read_GetChatRoomAnnouncementsBulk_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChatRoomAnnouncementsBulk handler (getChatRoomAnnouncementsBulk_args_chatRoomMids args)
        let res = default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_success = val}
        T.writeMessage oprot ("getChatRoomAnnouncementsBulk", T.M_REPLY, seqid) $
          write_GetChatRoomAnnouncementsBulk_result oprot res)
      (\e  -> do
        let res = default_GetChatRoomAnnouncementsBulk_result{getChatRoomAnnouncementsBulk_result_e = P.Just e}
        T.writeMessage oprot ("getChatRoomAnnouncementsBulk", T.M_REPLY, seqid) $
          write_GetChatRoomAnnouncementsBulk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChatRoomAnnouncementsBulk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getChatRoomAnnouncements (seqid, iprot, oprot, handler) = do
  args <- read_GetChatRoomAnnouncements_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getChatRoomAnnouncements handler (getChatRoomAnnouncements_args_chatRoomMid args)
        let res = default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_success = val}
        T.writeMessage oprot ("getChatRoomAnnouncements", T.M_REPLY, seqid) $
          write_GetChatRoomAnnouncements_result oprot res)
      (\e  -> do
        let res = default_GetChatRoomAnnouncements_result{getChatRoomAnnouncements_result_e = P.Just e}
        T.writeMessage oprot ("getChatRoomAnnouncements", T.M_REPLY, seqid) $
          write_GetChatRoomAnnouncements_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getChatRoomAnnouncements", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createChatRoomAnnouncement (seqid, iprot, oprot, handler) = do
  args <- read_CreateChatRoomAnnouncement_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createChatRoomAnnouncement handler (createChatRoomAnnouncement_args_reqSeq args) (createChatRoomAnnouncement_args_chatRoomMid args) (createChatRoomAnnouncement_args_type args) (createChatRoomAnnouncement_args_contents args)
        let res = default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_success = val}
        T.writeMessage oprot ("createChatRoomAnnouncement", T.M_REPLY, seqid) $
          write_CreateChatRoomAnnouncement_result oprot res)
      (\e  -> do
        let res = default_CreateChatRoomAnnouncement_result{createChatRoomAnnouncement_result_e = P.Just e}
        T.writeMessage oprot ("createChatRoomAnnouncement", T.M_REPLY, seqid) $
          write_CreateChatRoomAnnouncement_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createChatRoomAnnouncement", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeChatRoomAnnouncement (seqid, iprot, oprot, handler) = do
  args <- read_RemoveChatRoomAnnouncement_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeChatRoomAnnouncement handler (removeChatRoomAnnouncement_args_reqSeq args) (removeChatRoomAnnouncement_args_chatRoomMid args) (removeChatRoomAnnouncement_args_announcementSeq args)
        let res = default_RemoveChatRoomAnnouncement_result
        T.writeMessage oprot ("removeChatRoomAnnouncement", T.M_REPLY, seqid) $
          write_RemoveChatRoomAnnouncement_result oprot res)
      (\e  -> do
        let res = default_RemoveChatRoomAnnouncement_result{removeChatRoomAnnouncement_result_e = P.Just e}
        T.writeMessage oprot ("removeChatRoomAnnouncement", T.M_REPLY, seqid) $
          write_RemoveChatRoomAnnouncement_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeChatRoomAnnouncement", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unsendMessage (seqid, iprot, oprot, handler) = do
  args <- read_UnsendMessage_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unsendMessage handler (unsendMessage_args_seq args) (unsendMessage_args_messageId args)
        let res = default_UnsendMessage_result
        T.writeMessage oprot ("unsendMessage", T.M_REPLY, seqid) $
          write_UnsendMessage_result oprot res)
      (\e  -> do
        let res = default_UnsendMessage_result{unsendMessage_result_e = P.Just e}
        T.writeMessage oprot ("unsendMessage", T.M_REPLY, seqid) $
          write_UnsendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unsendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupWithoutMembers (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupWithoutMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupWithoutMembers handler (getGroupWithoutMembers_args_groupId args)
        let res = default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_success = val}
        T.writeMessage oprot ("getGroupWithoutMembers", T.M_REPLY, seqid) $
          write_GetGroupWithoutMembers_result oprot res)
      (\e  -> do
        let res = default_GetGroupWithoutMembers_result{getGroupWithoutMembers_result_e = P.Just e}
        T.writeMessage oprot ("getGroupWithoutMembers", T.M_REPLY, seqid) $
          write_GetGroupWithoutMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupWithoutMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestResendMessage (seqid, iprot, oprot, handler) = do
  args <- read_RequestResendMessage_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestResendMessage handler (requestResendMessage_args_reqSeq args) (requestResendMessage_args_senderMid args) (requestResendMessage_args_messageId args)
        let res = default_RequestResendMessage_result
        T.writeMessage oprot ("requestResendMessage", T.M_REPLY, seqid) $
          write_RequestResendMessage_result oprot res)
      (\e  -> do
        let res = default_RequestResendMessage_result{requestResendMessage_result_e = P.Just e}
        T.writeMessage oprot ("requestResendMessage", T.M_REPLY, seqid) $
          write_RequestResendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestResendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_respondResendMessage (seqid, iprot, oprot, handler) = do
  args <- read_RespondResendMessage_args iprot
  (X.catch
    (X.catch
      (do
        Iface.respondResendMessage handler (respondResendMessage_args_reqSeq args) (respondResendMessage_args_receiverMid args) (respondResendMessage_args_originalMessageId args) (respondResendMessage_args_resendMessage args) (respondResendMessage_args_errorCode args)
        let res = default_RespondResendMessage_result
        T.writeMessage oprot ("respondResendMessage", T.M_REPLY, seqid) $
          write_RespondResendMessage_result oprot res)
      (\e  -> do
        let res = default_RespondResendMessage_result{respondResendMessage_result_e = P.Just e}
        T.writeMessage oprot ("respondResendMessage", T.M_REPLY, seqid) $
          write_RespondResendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("respondResendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acceptGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_AcceptGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.acceptGroupInvitation handler (acceptGroupInvitation_args_reqSeq args) (acceptGroupInvitation_args_groupId args)
        let res = default_AcceptGroupInvitation_result
        T.writeMessage oprot ("acceptGroupInvitation", T.M_REPLY, seqid) $
          write_AcceptGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_AcceptGroupInvitation_result{acceptGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("acceptGroupInvitation", T.M_REPLY, seqid) $
          write_AcceptGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acceptGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acceptGroupInvitationByTicket (seqid, iprot, oprot, handler) = do
  args <- read_AcceptGroupInvitationByTicket_args iprot
  (X.catch
    (X.catch
      (do
        Iface.acceptGroupInvitationByTicket handler (acceptGroupInvitationByTicket_args_reqSeq args) (acceptGroupInvitationByTicket_args_GroupMid args) (acceptGroupInvitationByTicket_args_ticketId args)
        let res = default_AcceptGroupInvitationByTicket_result
        T.writeMessage oprot ("acceptGroupInvitationByTicket", T.M_REPLY, seqid) $
          write_AcceptGroupInvitationByTicket_result oprot res)
      (\e  -> do
        let res = default_AcceptGroupInvitationByTicket_result{acceptGroupInvitationByTicket_result_e = P.Just e}
        T.writeMessage oprot ("acceptGroupInvitationByTicket", T.M_REPLY, seqid) $
          write_AcceptGroupInvitationByTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acceptGroupInvitationByTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acceptProximityMatches (seqid, iprot, oprot, handler) = do
  args <- read_AcceptProximityMatches_args iprot
  (X.catch
    (X.catch
      (do
        Iface.acceptProximityMatches handler (acceptProximityMatches_args_sessionId args) (acceptProximityMatches_args_ids args)
        let res = default_AcceptProximityMatches_result
        T.writeMessage oprot ("acceptProximityMatches", T.M_REPLY, seqid) $
          write_AcceptProximityMatches_result oprot res)
      (\e  -> do
        let res = default_AcceptProximityMatches_result{acceptProximityMatches_result_e = P.Just e}
        T.writeMessage oprot ("acceptProximityMatches", T.M_REPLY, seqid) $
          write_AcceptProximityMatches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acceptProximityMatches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquireCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireCallRoute handler (acquireCallRoute_args_to args)
        let res = default_AcquireCallRoute_result{acquireCallRoute_result_success = val}
        T.writeMessage oprot ("acquireCallRoute", T.M_REPLY, seqid) $
          write_AcquireCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquireCallRoute_result{acquireCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquireCallRoute", T.M_REPLY, seqid) $
          write_AcquireCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireCallTicket (seqid, iprot, oprot, handler) = do
  args <- read_AcquireCallTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireCallTicket handler (acquireCallTicket_args_to args)
        let res = default_AcquireCallTicket_result{acquireCallTicket_result_success = val}
        T.writeMessage oprot ("acquireCallTicket", T.M_REPLY, seqid) $
          write_AcquireCallTicket_result oprot res)
      (\e  -> do
        let res = default_AcquireCallTicket_result{acquireCallTicket_result_e = P.Just e}
        T.writeMessage oprot ("acquireCallTicket", T.M_REPLY, seqid) $
          write_AcquireCallTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireCallTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireEncryptedAccessToken (seqid, iprot, oprot, handler) = do
  args <- read_AcquireEncryptedAccessToken_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireEncryptedAccessToken handler (acquireEncryptedAccessToken_args_featureType args)
        let res = default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_success = val}
        T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_REPLY, seqid) $
          write_AcquireEncryptedAccessToken_result oprot res)
      (\e  -> do
        let res = default_AcquireEncryptedAccessToken_result{acquireEncryptedAccessToken_result_e = P.Just e}
        T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_REPLY, seqid) $
          write_AcquireEncryptedAccessToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireEncryptedAccessToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addSnsId (seqid, iprot, oprot, handler) = do
  args <- read_AddSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.addSnsId handler (addSnsId_args_snsIdType args) (addSnsId_args_snsAccessToken args)
        let res = default_AddSnsId_result{addSnsId_result_success = val}
        T.writeMessage oprot ("addSnsId", T.M_REPLY, seqid) $
          write_AddSnsId_result oprot res)
      (\e  -> do
        let res = default_AddSnsId_result{addSnsId_result_e = P.Just e}
        T.writeMessage oprot ("addSnsId", T.M_REPLY, seqid) $
          write_AddSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_blockContact (seqid, iprot, oprot, handler) = do
  args <- read_BlockContact_args iprot
  (X.catch
    (X.catch
      (do
        Iface.blockContact handler (blockContact_args_reqSeq args) (blockContact_args_id args)
        let res = default_BlockContact_result
        T.writeMessage oprot ("blockContact", T.M_REPLY, seqid) $
          write_BlockContact_result oprot res)
      (\e  -> do
        let res = default_BlockContact_result{blockContact_result_e = P.Just e}
        T.writeMessage oprot ("blockContact", T.M_REPLY, seqid) $
          write_BlockContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("blockContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_blockRecommendation (seqid, iprot, oprot, handler) = do
  args <- read_BlockRecommendation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.blockRecommendation handler (blockRecommendation_args_reqSeq args) (blockRecommendation_args_id args)
        let res = default_BlockRecommendation_result
        T.writeMessage oprot ("blockRecommendation", T.M_REPLY, seqid) $
          write_BlockRecommendation_result oprot res)
      (\e  -> do
        let res = default_BlockRecommendation_result{blockRecommendation_result_e = P.Just e}
        T.writeMessage oprot ("blockRecommendation", T.M_REPLY, seqid) $
          write_BlockRecommendation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("blockRecommendation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_cancelGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_CancelGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.cancelGroupInvitation handler (cancelGroupInvitation_args_reqSeq args) (cancelGroupInvitation_args_groupId args) (cancelGroupInvitation_args_contactIds args)
        let res = default_CancelGroupInvitation_result
        T.writeMessage oprot ("cancelGroupInvitation", T.M_REPLY, seqid) $
          write_CancelGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_CancelGroupInvitation_result{cancelGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("cancelGroupInvitation", T.M_REPLY, seqid) $
          write_CancelGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("cancelGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_changeVerificationMethod (seqid, iprot, oprot, handler) = do
  args <- read_ChangeVerificationMethod_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.changeVerificationMethod handler (changeVerificationMethod_args_sessionId args) (changeVerificationMethod_args_method args)
        let res = default_ChangeVerificationMethod_result{changeVerificationMethod_result_success = val}
        T.writeMessage oprot ("changeVerificationMethod", T.M_REPLY, seqid) $
          write_ChangeVerificationMethod_result oprot res)
      (\e  -> do
        let res = default_ChangeVerificationMethod_result{changeVerificationMethod_result_e = P.Just e}
        T.writeMessage oprot ("changeVerificationMethod", T.M_REPLY, seqid) $
          write_ChangeVerificationMethod_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("changeVerificationMethod", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_clearIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_ClearIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.clearIdentityCredential handler
        let res = default_ClearIdentityCredential_result
        T.writeMessage oprot ("clearIdentityCredential", T.M_REPLY, seqid) $
          write_ClearIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_ClearIdentityCredential_result{clearIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("clearIdentityCredential", T.M_REPLY, seqid) $
          write_ClearIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("clearIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_clearMessageBox (seqid, iprot, oprot, handler) = do
  args <- read_ClearMessageBox_args iprot
  (X.catch
    (X.catch
      (do
        Iface.clearMessageBox handler (clearMessageBox_args_channelId args) (clearMessageBox_args_messageBoxId args)
        let res = default_ClearMessageBox_result
        T.writeMessage oprot ("clearMessageBox", T.M_REPLY, seqid) $
          write_ClearMessageBox_result oprot res)
      (\e  -> do
        let res = default_ClearMessageBox_result{clearMessageBox_result_e = P.Just e}
        T.writeMessage oprot ("clearMessageBox", T.M_REPLY, seqid) $
          write_ClearMessageBox_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("clearMessageBox", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_closeProximityMatch (seqid, iprot, oprot, handler) = do
  args <- read_CloseProximityMatch_args iprot
  (X.catch
    (X.catch
      (do
        Iface.closeProximityMatch handler (closeProximityMatch_args_sessionId args)
        let res = default_CloseProximityMatch_result
        T.writeMessage oprot ("closeProximityMatch", T.M_REPLY, seqid) $
          write_CloseProximityMatch_result oprot res)
      (\e  -> do
        let res = default_CloseProximityMatch_result{closeProximityMatch_result_e = P.Just e}
        T.writeMessage oprot ("closeProximityMatch", T.M_REPLY, seqid) $
          write_CloseProximityMatch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("closeProximityMatch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitSendMessage (seqid, iprot, oprot, handler) = do
  args <- read_CommitSendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitSendMessage handler (commitSendMessage_args_seq args) (commitSendMessage_args_messageId args) (commitSendMessage_args_receiverMids args)
        let res = default_CommitSendMessage_result{commitSendMessage_result_success = val}
        T.writeMessage oprot ("commitSendMessage", T.M_REPLY, seqid) $
          write_CommitSendMessage_result oprot res)
      (\e  -> do
        let res = default_CommitSendMessage_result{commitSendMessage_result_e = P.Just e}
        T.writeMessage oprot ("commitSendMessage", T.M_REPLY, seqid) $
          write_CommitSendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitSendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitSendMessages (seqid, iprot, oprot, handler) = do
  args <- read_CommitSendMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitSendMessages handler (commitSendMessages_args_seq args) (commitSendMessages_args_messageIds args) (commitSendMessages_args_receiverMids args)
        let res = default_CommitSendMessages_result{commitSendMessages_result_success = val}
        T.writeMessage oprot ("commitSendMessages", T.M_REPLY, seqid) $
          write_CommitSendMessages_result oprot res)
      (\e  -> do
        let res = default_CommitSendMessages_result{commitSendMessages_result_e = P.Just e}
        T.writeMessage oprot ("commitSendMessages", T.M_REPLY, seqid) $
          write_CommitSendMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitSendMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_commitUpdateProfile (seqid, iprot, oprot, handler) = do
  args <- read_CommitUpdateProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.commitUpdateProfile handler (commitUpdateProfile_args_seq args) (commitUpdateProfile_args_attrs args) (commitUpdateProfile_args_receiverMids args)
        let res = default_CommitUpdateProfile_result{commitUpdateProfile_result_success = val}
        T.writeMessage oprot ("commitUpdateProfile", T.M_REPLY, seqid) $
          write_CommitUpdateProfile_result oprot res)
      (\e  -> do
        let res = default_CommitUpdateProfile_result{commitUpdateProfile_result_e = P.Just e}
        T.writeMessage oprot ("commitUpdateProfile", T.M_REPLY, seqid) $
          write_CommitUpdateProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("commitUpdateProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_confirmEmail (seqid, iprot, oprot, handler) = do
  args <- read_ConfirmEmail_args iprot
  (X.catch
    (X.catch
      (do
        Iface.confirmEmail handler (confirmEmail_args_verifier args) (confirmEmail_args_pinCode args)
        let res = default_ConfirmEmail_result
        T.writeMessage oprot ("confirmEmail", T.M_REPLY, seqid) $
          write_ConfirmEmail_result oprot res)
      (\e  -> do
        let res = default_ConfirmEmail_result{confirmEmail_result_e = P.Just e}
        T.writeMessage oprot ("confirmEmail", T.M_REPLY, seqid) $
          write_ConfirmEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("confirmEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createGroup (seqid, iprot, oprot, handler) = do
  args <- read_CreateGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createGroup handler (createGroup_args_seq args) (createGroup_args_name args) (createGroup_args_contactIds args)
        let res = default_CreateGroup_result{createGroup_result_success = val}
        T.writeMessage oprot ("createGroup", T.M_REPLY, seqid) $
          write_CreateGroup_result oprot res)
      (\e  -> do
        let res = default_CreateGroup_result{createGroup_result_e = P.Just e}
        T.writeMessage oprot ("createGroup", T.M_REPLY, seqid) $
          write_CreateGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createQrcodeBase64Image (seqid, iprot, oprot, handler) = do
  args <- read_CreateQrcodeBase64Image_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createQrcodeBase64Image handler (createQrcodeBase64Image_args_url args) (createQrcodeBase64Image_args_characterSet args) (createQrcodeBase64Image_args_imageSize args) (createQrcodeBase64Image_args_x args) (createQrcodeBase64Image_args_y args) (createQrcodeBase64Image_args_width args) (createQrcodeBase64Image_args_height args)
        let res = default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_success = val}
        T.writeMessage oprot ("createQrcodeBase64Image", T.M_REPLY, seqid) $
          write_CreateQrcodeBase64Image_result oprot res)
      (\e  -> do
        let res = default_CreateQrcodeBase64Image_result{createQrcodeBase64Image_result_e = P.Just e}
        T.writeMessage oprot ("createQrcodeBase64Image", T.M_REPLY, seqid) $
          write_CreateQrcodeBase64Image_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createQrcodeBase64Image", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createRoom (seqid, iprot, oprot, handler) = do
  args <- read_CreateRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createRoom handler (createRoom_args_reqSeq args) (createRoom_args_contactIds args)
        let res = default_CreateRoom_result{createRoom_result_success = val}
        T.writeMessage oprot ("createRoom", T.M_REPLY, seqid) $
          write_CreateRoom_result oprot res)
      (\e  -> do
        let res = default_CreateRoom_result{createRoom_result_e = P.Just e}
        T.writeMessage oprot ("createRoom", T.M_REPLY, seqid) $
          write_CreateRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSession (seqid, iprot, oprot, handler) = do
  args <- read_CreateSession_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createSession handler
        let res = default_CreateSession_result{createSession_result_success = val}
        T.writeMessage oprot ("createSession", T.M_REPLY, seqid) $
          write_CreateSession_result oprot res)
      (\e  -> do
        let res = default_CreateSession_result{createSession_result_e = P.Just e}
        T.writeMessage oprot ("createSession", T.M_REPLY, seqid) $
          write_CreateSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchAnnouncements (seqid, iprot, oprot, handler) = do
  args <- read_FetchAnnouncements_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchAnnouncements handler (fetchAnnouncements_args_lastFetchedIndex args)
        let res = default_FetchAnnouncements_result{fetchAnnouncements_result_success = val}
        T.writeMessage oprot ("fetchAnnouncements", T.M_REPLY, seqid) $
          write_FetchAnnouncements_result oprot res)
      (\e  -> do
        let res = default_FetchAnnouncements_result{fetchAnnouncements_result_e = P.Just e}
        T.writeMessage oprot ("fetchAnnouncements", T.M_REPLY, seqid) $
          write_FetchAnnouncements_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchAnnouncements", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchMessages (seqid, iprot, oprot, handler) = do
  args <- read_FetchMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchMessages handler (fetchMessages_args_localTs args) (fetchMessages_args_count args)
        let res = default_FetchMessages_result{fetchMessages_result_success = val}
        T.writeMessage oprot ("fetchMessages", T.M_REPLY, seqid) $
          write_FetchMessages_result oprot res)
      (\e  -> do
        let res = default_FetchMessages_result{fetchMessages_result_e = P.Just e}
        T.writeMessage oprot ("fetchMessages", T.M_REPLY, seqid) $
          write_FetchMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchOperations (seqid, iprot, oprot, handler) = do
  args <- read_FetchOperations_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchOperations handler (fetchOperations_args_localRev args) (fetchOperations_args_count args)
        let res = default_FetchOperations_result{fetchOperations_result_success = val}
        T.writeMessage oprot ("fetchOperations", T.M_REPLY, seqid) $
          write_FetchOperations_result oprot res)
      (\e  -> do
        let res = default_FetchOperations_result{fetchOperations_result_e = P.Just e}
        T.writeMessage oprot ("fetchOperations", T.M_REPLY, seqid) $
          write_FetchOperations_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchOperations", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_fetchOps (seqid, iprot, oprot, handler) = do
  args <- read_FetchOps_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.fetchOps handler (fetchOps_args_localRev args) (fetchOps_args_count args) (fetchOps_args_globalRev args) (fetchOps_args_individualRev args)
        let res = default_FetchOps_result{fetchOps_result_success = val}
        T.writeMessage oprot ("fetchOps", T.M_REPLY, seqid) $
          write_FetchOps_result oprot res)
      (\e  -> do
        let res = default_FetchOps_result{fetchOps_result_e = P.Just e}
        T.writeMessage oprot ("fetchOps", T.M_REPLY, seqid) $
          write_FetchOps_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("fetchOps", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByEmail (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByEmail_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByEmail handler (findAndAddContactsByEmail_args_reqSeq args) (findAndAddContactsByEmail_args_emails args)
        let res = default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByEmail", T.M_REPLY, seqid) $
          write_FindAndAddContactsByEmail_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByEmail_result{findAndAddContactsByEmail_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByEmail", T.M_REPLY, seqid) $
          write_FindAndAddContactsByEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByMid (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByMid handler (findAndAddContactsByMid_args_reqSeq args) (findAndAddContactsByMid_args_mid args) (findAndAddContactsByMid_args_type args) (findAndAddContactsByMid_args_reference args)
        let res = default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByMid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByMid_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByMid_result{findAndAddContactsByMid_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByMid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findGroupByTicketV2 (seqid, iprot, oprot, handler) = do
  args <- read_FindGroupByTicketV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findGroupByTicketV2 handler (findGroupByTicketV2_args_ticketId args)
        let res = default_FindGroupByTicketV2_result{findGroupByTicketV2_result_success = val}
        T.writeMessage oprot ("findGroupByTicketV2", T.M_REPLY, seqid) $
          write_FindGroupByTicketV2_result oprot res)
      (\e  -> do
        let res = default_FindGroupByTicketV2_result{findGroupByTicketV2_result_e = P.Just e}
        T.writeMessage oprot ("findGroupByTicketV2", T.M_REPLY, seqid) $
          write_FindGroupByTicketV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findGroupByTicketV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByPhone (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByPhone handler (findAndAddContactsByPhone_args_reqSeq args) (findAndAddContactsByPhone_args_phones args)
        let res = default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByPhone", T.M_REPLY, seqid) $
          write_FindAndAddContactsByPhone_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByPhone_result{findAndAddContactsByPhone_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByPhone", T.M_REPLY, seqid) $
          write_FindAndAddContactsByPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendRequests (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendRequests_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendRequests handler (getFriendRequests_args_direction args) (getFriendRequests_args_lastSeenSeqId args)
        let res = default_GetFriendRequests_result{getFriendRequests_result_success = val}
        T.writeMessage oprot ("getFriendRequests", T.M_REPLY, seqid) $
          write_GetFriendRequests_result oprot res)
      (\e  -> do
        let res = default_GetFriendRequests_result{getFriendRequests_result_e = P.Just e}
        T.writeMessage oprot ("getFriendRequests", T.M_REPLY, seqid) $
          write_GetFriendRequests_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendRequests", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeFriendRequest (seqid, iprot, oprot, handler) = do
  args <- read_RemoveFriendRequest_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeFriendRequest handler (removeFriendRequest_args_direction args) (removeFriendRequest_args_midOrEMid args)
        let res = default_RemoveFriendRequest_result
        T.writeMessage oprot ("removeFriendRequest", T.M_REPLY, seqid) $
          write_RemoveFriendRequest_result oprot res)
      (\e  -> do
        let res = default_RemoveFriendRequest_result{removeFriendRequest_result_e = P.Just e}
        T.writeMessage oprot ("removeFriendRequest", T.M_REPLY, seqid) $
          write_RemoveFriendRequest_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeFriendRequest", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactsByUserid (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactsByUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactsByUserid handler (findAndAddContactsByUserid_args_reqSeq args) (findAndAddContactsByUserid_args_userid args)
        let res = default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_success = val}
        T.writeMessage oprot ("findAndAddContactsByUserid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByUserid_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactsByUserid_result{findAndAddContactsByUserid_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactsByUserid", T.M_REPLY, seqid) $
          write_FindAndAddContactsByUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactsByUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUserid (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUserid handler (findContactByUserid_args_userid args)
        let res = default_FindContactByUserid_result{findContactByUserid_result_success = val}
        T.writeMessage oprot ("findContactByUserid", T.M_REPLY, seqid) $
          write_FindContactByUserid_result oprot res)
      (\e  -> do
        let res = default_FindContactByUserid_result{findContactByUserid_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUserid", T.M_REPLY, seqid) $
          write_FindContactByUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUserTicket handler (findContactByUserTicket_args_ticketIdWithTag args)
        let res = default_FindContactByUserTicket_result{findContactByUserTicket_result_success = val}
        T.writeMessage oprot ("findContactByUserTicket", T.M_REPLY, seqid) $
          write_FindContactByUserTicket_result oprot res)
      (\e  -> do
        let res = default_FindContactByUserTicket_result{findContactByUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUserTicket", T.M_REPLY, seqid) $
          write_FindContactByUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactsByEmail (seqid, iprot, oprot, handler) = do
  args <- read_FindContactsByEmail_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactsByEmail handler (findContactsByEmail_args_emails args)
        let res = default_FindContactsByEmail_result{findContactsByEmail_result_success = val}
        T.writeMessage oprot ("findContactsByEmail", T.M_REPLY, seqid) $
          write_FindContactsByEmail_result oprot res)
      (\e  -> do
        let res = default_FindContactsByEmail_result{findContactsByEmail_result_e = P.Just e}
        T.writeMessage oprot ("findContactsByEmail", T.M_REPLY, seqid) $
          write_FindContactsByEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactsByEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactsByPhone (seqid, iprot, oprot, handler) = do
  args <- read_FindContactsByPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactsByPhone handler (findContactsByPhone_args_phones args)
        let res = default_FindContactsByPhone_result{findContactsByPhone_result_success = val}
        T.writeMessage oprot ("findContactsByPhone", T.M_REPLY, seqid) $
          write_FindContactsByPhone_result oprot res)
      (\e  -> do
        let res = default_FindContactsByPhone_result{findContactsByPhone_result_e = P.Just e}
        T.writeMessage oprot ("findContactsByPhone", T.M_REPLY, seqid) $
          write_FindContactsByPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactsByPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findSnsIdUserStatus (seqid, iprot, oprot, handler) = do
  args <- read_FindSnsIdUserStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findSnsIdUserStatus handler (findSnsIdUserStatus_args_snsIdType args) (findSnsIdUserStatus_args_snsAccessToken args) (findSnsIdUserStatus_args_udidHash args)
        let res = default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_success = val}
        T.writeMessage oprot ("findSnsIdUserStatus", T.M_REPLY, seqid) $
          write_FindSnsIdUserStatus_result oprot res)
      (\e  -> do
        let res = default_FindSnsIdUserStatus_result{findSnsIdUserStatus_result_e = P.Just e}
        T.writeMessage oprot ("findSnsIdUserStatus", T.M_REPLY, seqid) $
          write_FindSnsIdUserStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findSnsIdUserStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_finishUpdateVerification (seqid, iprot, oprot, handler) = do
  args <- read_FinishUpdateVerification_args iprot
  (X.catch
    (X.catch
      (do
        Iface.finishUpdateVerification handler (finishUpdateVerification_args_sessionId args)
        let res = default_FinishUpdateVerification_result
        T.writeMessage oprot ("finishUpdateVerification", T.M_REPLY, seqid) $
          write_FinishUpdateVerification_result oprot res)
      (\e  -> do
        let res = default_FinishUpdateVerification_result{finishUpdateVerification_result_e = P.Just e}
        T.writeMessage oprot ("finishUpdateVerification", T.M_REPLY, seqid) $
          write_FinishUpdateVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("finishUpdateVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_generateUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_GenerateUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.generateUserTicket handler (generateUserTicket_args_expirationTime args) (generateUserTicket_args_maxUseCount args)
        let res = default_GenerateUserTicket_result{generateUserTicket_result_success = val}
        T.writeMessage oprot ("generateUserTicket", T.M_REPLY, seqid) $
          write_GenerateUserTicket_result oprot res)
      (\e  -> do
        let res = default_GenerateUserTicket_result{generateUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("generateUserTicket", T.M_REPLY, seqid) $
          write_GenerateUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("generateUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_destroyMessage (seqid, iprot, oprot, handler) = do
  args <- read_DestroyMessage_args iprot
  (X.catch
    (X.catch
      (do
        Iface.destroyMessage handler (destroyMessage_args_seq args) (destroyMessage_args_chatId args) (destroyMessage_args_messageId args) (destroyMessage_args_sessionId args)
        let res = default_DestroyMessage_result
        T.writeMessage oprot ("destroyMessage", T.M_REPLY, seqid) $
          write_DestroyMessage_result oprot res)
      (\e  -> do
        let res = default_DestroyMessage_result{destroyMessage_result_e = P.Just e}
        T.writeMessage oprot ("destroyMessage", T.M_REPLY, seqid) $
          write_DestroyMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("destroyMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAcceptedProximityMatches (seqid, iprot, oprot, handler) = do
  args <- read_GetAcceptedProximityMatches_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAcceptedProximityMatches handler (getAcceptedProximityMatches_args_sessionId args)
        let res = default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_success = val}
        T.writeMessage oprot ("getAcceptedProximityMatches", T.M_REPLY, seqid) $
          write_GetAcceptedProximityMatches_result oprot res)
      (\e  -> do
        let res = default_GetAcceptedProximityMatches_result{getAcceptedProximityMatches_result_e = P.Just e}
        T.writeMessage oprot ("getAcceptedProximityMatches", T.M_REPLY, seqid) $
          write_GetAcceptedProximityMatches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAcceptedProximityMatches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getActiveBuddySubscriberIds (seqid, iprot, oprot, handler) = do
  args <- read_GetActiveBuddySubscriberIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getActiveBuddySubscriberIds handler
        let res = default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_success = val}
        T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_REPLY, seqid) $
          write_GetActiveBuddySubscriberIds_result oprot res)
      (\e  -> do
        let res = default_GetActiveBuddySubscriberIds_result{getActiveBuddySubscriberIds_result_e = P.Just e}
        T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_REPLY, seqid) $
          write_GetActiveBuddySubscriberIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getActiveBuddySubscriberIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIds (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIds handler
        let res = default_GetAllContactIds_result{getAllContactIds_result_success = val}
        T.writeMessage oprot ("getAllContactIds", T.M_REPLY, seqid) $
          write_GetAllContactIds_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIds_result{getAllContactIds_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIds", T.M_REPLY, seqid) $
          write_GetAllContactIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAuthQrcode (seqid, iprot, oprot, handler) = do
  args <- read_GetAuthQrcode_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAuthQrcode handler (getAuthQrcode_args_keepLoggedIn args) (getAuthQrcode_args_systemName args)
        let res = default_GetAuthQrcode_result{getAuthQrcode_result_success = val}
        T.writeMessage oprot ("getAuthQrcode", T.M_REPLY, seqid) $
          write_GetAuthQrcode_result oprot res)
      (\e  -> do
        let res = default_GetAuthQrcode_result{getAuthQrcode_result_e = P.Just e}
        T.writeMessage oprot ("getAuthQrcode", T.M_REPLY, seqid) $
          write_GetAuthQrcode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAuthQrcode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedContactIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedContactIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedContactIds handler
        let res = default_GetBlockedContactIds_result{getBlockedContactIds_result_success = val}
        T.writeMessage oprot ("getBlockedContactIds", T.M_REPLY, seqid) $
          write_GetBlockedContactIds_result oprot res)
      (\e  -> do
        let res = default_GetBlockedContactIds_result{getBlockedContactIds_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedContactIds", T.M_REPLY, seqid) $
          write_GetBlockedContactIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedContactIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithPhoneNumber handler (registerWithPhoneNumber_args_sessionId args) (registerWithPhoneNumber_args_migrationPincodeSessionId args)
        let res = default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_success = val}
        T.writeMessage oprot ("registerWithPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterWithPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_RegisterWithPhoneNumber_result{registerWithPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("registerWithPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterWithPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithPhoneNumberAndPassword (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithPhoneNumberAndPassword_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithPhoneNumberAndPassword handler (registerWithPhoneNumberAndPassword_args_sessionId args) (registerWithPhoneNumberAndPassword_args_keynm args) (registerWithPhoneNumberAndPassword_args_encrypted args)
        let res = default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_success = val}
        T.writeMessage oprot ("registerWithPhoneNumberAndPassword", T.M_REPLY, seqid) $
          write_RegisterWithPhoneNumberAndPassword_result oprot res)
      (\e  -> do
        let res = default_RegisterWithPhoneNumberAndPassword_result{registerWithPhoneNumberAndPassword_result_e = P.Just e}
        T.writeMessage oprot ("registerWithPhoneNumberAndPassword", T.M_REPLY, seqid) $
          write_RegisterWithPhoneNumberAndPassword_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithPhoneNumberAndPassword", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAnalyticsInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetAnalyticsInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAnalyticsInfo handler
        let res = default_GetAnalyticsInfo_result{getAnalyticsInfo_result_success = val}
        T.writeMessage oprot ("getAnalyticsInfo", T.M_REPLY, seqid) $
          write_GetAnalyticsInfo_result oprot res)
      (\e  -> do
        let res = default_GetAnalyticsInfo_result{getAnalyticsInfo_result_e = P.Just e}
        T.writeMessage oprot ("getAnalyticsInfo", T.M_REPLY, seqid) $
          write_GetAnalyticsInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAnalyticsInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportClientStatistics (seqid, iprot, oprot, handler) = do
  args <- read_ReportClientStatistics_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportClientStatistics handler (reportClientStatistics_args_reqSeq args) (reportClientStatistics_args_category args) (reportClientStatistics_args_count args)
        let res = default_ReportClientStatistics_result
        T.writeMessage oprot ("reportClientStatistics", T.M_REPLY, seqid) $
          write_ReportClientStatistics_result oprot res)
      (\e  -> do
        let res = default_ReportClientStatistics_result{reportClientStatistics_result_e = P.Just e}
        T.writeMessage oprot ("reportClientStatistics", T.M_REPLY, seqid) $
          write_ReportClientStatistics_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportClientStatistics", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyPhoneNumberForLogin (seqid, iprot, oprot, handler) = do
  args <- read_VerifyPhoneNumberForLogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyPhoneNumberForLogin handler (verifyPhoneNumberForLogin_args_verifierFromPhone args) (verifyPhoneNumberForLogin_args_pinCodeForPhone args) (verifyPhoneNumberForLogin_args_verifierFromLogin args)
        let res = default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_success = val}
        T.writeMessage oprot ("verifyPhoneNumberForLogin", T.M_REPLY, seqid) $
          write_VerifyPhoneNumberForLogin_result oprot res)
      (\e  -> do
        let res = default_VerifyPhoneNumberForLogin_result{verifyPhoneNumberForLogin_result_e = P.Just e}
        T.writeMessage oprot ("verifyPhoneNumberForLogin", T.M_REPLY, seqid) $
          write_VerifyPhoneNumberForLogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyPhoneNumberForLogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_VerifyPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyPhoneNumber handler (verifyPhoneNumber_args_sessionId args) (verifyPhoneNumber_args_pinCode args) (verifyPhoneNumber_args_udidHash args) (verifyPhoneNumber_args_migrationPincodeSessionId args) (verifyPhoneNumber_args_oldUdidHash args)
        let res = default_VerifyPhoneNumber_result{verifyPhoneNumber_result_success = val}
        T.writeMessage oprot ("verifyPhoneNumber", T.M_REPLY, seqid) $
          write_VerifyPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_VerifyPhoneNumber_result{verifyPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("verifyPhoneNumber", T.M_REPLY, seqid) $
          write_VerifyPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedContactIdsByRange (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedContactIdsByRange_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedContactIdsByRange handler (getBlockedContactIdsByRange_args_start args) (getBlockedContactIdsByRange_args_count args)
        let res = default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_success = val}
        T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_REPLY, seqid) $
          write_GetBlockedContactIdsByRange_result oprot res)
      (\e  -> do
        let res = default_GetBlockedContactIdsByRange_result{getBlockedContactIdsByRange_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_REPLY, seqid) $
          write_GetBlockedContactIdsByRange_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedContactIdsByRange", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBlockedRecommendationIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBlockedRecommendationIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBlockedRecommendationIds handler
        let res = default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_success = val}
        T.writeMessage oprot ("getBlockedRecommendationIds", T.M_REPLY, seqid) $
          write_GetBlockedRecommendationIds_result oprot res)
      (\e  -> do
        let res = default_GetBlockedRecommendationIds_result{getBlockedRecommendationIds_result_e = P.Just e}
        T.writeMessage oprot ("getBlockedRecommendationIds", T.M_REPLY, seqid) $
          write_GetBlockedRecommendationIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBlockedRecommendationIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBuddyBlockerIds (seqid, iprot, oprot, handler) = do
  args <- read_GetBuddyBlockerIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBuddyBlockerIds handler
        let res = default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_success = val}
        T.writeMessage oprot ("getBuddyBlockerIds", T.M_REPLY, seqid) $
          write_GetBuddyBlockerIds_result oprot res)
      (\e  -> do
        let res = default_GetBuddyBlockerIds_result{getBuddyBlockerIds_result_e = P.Just e}
        T.writeMessage oprot ("getBuddyBlockerIds", T.M_REPLY, seqid) $
          write_GetBuddyBlockerIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBuddyBlockerIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_GetBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getBuddyLocation handler (getBuddyLocation_args_mid args) (getBuddyLocation_args_index args)
        let res = default_GetBuddyLocation_result{getBuddyLocation_result_success = val}
        T.writeMessage oprot ("getBuddyLocation", T.M_REPLY, seqid) $
          write_GetBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_GetBuddyLocation_result{getBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("getBuddyLocation", T.M_REPLY, seqid) $
          write_GetBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContactsModifiedSince (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContactsModifiedSince_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContactsModifiedSince handler (getCompactContactsModifiedSince_args_timestamp args)
        let res = default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_success = val}
        T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_REPLY, seqid) $
          write_GetCompactContactsModifiedSince_result oprot res)
      (\e  -> do
        let res = default_GetCompactContactsModifiedSince_result{getCompactContactsModifiedSince_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_REPLY, seqid) $
          write_GetCompactContactsModifiedSince_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContactsModifiedSince", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactGroup (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactGroup handler (getCompactGroup_args_groupId args)
        let res = default_GetCompactGroup_result{getCompactGroup_result_success = val}
        T.writeMessage oprot ("getCompactGroup", T.M_REPLY, seqid) $
          write_GetCompactGroup_result oprot res)
      (\e  -> do
        let res = default_GetCompactGroup_result{getCompactGroup_result_e = P.Just e}
        T.writeMessage oprot ("getCompactGroup", T.M_REPLY, seqid) $
          write_GetCompactGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactRoom (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactRoom handler (getCompactRoom_args_roomId args)
        let res = default_GetCompactRoom_result{getCompactRoom_result_success = val}
        T.writeMessage oprot ("getCompactRoom", T.M_REPLY, seqid) $
          write_GetCompactRoom_result oprot res)
      (\e  -> do
        let res = default_GetCompactRoom_result{getCompactRoom_result_e = P.Just e}
        T.writeMessage oprot ("getCompactRoom", T.M_REPLY, seqid) $
          write_GetCompactRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContact (seqid, iprot, oprot, handler) = do
  args <- read_GetContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContact handler (getContact_args_id args)
        let res = default_GetContact_result{getContact_result_success = val}
        T.writeMessage oprot ("getContact", T.M_REPLY, seqid) $
          write_GetContact_result oprot res)
      (\e  -> do
        let res = default_GetContact_result{getContact_result_e = P.Just e}
        T.writeMessage oprot ("getContact", T.M_REPLY, seqid) $
          write_GetContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContacts handler (getContacts_args_ids args)
        let res = default_GetContacts_result{getContacts_result_success = val}
        T.writeMessage oprot ("getContacts", T.M_REPLY, seqid) $
          write_GetContacts_result oprot res)
      (\e  -> do
        let res = default_GetContacts_result{getContacts_result_e = P.Just e}
        T.writeMessage oprot ("getContacts", T.M_REPLY, seqid) $
          write_GetContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContactWithFriendRequestStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetContactWithFriendRequestStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContactWithFriendRequestStatus handler (getContactWithFriendRequestStatus_args_id args)
        let res = default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_success = val}
        T.writeMessage oprot ("getContactWithFriendRequestStatus", T.M_REPLY, seqid) $
          write_GetContactWithFriendRequestStatus_result oprot res)
      (\e  -> do
        let res = default_GetContactWithFriendRequestStatus_result{getContactWithFriendRequestStatus_result_e = P.Just e}
        T.writeMessage oprot ("getContactWithFriendRequestStatus", T.M_REPLY, seqid) $
          write_GetContactWithFriendRequestStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContactWithFriendRequestStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCountryWithRequestIp (seqid, iprot, oprot, handler) = do
  args <- read_GetCountryWithRequestIp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCountryWithRequestIp handler
        let res = default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_success = val}
        T.writeMessage oprot ("getCountryWithRequestIp", T.M_REPLY, seqid) $
          write_GetCountryWithRequestIp_result oprot res)
      (\e  -> do
        let res = default_GetCountryWithRequestIp_result{getCountryWithRequestIp_result_e = P.Just e}
        T.writeMessage oprot ("getCountryWithRequestIp", T.M_REPLY, seqid) $
          write_GetCountryWithRequestIp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCountryWithRequestIp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMids handler
        let res = default_GetFavoriteMids_result{getFavoriteMids_result_success = val}
        T.writeMessage oprot ("getFavoriteMids", T.M_REPLY, seqid) $
          write_GetFavoriteMids_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMids_result{getFavoriteMids_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMids", T.M_REPLY, seqid) $
          write_GetFavoriteMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroup (seqid, iprot, oprot, handler) = do
  args <- read_GetGroup_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroup handler (getGroup_args_groupId args)
        let res = default_GetGroup_result{getGroup_result_success = val}
        T.writeMessage oprot ("getGroup", T.M_REPLY, seqid) $
          write_GetGroup_result oprot res)
      (\e  -> do
        let res = default_GetGroup_result{getGroup_result_e = P.Just e}
        T.writeMessage oprot ("getGroup", T.M_REPLY, seqid) $
          write_GetGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupIdsInvited (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupIdsInvited_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupIdsInvited handler
        let res = default_GetGroupIdsInvited_result{getGroupIdsInvited_result_success = val}
        T.writeMessage oprot ("getGroupIdsInvited", T.M_REPLY, seqid) $
          write_GetGroupIdsInvited_result oprot res)
      (\e  -> do
        let res = default_GetGroupIdsInvited_result{getGroupIdsInvited_result_e = P.Just e}
        T.writeMessage oprot ("getGroupIdsInvited", T.M_REPLY, seqid) $
          write_GetGroupIdsInvited_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupIdsInvited", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupIdsJoined (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupIdsJoined_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupIdsJoined handler
        let res = default_GetGroupIdsJoined_result{getGroupIdsJoined_result_success = val}
        T.writeMessage oprot ("getGroupIdsJoined", T.M_REPLY, seqid) $
          write_GetGroupIdsJoined_result oprot res)
      (\e  -> do
        let res = default_GetGroupIdsJoined_result{getGroupIdsJoined_result_e = P.Just e}
        T.writeMessage oprot ("getGroupIdsJoined", T.M_REPLY, seqid) $
          write_GetGroupIdsJoined_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupIdsJoined", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroups (seqid, iprot, oprot, handler) = do
  args <- read_GetGroups_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroups handler (getGroups_args_groupIds args)
        let res = default_GetGroups_result{getGroups_result_success = val}
        T.writeMessage oprot ("getGroups", T.M_REPLY, seqid) $
          write_GetGroups_result oprot res)
      (\e  -> do
        let res = default_GetGroups_result{getGroups_result_e = P.Just e}
        T.writeMessage oprot ("getGroups", T.M_REPLY, seqid) $
          write_GetGroups_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroups", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getHiddenContactMids (seqid, iprot, oprot, handler) = do
  args <- read_GetHiddenContactMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getHiddenContactMids handler
        let res = default_GetHiddenContactMids_result{getHiddenContactMids_result_success = val}
        T.writeMessage oprot ("getHiddenContactMids", T.M_REPLY, seqid) $
          write_GetHiddenContactMids_result oprot res)
      (\e  -> do
        let res = default_GetHiddenContactMids_result{getHiddenContactMids_result_e = P.Just e}
        T.writeMessage oprot ("getHiddenContactMids", T.M_REPLY, seqid) $
          write_GetHiddenContactMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getHiddenContactMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityIdentifier (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityIdentifier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityIdentifier handler
        let res = default_GetIdentityIdentifier_result{getIdentityIdentifier_result_success = val}
        T.writeMessage oprot ("getIdentityIdentifier", T.M_REPLY, seqid) $
          write_GetIdentityIdentifier_result oprot res)
      (\e  -> do
        let res = default_GetIdentityIdentifier_result{getIdentityIdentifier_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityIdentifier", T.M_REPLY, seqid) $
          write_GetIdentityIdentifier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityIdentifier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastAnnouncementIndex (seqid, iprot, oprot, handler) = do
  args <- read_GetLastAnnouncementIndex_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastAnnouncementIndex handler
        let res = default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_success = val}
        T.writeMessage oprot ("getLastAnnouncementIndex", T.M_REPLY, seqid) $
          write_GetLastAnnouncementIndex_result oprot res)
      (\e  -> do
        let res = default_GetLastAnnouncementIndex_result{getLastAnnouncementIndex_result_e = P.Just e}
        T.writeMessage oprot ("getLastAnnouncementIndex", T.M_REPLY, seqid) $
          write_GetLastAnnouncementIndex_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastAnnouncementIndex", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastOpRevision (seqid, iprot, oprot, handler) = do
  args <- read_GetLastOpRevision_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastOpRevision handler
        let res = default_GetLastOpRevision_result{getLastOpRevision_result_success = val}
        T.writeMessage oprot ("getLastOpRevision", T.M_REPLY, seqid) $
          write_GetLastOpRevision_result oprot res)
      (\e  -> do
        let res = default_GetLastOpRevision_result{getLastOpRevision_result_e = P.Just e}
        T.writeMessage oprot ("getLastOpRevision", T.M_REPLY, seqid) $
          write_GetLastOpRevision_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastOpRevision", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSuggestRevisions (seqid, iprot, oprot, handler) = do
  args <- read_GetSuggestRevisions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSuggestRevisions handler
        let res = default_GetSuggestRevisions_result{getSuggestRevisions_result_success = val}
        T.writeMessage oprot ("getSuggestRevisions", T.M_REPLY, seqid) $
          write_GetSuggestRevisions_result oprot res)
      (\e  -> do
        let res = default_GetSuggestRevisions_result{getSuggestRevisions_result_e = P.Just e}
        T.writeMessage oprot ("getSuggestRevisions", T.M_REPLY, seqid) $
          write_GetSuggestRevisions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSuggestRevisions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPreviousMessagesV2WithReadCount (seqid, iprot, oprot, handler) = do
  args <- read_GetPreviousMessagesV2WithReadCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPreviousMessagesV2WithReadCount handler (getPreviousMessagesV2WithReadCount_args_messageBoxId args) (getPreviousMessagesV2WithReadCount_args_endMessageId args) (getPreviousMessagesV2WithReadCount_args_messagesCount args)
        let res = default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_success = val}
        T.writeMessage oprot ("getPreviousMessagesV2WithReadCount", T.M_REPLY, seqid) $
          write_GetPreviousMessagesV2WithReadCount_result oprot res)
      (\e  -> do
        let res = default_GetPreviousMessagesV2WithReadCount_result{getPreviousMessagesV2WithReadCount_result_e = P.Just e}
        T.writeMessage oprot ("getPreviousMessagesV2WithReadCount", T.M_REPLY, seqid) $
          write_GetPreviousMessagesV2WithReadCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPreviousMessagesV2WithReadCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBox (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBox_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBox handler (getMessageBox_args_channelId args) (getMessageBox_args_messageBoxId args) (getMessageBox_args_lastMessagesCount args)
        let res = default_GetMessageBox_result{getMessageBox_result_success = val}
        T.writeMessage oprot ("getMessageBox", T.M_REPLY, seqid) $
          write_GetMessageBox_result oprot res)
      (\e  -> do
        let res = default_GetMessageBox_result{getMessageBox_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBox", T.M_REPLY, seqid) $
          write_GetMessageBox_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBox", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxCompactWrapUp (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxCompactWrapUp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxCompactWrapUp handler (getMessageBoxCompactWrapUp_args_mid args)
        let res = default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_success = val}
        T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUp_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxCompactWrapUp_result{getMessageBoxCompactWrapUp_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxCompactWrapUp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxCompactWrapUpList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxCompactWrapUpList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxCompactWrapUpList handler (getMessageBoxCompactWrapUpList_args_start args) (getMessageBoxCompactWrapUpList_args_messageBoxCount args)
        let res = default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_success = val}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxCompactWrapUpList_result{getMessageBoxCompactWrapUpList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxCompactWrapUpList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxList handler (getMessageBoxList_args_channelId args) (getMessageBoxList_args_lastMessagesCount args)
        let res = default_GetMessageBoxList_result{getMessageBoxList_result_success = val}
        T.writeMessage oprot ("getMessageBoxList", T.M_REPLY, seqid) $
          write_GetMessageBoxList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxList_result{getMessageBoxList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxList", T.M_REPLY, seqid) $
          write_GetMessageBoxList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxListByStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxListByStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxListByStatus handler (getMessageBoxListByStatus_args_channelId args) (getMessageBoxListByStatus_args_lastMessagesCount args) (getMessageBoxListByStatus_args_status args)
        let res = default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_success = val}
        T.writeMessage oprot ("getMessageBoxListByStatus", T.M_REPLY, seqid) $
          write_GetMessageBoxListByStatus_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxListByStatus_result{getMessageBoxListByStatus_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxListByStatus", T.M_REPLY, seqid) $
          write_GetMessageBoxListByStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxListByStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxWrapUp (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxWrapUp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxWrapUp handler (getMessageBoxWrapUp_args_mid args)
        let res = default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_success = val}
        T.writeMessage oprot ("getMessageBoxWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUp_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxWrapUp_result{getMessageBoxWrapUp_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxWrapUp", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxWrapUp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxWrapUpList (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxWrapUpList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxWrapUpList handler (getMessageBoxWrapUpList_args_start args) (getMessageBoxWrapUpList_args_messageBoxCount args)
        let res = default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_success = val}
        T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUpList_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxWrapUpList_result{getMessageBoxWrapUpList_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_REPLY, seqid) $
          write_GetMessageBoxWrapUpList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxWrapUpList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessagesBySequenceNumber (seqid, iprot, oprot, handler) = do
  args <- read_GetMessagesBySequenceNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessagesBySequenceNumber handler (getMessagesBySequenceNumber_args_channelId args) (getMessagesBySequenceNumber_args_messageBoxId args) (getMessagesBySequenceNumber_args_startSeq args) (getMessagesBySequenceNumber_args_endSeq args)
        let res = default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_success = val}
        T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_REPLY, seqid) $
          write_GetMessagesBySequenceNumber_result oprot res)
      (\e  -> do
        let res = default_GetMessagesBySequenceNumber_result{getMessagesBySequenceNumber_result_e = P.Just e}
        T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_REPLY, seqid) $
          write_GetMessagesBySequenceNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessagesBySequenceNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNextMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetNextMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNextMessages handler (getNextMessages_args_messageBoxId args) (getNextMessages_args_startSeq args) (getNextMessages_args_messagesCount args)
        let res = default_GetNextMessages_result{getNextMessages_result_success = val}
        T.writeMessage oprot ("getNextMessages", T.M_REPLY, seqid) $
          write_GetNextMessages_result oprot res)
      (\e  -> do
        let res = default_GetNextMessages_result{getNextMessages_result_e = P.Just e}
        T.writeMessage oprot ("getNextMessages", T.M_REPLY, seqid) $
          write_GetNextMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNextMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotificationPolicy (seqid, iprot, oprot, handler) = do
  args <- read_GetNotificationPolicy_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNotificationPolicy handler (getNotificationPolicy_args_carrier args)
        let res = default_GetNotificationPolicy_result{getNotificationPolicy_result_success = val}
        T.writeMessage oprot ("getNotificationPolicy", T.M_REPLY, seqid) $
          write_GetNotificationPolicy_result oprot res)
      (\e  -> do
        let res = default_GetNotificationPolicy_result{getNotificationPolicy_result_e = P.Just e}
        T.writeMessage oprot ("getNotificationPolicy", T.M_REPLY, seqid) $
          write_GetNotificationPolicy_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotificationPolicy", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPreviousMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetPreviousMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPreviousMessages handler (getPreviousMessages_args_messageBoxId args) (getPreviousMessages_args_endSeq args) (getPreviousMessages_args_messagesCount args)
        let res = default_GetPreviousMessages_result{getPreviousMessages_result_success = val}
        T.writeMessage oprot ("getPreviousMessages", T.M_REPLY, seqid) $
          write_GetPreviousMessages_result oprot res)
      (\e  -> do
        let res = default_GetPreviousMessages_result{getPreviousMessages_result_e = P.Just e}
        T.writeMessage oprot ("getPreviousMessages", T.M_REPLY, seqid) $
          write_GetPreviousMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPreviousMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfile handler
        let res = default_GetProfile_result{getProfile_result_success = val}
        T.writeMessage oprot ("getProfile", T.M_REPLY, seqid) $
          write_GetProfile_result oprot res)
      (\e  -> do
        let res = default_GetProfile_result{getProfile_result_e = P.Just e}
        T.writeMessage oprot ("getProfile", T.M_REPLY, seqid) $
          write_GetProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProximityMatchCandidateList (seqid, iprot, oprot, handler) = do
  args <- read_GetProximityMatchCandidateList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProximityMatchCandidateList handler (getProximityMatchCandidateList_args_sessionId args)
        let res = default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_success = val}
        T.writeMessage oprot ("getProximityMatchCandidateList", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidateList_result oprot res)
      (\e  -> do
        let res = default_GetProximityMatchCandidateList_result{getProximityMatchCandidateList_result_e = P.Just e}
        T.writeMessage oprot ("getProximityMatchCandidateList", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidateList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProximityMatchCandidateList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProximityMatchCandidates (seqid, iprot, oprot, handler) = do
  args <- read_GetProximityMatchCandidates_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProximityMatchCandidates handler (getProximityMatchCandidates_args_sessionId args)
        let res = default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_success = val}
        T.writeMessage oprot ("getProximityMatchCandidates", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidates_result oprot res)
      (\e  -> do
        let res = default_GetProximityMatchCandidates_result{getProximityMatchCandidates_result_e = P.Just e}
        T.writeMessage oprot ("getProximityMatchCandidates", T.M_REPLY, seqid) $
          write_GetProximityMatchCandidates_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProximityMatchCandidates", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRecentMessages (seqid, iprot, oprot, handler) = do
  args <- read_GetRecentMessages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRecentMessages handler (getRecentMessages_args_messageBoxId args) (getRecentMessages_args_messagesCount args)
        let res = default_GetRecentMessages_result{getRecentMessages_result_success = val}
        T.writeMessage oprot ("getRecentMessages", T.M_REPLY, seqid) $
          write_GetRecentMessages_result oprot res)
      (\e  -> do
        let res = default_GetRecentMessages_result{getRecentMessages_result_e = P.Just e}
        T.writeMessage oprot ("getRecentMessages", T.M_REPLY, seqid) $
          write_GetRecentMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRecentMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRecommendationIds (seqid, iprot, oprot, handler) = do
  args <- read_GetRecommendationIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRecommendationIds handler
        let res = default_GetRecommendationIds_result{getRecommendationIds_result_success = val}
        T.writeMessage oprot ("getRecommendationIds", T.M_REPLY, seqid) $
          write_GetRecommendationIds_result oprot res)
      (\e  -> do
        let res = default_GetRecommendationIds_result{getRecommendationIds_result_e = P.Just e}
        T.writeMessage oprot ("getRecommendationIds", T.M_REPLY, seqid) $
          write_GetRecommendationIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRecommendationIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoom (seqid, iprot, oprot, handler) = do
  args <- read_GetRoom_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoom handler (getRoom_args_roomId args)
        let res = default_GetRoom_result{getRoom_result_success = val}
        T.writeMessage oprot ("getRoom", T.M_REPLY, seqid) $
          write_GetRoom_result oprot res)
      (\e  -> do
        let res = default_GetRoom_result{getRoom_result_e = P.Just e}
        T.writeMessage oprot ("getRoom", T.M_REPLY, seqid) $
          write_GetRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRSAKeyInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetRSAKeyInfo_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRSAKeyInfo handler (getRSAKeyInfo_args_provider args)
        let res = default_GetRSAKeyInfo_result{getRSAKeyInfo_result_success = val}
        T.writeMessage oprot ("getRSAKeyInfo", T.M_REPLY, seqid) $
          write_GetRSAKeyInfo_result oprot res)
      (\e  -> do
        let res = default_GetRSAKeyInfo_result{getRSAKeyInfo_result_e = P.Just e}
        T.writeMessage oprot ("getRSAKeyInfo", T.M_REPLY, seqid) $
          write_GetRSAKeyInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRSAKeyInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getServerTime (seqid, iprot, oprot, handler) = do
  args <- read_GetServerTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getServerTime handler
        let res = default_GetServerTime_result{getServerTime_result_success = val}
        T.writeMessage oprot ("getServerTime", T.M_REPLY, seqid) $
          write_GetServerTime_result oprot res)
      (\e  -> do
        let res = default_GetServerTime_result{getServerTime_result_e = P.Just e}
        T.writeMessage oprot ("getServerTime", T.M_REPLY, seqid) $
          write_GetServerTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getServerTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSessions (seqid, iprot, oprot, handler) = do
  args <- read_GetSessions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSessions handler
        let res = default_GetSessions_result{getSessions_result_success = val}
        T.writeMessage oprot ("getSessions", T.M_REPLY, seqid) $
          write_GetSessions_result oprot res)
      (\e  -> do
        let res = default_GetSessions_result{getSessions_result_e = P.Just e}
        T.writeMessage oprot ("getSessions", T.M_REPLY, seqid) $
          write_GetSessions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSessions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSettings (seqid, iprot, oprot, handler) = do
  args <- read_GetSettings_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSettings handler
        let res = default_GetSettings_result{getSettings_result_success = val}
        T.writeMessage oprot ("getSettings", T.M_REPLY, seqid) $
          write_GetSettings_result oprot res)
      (\e  -> do
        let res = default_GetSettings_result{getSettings_result_e = P.Just e}
        T.writeMessage oprot ("getSettings", T.M_REPLY, seqid) $
          write_GetSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupsV2 (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupsV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupsV2 handler (getGroupsV2_args_groupIds args)
        let res = default_GetGroupsV2_result{getGroupsV2_result_success = val}
        T.writeMessage oprot ("getGroupsV2", T.M_REPLY, seqid) $
          write_GetGroupsV2_result oprot res)
      (\e  -> do
        let res = default_GetGroupsV2_result{getGroupsV2_result_e = P.Just e}
        T.writeMessage oprot ("getGroupsV2", T.M_REPLY, seqid) $
          write_GetGroupsV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupsV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSettingsAttributes (seqid, iprot, oprot, handler) = do
  args <- read_GetSettingsAttributes_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSettingsAttributes handler (getSettingsAttributes_args_attrBitset args)
        let res = default_GetSettingsAttributes_result{getSettingsAttributes_result_success = val}
        T.writeMessage oprot ("getSettingsAttributes", T.M_REPLY, seqid) $
          write_GetSettingsAttributes_result oprot res)
      (\e  -> do
        let res = default_GetSettingsAttributes_result{getSettingsAttributes_result_e = P.Just e}
        T.writeMessage oprot ("getSettingsAttributes", T.M_REPLY, seqid) $
          write_GetSettingsAttributes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSettingsAttributes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSystemConfiguration (seqid, iprot, oprot, handler) = do
  args <- read_GetSystemConfiguration_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSystemConfiguration handler
        let res = default_GetSystemConfiguration_result{getSystemConfiguration_result_success = val}
        T.writeMessage oprot ("getSystemConfiguration", T.M_REPLY, seqid) $
          write_GetSystemConfiguration_result oprot res)
      (\e  -> do
        let res = default_GetSystemConfiguration_result{getSystemConfiguration_result_e = P.Just e}
        T.writeMessage oprot ("getSystemConfiguration", T.M_REPLY, seqid) $
          write_GetSystemConfiguration_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSystemConfiguration", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_GetUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserTicket handler
        let res = default_GetUserTicket_result{getUserTicket_result_success = val}
        T.writeMessage oprot ("getUserTicket", T.M_REPLY, seqid) $
          write_GetUserTicket_result oprot res)
      (\e  -> do
        let res = default_GetUserTicket_result{getUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("getUserTicket", T.M_REPLY, seqid) $
          write_GetUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getWapInvitation (seqid, iprot, oprot, handler) = do
  args <- read_GetWapInvitation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getWapInvitation handler (getWapInvitation_args_invitationHash args)
        let res = default_GetWapInvitation_result{getWapInvitation_result_success = val}
        T.writeMessage oprot ("getWapInvitation", T.M_REPLY, seqid) $
          write_GetWapInvitation_result oprot res)
      (\e  -> do
        let res = default_GetWapInvitation_result{getWapInvitation_result_e = P.Just e}
        T.writeMessage oprot ("getWapInvitation", T.M_REPLY, seqid) $
          write_GetWapInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getWapInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_invalidateUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_InvalidateUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        Iface.invalidateUserTicket handler
        let res = default_InvalidateUserTicket_result
        T.writeMessage oprot ("invalidateUserTicket", T.M_REPLY, seqid) $
          write_InvalidateUserTicket_result oprot res)
      (\e  -> do
        let res = default_InvalidateUserTicket_result{invalidateUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("invalidateUserTicket", T.M_REPLY, seqid) $
          write_InvalidateUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("invalidateUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteFriendsBySms (seqid, iprot, oprot, handler) = do
  args <- read_InviteFriendsBySms_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteFriendsBySms handler (inviteFriendsBySms_args_phoneNumberList args)
        let res = default_InviteFriendsBySms_result
        T.writeMessage oprot ("inviteFriendsBySms", T.M_REPLY, seqid) $
          write_InviteFriendsBySms_result oprot res)
      (\e  -> do
        let res = default_InviteFriendsBySms_result{inviteFriendsBySms_result_e = P.Just e}
        T.writeMessage oprot ("inviteFriendsBySms", T.M_REPLY, seqid) $
          write_InviteFriendsBySms_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteFriendsBySms", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoGroup (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoGroup handler (inviteIntoGroup_args_reqSeq args) (inviteIntoGroup_args_groupId args) (inviteIntoGroup_args_contactIds args)
        let res = default_InviteIntoGroup_result
        T.writeMessage oprot ("inviteIntoGroup", T.M_REPLY, seqid) $
          write_InviteIntoGroup_result oprot res)
      (\e  -> do
        let res = default_InviteIntoGroup_result{inviteIntoGroup_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoGroup", T.M_REPLY, seqid) $
          write_InviteIntoGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoRoom (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoRoom_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoRoom handler (inviteIntoRoom_args_reqSeq args) (inviteIntoRoom_args_roomId args) (inviteIntoRoom_args_contactIds args)
        let res = default_InviteIntoRoom_result
        T.writeMessage oprot ("inviteIntoRoom", T.M_REPLY, seqid) $
          write_InviteIntoRoom_result oprot res)
      (\e  -> do
        let res = default_InviteIntoRoom_result{inviteIntoRoom_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoRoom", T.M_REPLY, seqid) $
          write_InviteIntoRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteViaEmail (seqid, iprot, oprot, handler) = do
  args <- read_InviteViaEmail_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteViaEmail handler (inviteViaEmail_args_reqSeq args) (inviteViaEmail_args_email args) (inviteViaEmail_args_name args)
        let res = default_InviteViaEmail_result
        T.writeMessage oprot ("inviteViaEmail", T.M_REPLY, seqid) $
          write_InviteViaEmail_result oprot res)
      (\e  -> do
        let res = default_InviteViaEmail_result{inviteViaEmail_result_e = P.Just e}
        T.writeMessage oprot ("inviteViaEmail", T.M_REPLY, seqid) $
          write_InviteViaEmail_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteViaEmail", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isIdentityIdentifierAvailable (seqid, iprot, oprot, handler) = do
  args <- read_IsIdentityIdentifierAvailable_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isIdentityIdentifierAvailable handler (isIdentityIdentifierAvailable_args_provider args) (isIdentityIdentifierAvailable_args_identifier args)
        let res = default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_success = val}
        T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_REPLY, seqid) $
          write_IsIdentityIdentifierAvailable_result oprot res)
      (\e  -> do
        let res = default_IsIdentityIdentifierAvailable_result{isIdentityIdentifierAvailable_result_e = P.Just e}
        T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_REPLY, seqid) $
          write_IsIdentityIdentifierAvailable_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isIdentityIdentifierAvailable", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isUseridAvailable (seqid, iprot, oprot, handler) = do
  args <- read_IsUseridAvailable_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isUseridAvailable handler (isUseridAvailable_args_userid args)
        let res = default_IsUseridAvailable_result{isUseridAvailable_result_success = val}
        T.writeMessage oprot ("isUseridAvailable", T.M_REPLY, seqid) $
          write_IsUseridAvailable_result oprot res)
      (\e  -> do
        let res = default_IsUseridAvailable_result{isUseridAvailable_result_e = P.Just e}
        T.writeMessage oprot ("isUseridAvailable", T.M_REPLY, seqid) $
          write_IsUseridAvailable_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isUseridAvailable", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_kickoutFromGroup (seqid, iprot, oprot, handler) = do
  args <- read_KickoutFromGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.kickoutFromGroup handler (kickoutFromGroup_args_reqSeq args) (kickoutFromGroup_args_groupId args) (kickoutFromGroup_args_contactIds args)
        let res = default_KickoutFromGroup_result
        T.writeMessage oprot ("kickoutFromGroup", T.M_REPLY, seqid) $
          write_KickoutFromGroup_result oprot res)
      (\e  -> do
        let res = default_KickoutFromGroup_result{kickoutFromGroup_result_e = P.Just e}
        T.writeMessage oprot ("kickoutFromGroup", T.M_REPLY, seqid) $
          write_KickoutFromGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("kickoutFromGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reissueGroupTicket (seqid, iprot, oprot, handler) = do
  args <- read_ReissueGroupTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reissueGroupTicket handler (reissueGroupTicket_args_groupMid args)
        let res = default_ReissueGroupTicket_result{reissueGroupTicket_result_success = val}
        T.writeMessage oprot ("reissueGroupTicket", T.M_REPLY, seqid) $
          write_ReissueGroupTicket_result oprot res)
      (\e  -> do
        let res = default_ReissueGroupTicket_result{reissueGroupTicket_result_e = P.Just e}
        T.writeMessage oprot ("reissueGroupTicket", T.M_REPLY, seqid) $
          write_ReissueGroupTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reissueGroupTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findGroupByTicket (seqid, iprot, oprot, handler) = do
  args <- read_FindGroupByTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findGroupByTicket handler (findGroupByTicket_args_ticketId args)
        let res = default_FindGroupByTicket_result{findGroupByTicket_result_success = val}
        T.writeMessage oprot ("findGroupByTicket", T.M_REPLY, seqid) $
          write_FindGroupByTicket_result oprot res)
      (\e  -> do
        let res = default_FindGroupByTicket_result{findGroupByTicket_result_e = P.Just e}
        T.writeMessage oprot ("findGroupByTicket", T.M_REPLY, seqid) $
          write_FindGroupByTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findGroupByTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveGroup (seqid, iprot, oprot, handler) = do
  args <- read_LeaveGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.leaveGroup handler (leaveGroup_args_reqSeq args) (leaveGroup_args_groupId args)
        let res = default_LeaveGroup_result
        T.writeMessage oprot ("leaveGroup", T.M_REPLY, seqid) $
          write_LeaveGroup_result oprot res)
      (\e  -> do
        let res = default_LeaveGroup_result{leaveGroup_result_e = P.Just e}
        T.writeMessage oprot ("leaveGroup", T.M_REPLY, seqid) $
          write_LeaveGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_leaveRoom (seqid, iprot, oprot, handler) = do
  args <- read_LeaveRoom_args iprot
  (X.catch
    (X.catch
      (do
        Iface.leaveRoom handler (leaveRoom_args_reqSeq args) (leaveRoom_args_roomId args)
        let res = default_LeaveRoom_result
        T.writeMessage oprot ("leaveRoom", T.M_REPLY, seqid) $
          write_LeaveRoom_result oprot res)
      (\e  -> do
        let res = default_LeaveRoom_result{leaveRoom_result_e = P.Just e}
        T.writeMessage oprot ("leaveRoom", T.M_REPLY, seqid) $
          write_LeaveRoom_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("leaveRoom", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithIdentityCredential handler (loginWithIdentityCredential_args_identityProvider args) (loginWithIdentityCredential_args_identifier args) (loginWithIdentityCredential_args_password args) (loginWithIdentityCredential_args_keepLoggedIn args) (loginWithIdentityCredential_args_accessLocation args) (loginWithIdentityCredential_args_systemName args) (loginWithIdentityCredential_args_certificate args)
        let res = default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("loginWithIdentityCredential", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_LoginWithIdentityCredential_result{loginWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("loginWithIdentityCredential", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithIdentityCredentialForCertificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithIdentityCredentialForCertificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithIdentityCredentialForCertificate handler (loginWithIdentityCredentialForCertificate_args_identityProvider args) (loginWithIdentityCredentialForCertificate_args_identifier args) (loginWithIdentityCredentialForCertificate_args_password args) (loginWithIdentityCredentialForCertificate_args_keepLoggedIn args) (loginWithIdentityCredentialForCertificate_args_accessLocation args) (loginWithIdentityCredentialForCertificate_args_systemName args) (loginWithIdentityCredentialForCertificate_args_certificate args)
        let res = default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_success = val}
        T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredentialForCertificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithIdentityCredentialForCertificate_result{loginWithIdentityCredentialForCertificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_REPLY, seqid) $
          write_LoginWithIdentityCredentialForCertificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithIdentityCredentialForCertificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifier (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifier handler (loginWithVerifier_args_verifier args)
        let res = default_LoginWithVerifier_result{loginWithVerifier_result_success = val}
        T.writeMessage oprot ("loginWithVerifier", T.M_REPLY, seqid) $
          write_LoginWithVerifier_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifier_result{loginWithVerifier_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifier", T.M_REPLY, seqid) $
          write_LoginWithVerifier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifierForCerificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifierForCerificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifierForCerificate handler (loginWithVerifierForCerificate_args_verifier args)
        let res = default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_success = val}
        T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCerificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifierForCerificate_result{loginWithVerifierForCerificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCerificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifierForCerificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_loginWithVerifierForCertificate (seqid, iprot, oprot, handler) = do
  args <- read_LoginWithVerifierForCertificate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.loginWithVerifierForCertificate handler (loginWithVerifierForCertificate_args_verifier args)
        let res = default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_success = val}
        T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCertificate_result oprot res)
      (\e  -> do
        let res = default_LoginWithVerifierForCertificate_result{loginWithVerifierForCertificate_result_e = P.Just e}
        T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_REPLY, seqid) $
          write_LoginWithVerifierForCertificate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("loginWithVerifierForCertificate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logout (seqid, iprot, oprot, handler) = do
  args <- read_Logout_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logout handler
        let res = default_Logout_result
        T.writeMessage oprot ("logout", T.M_REPLY, seqid) $
          write_Logout_result oprot res)
      (\e  -> do
        let res = default_Logout_result{logout_result_e = P.Just e}
        T.writeMessage oprot ("logout", T.M_REPLY, seqid) $
          write_Logout_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logout", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_logoutSession (seqid, iprot, oprot, handler) = do
  args <- read_LogoutSession_args iprot
  (X.catch
    (X.catch
      (do
        Iface.logoutSession handler (logoutSession_args_tokenKey args)
        let res = default_LogoutSession_result
        T.writeMessage oprot ("logoutSession", T.M_REPLY, seqid) $
          write_LogoutSession_result oprot res)
      (\e  -> do
        let res = default_LogoutSession_result{logoutSession_result_e = P.Just e}
        T.writeMessage oprot ("logoutSession", T.M_REPLY, seqid) $
          write_LogoutSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("logoutSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_noop (seqid, iprot, oprot, handler) = do
  args <- read_Noop_args iprot
  (X.catch
    (X.catch
      (do
        Iface.noop handler
        let res = default_Noop_result
        T.writeMessage oprot ("noop", T.M_REPLY, seqid) $
          write_Noop_result oprot res)
      (\e  -> do
        let res = default_Noop_result{noop_result_e = P.Just e}
        T.writeMessage oprot ("noop", T.M_REPLY, seqid) $
          write_Noop_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("noop", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifiedRedirect (seqid, iprot, oprot, handler) = do
  args <- read_NotifiedRedirect_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifiedRedirect handler (notifiedRedirect_args_paramMap args)
        let res = default_NotifiedRedirect_result
        T.writeMessage oprot ("notifiedRedirect", T.M_REPLY, seqid) $
          write_NotifiedRedirect_result oprot res)
      (\e  -> do
        let res = default_NotifiedRedirect_result{notifiedRedirect_result_e = P.Just e}
        T.writeMessage oprot ("notifiedRedirect", T.M_REPLY, seqid) $
          write_NotifiedRedirect_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifiedRedirect", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyBuddyOnAir (seqid, iprot, oprot, handler) = do
  args <- read_NotifyBuddyOnAir_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.notifyBuddyOnAir handler (notifyBuddyOnAir_args_seq args) (notifyBuddyOnAir_args_receiverMids args)
        let res = default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_success = val}
        T.writeMessage oprot ("notifyBuddyOnAir", T.M_REPLY, seqid) $
          write_NotifyBuddyOnAir_result oprot res)
      (\e  -> do
        let res = default_NotifyBuddyOnAir_result{notifyBuddyOnAir_result_e = P.Just e}
        T.writeMessage oprot ("notifyBuddyOnAir", T.M_REPLY, seqid) $
          write_NotifyBuddyOnAir_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyBuddyOnAir", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyIndividualEvent (seqid, iprot, oprot, handler) = do
  args <- read_NotifyIndividualEvent_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyIndividualEvent handler (notifyIndividualEvent_args_notificationStatus args) (notifyIndividualEvent_args_receiverMids args)
        let res = default_NotifyIndividualEvent_result
        T.writeMessage oprot ("notifyIndividualEvent", T.M_REPLY, seqid) $
          write_NotifyIndividualEvent_result oprot res)
      (\e  -> do
        let res = default_NotifyIndividualEvent_result{notifyIndividualEvent_result_e = P.Just e}
        T.writeMessage oprot ("notifyIndividualEvent", T.M_REPLY, seqid) $
          write_NotifyIndividualEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyIndividualEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyInstalled (seqid, iprot, oprot, handler) = do
  args <- read_NotifyInstalled_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyInstalled handler (notifyInstalled_args_udidHash args) (notifyInstalled_args_applicationTypeWithExtensions args)
        let res = default_NotifyInstalled_result
        T.writeMessage oprot ("notifyInstalled", T.M_REPLY, seqid) $
          write_NotifyInstalled_result oprot res)
      (\e  -> do
        let res = default_NotifyInstalled_result{notifyInstalled_result_e = P.Just e}
        T.writeMessage oprot ("notifyInstalled", T.M_REPLY, seqid) $
          write_NotifyInstalled_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyInstalled", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyRegistrationComplete (seqid, iprot, oprot, handler) = do
  args <- read_NotifyRegistrationComplete_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyRegistrationComplete handler (notifyRegistrationComplete_args_udidHash args) (notifyRegistrationComplete_args_applicationTypeWithExtensions args)
        let res = default_NotifyRegistrationComplete_result
        T.writeMessage oprot ("notifyRegistrationComplete", T.M_REPLY, seqid) $
          write_NotifyRegistrationComplete_result oprot res)
      (\e  -> do
        let res = default_NotifyRegistrationComplete_result{notifyRegistrationComplete_result_e = P.Just e}
        T.writeMessage oprot ("notifyRegistrationComplete", T.M_REPLY, seqid) $
          write_NotifyRegistrationComplete_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyRegistrationComplete", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifySleep (seqid, iprot, oprot, handler) = do
  args <- read_NotifySleep_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifySleep handler (notifySleep_args_lastRev args) (notifySleep_args_badge args)
        let res = default_NotifySleep_result
        T.writeMessage oprot ("notifySleep", T.M_REPLY, seqid) $
          write_NotifySleep_result oprot res)
      (\e  -> do
        let res = default_NotifySleep_result{notifySleep_result_e = P.Just e}
        T.writeMessage oprot ("notifySleep", T.M_REPLY, seqid) $
          write_NotifySleep_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifySleep", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyUpdated (seqid, iprot, oprot, handler) = do
  args <- read_NotifyUpdated_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyUpdated handler (notifyUpdated_args_lastRev args) (notifyUpdated_args_deviceInfo args)
        let res = default_NotifyUpdated_result
        T.writeMessage oprot ("notifyUpdated", T.M_REPLY, seqid) $
          write_NotifyUpdated_result oprot res)
      (\e  -> do
        let res = default_NotifyUpdated_result{notifyUpdated_result_e = P.Just e}
        T.writeMessage oprot ("notifyUpdated", T.M_REPLY, seqid) $
          write_NotifyUpdated_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyUpdated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_openProximityMatch (seqid, iprot, oprot, handler) = do
  args <- read_OpenProximityMatch_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.openProximityMatch handler (openProximityMatch_args_location args)
        let res = default_OpenProximityMatch_result{openProximityMatch_result_success = val}
        T.writeMessage oprot ("openProximityMatch", T.M_REPLY, seqid) $
          write_OpenProximityMatch_result oprot res)
      (\e  -> do
        let res = default_OpenProximityMatch_result{openProximityMatch_result_e = P.Just e}
        T.writeMessage oprot ("openProximityMatch", T.M_REPLY, seqid) $
          write_OpenProximityMatch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("openProximityMatch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerBuddyUser (seqid, iprot, oprot, handler) = do
  args <- read_RegisterBuddyUser_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerBuddyUser handler (registerBuddyUser_args_buddyId args) (registerBuddyUser_args_registrarPassword args)
        let res = default_RegisterBuddyUser_result{registerBuddyUser_result_success = val}
        T.writeMessage oprot ("registerBuddyUser", T.M_REPLY, seqid) $
          write_RegisterBuddyUser_result oprot res)
      (\e  -> do
        let res = default_RegisterBuddyUser_result{registerBuddyUser_result_e = P.Just e}
        T.writeMessage oprot ("registerBuddyUser", T.M_REPLY, seqid) $
          write_RegisterBuddyUser_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerBuddyUser", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerBuddyUserid (seqid, iprot, oprot, handler) = do
  args <- read_RegisterBuddyUserid_args iprot
  (X.catch
    (X.catch
      (do
        Iface.registerBuddyUserid handler (registerBuddyUserid_args_seq args) (registerBuddyUserid_args_userid args)
        let res = default_RegisterBuddyUserid_result
        T.writeMessage oprot ("registerBuddyUserid", T.M_REPLY, seqid) $
          write_RegisterBuddyUserid_result oprot res)
      (\e  -> do
        let res = default_RegisterBuddyUserid_result{registerBuddyUserid_result_e = P.Just e}
        T.writeMessage oprot ("registerBuddyUserid", T.M_REPLY, seqid) $
          write_RegisterBuddyUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerBuddyUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDevice (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDevice handler (registerDevice_args_sessionId args)
        let res = default_RegisterDevice_result{registerDevice_result_success = val}
        T.writeMessage oprot ("registerDevice", T.M_REPLY, seqid) $
          write_RegisterDevice_result oprot res)
      (\e  -> do
        let res = default_RegisterDevice_result{registerDevice_result_e = P.Just e}
        T.writeMessage oprot ("registerDevice", T.M_REPLY, seqid) $
          write_RegisterDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithIdentityCredential handler (registerDeviceWithIdentityCredential_args_sessionId args) (registerDeviceWithIdentityCredential_args_provider args) (registerDeviceWithIdentityCredential_args_identifier args) (registerDeviceWithIdentityCredential_args_verifier args)
        let res = default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithIdentityCredential_result{registerDeviceWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithoutPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithoutPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithoutPhoneNumber handler (registerDeviceWithoutPhoneNumber_args_region args) (registerDeviceWithoutPhoneNumber_args_udidHash args) (registerDeviceWithoutPhoneNumber_args_deviceInfo args)
        let res = default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_success = val}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithoutPhoneNumber_result{registerDeviceWithoutPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithoutPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerDeviceWithoutPhoneNumberWithIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerDeviceWithoutPhoneNumberWithIdentityCredential handler (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_region args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_udidHash args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_deviceInfo args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_provider args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_identifier args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_verifier args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_mid args) (registerDeviceWithoutPhoneNumberWithIdentityCredential_args_migrationPincodeSessionId args)
        let res = default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result{registerDeviceWithoutPhoneNumberWithIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterDeviceWithoutPhoneNumberWithIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerDeviceWithoutPhoneNumberWithIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerUserid (seqid, iprot, oprot, handler) = do
  args <- read_RegisterUserid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerUserid handler (registerUserid_args_reqSeq args) (registerUserid_args_userid args)
        let res = default_RegisterUserid_result{registerUserid_result_success = val}
        T.writeMessage oprot ("registerUserid", T.M_REPLY, seqid) $
          write_RegisterUserid_result oprot res)
      (\e  -> do
        let res = default_RegisterUserid_result{registerUserid_result_e = P.Just e}
        T.writeMessage oprot ("registerUserid", T.M_REPLY, seqid) $
          write_RegisterUserid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerUserid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWapDevice (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWapDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWapDevice handler (registerWapDevice_args_invitationHash args) (registerWapDevice_args_guidHash args) (registerWapDevice_args_email args) (registerWapDevice_args_deviceInfo args)
        let res = default_RegisterWapDevice_result{registerWapDevice_result_success = val}
        T.writeMessage oprot ("registerWapDevice", T.M_REPLY, seqid) $
          write_RegisterWapDevice_result oprot res)
      (\e  -> do
        let res = default_RegisterWapDevice_result{registerWapDevice_result_e = P.Just e}
        T.writeMessage oprot ("registerWapDevice", T.M_REPLY, seqid) $
          write_RegisterWapDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWapDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithExistingSnsIdAndIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithExistingSnsIdAndIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithExistingSnsIdAndIdentityCredential handler (registerWithExistingSnsIdAndIdentityCredential_args_identityCredential args) (registerWithExistingSnsIdAndIdentityCredential_args_region args) (registerWithExistingSnsIdAndIdentityCredential_args_udidHash args) (registerWithExistingSnsIdAndIdentityCredential_args_deviceInfo args)
        let res = default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterWithExistingSnsIdAndIdentityCredential_result{registerWithExistingSnsIdAndIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithExistingSnsIdAndIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithExistingSnsIdAndIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithSnsId (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithSnsId handler (registerWithSnsId_args_snsIdType args) (registerWithSnsId_args_snsAccessToken args) (registerWithSnsId_args_region args) (registerWithSnsId_args_udidHash args) (registerWithSnsId_args_deviceInfo args) (registerWithSnsId_args_mid args)
        let res = default_RegisterWithSnsId_result{registerWithSnsId_result_success = val}
        T.writeMessage oprot ("registerWithSnsId", T.M_REPLY, seqid) $
          write_RegisterWithSnsId_result oprot res)
      (\e  -> do
        let res = default_RegisterWithSnsId_result{registerWithSnsId_result_e = P.Just e}
        T.writeMessage oprot ("registerWithSnsId", T.M_REPLY, seqid) $
          write_RegisterWithSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerWithSnsIdAndIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_RegisterWithSnsIdAndIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerWithSnsIdAndIdentityCredential handler (registerWithSnsIdAndIdentityCredential_args_snsIdType args) (registerWithSnsIdAndIdentityCredential_args_snsAccessToken args) (registerWithSnsIdAndIdentityCredential_args_identityCredential args) (registerWithSnsIdAndIdentityCredential_args_region args) (registerWithSnsIdAndIdentityCredential_args_udidHash args) (registerWithSnsIdAndIdentityCredential_args_deviceInfo args)
        let res = default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_success = val}
        T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithSnsIdAndIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_RegisterWithSnsIdAndIdentityCredential_result{registerWithSnsIdAndIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_REPLY, seqid) $
          write_RegisterWithSnsIdAndIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerWithSnsIdAndIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reissueDeviceCredential (seqid, iprot, oprot, handler) = do
  args <- read_ReissueDeviceCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reissueDeviceCredential handler
        let res = default_ReissueDeviceCredential_result{reissueDeviceCredential_result_success = val}
        T.writeMessage oprot ("reissueDeviceCredential", T.M_REPLY, seqid) $
          write_ReissueDeviceCredential_result oprot res)
      (\e  -> do
        let res = default_ReissueDeviceCredential_result{reissueDeviceCredential_result_e = P.Just e}
        T.writeMessage oprot ("reissueDeviceCredential", T.M_REPLY, seqid) $
          write_ReissueDeviceCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reissueDeviceCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reissueUserTicket (seqid, iprot, oprot, handler) = do
  args <- read_ReissueUserTicket_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reissueUserTicket handler (reissueUserTicket_args_expirationTime args) (reissueUserTicket_args_maxUseCount args)
        let res = default_ReissueUserTicket_result{reissueUserTicket_result_success = val}
        T.writeMessage oprot ("reissueUserTicket", T.M_REPLY, seqid) $
          write_ReissueUserTicket_result oprot res)
      (\e  -> do
        let res = default_ReissueUserTicket_result{reissueUserTicket_result_e = P.Just e}
        T.writeMessage oprot ("reissueUserTicket", T.M_REPLY, seqid) $
          write_ReissueUserTicket_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reissueUserTicket", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageReadRange (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageReadRange_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageReadRange handler (getMessageReadRange_args_chatIds args)
        let res = default_GetMessageReadRange_result{getMessageReadRange_result_success = val}
        T.writeMessage oprot ("getMessageReadRange", T.M_REPLY, seqid) $
          write_GetMessageReadRange_result oprot res)
      (\e  -> do
        let res = default_GetMessageReadRange_result{getMessageReadRange_result_e = P.Just e}
        T.writeMessage oprot ("getMessageReadRange", T.M_REPLY, seqid) $
          write_GetMessageReadRange_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageReadRange", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_rejectGroupInvitation (seqid, iprot, oprot, handler) = do
  args <- read_RejectGroupInvitation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.rejectGroupInvitation handler (rejectGroupInvitation_args_reqSeq args) (rejectGroupInvitation_args_groupId args)
        let res = default_RejectGroupInvitation_result
        T.writeMessage oprot ("rejectGroupInvitation", T.M_REPLY, seqid) $
          write_RejectGroupInvitation_result oprot res)
      (\e  -> do
        let res = default_RejectGroupInvitation_result{rejectGroupInvitation_result_e = P.Just e}
        T.writeMessage oprot ("rejectGroupInvitation", T.M_REPLY, seqid) $
          write_RejectGroupInvitation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("rejectGroupInvitation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_releaseSession (seqid, iprot, oprot, handler) = do
  args <- read_ReleaseSession_args iprot
  (X.catch
    (X.catch
      (do
        Iface.releaseSession handler
        let res = default_ReleaseSession_result
        T.writeMessage oprot ("releaseSession", T.M_REPLY, seqid) $
          write_ReleaseSession_result oprot res)
      (\e  -> do
        let res = default_ReleaseSession_result{releaseSession_result_e = P.Just e}
        T.writeMessage oprot ("releaseSession", T.M_REPLY, seqid) $
          write_ReleaseSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("releaseSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeAllMessages (seqid, iprot, oprot, handler) = do
  args <- read_RemoveAllMessages_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeAllMessages handler (removeAllMessages_args_seq args) (removeAllMessages_args_lastMessageId args)
        let res = default_RemoveAllMessages_result
        T.writeMessage oprot ("removeAllMessages", T.M_REPLY, seqid) $
          write_RemoveAllMessages_result oprot res)
      (\e  -> do
        let res = default_RemoveAllMessages_result{removeAllMessages_result_e = P.Just e}
        T.writeMessage oprot ("removeAllMessages", T.M_REPLY, seqid) $
          write_RemoveAllMessages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeAllMessages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_RemoveBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeBuddyLocation handler (removeBuddyLocation_args_mid args) (removeBuddyLocation_args_index args)
        let res = default_RemoveBuddyLocation_result
        T.writeMessage oprot ("removeBuddyLocation", T.M_REPLY, seqid) $
          write_RemoveBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_RemoveBuddyLocation_result{removeBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("removeBuddyLocation", T.M_REPLY, seqid) $
          write_RemoveBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeMessage (seqid, iprot, oprot, handler) = do
  args <- read_RemoveMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeMessage handler (removeMessage_args_messageId args)
        let res = default_RemoveMessage_result{removeMessage_result_success = val}
        T.writeMessage oprot ("removeMessage", T.M_REPLY, seqid) $
          write_RemoveMessage_result oprot res)
      (\e  -> do
        let res = default_RemoveMessage_result{removeMessage_result_e = P.Just e}
        T.writeMessage oprot ("removeMessage", T.M_REPLY, seqid) $
          write_RemoveMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_makeUserAddMyselfAsContact (seqid, iprot, oprot, handler) = do
  args <- read_MakeUserAddMyselfAsContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.makeUserAddMyselfAsContact handler (makeUserAddMyselfAsContact_args_contactOwnerMid args)
        let res = default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_success = val}
        T.writeMessage oprot ("makeUserAddMyselfAsContact", T.M_REPLY, seqid) $
          write_MakeUserAddMyselfAsContact_result oprot res)
      (\e  -> do
        let res = default_MakeUserAddMyselfAsContact_result{makeUserAddMyselfAsContact_result_e = P.Just e}
        T.writeMessage oprot ("makeUserAddMyselfAsContact", T.M_REPLY, seqid) $
          write_MakeUserAddMyselfAsContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("makeUserAddMyselfAsContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeMessageFromMyHome (seqid, iprot, oprot, handler) = do
  args <- read_RemoveMessageFromMyHome_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeMessageFromMyHome handler (removeMessageFromMyHome_args_messageId args)
        let res = default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_success = val}
        T.writeMessage oprot ("removeMessageFromMyHome", T.M_REPLY, seqid) $
          write_RemoveMessageFromMyHome_result oprot res)
      (\e  -> do
        let res = default_RemoveMessageFromMyHome_result{removeMessageFromMyHome_result_e = P.Just e}
        T.writeMessage oprot ("removeMessageFromMyHome", T.M_REPLY, seqid) $
          write_RemoveMessageFromMyHome_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeMessageFromMyHome", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeSnsId (seqid, iprot, oprot, handler) = do
  args <- read_RemoveSnsId_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.removeSnsId handler (removeSnsId_args_snsIdType args)
        let res = default_RemoveSnsId_result{removeSnsId_result_success = val}
        T.writeMessage oprot ("removeSnsId", T.M_REPLY, seqid) $
          write_RemoveSnsId_result oprot res)
      (\e  -> do
        let res = default_RemoveSnsId_result{removeSnsId_result_e = P.Just e}
        T.writeMessage oprot ("removeSnsId", T.M_REPLY, seqid) $
          write_RemoveSnsId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeSnsId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_report (seqid, iprot, oprot, handler) = do
  args <- read_Report_args iprot
  (X.catch
    (X.catch
      (do
        Iface.report handler (report_args_syncOpRevision args) (report_args_category args) (report_args_report args)
        let res = default_Report_result
        T.writeMessage oprot ("report", T.M_REPLY, seqid) $
          write_Report_result oprot res)
      (\e  -> do
        let res = default_Report_result{report_result_e = P.Just e}
        T.writeMessage oprot ("report", T.M_REPLY, seqid) $
          write_Report_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("report", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportContacts (seqid, iprot, oprot, handler) = do
  args <- read_ReportContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reportContacts handler (reportContacts_args_syncOpRevision args) (reportContacts_args_category args) (reportContacts_args_contactReports args) (reportContacts_args_actionType args)
        let res = default_ReportContacts_result{reportContacts_result_success = val}
        T.writeMessage oprot ("reportContacts", T.M_REPLY, seqid) $
          write_ReportContacts_result oprot res)
      (\e  -> do
        let res = default_ReportContacts_result{reportContacts_result_e = P.Just e}
        T.writeMessage oprot ("reportContacts", T.M_REPLY, seqid) $
          write_ReportContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportGroups (seqid, iprot, oprot, handler) = do
  args <- read_ReportGroups_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportGroups handler (reportGroups_args_syncOpRevision args) (reportGroups_args_groups args)
        let res = default_ReportGroups_result
        T.writeMessage oprot ("reportGroups", T.M_REPLY, seqid) $
          write_ReportGroups_result oprot res)
      (\e  -> do
        let res = default_ReportGroups_result{reportGroups_result_e = P.Just e}
        T.writeMessage oprot ("reportGroups", T.M_REPLY, seqid) $
          write_ReportGroups_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportGroups", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportProfile (seqid, iprot, oprot, handler) = do
  args <- read_ReportProfile_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportProfile handler (reportProfile_args_syncOpRevision args) (reportProfile_args_profile args)
        let res = default_ReportProfile_result
        T.writeMessage oprot ("reportProfile", T.M_REPLY, seqid) $
          write_ReportProfile_result oprot res)
      (\e  -> do
        let res = default_ReportProfile_result{reportProfile_result_e = P.Just e}
        T.writeMessage oprot ("reportProfile", T.M_REPLY, seqid) $
          write_ReportProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportRooms (seqid, iprot, oprot, handler) = do
  args <- read_ReportRooms_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportRooms handler (reportRooms_args_syncOpRevision args) (reportRooms_args_rooms args)
        let res = default_ReportRooms_result
        T.writeMessage oprot ("reportRooms", T.M_REPLY, seqid) $
          write_ReportRooms_result oprot res)
      (\e  -> do
        let res = default_ReportRooms_result{reportRooms_result_e = P.Just e}
        T.writeMessage oprot ("reportRooms", T.M_REPLY, seqid) $
          write_ReportRooms_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportRooms", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findAndAddContactByMetaTag (seqid, iprot, oprot, handler) = do
  args <- read_FindAndAddContactByMetaTag_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findAndAddContactByMetaTag handler (findAndAddContactByMetaTag_args_reqSeq args) (findAndAddContactByMetaTag_args_userid args) (findAndAddContactByMetaTag_args_reference args)
        let res = default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_success = val}
        T.writeMessage oprot ("findAndAddContactByMetaTag", T.M_REPLY, seqid) $
          write_FindAndAddContactByMetaTag_result oprot res)
      (\e  -> do
        let res = default_FindAndAddContactByMetaTag_result{findAndAddContactByMetaTag_result_e = P.Just e}
        T.writeMessage oprot ("findAndAddContactByMetaTag", T.M_REPLY, seqid) $
          write_FindAndAddContactByMetaTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findAndAddContactByMetaTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSettings (seqid, iprot, oprot, handler) = do
  args <- read_ReportSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportSettings handler (reportSettings_args_syncOpRevision args) (reportSettings_args_settings args)
        let res = default_ReportSettings_result
        T.writeMessage oprot ("reportSettings", T.M_REPLY, seqid) $
          write_ReportSettings_result oprot res)
      (\e  -> do
        let res = default_ReportSettings_result{reportSettings_result_e = P.Just e}
        T.writeMessage oprot ("reportSettings", T.M_REPLY, seqid) $
          write_ReportSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSpam (seqid, iprot, oprot, handler) = do
  args <- read_ReportSpam_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportSpam handler (reportSpam_args_chatMid args) (reportSpam_args_memberMids args) (reportSpam_args_spammerReasons args) (reportSpam_args_senderMids args) (reportSpam_args_spamMessageIds args) (reportSpam_args_spamMessages args)
        let res = default_ReportSpam_result
        T.writeMessage oprot ("reportSpam", T.M_REPLY, seqid) $
          write_ReportSpam_result oprot res)
      (\e  -> do
        let res = default_ReportSpam_result{reportSpam_result_e = P.Just e}
        T.writeMessage oprot ("reportSpam", T.M_REPLY, seqid) $
          write_ReportSpam_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSpam", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reportSpammer (seqid, iprot, oprot, handler) = do
  args <- read_ReportSpammer_args iprot
  (X.catch
    (X.catch
      (do
        Iface.reportSpammer handler (reportSpammer_args_spammerMid args) (reportSpammer_args_spammerReasons args) (reportSpammer_args_spamMessageIds args)
        let res = default_ReportSpammer_result
        T.writeMessage oprot ("reportSpammer", T.M_REPLY, seqid) $
          write_ReportSpammer_result oprot res)
      (\e  -> do
        let res = default_ReportSpammer_result{reportSpammer_result_e = P.Just e}
        T.writeMessage oprot ("reportSpammer", T.M_REPLY, seqid) $
          write_ReportSpammer_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reportSpammer", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestAccountPasswordReset (seqid, iprot, oprot, handler) = do
  args <- read_RequestAccountPasswordReset_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestAccountPasswordReset handler (requestAccountPasswordReset_args_provider args) (requestAccountPasswordReset_args_identifier args) (requestAccountPasswordReset_args_locale args)
        let res = default_RequestAccountPasswordReset_result
        T.writeMessage oprot ("requestAccountPasswordReset", T.M_REPLY, seqid) $
          write_RequestAccountPasswordReset_result oprot res)
      (\e  -> do
        let res = default_RequestAccountPasswordReset_result{requestAccountPasswordReset_result_e = P.Just e}
        T.writeMessage oprot ("requestAccountPasswordReset", T.M_REPLY, seqid) $
          write_RequestAccountPasswordReset_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestAccountPasswordReset", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestEmailConfirmation (seqid, iprot, oprot, handler) = do
  args <- read_RequestEmailConfirmation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.requestEmailConfirmation handler (requestEmailConfirmation_args_emailConfirmation args)
        let res = default_RequestEmailConfirmation_result{requestEmailConfirmation_result_success = val}
        T.writeMessage oprot ("requestEmailConfirmation", T.M_REPLY, seqid) $
          write_RequestEmailConfirmation_result oprot res)
      (\e  -> do
        let res = default_RequestEmailConfirmation_result{requestEmailConfirmation_result_e = P.Just e}
        T.writeMessage oprot ("requestEmailConfirmation", T.M_REPLY, seqid) $
          write_RequestEmailConfirmation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestEmailConfirmation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestIdentityUnbind (seqid, iprot, oprot, handler) = do
  args <- read_RequestIdentityUnbind_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestIdentityUnbind handler (requestIdentityUnbind_args_provider args) (requestIdentityUnbind_args_identifier args)
        let res = default_RequestIdentityUnbind_result
        T.writeMessage oprot ("requestIdentityUnbind", T.M_REPLY, seqid) $
          write_RequestIdentityUnbind_result oprot res)
      (\e  -> do
        let res = default_RequestIdentityUnbind_result{requestIdentityUnbind_result_e = P.Just e}
        T.writeMessage oprot ("requestIdentityUnbind", T.M_REPLY, seqid) $
          write_RequestIdentityUnbind_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestIdentityUnbind", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendEmailConfirmation (seqid, iprot, oprot, handler) = do
  args <- read_ResendEmailConfirmation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.resendEmailConfirmation handler (resendEmailConfirmation_args_verifier args)
        let res = default_ResendEmailConfirmation_result{resendEmailConfirmation_result_success = val}
        T.writeMessage oprot ("resendEmailConfirmation", T.M_REPLY, seqid) $
          write_ResendEmailConfirmation_result oprot res)
      (\e  -> do
        let res = default_ResendEmailConfirmation_result{resendEmailConfirmation_result_e = P.Just e}
        T.writeMessage oprot ("resendEmailConfirmation", T.M_REPLY, seqid) $
          write_ResendEmailConfirmation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendEmailConfirmation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendPinCode (seqid, iprot, oprot, handler) = do
  args <- read_ResendPinCode_args iprot
  (X.catch
    (X.catch
      (do
        Iface.resendPinCode handler (resendPinCode_args_sessionId args)
        let res = default_ResendPinCode_result
        T.writeMessage oprot ("resendPinCode", T.M_REPLY, seqid) $
          write_ResendPinCode_result oprot res)
      (\e  -> do
        let res = default_ResendPinCode_result{resendPinCode_result_e = P.Just e}
        T.writeMessage oprot ("resendPinCode", T.M_REPLY, seqid) $
          write_ResendPinCode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendPinCode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_resendPinCodeBySMS (seqid, iprot, oprot, handler) = do
  args <- read_ResendPinCodeBySMS_args iprot
  (X.catch
    (X.catch
      (do
        Iface.resendPinCodeBySMS handler (resendPinCodeBySMS_args_sessionId args)
        let res = default_ResendPinCodeBySMS_result
        T.writeMessage oprot ("resendPinCodeBySMS", T.M_REPLY, seqid) $
          write_ResendPinCodeBySMS_result oprot res)
      (\e  -> do
        let res = default_ResendPinCodeBySMS_result{resendPinCodeBySMS_result_e = P.Just e}
        T.writeMessage oprot ("resendPinCodeBySMS", T.M_REPLY, seqid) $
          write_ResendPinCodeBySMS_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("resendPinCodeBySMS", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendChatChecked (seqid, iprot, oprot, handler) = do
  args <- read_SendChatChecked_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendChatChecked handler (sendChatChecked_args_seq args) (sendChatChecked_args_consumer args) (sendChatChecked_args_lastMessageId args)
        let res = default_SendChatChecked_result
        T.writeMessage oprot ("sendChatChecked", T.M_REPLY, seqid) $
          write_SendChatChecked_result oprot res)
      (\e  -> do
        let res = default_SendChatChecked_result{sendChatChecked_result_e = P.Just e}
        T.writeMessage oprot ("sendChatChecked", T.M_REPLY, seqid) $
          write_SendChatChecked_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendChatChecked", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageAwaitCommit (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageAwaitCommit_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageAwaitCommit handler (sendMessageAwaitCommit_args_seq args) (sendMessageAwaitCommit_args_message args)
        let res = default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_success = val}
        T.writeMessage oprot ("sendMessageAwaitCommit", T.M_REPLY, seqid) $
          write_SendMessageAwaitCommit_result oprot res)
      (\e  -> do
        let res = default_SendMessageAwaitCommit_result{sendMessageAwaitCommit_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageAwaitCommit", T.M_REPLY, seqid) $
          write_SendMessageAwaitCommit_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageAwaitCommit", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendChatRemoved (seqid, iprot, oprot, handler) = do
  args <- read_SendChatRemoved_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendChatRemoved handler (sendChatRemoved_args_seq args) (sendChatRemoved_args_consumer args) (sendChatRemoved_args_lastMessageId args)
        let res = default_SendChatRemoved_result
        T.writeMessage oprot ("sendChatRemoved", T.M_REPLY, seqid) $
          write_SendChatRemoved_result oprot res)
      (\e  -> do
        let res = default_SendChatRemoved_result{sendChatRemoved_result_e = P.Just e}
        T.writeMessage oprot ("sendChatRemoved", T.M_REPLY, seqid) $
          write_SendChatRemoved_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendChatRemoved", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendContentPreviewUpdated (seqid, iprot, oprot, handler) = do
  args <- read_SendContentPreviewUpdated_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendContentPreviewUpdated handler (sendContentPreviewUpdated_args_esq args) (sendContentPreviewUpdated_args_messageId args) (sendContentPreviewUpdated_args_receiverMids args)
        let res = default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_success = val}
        T.writeMessage oprot ("sendContentPreviewUpdated", T.M_REPLY, seqid) $
          write_SendContentPreviewUpdated_result oprot res)
      (\e  -> do
        let res = default_SendContentPreviewUpdated_result{sendContentPreviewUpdated_result_e = P.Just e}
        T.writeMessage oprot ("sendContentPreviewUpdated", T.M_REPLY, seqid) $
          write_SendContentPreviewUpdated_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendContentPreviewUpdated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendContentReceipt (seqid, iprot, oprot, handler) = do
  args <- read_SendContentReceipt_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendContentReceipt handler (sendContentReceipt_args_seq args) (sendContentReceipt_args_consumer args) (sendContentReceipt_args_messageId args)
        let res = default_SendContentReceipt_result
        T.writeMessage oprot ("sendContentReceipt", T.M_REPLY, seqid) $
          write_SendContentReceipt_result oprot res)
      (\e  -> do
        let res = default_SendContentReceipt_result{sendContentReceipt_result_e = P.Just e}
        T.writeMessage oprot ("sendContentReceipt", T.M_REPLY, seqid) $
          write_SendContentReceipt_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendContentReceipt", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendDummyPush (seqid, iprot, oprot, handler) = do
  args <- read_SendDummyPush_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendDummyPush handler
        let res = default_SendDummyPush_result
        T.writeMessage oprot ("sendDummyPush", T.M_REPLY, seqid) $
          write_SendDummyPush_result oprot res)
      (\e  -> do
        let res = default_SendDummyPush_result{sendDummyPush_result_e = P.Just e}
        T.writeMessage oprot ("sendDummyPush", T.M_REPLY, seqid) $
          write_SendDummyPush_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendDummyPush", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeE2EEPublicKey (seqid, iprot, oprot, handler) = do
  args <- read_RemoveE2EEPublicKey_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeE2EEPublicKey handler (removeE2EEPublicKey_args_publicKey args)
        let res = default_RemoveE2EEPublicKey_result
        T.writeMessage oprot ("removeE2EEPublicKey", T.M_REPLY, seqid) $
          write_RemoveE2EEPublicKey_result oprot res)
      (\e  -> do
        let res = default_RemoveE2EEPublicKey_result{removeE2EEPublicKey_result_e = P.Just e}
        T.writeMessage oprot ("removeE2EEPublicKey", T.M_REPLY, seqid) $
          write_RemoveE2EEPublicKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeE2EEPublicKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_negotiateE2EEPublicKey (seqid, iprot, oprot, handler) = do
  args <- read_NegotiateE2EEPublicKey_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.negotiateE2EEPublicKey handler (negotiateE2EEPublicKey_args_mid args)
        let res = default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_success = val}
        T.writeMessage oprot ("negotiateE2EEPublicKey", T.M_REPLY, seqid) $
          write_NegotiateE2EEPublicKey_result oprot res)
      (\e  -> do
        let res = default_NegotiateE2EEPublicKey_result{negotiateE2EEPublicKey_result_e = P.Just e}
        T.writeMessage oprot ("negotiateE2EEPublicKey", T.M_REPLY, seqid) $
          write_NegotiateE2EEPublicKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("negotiateE2EEPublicKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getE2EEPublicKey (seqid, iprot, oprot, handler) = do
  args <- read_GetE2EEPublicKey_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getE2EEPublicKey handler (getE2EEPublicKey_args_mid args) (getE2EEPublicKey_args_version args) (getE2EEPublicKey_args_keyId args)
        let res = default_GetE2EEPublicKey_result{getE2EEPublicKey_result_success = val}
        T.writeMessage oprot ("getE2EEPublicKey", T.M_REPLY, seqid) $
          write_GetE2EEPublicKey_result oprot res)
      (\e  -> do
        let res = default_GetE2EEPublicKey_result{getE2EEPublicKey_result_e = P.Just e}
        T.writeMessage oprot ("getE2EEPublicKey", T.M_REPLY, seqid) $
          write_GetE2EEPublicKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getE2EEPublicKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_requestE2EEKeyExchange (seqid, iprot, oprot, handler) = do
  args <- read_RequestE2EEKeyExchange_args iprot
  (X.catch
    (X.catch
      (do
        Iface.requestE2EEKeyExchange handler (requestE2EEKeyExchange_args_reqSeq args) (requestE2EEKeyExchange_args_temporalPublicKey args) (requestE2EEKeyExchange_args_publicKey args) (requestE2EEKeyExchange_args_verifier args)
        let res = default_RequestE2EEKeyExchange_result
        T.writeMessage oprot ("requestE2EEKeyExchange", T.M_REPLY, seqid) $
          write_RequestE2EEKeyExchange_result oprot res)
      (\e  -> do
        let res = default_RequestE2EEKeyExchange_result{requestE2EEKeyExchange_result_e = P.Just e}
        T.writeMessage oprot ("requestE2EEKeyExchange", T.M_REPLY, seqid) $
          write_RequestE2EEKeyExchange_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("requestE2EEKeyExchange", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLastE2EEPublicKeys (seqid, iprot, oprot, handler) = do
  args <- read_GetLastE2EEPublicKeys_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getLastE2EEPublicKeys handler (getLastE2EEPublicKeys_args_chatMid args)
        let res = default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_success = val}
        T.writeMessage oprot ("getLastE2EEPublicKeys", T.M_REPLY, seqid) $
          write_GetLastE2EEPublicKeys_result oprot res)
      (\e  -> do
        let res = default_GetLastE2EEPublicKeys_result{getLastE2EEPublicKeys_result_e = P.Just e}
        T.writeMessage oprot ("getLastE2EEPublicKeys", T.M_REPLY, seqid) $
          write_GetLastE2EEPublicKeys_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLastE2EEPublicKeys", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerE2EEPublicKey (seqid, iprot, oprot, handler) = do
  args <- read_RegisterE2EEPublicKey_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerE2EEPublicKey handler (registerE2EEPublicKey_args_reqSeq args) (registerE2EEPublicKey_args_publicKey args)
        let res = default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_success = val}
        T.writeMessage oprot ("registerE2EEPublicKey", T.M_REPLY, seqid) $
          write_RegisterE2EEPublicKey_result oprot res)
      (\e  -> do
        let res = default_RegisterE2EEPublicKey_result{registerE2EEPublicKey_result_e = P.Just e}
        T.writeMessage oprot ("registerE2EEPublicKey", T.M_REPLY, seqid) $
          write_RegisterE2EEPublicKey_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerE2EEPublicKey", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getE2EEPublicKeys (seqid, iprot, oprot, handler) = do
  args <- read_GetE2EEPublicKeys_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getE2EEPublicKeys handler
        let res = default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_success = val}
        T.writeMessage oprot ("getE2EEPublicKeys", T.M_REPLY, seqid) $
          write_GetE2EEPublicKeys_result oprot res)
      (\e  -> do
        let res = default_GetE2EEPublicKeys_result{getE2EEPublicKeys_result_e = P.Just e}
        T.writeMessage oprot ("getE2EEPublicKeys", T.M_REPLY, seqid) $
          write_GetE2EEPublicKeys_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getE2EEPublicKeys", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getE2EEPublicKeysEx (seqid, iprot, oprot, handler) = do
  args <- read_GetE2EEPublicKeysEx_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getE2EEPublicKeysEx handler (getE2EEPublicKeysEx_args_ignoreE2EEStatus args)
        let res = default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_success = val}
        T.writeMessage oprot ("getE2EEPublicKeysEx", T.M_REPLY, seqid) $
          write_GetE2EEPublicKeysEx_result oprot res)
      (\e  -> do
        let res = default_GetE2EEPublicKeysEx_result{getE2EEPublicKeysEx_result_e = P.Just e}
        T.writeMessage oprot ("getE2EEPublicKeysEx", T.M_REPLY, seqid) $
          write_GetE2EEPublicKeysEx_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getE2EEPublicKeysEx", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getReadMessageOpsInBulk (seqid, iprot, oprot, handler) = do
  args <- read_GetReadMessageOpsInBulk_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getReadMessageOpsInBulk handler (getReadMessageOpsInBulk_args_chatIds args)
        let res = default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_success = val}
        T.writeMessage oprot ("getReadMessageOpsInBulk", T.M_REPLY, seqid) $
          write_GetReadMessageOpsInBulk_result oprot res)
      (\e  -> do
        let res = default_GetReadMessageOpsInBulk_result{getReadMessageOpsInBulk_result_e = P.Just e}
        T.writeMessage oprot ("getReadMessageOpsInBulk", T.M_REPLY, seqid) $
          write_GetReadMessageOpsInBulk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getReadMessageOpsInBulk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendEvent (seqid, iprot, oprot, handler) = do
  args <- read_SendEvent_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendEvent handler (sendEvent_args_seq args) (sendEvent_args_message args)
        let res = default_SendEvent_result{sendEvent_result_success = val}
        T.writeMessage oprot ("sendEvent", T.M_REPLY, seqid) $
          write_SendEvent_result oprot res)
      (\e  -> do
        let res = default_SendEvent_result{sendEvent_result_e = P.Just e}
        T.writeMessage oprot ("sendEvent", T.M_REPLY, seqid) $
          write_SendEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessage (seqid, iprot, oprot, handler) = do
  args <- read_SendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessage handler (sendMessage_args_seq args) (sendMessage_args_message args)
        let res = default_SendMessage_result{sendMessage_result_success = val}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res)
      (\e  -> do
        let res = default_SendMessage_result{sendMessage_result_e = P.Just e}
        T.writeMessage oprot ("sendMessage", T.M_REPLY, seqid) $
          write_SendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageIgnored (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageIgnored_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendMessageIgnored handler (sendMessageIgnored_args_seq args) (sendMessageIgnored_args_consumer args) (sendMessageIgnored_args_messageIds args)
        let res = default_SendMessageIgnored_result
        T.writeMessage oprot ("sendMessageIgnored", T.M_REPLY, seqid) $
          write_SendMessageIgnored_result oprot res)
      (\e  -> do
        let res = default_SendMessageIgnored_result{sendMessageIgnored_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageIgnored", T.M_REPLY, seqid) $
          write_SendMessageIgnored_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageIgnored", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageReceipt (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageReceipt_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendMessageReceipt handler (sendMessageReceipt_args_seq args) (sendMessageReceipt_args_consumer args) (sendMessageReceipt_args_messageIds args)
        let res = default_SendMessageReceipt_result
        T.writeMessage oprot ("sendMessageReceipt", T.M_REPLY, seqid) $
          write_SendMessageReceipt_result oprot res)
      (\e  -> do
        let res = default_SendMessageReceipt_result{sendMessageReceipt_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageReceipt", T.M_REPLY, seqid) $
          write_SendMessageReceipt_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageReceipt", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByMetaTag (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByMetaTag_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByMetaTag handler (findContactByMetaTag_args_userid args) (findContactByMetaTag_args_reference args)
        let res = default_FindContactByMetaTag_result{findContactByMetaTag_result_success = val}
        T.writeMessage oprot ("findContactByMetaTag", T.M_REPLY, seqid) $
          write_FindContactByMetaTag_result oprot res)
      (\e  -> do
        let res = default_FindContactByMetaTag_result{findContactByMetaTag_result_e = P.Just e}
        T.writeMessage oprot ("findContactByMetaTag", T.M_REPLY, seqid) $
          write_FindContactByMetaTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByMetaTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageToMyHome (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageToMyHome_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageToMyHome handler (sendMessageToMyHome_args_seq args) (sendMessageToMyHome_args_message args)
        let res = default_SendMessageToMyHome_result{sendMessageToMyHome_result_success = val}
        T.writeMessage oprot ("sendMessageToMyHome", T.M_REPLY, seqid) $
          write_SendMessageToMyHome_result oprot res)
      (\e  -> do
        let res = default_SendMessageToMyHome_result{sendMessageToMyHome_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageToMyHome", T.M_REPLY, seqid) $
          write_SendMessageToMyHome_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageToMyHome", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setBuddyLocation (seqid, iprot, oprot, handler) = do
  args <- read_SetBuddyLocation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setBuddyLocation handler (setBuddyLocation_args_mid args) (setBuddyLocation_args_index args) (setBuddyLocation_args_location args)
        let res = default_SetBuddyLocation_result
        T.writeMessage oprot ("setBuddyLocation", T.M_REPLY, seqid) $
          write_SetBuddyLocation_result oprot res)
      (\e  -> do
        let res = default_SetBuddyLocation_result{setBuddyLocation_result_e = P.Just e}
        T.writeMessage oprot ("setBuddyLocation", T.M_REPLY, seqid) $
          write_SetBuddyLocation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setBuddyLocation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_SetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setIdentityCredential handler (setIdentityCredential_args_identifier args) (setIdentityCredential_args_verifier args) (setIdentityCredential_args_provider args)
        let res = default_SetIdentityCredential_result
        T.writeMessage oprot ("setIdentityCredential", T.M_REPLY, seqid) $
          write_SetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_SetIdentityCredential_result{setIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("setIdentityCredential", T.M_REPLY, seqid) $
          write_SetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setNotificationsEnabled (seqid, iprot, oprot, handler) = do
  args <- read_SetNotificationsEnabled_args iprot
  (X.catch
    (X.catch
      (do
        Iface.setNotificationsEnabled handler (setNotificationsEnabled_args_reqSeq args) (setNotificationsEnabled_args_type args) (setNotificationsEnabled_args_target args) (setNotificationsEnabled_args_enablement args)
        let res = default_SetNotificationsEnabled_result
        T.writeMessage oprot ("setNotificationsEnabled", T.M_REPLY, seqid) $
          write_SetNotificationsEnabled_result oprot res)
      (\e  -> do
        let res = default_SetNotificationsEnabled_result{setNotificationsEnabled_result_e = P.Just e}
        T.writeMessage oprot ("setNotificationsEnabled", T.M_REPLY, seqid) $
          write_SetNotificationsEnabled_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setNotificationsEnabled", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_startUpdateVerification (seqid, iprot, oprot, handler) = do
  args <- read_StartUpdateVerification_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.startUpdateVerification handler (startUpdateVerification_args_region args) (startUpdateVerification_args_carrier args) (startUpdateVerification_args_phone args) (startUpdateVerification_args_udidHash args) (startUpdateVerification_args_deviceInfo args) (startUpdateVerification_args_networkCode args) (startUpdateVerification_args_locale args)
        let res = default_StartUpdateVerification_result{startUpdateVerification_result_success = val}
        T.writeMessage oprot ("startUpdateVerification", T.M_REPLY, seqid) $
          write_StartUpdateVerification_result oprot res)
      (\e  -> do
        let res = default_StartUpdateVerification_result{startUpdateVerification_result_e = P.Just e}
        T.writeMessage oprot ("startUpdateVerification", T.M_REPLY, seqid) $
          write_StartUpdateVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("startUpdateVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_startVerification (seqid, iprot, oprot, handler) = do
  args <- read_StartVerification_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.startVerification handler (startVerification_args_region args) (startVerification_args_carrier args) (startVerification_args_phone args) (startVerification_args_udidHash args) (startVerification_args_deviceInfo args) (startVerification_args_networkCode args) (startVerification_args_mid args) (startVerification_args_locale args) (startVerification_args_simInfo args) (startVerification_args_oldUdidHash args)
        let res = default_StartVerification_result{startVerification_result_success = val}
        T.writeMessage oprot ("startVerification", T.M_REPLY, seqid) $
          write_StartVerification_result oprot res)
      (\e  -> do
        let res = default_StartVerification_result{startVerification_result_e = P.Just e}
        T.writeMessage oprot ("startVerification", T.M_REPLY, seqid) $
          write_StartVerification_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("startVerification", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateGroupPreferenceAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateGroupPreferenceAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateGroupPreferenceAttribute handler (updateGroupPreferenceAttribute_args_reqSeq args) (updateGroupPreferenceAttribute_args_groupMid args) (updateGroupPreferenceAttribute_args_updatedAttrs args)
        let res = default_UpdateGroupPreferenceAttribute_result
        T.writeMessage oprot ("updateGroupPreferenceAttribute", T.M_REPLY, seqid) $
          write_UpdateGroupPreferenceAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateGroupPreferenceAttribute_result{updateGroupPreferenceAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateGroupPreferenceAttribute", T.M_REPLY, seqid) $
          write_UpdateGroupPreferenceAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateGroupPreferenceAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createRoomV2 (seqid, iprot, oprot, handler) = do
  args <- read_CreateRoomV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createRoomV2 handler (createRoomV2_args_reqSeq args) (createRoomV2_args_contactIds args)
        let res = default_CreateRoomV2_result{createRoomV2_result_success = val}
        T.writeMessage oprot ("createRoomV2", T.M_REPLY, seqid) $
          write_CreateRoomV2_result oprot res)
      (\e  -> do
        let res = default_CreateRoomV2_result{createRoomV2_result_e = P.Just e}
        T.writeMessage oprot ("createRoomV2", T.M_REPLY, seqid) $
          write_CreateRoomV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createRoomV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_storeUpdateProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_StoreUpdateProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.storeUpdateProfileAttribute handler (storeUpdateProfileAttribute_args_seq args) (storeUpdateProfileAttribute_args_profileAttribute args) (storeUpdateProfileAttribute_args_value args)
        let res = default_StoreUpdateProfileAttribute_result
        T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_REPLY, seqid) $
          write_StoreUpdateProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_StoreUpdateProfileAttribute_result{storeUpdateProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_REPLY, seqid) $
          write_StoreUpdateProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("storeUpdateProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncContactBySnsIds (seqid, iprot, oprot, handler) = do
  args <- read_SyncContactBySnsIds_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncContactBySnsIds handler (syncContactBySnsIds_args_reqSeq args) (syncContactBySnsIds_args_modifications args)
        let res = default_SyncContactBySnsIds_result{syncContactBySnsIds_result_success = val}
        T.writeMessage oprot ("syncContactBySnsIds", T.M_REPLY, seqid) $
          write_SyncContactBySnsIds_result oprot res)
      (\e  -> do
        let res = default_SyncContactBySnsIds_result{syncContactBySnsIds_result_e = P.Just e}
        T.writeMessage oprot ("syncContactBySnsIds", T.M_REPLY, seqid) $
          write_SyncContactBySnsIds_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncContactBySnsIds", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_syncContacts (seqid, iprot, oprot, handler) = do
  args <- read_SyncContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.syncContacts handler (syncContacts_args_reqSeq args) (syncContacts_args_localContacts args)
        let res = default_SyncContacts_result{syncContacts_result_success = val}
        T.writeMessage oprot ("syncContacts", T.M_REPLY, seqid) $
          write_SyncContacts_result oprot res)
      (\e  -> do
        let res = default_SyncContacts_result{syncContacts_result_e = P.Just e}
        T.writeMessage oprot ("syncContacts", T.M_REPLY, seqid) $
          write_SyncContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("syncContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_trySendMessage (seqid, iprot, oprot, handler) = do
  args <- read_TrySendMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.trySendMessage handler (trySendMessage_args_seq args) (trySendMessage_args_message args)
        let res = default_TrySendMessage_result{trySendMessage_result_success = val}
        T.writeMessage oprot ("trySendMessage", T.M_REPLY, seqid) $
          write_TrySendMessage_result oprot res)
      (\e  -> do
        let res = default_TrySendMessage_result{trySendMessage_result_e = P.Just e}
        T.writeMessage oprot ("trySendMessage", T.M_REPLY, seqid) $
          write_TrySendMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("trySendMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNextMessagesV2 (seqid, iprot, oprot, handler) = do
  args <- read_GetNextMessagesV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNextMessagesV2 handler (getNextMessagesV2_args_messageBoxId args) (getNextMessagesV2_args_startMessageId args) (getNextMessagesV2_args_messagesCount args)
        let res = default_GetNextMessagesV2_result{getNextMessagesV2_result_success = val}
        T.writeMessage oprot ("getNextMessagesV2", T.M_REPLY, seqid) $
          write_GetNextMessagesV2_result oprot res)
      (\e  -> do
        let res = default_GetNextMessagesV2_result{getNextMessagesV2_result_e = P.Just e}
        T.writeMessage oprot ("getNextMessagesV2", T.M_REPLY, seqid) $
          write_GetNextMessagesV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNextMessagesV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMessageBoxCompactWrapUpV2 (seqid, iprot, oprot, handler) = do
  args <- read_GetMessageBoxCompactWrapUpV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMessageBoxCompactWrapUpV2 handler (getMessageBoxCompactWrapUpV2_args_messageBoxId args)
        let res = default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_success = val}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpV2", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpV2_result oprot res)
      (\e  -> do
        let res = default_GetMessageBoxCompactWrapUpV2_result{getMessageBoxCompactWrapUpV2_result_e = P.Just e}
        T.writeMessage oprot ("getMessageBoxCompactWrapUpV2", T.M_REPLY, seqid) $
          write_GetMessageBoxCompactWrapUpV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMessageBoxCompactWrapUpV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRecentMessagesV2 (seqid, iprot, oprot, handler) = do
  args <- read_GetRecentMessagesV2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRecentMessagesV2 handler (getRecentMessagesV2_args_messageBoxId args) (getRecentMessagesV2_args_messagesCount args)
        let res = default_GetRecentMessagesV2_result{getRecentMessagesV2_result_success = val}
        T.writeMessage oprot ("getRecentMessagesV2", T.M_REPLY, seqid) $
          write_GetRecentMessagesV2_result oprot res)
      (\e  -> do
        let res = default_GetRecentMessagesV2_result{getRecentMessagesV2_result_e = P.Just e}
        T.writeMessage oprot ("getRecentMessagesV2", T.M_REPLY, seqid) $
          write_GetRecentMessagesV2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRecentMessagesV2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_validateContactsOnBot (seqid, iprot, oprot, handler) = do
  args <- read_ValidateContactsOnBot_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.validateContactsOnBot handler (validateContactsOnBot_args_contacts args)
        let res = default_ValidateContactsOnBot_result{validateContactsOnBot_result_success = val}
        T.writeMessage oprot ("validateContactsOnBot", T.M_REPLY, seqid) $
          write_ValidateContactsOnBot_result oprot res)
      (\e  -> do
        let res = default_ValidateContactsOnBot_result{validateContactsOnBot_result_e = P.Just e}
        T.writeMessage oprot ("validateContactsOnBot", T.M_REPLY, seqid) $
          write_ValidateContactsOnBot_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("validateContactsOnBot", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_tryFriendRequest (seqid, iprot, oprot, handler) = do
  args <- read_TryFriendRequest_args iprot
  (X.catch
    (X.catch
      (do
        Iface.tryFriendRequest handler (tryFriendRequest_args_midOrEMid args) (tryFriendRequest_args_method args) (tryFriendRequest_args_friendRequestParams args)
        let res = default_TryFriendRequest_result
        T.writeMessage oprot ("tryFriendRequest", T.M_REPLY, seqid) $
          write_TryFriendRequest_result oprot res)
      (\e  -> do
        let res = default_TryFriendRequest_result{tryFriendRequest_result_e = P.Just e}
        T.writeMessage oprot ("tryFriendRequest", T.M_REPLY, seqid) $
          write_TryFriendRequest_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("tryFriendRequest", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unblockContact (seqid, iprot, oprot, handler) = do
  args <- read_UnblockContact_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unblockContact handler (unblockContact_args_reqSeq args) (unblockContact_args_id args)
        let res = default_UnblockContact_result
        T.writeMessage oprot ("unblockContact", T.M_REPLY, seqid) $
          write_UnblockContact_result oprot res)
      (\e  -> do
        let res = default_UnblockContact_result{unblockContact_result_e = P.Just e}
        T.writeMessage oprot ("unblockContact", T.M_REPLY, seqid) $
          write_UnblockContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unblockContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unblockRecommendation (seqid, iprot, oprot, handler) = do
  args <- read_UnblockRecommendation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.unblockRecommendation handler (unblockRecommendation_args_reqSeq args) (unblockRecommendation_args_id args)
        let res = default_UnblockRecommendation_result
        T.writeMessage oprot ("unblockRecommendation", T.M_REPLY, seqid) $
          write_UnblockRecommendation_result oprot res)
      (\e  -> do
        let res = default_UnblockRecommendation_result{unblockRecommendation_result_e = P.Just e}
        T.writeMessage oprot ("unblockRecommendation", T.M_REPLY, seqid) $
          write_UnblockRecommendation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unblockRecommendation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unregisterUserAndDevice (seqid, iprot, oprot, handler) = do
  args <- read_UnregisterUserAndDevice_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.unregisterUserAndDevice handler
        let res = default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_success = val}
        T.writeMessage oprot ("unregisterUserAndDevice", T.M_REPLY, seqid) $
          write_UnregisterUserAndDevice_result oprot res)
      (\e  -> do
        let res = default_UnregisterUserAndDevice_result{unregisterUserAndDevice_result_e = P.Just e}
        T.writeMessage oprot ("unregisterUserAndDevice", T.M_REPLY, seqid) $
          write_UnregisterUserAndDevice_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unregisterUserAndDevice", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateApnsDeviceToken (seqid, iprot, oprot, handler) = do
  args <- read_UpdateApnsDeviceToken_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateApnsDeviceToken handler (updateApnsDeviceToken_args_apnsDeviceToken args)
        let res = default_UpdateApnsDeviceToken_result
        T.writeMessage oprot ("updateApnsDeviceToken", T.M_REPLY, seqid) $
          write_UpdateApnsDeviceToken_result oprot res)
      (\e  -> do
        let res = default_UpdateApnsDeviceToken_result{updateApnsDeviceToken_result_e = P.Just e}
        T.writeMessage oprot ("updateApnsDeviceToken", T.M_REPLY, seqid) $
          write_UpdateApnsDeviceToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateApnsDeviceToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateBuddySetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateBuddySetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateBuddySetting handler (updateBuddySetting_args_key args) (updateBuddySetting_args_value args)
        let res = default_UpdateBuddySetting_result
        T.writeMessage oprot ("updateBuddySetting", T.M_REPLY, seqid) $
          write_UpdateBuddySetting_result oprot res)
      (\e  -> do
        let res = default_UpdateBuddySetting_result{updateBuddySetting_result_e = P.Just e}
        T.writeMessage oprot ("updateBuddySetting", T.M_REPLY, seqid) $
          write_UpdateBuddySetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateBuddySetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateC2DMRegistrationId (seqid, iprot, oprot, handler) = do
  args <- read_UpdateC2DMRegistrationId_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateC2DMRegistrationId handler (updateC2DMRegistrationId_args_registrationId args)
        let res = default_UpdateC2DMRegistrationId_result
        T.writeMessage oprot ("updateC2DMRegistrationId", T.M_REPLY, seqid) $
          write_UpdateC2DMRegistrationId_result oprot res)
      (\e  -> do
        let res = default_UpdateC2DMRegistrationId_result{updateC2DMRegistrationId_result_e = P.Just e}
        T.writeMessage oprot ("updateC2DMRegistrationId", T.M_REPLY, seqid) $
          write_UpdateC2DMRegistrationId_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateC2DMRegistrationId", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateContactSetting (seqid, iprot, oprot, handler) = do
  args <- read_UpdateContactSetting_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateContactSetting handler (updateContactSetting_args_reqSeq args) (updateContactSetting_args_mid args) (updateContactSetting_args_flag args) (updateContactSetting_args_value args)
        let res = default_UpdateContactSetting_result
        T.writeMessage oprot ("updateContactSetting", T.M_REPLY, seqid) $
          write_UpdateContactSetting_result oprot res)
      (\e  -> do
        let res = default_UpdateContactSetting_result{updateContactSetting_result_e = P.Just e}
        T.writeMessage oprot ("updateContactSetting", T.M_REPLY, seqid) $
          write_UpdateContactSetting_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateContactSetting", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateCustomModeSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateCustomModeSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateCustomModeSettings handler (updateCustomModeSettings_args_customMode args) (updateCustomModeSettings_args_paramMap args)
        let res = default_UpdateCustomModeSettings_result
        T.writeMessage oprot ("updateCustomModeSettings", T.M_REPLY, seqid) $
          write_UpdateCustomModeSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateCustomModeSettings_result{updateCustomModeSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateCustomModeSettings", T.M_REPLY, seqid) $
          write_UpdateCustomModeSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateCustomModeSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateDeviceInfo (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDeviceInfo_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateDeviceInfo handler (updateDeviceInfo_args_deviceUid args) (updateDeviceInfo_args_deviceInfo args)
        let res = default_UpdateDeviceInfo_result
        T.writeMessage oprot ("updateDeviceInfo", T.M_REPLY, seqid) $
          write_UpdateDeviceInfo_result oprot res)
      (\e  -> do
        let res = default_UpdateDeviceInfo_result{updateDeviceInfo_result_e = P.Just e}
        T.writeMessage oprot ("updateDeviceInfo", T.M_REPLY, seqid) $
          write_UpdateDeviceInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateDeviceInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateGroup (seqid, iprot, oprot, handler) = do
  args <- read_UpdateGroup_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateGroup handler (updateGroup_args_reqSeq args) (updateGroup_args_group args)
        let res = default_UpdateGroup_result
        T.writeMessage oprot ("updateGroup", T.M_REPLY, seqid) $
          write_UpdateGroup_result oprot res)
      (\e  -> do
        let res = default_UpdateGroup_result{updateGroup_result_e = P.Just e}
        T.writeMessage oprot ("updateGroup", T.M_REPLY, seqid) $
          write_UpdateGroup_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateGroup", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNotificationToken (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNotificationToken_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateNotificationToken handler (updateNotificationToken_args_type args) (updateNotificationToken_args_token args)
        let res = default_UpdateNotificationToken_result
        T.writeMessage oprot ("updateNotificationToken", T.M_REPLY, seqid) $
          write_UpdateNotificationToken_result oprot res)
      (\e  -> do
        let res = default_UpdateNotificationToken_result{updateNotificationToken_result_e = P.Just e}
        T.writeMessage oprot ("updateNotificationToken", T.M_REPLY, seqid) $
          write_UpdateNotificationToken_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNotificationToken", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNotificationTokenWithBytes (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNotificationTokenWithBytes_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateNotificationTokenWithBytes handler (updateNotificationTokenWithBytes_args_type args) (updateNotificationTokenWithBytes_args_token args)
        let res = default_UpdateNotificationTokenWithBytes_result
        T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_REPLY, seqid) $
          write_UpdateNotificationTokenWithBytes_result oprot res)
      (\e  -> do
        let res = default_UpdateNotificationTokenWithBytes_result{updateNotificationTokenWithBytes_result_e = P.Just e}
        T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_REPLY, seqid) $
          write_UpdateNotificationTokenWithBytes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNotificationTokenWithBytes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfile (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfile_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfile handler (updateProfile_args_reqSeq args) (updateProfile_args_profile args)
        let res = default_UpdateProfile_result
        T.writeMessage oprot ("updateProfile", T.M_REPLY, seqid) $
          write_UpdateProfile_result oprot res)
      (\e  -> do
        let res = default_UpdateProfile_result{updateProfile_result_e = P.Just e}
        T.writeMessage oprot ("updateProfile", T.M_REPLY, seqid) $
          write_UpdateProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttribute handler (updateProfileAttribute_args_reqSeq args) (updateProfileAttribute_args_attr args) (updateProfileAttribute_args_value args)
        let res = default_UpdateProfileAttribute_result
        T.writeMessage oprot ("updateProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttribute_result{updateProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateRegion (seqid, iprot, oprot, handler) = do
  args <- read_UpdateRegion_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateRegion handler (updateRegion_args_region args)
        let res = default_UpdateRegion_result
        T.writeMessage oprot ("updateRegion", T.M_REPLY, seqid) $
          write_UpdateRegion_result oprot res)
      (\e  -> do
        let res = default_UpdateRegion_result{updateRegion_result_e = P.Just e}
        T.writeMessage oprot ("updateRegion", T.M_REPLY, seqid) $
          write_UpdateRegion_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateRegion", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettings (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettings_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateSettings handler (updateSettings_args_reqSeq args) (updateSettings_args_settings args)
        let res = default_UpdateSettings_result
        T.writeMessage oprot ("updateSettings", T.M_REPLY, seqid) $
          write_UpdateSettings_result oprot res)
      (\e  -> do
        let res = default_UpdateSettings_result{updateSettings_result_e = P.Just e}
        T.writeMessage oprot ("updateSettings", T.M_REPLY, seqid) $
          write_UpdateSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettings2 (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettings2_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSettings2 handler (updateSettings2_args_reqSeq args) (updateSettings2_args_settings args)
        let res = default_UpdateSettings2_result{updateSettings2_result_success = val}
        T.writeMessage oprot ("updateSettings2", T.M_REPLY, seqid) $
          write_UpdateSettings2_result oprot res)
      (\e  -> do
        let res = default_UpdateSettings2_result{updateSettings2_result_e = P.Just e}
        T.writeMessage oprot ("updateSettings2", T.M_REPLY, seqid) $
          write_UpdateSettings2_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettings2", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettingsAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettingsAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateSettingsAttribute handler (updateSettingsAttribute_args_reqSeq args) (updateSettingsAttribute_args_attr args) (updateSettingsAttribute_args_value args)
        let res = default_UpdateSettingsAttribute_result
        T.writeMessage oprot ("updateSettingsAttribute", T.M_REPLY, seqid) $
          write_UpdateSettingsAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateSettingsAttribute_result{updateSettingsAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateSettingsAttribute", T.M_REPLY, seqid) $
          write_UpdateSettingsAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettingsAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSettingsAttributes (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSettingsAttributes_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.updateSettingsAttributes handler (updateSettingsAttributes_args_reqSeq args) (updateSettingsAttributes_args_attrBitset args) (updateSettingsAttributes_args_settings args)
        let res = default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_success = val}
        T.writeMessage oprot ("updateSettingsAttributes", T.M_REPLY, seqid) $
          write_UpdateSettingsAttributes_result oprot res)
      (\e  -> do
        let res = default_UpdateSettingsAttributes_result{updateSettingsAttributes_result_e = P.Just e}
        T.writeMessage oprot ("updateSettingsAttributes", T.M_REPLY, seqid) $
          write_UpdateSettingsAttributes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSettingsAttributes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_VerifyIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        Iface.verifyIdentityCredential handler (verifyIdentityCredential_args_identityProvider args) (verifyIdentityCredential_args_identifier args) (verifyIdentityCredential_args_password args)
        let res = default_VerifyIdentityCredential_result
        T.writeMessage oprot ("verifyIdentityCredential", T.M_REPLY, seqid) $
          write_VerifyIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_VerifyIdentityCredential_result{verifyIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("verifyIdentityCredential", T.M_REPLY, seqid) $
          write_VerifyIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyIdentityCredentialWithResult (seqid, iprot, oprot, handler) = do
  args <- read_VerifyIdentityCredentialWithResult_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyIdentityCredentialWithResult handler (verifyIdentityCredentialWithResult_args_identityCredential args)
        let res = default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_success = val}
        T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_REPLY, seqid) $
          write_VerifyIdentityCredentialWithResult_result oprot res)
      (\e  -> do
        let res = default_VerifyIdentityCredentialWithResult_result{verifyIdentityCredentialWithResult_result_e = P.Just e}
        T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_REPLY, seqid) $
          write_VerifyIdentityCredentialWithResult_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyIdentityCredentialWithResult", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyPhone (seqid, iprot, oprot, handler) = do
  args <- read_VerifyPhone_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyPhone handler (verifyPhone_args_sessionId args) (verifyPhone_args_pinCode args) (verifyPhone_args_udidHash args)
        let res = default_VerifyPhone_result{verifyPhone_result_success = val}
        T.writeMessage oprot ("verifyPhone", T.M_REPLY, seqid) $
          write_VerifyPhone_result oprot res)
      (\e  -> do
        let res = default_VerifyPhone_result{verifyPhone_result_e = P.Just e}
        T.writeMessage oprot ("verifyPhone", T.M_REPLY, seqid) $
          write_VerifyPhone_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyPhone", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_verifyQrcode (seqid, iprot, oprot, handler) = do
  args <- read_VerifyQrcode_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.verifyQrcode handler (verifyQrcode_args_verifier args) (verifyQrcode_args_pinCode args)
        let res = default_VerifyQrcode_result{verifyQrcode_result_success = val}
        T.writeMessage oprot ("verifyQrcode", T.M_REPLY, seqid) $
          write_VerifyQrcode_result oprot res)
      (\e  -> do
        let res = default_VerifyQrcode_result{verifyQrcode_result_e = P.Just e}
        T.writeMessage oprot ("verifyQrcode", T.M_REPLY, seqid) $
          write_VerifyQrcode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("verifyQrcode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getChatRoomAnnouncementsBulk" -> process_getChatRoomAnnouncementsBulk (seqid,iprot,oprot,handler)
  "getChatRoomAnnouncements" -> process_getChatRoomAnnouncements (seqid,iprot,oprot,handler)
  "createChatRoomAnnouncement" -> process_createChatRoomAnnouncement (seqid,iprot,oprot,handler)
  "removeChatRoomAnnouncement" -> process_removeChatRoomAnnouncement (seqid,iprot,oprot,handler)
  "unsendMessage" -> process_unsendMessage (seqid,iprot,oprot,handler)
  "getGroupWithoutMembers" -> process_getGroupWithoutMembers (seqid,iprot,oprot,handler)
  "requestResendMessage" -> process_requestResendMessage (seqid,iprot,oprot,handler)
  "respondResendMessage" -> process_respondResendMessage (seqid,iprot,oprot,handler)
  "acceptGroupInvitation" -> process_acceptGroupInvitation (seqid,iprot,oprot,handler)
  "acceptGroupInvitationByTicket" -> process_acceptGroupInvitationByTicket (seqid,iprot,oprot,handler)
  "acceptProximityMatches" -> process_acceptProximityMatches (seqid,iprot,oprot,handler)
  "acquireCallRoute" -> process_acquireCallRoute (seqid,iprot,oprot,handler)
  "acquireCallTicket" -> process_acquireCallTicket (seqid,iprot,oprot,handler)
  "acquireEncryptedAccessToken" -> process_acquireEncryptedAccessToken (seqid,iprot,oprot,handler)
  "addSnsId" -> process_addSnsId (seqid,iprot,oprot,handler)
  "blockContact" -> process_blockContact (seqid,iprot,oprot,handler)
  "blockRecommendation" -> process_blockRecommendation (seqid,iprot,oprot,handler)
  "cancelGroupInvitation" -> process_cancelGroupInvitation (seqid,iprot,oprot,handler)
  "changeVerificationMethod" -> process_changeVerificationMethod (seqid,iprot,oprot,handler)
  "clearIdentityCredential" -> process_clearIdentityCredential (seqid,iprot,oprot,handler)
  "clearMessageBox" -> process_clearMessageBox (seqid,iprot,oprot,handler)
  "closeProximityMatch" -> process_closeProximityMatch (seqid,iprot,oprot,handler)
  "commitSendMessage" -> process_commitSendMessage (seqid,iprot,oprot,handler)
  "commitSendMessages" -> process_commitSendMessages (seqid,iprot,oprot,handler)
  "commitUpdateProfile" -> process_commitUpdateProfile (seqid,iprot,oprot,handler)
  "confirmEmail" -> process_confirmEmail (seqid,iprot,oprot,handler)
  "createGroup" -> process_createGroup (seqid,iprot,oprot,handler)
  "createQrcodeBase64Image" -> process_createQrcodeBase64Image (seqid,iprot,oprot,handler)
  "createRoom" -> process_createRoom (seqid,iprot,oprot,handler)
  "createSession" -> process_createSession (seqid,iprot,oprot,handler)
  "fetchAnnouncements" -> process_fetchAnnouncements (seqid,iprot,oprot,handler)
  "fetchMessages" -> process_fetchMessages (seqid,iprot,oprot,handler)
  "fetchOperations" -> process_fetchOperations (seqid,iprot,oprot,handler)
  "fetchOps" -> process_fetchOps (seqid,iprot,oprot,handler)
  "findAndAddContactsByEmail" -> process_findAndAddContactsByEmail (seqid,iprot,oprot,handler)
  "findAndAddContactsByMid" -> process_findAndAddContactsByMid (seqid,iprot,oprot,handler)
  "findGroupByTicketV2" -> process_findGroupByTicketV2 (seqid,iprot,oprot,handler)
  "findAndAddContactsByPhone" -> process_findAndAddContactsByPhone (seqid,iprot,oprot,handler)
  "getFriendRequests" -> process_getFriendRequests (seqid,iprot,oprot,handler)
  "removeFriendRequest" -> process_removeFriendRequest (seqid,iprot,oprot,handler)
  "findAndAddContactsByUserid" -> process_findAndAddContactsByUserid (seqid,iprot,oprot,handler)
  "findContactByUserid" -> process_findContactByUserid (seqid,iprot,oprot,handler)
  "findContactByUserTicket" -> process_findContactByUserTicket (seqid,iprot,oprot,handler)
  "findContactsByEmail" -> process_findContactsByEmail (seqid,iprot,oprot,handler)
  "findContactsByPhone" -> process_findContactsByPhone (seqid,iprot,oprot,handler)
  "findSnsIdUserStatus" -> process_findSnsIdUserStatus (seqid,iprot,oprot,handler)
  "finishUpdateVerification" -> process_finishUpdateVerification (seqid,iprot,oprot,handler)
  "generateUserTicket" -> process_generateUserTicket (seqid,iprot,oprot,handler)
  "destroyMessage" -> process_destroyMessage (seqid,iprot,oprot,handler)
  "getAcceptedProximityMatches" -> process_getAcceptedProximityMatches (seqid,iprot,oprot,handler)
  "getActiveBuddySubscriberIds" -> process_getActiveBuddySubscriberIds (seqid,iprot,oprot,handler)
  "getAllContactIds" -> process_getAllContactIds (seqid,iprot,oprot,handler)
  "getAuthQrcode" -> process_getAuthQrcode (seqid,iprot,oprot,handler)
  "getBlockedContactIds" -> process_getBlockedContactIds (seqid,iprot,oprot,handler)
  "registerWithPhoneNumber" -> process_registerWithPhoneNumber (seqid,iprot,oprot,handler)
  "registerWithPhoneNumberAndPassword" -> process_registerWithPhoneNumberAndPassword (seqid,iprot,oprot,handler)
  "getAnalyticsInfo" -> process_getAnalyticsInfo (seqid,iprot,oprot,handler)
  "reportClientStatistics" -> process_reportClientStatistics (seqid,iprot,oprot,handler)
  "verifyPhoneNumberForLogin" -> process_verifyPhoneNumberForLogin (seqid,iprot,oprot,handler)
  "verifyPhoneNumber" -> process_verifyPhoneNumber (seqid,iprot,oprot,handler)
  "getBlockedContactIdsByRange" -> process_getBlockedContactIdsByRange (seqid,iprot,oprot,handler)
  "getBlockedRecommendationIds" -> process_getBlockedRecommendationIds (seqid,iprot,oprot,handler)
  "getBuddyBlockerIds" -> process_getBuddyBlockerIds (seqid,iprot,oprot,handler)
  "getBuddyLocation" -> process_getBuddyLocation (seqid,iprot,oprot,handler)
  "getCompactContactsModifiedSince" -> process_getCompactContactsModifiedSince (seqid,iprot,oprot,handler)
  "getCompactGroup" -> process_getCompactGroup (seqid,iprot,oprot,handler)
  "getCompactRoom" -> process_getCompactRoom (seqid,iprot,oprot,handler)
  "getContact" -> process_getContact (seqid,iprot,oprot,handler)
  "getContacts" -> process_getContacts (seqid,iprot,oprot,handler)
  "getContactWithFriendRequestStatus" -> process_getContactWithFriendRequestStatus (seqid,iprot,oprot,handler)
  "getCountryWithRequestIp" -> process_getCountryWithRequestIp (seqid,iprot,oprot,handler)
  "getFavoriteMids" -> process_getFavoriteMids (seqid,iprot,oprot,handler)
  "getGroup" -> process_getGroup (seqid,iprot,oprot,handler)
  "getGroupIdsInvited" -> process_getGroupIdsInvited (seqid,iprot,oprot,handler)
  "getGroupIdsJoined" -> process_getGroupIdsJoined (seqid,iprot,oprot,handler)
  "getGroups" -> process_getGroups (seqid,iprot,oprot,handler)
  "getHiddenContactMids" -> process_getHiddenContactMids (seqid,iprot,oprot,handler)
  "getIdentityIdentifier" -> process_getIdentityIdentifier (seqid,iprot,oprot,handler)
  "getLastAnnouncementIndex" -> process_getLastAnnouncementIndex (seqid,iprot,oprot,handler)
  "getLastOpRevision" -> process_getLastOpRevision (seqid,iprot,oprot,handler)
  "getSuggestRevisions" -> process_getSuggestRevisions (seqid,iprot,oprot,handler)
  "getPreviousMessagesV2WithReadCount" -> process_getPreviousMessagesV2WithReadCount (seqid,iprot,oprot,handler)
  "getMessageBox" -> process_getMessageBox (seqid,iprot,oprot,handler)
  "getMessageBoxCompactWrapUp" -> process_getMessageBoxCompactWrapUp (seqid,iprot,oprot,handler)
  "getMessageBoxCompactWrapUpList" -> process_getMessageBoxCompactWrapUpList (seqid,iprot,oprot,handler)
  "getMessageBoxList" -> process_getMessageBoxList (seqid,iprot,oprot,handler)
  "getMessageBoxListByStatus" -> process_getMessageBoxListByStatus (seqid,iprot,oprot,handler)
  "getMessageBoxWrapUp" -> process_getMessageBoxWrapUp (seqid,iprot,oprot,handler)
  "getMessageBoxWrapUpList" -> process_getMessageBoxWrapUpList (seqid,iprot,oprot,handler)
  "getMessagesBySequenceNumber" -> process_getMessagesBySequenceNumber (seqid,iprot,oprot,handler)
  "getNextMessages" -> process_getNextMessages (seqid,iprot,oprot,handler)
  "getNotificationPolicy" -> process_getNotificationPolicy (seqid,iprot,oprot,handler)
  "getPreviousMessages" -> process_getPreviousMessages (seqid,iprot,oprot,handler)
  "getProfile" -> process_getProfile (seqid,iprot,oprot,handler)
  "getProximityMatchCandidateList" -> process_getProximityMatchCandidateList (seqid,iprot,oprot,handler)
  "getProximityMatchCandidates" -> process_getProximityMatchCandidates (seqid,iprot,oprot,handler)
  "getRecentMessages" -> process_getRecentMessages (seqid,iprot,oprot,handler)
  "getRecommendationIds" -> process_getRecommendationIds (seqid,iprot,oprot,handler)
  "getRoom" -> process_getRoom (seqid,iprot,oprot,handler)
  "getRSAKeyInfo" -> process_getRSAKeyInfo (seqid,iprot,oprot,handler)
  "getServerTime" -> process_getServerTime (seqid,iprot,oprot,handler)
  "getSessions" -> process_getSessions (seqid,iprot,oprot,handler)
  "getSettings" -> process_getSettings (seqid,iprot,oprot,handler)
  "getGroupsV2" -> process_getGroupsV2 (seqid,iprot,oprot,handler)
  "getSettingsAttributes" -> process_getSettingsAttributes (seqid,iprot,oprot,handler)
  "getSystemConfiguration" -> process_getSystemConfiguration (seqid,iprot,oprot,handler)
  "getUserTicket" -> process_getUserTicket (seqid,iprot,oprot,handler)
  "getWapInvitation" -> process_getWapInvitation (seqid,iprot,oprot,handler)
  "invalidateUserTicket" -> process_invalidateUserTicket (seqid,iprot,oprot,handler)
  "inviteFriendsBySms" -> process_inviteFriendsBySms (seqid,iprot,oprot,handler)
  "inviteIntoGroup" -> process_inviteIntoGroup (seqid,iprot,oprot,handler)
  "inviteIntoRoom" -> process_inviteIntoRoom (seqid,iprot,oprot,handler)
  "inviteViaEmail" -> process_inviteViaEmail (seqid,iprot,oprot,handler)
  "isIdentityIdentifierAvailable" -> process_isIdentityIdentifierAvailable (seqid,iprot,oprot,handler)
  "isUseridAvailable" -> process_isUseridAvailable (seqid,iprot,oprot,handler)
  "kickoutFromGroup" -> process_kickoutFromGroup (seqid,iprot,oprot,handler)
  "reissueGroupTicket" -> process_reissueGroupTicket (seqid,iprot,oprot,handler)
  "findGroupByTicket" -> process_findGroupByTicket (seqid,iprot,oprot,handler)
  "leaveGroup" -> process_leaveGroup (seqid,iprot,oprot,handler)
  "leaveRoom" -> process_leaveRoom (seqid,iprot,oprot,handler)
  "loginWithIdentityCredential" -> process_loginWithIdentityCredential (seqid,iprot,oprot,handler)
  "loginWithIdentityCredentialForCertificate" -> process_loginWithIdentityCredentialForCertificate (seqid,iprot,oprot,handler)
  "loginWithVerifier" -> process_loginWithVerifier (seqid,iprot,oprot,handler)
  "loginWithVerifierForCerificate" -> process_loginWithVerifierForCerificate (seqid,iprot,oprot,handler)
  "loginWithVerifierForCertificate" -> process_loginWithVerifierForCertificate (seqid,iprot,oprot,handler)
  "logout" -> process_logout (seqid,iprot,oprot,handler)
  "logoutSession" -> process_logoutSession (seqid,iprot,oprot,handler)
  "noop" -> process_noop (seqid,iprot,oprot,handler)
  "notifiedRedirect" -> process_notifiedRedirect (seqid,iprot,oprot,handler)
  "notifyBuddyOnAir" -> process_notifyBuddyOnAir (seqid,iprot,oprot,handler)
  "notifyIndividualEvent" -> process_notifyIndividualEvent (seqid,iprot,oprot,handler)
  "notifyInstalled" -> process_notifyInstalled (seqid,iprot,oprot,handler)
  "notifyRegistrationComplete" -> process_notifyRegistrationComplete (seqid,iprot,oprot,handler)
  "notifySleep" -> process_notifySleep (seqid,iprot,oprot,handler)
  "notifyUpdated" -> process_notifyUpdated (seqid,iprot,oprot,handler)
  "openProximityMatch" -> process_openProximityMatch (seqid,iprot,oprot,handler)
  "registerBuddyUser" -> process_registerBuddyUser (seqid,iprot,oprot,handler)
  "registerBuddyUserid" -> process_registerBuddyUserid (seqid,iprot,oprot,handler)
  "registerDevice" -> process_registerDevice (seqid,iprot,oprot,handler)
  "registerDeviceWithIdentityCredential" -> process_registerDeviceWithIdentityCredential (seqid,iprot,oprot,handler)
  "registerDeviceWithoutPhoneNumber" -> process_registerDeviceWithoutPhoneNumber (seqid,iprot,oprot,handler)
  "registerDeviceWithoutPhoneNumberWithIdentityCredential" -> process_registerDeviceWithoutPhoneNumberWithIdentityCredential (seqid,iprot,oprot,handler)
  "registerUserid" -> process_registerUserid (seqid,iprot,oprot,handler)
  "registerWapDevice" -> process_registerWapDevice (seqid,iprot,oprot,handler)
  "registerWithExistingSnsIdAndIdentityCredential" -> process_registerWithExistingSnsIdAndIdentityCredential (seqid,iprot,oprot,handler)
  "registerWithSnsId" -> process_registerWithSnsId (seqid,iprot,oprot,handler)
  "registerWithSnsIdAndIdentityCredential" -> process_registerWithSnsIdAndIdentityCredential (seqid,iprot,oprot,handler)
  "reissueDeviceCredential" -> process_reissueDeviceCredential (seqid,iprot,oprot,handler)
  "reissueUserTicket" -> process_reissueUserTicket (seqid,iprot,oprot,handler)
  "getMessageReadRange" -> process_getMessageReadRange (seqid,iprot,oprot,handler)
  "rejectGroupInvitation" -> process_rejectGroupInvitation (seqid,iprot,oprot,handler)
  "releaseSession" -> process_releaseSession (seqid,iprot,oprot,handler)
  "removeAllMessages" -> process_removeAllMessages (seqid,iprot,oprot,handler)
  "removeBuddyLocation" -> process_removeBuddyLocation (seqid,iprot,oprot,handler)
  "removeMessage" -> process_removeMessage (seqid,iprot,oprot,handler)
  "makeUserAddMyselfAsContact" -> process_makeUserAddMyselfAsContact (seqid,iprot,oprot,handler)
  "removeMessageFromMyHome" -> process_removeMessageFromMyHome (seqid,iprot,oprot,handler)
  "removeSnsId" -> process_removeSnsId (seqid,iprot,oprot,handler)
  "report" -> process_report (seqid,iprot,oprot,handler)
  "reportContacts" -> process_reportContacts (seqid,iprot,oprot,handler)
  "reportGroups" -> process_reportGroups (seqid,iprot,oprot,handler)
  "reportProfile" -> process_reportProfile (seqid,iprot,oprot,handler)
  "reportRooms" -> process_reportRooms (seqid,iprot,oprot,handler)
  "findAndAddContactByMetaTag" -> process_findAndAddContactByMetaTag (seqid,iprot,oprot,handler)
  "reportSettings" -> process_reportSettings (seqid,iprot,oprot,handler)
  "reportSpam" -> process_reportSpam (seqid,iprot,oprot,handler)
  "reportSpammer" -> process_reportSpammer (seqid,iprot,oprot,handler)
  "requestAccountPasswordReset" -> process_requestAccountPasswordReset (seqid,iprot,oprot,handler)
  "requestEmailConfirmation" -> process_requestEmailConfirmation (seqid,iprot,oprot,handler)
  "requestIdentityUnbind" -> process_requestIdentityUnbind (seqid,iprot,oprot,handler)
  "resendEmailConfirmation" -> process_resendEmailConfirmation (seqid,iprot,oprot,handler)
  "resendPinCode" -> process_resendPinCode (seqid,iprot,oprot,handler)
  "resendPinCodeBySMS" -> process_resendPinCodeBySMS (seqid,iprot,oprot,handler)
  "sendChatChecked" -> process_sendChatChecked (seqid,iprot,oprot,handler)
  "sendMessageAwaitCommit" -> process_sendMessageAwaitCommit (seqid,iprot,oprot,handler)
  "sendChatRemoved" -> process_sendChatRemoved (seqid,iprot,oprot,handler)
  "sendContentPreviewUpdated" -> process_sendContentPreviewUpdated (seqid,iprot,oprot,handler)
  "sendContentReceipt" -> process_sendContentReceipt (seqid,iprot,oprot,handler)
  "sendDummyPush" -> process_sendDummyPush (seqid,iprot,oprot,handler)
  "removeE2EEPublicKey" -> process_removeE2EEPublicKey (seqid,iprot,oprot,handler)
  "negotiateE2EEPublicKey" -> process_negotiateE2EEPublicKey (seqid,iprot,oprot,handler)
  "getE2EEPublicKey" -> process_getE2EEPublicKey (seqid,iprot,oprot,handler)
  "requestE2EEKeyExchange" -> process_requestE2EEKeyExchange (seqid,iprot,oprot,handler)
  "getLastE2EEPublicKeys" -> process_getLastE2EEPublicKeys (seqid,iprot,oprot,handler)
  "registerE2EEPublicKey" -> process_registerE2EEPublicKey (seqid,iprot,oprot,handler)
  "getE2EEPublicKeys" -> process_getE2EEPublicKeys (seqid,iprot,oprot,handler)
  "getE2EEPublicKeysEx" -> process_getE2EEPublicKeysEx (seqid,iprot,oprot,handler)
  "getReadMessageOpsInBulk" -> process_getReadMessageOpsInBulk (seqid,iprot,oprot,handler)
  "sendEvent" -> process_sendEvent (seqid,iprot,oprot,handler)
  "sendMessage" -> process_sendMessage (seqid,iprot,oprot,handler)
  "sendMessageIgnored" -> process_sendMessageIgnored (seqid,iprot,oprot,handler)
  "sendMessageReceipt" -> process_sendMessageReceipt (seqid,iprot,oprot,handler)
  "findContactByMetaTag" -> process_findContactByMetaTag (seqid,iprot,oprot,handler)
  "sendMessageToMyHome" -> process_sendMessageToMyHome (seqid,iprot,oprot,handler)
  "setBuddyLocation" -> process_setBuddyLocation (seqid,iprot,oprot,handler)
  "setIdentityCredential" -> process_setIdentityCredential (seqid,iprot,oprot,handler)
  "setNotificationsEnabled" -> process_setNotificationsEnabled (seqid,iprot,oprot,handler)
  "startUpdateVerification" -> process_startUpdateVerification (seqid,iprot,oprot,handler)
  "startVerification" -> process_startVerification (seqid,iprot,oprot,handler)
  "updateGroupPreferenceAttribute" -> process_updateGroupPreferenceAttribute (seqid,iprot,oprot,handler)
  "createRoomV2" -> process_createRoomV2 (seqid,iprot,oprot,handler)
  "storeUpdateProfileAttribute" -> process_storeUpdateProfileAttribute (seqid,iprot,oprot,handler)
  "syncContactBySnsIds" -> process_syncContactBySnsIds (seqid,iprot,oprot,handler)
  "syncContacts" -> process_syncContacts (seqid,iprot,oprot,handler)
  "trySendMessage" -> process_trySendMessage (seqid,iprot,oprot,handler)
  "getNextMessagesV2" -> process_getNextMessagesV2 (seqid,iprot,oprot,handler)
  "getMessageBoxCompactWrapUpV2" -> process_getMessageBoxCompactWrapUpV2 (seqid,iprot,oprot,handler)
  "getRecentMessagesV2" -> process_getRecentMessagesV2 (seqid,iprot,oprot,handler)
  "validateContactsOnBot" -> process_validateContactsOnBot (seqid,iprot,oprot,handler)
  "tryFriendRequest" -> process_tryFriendRequest (seqid,iprot,oprot,handler)
  "unblockContact" -> process_unblockContact (seqid,iprot,oprot,handler)
  "unblockRecommendation" -> process_unblockRecommendation (seqid,iprot,oprot,handler)
  "unregisterUserAndDevice" -> process_unregisterUserAndDevice (seqid,iprot,oprot,handler)
  "updateApnsDeviceToken" -> process_updateApnsDeviceToken (seqid,iprot,oprot,handler)
  "updateBuddySetting" -> process_updateBuddySetting (seqid,iprot,oprot,handler)
  "updateC2DMRegistrationId" -> process_updateC2DMRegistrationId (seqid,iprot,oprot,handler)
  "updateContactSetting" -> process_updateContactSetting (seqid,iprot,oprot,handler)
  "updateCustomModeSettings" -> process_updateCustomModeSettings (seqid,iprot,oprot,handler)
  "updateDeviceInfo" -> process_updateDeviceInfo (seqid,iprot,oprot,handler)
  "updateGroup" -> process_updateGroup (seqid,iprot,oprot,handler)
  "updateNotificationToken" -> process_updateNotificationToken (seqid,iprot,oprot,handler)
  "updateNotificationTokenWithBytes" -> process_updateNotificationTokenWithBytes (seqid,iprot,oprot,handler)
  "updateProfile" -> process_updateProfile (seqid,iprot,oprot,handler)
  "updateProfileAttribute" -> process_updateProfileAttribute (seqid,iprot,oprot,handler)
  "updateRegion" -> process_updateRegion (seqid,iprot,oprot,handler)
  "updateSettings" -> process_updateSettings (seqid,iprot,oprot,handler)
  "updateSettings2" -> process_updateSettings2 (seqid,iprot,oprot,handler)
  "updateSettingsAttribute" -> process_updateSettingsAttribute (seqid,iprot,oprot,handler)
  "updateSettingsAttributes" -> process_updateSettingsAttributes (seqid,iprot,oprot,handler)
  "verifyIdentityCredential" -> process_verifyIdentityCredential (seqid,iprot,oprot,handler)
  "verifyIdentityCredentialWithResult" -> process_verifyIdentityCredentialWithResult (seqid,iprot,oprot,handler)
  "verifyPhone" -> process_verifyPhone (seqid,iprot,oprot,handler)
  "verifyQrcode" -> process_verifyQrcode (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
