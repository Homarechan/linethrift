{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.14.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ShopService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ShopService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data BuyCoinProduct_args = BuyCoinProduct_args  { buyCoinProduct_args_paymentReservation :: PaymentReservation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyCoinProduct_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyCoinProduct_args_paymentReservation record  
instance QC.Arbitrary BuyCoinProduct_args where 
  arbitrary = M.liftM BuyCoinProduct_args (QC.arbitrary)
  shrink obj | obj == default_BuyCoinProduct_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyCoinProduct_args{buyCoinProduct_args_paymentReservation = buyCoinProduct_args_paymentReservation obj} then P.Nothing else P.Just $ default_BuyCoinProduct_args{buyCoinProduct_args_paymentReservation = buyCoinProduct_args_paymentReservation obj}
    ]
from_BuyCoinProduct_args :: BuyCoinProduct_args -> T.ThriftVal
from_BuyCoinProduct_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5507 -> P.Just (2, ("paymentReservation",from_PaymentReservation _v5507))) $ buyCoinProduct_args_paymentReservation record
  ]
write_BuyCoinProduct_args :: T.Protocol p => p -> BuyCoinProduct_args -> P.IO ()
write_BuyCoinProduct_args oprot record = T.writeVal oprot $ from_BuyCoinProduct_args record
encode_BuyCoinProduct_args :: T.StatelessProtocol p => p -> BuyCoinProduct_args -> LBS.ByteString
encode_BuyCoinProduct_args oprot record = T.serializeVal oprot $ from_BuyCoinProduct_args record
to_BuyCoinProduct_args :: T.ThriftVal -> BuyCoinProduct_args
to_BuyCoinProduct_args (T.TStruct fields) = BuyCoinProduct_args{
  buyCoinProduct_args_paymentReservation = P.maybe (buyCoinProduct_args_paymentReservation default_BuyCoinProduct_args) (\(_,_val5509) -> (case _val5509 of {T.TStruct _val5510 -> (to_PaymentReservation (T.TStruct _val5510)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BuyCoinProduct_args _ = P.error "not a struct"
read_BuyCoinProduct_args :: T.Protocol p => p -> P.IO BuyCoinProduct_args
read_BuyCoinProduct_args iprot = to_BuyCoinProduct_args <$> T.readVal iprot (T.T_STRUCT typemap_BuyCoinProduct_args)
decode_BuyCoinProduct_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyCoinProduct_args
decode_BuyCoinProduct_args iprot bs = to_BuyCoinProduct_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyCoinProduct_args) bs
typemap_BuyCoinProduct_args :: T.TypeMap
typemap_BuyCoinProduct_args = Map.fromList [(2,("paymentReservation",(T.T_STRUCT typemap_PaymentReservation)))]
default_BuyCoinProduct_args :: BuyCoinProduct_args
default_BuyCoinProduct_args = BuyCoinProduct_args{
  buyCoinProduct_args_paymentReservation = default_PaymentReservation}
data BuyCoinProduct_result = BuyCoinProduct_result  { buyCoinProduct_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyCoinProduct_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyCoinProduct_result_e record  
instance QC.Arbitrary BuyCoinProduct_result where 
  arbitrary = M.liftM BuyCoinProduct_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BuyCoinProduct_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyCoinProduct_result{buyCoinProduct_result_e = buyCoinProduct_result_e obj} then P.Nothing else P.Just $ default_BuyCoinProduct_result{buyCoinProduct_result_e = buyCoinProduct_result_e obj}
    ]
from_BuyCoinProduct_result :: BuyCoinProduct_result -> T.ThriftVal
from_BuyCoinProduct_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5513 -> (1, ("e",from_TalkException _v5513))) <$> buyCoinProduct_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5513 -> (1, ("e",from_TalkException _v5513))) <$> buyCoinProduct_result_e record
    ]
    )
write_BuyCoinProduct_result :: T.Protocol p => p -> BuyCoinProduct_result -> P.IO ()
write_BuyCoinProduct_result oprot record = T.writeVal oprot $ from_BuyCoinProduct_result record
encode_BuyCoinProduct_result :: T.StatelessProtocol p => p -> BuyCoinProduct_result -> LBS.ByteString
encode_BuyCoinProduct_result oprot record = T.serializeVal oprot $ from_BuyCoinProduct_result record
to_BuyCoinProduct_result :: T.ThriftVal -> BuyCoinProduct_result
to_BuyCoinProduct_result (T.TStruct fields) = BuyCoinProduct_result{
  buyCoinProduct_result_e = P.maybe (P.Nothing) (\(_,_val5515) -> P.Just (case _val5515 of {T.TStruct _val5516 -> (to_TalkException (T.TStruct _val5516)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BuyCoinProduct_result _ = P.error "not a struct"
read_BuyCoinProduct_result :: T.Protocol p => p -> P.IO BuyCoinProduct_result
read_BuyCoinProduct_result iprot = to_BuyCoinProduct_result <$> T.readVal iprot (T.T_STRUCT typemap_BuyCoinProduct_result)
decode_BuyCoinProduct_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyCoinProduct_result
decode_BuyCoinProduct_result iprot bs = to_BuyCoinProduct_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyCoinProduct_result) bs
typemap_BuyCoinProduct_result :: T.TypeMap
typemap_BuyCoinProduct_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BuyCoinProduct_result :: BuyCoinProduct_result
default_BuyCoinProduct_result = BuyCoinProduct_result{
  buyCoinProduct_result_e = P.Nothing}
data BuyFreeProduct_args = BuyFreeProduct_args  { buyFreeProduct_args_receiverMid :: LT.Text
  , buyFreeProduct_args_productId :: LT.Text
  , buyFreeProduct_args_messageTemplate :: I.Int32
  , buyFreeProduct_args_language :: LT.Text
  , buyFreeProduct_args_country :: LT.Text
  , buyFreeProduct_args_packageId :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyFreeProduct_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyFreeProduct_args_receiverMid record   `H.hashWithSalt` buyFreeProduct_args_productId record   `H.hashWithSalt` buyFreeProduct_args_messageTemplate record   `H.hashWithSalt` buyFreeProduct_args_language record   `H.hashWithSalt` buyFreeProduct_args_country record   `H.hashWithSalt` buyFreeProduct_args_packageId record  
instance QC.Arbitrary BuyFreeProduct_args where 
  arbitrary = M.liftM BuyFreeProduct_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuyFreeProduct_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyFreeProduct_args{buyFreeProduct_args_receiverMid = buyFreeProduct_args_receiverMid obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_receiverMid = buyFreeProduct_args_receiverMid obj}
    , if obj == default_BuyFreeProduct_args{buyFreeProduct_args_productId = buyFreeProduct_args_productId obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_productId = buyFreeProduct_args_productId obj}
    , if obj == default_BuyFreeProduct_args{buyFreeProduct_args_messageTemplate = buyFreeProduct_args_messageTemplate obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_messageTemplate = buyFreeProduct_args_messageTemplate obj}
    , if obj == default_BuyFreeProduct_args{buyFreeProduct_args_language = buyFreeProduct_args_language obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_language = buyFreeProduct_args_language obj}
    , if obj == default_BuyFreeProduct_args{buyFreeProduct_args_country = buyFreeProduct_args_country obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_country = buyFreeProduct_args_country obj}
    , if obj == default_BuyFreeProduct_args{buyFreeProduct_args_packageId = buyFreeProduct_args_packageId obj} then P.Nothing else P.Just $ default_BuyFreeProduct_args{buyFreeProduct_args_packageId = buyFreeProduct_args_packageId obj}
    ]
from_BuyFreeProduct_args :: BuyFreeProduct_args -> T.ThriftVal
from_BuyFreeProduct_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5519 -> P.Just (2, ("receiverMid",T.TString $ E.encodeUtf8 _v5519))) $ buyFreeProduct_args_receiverMid record
  , (\_v5519 -> P.Just (3, ("productId",T.TString $ E.encodeUtf8 _v5519))) $ buyFreeProduct_args_productId record
  , (\_v5519 -> P.Just (4, ("messageTemplate",T.TI32 _v5519))) $ buyFreeProduct_args_messageTemplate record
  , (\_v5519 -> P.Just (5, ("language",T.TString $ E.encodeUtf8 _v5519))) $ buyFreeProduct_args_language record
  , (\_v5519 -> P.Just (6, ("country",T.TString $ E.encodeUtf8 _v5519))) $ buyFreeProduct_args_country record
  , (\_v5519 -> P.Just (7, ("packageId",T.TI64 _v5519))) $ buyFreeProduct_args_packageId record
  ]
write_BuyFreeProduct_args :: T.Protocol p => p -> BuyFreeProduct_args -> P.IO ()
write_BuyFreeProduct_args oprot record = T.writeVal oprot $ from_BuyFreeProduct_args record
encode_BuyFreeProduct_args :: T.StatelessProtocol p => p -> BuyFreeProduct_args -> LBS.ByteString
encode_BuyFreeProduct_args oprot record = T.serializeVal oprot $ from_BuyFreeProduct_args record
to_BuyFreeProduct_args :: T.ThriftVal -> BuyFreeProduct_args
to_BuyFreeProduct_args (T.TStruct fields) = BuyFreeProduct_args{
  buyFreeProduct_args_receiverMid = P.maybe (buyFreeProduct_args_receiverMid default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TString _val5522 -> E.decodeUtf8 _val5522; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buyFreeProduct_args_productId = P.maybe (buyFreeProduct_args_productId default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TString _val5523 -> E.decodeUtf8 _val5523; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buyFreeProduct_args_messageTemplate = P.maybe (buyFreeProduct_args_messageTemplate default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TI32 _val5524 -> _val5524; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buyFreeProduct_args_language = P.maybe (buyFreeProduct_args_language default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TString _val5525 -> E.decodeUtf8 _val5525; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buyFreeProduct_args_country = P.maybe (buyFreeProduct_args_country default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TString _val5526 -> E.decodeUtf8 _val5526; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  buyFreeProduct_args_packageId = P.maybe (buyFreeProduct_args_packageId default_BuyFreeProduct_args) (\(_,_val5521) -> (case _val5521 of {T.TI64 _val5527 -> _val5527; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_BuyFreeProduct_args _ = P.error "not a struct"
read_BuyFreeProduct_args :: T.Protocol p => p -> P.IO BuyFreeProduct_args
read_BuyFreeProduct_args iprot = to_BuyFreeProduct_args <$> T.readVal iprot (T.T_STRUCT typemap_BuyFreeProduct_args)
decode_BuyFreeProduct_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyFreeProduct_args
decode_BuyFreeProduct_args iprot bs = to_BuyFreeProduct_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyFreeProduct_args) bs
typemap_BuyFreeProduct_args :: T.TypeMap
typemap_BuyFreeProduct_args = Map.fromList [(2,("receiverMid",T.T_STRING)),(3,("productId",T.T_STRING)),(4,("messageTemplate",T.T_I32)),(5,("language",T.T_STRING)),(6,("country",T.T_STRING)),(7,("packageId",T.T_I64))]
default_BuyFreeProduct_args :: BuyFreeProduct_args
default_BuyFreeProduct_args = BuyFreeProduct_args{
  buyFreeProduct_args_receiverMid = "",
  buyFreeProduct_args_productId = "",
  buyFreeProduct_args_messageTemplate = 0,
  buyFreeProduct_args_language = "",
  buyFreeProduct_args_country = "",
  buyFreeProduct_args_packageId = 0}
data BuyFreeProduct_result = BuyFreeProduct_result  { buyFreeProduct_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyFreeProduct_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyFreeProduct_result_e record  
instance QC.Arbitrary BuyFreeProduct_result where 
  arbitrary = M.liftM BuyFreeProduct_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BuyFreeProduct_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyFreeProduct_result{buyFreeProduct_result_e = buyFreeProduct_result_e obj} then P.Nothing else P.Just $ default_BuyFreeProduct_result{buyFreeProduct_result_e = buyFreeProduct_result_e obj}
    ]
from_BuyFreeProduct_result :: BuyFreeProduct_result -> T.ThriftVal
from_BuyFreeProduct_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5530 -> (1, ("e",from_TalkException _v5530))) <$> buyFreeProduct_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5530 -> (1, ("e",from_TalkException _v5530))) <$> buyFreeProduct_result_e record
    ]
    )
write_BuyFreeProduct_result :: T.Protocol p => p -> BuyFreeProduct_result -> P.IO ()
write_BuyFreeProduct_result oprot record = T.writeVal oprot $ from_BuyFreeProduct_result record
encode_BuyFreeProduct_result :: T.StatelessProtocol p => p -> BuyFreeProduct_result -> LBS.ByteString
encode_BuyFreeProduct_result oprot record = T.serializeVal oprot $ from_BuyFreeProduct_result record
to_BuyFreeProduct_result :: T.ThriftVal -> BuyFreeProduct_result
to_BuyFreeProduct_result (T.TStruct fields) = BuyFreeProduct_result{
  buyFreeProduct_result_e = P.maybe (P.Nothing) (\(_,_val5532) -> P.Just (case _val5532 of {T.TStruct _val5533 -> (to_TalkException (T.TStruct _val5533)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BuyFreeProduct_result _ = P.error "not a struct"
read_BuyFreeProduct_result :: T.Protocol p => p -> P.IO BuyFreeProduct_result
read_BuyFreeProduct_result iprot = to_BuyFreeProduct_result <$> T.readVal iprot (T.T_STRUCT typemap_BuyFreeProduct_result)
decode_BuyFreeProduct_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyFreeProduct_result
decode_BuyFreeProduct_result iprot bs = to_BuyFreeProduct_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyFreeProduct_result) bs
typemap_BuyFreeProduct_result :: T.TypeMap
typemap_BuyFreeProduct_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BuyFreeProduct_result :: BuyFreeProduct_result
default_BuyFreeProduct_result = BuyFreeProduct_result{
  buyFreeProduct_result_e = P.Nothing}
data BuyMustbuyProduct_args = BuyMustbuyProduct_args  { buyMustbuyProduct_args_receiverMid :: LT.Text
  , buyMustbuyProduct_args_productId :: LT.Text
  , buyMustbuyProduct_args_messageTemplate :: I.Int32
  , buyMustbuyProduct_args_language :: LT.Text
  , buyMustbuyProduct_args_country :: LT.Text
  , buyMustbuyProduct_args_packageId :: I.Int64
  , buyMustbuyProduct_args_serialNumber :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyMustbuyProduct_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyMustbuyProduct_args_receiverMid record   `H.hashWithSalt` buyMustbuyProduct_args_productId record   `H.hashWithSalt` buyMustbuyProduct_args_messageTemplate record   `H.hashWithSalt` buyMustbuyProduct_args_language record   `H.hashWithSalt` buyMustbuyProduct_args_country record   `H.hashWithSalt` buyMustbuyProduct_args_packageId record   `H.hashWithSalt` buyMustbuyProduct_args_serialNumber record  
instance QC.Arbitrary BuyMustbuyProduct_args where 
  arbitrary = M.liftM BuyMustbuyProduct_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BuyMustbuyProduct_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_receiverMid = buyMustbuyProduct_args_receiverMid obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_receiverMid = buyMustbuyProduct_args_receiverMid obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_productId = buyMustbuyProduct_args_productId obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_productId = buyMustbuyProduct_args_productId obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_messageTemplate = buyMustbuyProduct_args_messageTemplate obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_messageTemplate = buyMustbuyProduct_args_messageTemplate obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_language = buyMustbuyProduct_args_language obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_language = buyMustbuyProduct_args_language obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_country = buyMustbuyProduct_args_country obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_country = buyMustbuyProduct_args_country obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_packageId = buyMustbuyProduct_args_packageId obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_packageId = buyMustbuyProduct_args_packageId obj}
    , if obj == default_BuyMustbuyProduct_args{buyMustbuyProduct_args_serialNumber = buyMustbuyProduct_args_serialNumber obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_args{buyMustbuyProduct_args_serialNumber = buyMustbuyProduct_args_serialNumber obj}
    ]
from_BuyMustbuyProduct_args :: BuyMustbuyProduct_args -> T.ThriftVal
from_BuyMustbuyProduct_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5536 -> P.Just (2, ("receiverMid",T.TString $ E.encodeUtf8 _v5536))) $ buyMustbuyProduct_args_receiverMid record
  , (\_v5536 -> P.Just (3, ("productId",T.TString $ E.encodeUtf8 _v5536))) $ buyMustbuyProduct_args_productId record
  , (\_v5536 -> P.Just (4, ("messageTemplate",T.TI32 _v5536))) $ buyMustbuyProduct_args_messageTemplate record
  , (\_v5536 -> P.Just (5, ("language",T.TString $ E.encodeUtf8 _v5536))) $ buyMustbuyProduct_args_language record
  , (\_v5536 -> P.Just (6, ("country",T.TString $ E.encodeUtf8 _v5536))) $ buyMustbuyProduct_args_country record
  , (\_v5536 -> P.Just (7, ("packageId",T.TI64 _v5536))) $ buyMustbuyProduct_args_packageId record
  , (\_v5536 -> P.Just (8, ("serialNumber",T.TString $ E.encodeUtf8 _v5536))) $ buyMustbuyProduct_args_serialNumber record
  ]
write_BuyMustbuyProduct_args :: T.Protocol p => p -> BuyMustbuyProduct_args -> P.IO ()
write_BuyMustbuyProduct_args oprot record = T.writeVal oprot $ from_BuyMustbuyProduct_args record
encode_BuyMustbuyProduct_args :: T.StatelessProtocol p => p -> BuyMustbuyProduct_args -> LBS.ByteString
encode_BuyMustbuyProduct_args oprot record = T.serializeVal oprot $ from_BuyMustbuyProduct_args record
to_BuyMustbuyProduct_args :: T.ThriftVal -> BuyMustbuyProduct_args
to_BuyMustbuyProduct_args (T.TStruct fields) = BuyMustbuyProduct_args{
  buyMustbuyProduct_args_receiverMid = P.maybe (buyMustbuyProduct_args_receiverMid default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TString _val5539 -> E.decodeUtf8 _val5539; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  buyMustbuyProduct_args_productId = P.maybe (buyMustbuyProduct_args_productId default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TString _val5540 -> E.decodeUtf8 _val5540; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  buyMustbuyProduct_args_messageTemplate = P.maybe (buyMustbuyProduct_args_messageTemplate default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TI32 _val5541 -> _val5541; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  buyMustbuyProduct_args_language = P.maybe (buyMustbuyProduct_args_language default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TString _val5542 -> E.decodeUtf8 _val5542; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  buyMustbuyProduct_args_country = P.maybe (buyMustbuyProduct_args_country default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TString _val5543 -> E.decodeUtf8 _val5543; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  buyMustbuyProduct_args_packageId = P.maybe (buyMustbuyProduct_args_packageId default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TI64 _val5544 -> _val5544; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  buyMustbuyProduct_args_serialNumber = P.maybe (buyMustbuyProduct_args_serialNumber default_BuyMustbuyProduct_args) (\(_,_val5538) -> (case _val5538 of {T.TString _val5545 -> E.decodeUtf8 _val5545; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_BuyMustbuyProduct_args _ = P.error "not a struct"
read_BuyMustbuyProduct_args :: T.Protocol p => p -> P.IO BuyMustbuyProduct_args
read_BuyMustbuyProduct_args iprot = to_BuyMustbuyProduct_args <$> T.readVal iprot (T.T_STRUCT typemap_BuyMustbuyProduct_args)
decode_BuyMustbuyProduct_args :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyMustbuyProduct_args
decode_BuyMustbuyProduct_args iprot bs = to_BuyMustbuyProduct_args $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyMustbuyProduct_args) bs
typemap_BuyMustbuyProduct_args :: T.TypeMap
typemap_BuyMustbuyProduct_args = Map.fromList [(2,("receiverMid",T.T_STRING)),(3,("productId",T.T_STRING)),(4,("messageTemplate",T.T_I32)),(5,("language",T.T_STRING)),(6,("country",T.T_STRING)),(7,("packageId",T.T_I64)),(8,("serialNumber",T.T_STRING))]
default_BuyMustbuyProduct_args :: BuyMustbuyProduct_args
default_BuyMustbuyProduct_args = BuyMustbuyProduct_args{
  buyMustbuyProduct_args_receiverMid = "",
  buyMustbuyProduct_args_productId = "",
  buyMustbuyProduct_args_messageTemplate = 0,
  buyMustbuyProduct_args_language = "",
  buyMustbuyProduct_args_country = "",
  buyMustbuyProduct_args_packageId = 0,
  buyMustbuyProduct_args_serialNumber = ""}
data BuyMustbuyProduct_result = BuyMustbuyProduct_result  { buyMustbuyProduct_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BuyMustbuyProduct_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` buyMustbuyProduct_result_e record  
instance QC.Arbitrary BuyMustbuyProduct_result where 
  arbitrary = M.liftM BuyMustbuyProduct_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BuyMustbuyProduct_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BuyMustbuyProduct_result{buyMustbuyProduct_result_e = buyMustbuyProduct_result_e obj} then P.Nothing else P.Just $ default_BuyMustbuyProduct_result{buyMustbuyProduct_result_e = buyMustbuyProduct_result_e obj}
    ]
from_BuyMustbuyProduct_result :: BuyMustbuyProduct_result -> T.ThriftVal
from_BuyMustbuyProduct_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5548 -> (1, ("e",from_TalkException _v5548))) <$> buyMustbuyProduct_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5548 -> (1, ("e",from_TalkException _v5548))) <$> buyMustbuyProduct_result_e record
    ]
    )
write_BuyMustbuyProduct_result :: T.Protocol p => p -> BuyMustbuyProduct_result -> P.IO ()
write_BuyMustbuyProduct_result oprot record = T.writeVal oprot $ from_BuyMustbuyProduct_result record
encode_BuyMustbuyProduct_result :: T.StatelessProtocol p => p -> BuyMustbuyProduct_result -> LBS.ByteString
encode_BuyMustbuyProduct_result oprot record = T.serializeVal oprot $ from_BuyMustbuyProduct_result record
to_BuyMustbuyProduct_result :: T.ThriftVal -> BuyMustbuyProduct_result
to_BuyMustbuyProduct_result (T.TStruct fields) = BuyMustbuyProduct_result{
  buyMustbuyProduct_result_e = P.maybe (P.Nothing) (\(_,_val5550) -> P.Just (case _val5550 of {T.TStruct _val5551 -> (to_TalkException (T.TStruct _val5551)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BuyMustbuyProduct_result _ = P.error "not a struct"
read_BuyMustbuyProduct_result :: T.Protocol p => p -> P.IO BuyMustbuyProduct_result
read_BuyMustbuyProduct_result iprot = to_BuyMustbuyProduct_result <$> T.readVal iprot (T.T_STRUCT typemap_BuyMustbuyProduct_result)
decode_BuyMustbuyProduct_result :: T.StatelessProtocol p => p -> LBS.ByteString -> BuyMustbuyProduct_result
decode_BuyMustbuyProduct_result iprot bs = to_BuyMustbuyProduct_result $ T.deserializeVal iprot (T.T_STRUCT typemap_BuyMustbuyProduct_result) bs
typemap_BuyMustbuyProduct_result :: T.TypeMap
typemap_BuyMustbuyProduct_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_BuyMustbuyProduct_result :: BuyMustbuyProduct_result
default_BuyMustbuyProduct_result = BuyMustbuyProduct_result{
  buyMustbuyProduct_result_e = P.Nothing}
data CheckCanReceivePresent_args = CheckCanReceivePresent_args  { checkCanReceivePresent_args_recipientMid :: LT.Text
  , checkCanReceivePresent_args_packageId :: I.Int64
  , checkCanReceivePresent_args_language :: LT.Text
  , checkCanReceivePresent_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CheckCanReceivePresent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` checkCanReceivePresent_args_recipientMid record   `H.hashWithSalt` checkCanReceivePresent_args_packageId record   `H.hashWithSalt` checkCanReceivePresent_args_language record   `H.hashWithSalt` checkCanReceivePresent_args_country record  
instance QC.Arbitrary CheckCanReceivePresent_args where 
  arbitrary = M.liftM CheckCanReceivePresent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CheckCanReceivePresent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CheckCanReceivePresent_args{checkCanReceivePresent_args_recipientMid = checkCanReceivePresent_args_recipientMid obj} then P.Nothing else P.Just $ default_CheckCanReceivePresent_args{checkCanReceivePresent_args_recipientMid = checkCanReceivePresent_args_recipientMid obj}
    , if obj == default_CheckCanReceivePresent_args{checkCanReceivePresent_args_packageId = checkCanReceivePresent_args_packageId obj} then P.Nothing else P.Just $ default_CheckCanReceivePresent_args{checkCanReceivePresent_args_packageId = checkCanReceivePresent_args_packageId obj}
    , if obj == default_CheckCanReceivePresent_args{checkCanReceivePresent_args_language = checkCanReceivePresent_args_language obj} then P.Nothing else P.Just $ default_CheckCanReceivePresent_args{checkCanReceivePresent_args_language = checkCanReceivePresent_args_language obj}
    , if obj == default_CheckCanReceivePresent_args{checkCanReceivePresent_args_country = checkCanReceivePresent_args_country obj} then P.Nothing else P.Just $ default_CheckCanReceivePresent_args{checkCanReceivePresent_args_country = checkCanReceivePresent_args_country obj}
    ]
from_CheckCanReceivePresent_args :: CheckCanReceivePresent_args -> T.ThriftVal
from_CheckCanReceivePresent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5554 -> P.Just (2, ("recipientMid",T.TString $ E.encodeUtf8 _v5554))) $ checkCanReceivePresent_args_recipientMid record
  , (\_v5554 -> P.Just (3, ("packageId",T.TI64 _v5554))) $ checkCanReceivePresent_args_packageId record
  , (\_v5554 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5554))) $ checkCanReceivePresent_args_language record
  , (\_v5554 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5554))) $ checkCanReceivePresent_args_country record
  ]
write_CheckCanReceivePresent_args :: T.Protocol p => p -> CheckCanReceivePresent_args -> P.IO ()
write_CheckCanReceivePresent_args oprot record = T.writeVal oprot $ from_CheckCanReceivePresent_args record
encode_CheckCanReceivePresent_args :: T.StatelessProtocol p => p -> CheckCanReceivePresent_args -> LBS.ByteString
encode_CheckCanReceivePresent_args oprot record = T.serializeVal oprot $ from_CheckCanReceivePresent_args record
to_CheckCanReceivePresent_args :: T.ThriftVal -> CheckCanReceivePresent_args
to_CheckCanReceivePresent_args (T.TStruct fields) = CheckCanReceivePresent_args{
  checkCanReceivePresent_args_recipientMid = P.maybe (checkCanReceivePresent_args_recipientMid default_CheckCanReceivePresent_args) (\(_,_val5556) -> (case _val5556 of {T.TString _val5557 -> E.decodeUtf8 _val5557; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  checkCanReceivePresent_args_packageId = P.maybe (checkCanReceivePresent_args_packageId default_CheckCanReceivePresent_args) (\(_,_val5556) -> (case _val5556 of {T.TI64 _val5558 -> _val5558; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  checkCanReceivePresent_args_language = P.maybe (checkCanReceivePresent_args_language default_CheckCanReceivePresent_args) (\(_,_val5556) -> (case _val5556 of {T.TString _val5559 -> E.decodeUtf8 _val5559; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  checkCanReceivePresent_args_country = P.maybe (checkCanReceivePresent_args_country default_CheckCanReceivePresent_args) (\(_,_val5556) -> (case _val5556 of {T.TString _val5560 -> E.decodeUtf8 _val5560; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_CheckCanReceivePresent_args _ = P.error "not a struct"
read_CheckCanReceivePresent_args :: T.Protocol p => p -> P.IO CheckCanReceivePresent_args
read_CheckCanReceivePresent_args iprot = to_CheckCanReceivePresent_args <$> T.readVal iprot (T.T_STRUCT typemap_CheckCanReceivePresent_args)
decode_CheckCanReceivePresent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CheckCanReceivePresent_args
decode_CheckCanReceivePresent_args iprot bs = to_CheckCanReceivePresent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CheckCanReceivePresent_args) bs
typemap_CheckCanReceivePresent_args :: T.TypeMap
typemap_CheckCanReceivePresent_args = Map.fromList [(2,("recipientMid",T.T_STRING)),(3,("packageId",T.T_I64)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_CheckCanReceivePresent_args :: CheckCanReceivePresent_args
default_CheckCanReceivePresent_args = CheckCanReceivePresent_args{
  checkCanReceivePresent_args_recipientMid = "",
  checkCanReceivePresent_args_packageId = 0,
  checkCanReceivePresent_args_language = "",
  checkCanReceivePresent_args_country = ""}
data CheckCanReceivePresent_result = CheckCanReceivePresent_result  { checkCanReceivePresent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CheckCanReceivePresent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` checkCanReceivePresent_result_e record  
instance QC.Arbitrary CheckCanReceivePresent_result where 
  arbitrary = M.liftM CheckCanReceivePresent_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CheckCanReceivePresent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CheckCanReceivePresent_result{checkCanReceivePresent_result_e = checkCanReceivePresent_result_e obj} then P.Nothing else P.Just $ default_CheckCanReceivePresent_result{checkCanReceivePresent_result_e = checkCanReceivePresent_result_e obj}
    ]
from_CheckCanReceivePresent_result :: CheckCanReceivePresent_result -> T.ThriftVal
from_CheckCanReceivePresent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5563 -> (1, ("e",from_TalkException _v5563))) <$> checkCanReceivePresent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5563 -> (1, ("e",from_TalkException _v5563))) <$> checkCanReceivePresent_result_e record
    ]
    )
write_CheckCanReceivePresent_result :: T.Protocol p => p -> CheckCanReceivePresent_result -> P.IO ()
write_CheckCanReceivePresent_result oprot record = T.writeVal oprot $ from_CheckCanReceivePresent_result record
encode_CheckCanReceivePresent_result :: T.StatelessProtocol p => p -> CheckCanReceivePresent_result -> LBS.ByteString
encode_CheckCanReceivePresent_result oprot record = T.serializeVal oprot $ from_CheckCanReceivePresent_result record
to_CheckCanReceivePresent_result :: T.ThriftVal -> CheckCanReceivePresent_result
to_CheckCanReceivePresent_result (T.TStruct fields) = CheckCanReceivePresent_result{
  checkCanReceivePresent_result_e = P.maybe (P.Nothing) (\(_,_val5565) -> P.Just (case _val5565 of {T.TStruct _val5566 -> (to_TalkException (T.TStruct _val5566)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CheckCanReceivePresent_result _ = P.error "not a struct"
read_CheckCanReceivePresent_result :: T.Protocol p => p -> P.IO CheckCanReceivePresent_result
read_CheckCanReceivePresent_result iprot = to_CheckCanReceivePresent_result <$> T.readVal iprot (T.T_STRUCT typemap_CheckCanReceivePresent_result)
decode_CheckCanReceivePresent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CheckCanReceivePresent_result
decode_CheckCanReceivePresent_result iprot bs = to_CheckCanReceivePresent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CheckCanReceivePresent_result) bs
typemap_CheckCanReceivePresent_result :: T.TypeMap
typemap_CheckCanReceivePresent_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CheckCanReceivePresent_result :: CheckCanReceivePresent_result
default_CheckCanReceivePresent_result = CheckCanReceivePresent_result{
  checkCanReceivePresent_result_e = P.Nothing}
data GetActivePurchases_args = GetActivePurchases_args  { getActivePurchases_args_start :: I.Int64
  , getActivePurchases_args_size :: I.Int32
  , getActivePurchases_args_language :: LT.Text
  , getActivePurchases_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActivePurchases_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActivePurchases_args_start record   `H.hashWithSalt` getActivePurchases_args_size record   `H.hashWithSalt` getActivePurchases_args_language record   `H.hashWithSalt` getActivePurchases_args_country record  
instance QC.Arbitrary GetActivePurchases_args where 
  arbitrary = M.liftM GetActivePurchases_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetActivePurchases_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActivePurchases_args{getActivePurchases_args_start = getActivePurchases_args_start obj} then P.Nothing else P.Just $ default_GetActivePurchases_args{getActivePurchases_args_start = getActivePurchases_args_start obj}
    , if obj == default_GetActivePurchases_args{getActivePurchases_args_size = getActivePurchases_args_size obj} then P.Nothing else P.Just $ default_GetActivePurchases_args{getActivePurchases_args_size = getActivePurchases_args_size obj}
    , if obj == default_GetActivePurchases_args{getActivePurchases_args_language = getActivePurchases_args_language obj} then P.Nothing else P.Just $ default_GetActivePurchases_args{getActivePurchases_args_language = getActivePurchases_args_language obj}
    , if obj == default_GetActivePurchases_args{getActivePurchases_args_country = getActivePurchases_args_country obj} then P.Nothing else P.Just $ default_GetActivePurchases_args{getActivePurchases_args_country = getActivePurchases_args_country obj}
    ]
from_GetActivePurchases_args :: GetActivePurchases_args -> T.ThriftVal
from_GetActivePurchases_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5569 -> P.Just (2, ("start",T.TI64 _v5569))) $ getActivePurchases_args_start record
  , (\_v5569 -> P.Just (3, ("size",T.TI32 _v5569))) $ getActivePurchases_args_size record
  , (\_v5569 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5569))) $ getActivePurchases_args_language record
  , (\_v5569 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5569))) $ getActivePurchases_args_country record
  ]
write_GetActivePurchases_args :: T.Protocol p => p -> GetActivePurchases_args -> P.IO ()
write_GetActivePurchases_args oprot record = T.writeVal oprot $ from_GetActivePurchases_args record
encode_GetActivePurchases_args :: T.StatelessProtocol p => p -> GetActivePurchases_args -> LBS.ByteString
encode_GetActivePurchases_args oprot record = T.serializeVal oprot $ from_GetActivePurchases_args record
to_GetActivePurchases_args :: T.ThriftVal -> GetActivePurchases_args
to_GetActivePurchases_args (T.TStruct fields) = GetActivePurchases_args{
  getActivePurchases_args_start = P.maybe (getActivePurchases_args_start default_GetActivePurchases_args) (\(_,_val5571) -> (case _val5571 of {T.TI64 _val5572 -> _val5572; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getActivePurchases_args_size = P.maybe (getActivePurchases_args_size default_GetActivePurchases_args) (\(_,_val5571) -> (case _val5571 of {T.TI32 _val5573 -> _val5573; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getActivePurchases_args_language = P.maybe (getActivePurchases_args_language default_GetActivePurchases_args) (\(_,_val5571) -> (case _val5571 of {T.TString _val5574 -> E.decodeUtf8 _val5574; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getActivePurchases_args_country = P.maybe (getActivePurchases_args_country default_GetActivePurchases_args) (\(_,_val5571) -> (case _val5571 of {T.TString _val5575 -> E.decodeUtf8 _val5575; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetActivePurchases_args _ = P.error "not a struct"
read_GetActivePurchases_args :: T.Protocol p => p -> P.IO GetActivePurchases_args
read_GetActivePurchases_args iprot = to_GetActivePurchases_args <$> T.readVal iprot (T.T_STRUCT typemap_GetActivePurchases_args)
decode_GetActivePurchases_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActivePurchases_args
decode_GetActivePurchases_args iprot bs = to_GetActivePurchases_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActivePurchases_args) bs
typemap_GetActivePurchases_args :: T.TypeMap
typemap_GetActivePurchases_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetActivePurchases_args :: GetActivePurchases_args
default_GetActivePurchases_args = GetActivePurchases_args{
  getActivePurchases_args_start = 0,
  getActivePurchases_args_size = 0,
  getActivePurchases_args_language = "",
  getActivePurchases_args_country = ""}
data GetActivePurchases_result = GetActivePurchases_result  { getActivePurchases_result_success :: ProductList
  , getActivePurchases_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActivePurchases_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActivePurchases_result_success record   `H.hashWithSalt` getActivePurchases_result_e record  
instance QC.Arbitrary GetActivePurchases_result where 
  arbitrary = M.liftM GetActivePurchases_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetActivePurchases_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActivePurchases_result{getActivePurchases_result_success = getActivePurchases_result_success obj} then P.Nothing else P.Just $ default_GetActivePurchases_result{getActivePurchases_result_success = getActivePurchases_result_success obj}
    , if obj == default_GetActivePurchases_result{getActivePurchases_result_e = getActivePurchases_result_e obj} then P.Nothing else P.Just $ default_GetActivePurchases_result{getActivePurchases_result_e = getActivePurchases_result_e obj}
    ]
from_GetActivePurchases_result :: GetActivePurchases_result -> T.ThriftVal
from_GetActivePurchases_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5578 -> (1, ("e",from_TalkException _v5578))) <$> getActivePurchases_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5578 -> P.Just (0, ("success",from_ProductList _v5578))) $ getActivePurchases_result_success record
    , (\_v5578 -> (1, ("e",from_TalkException _v5578))) <$> getActivePurchases_result_e record
    ]
    )
write_GetActivePurchases_result :: T.Protocol p => p -> GetActivePurchases_result -> P.IO ()
write_GetActivePurchases_result oprot record = T.writeVal oprot $ from_GetActivePurchases_result record
encode_GetActivePurchases_result :: T.StatelessProtocol p => p -> GetActivePurchases_result -> LBS.ByteString
encode_GetActivePurchases_result oprot record = T.serializeVal oprot $ from_GetActivePurchases_result record
to_GetActivePurchases_result :: T.ThriftVal -> GetActivePurchases_result
to_GetActivePurchases_result (T.TStruct fields) = GetActivePurchases_result{
  getActivePurchases_result_success = P.maybe (getActivePurchases_result_success default_GetActivePurchases_result) (\(_,_val5580) -> (case _val5580 of {T.TStruct _val5581 -> (to_ProductList (T.TStruct _val5581)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getActivePurchases_result_e = P.maybe (P.Nothing) (\(_,_val5580) -> P.Just (case _val5580 of {T.TStruct _val5582 -> (to_TalkException (T.TStruct _val5582)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetActivePurchases_result _ = P.error "not a struct"
read_GetActivePurchases_result :: T.Protocol p => p -> P.IO GetActivePurchases_result
read_GetActivePurchases_result iprot = to_GetActivePurchases_result <$> T.readVal iprot (T.T_STRUCT typemap_GetActivePurchases_result)
decode_GetActivePurchases_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActivePurchases_result
decode_GetActivePurchases_result iprot bs = to_GetActivePurchases_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActivePurchases_result) bs
typemap_GetActivePurchases_result :: T.TypeMap
typemap_GetActivePurchases_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetActivePurchases_result :: GetActivePurchases_result
default_GetActivePurchases_result = GetActivePurchases_result{
  getActivePurchases_result_success = default_ProductList,
  getActivePurchases_result_e = P.Nothing}
data GetActivePurchaseVersions_args = GetActivePurchaseVersions_args  { getActivePurchaseVersions_args_start :: I.Int64
  , getActivePurchaseVersions_args_size :: I.Int32
  , getActivePurchaseVersions_args_language :: LT.Text
  , getActivePurchaseVersions_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActivePurchaseVersions_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActivePurchaseVersions_args_start record   `H.hashWithSalt` getActivePurchaseVersions_args_size record   `H.hashWithSalt` getActivePurchaseVersions_args_language record   `H.hashWithSalt` getActivePurchaseVersions_args_country record  
instance QC.Arbitrary GetActivePurchaseVersions_args where 
  arbitrary = M.liftM GetActivePurchaseVersions_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetActivePurchaseVersions_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_start = getActivePurchaseVersions_args_start obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_start = getActivePurchaseVersions_args_start obj}
    , if obj == default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_size = getActivePurchaseVersions_args_size obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_size = getActivePurchaseVersions_args_size obj}
    , if obj == default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_language = getActivePurchaseVersions_args_language obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_language = getActivePurchaseVersions_args_language obj}
    , if obj == default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_country = getActivePurchaseVersions_args_country obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_args{getActivePurchaseVersions_args_country = getActivePurchaseVersions_args_country obj}
    ]
from_GetActivePurchaseVersions_args :: GetActivePurchaseVersions_args -> T.ThriftVal
from_GetActivePurchaseVersions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5585 -> P.Just (2, ("start",T.TI64 _v5585))) $ getActivePurchaseVersions_args_start record
  , (\_v5585 -> P.Just (3, ("size",T.TI32 _v5585))) $ getActivePurchaseVersions_args_size record
  , (\_v5585 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5585))) $ getActivePurchaseVersions_args_language record
  , (\_v5585 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5585))) $ getActivePurchaseVersions_args_country record
  ]
write_GetActivePurchaseVersions_args :: T.Protocol p => p -> GetActivePurchaseVersions_args -> P.IO ()
write_GetActivePurchaseVersions_args oprot record = T.writeVal oprot $ from_GetActivePurchaseVersions_args record
encode_GetActivePurchaseVersions_args :: T.StatelessProtocol p => p -> GetActivePurchaseVersions_args -> LBS.ByteString
encode_GetActivePurchaseVersions_args oprot record = T.serializeVal oprot $ from_GetActivePurchaseVersions_args record
to_GetActivePurchaseVersions_args :: T.ThriftVal -> GetActivePurchaseVersions_args
to_GetActivePurchaseVersions_args (T.TStruct fields) = GetActivePurchaseVersions_args{
  getActivePurchaseVersions_args_start = P.maybe (getActivePurchaseVersions_args_start default_GetActivePurchaseVersions_args) (\(_,_val5587) -> (case _val5587 of {T.TI64 _val5588 -> _val5588; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getActivePurchaseVersions_args_size = P.maybe (getActivePurchaseVersions_args_size default_GetActivePurchaseVersions_args) (\(_,_val5587) -> (case _val5587 of {T.TI32 _val5589 -> _val5589; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getActivePurchaseVersions_args_language = P.maybe (getActivePurchaseVersions_args_language default_GetActivePurchaseVersions_args) (\(_,_val5587) -> (case _val5587 of {T.TString _val5590 -> E.decodeUtf8 _val5590; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getActivePurchaseVersions_args_country = P.maybe (getActivePurchaseVersions_args_country default_GetActivePurchaseVersions_args) (\(_,_val5587) -> (case _val5587 of {T.TString _val5591 -> E.decodeUtf8 _val5591; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetActivePurchaseVersions_args _ = P.error "not a struct"
read_GetActivePurchaseVersions_args :: T.Protocol p => p -> P.IO GetActivePurchaseVersions_args
read_GetActivePurchaseVersions_args iprot = to_GetActivePurchaseVersions_args <$> T.readVal iprot (T.T_STRUCT typemap_GetActivePurchaseVersions_args)
decode_GetActivePurchaseVersions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActivePurchaseVersions_args
decode_GetActivePurchaseVersions_args iprot bs = to_GetActivePurchaseVersions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActivePurchaseVersions_args) bs
typemap_GetActivePurchaseVersions_args :: T.TypeMap
typemap_GetActivePurchaseVersions_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetActivePurchaseVersions_args :: GetActivePurchaseVersions_args
default_GetActivePurchaseVersions_args = GetActivePurchaseVersions_args{
  getActivePurchaseVersions_args_start = 0,
  getActivePurchaseVersions_args_size = 0,
  getActivePurchaseVersions_args_language = "",
  getActivePurchaseVersions_args_country = ""}
data GetActivePurchaseVersions_result = GetActivePurchaseVersions_result  { getActivePurchaseVersions_result_success :: ProductSimpleList
  , getActivePurchaseVersions_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetActivePurchaseVersions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getActivePurchaseVersions_result_success record   `H.hashWithSalt` getActivePurchaseVersions_result_e record  
instance QC.Arbitrary GetActivePurchaseVersions_result where 
  arbitrary = M.liftM GetActivePurchaseVersions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetActivePurchaseVersions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_success = getActivePurchaseVersions_result_success obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_success = getActivePurchaseVersions_result_success obj}
    , if obj == default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_e = getActivePurchaseVersions_result_e obj} then P.Nothing else P.Just $ default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_e = getActivePurchaseVersions_result_e obj}
    ]
from_GetActivePurchaseVersions_result :: GetActivePurchaseVersions_result -> T.ThriftVal
from_GetActivePurchaseVersions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5594 -> (1, ("e",from_TalkException _v5594))) <$> getActivePurchaseVersions_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5594 -> P.Just (0, ("success",from_ProductSimpleList _v5594))) $ getActivePurchaseVersions_result_success record
    , (\_v5594 -> (1, ("e",from_TalkException _v5594))) <$> getActivePurchaseVersions_result_e record
    ]
    )
write_GetActivePurchaseVersions_result :: T.Protocol p => p -> GetActivePurchaseVersions_result -> P.IO ()
write_GetActivePurchaseVersions_result oprot record = T.writeVal oprot $ from_GetActivePurchaseVersions_result record
encode_GetActivePurchaseVersions_result :: T.StatelessProtocol p => p -> GetActivePurchaseVersions_result -> LBS.ByteString
encode_GetActivePurchaseVersions_result oprot record = T.serializeVal oprot $ from_GetActivePurchaseVersions_result record
to_GetActivePurchaseVersions_result :: T.ThriftVal -> GetActivePurchaseVersions_result
to_GetActivePurchaseVersions_result (T.TStruct fields) = GetActivePurchaseVersions_result{
  getActivePurchaseVersions_result_success = P.maybe (getActivePurchaseVersions_result_success default_GetActivePurchaseVersions_result) (\(_,_val5596) -> (case _val5596 of {T.TStruct _val5597 -> (to_ProductSimpleList (T.TStruct _val5597)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getActivePurchaseVersions_result_e = P.maybe (P.Nothing) (\(_,_val5596) -> P.Just (case _val5596 of {T.TStruct _val5598 -> (to_TalkException (T.TStruct _val5598)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetActivePurchaseVersions_result _ = P.error "not a struct"
read_GetActivePurchaseVersions_result :: T.Protocol p => p -> P.IO GetActivePurchaseVersions_result
read_GetActivePurchaseVersions_result iprot = to_GetActivePurchaseVersions_result <$> T.readVal iprot (T.T_STRUCT typemap_GetActivePurchaseVersions_result)
decode_GetActivePurchaseVersions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetActivePurchaseVersions_result
decode_GetActivePurchaseVersions_result iprot bs = to_GetActivePurchaseVersions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetActivePurchaseVersions_result) bs
typemap_GetActivePurchaseVersions_result :: T.TypeMap
typemap_GetActivePurchaseVersions_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductSimpleList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetActivePurchaseVersions_result :: GetActivePurchaseVersions_result
default_GetActivePurchaseVersions_result = GetActivePurchaseVersions_result{
  getActivePurchaseVersions_result_success = default_ProductSimpleList,
  getActivePurchaseVersions_result_e = P.Nothing}
data GetCoinProducts_args = GetCoinProducts_args  { getCoinProducts_args_appStoreCode :: PaymentType
  , getCoinProducts_args_country :: LT.Text
  , getCoinProducts_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinProducts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinProducts_args_appStoreCode record   `H.hashWithSalt` getCoinProducts_args_country record   `H.hashWithSalt` getCoinProducts_args_language record  
instance QC.Arbitrary GetCoinProducts_args where 
  arbitrary = M.liftM GetCoinProducts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetCoinProducts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinProducts_args{getCoinProducts_args_appStoreCode = getCoinProducts_args_appStoreCode obj} then P.Nothing else P.Just $ default_GetCoinProducts_args{getCoinProducts_args_appStoreCode = getCoinProducts_args_appStoreCode obj}
    , if obj == default_GetCoinProducts_args{getCoinProducts_args_country = getCoinProducts_args_country obj} then P.Nothing else P.Just $ default_GetCoinProducts_args{getCoinProducts_args_country = getCoinProducts_args_country obj}
    , if obj == default_GetCoinProducts_args{getCoinProducts_args_language = getCoinProducts_args_language obj} then P.Nothing else P.Just $ default_GetCoinProducts_args{getCoinProducts_args_language = getCoinProducts_args_language obj}
    ]
from_GetCoinProducts_args :: GetCoinProducts_args -> T.ThriftVal
from_GetCoinProducts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5601 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v5601))) $ getCoinProducts_args_appStoreCode record
  , (\_v5601 -> P.Just (3, ("country",T.TString $ E.encodeUtf8 _v5601))) $ getCoinProducts_args_country record
  , (\_v5601 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5601))) $ getCoinProducts_args_language record
  ]
write_GetCoinProducts_args :: T.Protocol p => p -> GetCoinProducts_args -> P.IO ()
write_GetCoinProducts_args oprot record = T.writeVal oprot $ from_GetCoinProducts_args record
encode_GetCoinProducts_args :: T.StatelessProtocol p => p -> GetCoinProducts_args -> LBS.ByteString
encode_GetCoinProducts_args oprot record = T.serializeVal oprot $ from_GetCoinProducts_args record
to_GetCoinProducts_args :: T.ThriftVal -> GetCoinProducts_args
to_GetCoinProducts_args (T.TStruct fields) = GetCoinProducts_args{
  getCoinProducts_args_appStoreCode = P.maybe (getCoinProducts_args_appStoreCode default_GetCoinProducts_args) (\(_,_val5603) -> (case _val5603 of {T.TI32 _val5604 -> P.toEnum $ P.fromIntegral _val5604; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getCoinProducts_args_country = P.maybe (getCoinProducts_args_country default_GetCoinProducts_args) (\(_,_val5603) -> (case _val5603 of {T.TString _val5605 -> E.decodeUtf8 _val5605; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getCoinProducts_args_language = P.maybe (getCoinProducts_args_language default_GetCoinProducts_args) (\(_,_val5603) -> (case _val5603 of {T.TString _val5606 -> E.decodeUtf8 _val5606; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetCoinProducts_args _ = P.error "not a struct"
read_GetCoinProducts_args :: T.Protocol p => p -> P.IO GetCoinProducts_args
read_GetCoinProducts_args iprot = to_GetCoinProducts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinProducts_args)
decode_GetCoinProducts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinProducts_args
decode_GetCoinProducts_args iprot bs = to_GetCoinProducts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinProducts_args) bs
typemap_GetCoinProducts_args :: T.TypeMap
typemap_GetCoinProducts_args = Map.fromList [(2,("appStoreCode",T.T_I32)),(3,("country",T.T_STRING)),(4,("language",T.T_STRING))]
default_GetCoinProducts_args :: GetCoinProducts_args
default_GetCoinProducts_args = GetCoinProducts_args{
  getCoinProducts_args_appStoreCode = (P.toEnum 0),
  getCoinProducts_args_country = "",
  getCoinProducts_args_language = ""}
data GetCoinProducts_result = GetCoinProducts_result  { getCoinProducts_result_success :: (Vector.Vector CoinProductItem)
  , getCoinProducts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinProducts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinProducts_result_success record   `H.hashWithSalt` getCoinProducts_result_e record  
instance QC.Arbitrary GetCoinProducts_result where 
  arbitrary = M.liftM GetCoinProducts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCoinProducts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinProducts_result{getCoinProducts_result_success = getCoinProducts_result_success obj} then P.Nothing else P.Just $ default_GetCoinProducts_result{getCoinProducts_result_success = getCoinProducts_result_success obj}
    , if obj == default_GetCoinProducts_result{getCoinProducts_result_e = getCoinProducts_result_e obj} then P.Nothing else P.Just $ default_GetCoinProducts_result{getCoinProducts_result_e = getCoinProducts_result_e obj}
    ]
from_GetCoinProducts_result :: GetCoinProducts_result -> T.ThriftVal
from_GetCoinProducts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5609 -> (1, ("e",from_TalkException _v5609))) <$> getCoinProducts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5609 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CoinProductItem) $ P.map (\_v5611 -> from_CoinProductItem _v5611) $ Vector.toList _v5609))) $ getCoinProducts_result_success record
    , (\_v5609 -> (1, ("e",from_TalkException _v5609))) <$> getCoinProducts_result_e record
    ]
    )
write_GetCoinProducts_result :: T.Protocol p => p -> GetCoinProducts_result -> P.IO ()
write_GetCoinProducts_result oprot record = T.writeVal oprot $ from_GetCoinProducts_result record
encode_GetCoinProducts_result :: T.StatelessProtocol p => p -> GetCoinProducts_result -> LBS.ByteString
encode_GetCoinProducts_result oprot record = T.serializeVal oprot $ from_GetCoinProducts_result record
to_GetCoinProducts_result :: T.ThriftVal -> GetCoinProducts_result
to_GetCoinProducts_result (T.TStruct fields) = GetCoinProducts_result{
  getCoinProducts_result_success = P.maybe (getCoinProducts_result_success default_GetCoinProducts_result) (\(_,_val5613) -> (case _val5613 of {T.TList _ _val5614 -> (Vector.fromList $ P.map (\_v5615 -> (case _v5615 of {T.TStruct _val5616 -> (to_CoinProductItem (T.TStruct _val5616)); _ -> P.error "wrong type"})) _val5614); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCoinProducts_result_e = P.maybe (P.Nothing) (\(_,_val5613) -> P.Just (case _val5613 of {T.TStruct _val5617 -> (to_TalkException (T.TStruct _val5617)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCoinProducts_result _ = P.error "not a struct"
read_GetCoinProducts_result :: T.Protocol p => p -> P.IO GetCoinProducts_result
read_GetCoinProducts_result iprot = to_GetCoinProducts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinProducts_result)
decode_GetCoinProducts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinProducts_result
decode_GetCoinProducts_result iprot bs = to_GetCoinProducts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinProducts_result) bs
typemap_GetCoinProducts_result :: T.TypeMap
typemap_GetCoinProducts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CoinProductItem)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCoinProducts_result :: GetCoinProducts_result
default_GetCoinProducts_result = GetCoinProducts_result{
  getCoinProducts_result_success = Vector.empty,
  getCoinProducts_result_e = P.Nothing}
data GetCoinProductsByPgCode_args = GetCoinProductsByPgCode_args  { getCoinProductsByPgCode_args_appStoreCode :: PaymentType
  , getCoinProductsByPgCode_args_pgCode :: PaymentPgType
  , getCoinProductsByPgCode_args_country :: LT.Text
  , getCoinProductsByPgCode_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinProductsByPgCode_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinProductsByPgCode_args_appStoreCode record   `H.hashWithSalt` getCoinProductsByPgCode_args_pgCode record   `H.hashWithSalt` getCoinProductsByPgCode_args_country record   `H.hashWithSalt` getCoinProductsByPgCode_args_language record  
instance QC.Arbitrary GetCoinProductsByPgCode_args where 
  arbitrary = M.liftM GetCoinProductsByPgCode_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetCoinProductsByPgCode_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_appStoreCode = getCoinProductsByPgCode_args_appStoreCode obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_appStoreCode = getCoinProductsByPgCode_args_appStoreCode obj}
    , if obj == default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_pgCode = getCoinProductsByPgCode_args_pgCode obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_pgCode = getCoinProductsByPgCode_args_pgCode obj}
    , if obj == default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_country = getCoinProductsByPgCode_args_country obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_country = getCoinProductsByPgCode_args_country obj}
    , if obj == default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_language = getCoinProductsByPgCode_args_language obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_args{getCoinProductsByPgCode_args_language = getCoinProductsByPgCode_args_language obj}
    ]
from_GetCoinProductsByPgCode_args :: GetCoinProductsByPgCode_args -> T.ThriftVal
from_GetCoinProductsByPgCode_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5620 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v5620))) $ getCoinProductsByPgCode_args_appStoreCode record
  , (\_v5620 -> P.Just (3, ("pgCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v5620))) $ getCoinProductsByPgCode_args_pgCode record
  , (\_v5620 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v5620))) $ getCoinProductsByPgCode_args_country record
  , (\_v5620 -> P.Just (5, ("language",T.TString $ E.encodeUtf8 _v5620))) $ getCoinProductsByPgCode_args_language record
  ]
write_GetCoinProductsByPgCode_args :: T.Protocol p => p -> GetCoinProductsByPgCode_args -> P.IO ()
write_GetCoinProductsByPgCode_args oprot record = T.writeVal oprot $ from_GetCoinProductsByPgCode_args record
encode_GetCoinProductsByPgCode_args :: T.StatelessProtocol p => p -> GetCoinProductsByPgCode_args -> LBS.ByteString
encode_GetCoinProductsByPgCode_args oprot record = T.serializeVal oprot $ from_GetCoinProductsByPgCode_args record
to_GetCoinProductsByPgCode_args :: T.ThriftVal -> GetCoinProductsByPgCode_args
to_GetCoinProductsByPgCode_args (T.TStruct fields) = GetCoinProductsByPgCode_args{
  getCoinProductsByPgCode_args_appStoreCode = P.maybe (getCoinProductsByPgCode_args_appStoreCode default_GetCoinProductsByPgCode_args) (\(_,_val5622) -> (case _val5622 of {T.TI32 _val5623 -> P.toEnum $ P.fromIntegral _val5623; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getCoinProductsByPgCode_args_pgCode = P.maybe (getCoinProductsByPgCode_args_pgCode default_GetCoinProductsByPgCode_args) (\(_,_val5622) -> (case _val5622 of {T.TI32 _val5624 -> P.toEnum $ P.fromIntegral _val5624; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getCoinProductsByPgCode_args_country = P.maybe (getCoinProductsByPgCode_args_country default_GetCoinProductsByPgCode_args) (\(_,_val5622) -> (case _val5622 of {T.TString _val5625 -> E.decodeUtf8 _val5625; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getCoinProductsByPgCode_args_language = P.maybe (getCoinProductsByPgCode_args_language default_GetCoinProductsByPgCode_args) (\(_,_val5622) -> (case _val5622 of {T.TString _val5626 -> E.decodeUtf8 _val5626; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetCoinProductsByPgCode_args _ = P.error "not a struct"
read_GetCoinProductsByPgCode_args :: T.Protocol p => p -> P.IO GetCoinProductsByPgCode_args
read_GetCoinProductsByPgCode_args iprot = to_GetCoinProductsByPgCode_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinProductsByPgCode_args)
decode_GetCoinProductsByPgCode_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinProductsByPgCode_args
decode_GetCoinProductsByPgCode_args iprot bs = to_GetCoinProductsByPgCode_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinProductsByPgCode_args) bs
typemap_GetCoinProductsByPgCode_args :: T.TypeMap
typemap_GetCoinProductsByPgCode_args = Map.fromList [(2,("appStoreCode",T.T_I32)),(3,("pgCode",T.T_I32)),(4,("country",T.T_STRING)),(5,("language",T.T_STRING))]
default_GetCoinProductsByPgCode_args :: GetCoinProductsByPgCode_args
default_GetCoinProductsByPgCode_args = GetCoinProductsByPgCode_args{
  getCoinProductsByPgCode_args_appStoreCode = (P.toEnum 0),
  getCoinProductsByPgCode_args_pgCode = (P.toEnum 0),
  getCoinProductsByPgCode_args_country = "",
  getCoinProductsByPgCode_args_language = ""}
data GetCoinProductsByPgCode_result = GetCoinProductsByPgCode_result  { getCoinProductsByPgCode_result_success :: (Vector.Vector CoinProductItem)
  , getCoinProductsByPgCode_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinProductsByPgCode_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinProductsByPgCode_result_success record   `H.hashWithSalt` getCoinProductsByPgCode_result_e record  
instance QC.Arbitrary GetCoinProductsByPgCode_result where 
  arbitrary = M.liftM GetCoinProductsByPgCode_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCoinProductsByPgCode_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_success = getCoinProductsByPgCode_result_success obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_success = getCoinProductsByPgCode_result_success obj}
    , if obj == default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_e = getCoinProductsByPgCode_result_e obj} then P.Nothing else P.Just $ default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_e = getCoinProductsByPgCode_result_e obj}
    ]
from_GetCoinProductsByPgCode_result :: GetCoinProductsByPgCode_result -> T.ThriftVal
from_GetCoinProductsByPgCode_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5629 -> (1, ("e",from_TalkException _v5629))) <$> getCoinProductsByPgCode_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5629 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CoinProductItem) $ P.map (\_v5631 -> from_CoinProductItem _v5631) $ Vector.toList _v5629))) $ getCoinProductsByPgCode_result_success record
    , (\_v5629 -> (1, ("e",from_TalkException _v5629))) <$> getCoinProductsByPgCode_result_e record
    ]
    )
write_GetCoinProductsByPgCode_result :: T.Protocol p => p -> GetCoinProductsByPgCode_result -> P.IO ()
write_GetCoinProductsByPgCode_result oprot record = T.writeVal oprot $ from_GetCoinProductsByPgCode_result record
encode_GetCoinProductsByPgCode_result :: T.StatelessProtocol p => p -> GetCoinProductsByPgCode_result -> LBS.ByteString
encode_GetCoinProductsByPgCode_result oprot record = T.serializeVal oprot $ from_GetCoinProductsByPgCode_result record
to_GetCoinProductsByPgCode_result :: T.ThriftVal -> GetCoinProductsByPgCode_result
to_GetCoinProductsByPgCode_result (T.TStruct fields) = GetCoinProductsByPgCode_result{
  getCoinProductsByPgCode_result_success = P.maybe (getCoinProductsByPgCode_result_success default_GetCoinProductsByPgCode_result) (\(_,_val5633) -> (case _val5633 of {T.TList _ _val5634 -> (Vector.fromList $ P.map (\_v5635 -> (case _v5635 of {T.TStruct _val5636 -> (to_CoinProductItem (T.TStruct _val5636)); _ -> P.error "wrong type"})) _val5634); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCoinProductsByPgCode_result_e = P.maybe (P.Nothing) (\(_,_val5633) -> P.Just (case _val5633 of {T.TStruct _val5637 -> (to_TalkException (T.TStruct _val5637)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCoinProductsByPgCode_result _ = P.error "not a struct"
read_GetCoinProductsByPgCode_result :: T.Protocol p => p -> P.IO GetCoinProductsByPgCode_result
read_GetCoinProductsByPgCode_result iprot = to_GetCoinProductsByPgCode_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinProductsByPgCode_result)
decode_GetCoinProductsByPgCode_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinProductsByPgCode_result
decode_GetCoinProductsByPgCode_result iprot bs = to_GetCoinProductsByPgCode_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinProductsByPgCode_result) bs
typemap_GetCoinProductsByPgCode_result :: T.TypeMap
typemap_GetCoinProductsByPgCode_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CoinProductItem)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCoinProductsByPgCode_result :: GetCoinProductsByPgCode_result
default_GetCoinProductsByPgCode_result = GetCoinProductsByPgCode_result{
  getCoinProductsByPgCode_result_success = Vector.empty,
  getCoinProductsByPgCode_result_e = P.Nothing}
data GetCoinPurchaseHistory_args = GetCoinPurchaseHistory_args  { getCoinPurchaseHistory_args_request :: CoinHistoryCondition
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinPurchaseHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinPurchaseHistory_args_request record  
instance QC.Arbitrary GetCoinPurchaseHistory_args where 
  arbitrary = M.liftM GetCoinPurchaseHistory_args (QC.arbitrary)
  shrink obj | obj == default_GetCoinPurchaseHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinPurchaseHistory_args{getCoinPurchaseHistory_args_request = getCoinPurchaseHistory_args_request obj} then P.Nothing else P.Just $ default_GetCoinPurchaseHistory_args{getCoinPurchaseHistory_args_request = getCoinPurchaseHistory_args_request obj}
    ]
from_GetCoinPurchaseHistory_args :: GetCoinPurchaseHistory_args -> T.ThriftVal
from_GetCoinPurchaseHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5640 -> P.Just (2, ("request",from_CoinHistoryCondition _v5640))) $ getCoinPurchaseHistory_args_request record
  ]
write_GetCoinPurchaseHistory_args :: T.Protocol p => p -> GetCoinPurchaseHistory_args -> P.IO ()
write_GetCoinPurchaseHistory_args oprot record = T.writeVal oprot $ from_GetCoinPurchaseHistory_args record
encode_GetCoinPurchaseHistory_args :: T.StatelessProtocol p => p -> GetCoinPurchaseHistory_args -> LBS.ByteString
encode_GetCoinPurchaseHistory_args oprot record = T.serializeVal oprot $ from_GetCoinPurchaseHistory_args record
to_GetCoinPurchaseHistory_args :: T.ThriftVal -> GetCoinPurchaseHistory_args
to_GetCoinPurchaseHistory_args (T.TStruct fields) = GetCoinPurchaseHistory_args{
  getCoinPurchaseHistory_args_request = P.maybe (getCoinPurchaseHistory_args_request default_GetCoinPurchaseHistory_args) (\(_,_val5642) -> (case _val5642 of {T.TStruct _val5643 -> (to_CoinHistoryCondition (T.TStruct _val5643)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCoinPurchaseHistory_args _ = P.error "not a struct"
read_GetCoinPurchaseHistory_args :: T.Protocol p => p -> P.IO GetCoinPurchaseHistory_args
read_GetCoinPurchaseHistory_args iprot = to_GetCoinPurchaseHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinPurchaseHistory_args)
decode_GetCoinPurchaseHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinPurchaseHistory_args
decode_GetCoinPurchaseHistory_args iprot bs = to_GetCoinPurchaseHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinPurchaseHistory_args) bs
typemap_GetCoinPurchaseHistory_args :: T.TypeMap
typemap_GetCoinPurchaseHistory_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinHistoryCondition)))]
default_GetCoinPurchaseHistory_args :: GetCoinPurchaseHistory_args
default_GetCoinPurchaseHistory_args = GetCoinPurchaseHistory_args{
  getCoinPurchaseHistory_args_request = default_CoinHistoryCondition}
data GetCoinPurchaseHistory_result = GetCoinPurchaseHistory_result  { getCoinPurchaseHistory_result_success :: CoinHistoryResult
  , getCoinPurchaseHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinPurchaseHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinPurchaseHistory_result_success record   `H.hashWithSalt` getCoinPurchaseHistory_result_e record  
instance QC.Arbitrary GetCoinPurchaseHistory_result where 
  arbitrary = M.liftM GetCoinPurchaseHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCoinPurchaseHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_success = getCoinPurchaseHistory_result_success obj} then P.Nothing else P.Just $ default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_success = getCoinPurchaseHistory_result_success obj}
    , if obj == default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_e = getCoinPurchaseHistory_result_e obj} then P.Nothing else P.Just $ default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_e = getCoinPurchaseHistory_result_e obj}
    ]
from_GetCoinPurchaseHistory_result :: GetCoinPurchaseHistory_result -> T.ThriftVal
from_GetCoinPurchaseHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5646 -> (1, ("e",from_TalkException _v5646))) <$> getCoinPurchaseHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5646 -> P.Just (0, ("success",from_CoinHistoryResult _v5646))) $ getCoinPurchaseHistory_result_success record
    , (\_v5646 -> (1, ("e",from_TalkException _v5646))) <$> getCoinPurchaseHistory_result_e record
    ]
    )
write_GetCoinPurchaseHistory_result :: T.Protocol p => p -> GetCoinPurchaseHistory_result -> P.IO ()
write_GetCoinPurchaseHistory_result oprot record = T.writeVal oprot $ from_GetCoinPurchaseHistory_result record
encode_GetCoinPurchaseHistory_result :: T.StatelessProtocol p => p -> GetCoinPurchaseHistory_result -> LBS.ByteString
encode_GetCoinPurchaseHistory_result oprot record = T.serializeVal oprot $ from_GetCoinPurchaseHistory_result record
to_GetCoinPurchaseHistory_result :: T.ThriftVal -> GetCoinPurchaseHistory_result
to_GetCoinPurchaseHistory_result (T.TStruct fields) = GetCoinPurchaseHistory_result{
  getCoinPurchaseHistory_result_success = P.maybe (getCoinPurchaseHistory_result_success default_GetCoinPurchaseHistory_result) (\(_,_val5648) -> (case _val5648 of {T.TStruct _val5649 -> (to_CoinHistoryResult (T.TStruct _val5649)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCoinPurchaseHistory_result_e = P.maybe (P.Nothing) (\(_,_val5648) -> P.Just (case _val5648 of {T.TStruct _val5650 -> (to_TalkException (T.TStruct _val5650)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCoinPurchaseHistory_result _ = P.error "not a struct"
read_GetCoinPurchaseHistory_result :: T.Protocol p => p -> P.IO GetCoinPurchaseHistory_result
read_GetCoinPurchaseHistory_result iprot = to_GetCoinPurchaseHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinPurchaseHistory_result)
decode_GetCoinPurchaseHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinPurchaseHistory_result
decode_GetCoinPurchaseHistory_result iprot bs = to_GetCoinPurchaseHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinPurchaseHistory_result) bs
typemap_GetCoinPurchaseHistory_result :: T.TypeMap
typemap_GetCoinPurchaseHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CoinHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCoinPurchaseHistory_result :: GetCoinPurchaseHistory_result
default_GetCoinPurchaseHistory_result = GetCoinPurchaseHistory_result{
  getCoinPurchaseHistory_result_success = default_CoinHistoryResult,
  getCoinPurchaseHistory_result_e = P.Nothing}
data GetCoinUseAndRefundHistory_args = GetCoinUseAndRefundHistory_args  { getCoinUseAndRefundHistory_args_request :: CoinHistoryCondition
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinUseAndRefundHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinUseAndRefundHistory_args_request record  
instance QC.Arbitrary GetCoinUseAndRefundHistory_args where 
  arbitrary = M.liftM GetCoinUseAndRefundHistory_args (QC.arbitrary)
  shrink obj | obj == default_GetCoinUseAndRefundHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinUseAndRefundHistory_args{getCoinUseAndRefundHistory_args_request = getCoinUseAndRefundHistory_args_request obj} then P.Nothing else P.Just $ default_GetCoinUseAndRefundHistory_args{getCoinUseAndRefundHistory_args_request = getCoinUseAndRefundHistory_args_request obj}
    ]
from_GetCoinUseAndRefundHistory_args :: GetCoinUseAndRefundHistory_args -> T.ThriftVal
from_GetCoinUseAndRefundHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5653 -> P.Just (2, ("request",from_CoinHistoryCondition _v5653))) $ getCoinUseAndRefundHistory_args_request record
  ]
write_GetCoinUseAndRefundHistory_args :: T.Protocol p => p -> GetCoinUseAndRefundHistory_args -> P.IO ()
write_GetCoinUseAndRefundHistory_args oprot record = T.writeVal oprot $ from_GetCoinUseAndRefundHistory_args record
encode_GetCoinUseAndRefundHistory_args :: T.StatelessProtocol p => p -> GetCoinUseAndRefundHistory_args -> LBS.ByteString
encode_GetCoinUseAndRefundHistory_args oprot record = T.serializeVal oprot $ from_GetCoinUseAndRefundHistory_args record
to_GetCoinUseAndRefundHistory_args :: T.ThriftVal -> GetCoinUseAndRefundHistory_args
to_GetCoinUseAndRefundHistory_args (T.TStruct fields) = GetCoinUseAndRefundHistory_args{
  getCoinUseAndRefundHistory_args_request = P.maybe (getCoinUseAndRefundHistory_args_request default_GetCoinUseAndRefundHistory_args) (\(_,_val5655) -> (case _val5655 of {T.TStruct _val5656 -> (to_CoinHistoryCondition (T.TStruct _val5656)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCoinUseAndRefundHistory_args _ = P.error "not a struct"
read_GetCoinUseAndRefundHistory_args :: T.Protocol p => p -> P.IO GetCoinUseAndRefundHistory_args
read_GetCoinUseAndRefundHistory_args iprot = to_GetCoinUseAndRefundHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinUseAndRefundHistory_args)
decode_GetCoinUseAndRefundHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinUseAndRefundHistory_args
decode_GetCoinUseAndRefundHistory_args iprot bs = to_GetCoinUseAndRefundHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinUseAndRefundHistory_args) bs
typemap_GetCoinUseAndRefundHistory_args :: T.TypeMap
typemap_GetCoinUseAndRefundHistory_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinHistoryCondition)))]
default_GetCoinUseAndRefundHistory_args :: GetCoinUseAndRefundHistory_args
default_GetCoinUseAndRefundHistory_args = GetCoinUseAndRefundHistory_args{
  getCoinUseAndRefundHistory_args_request = default_CoinHistoryCondition}
data GetCoinUseAndRefundHistory_result = GetCoinUseAndRefundHistory_result  { getCoinUseAndRefundHistory_result_success :: CoinHistoryResult
  , getCoinUseAndRefundHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCoinUseAndRefundHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCoinUseAndRefundHistory_result_success record   `H.hashWithSalt` getCoinUseAndRefundHistory_result_e record  
instance QC.Arbitrary GetCoinUseAndRefundHistory_result where 
  arbitrary = M.liftM GetCoinUseAndRefundHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCoinUseAndRefundHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_success = getCoinUseAndRefundHistory_result_success obj} then P.Nothing else P.Just $ default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_success = getCoinUseAndRefundHistory_result_success obj}
    , if obj == default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_e = getCoinUseAndRefundHistory_result_e obj} then P.Nothing else P.Just $ default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_e = getCoinUseAndRefundHistory_result_e obj}
    ]
from_GetCoinUseAndRefundHistory_result :: GetCoinUseAndRefundHistory_result -> T.ThriftVal
from_GetCoinUseAndRefundHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5659 -> (1, ("e",from_TalkException _v5659))) <$> getCoinUseAndRefundHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5659 -> P.Just (0, ("success",from_CoinHistoryResult _v5659))) $ getCoinUseAndRefundHistory_result_success record
    , (\_v5659 -> (1, ("e",from_TalkException _v5659))) <$> getCoinUseAndRefundHistory_result_e record
    ]
    )
write_GetCoinUseAndRefundHistory_result :: T.Protocol p => p -> GetCoinUseAndRefundHistory_result -> P.IO ()
write_GetCoinUseAndRefundHistory_result oprot record = T.writeVal oprot $ from_GetCoinUseAndRefundHistory_result record
encode_GetCoinUseAndRefundHistory_result :: T.StatelessProtocol p => p -> GetCoinUseAndRefundHistory_result -> LBS.ByteString
encode_GetCoinUseAndRefundHistory_result oprot record = T.serializeVal oprot $ from_GetCoinUseAndRefundHistory_result record
to_GetCoinUseAndRefundHistory_result :: T.ThriftVal -> GetCoinUseAndRefundHistory_result
to_GetCoinUseAndRefundHistory_result (T.TStruct fields) = GetCoinUseAndRefundHistory_result{
  getCoinUseAndRefundHistory_result_success = P.maybe (getCoinUseAndRefundHistory_result_success default_GetCoinUseAndRefundHistory_result) (\(_,_val5661) -> (case _val5661 of {T.TStruct _val5662 -> (to_CoinHistoryResult (T.TStruct _val5662)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCoinUseAndRefundHistory_result_e = P.maybe (P.Nothing) (\(_,_val5661) -> P.Just (case _val5661 of {T.TStruct _val5663 -> (to_TalkException (T.TStruct _val5663)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCoinUseAndRefundHistory_result _ = P.error "not a struct"
read_GetCoinUseAndRefundHistory_result :: T.Protocol p => p -> P.IO GetCoinUseAndRefundHistory_result
read_GetCoinUseAndRefundHistory_result iprot = to_GetCoinUseAndRefundHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCoinUseAndRefundHistory_result)
decode_GetCoinUseAndRefundHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCoinUseAndRefundHistory_result
decode_GetCoinUseAndRefundHistory_result iprot bs = to_GetCoinUseAndRefundHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCoinUseAndRefundHistory_result) bs
typemap_GetCoinUseAndRefundHistory_result :: T.TypeMap
typemap_GetCoinUseAndRefundHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CoinHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCoinUseAndRefundHistory_result :: GetCoinUseAndRefundHistory_result
default_GetCoinUseAndRefundHistory_result = GetCoinUseAndRefundHistory_result{
  getCoinUseAndRefundHistory_result_success = default_CoinHistoryResult,
  getCoinUseAndRefundHistory_result_e = P.Nothing}
data GetDownloads_args = GetDownloads_args  { getDownloads_args_start :: I.Int64
  , getDownloads_args_size :: I.Int32
  , getDownloads_args_language :: LT.Text
  , getDownloads_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDownloads_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDownloads_args_start record   `H.hashWithSalt` getDownloads_args_size record   `H.hashWithSalt` getDownloads_args_language record   `H.hashWithSalt` getDownloads_args_country record  
instance QC.Arbitrary GetDownloads_args where 
  arbitrary = M.liftM GetDownloads_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetDownloads_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDownloads_args{getDownloads_args_start = getDownloads_args_start obj} then P.Nothing else P.Just $ default_GetDownloads_args{getDownloads_args_start = getDownloads_args_start obj}
    , if obj == default_GetDownloads_args{getDownloads_args_size = getDownloads_args_size obj} then P.Nothing else P.Just $ default_GetDownloads_args{getDownloads_args_size = getDownloads_args_size obj}
    , if obj == default_GetDownloads_args{getDownloads_args_language = getDownloads_args_language obj} then P.Nothing else P.Just $ default_GetDownloads_args{getDownloads_args_language = getDownloads_args_language obj}
    , if obj == default_GetDownloads_args{getDownloads_args_country = getDownloads_args_country obj} then P.Nothing else P.Just $ default_GetDownloads_args{getDownloads_args_country = getDownloads_args_country obj}
    ]
from_GetDownloads_args :: GetDownloads_args -> T.ThriftVal
from_GetDownloads_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5666 -> P.Just (2, ("start",T.TI64 _v5666))) $ getDownloads_args_start record
  , (\_v5666 -> P.Just (3, ("size",T.TI32 _v5666))) $ getDownloads_args_size record
  , (\_v5666 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5666))) $ getDownloads_args_language record
  , (\_v5666 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5666))) $ getDownloads_args_country record
  ]
write_GetDownloads_args :: T.Protocol p => p -> GetDownloads_args -> P.IO ()
write_GetDownloads_args oprot record = T.writeVal oprot $ from_GetDownloads_args record
encode_GetDownloads_args :: T.StatelessProtocol p => p -> GetDownloads_args -> LBS.ByteString
encode_GetDownloads_args oprot record = T.serializeVal oprot $ from_GetDownloads_args record
to_GetDownloads_args :: T.ThriftVal -> GetDownloads_args
to_GetDownloads_args (T.TStruct fields) = GetDownloads_args{
  getDownloads_args_start = P.maybe (getDownloads_args_start default_GetDownloads_args) (\(_,_val5668) -> (case _val5668 of {T.TI64 _val5669 -> _val5669; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getDownloads_args_size = P.maybe (getDownloads_args_size default_GetDownloads_args) (\(_,_val5668) -> (case _val5668 of {T.TI32 _val5670 -> _val5670; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getDownloads_args_language = P.maybe (getDownloads_args_language default_GetDownloads_args) (\(_,_val5668) -> (case _val5668 of {T.TString _val5671 -> E.decodeUtf8 _val5671; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getDownloads_args_country = P.maybe (getDownloads_args_country default_GetDownloads_args) (\(_,_val5668) -> (case _val5668 of {T.TString _val5672 -> E.decodeUtf8 _val5672; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetDownloads_args _ = P.error "not a struct"
read_GetDownloads_args :: T.Protocol p => p -> P.IO GetDownloads_args
read_GetDownloads_args iprot = to_GetDownloads_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDownloads_args)
decode_GetDownloads_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDownloads_args
decode_GetDownloads_args iprot bs = to_GetDownloads_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDownloads_args) bs
typemap_GetDownloads_args :: T.TypeMap
typemap_GetDownloads_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetDownloads_args :: GetDownloads_args
default_GetDownloads_args = GetDownloads_args{
  getDownloads_args_start = 0,
  getDownloads_args_size = 0,
  getDownloads_args_language = "",
  getDownloads_args_country = ""}
data GetDownloads_result = GetDownloads_result  { getDownloads_result_success :: ProductList
  , getDownloads_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDownloads_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDownloads_result_success record   `H.hashWithSalt` getDownloads_result_e record  
instance QC.Arbitrary GetDownloads_result where 
  arbitrary = M.liftM GetDownloads_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDownloads_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDownloads_result{getDownloads_result_success = getDownloads_result_success obj} then P.Nothing else P.Just $ default_GetDownloads_result{getDownloads_result_success = getDownloads_result_success obj}
    , if obj == default_GetDownloads_result{getDownloads_result_e = getDownloads_result_e obj} then P.Nothing else P.Just $ default_GetDownloads_result{getDownloads_result_e = getDownloads_result_e obj}
    ]
from_GetDownloads_result :: GetDownloads_result -> T.ThriftVal
from_GetDownloads_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5675 -> (1, ("e",from_TalkException _v5675))) <$> getDownloads_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5675 -> P.Just (0, ("success",from_ProductList _v5675))) $ getDownloads_result_success record
    , (\_v5675 -> (1, ("e",from_TalkException _v5675))) <$> getDownloads_result_e record
    ]
    )
write_GetDownloads_result :: T.Protocol p => p -> GetDownloads_result -> P.IO ()
write_GetDownloads_result oprot record = T.writeVal oprot $ from_GetDownloads_result record
encode_GetDownloads_result :: T.StatelessProtocol p => p -> GetDownloads_result -> LBS.ByteString
encode_GetDownloads_result oprot record = T.serializeVal oprot $ from_GetDownloads_result record
to_GetDownloads_result :: T.ThriftVal -> GetDownloads_result
to_GetDownloads_result (T.TStruct fields) = GetDownloads_result{
  getDownloads_result_success = P.maybe (getDownloads_result_success default_GetDownloads_result) (\(_,_val5677) -> (case _val5677 of {T.TStruct _val5678 -> (to_ProductList (T.TStruct _val5678)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDownloads_result_e = P.maybe (P.Nothing) (\(_,_val5677) -> P.Just (case _val5677 of {T.TStruct _val5679 -> (to_TalkException (T.TStruct _val5679)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDownloads_result _ = P.error "not a struct"
read_GetDownloads_result :: T.Protocol p => p -> P.IO GetDownloads_result
read_GetDownloads_result iprot = to_GetDownloads_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDownloads_result)
decode_GetDownloads_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDownloads_result
decode_GetDownloads_result iprot bs = to_GetDownloads_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDownloads_result) bs
typemap_GetDownloads_result :: T.TypeMap
typemap_GetDownloads_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetDownloads_result :: GetDownloads_result
default_GetDownloads_result = GetDownloads_result{
  getDownloads_result_success = default_ProductList,
  getDownloads_result_e = P.Nothing}
data GetEventPackages_args = GetEventPackages_args  { getEventPackages_args_start :: I.Int64
  , getEventPackages_args_size :: I.Int32
  , getEventPackages_args_language :: LT.Text
  , getEventPackages_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetEventPackages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getEventPackages_args_start record   `H.hashWithSalt` getEventPackages_args_size record   `H.hashWithSalt` getEventPackages_args_language record   `H.hashWithSalt` getEventPackages_args_country record  
instance QC.Arbitrary GetEventPackages_args where 
  arbitrary = M.liftM GetEventPackages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetEventPackages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetEventPackages_args{getEventPackages_args_start = getEventPackages_args_start obj} then P.Nothing else P.Just $ default_GetEventPackages_args{getEventPackages_args_start = getEventPackages_args_start obj}
    , if obj == default_GetEventPackages_args{getEventPackages_args_size = getEventPackages_args_size obj} then P.Nothing else P.Just $ default_GetEventPackages_args{getEventPackages_args_size = getEventPackages_args_size obj}
    , if obj == default_GetEventPackages_args{getEventPackages_args_language = getEventPackages_args_language obj} then P.Nothing else P.Just $ default_GetEventPackages_args{getEventPackages_args_language = getEventPackages_args_language obj}
    , if obj == default_GetEventPackages_args{getEventPackages_args_country = getEventPackages_args_country obj} then P.Nothing else P.Just $ default_GetEventPackages_args{getEventPackages_args_country = getEventPackages_args_country obj}
    ]
from_GetEventPackages_args :: GetEventPackages_args -> T.ThriftVal
from_GetEventPackages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5682 -> P.Just (2, ("start",T.TI64 _v5682))) $ getEventPackages_args_start record
  , (\_v5682 -> P.Just (3, ("size",T.TI32 _v5682))) $ getEventPackages_args_size record
  , (\_v5682 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5682))) $ getEventPackages_args_language record
  , (\_v5682 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5682))) $ getEventPackages_args_country record
  ]
write_GetEventPackages_args :: T.Protocol p => p -> GetEventPackages_args -> P.IO ()
write_GetEventPackages_args oprot record = T.writeVal oprot $ from_GetEventPackages_args record
encode_GetEventPackages_args :: T.StatelessProtocol p => p -> GetEventPackages_args -> LBS.ByteString
encode_GetEventPackages_args oprot record = T.serializeVal oprot $ from_GetEventPackages_args record
to_GetEventPackages_args :: T.ThriftVal -> GetEventPackages_args
to_GetEventPackages_args (T.TStruct fields) = GetEventPackages_args{
  getEventPackages_args_start = P.maybe (getEventPackages_args_start default_GetEventPackages_args) (\(_,_val5684) -> (case _val5684 of {T.TI64 _val5685 -> _val5685; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getEventPackages_args_size = P.maybe (getEventPackages_args_size default_GetEventPackages_args) (\(_,_val5684) -> (case _val5684 of {T.TI32 _val5686 -> _val5686; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getEventPackages_args_language = P.maybe (getEventPackages_args_language default_GetEventPackages_args) (\(_,_val5684) -> (case _val5684 of {T.TString _val5687 -> E.decodeUtf8 _val5687; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getEventPackages_args_country = P.maybe (getEventPackages_args_country default_GetEventPackages_args) (\(_,_val5684) -> (case _val5684 of {T.TString _val5688 -> E.decodeUtf8 _val5688; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetEventPackages_args _ = P.error "not a struct"
read_GetEventPackages_args :: T.Protocol p => p -> P.IO GetEventPackages_args
read_GetEventPackages_args iprot = to_GetEventPackages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetEventPackages_args)
decode_GetEventPackages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetEventPackages_args
decode_GetEventPackages_args iprot bs = to_GetEventPackages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetEventPackages_args) bs
typemap_GetEventPackages_args :: T.TypeMap
typemap_GetEventPackages_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetEventPackages_args :: GetEventPackages_args
default_GetEventPackages_args = GetEventPackages_args{
  getEventPackages_args_start = 0,
  getEventPackages_args_size = 0,
  getEventPackages_args_language = "",
  getEventPackages_args_country = ""}
data GetEventPackages_result = GetEventPackages_result  { getEventPackages_result_success :: ProductList
  , getEventPackages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetEventPackages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getEventPackages_result_success record   `H.hashWithSalt` getEventPackages_result_e record  
instance QC.Arbitrary GetEventPackages_result where 
  arbitrary = M.liftM GetEventPackages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetEventPackages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetEventPackages_result{getEventPackages_result_success = getEventPackages_result_success obj} then P.Nothing else P.Just $ default_GetEventPackages_result{getEventPackages_result_success = getEventPackages_result_success obj}
    , if obj == default_GetEventPackages_result{getEventPackages_result_e = getEventPackages_result_e obj} then P.Nothing else P.Just $ default_GetEventPackages_result{getEventPackages_result_e = getEventPackages_result_e obj}
    ]
from_GetEventPackages_result :: GetEventPackages_result -> T.ThriftVal
from_GetEventPackages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5691 -> (1, ("e",from_TalkException _v5691))) <$> getEventPackages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5691 -> P.Just (0, ("success",from_ProductList _v5691))) $ getEventPackages_result_success record
    , (\_v5691 -> (1, ("e",from_TalkException _v5691))) <$> getEventPackages_result_e record
    ]
    )
write_GetEventPackages_result :: T.Protocol p => p -> GetEventPackages_result -> P.IO ()
write_GetEventPackages_result oprot record = T.writeVal oprot $ from_GetEventPackages_result record
encode_GetEventPackages_result :: T.StatelessProtocol p => p -> GetEventPackages_result -> LBS.ByteString
encode_GetEventPackages_result oprot record = T.serializeVal oprot $ from_GetEventPackages_result record
to_GetEventPackages_result :: T.ThriftVal -> GetEventPackages_result
to_GetEventPackages_result (T.TStruct fields) = GetEventPackages_result{
  getEventPackages_result_success = P.maybe (getEventPackages_result_success default_GetEventPackages_result) (\(_,_val5693) -> (case _val5693 of {T.TStruct _val5694 -> (to_ProductList (T.TStruct _val5694)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getEventPackages_result_e = P.maybe (P.Nothing) (\(_,_val5693) -> P.Just (case _val5693 of {T.TStruct _val5695 -> (to_TalkException (T.TStruct _val5695)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetEventPackages_result _ = P.error "not a struct"
read_GetEventPackages_result :: T.Protocol p => p -> P.IO GetEventPackages_result
read_GetEventPackages_result iprot = to_GetEventPackages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetEventPackages_result)
decode_GetEventPackages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetEventPackages_result
decode_GetEventPackages_result iprot bs = to_GetEventPackages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetEventPackages_result) bs
typemap_GetEventPackages_result :: T.TypeMap
typemap_GetEventPackages_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetEventPackages_result :: GetEventPackages_result
default_GetEventPackages_result = GetEventPackages_result{
  getEventPackages_result_success = default_ProductList,
  getEventPackages_result_e = P.Nothing}
data GetNewlyReleasedPackages_args = GetNewlyReleasedPackages_args  { getNewlyReleasedPackages_args_start :: I.Int64
  , getNewlyReleasedPackages_args_size :: I.Int32
  , getNewlyReleasedPackages_args_language :: LT.Text
  , getNewlyReleasedPackages_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNewlyReleasedPackages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNewlyReleasedPackages_args_start record   `H.hashWithSalt` getNewlyReleasedPackages_args_size record   `H.hashWithSalt` getNewlyReleasedPackages_args_language record   `H.hashWithSalt` getNewlyReleasedPackages_args_country record  
instance QC.Arbitrary GetNewlyReleasedPackages_args where 
  arbitrary = M.liftM GetNewlyReleasedPackages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNewlyReleasedPackages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_start = getNewlyReleasedPackages_args_start obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_start = getNewlyReleasedPackages_args_start obj}
    , if obj == default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_size = getNewlyReleasedPackages_args_size obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_size = getNewlyReleasedPackages_args_size obj}
    , if obj == default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_language = getNewlyReleasedPackages_args_language obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_language = getNewlyReleasedPackages_args_language obj}
    , if obj == default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_country = getNewlyReleasedPackages_args_country obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_args{getNewlyReleasedPackages_args_country = getNewlyReleasedPackages_args_country obj}
    ]
from_GetNewlyReleasedPackages_args :: GetNewlyReleasedPackages_args -> T.ThriftVal
from_GetNewlyReleasedPackages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5698 -> P.Just (2, ("start",T.TI64 _v5698))) $ getNewlyReleasedPackages_args_start record
  , (\_v5698 -> P.Just (3, ("size",T.TI32 _v5698))) $ getNewlyReleasedPackages_args_size record
  , (\_v5698 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5698))) $ getNewlyReleasedPackages_args_language record
  , (\_v5698 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5698))) $ getNewlyReleasedPackages_args_country record
  ]
write_GetNewlyReleasedPackages_args :: T.Protocol p => p -> GetNewlyReleasedPackages_args -> P.IO ()
write_GetNewlyReleasedPackages_args oprot record = T.writeVal oprot $ from_GetNewlyReleasedPackages_args record
encode_GetNewlyReleasedPackages_args :: T.StatelessProtocol p => p -> GetNewlyReleasedPackages_args -> LBS.ByteString
encode_GetNewlyReleasedPackages_args oprot record = T.serializeVal oprot $ from_GetNewlyReleasedPackages_args record
to_GetNewlyReleasedPackages_args :: T.ThriftVal -> GetNewlyReleasedPackages_args
to_GetNewlyReleasedPackages_args (T.TStruct fields) = GetNewlyReleasedPackages_args{
  getNewlyReleasedPackages_args_start = P.maybe (getNewlyReleasedPackages_args_start default_GetNewlyReleasedPackages_args) (\(_,_val5700) -> (case _val5700 of {T.TI64 _val5701 -> _val5701; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNewlyReleasedPackages_args_size = P.maybe (getNewlyReleasedPackages_args_size default_GetNewlyReleasedPackages_args) (\(_,_val5700) -> (case _val5700 of {T.TI32 _val5702 -> _val5702; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNewlyReleasedPackages_args_language = P.maybe (getNewlyReleasedPackages_args_language default_GetNewlyReleasedPackages_args) (\(_,_val5700) -> (case _val5700 of {T.TString _val5703 -> E.decodeUtf8 _val5703; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getNewlyReleasedPackages_args_country = P.maybe (getNewlyReleasedPackages_args_country default_GetNewlyReleasedPackages_args) (\(_,_val5700) -> (case _val5700 of {T.TString _val5704 -> E.decodeUtf8 _val5704; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetNewlyReleasedPackages_args _ = P.error "not a struct"
read_GetNewlyReleasedPackages_args :: T.Protocol p => p -> P.IO GetNewlyReleasedPackages_args
read_GetNewlyReleasedPackages_args iprot = to_GetNewlyReleasedPackages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNewlyReleasedPackages_args)
decode_GetNewlyReleasedPackages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNewlyReleasedPackages_args
decode_GetNewlyReleasedPackages_args iprot bs = to_GetNewlyReleasedPackages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNewlyReleasedPackages_args) bs
typemap_GetNewlyReleasedPackages_args :: T.TypeMap
typemap_GetNewlyReleasedPackages_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetNewlyReleasedPackages_args :: GetNewlyReleasedPackages_args
default_GetNewlyReleasedPackages_args = GetNewlyReleasedPackages_args{
  getNewlyReleasedPackages_args_start = 0,
  getNewlyReleasedPackages_args_size = 0,
  getNewlyReleasedPackages_args_language = "",
  getNewlyReleasedPackages_args_country = ""}
data GetNewlyReleasedPackages_result = GetNewlyReleasedPackages_result  { getNewlyReleasedPackages_result_success :: ProductList
  , getNewlyReleasedPackages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNewlyReleasedPackages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNewlyReleasedPackages_result_success record   `H.hashWithSalt` getNewlyReleasedPackages_result_e record  
instance QC.Arbitrary GetNewlyReleasedPackages_result where 
  arbitrary = M.liftM GetNewlyReleasedPackages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNewlyReleasedPackages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_success = getNewlyReleasedPackages_result_success obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_success = getNewlyReleasedPackages_result_success obj}
    , if obj == default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_e = getNewlyReleasedPackages_result_e obj} then P.Nothing else P.Just $ default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_e = getNewlyReleasedPackages_result_e obj}
    ]
from_GetNewlyReleasedPackages_result :: GetNewlyReleasedPackages_result -> T.ThriftVal
from_GetNewlyReleasedPackages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5707 -> (1, ("e",from_TalkException _v5707))) <$> getNewlyReleasedPackages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5707 -> P.Just (0, ("success",from_ProductList _v5707))) $ getNewlyReleasedPackages_result_success record
    , (\_v5707 -> (1, ("e",from_TalkException _v5707))) <$> getNewlyReleasedPackages_result_e record
    ]
    )
write_GetNewlyReleasedPackages_result :: T.Protocol p => p -> GetNewlyReleasedPackages_result -> P.IO ()
write_GetNewlyReleasedPackages_result oprot record = T.writeVal oprot $ from_GetNewlyReleasedPackages_result record
encode_GetNewlyReleasedPackages_result :: T.StatelessProtocol p => p -> GetNewlyReleasedPackages_result -> LBS.ByteString
encode_GetNewlyReleasedPackages_result oprot record = T.serializeVal oprot $ from_GetNewlyReleasedPackages_result record
to_GetNewlyReleasedPackages_result :: T.ThriftVal -> GetNewlyReleasedPackages_result
to_GetNewlyReleasedPackages_result (T.TStruct fields) = GetNewlyReleasedPackages_result{
  getNewlyReleasedPackages_result_success = P.maybe (getNewlyReleasedPackages_result_success default_GetNewlyReleasedPackages_result) (\(_,_val5709) -> (case _val5709 of {T.TStruct _val5710 -> (to_ProductList (T.TStruct _val5710)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNewlyReleasedPackages_result_e = P.maybe (P.Nothing) (\(_,_val5709) -> P.Just (case _val5709 of {T.TStruct _val5711 -> (to_TalkException (T.TStruct _val5711)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetNewlyReleasedPackages_result _ = P.error "not a struct"
read_GetNewlyReleasedPackages_result :: T.Protocol p => p -> P.IO GetNewlyReleasedPackages_result
read_GetNewlyReleasedPackages_result iprot = to_GetNewlyReleasedPackages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNewlyReleasedPackages_result)
decode_GetNewlyReleasedPackages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNewlyReleasedPackages_result
decode_GetNewlyReleasedPackages_result iprot bs = to_GetNewlyReleasedPackages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNewlyReleasedPackages_result) bs
typemap_GetNewlyReleasedPackages_result :: T.TypeMap
typemap_GetNewlyReleasedPackages_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetNewlyReleasedPackages_result :: GetNewlyReleasedPackages_result
default_GetNewlyReleasedPackages_result = GetNewlyReleasedPackages_result{
  getNewlyReleasedPackages_result_success = default_ProductList,
  getNewlyReleasedPackages_result_e = P.Nothing}
data GetPopularPackages_args = GetPopularPackages_args  { getPopularPackages_args_start :: I.Int64
  , getPopularPackages_args_size :: I.Int32
  , getPopularPackages_args_language :: LT.Text
  , getPopularPackages_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPopularPackages_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPopularPackages_args_start record   `H.hashWithSalt` getPopularPackages_args_size record   `H.hashWithSalt` getPopularPackages_args_language record   `H.hashWithSalt` getPopularPackages_args_country record  
instance QC.Arbitrary GetPopularPackages_args where 
  arbitrary = M.liftM GetPopularPackages_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPopularPackages_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPopularPackages_args{getPopularPackages_args_start = getPopularPackages_args_start obj} then P.Nothing else P.Just $ default_GetPopularPackages_args{getPopularPackages_args_start = getPopularPackages_args_start obj}
    , if obj == default_GetPopularPackages_args{getPopularPackages_args_size = getPopularPackages_args_size obj} then P.Nothing else P.Just $ default_GetPopularPackages_args{getPopularPackages_args_size = getPopularPackages_args_size obj}
    , if obj == default_GetPopularPackages_args{getPopularPackages_args_language = getPopularPackages_args_language obj} then P.Nothing else P.Just $ default_GetPopularPackages_args{getPopularPackages_args_language = getPopularPackages_args_language obj}
    , if obj == default_GetPopularPackages_args{getPopularPackages_args_country = getPopularPackages_args_country obj} then P.Nothing else P.Just $ default_GetPopularPackages_args{getPopularPackages_args_country = getPopularPackages_args_country obj}
    ]
from_GetPopularPackages_args :: GetPopularPackages_args -> T.ThriftVal
from_GetPopularPackages_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5714 -> P.Just (2, ("start",T.TI64 _v5714))) $ getPopularPackages_args_start record
  , (\_v5714 -> P.Just (3, ("size",T.TI32 _v5714))) $ getPopularPackages_args_size record
  , (\_v5714 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5714))) $ getPopularPackages_args_language record
  , (\_v5714 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5714))) $ getPopularPackages_args_country record
  ]
write_GetPopularPackages_args :: T.Protocol p => p -> GetPopularPackages_args -> P.IO ()
write_GetPopularPackages_args oprot record = T.writeVal oprot $ from_GetPopularPackages_args record
encode_GetPopularPackages_args :: T.StatelessProtocol p => p -> GetPopularPackages_args -> LBS.ByteString
encode_GetPopularPackages_args oprot record = T.serializeVal oprot $ from_GetPopularPackages_args record
to_GetPopularPackages_args :: T.ThriftVal -> GetPopularPackages_args
to_GetPopularPackages_args (T.TStruct fields) = GetPopularPackages_args{
  getPopularPackages_args_start = P.maybe (getPopularPackages_args_start default_GetPopularPackages_args) (\(_,_val5716) -> (case _val5716 of {T.TI64 _val5717 -> _val5717; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPopularPackages_args_size = P.maybe (getPopularPackages_args_size default_GetPopularPackages_args) (\(_,_val5716) -> (case _val5716 of {T.TI32 _val5718 -> _val5718; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPopularPackages_args_language = P.maybe (getPopularPackages_args_language default_GetPopularPackages_args) (\(_,_val5716) -> (case _val5716 of {T.TString _val5719 -> E.decodeUtf8 _val5719; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getPopularPackages_args_country = P.maybe (getPopularPackages_args_country default_GetPopularPackages_args) (\(_,_val5716) -> (case _val5716 of {T.TString _val5720 -> E.decodeUtf8 _val5720; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetPopularPackages_args _ = P.error "not a struct"
read_GetPopularPackages_args :: T.Protocol p => p -> P.IO GetPopularPackages_args
read_GetPopularPackages_args iprot = to_GetPopularPackages_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPopularPackages_args)
decode_GetPopularPackages_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPopularPackages_args
decode_GetPopularPackages_args iprot bs = to_GetPopularPackages_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPopularPackages_args) bs
typemap_GetPopularPackages_args :: T.TypeMap
typemap_GetPopularPackages_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetPopularPackages_args :: GetPopularPackages_args
default_GetPopularPackages_args = GetPopularPackages_args{
  getPopularPackages_args_start = 0,
  getPopularPackages_args_size = 0,
  getPopularPackages_args_language = "",
  getPopularPackages_args_country = ""}
data GetPopularPackages_result = GetPopularPackages_result  { getPopularPackages_result_success :: ProductList
  , getPopularPackages_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPopularPackages_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPopularPackages_result_success record   `H.hashWithSalt` getPopularPackages_result_e record  
instance QC.Arbitrary GetPopularPackages_result where 
  arbitrary = M.liftM GetPopularPackages_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPopularPackages_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPopularPackages_result{getPopularPackages_result_success = getPopularPackages_result_success obj} then P.Nothing else P.Just $ default_GetPopularPackages_result{getPopularPackages_result_success = getPopularPackages_result_success obj}
    , if obj == default_GetPopularPackages_result{getPopularPackages_result_e = getPopularPackages_result_e obj} then P.Nothing else P.Just $ default_GetPopularPackages_result{getPopularPackages_result_e = getPopularPackages_result_e obj}
    ]
from_GetPopularPackages_result :: GetPopularPackages_result -> T.ThriftVal
from_GetPopularPackages_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5723 -> (1, ("e",from_TalkException _v5723))) <$> getPopularPackages_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5723 -> P.Just (0, ("success",from_ProductList _v5723))) $ getPopularPackages_result_success record
    , (\_v5723 -> (1, ("e",from_TalkException _v5723))) <$> getPopularPackages_result_e record
    ]
    )
write_GetPopularPackages_result :: T.Protocol p => p -> GetPopularPackages_result -> P.IO ()
write_GetPopularPackages_result oprot record = T.writeVal oprot $ from_GetPopularPackages_result record
encode_GetPopularPackages_result :: T.StatelessProtocol p => p -> GetPopularPackages_result -> LBS.ByteString
encode_GetPopularPackages_result oprot record = T.serializeVal oprot $ from_GetPopularPackages_result record
to_GetPopularPackages_result :: T.ThriftVal -> GetPopularPackages_result
to_GetPopularPackages_result (T.TStruct fields) = GetPopularPackages_result{
  getPopularPackages_result_success = P.maybe (getPopularPackages_result_success default_GetPopularPackages_result) (\(_,_val5725) -> (case _val5725 of {T.TStruct _val5726 -> (to_ProductList (T.TStruct _val5726)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPopularPackages_result_e = P.maybe (P.Nothing) (\(_,_val5725) -> P.Just (case _val5725 of {T.TStruct _val5727 -> (to_TalkException (T.TStruct _val5727)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPopularPackages_result _ = P.error "not a struct"
read_GetPopularPackages_result :: T.Protocol p => p -> P.IO GetPopularPackages_result
read_GetPopularPackages_result iprot = to_GetPopularPackages_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPopularPackages_result)
decode_GetPopularPackages_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPopularPackages_result
decode_GetPopularPackages_result iprot bs = to_GetPopularPackages_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPopularPackages_result) bs
typemap_GetPopularPackages_result :: T.TypeMap
typemap_GetPopularPackages_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPopularPackages_result :: GetPopularPackages_result
default_GetPopularPackages_result = GetPopularPackages_result{
  getPopularPackages_result_success = default_ProductList,
  getPopularPackages_result_e = P.Nothing}
data GetPresentsReceived_args = GetPresentsReceived_args  { getPresentsReceived_args_start :: I.Int64
  , getPresentsReceived_args_size :: I.Int32
  , getPresentsReceived_args_language :: LT.Text
  , getPresentsReceived_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPresentsReceived_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPresentsReceived_args_start record   `H.hashWithSalt` getPresentsReceived_args_size record   `H.hashWithSalt` getPresentsReceived_args_language record   `H.hashWithSalt` getPresentsReceived_args_country record  
instance QC.Arbitrary GetPresentsReceived_args where 
  arbitrary = M.liftM GetPresentsReceived_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPresentsReceived_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPresentsReceived_args{getPresentsReceived_args_start = getPresentsReceived_args_start obj} then P.Nothing else P.Just $ default_GetPresentsReceived_args{getPresentsReceived_args_start = getPresentsReceived_args_start obj}
    , if obj == default_GetPresentsReceived_args{getPresentsReceived_args_size = getPresentsReceived_args_size obj} then P.Nothing else P.Just $ default_GetPresentsReceived_args{getPresentsReceived_args_size = getPresentsReceived_args_size obj}
    , if obj == default_GetPresentsReceived_args{getPresentsReceived_args_language = getPresentsReceived_args_language obj} then P.Nothing else P.Just $ default_GetPresentsReceived_args{getPresentsReceived_args_language = getPresentsReceived_args_language obj}
    , if obj == default_GetPresentsReceived_args{getPresentsReceived_args_country = getPresentsReceived_args_country obj} then P.Nothing else P.Just $ default_GetPresentsReceived_args{getPresentsReceived_args_country = getPresentsReceived_args_country obj}
    ]
from_GetPresentsReceived_args :: GetPresentsReceived_args -> T.ThriftVal
from_GetPresentsReceived_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5730 -> P.Just (2, ("start",T.TI64 _v5730))) $ getPresentsReceived_args_start record
  , (\_v5730 -> P.Just (3, ("size",T.TI32 _v5730))) $ getPresentsReceived_args_size record
  , (\_v5730 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5730))) $ getPresentsReceived_args_language record
  , (\_v5730 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5730))) $ getPresentsReceived_args_country record
  ]
write_GetPresentsReceived_args :: T.Protocol p => p -> GetPresentsReceived_args -> P.IO ()
write_GetPresentsReceived_args oprot record = T.writeVal oprot $ from_GetPresentsReceived_args record
encode_GetPresentsReceived_args :: T.StatelessProtocol p => p -> GetPresentsReceived_args -> LBS.ByteString
encode_GetPresentsReceived_args oprot record = T.serializeVal oprot $ from_GetPresentsReceived_args record
to_GetPresentsReceived_args :: T.ThriftVal -> GetPresentsReceived_args
to_GetPresentsReceived_args (T.TStruct fields) = GetPresentsReceived_args{
  getPresentsReceived_args_start = P.maybe (getPresentsReceived_args_start default_GetPresentsReceived_args) (\(_,_val5732) -> (case _val5732 of {T.TI64 _val5733 -> _val5733; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPresentsReceived_args_size = P.maybe (getPresentsReceived_args_size default_GetPresentsReceived_args) (\(_,_val5732) -> (case _val5732 of {T.TI32 _val5734 -> _val5734; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPresentsReceived_args_language = P.maybe (getPresentsReceived_args_language default_GetPresentsReceived_args) (\(_,_val5732) -> (case _val5732 of {T.TString _val5735 -> E.decodeUtf8 _val5735; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getPresentsReceived_args_country = P.maybe (getPresentsReceived_args_country default_GetPresentsReceived_args) (\(_,_val5732) -> (case _val5732 of {T.TString _val5736 -> E.decodeUtf8 _val5736; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetPresentsReceived_args _ = P.error "not a struct"
read_GetPresentsReceived_args :: T.Protocol p => p -> P.IO GetPresentsReceived_args
read_GetPresentsReceived_args iprot = to_GetPresentsReceived_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPresentsReceived_args)
decode_GetPresentsReceived_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPresentsReceived_args
decode_GetPresentsReceived_args iprot bs = to_GetPresentsReceived_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPresentsReceived_args) bs
typemap_GetPresentsReceived_args :: T.TypeMap
typemap_GetPresentsReceived_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetPresentsReceived_args :: GetPresentsReceived_args
default_GetPresentsReceived_args = GetPresentsReceived_args{
  getPresentsReceived_args_start = 0,
  getPresentsReceived_args_size = 0,
  getPresentsReceived_args_language = "",
  getPresentsReceived_args_country = ""}
data GetPresentsReceived_result = GetPresentsReceived_result  { getPresentsReceived_result_success :: ProductList
  , getPresentsReceived_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPresentsReceived_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPresentsReceived_result_success record   `H.hashWithSalt` getPresentsReceived_result_e record  
instance QC.Arbitrary GetPresentsReceived_result where 
  arbitrary = M.liftM GetPresentsReceived_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPresentsReceived_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPresentsReceived_result{getPresentsReceived_result_success = getPresentsReceived_result_success obj} then P.Nothing else P.Just $ default_GetPresentsReceived_result{getPresentsReceived_result_success = getPresentsReceived_result_success obj}
    , if obj == default_GetPresentsReceived_result{getPresentsReceived_result_e = getPresentsReceived_result_e obj} then P.Nothing else P.Just $ default_GetPresentsReceived_result{getPresentsReceived_result_e = getPresentsReceived_result_e obj}
    ]
from_GetPresentsReceived_result :: GetPresentsReceived_result -> T.ThriftVal
from_GetPresentsReceived_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5739 -> (1, ("e",from_TalkException _v5739))) <$> getPresentsReceived_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5739 -> P.Just (0, ("success",from_ProductList _v5739))) $ getPresentsReceived_result_success record
    , (\_v5739 -> (1, ("e",from_TalkException _v5739))) <$> getPresentsReceived_result_e record
    ]
    )
write_GetPresentsReceived_result :: T.Protocol p => p -> GetPresentsReceived_result -> P.IO ()
write_GetPresentsReceived_result oprot record = T.writeVal oprot $ from_GetPresentsReceived_result record
encode_GetPresentsReceived_result :: T.StatelessProtocol p => p -> GetPresentsReceived_result -> LBS.ByteString
encode_GetPresentsReceived_result oprot record = T.serializeVal oprot $ from_GetPresentsReceived_result record
to_GetPresentsReceived_result :: T.ThriftVal -> GetPresentsReceived_result
to_GetPresentsReceived_result (T.TStruct fields) = GetPresentsReceived_result{
  getPresentsReceived_result_success = P.maybe (getPresentsReceived_result_success default_GetPresentsReceived_result) (\(_,_val5741) -> (case _val5741 of {T.TStruct _val5742 -> (to_ProductList (T.TStruct _val5742)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPresentsReceived_result_e = P.maybe (P.Nothing) (\(_,_val5741) -> P.Just (case _val5741 of {T.TStruct _val5743 -> (to_TalkException (T.TStruct _val5743)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPresentsReceived_result _ = P.error "not a struct"
read_GetPresentsReceived_result :: T.Protocol p => p -> P.IO GetPresentsReceived_result
read_GetPresentsReceived_result iprot = to_GetPresentsReceived_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPresentsReceived_result)
decode_GetPresentsReceived_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPresentsReceived_result
decode_GetPresentsReceived_result iprot bs = to_GetPresentsReceived_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPresentsReceived_result) bs
typemap_GetPresentsReceived_result :: T.TypeMap
typemap_GetPresentsReceived_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPresentsReceived_result :: GetPresentsReceived_result
default_GetPresentsReceived_result = GetPresentsReceived_result{
  getPresentsReceived_result_success = default_ProductList,
  getPresentsReceived_result_e = P.Nothing}
data GetPresentsSent_args = GetPresentsSent_args  { getPresentsSent_args_start :: I.Int64
  , getPresentsSent_args_size :: I.Int32
  , getPresentsSent_args_language :: LT.Text
  , getPresentsSent_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPresentsSent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPresentsSent_args_start record   `H.hashWithSalt` getPresentsSent_args_size record   `H.hashWithSalt` getPresentsSent_args_language record   `H.hashWithSalt` getPresentsSent_args_country record  
instance QC.Arbitrary GetPresentsSent_args where 
  arbitrary = M.liftM GetPresentsSent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPresentsSent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPresentsSent_args{getPresentsSent_args_start = getPresentsSent_args_start obj} then P.Nothing else P.Just $ default_GetPresentsSent_args{getPresentsSent_args_start = getPresentsSent_args_start obj}
    , if obj == default_GetPresentsSent_args{getPresentsSent_args_size = getPresentsSent_args_size obj} then P.Nothing else P.Just $ default_GetPresentsSent_args{getPresentsSent_args_size = getPresentsSent_args_size obj}
    , if obj == default_GetPresentsSent_args{getPresentsSent_args_language = getPresentsSent_args_language obj} then P.Nothing else P.Just $ default_GetPresentsSent_args{getPresentsSent_args_language = getPresentsSent_args_language obj}
    , if obj == default_GetPresentsSent_args{getPresentsSent_args_country = getPresentsSent_args_country obj} then P.Nothing else P.Just $ default_GetPresentsSent_args{getPresentsSent_args_country = getPresentsSent_args_country obj}
    ]
from_GetPresentsSent_args :: GetPresentsSent_args -> T.ThriftVal
from_GetPresentsSent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5746 -> P.Just (2, ("start",T.TI64 _v5746))) $ getPresentsSent_args_start record
  , (\_v5746 -> P.Just (3, ("size",T.TI32 _v5746))) $ getPresentsSent_args_size record
  , (\_v5746 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5746))) $ getPresentsSent_args_language record
  , (\_v5746 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5746))) $ getPresentsSent_args_country record
  ]
write_GetPresentsSent_args :: T.Protocol p => p -> GetPresentsSent_args -> P.IO ()
write_GetPresentsSent_args oprot record = T.writeVal oprot $ from_GetPresentsSent_args record
encode_GetPresentsSent_args :: T.StatelessProtocol p => p -> GetPresentsSent_args -> LBS.ByteString
encode_GetPresentsSent_args oprot record = T.serializeVal oprot $ from_GetPresentsSent_args record
to_GetPresentsSent_args :: T.ThriftVal -> GetPresentsSent_args
to_GetPresentsSent_args (T.TStruct fields) = GetPresentsSent_args{
  getPresentsSent_args_start = P.maybe (getPresentsSent_args_start default_GetPresentsSent_args) (\(_,_val5748) -> (case _val5748 of {T.TI64 _val5749 -> _val5749; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPresentsSent_args_size = P.maybe (getPresentsSent_args_size default_GetPresentsSent_args) (\(_,_val5748) -> (case _val5748 of {T.TI32 _val5750 -> _val5750; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPresentsSent_args_language = P.maybe (getPresentsSent_args_language default_GetPresentsSent_args) (\(_,_val5748) -> (case _val5748 of {T.TString _val5751 -> E.decodeUtf8 _val5751; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getPresentsSent_args_country = P.maybe (getPresentsSent_args_country default_GetPresentsSent_args) (\(_,_val5748) -> (case _val5748 of {T.TString _val5752 -> E.decodeUtf8 _val5752; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetPresentsSent_args _ = P.error "not a struct"
read_GetPresentsSent_args :: T.Protocol p => p -> P.IO GetPresentsSent_args
read_GetPresentsSent_args iprot = to_GetPresentsSent_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPresentsSent_args)
decode_GetPresentsSent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPresentsSent_args
decode_GetPresentsSent_args iprot bs = to_GetPresentsSent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPresentsSent_args) bs
typemap_GetPresentsSent_args :: T.TypeMap
typemap_GetPresentsSent_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetPresentsSent_args :: GetPresentsSent_args
default_GetPresentsSent_args = GetPresentsSent_args{
  getPresentsSent_args_start = 0,
  getPresentsSent_args_size = 0,
  getPresentsSent_args_language = "",
  getPresentsSent_args_country = ""}
data GetPresentsSent_result = GetPresentsSent_result  { getPresentsSent_result_success :: ProductList
  , getPresentsSent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPresentsSent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPresentsSent_result_success record   `H.hashWithSalt` getPresentsSent_result_e record  
instance QC.Arbitrary GetPresentsSent_result where 
  arbitrary = M.liftM GetPresentsSent_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPresentsSent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPresentsSent_result{getPresentsSent_result_success = getPresentsSent_result_success obj} then P.Nothing else P.Just $ default_GetPresentsSent_result{getPresentsSent_result_success = getPresentsSent_result_success obj}
    , if obj == default_GetPresentsSent_result{getPresentsSent_result_e = getPresentsSent_result_e obj} then P.Nothing else P.Just $ default_GetPresentsSent_result{getPresentsSent_result_e = getPresentsSent_result_e obj}
    ]
from_GetPresentsSent_result :: GetPresentsSent_result -> T.ThriftVal
from_GetPresentsSent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5755 -> (1, ("e",from_TalkException _v5755))) <$> getPresentsSent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5755 -> P.Just (0, ("success",from_ProductList _v5755))) $ getPresentsSent_result_success record
    , (\_v5755 -> (1, ("e",from_TalkException _v5755))) <$> getPresentsSent_result_e record
    ]
    )
write_GetPresentsSent_result :: T.Protocol p => p -> GetPresentsSent_result -> P.IO ()
write_GetPresentsSent_result oprot record = T.writeVal oprot $ from_GetPresentsSent_result record
encode_GetPresentsSent_result :: T.StatelessProtocol p => p -> GetPresentsSent_result -> LBS.ByteString
encode_GetPresentsSent_result oprot record = T.serializeVal oprot $ from_GetPresentsSent_result record
to_GetPresentsSent_result :: T.ThriftVal -> GetPresentsSent_result
to_GetPresentsSent_result (T.TStruct fields) = GetPresentsSent_result{
  getPresentsSent_result_success = P.maybe (getPresentsSent_result_success default_GetPresentsSent_result) (\(_,_val5757) -> (case _val5757 of {T.TStruct _val5758 -> (to_ProductList (T.TStruct _val5758)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPresentsSent_result_e = P.maybe (P.Nothing) (\(_,_val5757) -> P.Just (case _val5757 of {T.TStruct _val5759 -> (to_TalkException (T.TStruct _val5759)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPresentsSent_result _ = P.error "not a struct"
read_GetPresentsSent_result :: T.Protocol p => p -> P.IO GetPresentsSent_result
read_GetPresentsSent_result iprot = to_GetPresentsSent_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPresentsSent_result)
decode_GetPresentsSent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPresentsSent_result
decode_GetPresentsSent_result iprot bs = to_GetPresentsSent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPresentsSent_result) bs
typemap_GetPresentsSent_result :: T.TypeMap
typemap_GetPresentsSent_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPresentsSent_result :: GetPresentsSent_result
default_GetPresentsSent_result = GetPresentsSent_result{
  getPresentsSent_result_success = default_ProductList,
  getPresentsSent_result_e = P.Nothing}
data GetProduct_args = GetProduct_args  { getProduct_args_packageID :: I.Int64
  , getProduct_args_language :: LT.Text
  , getProduct_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProduct_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProduct_args_packageID record   `H.hashWithSalt` getProduct_args_language record   `H.hashWithSalt` getProduct_args_country record  
instance QC.Arbitrary GetProduct_args where 
  arbitrary = M.liftM GetProduct_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetProduct_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProduct_args{getProduct_args_packageID = getProduct_args_packageID obj} then P.Nothing else P.Just $ default_GetProduct_args{getProduct_args_packageID = getProduct_args_packageID obj}
    , if obj == default_GetProduct_args{getProduct_args_language = getProduct_args_language obj} then P.Nothing else P.Just $ default_GetProduct_args{getProduct_args_language = getProduct_args_language obj}
    , if obj == default_GetProduct_args{getProduct_args_country = getProduct_args_country obj} then P.Nothing else P.Just $ default_GetProduct_args{getProduct_args_country = getProduct_args_country obj}
    ]
from_GetProduct_args :: GetProduct_args -> T.ThriftVal
from_GetProduct_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5762 -> P.Just (2, ("packageID",T.TI64 _v5762))) $ getProduct_args_packageID record
  , (\_v5762 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v5762))) $ getProduct_args_language record
  , (\_v5762 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v5762))) $ getProduct_args_country record
  ]
write_GetProduct_args :: T.Protocol p => p -> GetProduct_args -> P.IO ()
write_GetProduct_args oprot record = T.writeVal oprot $ from_GetProduct_args record
encode_GetProduct_args :: T.StatelessProtocol p => p -> GetProduct_args -> LBS.ByteString
encode_GetProduct_args oprot record = T.serializeVal oprot $ from_GetProduct_args record
to_GetProduct_args :: T.ThriftVal -> GetProduct_args
to_GetProduct_args (T.TStruct fields) = GetProduct_args{
  getProduct_args_packageID = P.maybe (getProduct_args_packageID default_GetProduct_args) (\(_,_val5764) -> (case _val5764 of {T.TI64 _val5765 -> _val5765; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getProduct_args_language = P.maybe (getProduct_args_language default_GetProduct_args) (\(_,_val5764) -> (case _val5764 of {T.TString _val5766 -> E.decodeUtf8 _val5766; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getProduct_args_country = P.maybe (getProduct_args_country default_GetProduct_args) (\(_,_val5764) -> (case _val5764 of {T.TString _val5767 -> E.decodeUtf8 _val5767; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetProduct_args _ = P.error "not a struct"
read_GetProduct_args :: T.Protocol p => p -> P.IO GetProduct_args
read_GetProduct_args iprot = to_GetProduct_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProduct_args)
decode_GetProduct_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProduct_args
decode_GetProduct_args iprot bs = to_GetProduct_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProduct_args) bs
typemap_GetProduct_args :: T.TypeMap
typemap_GetProduct_args = Map.fromList [(2,("packageID",T.T_I64)),(3,("language",T.T_STRING)),(4,("country",T.T_STRING))]
default_GetProduct_args :: GetProduct_args
default_GetProduct_args = GetProduct_args{
  getProduct_args_packageID = 0,
  getProduct_args_language = "",
  getProduct_args_country = ""}
data GetProduct_result = GetProduct_result  { getProduct_result_success :: Product
  , getProduct_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProduct_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProduct_result_success record   `H.hashWithSalt` getProduct_result_e record  
instance QC.Arbitrary GetProduct_result where 
  arbitrary = M.liftM GetProduct_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProduct_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProduct_result{getProduct_result_success = getProduct_result_success obj} then P.Nothing else P.Just $ default_GetProduct_result{getProduct_result_success = getProduct_result_success obj}
    , if obj == default_GetProduct_result{getProduct_result_e = getProduct_result_e obj} then P.Nothing else P.Just $ default_GetProduct_result{getProduct_result_e = getProduct_result_e obj}
    ]
from_GetProduct_result :: GetProduct_result -> T.ThriftVal
from_GetProduct_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5770 -> (1, ("e",from_TalkException _v5770))) <$> getProduct_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5770 -> P.Just (0, ("success",from_Product _v5770))) $ getProduct_result_success record
    , (\_v5770 -> (1, ("e",from_TalkException _v5770))) <$> getProduct_result_e record
    ]
    )
write_GetProduct_result :: T.Protocol p => p -> GetProduct_result -> P.IO ()
write_GetProduct_result oprot record = T.writeVal oprot $ from_GetProduct_result record
encode_GetProduct_result :: T.StatelessProtocol p => p -> GetProduct_result -> LBS.ByteString
encode_GetProduct_result oprot record = T.serializeVal oprot $ from_GetProduct_result record
to_GetProduct_result :: T.ThriftVal -> GetProduct_result
to_GetProduct_result (T.TStruct fields) = GetProduct_result{
  getProduct_result_success = P.maybe (getProduct_result_success default_GetProduct_result) (\(_,_val5772) -> (case _val5772 of {T.TStruct _val5773 -> (to_Product (T.TStruct _val5773)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProduct_result_e = P.maybe (P.Nothing) (\(_,_val5772) -> P.Just (case _val5772 of {T.TStruct _val5774 -> (to_TalkException (T.TStruct _val5774)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProduct_result _ = P.error "not a struct"
read_GetProduct_result :: T.Protocol p => p -> P.IO GetProduct_result
read_GetProduct_result iprot = to_GetProduct_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProduct_result)
decode_GetProduct_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProduct_result
decode_GetProduct_result iprot bs = to_GetProduct_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProduct_result) bs
typemap_GetProduct_result :: T.TypeMap
typemap_GetProduct_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Product))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProduct_result :: GetProduct_result
default_GetProduct_result = GetProduct_result{
  getProduct_result_success = default_Product,
  getProduct_result_e = P.Nothing}
data GetProductList_args = GetProductList_args  { getProductList_args_productIdList :: (Vector.Vector LT.Text)
  , getProductList_args_language :: LT.Text
  , getProductList_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductList_args_productIdList record   `H.hashWithSalt` getProductList_args_language record   `H.hashWithSalt` getProductList_args_country record  
instance QC.Arbitrary GetProductList_args where 
  arbitrary = M.liftM GetProductList_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetProductList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductList_args{getProductList_args_productIdList = getProductList_args_productIdList obj} then P.Nothing else P.Just $ default_GetProductList_args{getProductList_args_productIdList = getProductList_args_productIdList obj}
    , if obj == default_GetProductList_args{getProductList_args_language = getProductList_args_language obj} then P.Nothing else P.Just $ default_GetProductList_args{getProductList_args_language = getProductList_args_language obj}
    , if obj == default_GetProductList_args{getProductList_args_country = getProductList_args_country obj} then P.Nothing else P.Just $ default_GetProductList_args{getProductList_args_country = getProductList_args_country obj}
    ]
from_GetProductList_args :: GetProductList_args -> T.ThriftVal
from_GetProductList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5777 -> P.Just (2, ("productIdList",T.TList T.T_STRING $ P.map (\_v5779 -> T.TString $ E.encodeUtf8 _v5779) $ Vector.toList _v5777))) $ getProductList_args_productIdList record
  , (\_v5777 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v5777))) $ getProductList_args_language record
  , (\_v5777 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v5777))) $ getProductList_args_country record
  ]
write_GetProductList_args :: T.Protocol p => p -> GetProductList_args -> P.IO ()
write_GetProductList_args oprot record = T.writeVal oprot $ from_GetProductList_args record
encode_GetProductList_args :: T.StatelessProtocol p => p -> GetProductList_args -> LBS.ByteString
encode_GetProductList_args oprot record = T.serializeVal oprot $ from_GetProductList_args record
to_GetProductList_args :: T.ThriftVal -> GetProductList_args
to_GetProductList_args (T.TStruct fields) = GetProductList_args{
  getProductList_args_productIdList = P.maybe (getProductList_args_productIdList default_GetProductList_args) (\(_,_val5781) -> (case _val5781 of {T.TList _ _val5782 -> (Vector.fromList $ P.map (\_v5783 -> (case _v5783 of {T.TString _val5784 -> E.decodeUtf8 _val5784; _ -> P.error "wrong type"})) _val5782); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getProductList_args_language = P.maybe (getProductList_args_language default_GetProductList_args) (\(_,_val5781) -> (case _val5781 of {T.TString _val5785 -> E.decodeUtf8 _val5785; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getProductList_args_country = P.maybe (getProductList_args_country default_GetProductList_args) (\(_,_val5781) -> (case _val5781 of {T.TString _val5786 -> E.decodeUtf8 _val5786; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetProductList_args _ = P.error "not a struct"
read_GetProductList_args :: T.Protocol p => p -> P.IO GetProductList_args
read_GetProductList_args iprot = to_GetProductList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProductList_args)
decode_GetProductList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductList_args
decode_GetProductList_args iprot bs = to_GetProductList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductList_args) bs
typemap_GetProductList_args :: T.TypeMap
typemap_GetProductList_args = Map.fromList [(2,("productIdList",(T.T_LIST T.T_STRING))),(3,("language",T.T_STRING)),(4,("country",T.T_STRING))]
default_GetProductList_args :: GetProductList_args
default_GetProductList_args = GetProductList_args{
  getProductList_args_productIdList = Vector.empty,
  getProductList_args_language = "",
  getProductList_args_country = ""}
data GetProductList_result = GetProductList_result  { getProductList_result_success :: ProductList
  , getProductList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductList_result_success record   `H.hashWithSalt` getProductList_result_e record  
instance QC.Arbitrary GetProductList_result where 
  arbitrary = M.liftM GetProductList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProductList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductList_result{getProductList_result_success = getProductList_result_success obj} then P.Nothing else P.Just $ default_GetProductList_result{getProductList_result_success = getProductList_result_success obj}
    , if obj == default_GetProductList_result{getProductList_result_e = getProductList_result_e obj} then P.Nothing else P.Just $ default_GetProductList_result{getProductList_result_e = getProductList_result_e obj}
    ]
from_GetProductList_result :: GetProductList_result -> T.ThriftVal
from_GetProductList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5789 -> (1, ("e",from_TalkException _v5789))) <$> getProductList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5789 -> P.Just (0, ("success",from_ProductList _v5789))) $ getProductList_result_success record
    , (\_v5789 -> (1, ("e",from_TalkException _v5789))) <$> getProductList_result_e record
    ]
    )
write_GetProductList_result :: T.Protocol p => p -> GetProductList_result -> P.IO ()
write_GetProductList_result oprot record = T.writeVal oprot $ from_GetProductList_result record
encode_GetProductList_result :: T.StatelessProtocol p => p -> GetProductList_result -> LBS.ByteString
encode_GetProductList_result oprot record = T.serializeVal oprot $ from_GetProductList_result record
to_GetProductList_result :: T.ThriftVal -> GetProductList_result
to_GetProductList_result (T.TStruct fields) = GetProductList_result{
  getProductList_result_success = P.maybe (getProductList_result_success default_GetProductList_result) (\(_,_val5791) -> (case _val5791 of {T.TStruct _val5792 -> (to_ProductList (T.TStruct _val5792)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProductList_result_e = P.maybe (P.Nothing) (\(_,_val5791) -> P.Just (case _val5791 of {T.TStruct _val5793 -> (to_TalkException (T.TStruct _val5793)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProductList_result _ = P.error "not a struct"
read_GetProductList_result :: T.Protocol p => p -> P.IO GetProductList_result
read_GetProductList_result iprot = to_GetProductList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProductList_result)
decode_GetProductList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductList_result
decode_GetProductList_result iprot bs = to_GetProductList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductList_result) bs
typemap_GetProductList_result :: T.TypeMap
typemap_GetProductList_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProductList_result :: GetProductList_result
default_GetProductList_result = GetProductList_result{
  getProductList_result_success = default_ProductList,
  getProductList_result_e = P.Nothing}
data GetProductListWithCarrier_args = GetProductListWithCarrier_args  { getProductListWithCarrier_args_productIdList :: (Vector.Vector LT.Text)
  , getProductListWithCarrier_args_language :: LT.Text
  , getProductListWithCarrier_args_country :: LT.Text
  , getProductListWithCarrier_args_carrierCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductListWithCarrier_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductListWithCarrier_args_productIdList record   `H.hashWithSalt` getProductListWithCarrier_args_language record   `H.hashWithSalt` getProductListWithCarrier_args_country record   `H.hashWithSalt` getProductListWithCarrier_args_carrierCode record  
instance QC.Arbitrary GetProductListWithCarrier_args where 
  arbitrary = M.liftM GetProductListWithCarrier_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetProductListWithCarrier_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductListWithCarrier_args{getProductListWithCarrier_args_productIdList = getProductListWithCarrier_args_productIdList obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_args{getProductListWithCarrier_args_productIdList = getProductListWithCarrier_args_productIdList obj}
    , if obj == default_GetProductListWithCarrier_args{getProductListWithCarrier_args_language = getProductListWithCarrier_args_language obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_args{getProductListWithCarrier_args_language = getProductListWithCarrier_args_language obj}
    , if obj == default_GetProductListWithCarrier_args{getProductListWithCarrier_args_country = getProductListWithCarrier_args_country obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_args{getProductListWithCarrier_args_country = getProductListWithCarrier_args_country obj}
    , if obj == default_GetProductListWithCarrier_args{getProductListWithCarrier_args_carrierCode = getProductListWithCarrier_args_carrierCode obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_args{getProductListWithCarrier_args_carrierCode = getProductListWithCarrier_args_carrierCode obj}
    ]
from_GetProductListWithCarrier_args :: GetProductListWithCarrier_args -> T.ThriftVal
from_GetProductListWithCarrier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5796 -> P.Just (2, ("productIdList",T.TList T.T_STRING $ P.map (\_v5798 -> T.TString $ E.encodeUtf8 _v5798) $ Vector.toList _v5796))) $ getProductListWithCarrier_args_productIdList record
  , (\_v5796 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v5796))) $ getProductListWithCarrier_args_language record
  , (\_v5796 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v5796))) $ getProductListWithCarrier_args_country record
  , (\_v5796 -> P.Just (5, ("carrierCode",T.TString $ E.encodeUtf8 _v5796))) $ getProductListWithCarrier_args_carrierCode record
  ]
write_GetProductListWithCarrier_args :: T.Protocol p => p -> GetProductListWithCarrier_args -> P.IO ()
write_GetProductListWithCarrier_args oprot record = T.writeVal oprot $ from_GetProductListWithCarrier_args record
encode_GetProductListWithCarrier_args :: T.StatelessProtocol p => p -> GetProductListWithCarrier_args -> LBS.ByteString
encode_GetProductListWithCarrier_args oprot record = T.serializeVal oprot $ from_GetProductListWithCarrier_args record
to_GetProductListWithCarrier_args :: T.ThriftVal -> GetProductListWithCarrier_args
to_GetProductListWithCarrier_args (T.TStruct fields) = GetProductListWithCarrier_args{
  getProductListWithCarrier_args_productIdList = P.maybe (getProductListWithCarrier_args_productIdList default_GetProductListWithCarrier_args) (\(_,_val5800) -> (case _val5800 of {T.TList _ _val5801 -> (Vector.fromList $ P.map (\_v5802 -> (case _v5802 of {T.TString _val5803 -> E.decodeUtf8 _val5803; _ -> P.error "wrong type"})) _val5801); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getProductListWithCarrier_args_language = P.maybe (getProductListWithCarrier_args_language default_GetProductListWithCarrier_args) (\(_,_val5800) -> (case _val5800 of {T.TString _val5804 -> E.decodeUtf8 _val5804; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getProductListWithCarrier_args_country = P.maybe (getProductListWithCarrier_args_country default_GetProductListWithCarrier_args) (\(_,_val5800) -> (case _val5800 of {T.TString _val5805 -> E.decodeUtf8 _val5805; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getProductListWithCarrier_args_carrierCode = P.maybe (getProductListWithCarrier_args_carrierCode default_GetProductListWithCarrier_args) (\(_,_val5800) -> (case _val5800 of {T.TString _val5806 -> E.decodeUtf8 _val5806; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetProductListWithCarrier_args _ = P.error "not a struct"
read_GetProductListWithCarrier_args :: T.Protocol p => p -> P.IO GetProductListWithCarrier_args
read_GetProductListWithCarrier_args iprot = to_GetProductListWithCarrier_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProductListWithCarrier_args)
decode_GetProductListWithCarrier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductListWithCarrier_args
decode_GetProductListWithCarrier_args iprot bs = to_GetProductListWithCarrier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductListWithCarrier_args) bs
typemap_GetProductListWithCarrier_args :: T.TypeMap
typemap_GetProductListWithCarrier_args = Map.fromList [(2,("productIdList",(T.T_LIST T.T_STRING))),(3,("language",T.T_STRING)),(4,("country",T.T_STRING)),(5,("carrierCode",T.T_STRING))]
default_GetProductListWithCarrier_args :: GetProductListWithCarrier_args
default_GetProductListWithCarrier_args = GetProductListWithCarrier_args{
  getProductListWithCarrier_args_productIdList = Vector.empty,
  getProductListWithCarrier_args_language = "",
  getProductListWithCarrier_args_country = "",
  getProductListWithCarrier_args_carrierCode = ""}
data GetProductListWithCarrier_result = GetProductListWithCarrier_result  { getProductListWithCarrier_result_success :: ProductList
  , getProductListWithCarrier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductListWithCarrier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductListWithCarrier_result_success record   `H.hashWithSalt` getProductListWithCarrier_result_e record  
instance QC.Arbitrary GetProductListWithCarrier_result where 
  arbitrary = M.liftM GetProductListWithCarrier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProductListWithCarrier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductListWithCarrier_result{getProductListWithCarrier_result_success = getProductListWithCarrier_result_success obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_result{getProductListWithCarrier_result_success = getProductListWithCarrier_result_success obj}
    , if obj == default_GetProductListWithCarrier_result{getProductListWithCarrier_result_e = getProductListWithCarrier_result_e obj} then P.Nothing else P.Just $ default_GetProductListWithCarrier_result{getProductListWithCarrier_result_e = getProductListWithCarrier_result_e obj}
    ]
from_GetProductListWithCarrier_result :: GetProductListWithCarrier_result -> T.ThriftVal
from_GetProductListWithCarrier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5809 -> (1, ("e",from_TalkException _v5809))) <$> getProductListWithCarrier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5809 -> P.Just (0, ("success",from_ProductList _v5809))) $ getProductListWithCarrier_result_success record
    , (\_v5809 -> (1, ("e",from_TalkException _v5809))) <$> getProductListWithCarrier_result_e record
    ]
    )
write_GetProductListWithCarrier_result :: T.Protocol p => p -> GetProductListWithCarrier_result -> P.IO ()
write_GetProductListWithCarrier_result oprot record = T.writeVal oprot $ from_GetProductListWithCarrier_result record
encode_GetProductListWithCarrier_result :: T.StatelessProtocol p => p -> GetProductListWithCarrier_result -> LBS.ByteString
encode_GetProductListWithCarrier_result oprot record = T.serializeVal oprot $ from_GetProductListWithCarrier_result record
to_GetProductListWithCarrier_result :: T.ThriftVal -> GetProductListWithCarrier_result
to_GetProductListWithCarrier_result (T.TStruct fields) = GetProductListWithCarrier_result{
  getProductListWithCarrier_result_success = P.maybe (getProductListWithCarrier_result_success default_GetProductListWithCarrier_result) (\(_,_val5811) -> (case _val5811 of {T.TStruct _val5812 -> (to_ProductList (T.TStruct _val5812)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProductListWithCarrier_result_e = P.maybe (P.Nothing) (\(_,_val5811) -> P.Just (case _val5811 of {T.TStruct _val5813 -> (to_TalkException (T.TStruct _val5813)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProductListWithCarrier_result _ = P.error "not a struct"
read_GetProductListWithCarrier_result :: T.Protocol p => p -> P.IO GetProductListWithCarrier_result
read_GetProductListWithCarrier_result iprot = to_GetProductListWithCarrier_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProductListWithCarrier_result)
decode_GetProductListWithCarrier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductListWithCarrier_result
decode_GetProductListWithCarrier_result iprot bs = to_GetProductListWithCarrier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductListWithCarrier_result) bs
typemap_GetProductListWithCarrier_result :: T.TypeMap
typemap_GetProductListWithCarrier_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProductListWithCarrier_result :: GetProductListWithCarrier_result
default_GetProductListWithCarrier_result = GetProductListWithCarrier_result{
  getProductListWithCarrier_result_success = default_ProductList,
  getProductListWithCarrier_result_e = P.Nothing}
data GetProductWithCarrier_args = GetProductWithCarrier_args  { getProductWithCarrier_args_packageID :: I.Int64
  , getProductWithCarrier_args_language :: LT.Text
  , getProductWithCarrier_args_country :: LT.Text
  , getProductWithCarrier_args_carrierCode :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductWithCarrier_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductWithCarrier_args_packageID record   `H.hashWithSalt` getProductWithCarrier_args_language record   `H.hashWithSalt` getProductWithCarrier_args_country record   `H.hashWithSalt` getProductWithCarrier_args_carrierCode record  
instance QC.Arbitrary GetProductWithCarrier_args where 
  arbitrary = M.liftM GetProductWithCarrier_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetProductWithCarrier_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductWithCarrier_args{getProductWithCarrier_args_packageID = getProductWithCarrier_args_packageID obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_args{getProductWithCarrier_args_packageID = getProductWithCarrier_args_packageID obj}
    , if obj == default_GetProductWithCarrier_args{getProductWithCarrier_args_language = getProductWithCarrier_args_language obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_args{getProductWithCarrier_args_language = getProductWithCarrier_args_language obj}
    , if obj == default_GetProductWithCarrier_args{getProductWithCarrier_args_country = getProductWithCarrier_args_country obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_args{getProductWithCarrier_args_country = getProductWithCarrier_args_country obj}
    , if obj == default_GetProductWithCarrier_args{getProductWithCarrier_args_carrierCode = getProductWithCarrier_args_carrierCode obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_args{getProductWithCarrier_args_carrierCode = getProductWithCarrier_args_carrierCode obj}
    ]
from_GetProductWithCarrier_args :: GetProductWithCarrier_args -> T.ThriftVal
from_GetProductWithCarrier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5816 -> P.Just (2, ("packageID",T.TI64 _v5816))) $ getProductWithCarrier_args_packageID record
  , (\_v5816 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v5816))) $ getProductWithCarrier_args_language record
  , (\_v5816 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v5816))) $ getProductWithCarrier_args_country record
  , (\_v5816 -> P.Just (5, ("carrierCode",T.TString $ E.encodeUtf8 _v5816))) $ getProductWithCarrier_args_carrierCode record
  ]
write_GetProductWithCarrier_args :: T.Protocol p => p -> GetProductWithCarrier_args -> P.IO ()
write_GetProductWithCarrier_args oprot record = T.writeVal oprot $ from_GetProductWithCarrier_args record
encode_GetProductWithCarrier_args :: T.StatelessProtocol p => p -> GetProductWithCarrier_args -> LBS.ByteString
encode_GetProductWithCarrier_args oprot record = T.serializeVal oprot $ from_GetProductWithCarrier_args record
to_GetProductWithCarrier_args :: T.ThriftVal -> GetProductWithCarrier_args
to_GetProductWithCarrier_args (T.TStruct fields) = GetProductWithCarrier_args{
  getProductWithCarrier_args_packageID = P.maybe (getProductWithCarrier_args_packageID default_GetProductWithCarrier_args) (\(_,_val5818) -> (case _val5818 of {T.TI64 _val5819 -> _val5819; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getProductWithCarrier_args_language = P.maybe (getProductWithCarrier_args_language default_GetProductWithCarrier_args) (\(_,_val5818) -> (case _val5818 of {T.TString _val5820 -> E.decodeUtf8 _val5820; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getProductWithCarrier_args_country = P.maybe (getProductWithCarrier_args_country default_GetProductWithCarrier_args) (\(_,_val5818) -> (case _val5818 of {T.TString _val5821 -> E.decodeUtf8 _val5821; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getProductWithCarrier_args_carrierCode = P.maybe (getProductWithCarrier_args_carrierCode default_GetProductWithCarrier_args) (\(_,_val5818) -> (case _val5818 of {T.TString _val5822 -> E.decodeUtf8 _val5822; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetProductWithCarrier_args _ = P.error "not a struct"
read_GetProductWithCarrier_args :: T.Protocol p => p -> P.IO GetProductWithCarrier_args
read_GetProductWithCarrier_args iprot = to_GetProductWithCarrier_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProductWithCarrier_args)
decode_GetProductWithCarrier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductWithCarrier_args
decode_GetProductWithCarrier_args iprot bs = to_GetProductWithCarrier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductWithCarrier_args) bs
typemap_GetProductWithCarrier_args :: T.TypeMap
typemap_GetProductWithCarrier_args = Map.fromList [(2,("packageID",T.T_I64)),(3,("language",T.T_STRING)),(4,("country",T.T_STRING)),(5,("carrierCode",T.T_STRING))]
default_GetProductWithCarrier_args :: GetProductWithCarrier_args
default_GetProductWithCarrier_args = GetProductWithCarrier_args{
  getProductWithCarrier_args_packageID = 0,
  getProductWithCarrier_args_language = "",
  getProductWithCarrier_args_country = "",
  getProductWithCarrier_args_carrierCode = ""}
data GetProductWithCarrier_result = GetProductWithCarrier_result  { getProductWithCarrier_result_success :: Product
  , getProductWithCarrier_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProductWithCarrier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProductWithCarrier_result_success record   `H.hashWithSalt` getProductWithCarrier_result_e record  
instance QC.Arbitrary GetProductWithCarrier_result where 
  arbitrary = M.liftM GetProductWithCarrier_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProductWithCarrier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProductWithCarrier_result{getProductWithCarrier_result_success = getProductWithCarrier_result_success obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_result{getProductWithCarrier_result_success = getProductWithCarrier_result_success obj}
    , if obj == default_GetProductWithCarrier_result{getProductWithCarrier_result_e = getProductWithCarrier_result_e obj} then P.Nothing else P.Just $ default_GetProductWithCarrier_result{getProductWithCarrier_result_e = getProductWithCarrier_result_e obj}
    ]
from_GetProductWithCarrier_result :: GetProductWithCarrier_result -> T.ThriftVal
from_GetProductWithCarrier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5825 -> (1, ("e",from_TalkException _v5825))) <$> getProductWithCarrier_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5825 -> P.Just (0, ("success",from_Product _v5825))) $ getProductWithCarrier_result_success record
    , (\_v5825 -> (1, ("e",from_TalkException _v5825))) <$> getProductWithCarrier_result_e record
    ]
    )
write_GetProductWithCarrier_result :: T.Protocol p => p -> GetProductWithCarrier_result -> P.IO ()
write_GetProductWithCarrier_result oprot record = T.writeVal oprot $ from_GetProductWithCarrier_result record
encode_GetProductWithCarrier_result :: T.StatelessProtocol p => p -> GetProductWithCarrier_result -> LBS.ByteString
encode_GetProductWithCarrier_result oprot record = T.serializeVal oprot $ from_GetProductWithCarrier_result record
to_GetProductWithCarrier_result :: T.ThriftVal -> GetProductWithCarrier_result
to_GetProductWithCarrier_result (T.TStruct fields) = GetProductWithCarrier_result{
  getProductWithCarrier_result_success = P.maybe (getProductWithCarrier_result_success default_GetProductWithCarrier_result) (\(_,_val5827) -> (case _val5827 of {T.TStruct _val5828 -> (to_Product (T.TStruct _val5828)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProductWithCarrier_result_e = P.maybe (P.Nothing) (\(_,_val5827) -> P.Just (case _val5827 of {T.TStruct _val5829 -> (to_TalkException (T.TStruct _val5829)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProductWithCarrier_result _ = P.error "not a struct"
read_GetProductWithCarrier_result :: T.Protocol p => p -> P.IO GetProductWithCarrier_result
read_GetProductWithCarrier_result iprot = to_GetProductWithCarrier_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProductWithCarrier_result)
decode_GetProductWithCarrier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProductWithCarrier_result
decode_GetProductWithCarrier_result iprot bs = to_GetProductWithCarrier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProductWithCarrier_result) bs
typemap_GetProductWithCarrier_result :: T.TypeMap
typemap_GetProductWithCarrier_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Product))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProductWithCarrier_result :: GetProductWithCarrier_result
default_GetProductWithCarrier_result = GetProductWithCarrier_result{
  getProductWithCarrier_result_success = default_Product,
  getProductWithCarrier_result_e = P.Nothing}
data GetPurchaseHistory_args = GetPurchaseHistory_args  { getPurchaseHistory_args_start :: I.Int64
  , getPurchaseHistory_args_size :: I.Int32
  , getPurchaseHistory_args_language :: LT.Text
  , getPurchaseHistory_args_country :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPurchaseHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPurchaseHistory_args_start record   `H.hashWithSalt` getPurchaseHistory_args_size record   `H.hashWithSalt` getPurchaseHistory_args_language record   `H.hashWithSalt` getPurchaseHistory_args_country record  
instance QC.Arbitrary GetPurchaseHistory_args where 
  arbitrary = M.liftM GetPurchaseHistory_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPurchaseHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPurchaseHistory_args{getPurchaseHistory_args_start = getPurchaseHistory_args_start obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_args{getPurchaseHistory_args_start = getPurchaseHistory_args_start obj}
    , if obj == default_GetPurchaseHistory_args{getPurchaseHistory_args_size = getPurchaseHistory_args_size obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_args{getPurchaseHistory_args_size = getPurchaseHistory_args_size obj}
    , if obj == default_GetPurchaseHistory_args{getPurchaseHistory_args_language = getPurchaseHistory_args_language obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_args{getPurchaseHistory_args_language = getPurchaseHistory_args_language obj}
    , if obj == default_GetPurchaseHistory_args{getPurchaseHistory_args_country = getPurchaseHistory_args_country obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_args{getPurchaseHistory_args_country = getPurchaseHistory_args_country obj}
    ]
from_GetPurchaseHistory_args :: GetPurchaseHistory_args -> T.ThriftVal
from_GetPurchaseHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5832 -> P.Just (2, ("start",T.TI64 _v5832))) $ getPurchaseHistory_args_start record
  , (\_v5832 -> P.Just (3, ("size",T.TI32 _v5832))) $ getPurchaseHistory_args_size record
  , (\_v5832 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v5832))) $ getPurchaseHistory_args_language record
  , (\_v5832 -> P.Just (5, ("country",T.TString $ E.encodeUtf8 _v5832))) $ getPurchaseHistory_args_country record
  ]
write_GetPurchaseHistory_args :: T.Protocol p => p -> GetPurchaseHistory_args -> P.IO ()
write_GetPurchaseHistory_args oprot record = T.writeVal oprot $ from_GetPurchaseHistory_args record
encode_GetPurchaseHistory_args :: T.StatelessProtocol p => p -> GetPurchaseHistory_args -> LBS.ByteString
encode_GetPurchaseHistory_args oprot record = T.serializeVal oprot $ from_GetPurchaseHistory_args record
to_GetPurchaseHistory_args :: T.ThriftVal -> GetPurchaseHistory_args
to_GetPurchaseHistory_args (T.TStruct fields) = GetPurchaseHistory_args{
  getPurchaseHistory_args_start = P.maybe (getPurchaseHistory_args_start default_GetPurchaseHistory_args) (\(_,_val5834) -> (case _val5834 of {T.TI64 _val5835 -> _val5835; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPurchaseHistory_args_size = P.maybe (getPurchaseHistory_args_size default_GetPurchaseHistory_args) (\(_,_val5834) -> (case _val5834 of {T.TI32 _val5836 -> _val5836; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPurchaseHistory_args_language = P.maybe (getPurchaseHistory_args_language default_GetPurchaseHistory_args) (\(_,_val5834) -> (case _val5834 of {T.TString _val5837 -> E.decodeUtf8 _val5837; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getPurchaseHistory_args_country = P.maybe (getPurchaseHistory_args_country default_GetPurchaseHistory_args) (\(_,_val5834) -> (case _val5834 of {T.TString _val5838 -> E.decodeUtf8 _val5838; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetPurchaseHistory_args _ = P.error "not a struct"
read_GetPurchaseHistory_args :: T.Protocol p => p -> P.IO GetPurchaseHistory_args
read_GetPurchaseHistory_args iprot = to_GetPurchaseHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPurchaseHistory_args)
decode_GetPurchaseHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPurchaseHistory_args
decode_GetPurchaseHistory_args iprot bs = to_GetPurchaseHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPurchaseHistory_args) bs
typemap_GetPurchaseHistory_args :: T.TypeMap
typemap_GetPurchaseHistory_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING)),(5,("country",T.T_STRING))]
default_GetPurchaseHistory_args :: GetPurchaseHistory_args
default_GetPurchaseHistory_args = GetPurchaseHistory_args{
  getPurchaseHistory_args_start = 0,
  getPurchaseHistory_args_size = 0,
  getPurchaseHistory_args_language = "",
  getPurchaseHistory_args_country = ""}
data GetPurchaseHistory_result = GetPurchaseHistory_result  { getPurchaseHistory_result_success :: ProductList
  , getPurchaseHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPurchaseHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPurchaseHistory_result_success record   `H.hashWithSalt` getPurchaseHistory_result_e record  
instance QC.Arbitrary GetPurchaseHistory_result where 
  arbitrary = M.liftM GetPurchaseHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPurchaseHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPurchaseHistory_result{getPurchaseHistory_result_success = getPurchaseHistory_result_success obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_result{getPurchaseHistory_result_success = getPurchaseHistory_result_success obj}
    , if obj == default_GetPurchaseHistory_result{getPurchaseHistory_result_e = getPurchaseHistory_result_e obj} then P.Nothing else P.Just $ default_GetPurchaseHistory_result{getPurchaseHistory_result_e = getPurchaseHistory_result_e obj}
    ]
from_GetPurchaseHistory_result :: GetPurchaseHistory_result -> T.ThriftVal
from_GetPurchaseHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5841 -> (1, ("e",from_TalkException _v5841))) <$> getPurchaseHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5841 -> P.Just (0, ("success",from_ProductList _v5841))) $ getPurchaseHistory_result_success record
    , (\_v5841 -> (1, ("e",from_TalkException _v5841))) <$> getPurchaseHistory_result_e record
    ]
    )
write_GetPurchaseHistory_result :: T.Protocol p => p -> GetPurchaseHistory_result -> P.IO ()
write_GetPurchaseHistory_result oprot record = T.writeVal oprot $ from_GetPurchaseHistory_result record
encode_GetPurchaseHistory_result :: T.StatelessProtocol p => p -> GetPurchaseHistory_result -> LBS.ByteString
encode_GetPurchaseHistory_result oprot record = T.serializeVal oprot $ from_GetPurchaseHistory_result record
to_GetPurchaseHistory_result :: T.ThriftVal -> GetPurchaseHistory_result
to_GetPurchaseHistory_result (T.TStruct fields) = GetPurchaseHistory_result{
  getPurchaseHistory_result_success = P.maybe (getPurchaseHistory_result_success default_GetPurchaseHistory_result) (\(_,_val5843) -> (case _val5843 of {T.TStruct _val5844 -> (to_ProductList (T.TStruct _val5844)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPurchaseHistory_result_e = P.maybe (P.Nothing) (\(_,_val5843) -> P.Just (case _val5843 of {T.TStruct _val5845 -> (to_TalkException (T.TStruct _val5845)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPurchaseHistory_result _ = P.error "not a struct"
read_GetPurchaseHistory_result :: T.Protocol p => p -> P.IO GetPurchaseHistory_result
read_GetPurchaseHistory_result iprot = to_GetPurchaseHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPurchaseHistory_result)
decode_GetPurchaseHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPurchaseHistory_result
decode_GetPurchaseHistory_result iprot bs = to_GetPurchaseHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPurchaseHistory_result) bs
typemap_GetPurchaseHistory_result :: T.TypeMap
typemap_GetPurchaseHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ProductList))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPurchaseHistory_result :: GetPurchaseHistory_result
default_GetPurchaseHistory_result = GetPurchaseHistory_result{
  getPurchaseHistory_result_success = default_ProductList,
  getPurchaseHistory_result_e = P.Nothing}
data GetTotalBalance_args = GetTotalBalance_args  { getTotalBalance_args_appStoreCode :: PaymentType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTotalBalance_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTotalBalance_args_appStoreCode record  
instance QC.Arbitrary GetTotalBalance_args where 
  arbitrary = M.liftM GetTotalBalance_args (QC.arbitrary)
  shrink obj | obj == default_GetTotalBalance_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTotalBalance_args{getTotalBalance_args_appStoreCode = getTotalBalance_args_appStoreCode obj} then P.Nothing else P.Just $ default_GetTotalBalance_args{getTotalBalance_args_appStoreCode = getTotalBalance_args_appStoreCode obj}
    ]
from_GetTotalBalance_args :: GetTotalBalance_args -> T.ThriftVal
from_GetTotalBalance_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5848 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v5848))) $ getTotalBalance_args_appStoreCode record
  ]
write_GetTotalBalance_args :: T.Protocol p => p -> GetTotalBalance_args -> P.IO ()
write_GetTotalBalance_args oprot record = T.writeVal oprot $ from_GetTotalBalance_args record
encode_GetTotalBalance_args :: T.StatelessProtocol p => p -> GetTotalBalance_args -> LBS.ByteString
encode_GetTotalBalance_args oprot record = T.serializeVal oprot $ from_GetTotalBalance_args record
to_GetTotalBalance_args :: T.ThriftVal -> GetTotalBalance_args
to_GetTotalBalance_args (T.TStruct fields) = GetTotalBalance_args{
  getTotalBalance_args_appStoreCode = P.maybe (getTotalBalance_args_appStoreCode default_GetTotalBalance_args) (\(_,_val5850) -> (case _val5850 of {T.TI32 _val5851 -> P.toEnum $ P.fromIntegral _val5851; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetTotalBalance_args _ = P.error "not a struct"
read_GetTotalBalance_args :: T.Protocol p => p -> P.IO GetTotalBalance_args
read_GetTotalBalance_args iprot = to_GetTotalBalance_args <$> T.readVal iprot (T.T_STRUCT typemap_GetTotalBalance_args)
decode_GetTotalBalance_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTotalBalance_args
decode_GetTotalBalance_args iprot bs = to_GetTotalBalance_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTotalBalance_args) bs
typemap_GetTotalBalance_args :: T.TypeMap
typemap_GetTotalBalance_args = Map.fromList [(2,("appStoreCode",T.T_I32))]
default_GetTotalBalance_args :: GetTotalBalance_args
default_GetTotalBalance_args = GetTotalBalance_args{
  getTotalBalance_args_appStoreCode = (P.toEnum 0)}
data GetTotalBalance_result = GetTotalBalance_result  { getTotalBalance_result_success :: Coin
  , getTotalBalance_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTotalBalance_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTotalBalance_result_success record   `H.hashWithSalt` getTotalBalance_result_e record  
instance QC.Arbitrary GetTotalBalance_result where 
  arbitrary = M.liftM GetTotalBalance_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetTotalBalance_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTotalBalance_result{getTotalBalance_result_success = getTotalBalance_result_success obj} then P.Nothing else P.Just $ default_GetTotalBalance_result{getTotalBalance_result_success = getTotalBalance_result_success obj}
    , if obj == default_GetTotalBalance_result{getTotalBalance_result_e = getTotalBalance_result_e obj} then P.Nothing else P.Just $ default_GetTotalBalance_result{getTotalBalance_result_e = getTotalBalance_result_e obj}
    ]
from_GetTotalBalance_result :: GetTotalBalance_result -> T.ThriftVal
from_GetTotalBalance_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5854 -> (1, ("e",from_TalkException _v5854))) <$> getTotalBalance_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5854 -> P.Just (0, ("success",from_Coin _v5854))) $ getTotalBalance_result_success record
    , (\_v5854 -> (1, ("e",from_TalkException _v5854))) <$> getTotalBalance_result_e record
    ]
    )
write_GetTotalBalance_result :: T.Protocol p => p -> GetTotalBalance_result -> P.IO ()
write_GetTotalBalance_result oprot record = T.writeVal oprot $ from_GetTotalBalance_result record
encode_GetTotalBalance_result :: T.StatelessProtocol p => p -> GetTotalBalance_result -> LBS.ByteString
encode_GetTotalBalance_result oprot record = T.serializeVal oprot $ from_GetTotalBalance_result record
to_GetTotalBalance_result :: T.ThriftVal -> GetTotalBalance_result
to_GetTotalBalance_result (T.TStruct fields) = GetTotalBalance_result{
  getTotalBalance_result_success = P.maybe (getTotalBalance_result_success default_GetTotalBalance_result) (\(_,_val5856) -> (case _val5856 of {T.TStruct _val5857 -> (to_Coin (T.TStruct _val5857)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getTotalBalance_result_e = P.maybe (P.Nothing) (\(_,_val5856) -> P.Just (case _val5856 of {T.TStruct _val5858 -> (to_TalkException (T.TStruct _val5858)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetTotalBalance_result _ = P.error "not a struct"
read_GetTotalBalance_result :: T.Protocol p => p -> P.IO GetTotalBalance_result
read_GetTotalBalance_result iprot = to_GetTotalBalance_result <$> T.readVal iprot (T.T_STRUCT typemap_GetTotalBalance_result)
decode_GetTotalBalance_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTotalBalance_result
decode_GetTotalBalance_result iprot bs = to_GetTotalBalance_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTotalBalance_result) bs
typemap_GetTotalBalance_result :: T.TypeMap
typemap_GetTotalBalance_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Coin))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetTotalBalance_result :: GetTotalBalance_result
default_GetTotalBalance_result = GetTotalBalance_result{
  getTotalBalance_result_success = default_Coin,
  getTotalBalance_result_e = P.Nothing}
data NotifyDownloaded_args = NotifyDownloaded_args  { notifyDownloaded_args_packageId :: I.Int64
  , notifyDownloaded_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyDownloaded_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyDownloaded_args_packageId record   `H.hashWithSalt` notifyDownloaded_args_language record  
instance QC.Arbitrary NotifyDownloaded_args where 
  arbitrary = M.liftM NotifyDownloaded_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_NotifyDownloaded_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyDownloaded_args{notifyDownloaded_args_packageId = notifyDownloaded_args_packageId obj} then P.Nothing else P.Just $ default_NotifyDownloaded_args{notifyDownloaded_args_packageId = notifyDownloaded_args_packageId obj}
    , if obj == default_NotifyDownloaded_args{notifyDownloaded_args_language = notifyDownloaded_args_language obj} then P.Nothing else P.Just $ default_NotifyDownloaded_args{notifyDownloaded_args_language = notifyDownloaded_args_language obj}
    ]
from_NotifyDownloaded_args :: NotifyDownloaded_args -> T.ThriftVal
from_NotifyDownloaded_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5861 -> P.Just (2, ("packageId",T.TI64 _v5861))) $ notifyDownloaded_args_packageId record
  , (\_v5861 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v5861))) $ notifyDownloaded_args_language record
  ]
write_NotifyDownloaded_args :: T.Protocol p => p -> NotifyDownloaded_args -> P.IO ()
write_NotifyDownloaded_args oprot record = T.writeVal oprot $ from_NotifyDownloaded_args record
encode_NotifyDownloaded_args :: T.StatelessProtocol p => p -> NotifyDownloaded_args -> LBS.ByteString
encode_NotifyDownloaded_args oprot record = T.serializeVal oprot $ from_NotifyDownloaded_args record
to_NotifyDownloaded_args :: T.ThriftVal -> NotifyDownloaded_args
to_NotifyDownloaded_args (T.TStruct fields) = NotifyDownloaded_args{
  notifyDownloaded_args_packageId = P.maybe (notifyDownloaded_args_packageId default_NotifyDownloaded_args) (\(_,_val5863) -> (case _val5863 of {T.TI64 _val5864 -> _val5864; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notifyDownloaded_args_language = P.maybe (notifyDownloaded_args_language default_NotifyDownloaded_args) (\(_,_val5863) -> (case _val5863 of {T.TString _val5865 -> E.decodeUtf8 _val5865; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotifyDownloaded_args _ = P.error "not a struct"
read_NotifyDownloaded_args :: T.Protocol p => p -> P.IO NotifyDownloaded_args
read_NotifyDownloaded_args iprot = to_NotifyDownloaded_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyDownloaded_args)
decode_NotifyDownloaded_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyDownloaded_args
decode_NotifyDownloaded_args iprot bs = to_NotifyDownloaded_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyDownloaded_args) bs
typemap_NotifyDownloaded_args :: T.TypeMap
typemap_NotifyDownloaded_args = Map.fromList [(2,("packageId",T.T_I64)),(3,("language",T.T_STRING))]
default_NotifyDownloaded_args :: NotifyDownloaded_args
default_NotifyDownloaded_args = NotifyDownloaded_args{
  notifyDownloaded_args_packageId = 0,
  notifyDownloaded_args_language = ""}
data NotifyDownloaded_result = NotifyDownloaded_result  { notifyDownloaded_result_success :: I.Int64
  , notifyDownloaded_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyDownloaded_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyDownloaded_result_success record   `H.hashWithSalt` notifyDownloaded_result_e record  
instance QC.Arbitrary NotifyDownloaded_result where 
  arbitrary = M.liftM NotifyDownloaded_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyDownloaded_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyDownloaded_result{notifyDownloaded_result_success = notifyDownloaded_result_success obj} then P.Nothing else P.Just $ default_NotifyDownloaded_result{notifyDownloaded_result_success = notifyDownloaded_result_success obj}
    , if obj == default_NotifyDownloaded_result{notifyDownloaded_result_e = notifyDownloaded_result_e obj} then P.Nothing else P.Just $ default_NotifyDownloaded_result{notifyDownloaded_result_e = notifyDownloaded_result_e obj}
    ]
from_NotifyDownloaded_result :: NotifyDownloaded_result -> T.ThriftVal
from_NotifyDownloaded_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5868 -> (1, ("e",from_TalkException _v5868))) <$> notifyDownloaded_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5868 -> P.Just (0, ("success",T.TI64 _v5868))) $ notifyDownloaded_result_success record
    , (\_v5868 -> (1, ("e",from_TalkException _v5868))) <$> notifyDownloaded_result_e record
    ]
    )
write_NotifyDownloaded_result :: T.Protocol p => p -> NotifyDownloaded_result -> P.IO ()
write_NotifyDownloaded_result oprot record = T.writeVal oprot $ from_NotifyDownloaded_result record
encode_NotifyDownloaded_result :: T.StatelessProtocol p => p -> NotifyDownloaded_result -> LBS.ByteString
encode_NotifyDownloaded_result oprot record = T.serializeVal oprot $ from_NotifyDownloaded_result record
to_NotifyDownloaded_result :: T.ThriftVal -> NotifyDownloaded_result
to_NotifyDownloaded_result (T.TStruct fields) = NotifyDownloaded_result{
  notifyDownloaded_result_success = P.maybe (notifyDownloaded_result_success default_NotifyDownloaded_result) (\(_,_val5870) -> (case _val5870 of {T.TI64 _val5871 -> _val5871; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  notifyDownloaded_result_e = P.maybe (P.Nothing) (\(_,_val5870) -> P.Just (case _val5870 of {T.TStruct _val5872 -> (to_TalkException (T.TStruct _val5872)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyDownloaded_result _ = P.error "not a struct"
read_NotifyDownloaded_result :: T.Protocol p => p -> P.IO NotifyDownloaded_result
read_NotifyDownloaded_result iprot = to_NotifyDownloaded_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyDownloaded_result)
decode_NotifyDownloaded_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyDownloaded_result
decode_NotifyDownloaded_result iprot bs = to_NotifyDownloaded_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyDownloaded_result) bs
typemap_NotifyDownloaded_result :: T.TypeMap
typemap_NotifyDownloaded_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyDownloaded_result :: NotifyDownloaded_result
default_NotifyDownloaded_result = NotifyDownloaded_result{
  notifyDownloaded_result_success = 0,
  notifyDownloaded_result_e = P.Nothing}
data ReserveCoinPurchase_args = ReserveCoinPurchase_args  { reserveCoinPurchase_args_request :: CoinPurchaseReservation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinPurchase_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinPurchase_args_request record  
instance QC.Arbitrary ReserveCoinPurchase_args where 
  arbitrary = M.liftM ReserveCoinPurchase_args (QC.arbitrary)
  shrink obj | obj == default_ReserveCoinPurchase_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinPurchase_args{reserveCoinPurchase_args_request = reserveCoinPurchase_args_request obj} then P.Nothing else P.Just $ default_ReserveCoinPurchase_args{reserveCoinPurchase_args_request = reserveCoinPurchase_args_request obj}
    ]
from_ReserveCoinPurchase_args :: ReserveCoinPurchase_args -> T.ThriftVal
from_ReserveCoinPurchase_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5875 -> P.Just (2, ("request",from_CoinPurchaseReservation _v5875))) $ reserveCoinPurchase_args_request record
  ]
write_ReserveCoinPurchase_args :: T.Protocol p => p -> ReserveCoinPurchase_args -> P.IO ()
write_ReserveCoinPurchase_args oprot record = T.writeVal oprot $ from_ReserveCoinPurchase_args record
encode_ReserveCoinPurchase_args :: T.StatelessProtocol p => p -> ReserveCoinPurchase_args -> LBS.ByteString
encode_ReserveCoinPurchase_args oprot record = T.serializeVal oprot $ from_ReserveCoinPurchase_args record
to_ReserveCoinPurchase_args :: T.ThriftVal -> ReserveCoinPurchase_args
to_ReserveCoinPurchase_args (T.TStruct fields) = ReserveCoinPurchase_args{
  reserveCoinPurchase_args_request = P.maybe (reserveCoinPurchase_args_request default_ReserveCoinPurchase_args) (\(_,_val5877) -> (case _val5877 of {T.TStruct _val5878 -> (to_CoinPurchaseReservation (T.TStruct _val5878)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ReserveCoinPurchase_args _ = P.error "not a struct"
read_ReserveCoinPurchase_args :: T.Protocol p => p -> P.IO ReserveCoinPurchase_args
read_ReserveCoinPurchase_args iprot = to_ReserveCoinPurchase_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinPurchase_args)
decode_ReserveCoinPurchase_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinPurchase_args
decode_ReserveCoinPurchase_args iprot bs = to_ReserveCoinPurchase_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinPurchase_args) bs
typemap_ReserveCoinPurchase_args :: T.TypeMap
typemap_ReserveCoinPurchase_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinPurchaseReservation)))]
default_ReserveCoinPurchase_args :: ReserveCoinPurchase_args
default_ReserveCoinPurchase_args = ReserveCoinPurchase_args{
  reserveCoinPurchase_args_request = default_CoinPurchaseReservation}
data ReserveCoinPurchase_result = ReserveCoinPurchase_result  { reserveCoinPurchase_result_success :: PaymentReservationResult
  , reserveCoinPurchase_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCoinPurchase_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCoinPurchase_result_success record   `H.hashWithSalt` reserveCoinPurchase_result_e record  
instance QC.Arbitrary ReserveCoinPurchase_result where 
  arbitrary = M.liftM ReserveCoinPurchase_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCoinPurchase_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCoinPurchase_result{reserveCoinPurchase_result_success = reserveCoinPurchase_result_success obj} then P.Nothing else P.Just $ default_ReserveCoinPurchase_result{reserveCoinPurchase_result_success = reserveCoinPurchase_result_success obj}
    , if obj == default_ReserveCoinPurchase_result{reserveCoinPurchase_result_e = reserveCoinPurchase_result_e obj} then P.Nothing else P.Just $ default_ReserveCoinPurchase_result{reserveCoinPurchase_result_e = reserveCoinPurchase_result_e obj}
    ]
from_ReserveCoinPurchase_result :: ReserveCoinPurchase_result -> T.ThriftVal
from_ReserveCoinPurchase_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5881 -> (1, ("e",from_TalkException _v5881))) <$> reserveCoinPurchase_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5881 -> P.Just (0, ("success",from_PaymentReservationResult _v5881))) $ reserveCoinPurchase_result_success record
    , (\_v5881 -> (1, ("e",from_TalkException _v5881))) <$> reserveCoinPurchase_result_e record
    ]
    )
write_ReserveCoinPurchase_result :: T.Protocol p => p -> ReserveCoinPurchase_result -> P.IO ()
write_ReserveCoinPurchase_result oprot record = T.writeVal oprot $ from_ReserveCoinPurchase_result record
encode_ReserveCoinPurchase_result :: T.StatelessProtocol p => p -> ReserveCoinPurchase_result -> LBS.ByteString
encode_ReserveCoinPurchase_result oprot record = T.serializeVal oprot $ from_ReserveCoinPurchase_result record
to_ReserveCoinPurchase_result :: T.ThriftVal -> ReserveCoinPurchase_result
to_ReserveCoinPurchase_result (T.TStruct fields) = ReserveCoinPurchase_result{
  reserveCoinPurchase_result_success = P.maybe (reserveCoinPurchase_result_success default_ReserveCoinPurchase_result) (\(_,_val5883) -> (case _val5883 of {T.TStruct _val5884 -> (to_PaymentReservationResult (T.TStruct _val5884)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCoinPurchase_result_e = P.maybe (P.Nothing) (\(_,_val5883) -> P.Just (case _val5883 of {T.TStruct _val5885 -> (to_TalkException (T.TStruct _val5885)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCoinPurchase_result _ = P.error "not a struct"
read_ReserveCoinPurchase_result :: T.Protocol p => p -> P.IO ReserveCoinPurchase_result
read_ReserveCoinPurchase_result iprot = to_ReserveCoinPurchase_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCoinPurchase_result)
decode_ReserveCoinPurchase_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCoinPurchase_result
decode_ReserveCoinPurchase_result iprot bs = to_ReserveCoinPurchase_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCoinPurchase_result) bs
typemap_ReserveCoinPurchase_result :: T.TypeMap
typemap_ReserveCoinPurchase_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaymentReservationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReserveCoinPurchase_result :: ReserveCoinPurchase_result
default_ReserveCoinPurchase_result = ReserveCoinPurchase_result{
  reserveCoinPurchase_result_success = default_PaymentReservationResult,
  reserveCoinPurchase_result_e = P.Nothing}
data ReservePayment_args = ReservePayment_args  { reservePayment_args_paymentReservation :: PaymentReservation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReservePayment_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reservePayment_args_paymentReservation record  
instance QC.Arbitrary ReservePayment_args where 
  arbitrary = M.liftM ReservePayment_args (QC.arbitrary)
  shrink obj | obj == default_ReservePayment_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReservePayment_args{reservePayment_args_paymentReservation = reservePayment_args_paymentReservation obj} then P.Nothing else P.Just $ default_ReservePayment_args{reservePayment_args_paymentReservation = reservePayment_args_paymentReservation obj}
    ]
from_ReservePayment_args :: ReservePayment_args -> T.ThriftVal
from_ReservePayment_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5888 -> P.Just (2, ("paymentReservation",from_PaymentReservation _v5888))) $ reservePayment_args_paymentReservation record
  ]
write_ReservePayment_args :: T.Protocol p => p -> ReservePayment_args -> P.IO ()
write_ReservePayment_args oprot record = T.writeVal oprot $ from_ReservePayment_args record
encode_ReservePayment_args :: T.StatelessProtocol p => p -> ReservePayment_args -> LBS.ByteString
encode_ReservePayment_args oprot record = T.serializeVal oprot $ from_ReservePayment_args record
to_ReservePayment_args :: T.ThriftVal -> ReservePayment_args
to_ReservePayment_args (T.TStruct fields) = ReservePayment_args{
  reservePayment_args_paymentReservation = P.maybe (reservePayment_args_paymentReservation default_ReservePayment_args) (\(_,_val5890) -> (case _val5890 of {T.TStruct _val5891 -> (to_PaymentReservation (T.TStruct _val5891)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ReservePayment_args _ = P.error "not a struct"
read_ReservePayment_args :: T.Protocol p => p -> P.IO ReservePayment_args
read_ReservePayment_args iprot = to_ReservePayment_args <$> T.readVal iprot (T.T_STRUCT typemap_ReservePayment_args)
decode_ReservePayment_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReservePayment_args
decode_ReservePayment_args iprot bs = to_ReservePayment_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReservePayment_args) bs
typemap_ReservePayment_args :: T.TypeMap
typemap_ReservePayment_args = Map.fromList [(2,("paymentReservation",(T.T_STRUCT typemap_PaymentReservation)))]
default_ReservePayment_args :: ReservePayment_args
default_ReservePayment_args = ReservePayment_args{
  reservePayment_args_paymentReservation = default_PaymentReservation}
data ReservePayment_result = ReservePayment_result  { reservePayment_result_success :: PaymentReservationResult
  , reservePayment_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReservePayment_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reservePayment_result_success record   `H.hashWithSalt` reservePayment_result_e record  
instance QC.Arbitrary ReservePayment_result where 
  arbitrary = M.liftM ReservePayment_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReservePayment_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReservePayment_result{reservePayment_result_success = reservePayment_result_success obj} then P.Nothing else P.Just $ default_ReservePayment_result{reservePayment_result_success = reservePayment_result_success obj}
    , if obj == default_ReservePayment_result{reservePayment_result_e = reservePayment_result_e obj} then P.Nothing else P.Just $ default_ReservePayment_result{reservePayment_result_e = reservePayment_result_e obj}
    ]
from_ReservePayment_result :: ReservePayment_result -> T.ThriftVal
from_ReservePayment_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5894 -> (1, ("e",from_TalkException _v5894))) <$> reservePayment_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5894 -> P.Just (0, ("success",from_PaymentReservationResult _v5894))) $ reservePayment_result_success record
    , (\_v5894 -> (1, ("e",from_TalkException _v5894))) <$> reservePayment_result_e record
    ]
    )
write_ReservePayment_result :: T.Protocol p => p -> ReservePayment_result -> P.IO ()
write_ReservePayment_result oprot record = T.writeVal oprot $ from_ReservePayment_result record
encode_ReservePayment_result :: T.StatelessProtocol p => p -> ReservePayment_result -> LBS.ByteString
encode_ReservePayment_result oprot record = T.serializeVal oprot $ from_ReservePayment_result record
to_ReservePayment_result :: T.ThriftVal -> ReservePayment_result
to_ReservePayment_result (T.TStruct fields) = ReservePayment_result{
  reservePayment_result_success = P.maybe (reservePayment_result_success default_ReservePayment_result) (\(_,_val5896) -> (case _val5896 of {T.TStruct _val5897 -> (to_PaymentReservationResult (T.TStruct _val5897)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reservePayment_result_e = P.maybe (P.Nothing) (\(_,_val5896) -> P.Just (case _val5896 of {T.TStruct _val5898 -> (to_TalkException (T.TStruct _val5898)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReservePayment_result _ = P.error "not a struct"
read_ReservePayment_result :: T.Protocol p => p -> P.IO ReservePayment_result
read_ReservePayment_result iprot = to_ReservePayment_result <$> T.readVal iprot (T.T_STRUCT typemap_ReservePayment_result)
decode_ReservePayment_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReservePayment_result
decode_ReservePayment_result iprot bs = to_ReservePayment_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReservePayment_result) bs
typemap_ReservePayment_result :: T.TypeMap
typemap_ReservePayment_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaymentReservationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReservePayment_result :: ReservePayment_result
default_ReservePayment_result = ReservePayment_result{
  reservePayment_result_success = default_PaymentReservationResult,
  reservePayment_result_e = P.Nothing}
process_buyCoinProduct (seqid, iprot, oprot, handler) = do
  args <- read_BuyCoinProduct_args iprot
  (X.catch
    (X.catch
      (do
        Iface.buyCoinProduct handler (buyCoinProduct_args_paymentReservation args)
        let res = default_BuyCoinProduct_result
        T.writeMessage oprot ("buyCoinProduct", T.M_REPLY, seqid) $
          write_BuyCoinProduct_result oprot res)
      (\e  -> do
        let res = default_BuyCoinProduct_result{buyCoinProduct_result_e = P.Just e}
        T.writeMessage oprot ("buyCoinProduct", T.M_REPLY, seqid) $
          write_BuyCoinProduct_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("buyCoinProduct", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_buyFreeProduct (seqid, iprot, oprot, handler) = do
  args <- read_BuyFreeProduct_args iprot
  (X.catch
    (X.catch
      (do
        Iface.buyFreeProduct handler (buyFreeProduct_args_receiverMid args) (buyFreeProduct_args_productId args) (buyFreeProduct_args_messageTemplate args) (buyFreeProduct_args_language args) (buyFreeProduct_args_country args) (buyFreeProduct_args_packageId args)
        let res = default_BuyFreeProduct_result
        T.writeMessage oprot ("buyFreeProduct", T.M_REPLY, seqid) $
          write_BuyFreeProduct_result oprot res)
      (\e  -> do
        let res = default_BuyFreeProduct_result{buyFreeProduct_result_e = P.Just e}
        T.writeMessage oprot ("buyFreeProduct", T.M_REPLY, seqid) $
          write_BuyFreeProduct_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("buyFreeProduct", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_buyMustbuyProduct (seqid, iprot, oprot, handler) = do
  args <- read_BuyMustbuyProduct_args iprot
  (X.catch
    (X.catch
      (do
        Iface.buyMustbuyProduct handler (buyMustbuyProduct_args_receiverMid args) (buyMustbuyProduct_args_productId args) (buyMustbuyProduct_args_messageTemplate args) (buyMustbuyProduct_args_language args) (buyMustbuyProduct_args_country args) (buyMustbuyProduct_args_packageId args) (buyMustbuyProduct_args_serialNumber args)
        let res = default_BuyMustbuyProduct_result
        T.writeMessage oprot ("buyMustbuyProduct", T.M_REPLY, seqid) $
          write_BuyMustbuyProduct_result oprot res)
      (\e  -> do
        let res = default_BuyMustbuyProduct_result{buyMustbuyProduct_result_e = P.Just e}
        T.writeMessage oprot ("buyMustbuyProduct", T.M_REPLY, seqid) $
          write_BuyMustbuyProduct_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("buyMustbuyProduct", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_checkCanReceivePresent (seqid, iprot, oprot, handler) = do
  args <- read_CheckCanReceivePresent_args iprot
  (X.catch
    (X.catch
      (do
        Iface.checkCanReceivePresent handler (checkCanReceivePresent_args_recipientMid args) (checkCanReceivePresent_args_packageId args) (checkCanReceivePresent_args_language args) (checkCanReceivePresent_args_country args)
        let res = default_CheckCanReceivePresent_result
        T.writeMessage oprot ("checkCanReceivePresent", T.M_REPLY, seqid) $
          write_CheckCanReceivePresent_result oprot res)
      (\e  -> do
        let res = default_CheckCanReceivePresent_result{checkCanReceivePresent_result_e = P.Just e}
        T.writeMessage oprot ("checkCanReceivePresent", T.M_REPLY, seqid) $
          write_CheckCanReceivePresent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("checkCanReceivePresent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getActivePurchases (seqid, iprot, oprot, handler) = do
  args <- read_GetActivePurchases_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getActivePurchases handler (getActivePurchases_args_start args) (getActivePurchases_args_size args) (getActivePurchases_args_language args) (getActivePurchases_args_country args)
        let res = default_GetActivePurchases_result{getActivePurchases_result_success = val}
        T.writeMessage oprot ("getActivePurchases", T.M_REPLY, seqid) $
          write_GetActivePurchases_result oprot res)
      (\e  -> do
        let res = default_GetActivePurchases_result{getActivePurchases_result_e = P.Just e}
        T.writeMessage oprot ("getActivePurchases", T.M_REPLY, seqid) $
          write_GetActivePurchases_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getActivePurchases", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getActivePurchaseVersions (seqid, iprot, oprot, handler) = do
  args <- read_GetActivePurchaseVersions_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getActivePurchaseVersions handler (getActivePurchaseVersions_args_start args) (getActivePurchaseVersions_args_size args) (getActivePurchaseVersions_args_language args) (getActivePurchaseVersions_args_country args)
        let res = default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_success = val}
        T.writeMessage oprot ("getActivePurchaseVersions", T.M_REPLY, seqid) $
          write_GetActivePurchaseVersions_result oprot res)
      (\e  -> do
        let res = default_GetActivePurchaseVersions_result{getActivePurchaseVersions_result_e = P.Just e}
        T.writeMessage oprot ("getActivePurchaseVersions", T.M_REPLY, seqid) $
          write_GetActivePurchaseVersions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getActivePurchaseVersions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCoinProducts (seqid, iprot, oprot, handler) = do
  args <- read_GetCoinProducts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCoinProducts handler (getCoinProducts_args_appStoreCode args) (getCoinProducts_args_country args) (getCoinProducts_args_language args)
        let res = default_GetCoinProducts_result{getCoinProducts_result_success = val}
        T.writeMessage oprot ("getCoinProducts", T.M_REPLY, seqid) $
          write_GetCoinProducts_result oprot res)
      (\e  -> do
        let res = default_GetCoinProducts_result{getCoinProducts_result_e = P.Just e}
        T.writeMessage oprot ("getCoinProducts", T.M_REPLY, seqid) $
          write_GetCoinProducts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCoinProducts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCoinProductsByPgCode (seqid, iprot, oprot, handler) = do
  args <- read_GetCoinProductsByPgCode_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCoinProductsByPgCode handler (getCoinProductsByPgCode_args_appStoreCode args) (getCoinProductsByPgCode_args_pgCode args) (getCoinProductsByPgCode_args_country args) (getCoinProductsByPgCode_args_language args)
        let res = default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_success = val}
        T.writeMessage oprot ("getCoinProductsByPgCode", T.M_REPLY, seqid) $
          write_GetCoinProductsByPgCode_result oprot res)
      (\e  -> do
        let res = default_GetCoinProductsByPgCode_result{getCoinProductsByPgCode_result_e = P.Just e}
        T.writeMessage oprot ("getCoinProductsByPgCode", T.M_REPLY, seqid) $
          write_GetCoinProductsByPgCode_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCoinProductsByPgCode", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCoinPurchaseHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetCoinPurchaseHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCoinPurchaseHistory handler (getCoinPurchaseHistory_args_request args)
        let res = default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_success = val}
        T.writeMessage oprot ("getCoinPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCoinPurchaseHistory_result oprot res)
      (\e  -> do
        let res = default_GetCoinPurchaseHistory_result{getCoinPurchaseHistory_result_e = P.Just e}
        T.writeMessage oprot ("getCoinPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCoinPurchaseHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCoinPurchaseHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCoinUseAndRefundHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetCoinUseAndRefundHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCoinUseAndRefundHistory handler (getCoinUseAndRefundHistory_args_request args)
        let res = default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_success = val}
        T.writeMessage oprot ("getCoinUseAndRefundHistory", T.M_REPLY, seqid) $
          write_GetCoinUseAndRefundHistory_result oprot res)
      (\e  -> do
        let res = default_GetCoinUseAndRefundHistory_result{getCoinUseAndRefundHistory_result_e = P.Just e}
        T.writeMessage oprot ("getCoinUseAndRefundHistory", T.M_REPLY, seqid) $
          write_GetCoinUseAndRefundHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCoinUseAndRefundHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDownloads (seqid, iprot, oprot, handler) = do
  args <- read_GetDownloads_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDownloads handler (getDownloads_args_start args) (getDownloads_args_size args) (getDownloads_args_language args) (getDownloads_args_country args)
        let res = default_GetDownloads_result{getDownloads_result_success = val}
        T.writeMessage oprot ("getDownloads", T.M_REPLY, seqid) $
          write_GetDownloads_result oprot res)
      (\e  -> do
        let res = default_GetDownloads_result{getDownloads_result_e = P.Just e}
        T.writeMessage oprot ("getDownloads", T.M_REPLY, seqid) $
          write_GetDownloads_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDownloads", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getEventPackages (seqid, iprot, oprot, handler) = do
  args <- read_GetEventPackages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getEventPackages handler (getEventPackages_args_start args) (getEventPackages_args_size args) (getEventPackages_args_language args) (getEventPackages_args_country args)
        let res = default_GetEventPackages_result{getEventPackages_result_success = val}
        T.writeMessage oprot ("getEventPackages", T.M_REPLY, seqid) $
          write_GetEventPackages_result oprot res)
      (\e  -> do
        let res = default_GetEventPackages_result{getEventPackages_result_e = P.Just e}
        T.writeMessage oprot ("getEventPackages", T.M_REPLY, seqid) $
          write_GetEventPackages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getEventPackages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNewlyReleasedPackages (seqid, iprot, oprot, handler) = do
  args <- read_GetNewlyReleasedPackages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getNewlyReleasedPackages handler (getNewlyReleasedPackages_args_start args) (getNewlyReleasedPackages_args_size args) (getNewlyReleasedPackages_args_language args) (getNewlyReleasedPackages_args_country args)
        let res = default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_success = val}
        T.writeMessage oprot ("getNewlyReleasedPackages", T.M_REPLY, seqid) $
          write_GetNewlyReleasedPackages_result oprot res)
      (\e  -> do
        let res = default_GetNewlyReleasedPackages_result{getNewlyReleasedPackages_result_e = P.Just e}
        T.writeMessage oprot ("getNewlyReleasedPackages", T.M_REPLY, seqid) $
          write_GetNewlyReleasedPackages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNewlyReleasedPackages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPopularPackages (seqid, iprot, oprot, handler) = do
  args <- read_GetPopularPackages_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPopularPackages handler (getPopularPackages_args_start args) (getPopularPackages_args_size args) (getPopularPackages_args_language args) (getPopularPackages_args_country args)
        let res = default_GetPopularPackages_result{getPopularPackages_result_success = val}
        T.writeMessage oprot ("getPopularPackages", T.M_REPLY, seqid) $
          write_GetPopularPackages_result oprot res)
      (\e  -> do
        let res = default_GetPopularPackages_result{getPopularPackages_result_e = P.Just e}
        T.writeMessage oprot ("getPopularPackages", T.M_REPLY, seqid) $
          write_GetPopularPackages_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPopularPackages", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPresentsReceived (seqid, iprot, oprot, handler) = do
  args <- read_GetPresentsReceived_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPresentsReceived handler (getPresentsReceived_args_start args) (getPresentsReceived_args_size args) (getPresentsReceived_args_language args) (getPresentsReceived_args_country args)
        let res = default_GetPresentsReceived_result{getPresentsReceived_result_success = val}
        T.writeMessage oprot ("getPresentsReceived", T.M_REPLY, seqid) $
          write_GetPresentsReceived_result oprot res)
      (\e  -> do
        let res = default_GetPresentsReceived_result{getPresentsReceived_result_e = P.Just e}
        T.writeMessage oprot ("getPresentsReceived", T.M_REPLY, seqid) $
          write_GetPresentsReceived_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPresentsReceived", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPresentsSent (seqid, iprot, oprot, handler) = do
  args <- read_GetPresentsSent_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPresentsSent handler (getPresentsSent_args_start args) (getPresentsSent_args_size args) (getPresentsSent_args_language args) (getPresentsSent_args_country args)
        let res = default_GetPresentsSent_result{getPresentsSent_result_success = val}
        T.writeMessage oprot ("getPresentsSent", T.M_REPLY, seqid) $
          write_GetPresentsSent_result oprot res)
      (\e  -> do
        let res = default_GetPresentsSent_result{getPresentsSent_result_e = P.Just e}
        T.writeMessage oprot ("getPresentsSent", T.M_REPLY, seqid) $
          write_GetPresentsSent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPresentsSent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProduct (seqid, iprot, oprot, handler) = do
  args <- read_GetProduct_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProduct handler (getProduct_args_packageID args) (getProduct_args_language args) (getProduct_args_country args)
        let res = default_GetProduct_result{getProduct_result_success = val}
        T.writeMessage oprot ("getProduct", T.M_REPLY, seqid) $
          write_GetProduct_result oprot res)
      (\e  -> do
        let res = default_GetProduct_result{getProduct_result_e = P.Just e}
        T.writeMessage oprot ("getProduct", T.M_REPLY, seqid) $
          write_GetProduct_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProduct", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProductList (seqid, iprot, oprot, handler) = do
  args <- read_GetProductList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProductList handler (getProductList_args_productIdList args) (getProductList_args_language args) (getProductList_args_country args)
        let res = default_GetProductList_result{getProductList_result_success = val}
        T.writeMessage oprot ("getProductList", T.M_REPLY, seqid) $
          write_GetProductList_result oprot res)
      (\e  -> do
        let res = default_GetProductList_result{getProductList_result_e = P.Just e}
        T.writeMessage oprot ("getProductList", T.M_REPLY, seqid) $
          write_GetProductList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProductList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProductListWithCarrier (seqid, iprot, oprot, handler) = do
  args <- read_GetProductListWithCarrier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProductListWithCarrier handler (getProductListWithCarrier_args_productIdList args) (getProductListWithCarrier_args_language args) (getProductListWithCarrier_args_country args) (getProductListWithCarrier_args_carrierCode args)
        let res = default_GetProductListWithCarrier_result{getProductListWithCarrier_result_success = val}
        T.writeMessage oprot ("getProductListWithCarrier", T.M_REPLY, seqid) $
          write_GetProductListWithCarrier_result oprot res)
      (\e  -> do
        let res = default_GetProductListWithCarrier_result{getProductListWithCarrier_result_e = P.Just e}
        T.writeMessage oprot ("getProductListWithCarrier", T.M_REPLY, seqid) $
          write_GetProductListWithCarrier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProductListWithCarrier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProductWithCarrier (seqid, iprot, oprot, handler) = do
  args <- read_GetProductWithCarrier_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProductWithCarrier handler (getProductWithCarrier_args_packageID args) (getProductWithCarrier_args_language args) (getProductWithCarrier_args_country args) (getProductWithCarrier_args_carrierCode args)
        let res = default_GetProductWithCarrier_result{getProductWithCarrier_result_success = val}
        T.writeMessage oprot ("getProductWithCarrier", T.M_REPLY, seqid) $
          write_GetProductWithCarrier_result oprot res)
      (\e  -> do
        let res = default_GetProductWithCarrier_result{getProductWithCarrier_result_e = P.Just e}
        T.writeMessage oprot ("getProductWithCarrier", T.M_REPLY, seqid) $
          write_GetProductWithCarrier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProductWithCarrier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPurchaseHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetPurchaseHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPurchaseHistory handler (getPurchaseHistory_args_start args) (getPurchaseHistory_args_size args) (getPurchaseHistory_args_language args) (getPurchaseHistory_args_country args)
        let res = default_GetPurchaseHistory_result{getPurchaseHistory_result_success = val}
        T.writeMessage oprot ("getPurchaseHistory", T.M_REPLY, seqid) $
          write_GetPurchaseHistory_result oprot res)
      (\e  -> do
        let res = default_GetPurchaseHistory_result{getPurchaseHistory_result_e = P.Just e}
        T.writeMessage oprot ("getPurchaseHistory", T.M_REPLY, seqid) $
          write_GetPurchaseHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPurchaseHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getTotalBalance (seqid, iprot, oprot, handler) = do
  args <- read_GetTotalBalance_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getTotalBalance handler (getTotalBalance_args_appStoreCode args)
        let res = default_GetTotalBalance_result{getTotalBalance_result_success = val}
        T.writeMessage oprot ("getTotalBalance", T.M_REPLY, seqid) $
          write_GetTotalBalance_result oprot res)
      (\e  -> do
        let res = default_GetTotalBalance_result{getTotalBalance_result_e = P.Just e}
        T.writeMessage oprot ("getTotalBalance", T.M_REPLY, seqid) $
          write_GetTotalBalance_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getTotalBalance", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyDownloaded (seqid, iprot, oprot, handler) = do
  args <- read_NotifyDownloaded_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.notifyDownloaded handler (notifyDownloaded_args_packageId args) (notifyDownloaded_args_language args)
        let res = default_NotifyDownloaded_result{notifyDownloaded_result_success = val}
        T.writeMessage oprot ("notifyDownloaded", T.M_REPLY, seqid) $
          write_NotifyDownloaded_result oprot res)
      (\e  -> do
        let res = default_NotifyDownloaded_result{notifyDownloaded_result_e = P.Just e}
        T.writeMessage oprot ("notifyDownloaded", T.M_REPLY, seqid) $
          write_NotifyDownloaded_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyDownloaded", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCoinPurchase (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCoinPurchase_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCoinPurchase handler (reserveCoinPurchase_args_request args)
        let res = default_ReserveCoinPurchase_result{reserveCoinPurchase_result_success = val}
        T.writeMessage oprot ("reserveCoinPurchase", T.M_REPLY, seqid) $
          write_ReserveCoinPurchase_result oprot res)
      (\e  -> do
        let res = default_ReserveCoinPurchase_result{reserveCoinPurchase_result_e = P.Just e}
        T.writeMessage oprot ("reserveCoinPurchase", T.M_REPLY, seqid) $
          write_ReserveCoinPurchase_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCoinPurchase", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reservePayment (seqid, iprot, oprot, handler) = do
  args <- read_ReservePayment_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reservePayment handler (reservePayment_args_paymentReservation args)
        let res = default_ReservePayment_result{reservePayment_result_success = val}
        T.writeMessage oprot ("reservePayment", T.M_REPLY, seqid) $
          write_ReservePayment_result oprot res)
      (\e  -> do
        let res = default_ReservePayment_result{reservePayment_result_e = P.Just e}
        T.writeMessage oprot ("reservePayment", T.M_REPLY, seqid) $
          write_ReservePayment_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reservePayment", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "buyCoinProduct" -> process_buyCoinProduct (seqid,iprot,oprot,handler)
  "buyFreeProduct" -> process_buyFreeProduct (seqid,iprot,oprot,handler)
  "buyMustbuyProduct" -> process_buyMustbuyProduct (seqid,iprot,oprot,handler)
  "checkCanReceivePresent" -> process_checkCanReceivePresent (seqid,iprot,oprot,handler)
  "getActivePurchases" -> process_getActivePurchases (seqid,iprot,oprot,handler)
  "getActivePurchaseVersions" -> process_getActivePurchaseVersions (seqid,iprot,oprot,handler)
  "getCoinProducts" -> process_getCoinProducts (seqid,iprot,oprot,handler)
  "getCoinProductsByPgCode" -> process_getCoinProductsByPgCode (seqid,iprot,oprot,handler)
  "getCoinPurchaseHistory" -> process_getCoinPurchaseHistory (seqid,iprot,oprot,handler)
  "getCoinUseAndRefundHistory" -> process_getCoinUseAndRefundHistory (seqid,iprot,oprot,handler)
  "getDownloads" -> process_getDownloads (seqid,iprot,oprot,handler)
  "getEventPackages" -> process_getEventPackages (seqid,iprot,oprot,handler)
  "getNewlyReleasedPackages" -> process_getNewlyReleasedPackages (seqid,iprot,oprot,handler)
  "getPopularPackages" -> process_getPopularPackages (seqid,iprot,oprot,handler)
  "getPresentsReceived" -> process_getPresentsReceived (seqid,iprot,oprot,handler)
  "getPresentsSent" -> process_getPresentsSent (seqid,iprot,oprot,handler)
  "getProduct" -> process_getProduct (seqid,iprot,oprot,handler)
  "getProductList" -> process_getProductList (seqid,iprot,oprot,handler)
  "getProductListWithCarrier" -> process_getProductListWithCarrier (seqid,iprot,oprot,handler)
  "getProductWithCarrier" -> process_getProductWithCarrier (seqid,iprot,oprot,handler)
  "getPurchaseHistory" -> process_getPurchaseHistory (seqid,iprot,oprot,handler)
  "getTotalBalance" -> process_getTotalBalance (seqid,iprot,oprot,handler)
  "notifyDownloaded" -> process_notifyDownloaded (seqid,iprot,oprot,handler)
  "reserveCoinPurchase" -> process_reserveCoinPurchase (seqid,iprot,oprot,handler)
  "reservePayment" -> process_reservePayment (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
