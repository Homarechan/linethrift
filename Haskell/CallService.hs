{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module CallService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified CallService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetUserStatus_args = GetUserStatus_args  { getUserStatus_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserStatus_args_mid record  
instance QC.Arbitrary GetUserStatus_args where 
  arbitrary = M.liftM GetUserStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetUserStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserStatus_args{getUserStatus_args_mid = getUserStatus_args_mid obj} then P.Nothing else P.Just $ default_GetUserStatus_args{getUserStatus_args_mid = getUserStatus_args_mid obj}
    ]
from_GetUserStatus_args :: GetUserStatus_args -> T.ThriftVal
from_GetUserStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10122 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v10122))) $ getUserStatus_args_mid record
  ]
write_GetUserStatus_args :: T.Protocol p => p -> GetUserStatus_args -> P.IO ()
write_GetUserStatus_args oprot record = T.writeVal oprot $ from_GetUserStatus_args record
encode_GetUserStatus_args :: T.StatelessProtocol p => p -> GetUserStatus_args -> LBS.ByteString
encode_GetUserStatus_args oprot record = T.serializeVal oprot $ from_GetUserStatus_args record
to_GetUserStatus_args :: T.ThriftVal -> GetUserStatus_args
to_GetUserStatus_args (T.TStruct fields) = GetUserStatus_args{
  getUserStatus_args_mid = P.maybe (getUserStatus_args_mid default_GetUserStatus_args) (\(_,_val10124) -> (case _val10124 of {T.TString _val10125 -> E.decodeUtf8 _val10125; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserStatus_args _ = P.error "not a struct"
read_GetUserStatus_args :: T.Protocol p => p -> P.IO GetUserStatus_args
read_GetUserStatus_args iprot = to_GetUserStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserStatus_args)
decode_GetUserStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserStatus_args
decode_GetUserStatus_args iprot bs = to_GetUserStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserStatus_args) bs
typemap_GetUserStatus_args :: T.TypeMap
typemap_GetUserStatus_args = Map.fromList [(1,("mid",T.T_STRING))]
default_GetUserStatus_args :: GetUserStatus_args
default_GetUserStatus_args = GetUserStatus_args{
  getUserStatus_args_mid = ""}
data GetUserStatus_result = GetUserStatus_result  { getUserStatus_result_success :: UserStatus
  , getUserStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserStatus_result_success record   `H.hashWithSalt` getUserStatus_result_e record  
instance QC.Arbitrary GetUserStatus_result where 
  arbitrary = M.liftM GetUserStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserStatus_result{getUserStatus_result_success = getUserStatus_result_success obj} then P.Nothing else P.Just $ default_GetUserStatus_result{getUserStatus_result_success = getUserStatus_result_success obj}
    , if obj == default_GetUserStatus_result{getUserStatus_result_e = getUserStatus_result_e obj} then P.Nothing else P.Just $ default_GetUserStatus_result{getUserStatus_result_e = getUserStatus_result_e obj}
    ]
from_GetUserStatus_result :: GetUserStatus_result -> T.ThriftVal
from_GetUserStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10128 -> (1, ("e",from_TalkException _v10128))) <$> getUserStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10128 -> P.Just (0, ("success",T.TI32 $ P.fromIntegral $ P.fromEnum _v10128))) $ getUserStatus_result_success record
    , (\_v10128 -> (1, ("e",from_TalkException _v10128))) <$> getUserStatus_result_e record
    ]
    )
write_GetUserStatus_result :: T.Protocol p => p -> GetUserStatus_result -> P.IO ()
write_GetUserStatus_result oprot record = T.writeVal oprot $ from_GetUserStatus_result record
encode_GetUserStatus_result :: T.StatelessProtocol p => p -> GetUserStatus_result -> LBS.ByteString
encode_GetUserStatus_result oprot record = T.serializeVal oprot $ from_GetUserStatus_result record
to_GetUserStatus_result :: T.ThriftVal -> GetUserStatus_result
to_GetUserStatus_result (T.TStruct fields) = GetUserStatus_result{
  getUserStatus_result_success = P.maybe (getUserStatus_result_success default_GetUserStatus_result) (\(_,_val10130) -> (case _val10130 of {T.TI32 _val10131 -> P.toEnum $ P.fromIntegral _val10131; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserStatus_result_e = P.maybe (P.Nothing) (\(_,_val10130) -> P.Just (case _val10130 of {T.TStruct _val10132 -> (to_TalkException (T.TStruct _val10132)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserStatus_result _ = P.error "not a struct"
read_GetUserStatus_result :: T.Protocol p => p -> P.IO GetUserStatus_result
read_GetUserStatus_result iprot = to_GetUserStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserStatus_result)
decode_GetUserStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserStatus_result
decode_GetUserStatus_result iprot bs = to_GetUserStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserStatus_result) bs
typemap_GetUserStatus_result :: T.TypeMap
typemap_GetUserStatus_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserStatus_result :: GetUserStatus_result
default_GetUserStatus_result = GetUserStatus_result{
  getUserStatus_result_success = (P.toEnum 0),
  getUserStatus_result_e = P.Nothing}
data UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args  { updateProfileAttributeForChannel_args_profileAttribute :: ProfileAttribute
  , updateProfileAttributeForChannel_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_args_profileAttribute record   `H.hashWithSalt` updateProfileAttributeForChannel_args_value record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_args where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj}
    , if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj}
    ]
from_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args -> T.ThriftVal
from_UpdateProfileAttributeForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10135 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v10135))) $ updateProfileAttributeForChannel_args_profileAttribute record
  , (\_v10135 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v10135))) $ updateProfileAttributeForChannel_args_value record
  ]
write_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> UpdateProfileAttributeForChannel_args -> P.IO ()
write_UpdateProfileAttributeForChannel_args oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_args record
encode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_args -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_args record
to_UpdateProfileAttributeForChannel_args :: T.ThriftVal -> UpdateProfileAttributeForChannel_args
to_UpdateProfileAttributeForChannel_args (T.TStruct fields) = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = P.maybe (updateProfileAttributeForChannel_args_profileAttribute default_UpdateProfileAttributeForChannel_args) (\(_,_val10137) -> (case _val10137 of {T.TI32 _val10138 -> P.toEnum $ P.fromIntegral _val10138; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttributeForChannel_args_value = P.maybe (updateProfileAttributeForChannel_args_value default_UpdateProfileAttributeForChannel_args) (\(_,_val10137) -> (case _val10137 of {T.TString _val10139 -> E.decodeUtf8 _val10139; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttributeForChannel_args _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_args
read_UpdateProfileAttributeForChannel_args iprot = to_UpdateProfileAttributeForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args)
decode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_args
decode_UpdateProfileAttributeForChannel_args iprot bs = to_UpdateProfileAttributeForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args) bs
typemap_UpdateProfileAttributeForChannel_args :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_args = Map.fromList [(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args
default_UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = (P.toEnum 0),
  updateProfileAttributeForChannel_args_value = ""}
data UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result  { updateProfileAttributeForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_result_e record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_result where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj}
    ]
from_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result -> T.ThriftVal
from_UpdateProfileAttributeForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10142 -> (1, ("e",from_TalkException _v10142))) <$> updateProfileAttributeForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10142 -> (1, ("e",from_TalkException _v10142))) <$> updateProfileAttributeForChannel_result_e record
    ]
    )
write_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> UpdateProfileAttributeForChannel_result -> P.IO ()
write_UpdateProfileAttributeForChannel_result oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_result record
encode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_result -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_result record
to_UpdateProfileAttributeForChannel_result :: T.ThriftVal -> UpdateProfileAttributeForChannel_result
to_UpdateProfileAttributeForChannel_result (T.TStruct fields) = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10144) -> P.Just (case _val10144 of {T.TStruct _val10145 -> (to_TalkException (T.TStruct _val10145)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttributeForChannel_result _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_result
read_UpdateProfileAttributeForChannel_result iprot = to_UpdateProfileAttributeForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result)
decode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_result
decode_UpdateProfileAttributeForChannel_result iprot bs = to_UpdateProfileAttributeForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result) bs
typemap_UpdateProfileAttributeForChannel_result :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result
default_UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.Nothing}
data UpdateExtendedProfileAttribute_args = UpdateExtendedProfileAttribute_args  { updateExtendedProfileAttribute_args_attr :: ExtendedProfileAttribute
  , updateExtendedProfileAttribute_args_extendedProfile :: ExtendedProfile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateExtendedProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateExtendedProfileAttribute_args_attr record   `H.hashWithSalt` updateExtendedProfileAttribute_args_extendedProfile record  
instance QC.Arbitrary UpdateExtendedProfileAttribute_args where 
  arbitrary = M.liftM UpdateExtendedProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateExtendedProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_attr = updateExtendedProfileAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_attr = updateExtendedProfileAttribute_args_attr obj}
    , if obj == default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_extendedProfile = updateExtendedProfileAttribute_args_extendedProfile obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_extendedProfile = updateExtendedProfileAttribute_args_extendedProfile obj}
    ]
from_UpdateExtendedProfileAttribute_args :: UpdateExtendedProfileAttribute_args -> T.ThriftVal
from_UpdateExtendedProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10148 -> P.Just (1, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v10148))) $ updateExtendedProfileAttribute_args_attr record
  , (\_v10148 -> P.Just (2, ("extendedProfile",from_ExtendedProfile _v10148))) $ updateExtendedProfileAttribute_args_extendedProfile record
  ]
write_UpdateExtendedProfileAttribute_args :: T.Protocol p => p -> UpdateExtendedProfileAttribute_args -> P.IO ()
write_UpdateExtendedProfileAttribute_args oprot record = T.writeVal oprot $ from_UpdateExtendedProfileAttribute_args record
encode_UpdateExtendedProfileAttribute_args :: T.StatelessProtocol p => p -> UpdateExtendedProfileAttribute_args -> LBS.ByteString
encode_UpdateExtendedProfileAttribute_args oprot record = T.serializeVal oprot $ from_UpdateExtendedProfileAttribute_args record
to_UpdateExtendedProfileAttribute_args :: T.ThriftVal -> UpdateExtendedProfileAttribute_args
to_UpdateExtendedProfileAttribute_args (T.TStruct fields) = UpdateExtendedProfileAttribute_args{
  updateExtendedProfileAttribute_args_attr = P.maybe (updateExtendedProfileAttribute_args_attr default_UpdateExtendedProfileAttribute_args) (\(_,_val10150) -> (case _val10150 of {T.TI32 _val10151 -> P.toEnum $ P.fromIntegral _val10151; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateExtendedProfileAttribute_args_extendedProfile = P.maybe (updateExtendedProfileAttribute_args_extendedProfile default_UpdateExtendedProfileAttribute_args) (\(_,_val10150) -> (case _val10150 of {T.TStruct _val10152 -> (to_ExtendedProfile (T.TStruct _val10152)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateExtendedProfileAttribute_args _ = P.error "not a struct"
read_UpdateExtendedProfileAttribute_args :: T.Protocol p => p -> P.IO UpdateExtendedProfileAttribute_args
read_UpdateExtendedProfileAttribute_args iprot = to_UpdateExtendedProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_args)
decode_UpdateExtendedProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateExtendedProfileAttribute_args
decode_UpdateExtendedProfileAttribute_args iprot bs = to_UpdateExtendedProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_args) bs
typemap_UpdateExtendedProfileAttribute_args :: T.TypeMap
typemap_UpdateExtendedProfileAttribute_args = Map.fromList [(1,("attr",T.T_I32)),(2,("extendedProfile",(T.T_STRUCT typemap_ExtendedProfile)))]
default_UpdateExtendedProfileAttribute_args :: UpdateExtendedProfileAttribute_args
default_UpdateExtendedProfileAttribute_args = UpdateExtendedProfileAttribute_args{
  updateExtendedProfileAttribute_args_attr = (P.toEnum 0),
  updateExtendedProfileAttribute_args_extendedProfile = default_ExtendedProfile}
data UpdateExtendedProfileAttribute_result = UpdateExtendedProfileAttribute_result  { updateExtendedProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateExtendedProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateExtendedProfileAttribute_result_e record  
instance QC.Arbitrary UpdateExtendedProfileAttribute_result where 
  arbitrary = M.liftM UpdateExtendedProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateExtendedProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = updateExtendedProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = updateExtendedProfileAttribute_result_e obj}
    ]
from_UpdateExtendedProfileAttribute_result :: UpdateExtendedProfileAttribute_result -> T.ThriftVal
from_UpdateExtendedProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10155 -> (1, ("e",from_TalkException _v10155))) <$> updateExtendedProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10155 -> (1, ("e",from_TalkException _v10155))) <$> updateExtendedProfileAttribute_result_e record
    ]
    )
write_UpdateExtendedProfileAttribute_result :: T.Protocol p => p -> UpdateExtendedProfileAttribute_result -> P.IO ()
write_UpdateExtendedProfileAttribute_result oprot record = T.writeVal oprot $ from_UpdateExtendedProfileAttribute_result record
encode_UpdateExtendedProfileAttribute_result :: T.StatelessProtocol p => p -> UpdateExtendedProfileAttribute_result -> LBS.ByteString
encode_UpdateExtendedProfileAttribute_result oprot record = T.serializeVal oprot $ from_UpdateExtendedProfileAttribute_result record
to_UpdateExtendedProfileAttribute_result :: T.ThriftVal -> UpdateExtendedProfileAttribute_result
to_UpdateExtendedProfileAttribute_result (T.TStruct fields) = UpdateExtendedProfileAttribute_result{
  updateExtendedProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val10157) -> P.Just (case _val10157 of {T.TStruct _val10158 -> (to_TalkException (T.TStruct _val10158)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateExtendedProfileAttribute_result _ = P.error "not a struct"
read_UpdateExtendedProfileAttribute_result :: T.Protocol p => p -> P.IO UpdateExtendedProfileAttribute_result
read_UpdateExtendedProfileAttribute_result iprot = to_UpdateExtendedProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_result)
decode_UpdateExtendedProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateExtendedProfileAttribute_result
decode_UpdateExtendedProfileAttribute_result iprot bs = to_UpdateExtendedProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_result) bs
typemap_UpdateExtendedProfileAttribute_result :: T.TypeMap
typemap_UpdateExtendedProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateExtendedProfileAttribute_result :: UpdateExtendedProfileAttribute_result
default_UpdateExtendedProfileAttribute_result = UpdateExtendedProfileAttribute_result{
  updateExtendedProfileAttribute_result_e = P.Nothing}
data GetAllSimpleChannelContacts_args = GetAllSimpleChannelContacts_args  { getAllSimpleChannelContacts_args_statusSticonFallbackDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllSimpleChannelContacts_args_statusSticonFallbackDisabled record  
instance QC.Arbitrary GetAllSimpleChannelContacts_args where 
  arbitrary = M.liftM GetAllSimpleChannelContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetAllSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllSimpleChannelContacts_args{getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = getAllSimpleChannelContacts_args_statusSticonFallbackDisabled obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_args{getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = getAllSimpleChannelContacts_args_statusSticonFallbackDisabled obj}
    ]
from_GetAllSimpleChannelContacts_args :: GetAllSimpleChannelContacts_args -> T.ThriftVal
from_GetAllSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10161 -> P.Just (1, ("statusSticonFallbackDisabled",T.TBool _v10161))) $ getAllSimpleChannelContacts_args_statusSticonFallbackDisabled record
  ]
write_GetAllSimpleChannelContacts_args :: T.Protocol p => p -> GetAllSimpleChannelContacts_args -> P.IO ()
write_GetAllSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetAllSimpleChannelContacts_args record
encode_GetAllSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetAllSimpleChannelContacts_args -> LBS.ByteString
encode_GetAllSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetAllSimpleChannelContacts_args record
to_GetAllSimpleChannelContacts_args :: T.ThriftVal -> GetAllSimpleChannelContacts_args
to_GetAllSimpleChannelContacts_args (T.TStruct fields) = GetAllSimpleChannelContacts_args{
  getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = P.maybe (getAllSimpleChannelContacts_args_statusSticonFallbackDisabled default_GetAllSimpleChannelContacts_args) (\(_,_val10163) -> (case _val10163 of {T.TBool _val10164 -> _val10164; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllSimpleChannelContacts_args _ = P.error "not a struct"
read_GetAllSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetAllSimpleChannelContacts_args
read_GetAllSimpleChannelContacts_args iprot = to_GetAllSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_args)
decode_GetAllSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllSimpleChannelContacts_args
decode_GetAllSimpleChannelContacts_args iprot bs = to_GetAllSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_args) bs
typemap_GetAllSimpleChannelContacts_args :: T.TypeMap
typemap_GetAllSimpleChannelContacts_args = Map.fromList [(1,("statusSticonFallbackDisabled",T.T_BOOL))]
default_GetAllSimpleChannelContacts_args :: GetAllSimpleChannelContacts_args
default_GetAllSimpleChannelContacts_args = GetAllSimpleChannelContacts_args{
  getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = P.False}
data GetAllSimpleChannelContacts_result = GetAllSimpleChannelContacts_result  { getAllSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getAllSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllSimpleChannelContacts_result_success record   `H.hashWithSalt` getAllSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetAllSimpleChannelContacts_result where 
  arbitrary = M.liftM GetAllSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = getAllSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = getAllSimpleChannelContacts_result_success obj}
    , if obj == default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = getAllSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = getAllSimpleChannelContacts_result_e obj}
    ]
from_GetAllSimpleChannelContacts_result :: GetAllSimpleChannelContacts_result -> T.ThriftVal
from_GetAllSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10167 -> (1, ("e",from_TalkException _v10167))) <$> getAllSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10167 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v10169 -> from_SimpleChannelContact _v10169) $ Vector.toList _v10167))) $ getAllSimpleChannelContacts_result_success record
    , (\_v10167 -> (1, ("e",from_TalkException _v10167))) <$> getAllSimpleChannelContacts_result_e record
    ]
    )
write_GetAllSimpleChannelContacts_result :: T.Protocol p => p -> GetAllSimpleChannelContacts_result -> P.IO ()
write_GetAllSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetAllSimpleChannelContacts_result record
encode_GetAllSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetAllSimpleChannelContacts_result -> LBS.ByteString
encode_GetAllSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetAllSimpleChannelContacts_result record
to_GetAllSimpleChannelContacts_result :: T.ThriftVal -> GetAllSimpleChannelContacts_result
to_GetAllSimpleChannelContacts_result (T.TStruct fields) = GetAllSimpleChannelContacts_result{
  getAllSimpleChannelContacts_result_success = P.maybe (getAllSimpleChannelContacts_result_success default_GetAllSimpleChannelContacts_result) (\(_,_val10171) -> (case _val10171 of {T.TList _ _val10172 -> (Vector.fromList $ P.map (\_v10173 -> (case _v10173 of {T.TStruct _val10174 -> (to_SimpleChannelContact (T.TStruct _val10174)); _ -> P.error "wrong type"})) _val10172); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val10171) -> P.Just (case _val10171 of {T.TStruct _val10175 -> (to_TalkException (T.TStruct _val10175)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllSimpleChannelContacts_result _ = P.error "not a struct"
read_GetAllSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetAllSimpleChannelContacts_result
read_GetAllSimpleChannelContacts_result iprot = to_GetAllSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_result)
decode_GetAllSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllSimpleChannelContacts_result
decode_GetAllSimpleChannelContacts_result iprot bs = to_GetAllSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_result) bs
typemap_GetAllSimpleChannelContacts_result :: T.TypeMap
typemap_GetAllSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllSimpleChannelContacts_result :: GetAllSimpleChannelContacts_result
default_GetAllSimpleChannelContacts_result = GetAllSimpleChannelContacts_result{
  getAllSimpleChannelContacts_result_success = Vector.empty,
  getAllSimpleChannelContacts_result_e = P.Nothing}
data GetUserIdentities_args = GetUserIdentities_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserIdentities_args where 
  arbitrary = QC.elements [GetUserIdentities_args]
from_GetUserIdentities_args :: GetUserIdentities_args -> T.ThriftVal
from_GetUserIdentities_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserIdentities_args :: T.Protocol p => p -> GetUserIdentities_args -> P.IO ()
write_GetUserIdentities_args oprot record = T.writeVal oprot $ from_GetUserIdentities_args record
encode_GetUserIdentities_args :: T.StatelessProtocol p => p -> GetUserIdentities_args -> LBS.ByteString
encode_GetUserIdentities_args oprot record = T.serializeVal oprot $ from_GetUserIdentities_args record
to_GetUserIdentities_args :: T.ThriftVal -> GetUserIdentities_args
to_GetUserIdentities_args (T.TStruct fields) = GetUserIdentities_args{

  }
to_GetUserIdentities_args _ = P.error "not a struct"
read_GetUserIdentities_args :: T.Protocol p => p -> P.IO GetUserIdentities_args
read_GetUserIdentities_args iprot = to_GetUserIdentities_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_args)
decode_GetUserIdentities_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_args
decode_GetUserIdentities_args iprot bs = to_GetUserIdentities_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_args) bs
typemap_GetUserIdentities_args :: T.TypeMap
typemap_GetUserIdentities_args = Map.fromList []
default_GetUserIdentities_args :: GetUserIdentities_args
default_GetUserIdentities_args = GetUserIdentities_args{
}
data GetUserIdentities_result = GetUserIdentities_result  { getUserIdentities_result_success :: (Map.HashMap RegistrationType LT.Text)
  , getUserIdentities_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserIdentities_result_success record   `H.hashWithSalt` getUserIdentities_result_e record  
instance QC.Arbitrary GetUserIdentities_result where 
  arbitrary = M.liftM GetUserIdentities_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserIdentities_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj}
    , if obj == default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj}
    ]
from_GetUserIdentities_result :: GetUserIdentities_result -> T.ThriftVal
from_GetUserIdentities_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10183 -> (1, ("e",from_TalkException _v10183))) <$> getUserIdentities_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10183 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k10184,_v10185) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k10184, T.TString $ E.encodeUtf8 _v10185)) $ Map.toList _v10183))) $ getUserIdentities_result_success record
    , (\_v10183 -> (1, ("e",from_TalkException _v10183))) <$> getUserIdentities_result_e record
    ]
    )
write_GetUserIdentities_result :: T.Protocol p => p -> GetUserIdentities_result -> P.IO ()
write_GetUserIdentities_result oprot record = T.writeVal oprot $ from_GetUserIdentities_result record
encode_GetUserIdentities_result :: T.StatelessProtocol p => p -> GetUserIdentities_result -> LBS.ByteString
encode_GetUserIdentities_result oprot record = T.serializeVal oprot $ from_GetUserIdentities_result record
to_GetUserIdentities_result :: T.ThriftVal -> GetUserIdentities_result
to_GetUserIdentities_result (T.TStruct fields) = GetUserIdentities_result{
  getUserIdentities_result_success = P.maybe (getUserIdentities_result_success default_GetUserIdentities_result) (\(_,_val10187) -> (case _val10187 of {T.TMap _ _ _val10188 -> (Map.fromList $ P.map (\(_k10190,_v10189) -> ((case _k10190 of {T.TI32 _val10191 -> P.toEnum $ P.fromIntegral _val10191; _ -> P.error "wrong type"}),(case _v10189 of {T.TString _val10192 -> E.decodeUtf8 _val10192; _ -> P.error "wrong type"}))) _val10188); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserIdentities_result_e = P.maybe (P.Nothing) (\(_,_val10187) -> P.Just (case _val10187 of {T.TStruct _val10193 -> (to_TalkException (T.TStruct _val10193)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserIdentities_result _ = P.error "not a struct"
read_GetUserIdentities_result :: T.Protocol p => p -> P.IO GetUserIdentities_result
read_GetUserIdentities_result iprot = to_GetUserIdentities_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_result)
decode_GetUserIdentities_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_result
decode_GetUserIdentities_result iprot bs = to_GetUserIdentities_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_result) bs
typemap_GetUserIdentities_result :: T.TypeMap
typemap_GetUserIdentities_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserIdentities_result :: GetUserIdentities_result
default_GetUserIdentities_result = GetUserIdentities_result{
  getUserIdentities_result_success = Map.empty,
  getUserIdentities_result_e = P.Nothing}
data MarkPaidCallAd_args = MarkPaidCallAd_args  { markPaidCallAd_args_dialedNumber :: LT.Text
  , markPaidCallAd_args_language :: LT.Text
  , markPaidCallAd_args_disableCallerId :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkPaidCallAd_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` markPaidCallAd_args_dialedNumber record   `H.hashWithSalt` markPaidCallAd_args_language record   `H.hashWithSalt` markPaidCallAd_args_disableCallerId record  
instance QC.Arbitrary MarkPaidCallAd_args where 
  arbitrary = M.liftM MarkPaidCallAd_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MarkPaidCallAd_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_dialedNumber = markPaidCallAd_args_dialedNumber obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_dialedNumber = markPaidCallAd_args_dialedNumber obj}
    , if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_language = markPaidCallAd_args_language obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_language = markPaidCallAd_args_language obj}
    , if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_disableCallerId = markPaidCallAd_args_disableCallerId obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_disableCallerId = markPaidCallAd_args_disableCallerId obj}
    ]
from_MarkPaidCallAd_args :: MarkPaidCallAd_args -> T.ThriftVal
from_MarkPaidCallAd_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10196 -> P.Just (2, ("dialedNumber",T.TString $ E.encodeUtf8 _v10196))) $ markPaidCallAd_args_dialedNumber record
  , (\_v10196 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v10196))) $ markPaidCallAd_args_language record
  , (\_v10196 -> P.Just (4, ("disableCallerId",T.TBool _v10196))) $ markPaidCallAd_args_disableCallerId record
  ]
write_MarkPaidCallAd_args :: T.Protocol p => p -> MarkPaidCallAd_args -> P.IO ()
write_MarkPaidCallAd_args oprot record = T.writeVal oprot $ from_MarkPaidCallAd_args record
encode_MarkPaidCallAd_args :: T.StatelessProtocol p => p -> MarkPaidCallAd_args -> LBS.ByteString
encode_MarkPaidCallAd_args oprot record = T.serializeVal oprot $ from_MarkPaidCallAd_args record
to_MarkPaidCallAd_args :: T.ThriftVal -> MarkPaidCallAd_args
to_MarkPaidCallAd_args (T.TStruct fields) = MarkPaidCallAd_args{
  markPaidCallAd_args_dialedNumber = P.maybe (markPaidCallAd_args_dialedNumber default_MarkPaidCallAd_args) (\(_,_val10198) -> (case _val10198 of {T.TString _val10199 -> E.decodeUtf8 _val10199; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  markPaidCallAd_args_language = P.maybe (markPaidCallAd_args_language default_MarkPaidCallAd_args) (\(_,_val10198) -> (case _val10198 of {T.TString _val10200 -> E.decodeUtf8 _val10200; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  markPaidCallAd_args_disableCallerId = P.maybe (markPaidCallAd_args_disableCallerId default_MarkPaidCallAd_args) (\(_,_val10198) -> (case _val10198 of {T.TBool _val10201 -> _val10201; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_MarkPaidCallAd_args _ = P.error "not a struct"
read_MarkPaidCallAd_args :: T.Protocol p => p -> P.IO MarkPaidCallAd_args
read_MarkPaidCallAd_args iprot = to_MarkPaidCallAd_args <$> T.readVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_args)
decode_MarkPaidCallAd_args :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkPaidCallAd_args
decode_MarkPaidCallAd_args iprot bs = to_MarkPaidCallAd_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_args) bs
typemap_MarkPaidCallAd_args :: T.TypeMap
typemap_MarkPaidCallAd_args = Map.fromList [(2,("dialedNumber",T.T_STRING)),(3,("language",T.T_STRING)),(4,("disableCallerId",T.T_BOOL))]
default_MarkPaidCallAd_args :: MarkPaidCallAd_args
default_MarkPaidCallAd_args = MarkPaidCallAd_args{
  markPaidCallAd_args_dialedNumber = "",
  markPaidCallAd_args_language = "",
  markPaidCallAd_args_disableCallerId = P.False}
data MarkPaidCallAd_result = MarkPaidCallAd_result  { markPaidCallAd_result_success :: PaidCallDialing
  , markPaidCallAd_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkPaidCallAd_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` markPaidCallAd_result_success record   `H.hashWithSalt` markPaidCallAd_result_e record  
instance QC.Arbitrary MarkPaidCallAd_result where 
  arbitrary = M.liftM MarkPaidCallAd_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MarkPaidCallAd_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkPaidCallAd_result{markPaidCallAd_result_success = markPaidCallAd_result_success obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_result{markPaidCallAd_result_success = markPaidCallAd_result_success obj}
    , if obj == default_MarkPaidCallAd_result{markPaidCallAd_result_e = markPaidCallAd_result_e obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_result{markPaidCallAd_result_e = markPaidCallAd_result_e obj}
    ]
from_MarkPaidCallAd_result :: MarkPaidCallAd_result -> T.ThriftVal
from_MarkPaidCallAd_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10204 -> (1, ("e",from_TalkException _v10204))) <$> markPaidCallAd_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10204 -> P.Just (0, ("success",from_PaidCallDialing _v10204))) $ markPaidCallAd_result_success record
    , (\_v10204 -> (1, ("e",from_TalkException _v10204))) <$> markPaidCallAd_result_e record
    ]
    )
write_MarkPaidCallAd_result :: T.Protocol p => p -> MarkPaidCallAd_result -> P.IO ()
write_MarkPaidCallAd_result oprot record = T.writeVal oprot $ from_MarkPaidCallAd_result record
encode_MarkPaidCallAd_result :: T.StatelessProtocol p => p -> MarkPaidCallAd_result -> LBS.ByteString
encode_MarkPaidCallAd_result oprot record = T.serializeVal oprot $ from_MarkPaidCallAd_result record
to_MarkPaidCallAd_result :: T.ThriftVal -> MarkPaidCallAd_result
to_MarkPaidCallAd_result (T.TStruct fields) = MarkPaidCallAd_result{
  markPaidCallAd_result_success = P.maybe (markPaidCallAd_result_success default_MarkPaidCallAd_result) (\(_,_val10206) -> (case _val10206 of {T.TStruct _val10207 -> (to_PaidCallDialing (T.TStruct _val10207)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  markPaidCallAd_result_e = P.maybe (P.Nothing) (\(_,_val10206) -> P.Just (case _val10206 of {T.TStruct _val10208 -> (to_TalkException (T.TStruct _val10208)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkPaidCallAd_result _ = P.error "not a struct"
read_MarkPaidCallAd_result :: T.Protocol p => p -> P.IO MarkPaidCallAd_result
read_MarkPaidCallAd_result iprot = to_MarkPaidCallAd_result <$> T.readVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_result)
decode_MarkPaidCallAd_result :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkPaidCallAd_result
decode_MarkPaidCallAd_result iprot bs = to_MarkPaidCallAd_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_result) bs
typemap_MarkPaidCallAd_result :: T.TypeMap
typemap_MarkPaidCallAd_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallDialing))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_MarkPaidCallAd_result :: MarkPaidCallAd_result
default_MarkPaidCallAd_result = MarkPaidCallAd_result{
  markPaidCallAd_result_success = default_PaidCallDialing,
  markPaidCallAd_result_e = P.Nothing}
data IsGroupMember_args = IsGroupMember_args  { isGroupMember_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_args_groupId record  
instance QC.Arbitrary IsGroupMember_args where 
  arbitrary = M.liftM IsGroupMember_args (QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj} then P.Nothing else P.Just $ default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj}
    ]
from_IsGroupMember_args :: IsGroupMember_args -> T.ThriftVal
from_IsGroupMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10211 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10211))) $ isGroupMember_args_groupId record
  ]
write_IsGroupMember_args :: T.Protocol p => p -> IsGroupMember_args -> P.IO ()
write_IsGroupMember_args oprot record = T.writeVal oprot $ from_IsGroupMember_args record
encode_IsGroupMember_args :: T.StatelessProtocol p => p -> IsGroupMember_args -> LBS.ByteString
encode_IsGroupMember_args oprot record = T.serializeVal oprot $ from_IsGroupMember_args record
to_IsGroupMember_args :: T.ThriftVal -> IsGroupMember_args
to_IsGroupMember_args (T.TStruct fields) = IsGroupMember_args{
  isGroupMember_args_groupId = P.maybe (isGroupMember_args_groupId default_IsGroupMember_args) (\(_,_val10213) -> (case _val10213 of {T.TString _val10214 -> E.decodeUtf8 _val10214; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_args _ = P.error "not a struct"
read_IsGroupMember_args :: T.Protocol p => p -> P.IO IsGroupMember_args
read_IsGroupMember_args iprot = to_IsGroupMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_args)
decode_IsGroupMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_args
decode_IsGroupMember_args iprot bs = to_IsGroupMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_args) bs
typemap_IsGroupMember_args :: T.TypeMap
typemap_IsGroupMember_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_IsGroupMember_args :: IsGroupMember_args
default_IsGroupMember_args = IsGroupMember_args{
  isGroupMember_args_groupId = ""}
data IsGroupMember_result = IsGroupMember_result  { isGroupMember_result_success :: P.Bool
  , isGroupMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_result_success record   `H.hashWithSalt` isGroupMember_result_e record  
instance QC.Arbitrary IsGroupMember_result where 
  arbitrary = M.liftM IsGroupMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj}
    , if obj == default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj}
    ]
from_IsGroupMember_result :: IsGroupMember_result -> T.ThriftVal
from_IsGroupMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10217 -> (1, ("e",from_TalkException _v10217))) <$> isGroupMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10217 -> P.Just (0, ("success",T.TBool _v10217))) $ isGroupMember_result_success record
    , (\_v10217 -> (1, ("e",from_TalkException _v10217))) <$> isGroupMember_result_e record
    ]
    )
write_IsGroupMember_result :: T.Protocol p => p -> IsGroupMember_result -> P.IO ()
write_IsGroupMember_result oprot record = T.writeVal oprot $ from_IsGroupMember_result record
encode_IsGroupMember_result :: T.StatelessProtocol p => p -> IsGroupMember_result -> LBS.ByteString
encode_IsGroupMember_result oprot record = T.serializeVal oprot $ from_IsGroupMember_result record
to_IsGroupMember_result :: T.ThriftVal -> IsGroupMember_result
to_IsGroupMember_result (T.TStruct fields) = IsGroupMember_result{
  isGroupMember_result_success = P.maybe (isGroupMember_result_success default_IsGroupMember_result) (\(_,_val10219) -> (case _val10219 of {T.TBool _val10220 -> _val10220; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isGroupMember_result_e = P.maybe (P.Nothing) (\(_,_val10219) -> P.Just (case _val10219 of {T.TStruct _val10221 -> (to_TalkException (T.TStruct _val10221)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_result _ = P.error "not a struct"
read_IsGroupMember_result :: T.Protocol p => p -> P.IO IsGroupMember_result
read_IsGroupMember_result iprot = to_IsGroupMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_result)
decode_IsGroupMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_result
decode_IsGroupMember_result iprot bs = to_IsGroupMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_result) bs
typemap_IsGroupMember_result :: T.TypeMap
typemap_IsGroupMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsGroupMember_result :: IsGroupMember_result
default_IsGroupMember_result = IsGroupMember_result{
  isGroupMember_result_success = P.False,
  isGroupMember_result_e = P.Nothing}
data GetPhoneInfoFromPhoneNumber_args = GetPhoneInfoFromPhoneNumber_args  { getPhoneInfoFromPhoneNumber_args_region :: LT.Text
  , getPhoneInfoFromPhoneNumber_args_phoneNumber :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPhoneInfoFromPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_args_region record   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_args_phoneNumber record  
instance QC.Arbitrary GetPhoneInfoFromPhoneNumber_args where 
  arbitrary = M.liftM GetPhoneInfoFromPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPhoneInfoFromPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_region = getPhoneInfoFromPhoneNumber_args_region obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_region = getPhoneInfoFromPhoneNumber_args_region obj}
    , if obj == default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_phoneNumber = getPhoneInfoFromPhoneNumber_args_phoneNumber obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_phoneNumber = getPhoneInfoFromPhoneNumber_args_phoneNumber obj}
    ]
from_GetPhoneInfoFromPhoneNumber_args :: GetPhoneInfoFromPhoneNumber_args -> T.ThriftVal
from_GetPhoneInfoFromPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10224 -> P.Just (1, ("region",T.TString $ E.encodeUtf8 _v10224))) $ getPhoneInfoFromPhoneNumber_args_region record
  , (\_v10224 -> P.Just (2, ("phoneNumber",T.TString $ E.encodeUtf8 _v10224))) $ getPhoneInfoFromPhoneNumber_args_phoneNumber record
  ]
write_GetPhoneInfoFromPhoneNumber_args :: T.Protocol p => p -> GetPhoneInfoFromPhoneNumber_args -> P.IO ()
write_GetPhoneInfoFromPhoneNumber_args oprot record = T.writeVal oprot $ from_GetPhoneInfoFromPhoneNumber_args record
encode_GetPhoneInfoFromPhoneNumber_args :: T.StatelessProtocol p => p -> GetPhoneInfoFromPhoneNumber_args -> LBS.ByteString
encode_GetPhoneInfoFromPhoneNumber_args oprot record = T.serializeVal oprot $ from_GetPhoneInfoFromPhoneNumber_args record
to_GetPhoneInfoFromPhoneNumber_args :: T.ThriftVal -> GetPhoneInfoFromPhoneNumber_args
to_GetPhoneInfoFromPhoneNumber_args (T.TStruct fields) = GetPhoneInfoFromPhoneNumber_args{
  getPhoneInfoFromPhoneNumber_args_region = P.maybe (getPhoneInfoFromPhoneNumber_args_region default_GetPhoneInfoFromPhoneNumber_args) (\(_,_val10226) -> (case _val10226 of {T.TString _val10227 -> E.decodeUtf8 _val10227; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getPhoneInfoFromPhoneNumber_args_phoneNumber = P.maybe (getPhoneInfoFromPhoneNumber_args_phoneNumber default_GetPhoneInfoFromPhoneNumber_args) (\(_,_val10226) -> (case _val10226 of {T.TString _val10228 -> E.decodeUtf8 _val10228; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPhoneInfoFromPhoneNumber_args _ = P.error "not a struct"
read_GetPhoneInfoFromPhoneNumber_args :: T.Protocol p => p -> P.IO GetPhoneInfoFromPhoneNumber_args
read_GetPhoneInfoFromPhoneNumber_args iprot = to_GetPhoneInfoFromPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_args)
decode_GetPhoneInfoFromPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPhoneInfoFromPhoneNumber_args
decode_GetPhoneInfoFromPhoneNumber_args iprot bs = to_GetPhoneInfoFromPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_args) bs
typemap_GetPhoneInfoFromPhoneNumber_args :: T.TypeMap
typemap_GetPhoneInfoFromPhoneNumber_args = Map.fromList [(1,("region",T.T_STRING)),(2,("phoneNumber",T.T_STRING))]
default_GetPhoneInfoFromPhoneNumber_args :: GetPhoneInfoFromPhoneNumber_args
default_GetPhoneInfoFromPhoneNumber_args = GetPhoneInfoFromPhoneNumber_args{
  getPhoneInfoFromPhoneNumber_args_region = "",
  getPhoneInfoFromPhoneNumber_args_phoneNumber = ""}
data GetPhoneInfoFromPhoneNumber_result = GetPhoneInfoFromPhoneNumber_result  { getPhoneInfoFromPhoneNumber_result_success :: PhoneInfoForChannel
  , getPhoneInfoFromPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPhoneInfoFromPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_result_success record   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_result_e record  
instance QC.Arbitrary GetPhoneInfoFromPhoneNumber_result where 
  arbitrary = M.liftM GetPhoneInfoFromPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPhoneInfoFromPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = getPhoneInfoFromPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = getPhoneInfoFromPhoneNumber_result_success obj}
    , if obj == default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = getPhoneInfoFromPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = getPhoneInfoFromPhoneNumber_result_e obj}
    ]
from_GetPhoneInfoFromPhoneNumber_result :: GetPhoneInfoFromPhoneNumber_result -> T.ThriftVal
from_GetPhoneInfoFromPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10231 -> (1, ("e",from_TalkException _v10231))) <$> getPhoneInfoFromPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10231 -> P.Just (0, ("success",from_PhoneInfoForChannel _v10231))) $ getPhoneInfoFromPhoneNumber_result_success record
    , (\_v10231 -> (1, ("e",from_TalkException _v10231))) <$> getPhoneInfoFromPhoneNumber_result_e record
    ]
    )
write_GetPhoneInfoFromPhoneNumber_result :: T.Protocol p => p -> GetPhoneInfoFromPhoneNumber_result -> P.IO ()
write_GetPhoneInfoFromPhoneNumber_result oprot record = T.writeVal oprot $ from_GetPhoneInfoFromPhoneNumber_result record
encode_GetPhoneInfoFromPhoneNumber_result :: T.StatelessProtocol p => p -> GetPhoneInfoFromPhoneNumber_result -> LBS.ByteString
encode_GetPhoneInfoFromPhoneNumber_result oprot record = T.serializeVal oprot $ from_GetPhoneInfoFromPhoneNumber_result record
to_GetPhoneInfoFromPhoneNumber_result :: T.ThriftVal -> GetPhoneInfoFromPhoneNumber_result
to_GetPhoneInfoFromPhoneNumber_result (T.TStruct fields) = GetPhoneInfoFromPhoneNumber_result{
  getPhoneInfoFromPhoneNumber_result_success = P.maybe (getPhoneInfoFromPhoneNumber_result_success default_GetPhoneInfoFromPhoneNumber_result) (\(_,_val10233) -> (case _val10233 of {T.TStruct _val10234 -> (to_PhoneInfoForChannel (T.TStruct _val10234)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPhoneInfoFromPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val10233) -> P.Just (case _val10233 of {T.TStruct _val10235 -> (to_TalkException (T.TStruct _val10235)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPhoneInfoFromPhoneNumber_result _ = P.error "not a struct"
read_GetPhoneInfoFromPhoneNumber_result :: T.Protocol p => p -> P.IO GetPhoneInfoFromPhoneNumber_result
read_GetPhoneInfoFromPhoneNumber_result iprot = to_GetPhoneInfoFromPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_result)
decode_GetPhoneInfoFromPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPhoneInfoFromPhoneNumber_result
decode_GetPhoneInfoFromPhoneNumber_result iprot bs = to_GetPhoneInfoFromPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_result) bs
typemap_GetPhoneInfoFromPhoneNumber_result :: T.TypeMap
typemap_GetPhoneInfoFromPhoneNumber_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PhoneInfoForChannel))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPhoneInfoFromPhoneNumber_result :: GetPhoneInfoFromPhoneNumber_result
default_GetPhoneInfoFromPhoneNumber_result = GetPhoneInfoFromPhoneNumber_result{
  getPhoneInfoFromPhoneNumber_result_success = default_PhoneInfoForChannel,
  getPhoneInfoFromPhoneNumber_result_e = P.Nothing}
data RedeemPaidCallVoucher_args = RedeemPaidCallVoucher_args  { redeemPaidCallVoucher_args_serial :: LT.Text
  , redeemPaidCallVoucher_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RedeemPaidCallVoucher_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` redeemPaidCallVoucher_args_serial record   `H.hashWithSalt` redeemPaidCallVoucher_args_language record  
instance QC.Arbitrary RedeemPaidCallVoucher_args where 
  arbitrary = M.liftM RedeemPaidCallVoucher_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RedeemPaidCallVoucher_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_serial = redeemPaidCallVoucher_args_serial obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_serial = redeemPaidCallVoucher_args_serial obj}
    , if obj == default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_language = redeemPaidCallVoucher_args_language obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_language = redeemPaidCallVoucher_args_language obj}
    ]
from_RedeemPaidCallVoucher_args :: RedeemPaidCallVoucher_args -> T.ThriftVal
from_RedeemPaidCallVoucher_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10238 -> P.Just (2, ("serial",T.TString $ E.encodeUtf8 _v10238))) $ redeemPaidCallVoucher_args_serial record
  , (\_v10238 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v10238))) $ redeemPaidCallVoucher_args_language record
  ]
write_RedeemPaidCallVoucher_args :: T.Protocol p => p -> RedeemPaidCallVoucher_args -> P.IO ()
write_RedeemPaidCallVoucher_args oprot record = T.writeVal oprot $ from_RedeemPaidCallVoucher_args record
encode_RedeemPaidCallVoucher_args :: T.StatelessProtocol p => p -> RedeemPaidCallVoucher_args -> LBS.ByteString
encode_RedeemPaidCallVoucher_args oprot record = T.serializeVal oprot $ from_RedeemPaidCallVoucher_args record
to_RedeemPaidCallVoucher_args :: T.ThriftVal -> RedeemPaidCallVoucher_args
to_RedeemPaidCallVoucher_args (T.TStruct fields) = RedeemPaidCallVoucher_args{
  redeemPaidCallVoucher_args_serial = P.maybe (redeemPaidCallVoucher_args_serial default_RedeemPaidCallVoucher_args) (\(_,_val10240) -> (case _val10240 of {T.TString _val10241 -> E.decodeUtf8 _val10241; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  redeemPaidCallVoucher_args_language = P.maybe (redeemPaidCallVoucher_args_language default_RedeemPaidCallVoucher_args) (\(_,_val10240) -> (case _val10240 of {T.TString _val10242 -> E.decodeUtf8 _val10242; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RedeemPaidCallVoucher_args _ = P.error "not a struct"
read_RedeemPaidCallVoucher_args :: T.Protocol p => p -> P.IO RedeemPaidCallVoucher_args
read_RedeemPaidCallVoucher_args iprot = to_RedeemPaidCallVoucher_args <$> T.readVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_args)
decode_RedeemPaidCallVoucher_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RedeemPaidCallVoucher_args
decode_RedeemPaidCallVoucher_args iprot bs = to_RedeemPaidCallVoucher_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_args) bs
typemap_RedeemPaidCallVoucher_args :: T.TypeMap
typemap_RedeemPaidCallVoucher_args = Map.fromList [(2,("serial",T.T_STRING)),(3,("language",T.T_STRING))]
default_RedeemPaidCallVoucher_args :: RedeemPaidCallVoucher_args
default_RedeemPaidCallVoucher_args = RedeemPaidCallVoucher_args{
  redeemPaidCallVoucher_args_serial = "",
  redeemPaidCallVoucher_args_language = ""}
data RedeemPaidCallVoucher_result = RedeemPaidCallVoucher_result  { redeemPaidCallVoucher_result_success :: PaidCallRedeemResult
  , redeemPaidCallVoucher_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RedeemPaidCallVoucher_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` redeemPaidCallVoucher_result_success record   `H.hashWithSalt` redeemPaidCallVoucher_result_e record  
instance QC.Arbitrary RedeemPaidCallVoucher_result where 
  arbitrary = M.liftM RedeemPaidCallVoucher_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RedeemPaidCallVoucher_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = redeemPaidCallVoucher_result_success obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = redeemPaidCallVoucher_result_success obj}
    , if obj == default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = redeemPaidCallVoucher_result_e obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = redeemPaidCallVoucher_result_e obj}
    ]
from_RedeemPaidCallVoucher_result :: RedeemPaidCallVoucher_result -> T.ThriftVal
from_RedeemPaidCallVoucher_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10245 -> (1, ("e",from_TalkException _v10245))) <$> redeemPaidCallVoucher_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10245 -> P.Just (0, ("success",from_PaidCallRedeemResult _v10245))) $ redeemPaidCallVoucher_result_success record
    , (\_v10245 -> (1, ("e",from_TalkException _v10245))) <$> redeemPaidCallVoucher_result_e record
    ]
    )
write_RedeemPaidCallVoucher_result :: T.Protocol p => p -> RedeemPaidCallVoucher_result -> P.IO ()
write_RedeemPaidCallVoucher_result oprot record = T.writeVal oprot $ from_RedeemPaidCallVoucher_result record
encode_RedeemPaidCallVoucher_result :: T.StatelessProtocol p => p -> RedeemPaidCallVoucher_result -> LBS.ByteString
encode_RedeemPaidCallVoucher_result oprot record = T.serializeVal oprot $ from_RedeemPaidCallVoucher_result record
to_RedeemPaidCallVoucher_result :: T.ThriftVal -> RedeemPaidCallVoucher_result
to_RedeemPaidCallVoucher_result (T.TStruct fields) = RedeemPaidCallVoucher_result{
  redeemPaidCallVoucher_result_success = P.maybe (redeemPaidCallVoucher_result_success default_RedeemPaidCallVoucher_result) (\(_,_val10247) -> (case _val10247 of {T.TStruct _val10248 -> (to_PaidCallRedeemResult (T.TStruct _val10248)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  redeemPaidCallVoucher_result_e = P.maybe (P.Nothing) (\(_,_val10247) -> P.Just (case _val10247 of {T.TStruct _val10249 -> (to_TalkException (T.TStruct _val10249)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RedeemPaidCallVoucher_result _ = P.error "not a struct"
read_RedeemPaidCallVoucher_result :: T.Protocol p => p -> P.IO RedeemPaidCallVoucher_result
read_RedeemPaidCallVoucher_result iprot = to_RedeemPaidCallVoucher_result <$> T.readVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_result)
decode_RedeemPaidCallVoucher_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RedeemPaidCallVoucher_result
decode_RedeemPaidCallVoucher_result iprot bs = to_RedeemPaidCallVoucher_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_result) bs
typemap_RedeemPaidCallVoucher_result :: T.TypeMap
typemap_RedeemPaidCallVoucher_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallRedeemResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RedeemPaidCallVoucher_result :: RedeemPaidCallVoucher_result
default_RedeemPaidCallVoucher_result = RedeemPaidCallVoucher_result{
  redeemPaidCallVoucher_result_success = default_PaidCallRedeemResult,
  redeemPaidCallVoucher_result_e = P.Nothing}
data GetPreferredDisplayName_args = GetPreferredDisplayName_args  { getPreferredDisplayName_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreferredDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreferredDisplayName_args_mids record  
instance QC.Arbitrary GetPreferredDisplayName_args where 
  arbitrary = M.liftM GetPreferredDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetPreferredDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreferredDisplayName_args{getPreferredDisplayName_args_mids = getPreferredDisplayName_args_mids obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_args{getPreferredDisplayName_args_mids = getPreferredDisplayName_args_mids obj}
    ]
from_GetPreferredDisplayName_args :: GetPreferredDisplayName_args -> T.ThriftVal
from_GetPreferredDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10252 -> P.Just (1, ("mids",T.TList T.T_STRING $ P.map (\_v10254 -> T.TString $ E.encodeUtf8 _v10254) $ Vector.toList _v10252))) $ getPreferredDisplayName_args_mids record
  ]
write_GetPreferredDisplayName_args :: T.Protocol p => p -> GetPreferredDisplayName_args -> P.IO ()
write_GetPreferredDisplayName_args oprot record = T.writeVal oprot $ from_GetPreferredDisplayName_args record
encode_GetPreferredDisplayName_args :: T.StatelessProtocol p => p -> GetPreferredDisplayName_args -> LBS.ByteString
encode_GetPreferredDisplayName_args oprot record = T.serializeVal oprot $ from_GetPreferredDisplayName_args record
to_GetPreferredDisplayName_args :: T.ThriftVal -> GetPreferredDisplayName_args
to_GetPreferredDisplayName_args (T.TStruct fields) = GetPreferredDisplayName_args{
  getPreferredDisplayName_args_mids = P.maybe (getPreferredDisplayName_args_mids default_GetPreferredDisplayName_args) (\(_,_val10256) -> (case _val10256 of {T.TList _ _val10257 -> (Vector.fromList $ P.map (\_v10258 -> (case _v10258 of {T.TString _val10259 -> E.decodeUtf8 _val10259; _ -> P.error "wrong type"})) _val10257); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreferredDisplayName_args _ = P.error "not a struct"
read_GetPreferredDisplayName_args :: T.Protocol p => p -> P.IO GetPreferredDisplayName_args
read_GetPreferredDisplayName_args iprot = to_GetPreferredDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_args)
decode_GetPreferredDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreferredDisplayName_args
decode_GetPreferredDisplayName_args iprot bs = to_GetPreferredDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_args) bs
typemap_GetPreferredDisplayName_args :: T.TypeMap
typemap_GetPreferredDisplayName_args = Map.fromList [(1,("mids",(T.T_LIST T.T_STRING)))]
default_GetPreferredDisplayName_args :: GetPreferredDisplayName_args
default_GetPreferredDisplayName_args = GetPreferredDisplayName_args{
  getPreferredDisplayName_args_mids = Vector.empty}
data GetPreferredDisplayName_result = GetPreferredDisplayName_result  { getPreferredDisplayName_result_success :: (Map.HashMap LT.Text LT.Text)
  , getPreferredDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreferredDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreferredDisplayName_result_success record   `H.hashWithSalt` getPreferredDisplayName_result_e record  
instance QC.Arbitrary GetPreferredDisplayName_result where 
  arbitrary = M.liftM GetPreferredDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPreferredDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = getPreferredDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = getPreferredDisplayName_result_success obj}
    , if obj == default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = getPreferredDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = getPreferredDisplayName_result_e obj}
    ]
from_GetPreferredDisplayName_result :: GetPreferredDisplayName_result -> T.ThriftVal
from_GetPreferredDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10262 -> (1, ("e",from_TalkException _v10262))) <$> getPreferredDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10262 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k10263,_v10264) -> (T.TString $ E.encodeUtf8 _k10263, T.TString $ E.encodeUtf8 _v10264)) $ Map.toList _v10262))) $ getPreferredDisplayName_result_success record
    , (\_v10262 -> (1, ("e",from_TalkException _v10262))) <$> getPreferredDisplayName_result_e record
    ]
    )
write_GetPreferredDisplayName_result :: T.Protocol p => p -> GetPreferredDisplayName_result -> P.IO ()
write_GetPreferredDisplayName_result oprot record = T.writeVal oprot $ from_GetPreferredDisplayName_result record
encode_GetPreferredDisplayName_result :: T.StatelessProtocol p => p -> GetPreferredDisplayName_result -> LBS.ByteString
encode_GetPreferredDisplayName_result oprot record = T.serializeVal oprot $ from_GetPreferredDisplayName_result record
to_GetPreferredDisplayName_result :: T.ThriftVal -> GetPreferredDisplayName_result
to_GetPreferredDisplayName_result (T.TStruct fields) = GetPreferredDisplayName_result{
  getPreferredDisplayName_result_success = P.maybe (getPreferredDisplayName_result_success default_GetPreferredDisplayName_result) (\(_,_val10266) -> (case _val10266 of {T.TMap _ _ _val10267 -> (Map.fromList $ P.map (\(_k10269,_v10268) -> ((case _k10269 of {T.TString _val10270 -> E.decodeUtf8 _val10270; _ -> P.error "wrong type"}),(case _v10268 of {T.TString _val10271 -> E.decodeUtf8 _val10271; _ -> P.error "wrong type"}))) _val10267); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPreferredDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val10266) -> P.Just (case _val10266 of {T.TStruct _val10272 -> (to_TalkException (T.TStruct _val10272)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreferredDisplayName_result _ = P.error "not a struct"
read_GetPreferredDisplayName_result :: T.Protocol p => p -> P.IO GetPreferredDisplayName_result
read_GetPreferredDisplayName_result iprot = to_GetPreferredDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_result)
decode_GetPreferredDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreferredDisplayName_result
decode_GetPreferredDisplayName_result iprot bs = to_GetPreferredDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_result) bs
typemap_GetPreferredDisplayName_result :: T.TypeMap
typemap_GetPreferredDisplayName_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPreferredDisplayName_result :: GetPreferredDisplayName_result
default_GetPreferredDisplayName_result = GetPreferredDisplayName_result{
  getPreferredDisplayName_result_success = Map.empty,
  getPreferredDisplayName_result_e = P.Nothing}
data GetContactsForChannel_args = GetContactsForChannel_args  { getContactsForChannel_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_args_ids record  
instance QC.Arbitrary GetContactsForChannel_args where 
  arbitrary = M.liftM GetContactsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj} then P.Nothing else P.Just $ default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj}
    ]
from_GetContactsForChannel_args :: GetContactsForChannel_args -> T.ThriftVal
from_GetContactsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10275 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v10277 -> T.TString $ E.encodeUtf8 _v10277) $ Vector.toList _v10275))) $ getContactsForChannel_args_ids record
  ]
write_GetContactsForChannel_args :: T.Protocol p => p -> GetContactsForChannel_args -> P.IO ()
write_GetContactsForChannel_args oprot record = T.writeVal oprot $ from_GetContactsForChannel_args record
encode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> GetContactsForChannel_args -> LBS.ByteString
encode_GetContactsForChannel_args oprot record = T.serializeVal oprot $ from_GetContactsForChannel_args record
to_GetContactsForChannel_args :: T.ThriftVal -> GetContactsForChannel_args
to_GetContactsForChannel_args (T.TStruct fields) = GetContactsForChannel_args{
  getContactsForChannel_args_ids = P.maybe (getContactsForChannel_args_ids default_GetContactsForChannel_args) (\(_,_val10279) -> (case _val10279 of {T.TList _ _val10280 -> (Vector.fromList $ P.map (\_v10281 -> (case _v10281 of {T.TString _val10282 -> E.decodeUtf8 _val10282; _ -> P.error "wrong type"})) _val10280); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContactsForChannel_args _ = P.error "not a struct"
read_GetContactsForChannel_args :: T.Protocol p => p -> P.IO GetContactsForChannel_args
read_GetContactsForChannel_args iprot = to_GetContactsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args)
decode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_args
decode_GetContactsForChannel_args iprot bs = to_GetContactsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args) bs
typemap_GetContactsForChannel_args :: T.TypeMap
typemap_GetContactsForChannel_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContactsForChannel_args :: GetContactsForChannel_args
default_GetContactsForChannel_args = GetContactsForChannel_args{
  getContactsForChannel_args_ids = Vector.empty}
data GetContactsForChannel_result = GetContactsForChannel_result  { getContactsForChannel_result_success :: (Vector.Vector Contact)
  , getContactsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_result_success record   `H.hashWithSalt` getContactsForChannel_result_e record  
instance QC.Arbitrary GetContactsForChannel_result where 
  arbitrary = M.liftM GetContactsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj}
    , if obj == default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj}
    ]
from_GetContactsForChannel_result :: GetContactsForChannel_result -> T.ThriftVal
from_GetContactsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10285 -> (1, ("e",from_TalkException _v10285))) <$> getContactsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10285 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v10287 -> from_Contact _v10287) $ Vector.toList _v10285))) $ getContactsForChannel_result_success record
    , (\_v10285 -> (1, ("e",from_TalkException _v10285))) <$> getContactsForChannel_result_e record
    ]
    )
write_GetContactsForChannel_result :: T.Protocol p => p -> GetContactsForChannel_result -> P.IO ()
write_GetContactsForChannel_result oprot record = T.writeVal oprot $ from_GetContactsForChannel_result record
encode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> GetContactsForChannel_result -> LBS.ByteString
encode_GetContactsForChannel_result oprot record = T.serializeVal oprot $ from_GetContactsForChannel_result record
to_GetContactsForChannel_result :: T.ThriftVal -> GetContactsForChannel_result
to_GetContactsForChannel_result (T.TStruct fields) = GetContactsForChannel_result{
  getContactsForChannel_result_success = P.maybe (getContactsForChannel_result_success default_GetContactsForChannel_result) (\(_,_val10289) -> (case _val10289 of {T.TList _ _val10290 -> (Vector.fromList $ P.map (\_v10291 -> (case _v10291 of {T.TStruct _val10292 -> (to_Contact (T.TStruct _val10292)); _ -> P.error "wrong type"})) _val10290); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContactsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10289) -> P.Just (case _val10289 of {T.TStruct _val10293 -> (to_TalkException (T.TStruct _val10293)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContactsForChannel_result _ = P.error "not a struct"
read_GetContactsForChannel_result :: T.Protocol p => p -> P.IO GetContactsForChannel_result
read_GetContactsForChannel_result iprot = to_GetContactsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result)
decode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_result
decode_GetContactsForChannel_result iprot bs = to_GetContactsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result) bs
typemap_GetContactsForChannel_result :: T.TypeMap
typemap_GetContactsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContactsForChannel_result :: GetContactsForChannel_result
default_GetContactsForChannel_result = GetContactsForChannel_result{
  getContactsForChannel_result_success = Vector.empty,
  getContactsForChannel_result_e = P.Nothing}
data GetCallCreditProducts_args = GetCallCreditProducts_args  { getCallCreditProducts_args_appStoreCode :: PaymentType
  , getCallCreditProducts_args_pgCode :: PaymentPgType
  , getCallCreditProducts_args_country :: LT.Text
  , getCallCreditProducts_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditProducts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditProducts_args_appStoreCode record   `H.hashWithSalt` getCallCreditProducts_args_pgCode record   `H.hashWithSalt` getCallCreditProducts_args_country record   `H.hashWithSalt` getCallCreditProducts_args_language record  
instance QC.Arbitrary GetCallCreditProducts_args where 
  arbitrary = M.liftM GetCallCreditProducts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetCallCreditProducts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_appStoreCode = getCallCreditProducts_args_appStoreCode obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_appStoreCode = getCallCreditProducts_args_appStoreCode obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_pgCode = getCallCreditProducts_args_pgCode obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_pgCode = getCallCreditProducts_args_pgCode obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_country = getCallCreditProducts_args_country obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_country = getCallCreditProducts_args_country obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_language = getCallCreditProducts_args_language obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_language = getCallCreditProducts_args_language obj}
    ]
from_GetCallCreditProducts_args :: GetCallCreditProducts_args -> T.ThriftVal
from_GetCallCreditProducts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10296 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v10296))) $ getCallCreditProducts_args_appStoreCode record
  , (\_v10296 -> P.Just (3, ("pgCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v10296))) $ getCallCreditProducts_args_pgCode record
  , (\_v10296 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v10296))) $ getCallCreditProducts_args_country record
  , (\_v10296 -> P.Just (5, ("language",T.TString $ E.encodeUtf8 _v10296))) $ getCallCreditProducts_args_language record
  ]
write_GetCallCreditProducts_args :: T.Protocol p => p -> GetCallCreditProducts_args -> P.IO ()
write_GetCallCreditProducts_args oprot record = T.writeVal oprot $ from_GetCallCreditProducts_args record
encode_GetCallCreditProducts_args :: T.StatelessProtocol p => p -> GetCallCreditProducts_args -> LBS.ByteString
encode_GetCallCreditProducts_args oprot record = T.serializeVal oprot $ from_GetCallCreditProducts_args record
to_GetCallCreditProducts_args :: T.ThriftVal -> GetCallCreditProducts_args
to_GetCallCreditProducts_args (T.TStruct fields) = GetCallCreditProducts_args{
  getCallCreditProducts_args_appStoreCode = P.maybe (getCallCreditProducts_args_appStoreCode default_GetCallCreditProducts_args) (\(_,_val10298) -> (case _val10298 of {T.TI32 _val10299 -> P.toEnum $ P.fromIntegral _val10299; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getCallCreditProducts_args_pgCode = P.maybe (getCallCreditProducts_args_pgCode default_GetCallCreditProducts_args) (\(_,_val10298) -> (case _val10298 of {T.TI32 _val10300 -> P.toEnum $ P.fromIntegral _val10300; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getCallCreditProducts_args_country = P.maybe (getCallCreditProducts_args_country default_GetCallCreditProducts_args) (\(_,_val10298) -> (case _val10298 of {T.TString _val10301 -> E.decodeUtf8 _val10301; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getCallCreditProducts_args_language = P.maybe (getCallCreditProducts_args_language default_GetCallCreditProducts_args) (\(_,_val10298) -> (case _val10298 of {T.TString _val10302 -> E.decodeUtf8 _val10302; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetCallCreditProducts_args _ = P.error "not a struct"
read_GetCallCreditProducts_args :: T.Protocol p => p -> P.IO GetCallCreditProducts_args
read_GetCallCreditProducts_args iprot = to_GetCallCreditProducts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_args)
decode_GetCallCreditProducts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditProducts_args
decode_GetCallCreditProducts_args iprot bs = to_GetCallCreditProducts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_args) bs
typemap_GetCallCreditProducts_args :: T.TypeMap
typemap_GetCallCreditProducts_args = Map.fromList [(2,("appStoreCode",T.T_I32)),(3,("pgCode",T.T_I32)),(4,("country",T.T_STRING)),(5,("language",T.T_STRING))]
default_GetCallCreditProducts_args :: GetCallCreditProducts_args
default_GetCallCreditProducts_args = GetCallCreditProducts_args{
  getCallCreditProducts_args_appStoreCode = (P.toEnum 0),
  getCallCreditProducts_args_pgCode = (P.toEnum 0),
  getCallCreditProducts_args_country = "",
  getCallCreditProducts_args_language = ""}
data GetCallCreditProducts_result = GetCallCreditProducts_result  { getCallCreditProducts_result_success :: (Vector.Vector CoinProductItem)
  , getCallCreditProducts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditProducts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditProducts_result_success record   `H.hashWithSalt` getCallCreditProducts_result_e record  
instance QC.Arbitrary GetCallCreditProducts_result where 
  arbitrary = M.liftM GetCallCreditProducts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCallCreditProducts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditProducts_result{getCallCreditProducts_result_success = getCallCreditProducts_result_success obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_result{getCallCreditProducts_result_success = getCallCreditProducts_result_success obj}
    , if obj == default_GetCallCreditProducts_result{getCallCreditProducts_result_e = getCallCreditProducts_result_e obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_result{getCallCreditProducts_result_e = getCallCreditProducts_result_e obj}
    ]
from_GetCallCreditProducts_result :: GetCallCreditProducts_result -> T.ThriftVal
from_GetCallCreditProducts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10305 -> (1, ("e",from_TalkException _v10305))) <$> getCallCreditProducts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10305 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CoinProductItem) $ P.map (\_v10307 -> from_CoinProductItem _v10307) $ Vector.toList _v10305))) $ getCallCreditProducts_result_success record
    , (\_v10305 -> (1, ("e",from_TalkException _v10305))) <$> getCallCreditProducts_result_e record
    ]
    )
write_GetCallCreditProducts_result :: T.Protocol p => p -> GetCallCreditProducts_result -> P.IO ()
write_GetCallCreditProducts_result oprot record = T.writeVal oprot $ from_GetCallCreditProducts_result record
encode_GetCallCreditProducts_result :: T.StatelessProtocol p => p -> GetCallCreditProducts_result -> LBS.ByteString
encode_GetCallCreditProducts_result oprot record = T.serializeVal oprot $ from_GetCallCreditProducts_result record
to_GetCallCreditProducts_result :: T.ThriftVal -> GetCallCreditProducts_result
to_GetCallCreditProducts_result (T.TStruct fields) = GetCallCreditProducts_result{
  getCallCreditProducts_result_success = P.maybe (getCallCreditProducts_result_success default_GetCallCreditProducts_result) (\(_,_val10309) -> (case _val10309 of {T.TList _ _val10310 -> (Vector.fromList $ P.map (\_v10311 -> (case _v10311 of {T.TStruct _val10312 -> (to_CoinProductItem (T.TStruct _val10312)); _ -> P.error "wrong type"})) _val10310); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCallCreditProducts_result_e = P.maybe (P.Nothing) (\(_,_val10309) -> P.Just (case _val10309 of {T.TStruct _val10313 -> (to_TalkException (T.TStruct _val10313)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCallCreditProducts_result _ = P.error "not a struct"
read_GetCallCreditProducts_result :: T.Protocol p => p -> P.IO GetCallCreditProducts_result
read_GetCallCreditProducts_result iprot = to_GetCallCreditProducts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_result)
decode_GetCallCreditProducts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditProducts_result
decode_GetCallCreditProducts_result iprot bs = to_GetCallCreditProducts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_result) bs
typemap_GetCallCreditProducts_result :: T.TypeMap
typemap_GetCallCreditProducts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CoinProductItem)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCallCreditProducts_result :: GetCallCreditProducts_result
default_GetCallCreditProducts_result = GetCallCreditProducts_result{
  getCallCreditProducts_result_success = Vector.empty,
  getCallCreditProducts_result_e = P.Nothing}
data GetCompactContacts_args = GetCompactContacts_args  { getCompactContacts_args_lastModifiedTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_args_lastModifiedTimestamp record  
instance QC.Arbitrary GetCompactContacts_args where 
  arbitrary = M.liftM GetCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj} then P.Nothing else P.Just $ default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj}
    ]
from_GetCompactContacts_args :: GetCompactContacts_args -> T.ThriftVal
from_GetCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10316 -> P.Just (2, ("lastModifiedTimestamp",T.TI64 _v10316))) $ getCompactContacts_args_lastModifiedTimestamp record
  ]
write_GetCompactContacts_args :: T.Protocol p => p -> GetCompactContacts_args -> P.IO ()
write_GetCompactContacts_args oprot record = T.writeVal oprot $ from_GetCompactContacts_args record
encode_GetCompactContacts_args :: T.StatelessProtocol p => p -> GetCompactContacts_args -> LBS.ByteString
encode_GetCompactContacts_args oprot record = T.serializeVal oprot $ from_GetCompactContacts_args record
to_GetCompactContacts_args :: T.ThriftVal -> GetCompactContacts_args
to_GetCompactContacts_args (T.TStruct fields) = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = P.maybe (getCompactContacts_args_lastModifiedTimestamp default_GetCompactContacts_args) (\(_,_val10318) -> (case _val10318 of {T.TI64 _val10319 -> _val10319; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContacts_args _ = P.error "not a struct"
read_GetCompactContacts_args :: T.Protocol p => p -> P.IO GetCompactContacts_args
read_GetCompactContacts_args iprot = to_GetCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_args)
decode_GetCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_args
decode_GetCompactContacts_args iprot bs = to_GetCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_args) bs
typemap_GetCompactContacts_args :: T.TypeMap
typemap_GetCompactContacts_args = Map.fromList [(2,("lastModifiedTimestamp",T.T_I64))]
default_GetCompactContacts_args :: GetCompactContacts_args
default_GetCompactContacts_args = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = 0}
data GetCompactContacts_result = GetCompactContacts_result  { getCompactContacts_result_success :: (Vector.Vector CompactContact)
  , getCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_result_success record   `H.hashWithSalt` getCompactContacts_result_e record  
instance QC.Arbitrary GetCompactContacts_result where 
  arbitrary = M.liftM GetCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj}
    , if obj == default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj}
    ]
from_GetCompactContacts_result :: GetCompactContacts_result -> T.ThriftVal
from_GetCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10322 -> (1, ("e",from_TalkException _v10322))) <$> getCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10322 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v10324 -> from_CompactContact _v10324) $ Vector.toList _v10322))) $ getCompactContacts_result_success record
    , (\_v10322 -> (1, ("e",from_TalkException _v10322))) <$> getCompactContacts_result_e record
    ]
    )
write_GetCompactContacts_result :: T.Protocol p => p -> GetCompactContacts_result -> P.IO ()
write_GetCompactContacts_result oprot record = T.writeVal oprot $ from_GetCompactContacts_result record
encode_GetCompactContacts_result :: T.StatelessProtocol p => p -> GetCompactContacts_result -> LBS.ByteString
encode_GetCompactContacts_result oprot record = T.serializeVal oprot $ from_GetCompactContacts_result record
to_GetCompactContacts_result :: T.ThriftVal -> GetCompactContacts_result
to_GetCompactContacts_result (T.TStruct fields) = GetCompactContacts_result{
  getCompactContacts_result_success = P.maybe (getCompactContacts_result_success default_GetCompactContacts_result) (\(_,_val10326) -> (case _val10326 of {T.TList _ _val10327 -> (Vector.fromList $ P.map (\_v10328 -> (case _v10328 of {T.TStruct _val10329 -> (to_CompactContact (T.TStruct _val10329)); _ -> P.error "wrong type"})) _val10327); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val10326) -> P.Just (case _val10326 of {T.TStruct _val10330 -> (to_TalkException (T.TStruct _val10330)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContacts_result _ = P.error "not a struct"
read_GetCompactContacts_result :: T.Protocol p => p -> P.IO GetCompactContacts_result
read_GetCompactContacts_result iprot = to_GetCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_result)
decode_GetCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_result
decode_GetCompactContacts_result iprot bs = to_GetCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_result) bs
typemap_GetCompactContacts_result :: T.TypeMap
typemap_GetCompactContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContacts_result :: GetCompactContacts_result
default_GetCompactContacts_result = GetCompactContacts_result{
  getCompactContacts_result_success = Vector.empty,
  getCompactContacts_result_e = P.Nothing}
data NotifyNotiCenterEvent_args = NotifyNotiCenterEvent_args  { notifyNotiCenterEvent_args_event :: NotiCenterEventData
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyNotiCenterEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyNotiCenterEvent_args_event record  
instance QC.Arbitrary NotifyNotiCenterEvent_args where 
  arbitrary = M.liftM NotifyNotiCenterEvent_args (QC.arbitrary)
  shrink obj | obj == default_NotifyNotiCenterEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyNotiCenterEvent_args{notifyNotiCenterEvent_args_event = notifyNotiCenterEvent_args_event obj} then P.Nothing else P.Just $ default_NotifyNotiCenterEvent_args{notifyNotiCenterEvent_args_event = notifyNotiCenterEvent_args_event obj}
    ]
from_NotifyNotiCenterEvent_args :: NotifyNotiCenterEvent_args -> T.ThriftVal
from_NotifyNotiCenterEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10333 -> P.Just (1, ("event",from_NotiCenterEventData _v10333))) $ notifyNotiCenterEvent_args_event record
  ]
write_NotifyNotiCenterEvent_args :: T.Protocol p => p -> NotifyNotiCenterEvent_args -> P.IO ()
write_NotifyNotiCenterEvent_args oprot record = T.writeVal oprot $ from_NotifyNotiCenterEvent_args record
encode_NotifyNotiCenterEvent_args :: T.StatelessProtocol p => p -> NotifyNotiCenterEvent_args -> LBS.ByteString
encode_NotifyNotiCenterEvent_args oprot record = T.serializeVal oprot $ from_NotifyNotiCenterEvent_args record
to_NotifyNotiCenterEvent_args :: T.ThriftVal -> NotifyNotiCenterEvent_args
to_NotifyNotiCenterEvent_args (T.TStruct fields) = NotifyNotiCenterEvent_args{
  notifyNotiCenterEvent_args_event = P.maybe (notifyNotiCenterEvent_args_event default_NotifyNotiCenterEvent_args) (\(_,_val10335) -> (case _val10335 of {T.TStruct _val10336 -> (to_NotiCenterEventData (T.TStruct _val10336)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyNotiCenterEvent_args _ = P.error "not a struct"
read_NotifyNotiCenterEvent_args :: T.Protocol p => p -> P.IO NotifyNotiCenterEvent_args
read_NotifyNotiCenterEvent_args iprot = to_NotifyNotiCenterEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_args)
decode_NotifyNotiCenterEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyNotiCenterEvent_args
decode_NotifyNotiCenterEvent_args iprot bs = to_NotifyNotiCenterEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_args) bs
typemap_NotifyNotiCenterEvent_args :: T.TypeMap
typemap_NotifyNotiCenterEvent_args = Map.fromList [(1,("event",(T.T_STRUCT typemap_NotiCenterEventData)))]
default_NotifyNotiCenterEvent_args :: NotifyNotiCenterEvent_args
default_NotifyNotiCenterEvent_args = NotifyNotiCenterEvent_args{
  notifyNotiCenterEvent_args_event = default_NotiCenterEventData}
data NotifyNotiCenterEvent_result = NotifyNotiCenterEvent_result  { notifyNotiCenterEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyNotiCenterEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyNotiCenterEvent_result_e record  
instance QC.Arbitrary NotifyNotiCenterEvent_result where 
  arbitrary = M.liftM NotifyNotiCenterEvent_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyNotiCenterEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = notifyNotiCenterEvent_result_e obj} then P.Nothing else P.Just $ default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = notifyNotiCenterEvent_result_e obj}
    ]
from_NotifyNotiCenterEvent_result :: NotifyNotiCenterEvent_result -> T.ThriftVal
from_NotifyNotiCenterEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10339 -> (1, ("e",from_TalkException _v10339))) <$> notifyNotiCenterEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10339 -> (1, ("e",from_TalkException _v10339))) <$> notifyNotiCenterEvent_result_e record
    ]
    )
write_NotifyNotiCenterEvent_result :: T.Protocol p => p -> NotifyNotiCenterEvent_result -> P.IO ()
write_NotifyNotiCenterEvent_result oprot record = T.writeVal oprot $ from_NotifyNotiCenterEvent_result record
encode_NotifyNotiCenterEvent_result :: T.StatelessProtocol p => p -> NotifyNotiCenterEvent_result -> LBS.ByteString
encode_NotifyNotiCenterEvent_result oprot record = T.serializeVal oprot $ from_NotifyNotiCenterEvent_result record
to_NotifyNotiCenterEvent_result :: T.ThriftVal -> NotifyNotiCenterEvent_result
to_NotifyNotiCenterEvent_result (T.TStruct fields) = NotifyNotiCenterEvent_result{
  notifyNotiCenterEvent_result_e = P.maybe (P.Nothing) (\(_,_val10341) -> P.Just (case _val10341 of {T.TStruct _val10342 -> (to_TalkException (T.TStruct _val10342)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyNotiCenterEvent_result _ = P.error "not a struct"
read_NotifyNotiCenterEvent_result :: T.Protocol p => p -> P.IO NotifyNotiCenterEvent_result
read_NotifyNotiCenterEvent_result iprot = to_NotifyNotiCenterEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_result)
decode_NotifyNotiCenterEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyNotiCenterEvent_result
decode_NotifyNotiCenterEvent_result iprot bs = to_NotifyNotiCenterEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_result) bs
typemap_NotifyNotiCenterEvent_result :: T.TypeMap
typemap_NotifyNotiCenterEvent_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyNotiCenterEvent_result :: NotifyNotiCenterEvent_result
default_NotifyNotiCenterEvent_result = NotifyNotiCenterEvent_result{
  notifyNotiCenterEvent_result_e = P.Nothing}
data IsInContact_args = IsInContact_args  { isInContact_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_args_mid record  
instance QC.Arbitrary IsInContact_args where 
  arbitrary = M.liftM IsInContact_args (QC.arbitrary)
  shrink obj | obj == default_IsInContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj} then P.Nothing else P.Just $ default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj}
    ]
from_IsInContact_args :: IsInContact_args -> T.ThriftVal
from_IsInContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10345 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v10345))) $ isInContact_args_mid record
  ]
write_IsInContact_args :: T.Protocol p => p -> IsInContact_args -> P.IO ()
write_IsInContact_args oprot record = T.writeVal oprot $ from_IsInContact_args record
encode_IsInContact_args :: T.StatelessProtocol p => p -> IsInContact_args -> LBS.ByteString
encode_IsInContact_args oprot record = T.serializeVal oprot $ from_IsInContact_args record
to_IsInContact_args :: T.ThriftVal -> IsInContact_args
to_IsInContact_args (T.TStruct fields) = IsInContact_args{
  isInContact_args_mid = P.maybe (isInContact_args_mid default_IsInContact_args) (\(_,_val10347) -> (case _val10347 of {T.TString _val10348 -> E.decodeUtf8 _val10348; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsInContact_args _ = P.error "not a struct"
read_IsInContact_args :: T.Protocol p => p -> P.IO IsInContact_args
read_IsInContact_args iprot = to_IsInContact_args <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_args)
decode_IsInContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_args
decode_IsInContact_args iprot bs = to_IsInContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_args) bs
typemap_IsInContact_args :: T.TypeMap
typemap_IsInContact_args = Map.fromList [(2,("mid",T.T_STRING))]
default_IsInContact_args :: IsInContact_args
default_IsInContact_args = IsInContact_args{
  isInContact_args_mid = ""}
data IsInContact_result = IsInContact_result  { isInContact_result_success :: P.Bool
  , isInContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_result_success record   `H.hashWithSalt` isInContact_result_e record  
instance QC.Arbitrary IsInContact_result where 
  arbitrary = M.liftM IsInContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsInContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_result{isInContact_result_success = isInContact_result_success obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_success = isInContact_result_success obj}
    , if obj == default_IsInContact_result{isInContact_result_e = isInContact_result_e obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_e = isInContact_result_e obj}
    ]
from_IsInContact_result :: IsInContact_result -> T.ThriftVal
from_IsInContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10351 -> (1, ("e",from_TalkException _v10351))) <$> isInContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10351 -> P.Just (0, ("success",T.TBool _v10351))) $ isInContact_result_success record
    , (\_v10351 -> (1, ("e",from_TalkException _v10351))) <$> isInContact_result_e record
    ]
    )
write_IsInContact_result :: T.Protocol p => p -> IsInContact_result -> P.IO ()
write_IsInContact_result oprot record = T.writeVal oprot $ from_IsInContact_result record
encode_IsInContact_result :: T.StatelessProtocol p => p -> IsInContact_result -> LBS.ByteString
encode_IsInContact_result oprot record = T.serializeVal oprot $ from_IsInContact_result record
to_IsInContact_result :: T.ThriftVal -> IsInContact_result
to_IsInContact_result (T.TStruct fields) = IsInContact_result{
  isInContact_result_success = P.maybe (isInContact_result_success default_IsInContact_result) (\(_,_val10353) -> (case _val10353 of {T.TBool _val10354 -> _val10354; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isInContact_result_e = P.maybe (P.Nothing) (\(_,_val10353) -> P.Just (case _val10353 of {T.TStruct _val10355 -> (to_TalkException (T.TStruct _val10355)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsInContact_result _ = P.error "not a struct"
read_IsInContact_result :: T.Protocol p => p -> P.IO IsInContact_result
read_IsInContact_result iprot = to_IsInContact_result <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_result)
decode_IsInContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_result
decode_IsInContact_result iprot bs = to_IsInContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_result) bs
typemap_IsInContact_result :: T.TypeMap
typemap_IsInContact_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsInContact_result :: IsInContact_result
default_IsInContact_result = IsInContact_result{
  isInContact_result_success = P.False,
  isInContact_result_e = P.Nothing}
data LookupGroupMembers_args = LookupGroupMembers_args  { lookupGroupMembers_args_groupId :: LT.Text
  , lookupGroupMembers_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupGroupMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupGroupMembers_args_groupId record   `H.hashWithSalt` lookupGroupMembers_args_mids record  
instance QC.Arbitrary LookupGroupMembers_args where 
  arbitrary = M.liftM LookupGroupMembers_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupGroupMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupGroupMembers_args{lookupGroupMembers_args_groupId = lookupGroupMembers_args_groupId obj} then P.Nothing else P.Just $ default_LookupGroupMembers_args{lookupGroupMembers_args_groupId = lookupGroupMembers_args_groupId obj}
    , if obj == default_LookupGroupMembers_args{lookupGroupMembers_args_mids = lookupGroupMembers_args_mids obj} then P.Nothing else P.Just $ default_LookupGroupMembers_args{lookupGroupMembers_args_mids = lookupGroupMembers_args_mids obj}
    ]
from_LookupGroupMembers_args :: LookupGroupMembers_args -> T.ThriftVal
from_LookupGroupMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10358 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10358))) $ lookupGroupMembers_args_groupId record
  , (\_v10358 -> P.Just (2, ("mids",T.TList T.T_STRING $ P.map (\_v10360 -> T.TString $ E.encodeUtf8 _v10360) $ Vector.toList _v10358))) $ lookupGroupMembers_args_mids record
  ]
write_LookupGroupMembers_args :: T.Protocol p => p -> LookupGroupMembers_args -> P.IO ()
write_LookupGroupMembers_args oprot record = T.writeVal oprot $ from_LookupGroupMembers_args record
encode_LookupGroupMembers_args :: T.StatelessProtocol p => p -> LookupGroupMembers_args -> LBS.ByteString
encode_LookupGroupMembers_args oprot record = T.serializeVal oprot $ from_LookupGroupMembers_args record
to_LookupGroupMembers_args :: T.ThriftVal -> LookupGroupMembers_args
to_LookupGroupMembers_args (T.TStruct fields) = LookupGroupMembers_args{
  lookupGroupMembers_args_groupId = P.maybe (lookupGroupMembers_args_groupId default_LookupGroupMembers_args) (\(_,_val10362) -> (case _val10362 of {T.TString _val10363 -> E.decodeUtf8 _val10363; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lookupGroupMembers_args_mids = P.maybe (lookupGroupMembers_args_mids default_LookupGroupMembers_args) (\(_,_val10362) -> (case _val10362 of {T.TList _ _val10364 -> (Vector.fromList $ P.map (\_v10365 -> (case _v10365 of {T.TString _val10366 -> E.decodeUtf8 _val10366; _ -> P.error "wrong type"})) _val10364); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LookupGroupMembers_args _ = P.error "not a struct"
read_LookupGroupMembers_args :: T.Protocol p => p -> P.IO LookupGroupMembers_args
read_LookupGroupMembers_args iprot = to_LookupGroupMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupGroupMembers_args)
decode_LookupGroupMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupGroupMembers_args
decode_LookupGroupMembers_args iprot bs = to_LookupGroupMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupGroupMembers_args) bs
typemap_LookupGroupMembers_args :: T.TypeMap
typemap_LookupGroupMembers_args = Map.fromList [(1,("groupId",T.T_STRING)),(2,("mids",(T.T_LIST T.T_STRING)))]
default_LookupGroupMembers_args :: LookupGroupMembers_args
default_LookupGroupMembers_args = LookupGroupMembers_args{
  lookupGroupMembers_args_groupId = "",
  lookupGroupMembers_args_mids = Vector.empty}
data LookupGroupMembers_result = LookupGroupMembers_result  { lookupGroupMembers_result_success :: (Vector.Vector SimpleChannelContact)
  , lookupGroupMembers_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupGroupMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupGroupMembers_result_success record   `H.hashWithSalt` lookupGroupMembers_result_e record  
instance QC.Arbitrary LookupGroupMembers_result where 
  arbitrary = M.liftM LookupGroupMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupGroupMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupGroupMembers_result{lookupGroupMembers_result_success = lookupGroupMembers_result_success obj} then P.Nothing else P.Just $ default_LookupGroupMembers_result{lookupGroupMembers_result_success = lookupGroupMembers_result_success obj}
    , if obj == default_LookupGroupMembers_result{lookupGroupMembers_result_e = lookupGroupMembers_result_e obj} then P.Nothing else P.Just $ default_LookupGroupMembers_result{lookupGroupMembers_result_e = lookupGroupMembers_result_e obj}
    ]
from_LookupGroupMembers_result :: LookupGroupMembers_result -> T.ThriftVal
from_LookupGroupMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10369 -> (1, ("e",from_TalkException _v10369))) <$> lookupGroupMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10369 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v10371 -> from_SimpleChannelContact _v10371) $ Vector.toList _v10369))) $ lookupGroupMembers_result_success record
    , (\_v10369 -> (1, ("e",from_TalkException _v10369))) <$> lookupGroupMembers_result_e record
    ]
    )
write_LookupGroupMembers_result :: T.Protocol p => p -> LookupGroupMembers_result -> P.IO ()
write_LookupGroupMembers_result oprot record = T.writeVal oprot $ from_LookupGroupMembers_result record
encode_LookupGroupMembers_result :: T.StatelessProtocol p => p -> LookupGroupMembers_result -> LBS.ByteString
encode_LookupGroupMembers_result oprot record = T.serializeVal oprot $ from_LookupGroupMembers_result record
to_LookupGroupMembers_result :: T.ThriftVal -> LookupGroupMembers_result
to_LookupGroupMembers_result (T.TStruct fields) = LookupGroupMembers_result{
  lookupGroupMembers_result_success = P.maybe (lookupGroupMembers_result_success default_LookupGroupMembers_result) (\(_,_val10373) -> (case _val10373 of {T.TList _ _val10374 -> (Vector.fromList $ P.map (\_v10375 -> (case _v10375 of {T.TStruct _val10376 -> (to_SimpleChannelContact (T.TStruct _val10376)); _ -> P.error "wrong type"})) _val10374); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupGroupMembers_result_e = P.maybe (P.Nothing) (\(_,_val10373) -> P.Just (case _val10373 of {T.TStruct _val10377 -> (to_TalkException (T.TStruct _val10377)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupGroupMembers_result _ = P.error "not a struct"
read_LookupGroupMembers_result :: T.Protocol p => p -> P.IO LookupGroupMembers_result
read_LookupGroupMembers_result iprot = to_LookupGroupMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupGroupMembers_result)
decode_LookupGroupMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupGroupMembers_result
decode_LookupGroupMembers_result iprot bs = to_LookupGroupMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupGroupMembers_result) bs
typemap_LookupGroupMembers_result :: T.TypeMap
typemap_LookupGroupMembers_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupGroupMembers_result :: LookupGroupMembers_result
default_LookupGroupMembers_result = LookupGroupMembers_result{
  lookupGroupMembers_result_success = Vector.empty,
  lookupGroupMembers_result_e = P.Nothing}
data GetRoomInformation_args = GetRoomInformation_args  { getRoomInformation_args_roomMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomInformation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomInformation_args_roomMid record  
instance QC.Arbitrary GetRoomInformation_args where 
  arbitrary = M.liftM GetRoomInformation_args (QC.arbitrary)
  shrink obj | obj == default_GetRoomInformation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomInformation_args{getRoomInformation_args_roomMid = getRoomInformation_args_roomMid obj} then P.Nothing else P.Just $ default_GetRoomInformation_args{getRoomInformation_args_roomMid = getRoomInformation_args_roomMid obj}
    ]
from_GetRoomInformation_args :: GetRoomInformation_args -> T.ThriftVal
from_GetRoomInformation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10380 -> P.Just (1, ("roomMid",T.TString $ E.encodeUtf8 _v10380))) $ getRoomInformation_args_roomMid record
  ]
write_GetRoomInformation_args :: T.Protocol p => p -> GetRoomInformation_args -> P.IO ()
write_GetRoomInformation_args oprot record = T.writeVal oprot $ from_GetRoomInformation_args record
encode_GetRoomInformation_args :: T.StatelessProtocol p => p -> GetRoomInformation_args -> LBS.ByteString
encode_GetRoomInformation_args oprot record = T.serializeVal oprot $ from_GetRoomInformation_args record
to_GetRoomInformation_args :: T.ThriftVal -> GetRoomInformation_args
to_GetRoomInformation_args (T.TStruct fields) = GetRoomInformation_args{
  getRoomInformation_args_roomMid = P.maybe (getRoomInformation_args_roomMid default_GetRoomInformation_args) (\(_,_val10382) -> (case _val10382 of {T.TString _val10383 -> E.decodeUtf8 _val10383; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomInformation_args _ = P.error "not a struct"
read_GetRoomInformation_args :: T.Protocol p => p -> P.IO GetRoomInformation_args
read_GetRoomInformation_args iprot = to_GetRoomInformation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomInformation_args)
decode_GetRoomInformation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomInformation_args
decode_GetRoomInformation_args iprot bs = to_GetRoomInformation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomInformation_args) bs
typemap_GetRoomInformation_args :: T.TypeMap
typemap_GetRoomInformation_args = Map.fromList [(1,("roomMid",T.T_STRING))]
default_GetRoomInformation_args :: GetRoomInformation_args
default_GetRoomInformation_args = GetRoomInformation_args{
  getRoomInformation_args_roomMid = ""}
data GetRoomInformation_result = GetRoomInformation_result  { getRoomInformation_result_success :: Room
  , getRoomInformation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomInformation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomInformation_result_success record   `H.hashWithSalt` getRoomInformation_result_e record  
instance QC.Arbitrary GetRoomInformation_result where 
  arbitrary = M.liftM GetRoomInformation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoomInformation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomInformation_result{getRoomInformation_result_success = getRoomInformation_result_success obj} then P.Nothing else P.Just $ default_GetRoomInformation_result{getRoomInformation_result_success = getRoomInformation_result_success obj}
    , if obj == default_GetRoomInformation_result{getRoomInformation_result_e = getRoomInformation_result_e obj} then P.Nothing else P.Just $ default_GetRoomInformation_result{getRoomInformation_result_e = getRoomInformation_result_e obj}
    ]
from_GetRoomInformation_result :: GetRoomInformation_result -> T.ThriftVal
from_GetRoomInformation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10386 -> (1, ("e",from_TalkException _v10386))) <$> getRoomInformation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10386 -> P.Just (0, ("success",from_Room _v10386))) $ getRoomInformation_result_success record
    , (\_v10386 -> (1, ("e",from_TalkException _v10386))) <$> getRoomInformation_result_e record
    ]
    )
write_GetRoomInformation_result :: T.Protocol p => p -> GetRoomInformation_result -> P.IO ()
write_GetRoomInformation_result oprot record = T.writeVal oprot $ from_GetRoomInformation_result record
encode_GetRoomInformation_result :: T.StatelessProtocol p => p -> GetRoomInformation_result -> LBS.ByteString
encode_GetRoomInformation_result oprot record = T.serializeVal oprot $ from_GetRoomInformation_result record
to_GetRoomInformation_result :: T.ThriftVal -> GetRoomInformation_result
to_GetRoomInformation_result (T.TStruct fields) = GetRoomInformation_result{
  getRoomInformation_result_success = P.maybe (getRoomInformation_result_success default_GetRoomInformation_result) (\(_,_val10388) -> (case _val10388 of {T.TStruct _val10389 -> (to_Room (T.TStruct _val10389)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoomInformation_result_e = P.maybe (P.Nothing) (\(_,_val10388) -> P.Just (case _val10388 of {T.TStruct _val10390 -> (to_TalkException (T.TStruct _val10390)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomInformation_result _ = P.error "not a struct"
read_GetRoomInformation_result :: T.Protocol p => p -> P.IO GetRoomInformation_result
read_GetRoomInformation_result iprot = to_GetRoomInformation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomInformation_result)
decode_GetRoomInformation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomInformation_result
decode_GetRoomInformation_result iprot bs = to_GetRoomInformation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomInformation_result) bs
typemap_GetRoomInformation_result :: T.TypeMap
typemap_GetRoomInformation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoomInformation_result :: GetRoomInformation_result
default_GetRoomInformation_result = GetRoomInformation_result{
  getRoomInformation_result_success = default_Room,
  getRoomInformation_result_e = P.Nothing}
data GetGroupCall_args = GetGroupCall_args  { getGroupCall_args_chatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupCall_args_chatMid record  
instance QC.Arbitrary GetGroupCall_args where 
  arbitrary = M.liftM GetGroupCall_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupCall_args{getGroupCall_args_chatMid = getGroupCall_args_chatMid obj} then P.Nothing else P.Just $ default_GetGroupCall_args{getGroupCall_args_chatMid = getGroupCall_args_chatMid obj}
    ]
from_GetGroupCall_args :: GetGroupCall_args -> T.ThriftVal
from_GetGroupCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10393 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v10393))) $ getGroupCall_args_chatMid record
  ]
write_GetGroupCall_args :: T.Protocol p => p -> GetGroupCall_args -> P.IO ()
write_GetGroupCall_args oprot record = T.writeVal oprot $ from_GetGroupCall_args record
encode_GetGroupCall_args :: T.StatelessProtocol p => p -> GetGroupCall_args -> LBS.ByteString
encode_GetGroupCall_args oprot record = T.serializeVal oprot $ from_GetGroupCall_args record
to_GetGroupCall_args :: T.ThriftVal -> GetGroupCall_args
to_GetGroupCall_args (T.TStruct fields) = GetGroupCall_args{
  getGroupCall_args_chatMid = P.maybe (getGroupCall_args_chatMid default_GetGroupCall_args) (\(_,_val10395) -> (case _val10395 of {T.TString _val10396 -> E.decodeUtf8 _val10396; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroupCall_args _ = P.error "not a struct"
read_GetGroupCall_args :: T.Protocol p => p -> P.IO GetGroupCall_args
read_GetGroupCall_args iprot = to_GetGroupCall_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupCall_args)
decode_GetGroupCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupCall_args
decode_GetGroupCall_args iprot bs = to_GetGroupCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupCall_args) bs
typemap_GetGroupCall_args :: T.TypeMap
typemap_GetGroupCall_args = Map.fromList [(2,("chatMid",T.T_STRING))]
default_GetGroupCall_args :: GetGroupCall_args
default_GetGroupCall_args = GetGroupCall_args{
  getGroupCall_args_chatMid = ""}
data GetGroupCall_result = GetGroupCall_result  { getGroupCall_result_success :: GroupCall
  , getGroupCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupCall_result_success record   `H.hashWithSalt` getGroupCall_result_e record  
instance QC.Arbitrary GetGroupCall_result where 
  arbitrary = M.liftM GetGroupCall_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupCall_result{getGroupCall_result_success = getGroupCall_result_success obj} then P.Nothing else P.Just $ default_GetGroupCall_result{getGroupCall_result_success = getGroupCall_result_success obj}
    , if obj == default_GetGroupCall_result{getGroupCall_result_e = getGroupCall_result_e obj} then P.Nothing else P.Just $ default_GetGroupCall_result{getGroupCall_result_e = getGroupCall_result_e obj}
    ]
from_GetGroupCall_result :: GetGroupCall_result -> T.ThriftVal
from_GetGroupCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10399 -> (1, ("e",from_TalkException _v10399))) <$> getGroupCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10399 -> P.Just (0, ("success",from_GroupCall _v10399))) $ getGroupCall_result_success record
    , (\_v10399 -> (1, ("e",from_TalkException _v10399))) <$> getGroupCall_result_e record
    ]
    )
write_GetGroupCall_result :: T.Protocol p => p -> GetGroupCall_result -> P.IO ()
write_GetGroupCall_result oprot record = T.writeVal oprot $ from_GetGroupCall_result record
encode_GetGroupCall_result :: T.StatelessProtocol p => p -> GetGroupCall_result -> LBS.ByteString
encode_GetGroupCall_result oprot record = T.serializeVal oprot $ from_GetGroupCall_result record
to_GetGroupCall_result :: T.ThriftVal -> GetGroupCall_result
to_GetGroupCall_result (T.TStruct fields) = GetGroupCall_result{
  getGroupCall_result_success = P.maybe (getGroupCall_result_success default_GetGroupCall_result) (\(_,_val10401) -> (case _val10401 of {T.TStruct _val10402 -> (to_GroupCall (T.TStruct _val10402)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupCall_result_e = P.maybe (P.Nothing) (\(_,_val10401) -> P.Just (case _val10401 of {T.TStruct _val10403 -> (to_TalkException (T.TStruct _val10403)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupCall_result _ = P.error "not a struct"
read_GetGroupCall_result :: T.Protocol p => p -> P.IO GetGroupCall_result
read_GetGroupCall_result iprot = to_GetGroupCall_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupCall_result)
decode_GetGroupCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupCall_result
decode_GetGroupCall_result iprot bs = to_GetGroupCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupCall_result) bs
typemap_GetGroupCall_result :: T.TypeMap
typemap_GetGroupCall_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GroupCall))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupCall_result :: GetGroupCall_result
default_GetGroupCall_result = GetGroupCall_result{
  getGroupCall_result_success = default_GroupCall,
  getGroupCall_result_e = P.Nothing}
data IsAllowSecondaryDeviceLogin_args = IsAllowSecondaryDeviceLogin_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsAllowSecondaryDeviceLogin_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary IsAllowSecondaryDeviceLogin_args where 
  arbitrary = QC.elements [IsAllowSecondaryDeviceLogin_args]
from_IsAllowSecondaryDeviceLogin_args :: IsAllowSecondaryDeviceLogin_args -> T.ThriftVal
from_IsAllowSecondaryDeviceLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_IsAllowSecondaryDeviceLogin_args :: T.Protocol p => p -> IsAllowSecondaryDeviceLogin_args -> P.IO ()
write_IsAllowSecondaryDeviceLogin_args oprot record = T.writeVal oprot $ from_IsAllowSecondaryDeviceLogin_args record
encode_IsAllowSecondaryDeviceLogin_args :: T.StatelessProtocol p => p -> IsAllowSecondaryDeviceLogin_args -> LBS.ByteString
encode_IsAllowSecondaryDeviceLogin_args oprot record = T.serializeVal oprot $ from_IsAllowSecondaryDeviceLogin_args record
to_IsAllowSecondaryDeviceLogin_args :: T.ThriftVal -> IsAllowSecondaryDeviceLogin_args
to_IsAllowSecondaryDeviceLogin_args (T.TStruct fields) = IsAllowSecondaryDeviceLogin_args{

  }
to_IsAllowSecondaryDeviceLogin_args _ = P.error "not a struct"
read_IsAllowSecondaryDeviceLogin_args :: T.Protocol p => p -> P.IO IsAllowSecondaryDeviceLogin_args
read_IsAllowSecondaryDeviceLogin_args iprot = to_IsAllowSecondaryDeviceLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_args)
decode_IsAllowSecondaryDeviceLogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsAllowSecondaryDeviceLogin_args
decode_IsAllowSecondaryDeviceLogin_args iprot bs = to_IsAllowSecondaryDeviceLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_args) bs
typemap_IsAllowSecondaryDeviceLogin_args :: T.TypeMap
typemap_IsAllowSecondaryDeviceLogin_args = Map.fromList []
default_IsAllowSecondaryDeviceLogin_args :: IsAllowSecondaryDeviceLogin_args
default_IsAllowSecondaryDeviceLogin_args = IsAllowSecondaryDeviceLogin_args{
}
data IsAllowSecondaryDeviceLogin_result = IsAllowSecondaryDeviceLogin_result  { isAllowSecondaryDeviceLogin_result_success :: P.Bool
  , isAllowSecondaryDeviceLogin_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsAllowSecondaryDeviceLogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isAllowSecondaryDeviceLogin_result_success record   `H.hashWithSalt` isAllowSecondaryDeviceLogin_result_e record  
instance QC.Arbitrary IsAllowSecondaryDeviceLogin_result where 
  arbitrary = M.liftM IsAllowSecondaryDeviceLogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsAllowSecondaryDeviceLogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = isAllowSecondaryDeviceLogin_result_success obj} then P.Nothing else P.Just $ default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = isAllowSecondaryDeviceLogin_result_success obj}
    , if obj == default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = isAllowSecondaryDeviceLogin_result_e obj} then P.Nothing else P.Just $ default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = isAllowSecondaryDeviceLogin_result_e obj}
    ]
from_IsAllowSecondaryDeviceLogin_result :: IsAllowSecondaryDeviceLogin_result -> T.ThriftVal
from_IsAllowSecondaryDeviceLogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10411 -> (1, ("e",from_TalkException _v10411))) <$> isAllowSecondaryDeviceLogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10411 -> P.Just (0, ("success",T.TBool _v10411))) $ isAllowSecondaryDeviceLogin_result_success record
    , (\_v10411 -> (1, ("e",from_TalkException _v10411))) <$> isAllowSecondaryDeviceLogin_result_e record
    ]
    )
write_IsAllowSecondaryDeviceLogin_result :: T.Protocol p => p -> IsAllowSecondaryDeviceLogin_result -> P.IO ()
write_IsAllowSecondaryDeviceLogin_result oprot record = T.writeVal oprot $ from_IsAllowSecondaryDeviceLogin_result record
encode_IsAllowSecondaryDeviceLogin_result :: T.StatelessProtocol p => p -> IsAllowSecondaryDeviceLogin_result -> LBS.ByteString
encode_IsAllowSecondaryDeviceLogin_result oprot record = T.serializeVal oprot $ from_IsAllowSecondaryDeviceLogin_result record
to_IsAllowSecondaryDeviceLogin_result :: T.ThriftVal -> IsAllowSecondaryDeviceLogin_result
to_IsAllowSecondaryDeviceLogin_result (T.TStruct fields) = IsAllowSecondaryDeviceLogin_result{
  isAllowSecondaryDeviceLogin_result_success = P.maybe (isAllowSecondaryDeviceLogin_result_success default_IsAllowSecondaryDeviceLogin_result) (\(_,_val10413) -> (case _val10413 of {T.TBool _val10414 -> _val10414; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isAllowSecondaryDeviceLogin_result_e = P.maybe (P.Nothing) (\(_,_val10413) -> P.Just (case _val10413 of {T.TStruct _val10415 -> (to_TalkException (T.TStruct _val10415)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsAllowSecondaryDeviceLogin_result _ = P.error "not a struct"
read_IsAllowSecondaryDeviceLogin_result :: T.Protocol p => p -> P.IO IsAllowSecondaryDeviceLogin_result
read_IsAllowSecondaryDeviceLogin_result iprot = to_IsAllowSecondaryDeviceLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_result)
decode_IsAllowSecondaryDeviceLogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsAllowSecondaryDeviceLogin_result
decode_IsAllowSecondaryDeviceLogin_result iprot bs = to_IsAllowSecondaryDeviceLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_result) bs
typemap_IsAllowSecondaryDeviceLogin_result :: T.TypeMap
typemap_IsAllowSecondaryDeviceLogin_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsAllowSecondaryDeviceLogin_result :: IsAllowSecondaryDeviceLogin_result
default_IsAllowSecondaryDeviceLogin_result = IsAllowSecondaryDeviceLogin_result{
  isAllowSecondaryDeviceLogin_result_success = P.False,
  isAllowSecondaryDeviceLogin_result_e = P.Nothing}
data GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPrimaryClientForChannel_args where 
  arbitrary = QC.elements [GetPrimaryClientForChannel_args]
from_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args -> T.ThriftVal
from_GetPrimaryClientForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPrimaryClientForChannel_args :: T.Protocol p => p -> GetPrimaryClientForChannel_args -> P.IO ()
write_GetPrimaryClientForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_args record
encode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_args -> LBS.ByteString
encode_GetPrimaryClientForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_args record
to_GetPrimaryClientForChannel_args :: T.ThriftVal -> GetPrimaryClientForChannel_args
to_GetPrimaryClientForChannel_args (T.TStruct fields) = GetPrimaryClientForChannel_args{

  }
to_GetPrimaryClientForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_args
read_GetPrimaryClientForChannel_args iprot = to_GetPrimaryClientForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args)
decode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_args
decode_GetPrimaryClientForChannel_args iprot bs = to_GetPrimaryClientForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args) bs
typemap_GetPrimaryClientForChannel_args :: T.TypeMap
typemap_GetPrimaryClientForChannel_args = Map.fromList []
default_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args
default_GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args{
}
data GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result  { getPrimaryClientForChannel_result_success :: SimpleChannelClient
  , getPrimaryClientForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientForChannel_result_success record   `H.hashWithSalt` getPrimaryClientForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj}
    , if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj}
    ]
from_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result -> T.ThriftVal
from_GetPrimaryClientForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10423 -> (1, ("e",from_TalkException _v10423))) <$> getPrimaryClientForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10423 -> P.Just (0, ("success",from_SimpleChannelClient _v10423))) $ getPrimaryClientForChannel_result_success record
    , (\_v10423 -> (1, ("e",from_TalkException _v10423))) <$> getPrimaryClientForChannel_result_e record
    ]
    )
write_GetPrimaryClientForChannel_result :: T.Protocol p => p -> GetPrimaryClientForChannel_result -> P.IO ()
write_GetPrimaryClientForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_result record
encode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_result -> LBS.ByteString
encode_GetPrimaryClientForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_result record
to_GetPrimaryClientForChannel_result :: T.ThriftVal -> GetPrimaryClientForChannel_result
to_GetPrimaryClientForChannel_result (T.TStruct fields) = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = P.maybe (getPrimaryClientForChannel_result_success default_GetPrimaryClientForChannel_result) (\(_,_val10425) -> (case _val10425 of {T.TStruct _val10426 -> (to_SimpleChannelClient (T.TStruct _val10426)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10425) -> P.Just (case _val10425 of {T.TStruct _val10427 -> (to_TalkException (T.TStruct _val10427)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_result
read_GetPrimaryClientForChannel_result iprot = to_GetPrimaryClientForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result)
decode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_result
decode_GetPrimaryClientForChannel_result iprot bs = to_GetPrimaryClientForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result) bs
typemap_GetPrimaryClientForChannel_result :: T.TypeMap
typemap_GetPrimaryClientForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SimpleChannelClient))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result
default_GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = default_SimpleChannelClient,
  getPrimaryClientForChannel_result_e = P.Nothing}
data CreateRoomWithBuddy_args = CreateRoomWithBuddy_args  { createRoomWithBuddy_args_reqSeq :: I.Int32
  , createRoomWithBuddy_args_buddyMid :: LT.Text
  , createRoomWithBuddy_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomWithBuddy_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomWithBuddy_args_reqSeq record   `H.hashWithSalt` createRoomWithBuddy_args_buddyMid record   `H.hashWithSalt` createRoomWithBuddy_args_contactIds record  
instance QC.Arbitrary CreateRoomWithBuddy_args where 
  arbitrary = M.liftM CreateRoomWithBuddy_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateRoomWithBuddy_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_reqSeq = createRoomWithBuddy_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_reqSeq = createRoomWithBuddy_args_reqSeq obj}
    , if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_buddyMid = createRoomWithBuddy_args_buddyMid obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_buddyMid = createRoomWithBuddy_args_buddyMid obj}
    , if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_contactIds = createRoomWithBuddy_args_contactIds obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_contactIds = createRoomWithBuddy_args_contactIds obj}
    ]
from_CreateRoomWithBuddy_args :: CreateRoomWithBuddy_args -> T.ThriftVal
from_CreateRoomWithBuddy_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10430 -> P.Just (1, ("reqSeq",T.TI32 _v10430))) $ createRoomWithBuddy_args_reqSeq record
  , (\_v10430 -> P.Just (2, ("buddyMid",T.TString $ E.encodeUtf8 _v10430))) $ createRoomWithBuddy_args_buddyMid record
  , (\_v10430 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v10432 -> T.TString $ E.encodeUtf8 _v10432) $ Vector.toList _v10430))) $ createRoomWithBuddy_args_contactIds record
  ]
write_CreateRoomWithBuddy_args :: T.Protocol p => p -> CreateRoomWithBuddy_args -> P.IO ()
write_CreateRoomWithBuddy_args oprot record = T.writeVal oprot $ from_CreateRoomWithBuddy_args record
encode_CreateRoomWithBuddy_args :: T.StatelessProtocol p => p -> CreateRoomWithBuddy_args -> LBS.ByteString
encode_CreateRoomWithBuddy_args oprot record = T.serializeVal oprot $ from_CreateRoomWithBuddy_args record
to_CreateRoomWithBuddy_args :: T.ThriftVal -> CreateRoomWithBuddy_args
to_CreateRoomWithBuddy_args (T.TStruct fields) = CreateRoomWithBuddy_args{
  createRoomWithBuddy_args_reqSeq = P.maybe (createRoomWithBuddy_args_reqSeq default_CreateRoomWithBuddy_args) (\(_,_val10434) -> (case _val10434 of {T.TI32 _val10435 -> _val10435; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createRoomWithBuddy_args_buddyMid = P.maybe (createRoomWithBuddy_args_buddyMid default_CreateRoomWithBuddy_args) (\(_,_val10434) -> (case _val10434 of {T.TString _val10436 -> E.decodeUtf8 _val10436; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createRoomWithBuddy_args_contactIds = P.maybe (createRoomWithBuddy_args_contactIds default_CreateRoomWithBuddy_args) (\(_,_val10434) -> (case _val10434 of {T.TList _ _val10437 -> (Vector.fromList $ P.map (\_v10438 -> (case _v10438 of {T.TString _val10439 -> E.decodeUtf8 _val10439; _ -> P.error "wrong type"})) _val10437); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateRoomWithBuddy_args _ = P.error "not a struct"
read_CreateRoomWithBuddy_args :: T.Protocol p => p -> P.IO CreateRoomWithBuddy_args
read_CreateRoomWithBuddy_args iprot = to_CreateRoomWithBuddy_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_args)
decode_CreateRoomWithBuddy_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomWithBuddy_args
decode_CreateRoomWithBuddy_args iprot bs = to_CreateRoomWithBuddy_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_args) bs
typemap_CreateRoomWithBuddy_args :: T.TypeMap
typemap_CreateRoomWithBuddy_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("buddyMid",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateRoomWithBuddy_args :: CreateRoomWithBuddy_args
default_CreateRoomWithBuddy_args = CreateRoomWithBuddy_args{
  createRoomWithBuddy_args_reqSeq = 0,
  createRoomWithBuddy_args_buddyMid = "",
  createRoomWithBuddy_args_contactIds = Vector.empty}
data CreateRoomWithBuddy_result = CreateRoomWithBuddy_result  { createRoomWithBuddy_result_success :: Room
  , createRoomWithBuddy_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomWithBuddy_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomWithBuddy_result_success record   `H.hashWithSalt` createRoomWithBuddy_result_e record  
instance QC.Arbitrary CreateRoomWithBuddy_result where 
  arbitrary = M.liftM CreateRoomWithBuddy_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateRoomWithBuddy_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = createRoomWithBuddy_result_success obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = createRoomWithBuddy_result_success obj}
    , if obj == default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = createRoomWithBuddy_result_e obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = createRoomWithBuddy_result_e obj}
    ]
from_CreateRoomWithBuddy_result :: CreateRoomWithBuddy_result -> T.ThriftVal
from_CreateRoomWithBuddy_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10442 -> (1, ("e",from_TalkException _v10442))) <$> createRoomWithBuddy_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10442 -> P.Just (0, ("success",from_Room _v10442))) $ createRoomWithBuddy_result_success record
    , (\_v10442 -> (1, ("e",from_TalkException _v10442))) <$> createRoomWithBuddy_result_e record
    ]
    )
write_CreateRoomWithBuddy_result :: T.Protocol p => p -> CreateRoomWithBuddy_result -> P.IO ()
write_CreateRoomWithBuddy_result oprot record = T.writeVal oprot $ from_CreateRoomWithBuddy_result record
encode_CreateRoomWithBuddy_result :: T.StatelessProtocol p => p -> CreateRoomWithBuddy_result -> LBS.ByteString
encode_CreateRoomWithBuddy_result oprot record = T.serializeVal oprot $ from_CreateRoomWithBuddy_result record
to_CreateRoomWithBuddy_result :: T.ThriftVal -> CreateRoomWithBuddy_result
to_CreateRoomWithBuddy_result (T.TStruct fields) = CreateRoomWithBuddy_result{
  createRoomWithBuddy_result_success = P.maybe (createRoomWithBuddy_result_success default_CreateRoomWithBuddy_result) (\(_,_val10444) -> (case _val10444 of {T.TStruct _val10445 -> (to_Room (T.TStruct _val10445)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createRoomWithBuddy_result_e = P.maybe (P.Nothing) (\(_,_val10444) -> P.Just (case _val10444 of {T.TStruct _val10446 -> (to_TalkException (T.TStruct _val10446)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateRoomWithBuddy_result _ = P.error "not a struct"
read_CreateRoomWithBuddy_result :: T.Protocol p => p -> P.IO CreateRoomWithBuddy_result
read_CreateRoomWithBuddy_result iprot = to_CreateRoomWithBuddy_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_result)
decode_CreateRoomWithBuddy_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomWithBuddy_result
decode_CreateRoomWithBuddy_result iprot bs = to_CreateRoomWithBuddy_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_result) bs
typemap_CreateRoomWithBuddy_result :: T.TypeMap
typemap_CreateRoomWithBuddy_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateRoomWithBuddy_result :: CreateRoomWithBuddy_result
default_CreateRoomWithBuddy_result = CreateRoomWithBuddy_result{
  createRoomWithBuddy_result_success = default_Room,
  createRoomWithBuddy_result_e = P.Nothing}
data GetDisplayName_args = GetDisplayName_args  { getDisplayName_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_args_mid record  
instance QC.Arbitrary GetDisplayName_args where 
  arbitrary = M.liftM GetDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj} then P.Nothing else P.Just $ default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj}
    ]
from_GetDisplayName_args :: GetDisplayName_args -> T.ThriftVal
from_GetDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10449 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v10449))) $ getDisplayName_args_mid record
  ]
write_GetDisplayName_args :: T.Protocol p => p -> GetDisplayName_args -> P.IO ()
write_GetDisplayName_args oprot record = T.writeVal oprot $ from_GetDisplayName_args record
encode_GetDisplayName_args :: T.StatelessProtocol p => p -> GetDisplayName_args -> LBS.ByteString
encode_GetDisplayName_args oprot record = T.serializeVal oprot $ from_GetDisplayName_args record
to_GetDisplayName_args :: T.ThriftVal -> GetDisplayName_args
to_GetDisplayName_args (T.TStruct fields) = GetDisplayName_args{
  getDisplayName_args_mid = P.maybe (getDisplayName_args_mid default_GetDisplayName_args) (\(_,_val10451) -> (case _val10451 of {T.TString _val10452 -> E.decodeUtf8 _val10452; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDisplayName_args _ = P.error "not a struct"
read_GetDisplayName_args :: T.Protocol p => p -> P.IO GetDisplayName_args
read_GetDisplayName_args iprot = to_GetDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_args)
decode_GetDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_args
decode_GetDisplayName_args iprot bs = to_GetDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_args) bs
typemap_GetDisplayName_args :: T.TypeMap
typemap_GetDisplayName_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetDisplayName_args :: GetDisplayName_args
default_GetDisplayName_args = GetDisplayName_args{
  getDisplayName_args_mid = ""}
data GetDisplayName_result = GetDisplayName_result  { getDisplayName_result_success :: LT.Text
  , getDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_result_success record   `H.hashWithSalt` getDisplayName_result_e record  
instance QC.Arbitrary GetDisplayName_result where 
  arbitrary = M.liftM GetDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj}
    , if obj == default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj}
    ]
from_GetDisplayName_result :: GetDisplayName_result -> T.ThriftVal
from_GetDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10455 -> (1, ("e",from_TalkException _v10455))) <$> getDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10455 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10455))) $ getDisplayName_result_success record
    , (\_v10455 -> (1, ("e",from_TalkException _v10455))) <$> getDisplayName_result_e record
    ]
    )
write_GetDisplayName_result :: T.Protocol p => p -> GetDisplayName_result -> P.IO ()
write_GetDisplayName_result oprot record = T.writeVal oprot $ from_GetDisplayName_result record
encode_GetDisplayName_result :: T.StatelessProtocol p => p -> GetDisplayName_result -> LBS.ByteString
encode_GetDisplayName_result oprot record = T.serializeVal oprot $ from_GetDisplayName_result record
to_GetDisplayName_result :: T.ThriftVal -> GetDisplayName_result
to_GetDisplayName_result (T.TStruct fields) = GetDisplayName_result{
  getDisplayName_result_success = P.maybe (getDisplayName_result_success default_GetDisplayName_result) (\(_,_val10457) -> (case _val10457 of {T.TString _val10458 -> E.decodeUtf8 _val10458; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val10457) -> P.Just (case _val10457 of {T.TStruct _val10459 -> (to_TalkException (T.TStruct _val10459)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDisplayName_result _ = P.error "not a struct"
read_GetDisplayName_result :: T.Protocol p => p -> P.IO GetDisplayName_result
read_GetDisplayName_result iprot = to_GetDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_result)
decode_GetDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_result
decode_GetDisplayName_result iprot bs = to_GetDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_result) bs
typemap_GetDisplayName_result :: T.TypeMap
typemap_GetDisplayName_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetDisplayName_result :: GetDisplayName_result
default_GetDisplayName_result = GetDisplayName_result{
  getDisplayName_result_success = "",
  getDisplayName_result_e = P.Nothing}
data GetPaidCallMetadata_args = GetPaidCallMetadata_args  { getPaidCallMetadata_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallMetadata_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallMetadata_args_language record  
instance QC.Arbitrary GetPaidCallMetadata_args where 
  arbitrary = M.liftM GetPaidCallMetadata_args (QC.arbitrary)
  shrink obj | obj == default_GetPaidCallMetadata_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallMetadata_args{getPaidCallMetadata_args_language = getPaidCallMetadata_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_args{getPaidCallMetadata_args_language = getPaidCallMetadata_args_language obj}
    ]
from_GetPaidCallMetadata_args :: GetPaidCallMetadata_args -> T.ThriftVal
from_GetPaidCallMetadata_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10462 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v10462))) $ getPaidCallMetadata_args_language record
  ]
write_GetPaidCallMetadata_args :: T.Protocol p => p -> GetPaidCallMetadata_args -> P.IO ()
write_GetPaidCallMetadata_args oprot record = T.writeVal oprot $ from_GetPaidCallMetadata_args record
encode_GetPaidCallMetadata_args :: T.StatelessProtocol p => p -> GetPaidCallMetadata_args -> LBS.ByteString
encode_GetPaidCallMetadata_args oprot record = T.serializeVal oprot $ from_GetPaidCallMetadata_args record
to_GetPaidCallMetadata_args :: T.ThriftVal -> GetPaidCallMetadata_args
to_GetPaidCallMetadata_args (T.TStruct fields) = GetPaidCallMetadata_args{
  getPaidCallMetadata_args_language = P.maybe (getPaidCallMetadata_args_language default_GetPaidCallMetadata_args) (\(_,_val10464) -> (case _val10464 of {T.TString _val10465 -> E.decodeUtf8 _val10465; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPaidCallMetadata_args _ = P.error "not a struct"
read_GetPaidCallMetadata_args :: T.Protocol p => p -> P.IO GetPaidCallMetadata_args
read_GetPaidCallMetadata_args iprot = to_GetPaidCallMetadata_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_args)
decode_GetPaidCallMetadata_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallMetadata_args
decode_GetPaidCallMetadata_args iprot bs = to_GetPaidCallMetadata_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_args) bs
typemap_GetPaidCallMetadata_args :: T.TypeMap
typemap_GetPaidCallMetadata_args = Map.fromList [(2,("language",T.T_STRING))]
default_GetPaidCallMetadata_args :: GetPaidCallMetadata_args
default_GetPaidCallMetadata_args = GetPaidCallMetadata_args{
  getPaidCallMetadata_args_language = ""}
data GetPaidCallMetadata_result = GetPaidCallMetadata_result  { getPaidCallMetadata_result_success :: PaidCallMetadataResult
  , getPaidCallMetadata_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallMetadata_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallMetadata_result_success record   `H.hashWithSalt` getPaidCallMetadata_result_e record  
instance QC.Arbitrary GetPaidCallMetadata_result where 
  arbitrary = M.liftM GetPaidCallMetadata_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallMetadata_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = getPaidCallMetadata_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = getPaidCallMetadata_result_success obj}
    , if obj == default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = getPaidCallMetadata_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = getPaidCallMetadata_result_e obj}
    ]
from_GetPaidCallMetadata_result :: GetPaidCallMetadata_result -> T.ThriftVal
from_GetPaidCallMetadata_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10468 -> (1, ("e",from_TalkException _v10468))) <$> getPaidCallMetadata_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10468 -> P.Just (0, ("success",from_PaidCallMetadataResult _v10468))) $ getPaidCallMetadata_result_success record
    , (\_v10468 -> (1, ("e",from_TalkException _v10468))) <$> getPaidCallMetadata_result_e record
    ]
    )
write_GetPaidCallMetadata_result :: T.Protocol p => p -> GetPaidCallMetadata_result -> P.IO ()
write_GetPaidCallMetadata_result oprot record = T.writeVal oprot $ from_GetPaidCallMetadata_result record
encode_GetPaidCallMetadata_result :: T.StatelessProtocol p => p -> GetPaidCallMetadata_result -> LBS.ByteString
encode_GetPaidCallMetadata_result oprot record = T.serializeVal oprot $ from_GetPaidCallMetadata_result record
to_GetPaidCallMetadata_result :: T.ThriftVal -> GetPaidCallMetadata_result
to_GetPaidCallMetadata_result (T.TStruct fields) = GetPaidCallMetadata_result{
  getPaidCallMetadata_result_success = P.maybe (getPaidCallMetadata_result_success default_GetPaidCallMetadata_result) (\(_,_val10470) -> (case _val10470 of {T.TStruct _val10471 -> (to_PaidCallMetadataResult (T.TStruct _val10471)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallMetadata_result_e = P.maybe (P.Nothing) (\(_,_val10470) -> P.Just (case _val10470 of {T.TStruct _val10472 -> (to_TalkException (T.TStruct _val10472)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallMetadata_result _ = P.error "not a struct"
read_GetPaidCallMetadata_result :: T.Protocol p => p -> P.IO GetPaidCallMetadata_result
read_GetPaidCallMetadata_result iprot = to_GetPaidCallMetadata_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_result)
decode_GetPaidCallMetadata_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallMetadata_result
decode_GetPaidCallMetadata_result iprot bs = to_GetPaidCallMetadata_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_result) bs
typemap_GetPaidCallMetadata_result :: T.TypeMap
typemap_GetPaidCallMetadata_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallMetadataResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallMetadata_result :: GetPaidCallMetadata_result
default_GetPaidCallMetadata_result = GetPaidCallMetadata_result{
  getPaidCallMetadata_result_success = default_PaidCallMetadataResult,
  getPaidCallMetadata_result_e = P.Nothing}
data GetMid_args = GetMid_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMid_args where 
  arbitrary = QC.elements [GetMid_args]
from_GetMid_args :: GetMid_args -> T.ThriftVal
from_GetMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMid_args :: T.Protocol p => p -> GetMid_args -> P.IO ()
write_GetMid_args oprot record = T.writeVal oprot $ from_GetMid_args record
encode_GetMid_args :: T.StatelessProtocol p => p -> GetMid_args -> LBS.ByteString
encode_GetMid_args oprot record = T.serializeVal oprot $ from_GetMid_args record
to_GetMid_args :: T.ThriftVal -> GetMid_args
to_GetMid_args (T.TStruct fields) = GetMid_args{

  }
to_GetMid_args _ = P.error "not a struct"
read_GetMid_args :: T.Protocol p => p -> P.IO GetMid_args
read_GetMid_args iprot = to_GetMid_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_args)
decode_GetMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_args
decode_GetMid_args iprot bs = to_GetMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_args) bs
typemap_GetMid_args :: T.TypeMap
typemap_GetMid_args = Map.fromList []
default_GetMid_args :: GetMid_args
default_GetMid_args = GetMid_args{
}
data GetMid_result = GetMid_result  { getMid_result_success :: LT.Text
  , getMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMid_result_success record   `H.hashWithSalt` getMid_result_e record  
instance QC.Arbitrary GetMid_result where 
  arbitrary = M.liftM GetMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMid_result{getMid_result_success = getMid_result_success obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_success = getMid_result_success obj}
    , if obj == default_GetMid_result{getMid_result_e = getMid_result_e obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_e = getMid_result_e obj}
    ]
from_GetMid_result :: GetMid_result -> T.ThriftVal
from_GetMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10480 -> (1, ("e",from_TalkException _v10480))) <$> getMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10480 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10480))) $ getMid_result_success record
    , (\_v10480 -> (1, ("e",from_TalkException _v10480))) <$> getMid_result_e record
    ]
    )
write_GetMid_result :: T.Protocol p => p -> GetMid_result -> P.IO ()
write_GetMid_result oprot record = T.writeVal oprot $ from_GetMid_result record
encode_GetMid_result :: T.StatelessProtocol p => p -> GetMid_result -> LBS.ByteString
encode_GetMid_result oprot record = T.serializeVal oprot $ from_GetMid_result record
to_GetMid_result :: T.ThriftVal -> GetMid_result
to_GetMid_result (T.TStruct fields) = GetMid_result{
  getMid_result_success = P.maybe (getMid_result_success default_GetMid_result) (\(_,_val10482) -> (case _val10482 of {T.TString _val10483 -> E.decodeUtf8 _val10483; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMid_result_e = P.maybe (P.Nothing) (\(_,_val10482) -> P.Just (case _val10482 of {T.TStruct _val10484 -> (to_TalkException (T.TStruct _val10484)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMid_result _ = P.error "not a struct"
read_GetMid_result :: T.Protocol p => p -> P.IO GetMid_result
read_GetMid_result iprot = to_GetMid_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_result)
decode_GetMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_result
decode_GetMid_result iprot bs = to_GetMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_result) bs
typemap_GetMid_result :: T.TypeMap
typemap_GetMid_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMid_result :: GetMid_result
default_GetMid_result = GetMid_result{
  getMid_result_success = "",
  getMid_result_e = P.Nothing}
data GetUserCountryForBilling_args = GetUserCountryForBilling_args  { getUserCountryForBilling_args_country :: LT.Text
  , getUserCountryForBilling_args_remoteIp :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_args_country record   `H.hashWithSalt` getUserCountryForBilling_args_remoteIp record  
instance QC.Arbitrary GetUserCountryForBilling_args where 
  arbitrary = M.liftM GetUserCountryForBilling_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj}
    , if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj}
    ]
from_GetUserCountryForBilling_args :: GetUserCountryForBilling_args -> T.ThriftVal
from_GetUserCountryForBilling_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10487 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v10487))) $ getUserCountryForBilling_args_country record
  , (\_v10487 -> P.Just (3, ("remoteIp",T.TString $ E.encodeUtf8 _v10487))) $ getUserCountryForBilling_args_remoteIp record
  ]
write_GetUserCountryForBilling_args :: T.Protocol p => p -> GetUserCountryForBilling_args -> P.IO ()
write_GetUserCountryForBilling_args oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_args record
encode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> GetUserCountryForBilling_args -> LBS.ByteString
encode_GetUserCountryForBilling_args oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_args record
to_GetUserCountryForBilling_args :: T.ThriftVal -> GetUserCountryForBilling_args
to_GetUserCountryForBilling_args (T.TStruct fields) = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = P.maybe (getUserCountryForBilling_args_country default_GetUserCountryForBilling_args) (\(_,_val10489) -> (case _val10489 of {T.TString _val10490 -> E.decodeUtf8 _val10490; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getUserCountryForBilling_args_remoteIp = P.maybe (getUserCountryForBilling_args_remoteIp default_GetUserCountryForBilling_args) (\(_,_val10489) -> (case _val10489 of {T.TString _val10491 -> E.decodeUtf8 _val10491; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetUserCountryForBilling_args _ = P.error "not a struct"
read_GetUserCountryForBilling_args :: T.Protocol p => p -> P.IO GetUserCountryForBilling_args
read_GetUserCountryForBilling_args iprot = to_GetUserCountryForBilling_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args)
decode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_args
decode_GetUserCountryForBilling_args iprot bs = to_GetUserCountryForBilling_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args) bs
typemap_GetUserCountryForBilling_args :: T.TypeMap
typemap_GetUserCountryForBilling_args = Map.fromList [(2,("country",T.T_STRING)),(3,("remoteIp",T.T_STRING))]
default_GetUserCountryForBilling_args :: GetUserCountryForBilling_args
default_GetUserCountryForBilling_args = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = "",
  getUserCountryForBilling_args_remoteIp = ""}
data GetUserCountryForBilling_result = GetUserCountryForBilling_result  { getUserCountryForBilling_result_success :: LT.Text
  , getUserCountryForBilling_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_result_success record   `H.hashWithSalt` getUserCountryForBilling_result_e record  
instance QC.Arbitrary GetUserCountryForBilling_result where 
  arbitrary = M.liftM GetUserCountryForBilling_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj}
    , if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj}
    ]
from_GetUserCountryForBilling_result :: GetUserCountryForBilling_result -> T.ThriftVal
from_GetUserCountryForBilling_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10494 -> (1, ("e",from_TalkException _v10494))) <$> getUserCountryForBilling_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10494 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10494))) $ getUserCountryForBilling_result_success record
    , (\_v10494 -> (1, ("e",from_TalkException _v10494))) <$> getUserCountryForBilling_result_e record
    ]
    )
write_GetUserCountryForBilling_result :: T.Protocol p => p -> GetUserCountryForBilling_result -> P.IO ()
write_GetUserCountryForBilling_result oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_result record
encode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> GetUserCountryForBilling_result -> LBS.ByteString
encode_GetUserCountryForBilling_result oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_result record
to_GetUserCountryForBilling_result :: T.ThriftVal -> GetUserCountryForBilling_result
to_GetUserCountryForBilling_result (T.TStruct fields) = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = P.maybe (getUserCountryForBilling_result_success default_GetUserCountryForBilling_result) (\(_,_val10496) -> (case _val10496 of {T.TString _val10497 -> E.decodeUtf8 _val10497; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCountryForBilling_result_e = P.maybe (P.Nothing) (\(_,_val10496) -> P.Just (case _val10496 of {T.TStruct _val10498 -> (to_TalkException (T.TStruct _val10498)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCountryForBilling_result _ = P.error "not a struct"
read_GetUserCountryForBilling_result :: T.Protocol p => p -> P.IO GetUserCountryForBilling_result
read_GetUserCountryForBilling_result iprot = to_GetUserCountryForBilling_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result)
decode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_result
decode_GetUserCountryForBilling_result iprot bs = to_GetUserCountryForBilling_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result) bs
typemap_GetUserCountryForBilling_result :: T.TypeMap
typemap_GetUserCountryForBilling_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCountryForBilling_result :: GetUserCountryForBilling_result
default_GetUserCountryForBilling_result = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = "",
  getUserCountryForBilling_result_e = P.Nothing}
data GetFavoriteGroupIdsForChannel_args = GetFavoriteGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteGroupIdsForChannel_args]
from_GetFavoriteGroupIdsForChannel_args :: GetFavoriteGroupIdsForChannel_args -> T.ThriftVal
from_GetFavoriteGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteGroupIdsForChannel_args :: T.Protocol p => p -> GetFavoriteGroupIdsForChannel_args -> P.IO ()
write_GetFavoriteGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteGroupIdsForChannel_args record
encode_GetFavoriteGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteGroupIdsForChannel_args -> LBS.ByteString
encode_GetFavoriteGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteGroupIdsForChannel_args record
to_GetFavoriteGroupIdsForChannel_args :: T.ThriftVal -> GetFavoriteGroupIdsForChannel_args
to_GetFavoriteGroupIdsForChannel_args (T.TStruct fields) = GetFavoriteGroupIdsForChannel_args{

  }
to_GetFavoriteGroupIdsForChannel_args _ = P.error "not a struct"
read_GetFavoriteGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteGroupIdsForChannel_args
read_GetFavoriteGroupIdsForChannel_args iprot = to_GetFavoriteGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_args)
decode_GetFavoriteGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteGroupIdsForChannel_args
decode_GetFavoriteGroupIdsForChannel_args iprot bs = to_GetFavoriteGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_args) bs
typemap_GetFavoriteGroupIdsForChannel_args :: T.TypeMap
typemap_GetFavoriteGroupIdsForChannel_args = Map.fromList []
default_GetFavoriteGroupIdsForChannel_args :: GetFavoriteGroupIdsForChannel_args
default_GetFavoriteGroupIdsForChannel_args = GetFavoriteGroupIdsForChannel_args{
}
data GetFavoriteGroupIdsForChannel_result = GetFavoriteGroupIdsForChannel_result  { getFavoriteGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteGroupIdsForChannel_result_success record   `H.hashWithSalt` getFavoriteGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteGroupIdsForChannel_result where 
  arbitrary = M.liftM GetFavoriteGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = getFavoriteGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = getFavoriteGroupIdsForChannel_result_success obj}
    , if obj == default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = getFavoriteGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = getFavoriteGroupIdsForChannel_result_e obj}
    ]
from_GetFavoriteGroupIdsForChannel_result :: GetFavoriteGroupIdsForChannel_result -> T.ThriftVal
from_GetFavoriteGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10506 -> (1, ("e",from_TalkException _v10506))) <$> getFavoriteGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10506 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10508 -> T.TString $ E.encodeUtf8 _v10508) $ Vector.toList _v10506))) $ getFavoriteGroupIdsForChannel_result_success record
    , (\_v10506 -> (1, ("e",from_TalkException _v10506))) <$> getFavoriteGroupIdsForChannel_result_e record
    ]
    )
write_GetFavoriteGroupIdsForChannel_result :: T.Protocol p => p -> GetFavoriteGroupIdsForChannel_result -> P.IO ()
write_GetFavoriteGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteGroupIdsForChannel_result record
encode_GetFavoriteGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteGroupIdsForChannel_result -> LBS.ByteString
encode_GetFavoriteGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteGroupIdsForChannel_result record
to_GetFavoriteGroupIdsForChannel_result :: T.ThriftVal -> GetFavoriteGroupIdsForChannel_result
to_GetFavoriteGroupIdsForChannel_result (T.TStruct fields) = GetFavoriteGroupIdsForChannel_result{
  getFavoriteGroupIdsForChannel_result_success = P.maybe (getFavoriteGroupIdsForChannel_result_success default_GetFavoriteGroupIdsForChannel_result) (\(_,_val10510) -> (case _val10510 of {T.TList _ _val10511 -> (Vector.fromList $ P.map (\_v10512 -> (case _v10512 of {T.TString _val10513 -> E.decodeUtf8 _val10513; _ -> P.error "wrong type"})) _val10511); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10510) -> P.Just (case _val10510 of {T.TStruct _val10514 -> (to_TalkException (T.TStruct _val10514)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteGroupIdsForChannel_result _ = P.error "not a struct"
read_GetFavoriteGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteGroupIdsForChannel_result
read_GetFavoriteGroupIdsForChannel_result iprot = to_GetFavoriteGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_result)
decode_GetFavoriteGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteGroupIdsForChannel_result
decode_GetFavoriteGroupIdsForChannel_result iprot bs = to_GetFavoriteGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_result) bs
typemap_GetFavoriteGroupIdsForChannel_result :: T.TypeMap
typemap_GetFavoriteGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteGroupIdsForChannel_result :: GetFavoriteGroupIdsForChannel_result
default_GetFavoriteGroupIdsForChannel_result = GetFavoriteGroupIdsForChannel_result{
  getFavoriteGroupIdsForChannel_result_success = Vector.empty,
  getFavoriteGroupIdsForChannel_result_e = P.Nothing}
data GetPaidCallHistory_args = GetPaidCallHistory_args  { getPaidCallHistory_args_start :: I.Int64
  , getPaidCallHistory_args_size :: I.Int32
  , getPaidCallHistory_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallHistory_args_start record   `H.hashWithSalt` getPaidCallHistory_args_size record   `H.hashWithSalt` getPaidCallHistory_args_language record  
instance QC.Arbitrary GetPaidCallHistory_args where 
  arbitrary = M.liftM GetPaidCallHistory_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPaidCallHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_start = getPaidCallHistory_args_start obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_start = getPaidCallHistory_args_start obj}
    , if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_size = getPaidCallHistory_args_size obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_size = getPaidCallHistory_args_size obj}
    , if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_language = getPaidCallHistory_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_language = getPaidCallHistory_args_language obj}
    ]
from_GetPaidCallHistory_args :: GetPaidCallHistory_args -> T.ThriftVal
from_GetPaidCallHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10517 -> P.Just (2, ("start",T.TI64 _v10517))) $ getPaidCallHistory_args_start record
  , (\_v10517 -> P.Just (3, ("size",T.TI32 _v10517))) $ getPaidCallHistory_args_size record
  , (\_v10517 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v10517))) $ getPaidCallHistory_args_language record
  ]
write_GetPaidCallHistory_args :: T.Protocol p => p -> GetPaidCallHistory_args -> P.IO ()
write_GetPaidCallHistory_args oprot record = T.writeVal oprot $ from_GetPaidCallHistory_args record
encode_GetPaidCallHistory_args :: T.StatelessProtocol p => p -> GetPaidCallHistory_args -> LBS.ByteString
encode_GetPaidCallHistory_args oprot record = T.serializeVal oprot $ from_GetPaidCallHistory_args record
to_GetPaidCallHistory_args :: T.ThriftVal -> GetPaidCallHistory_args
to_GetPaidCallHistory_args (T.TStruct fields) = GetPaidCallHistory_args{
  getPaidCallHistory_args_start = P.maybe (getPaidCallHistory_args_start default_GetPaidCallHistory_args) (\(_,_val10519) -> (case _val10519 of {T.TI64 _val10520 -> _val10520; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPaidCallHistory_args_size = P.maybe (getPaidCallHistory_args_size default_GetPaidCallHistory_args) (\(_,_val10519) -> (case _val10519 of {T.TI32 _val10521 -> _val10521; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPaidCallHistory_args_language = P.maybe (getPaidCallHistory_args_language default_GetPaidCallHistory_args) (\(_,_val10519) -> (case _val10519 of {T.TString _val10522 -> E.decodeUtf8 _val10522; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetPaidCallHistory_args _ = P.error "not a struct"
read_GetPaidCallHistory_args :: T.Protocol p => p -> P.IO GetPaidCallHistory_args
read_GetPaidCallHistory_args iprot = to_GetPaidCallHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_args)
decode_GetPaidCallHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallHistory_args
decode_GetPaidCallHistory_args iprot bs = to_GetPaidCallHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_args) bs
typemap_GetPaidCallHistory_args :: T.TypeMap
typemap_GetPaidCallHistory_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING))]
default_GetPaidCallHistory_args :: GetPaidCallHistory_args
default_GetPaidCallHistory_args = GetPaidCallHistory_args{
  getPaidCallHistory_args_start = 0,
  getPaidCallHistory_args_size = 0,
  getPaidCallHistory_args_language = ""}
data GetPaidCallHistory_result = GetPaidCallHistory_result  { getPaidCallHistory_result_success :: PaidCallHistoryResult
  , getPaidCallHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallHistory_result_success record   `H.hashWithSalt` getPaidCallHistory_result_e record  
instance QC.Arbitrary GetPaidCallHistory_result where 
  arbitrary = M.liftM GetPaidCallHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallHistory_result{getPaidCallHistory_result_success = getPaidCallHistory_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_result{getPaidCallHistory_result_success = getPaidCallHistory_result_success obj}
    , if obj == default_GetPaidCallHistory_result{getPaidCallHistory_result_e = getPaidCallHistory_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_result{getPaidCallHistory_result_e = getPaidCallHistory_result_e obj}
    ]
from_GetPaidCallHistory_result :: GetPaidCallHistory_result -> T.ThriftVal
from_GetPaidCallHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10525 -> (1, ("e",from_TalkException _v10525))) <$> getPaidCallHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10525 -> P.Just (0, ("success",from_PaidCallHistoryResult _v10525))) $ getPaidCallHistory_result_success record
    , (\_v10525 -> (1, ("e",from_TalkException _v10525))) <$> getPaidCallHistory_result_e record
    ]
    )
write_GetPaidCallHistory_result :: T.Protocol p => p -> GetPaidCallHistory_result -> P.IO ()
write_GetPaidCallHistory_result oprot record = T.writeVal oprot $ from_GetPaidCallHistory_result record
encode_GetPaidCallHistory_result :: T.StatelessProtocol p => p -> GetPaidCallHistory_result -> LBS.ByteString
encode_GetPaidCallHistory_result oprot record = T.serializeVal oprot $ from_GetPaidCallHistory_result record
to_GetPaidCallHistory_result :: T.ThriftVal -> GetPaidCallHistory_result
to_GetPaidCallHistory_result (T.TStruct fields) = GetPaidCallHistory_result{
  getPaidCallHistory_result_success = P.maybe (getPaidCallHistory_result_success default_GetPaidCallHistory_result) (\(_,_val10527) -> (case _val10527 of {T.TStruct _val10528 -> (to_PaidCallHistoryResult (T.TStruct _val10528)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallHistory_result_e = P.maybe (P.Nothing) (\(_,_val10527) -> P.Just (case _val10527 of {T.TStruct _val10529 -> (to_TalkException (T.TStruct _val10529)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallHistory_result _ = P.error "not a struct"
read_GetPaidCallHistory_result :: T.Protocol p => p -> P.IO GetPaidCallHistory_result
read_GetPaidCallHistory_result iprot = to_GetPaidCallHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_result)
decode_GetPaidCallHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallHistory_result
decode_GetPaidCallHistory_result iprot bs = to_GetPaidCallHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_result) bs
typemap_GetPaidCallHistory_result :: T.TypeMap
typemap_GetPaidCallHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallHistory_result :: GetPaidCallHistory_result
default_GetPaidCallHistory_result = GetPaidCallHistory_result{
  getPaidCallHistory_result_success = default_PaidCallHistoryResult,
  getPaidCallHistory_result_e = P.Nothing}
data SendPinCodeOperation_args = SendPinCodeOperation_args  { sendPinCodeOperation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_args_verifier record  
instance QC.Arbitrary SendPinCodeOperation_args where 
  arbitrary = M.liftM SendPinCodeOperation_args (QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj}
    ]
from_SendPinCodeOperation_args :: SendPinCodeOperation_args -> T.ThriftVal
from_SendPinCodeOperation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10532 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v10532))) $ sendPinCodeOperation_args_verifier record
  ]
write_SendPinCodeOperation_args :: T.Protocol p => p -> SendPinCodeOperation_args -> P.IO ()
write_SendPinCodeOperation_args oprot record = T.writeVal oprot $ from_SendPinCodeOperation_args record
encode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> SendPinCodeOperation_args -> LBS.ByteString
encode_SendPinCodeOperation_args oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_args record
to_SendPinCodeOperation_args :: T.ThriftVal -> SendPinCodeOperation_args
to_SendPinCodeOperation_args (T.TStruct fields) = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = P.maybe (sendPinCodeOperation_args_verifier default_SendPinCodeOperation_args) (\(_,_val10534) -> (case _val10534 of {T.TString _val10535 -> E.decodeUtf8 _val10535; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_args _ = P.error "not a struct"
read_SendPinCodeOperation_args :: T.Protocol p => p -> P.IO SendPinCodeOperation_args
read_SendPinCodeOperation_args iprot = to_SendPinCodeOperation_args <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args)
decode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_args
decode_SendPinCodeOperation_args iprot bs = to_SendPinCodeOperation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args) bs
typemap_SendPinCodeOperation_args :: T.TypeMap
typemap_SendPinCodeOperation_args = Map.fromList [(1,("verifier",T.T_STRING))]
default_SendPinCodeOperation_args :: SendPinCodeOperation_args
default_SendPinCodeOperation_args = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = ""}
data SendPinCodeOperation_result = SendPinCodeOperation_result  { sendPinCodeOperation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_result_e record  
instance QC.Arbitrary SendPinCodeOperation_result where 
  arbitrary = M.liftM SendPinCodeOperation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj}
    ]
from_SendPinCodeOperation_result :: SendPinCodeOperation_result -> T.ThriftVal
from_SendPinCodeOperation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10538 -> (1, ("e",from_TalkException _v10538))) <$> sendPinCodeOperation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10538 -> (1, ("e",from_TalkException _v10538))) <$> sendPinCodeOperation_result_e record
    ]
    )
write_SendPinCodeOperation_result :: T.Protocol p => p -> SendPinCodeOperation_result -> P.IO ()
write_SendPinCodeOperation_result oprot record = T.writeVal oprot $ from_SendPinCodeOperation_result record
encode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> SendPinCodeOperation_result -> LBS.ByteString
encode_SendPinCodeOperation_result oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_result record
to_SendPinCodeOperation_result :: T.ThriftVal -> SendPinCodeOperation_result
to_SendPinCodeOperation_result (T.TStruct fields) = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.maybe (P.Nothing) (\(_,_val10540) -> P.Just (case _val10540 of {T.TStruct _val10541 -> (to_TalkException (T.TStruct _val10541)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_result _ = P.error "not a struct"
read_SendPinCodeOperation_result :: T.Protocol p => p -> P.IO SendPinCodeOperation_result
read_SendPinCodeOperation_result iprot = to_SendPinCodeOperation_result <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result)
decode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_result
decode_SendPinCodeOperation_result iprot bs = to_SendPinCodeOperation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result) bs
typemap_SendPinCodeOperation_result :: T.TypeMap
typemap_SendPinCodeOperation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendPinCodeOperation_result :: SendPinCodeOperation_result
default_SendPinCodeOperation_result = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.Nothing}
data InviteIntoGroupCall_args = InviteIntoGroupCall_args  { inviteIntoGroupCall_args_chatMid :: LT.Text
  , inviteIntoGroupCall_args_memberMids :: (Vector.Vector LT.Text)
  , inviteIntoGroupCall_args_mediaType :: GroupCallMediaType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroupCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroupCall_args_chatMid record   `H.hashWithSalt` inviteIntoGroupCall_args_memberMids record   `H.hashWithSalt` inviteIntoGroupCall_args_mediaType record  
instance QC.Arbitrary InviteIntoGroupCall_args where 
  arbitrary = M.liftM InviteIntoGroupCall_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroupCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_chatMid = inviteIntoGroupCall_args_chatMid obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_chatMid = inviteIntoGroupCall_args_chatMid obj}
    , if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_memberMids = inviteIntoGroupCall_args_memberMids obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_memberMids = inviteIntoGroupCall_args_memberMids obj}
    , if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_mediaType = inviteIntoGroupCall_args_mediaType obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_mediaType = inviteIntoGroupCall_args_mediaType obj}
    ]
from_InviteIntoGroupCall_args :: InviteIntoGroupCall_args -> T.ThriftVal
from_InviteIntoGroupCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10544 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v10544))) $ inviteIntoGroupCall_args_chatMid record
  , (\_v10544 -> P.Just (3, ("memberMids",T.TList T.T_STRING $ P.map (\_v10546 -> T.TString $ E.encodeUtf8 _v10546) $ Vector.toList _v10544))) $ inviteIntoGroupCall_args_memberMids record
  , (\_v10544 -> P.Just (4, ("mediaType",T.TI32 $ P.fromIntegral $ P.fromEnum _v10544))) $ inviteIntoGroupCall_args_mediaType record
  ]
write_InviteIntoGroupCall_args :: T.Protocol p => p -> InviteIntoGroupCall_args -> P.IO ()
write_InviteIntoGroupCall_args oprot record = T.writeVal oprot $ from_InviteIntoGroupCall_args record
encode_InviteIntoGroupCall_args :: T.StatelessProtocol p => p -> InviteIntoGroupCall_args -> LBS.ByteString
encode_InviteIntoGroupCall_args oprot record = T.serializeVal oprot $ from_InviteIntoGroupCall_args record
to_InviteIntoGroupCall_args :: T.ThriftVal -> InviteIntoGroupCall_args
to_InviteIntoGroupCall_args (T.TStruct fields) = InviteIntoGroupCall_args{
  inviteIntoGroupCall_args_chatMid = P.maybe (inviteIntoGroupCall_args_chatMid default_InviteIntoGroupCall_args) (\(_,_val10548) -> (case _val10548 of {T.TString _val10549 -> E.decodeUtf8 _val10549; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoGroupCall_args_memberMids = P.maybe (inviteIntoGroupCall_args_memberMids default_InviteIntoGroupCall_args) (\(_,_val10548) -> (case _val10548 of {T.TList _ _val10550 -> (Vector.fromList $ P.map (\_v10551 -> (case _v10551 of {T.TString _val10552 -> E.decodeUtf8 _val10552; _ -> P.error "wrong type"})) _val10550); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  inviteIntoGroupCall_args_mediaType = P.maybe (inviteIntoGroupCall_args_mediaType default_InviteIntoGroupCall_args) (\(_,_val10548) -> (case _val10548 of {T.TI32 _val10553 -> P.toEnum $ P.fromIntegral _val10553; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_InviteIntoGroupCall_args _ = P.error "not a struct"
read_InviteIntoGroupCall_args :: T.Protocol p => p -> P.IO InviteIntoGroupCall_args
read_InviteIntoGroupCall_args iprot = to_InviteIntoGroupCall_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_args)
decode_InviteIntoGroupCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroupCall_args
decode_InviteIntoGroupCall_args iprot bs = to_InviteIntoGroupCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_args) bs
typemap_InviteIntoGroupCall_args :: T.TypeMap
typemap_InviteIntoGroupCall_args = Map.fromList [(2,("chatMid",T.T_STRING)),(3,("memberMids",(T.T_LIST T.T_STRING))),(4,("mediaType",T.T_I32))]
default_InviteIntoGroupCall_args :: InviteIntoGroupCall_args
default_InviteIntoGroupCall_args = InviteIntoGroupCall_args{
  inviteIntoGroupCall_args_chatMid = "",
  inviteIntoGroupCall_args_memberMids = Vector.empty,
  inviteIntoGroupCall_args_mediaType = (P.toEnum 0)}
data InviteIntoGroupCall_result = InviteIntoGroupCall_result  { inviteIntoGroupCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroupCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroupCall_result_e record  
instance QC.Arbitrary InviteIntoGroupCall_result where 
  arbitrary = M.liftM InviteIntoGroupCall_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroupCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = inviteIntoGroupCall_result_e obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = inviteIntoGroupCall_result_e obj}
    ]
from_InviteIntoGroupCall_result :: InviteIntoGroupCall_result -> T.ThriftVal
from_InviteIntoGroupCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10556 -> (1, ("e",from_TalkException _v10556))) <$> inviteIntoGroupCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10556 -> (1, ("e",from_TalkException _v10556))) <$> inviteIntoGroupCall_result_e record
    ]
    )
write_InviteIntoGroupCall_result :: T.Protocol p => p -> InviteIntoGroupCall_result -> P.IO ()
write_InviteIntoGroupCall_result oprot record = T.writeVal oprot $ from_InviteIntoGroupCall_result record
encode_InviteIntoGroupCall_result :: T.StatelessProtocol p => p -> InviteIntoGroupCall_result -> LBS.ByteString
encode_InviteIntoGroupCall_result oprot record = T.serializeVal oprot $ from_InviteIntoGroupCall_result record
to_InviteIntoGroupCall_result :: T.ThriftVal -> InviteIntoGroupCall_result
to_InviteIntoGroupCall_result (T.TStruct fields) = InviteIntoGroupCall_result{
  inviteIntoGroupCall_result_e = P.maybe (P.Nothing) (\(_,_val10558) -> P.Just (case _val10558 of {T.TStruct _val10559 -> (to_TalkException (T.TStruct _val10559)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoGroupCall_result _ = P.error "not a struct"
read_InviteIntoGroupCall_result :: T.Protocol p => p -> P.IO InviteIntoGroupCall_result
read_InviteIntoGroupCall_result iprot = to_InviteIntoGroupCall_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_result)
decode_InviteIntoGroupCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroupCall_result
decode_InviteIntoGroupCall_result iprot bs = to_InviteIntoGroupCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_result) bs
typemap_InviteIntoGroupCall_result :: T.TypeMap
typemap_InviteIntoGroupCall_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoGroupCall_result :: InviteIntoGroupCall_result
default_InviteIntoGroupCall_result = InviteIntoGroupCall_result{
  inviteIntoGroupCall_result_e = P.Nothing}
data GetFriendMids_args = GetFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFriendMids_args where 
  arbitrary = QC.elements [GetFriendMids_args]
from_GetFriendMids_args :: GetFriendMids_args -> T.ThriftVal
from_GetFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFriendMids_args :: T.Protocol p => p -> GetFriendMids_args -> P.IO ()
write_GetFriendMids_args oprot record = T.writeVal oprot $ from_GetFriendMids_args record
encode_GetFriendMids_args :: T.StatelessProtocol p => p -> GetFriendMids_args -> LBS.ByteString
encode_GetFriendMids_args oprot record = T.serializeVal oprot $ from_GetFriendMids_args record
to_GetFriendMids_args :: T.ThriftVal -> GetFriendMids_args
to_GetFriendMids_args (T.TStruct fields) = GetFriendMids_args{

  }
to_GetFriendMids_args _ = P.error "not a struct"
read_GetFriendMids_args :: T.Protocol p => p -> P.IO GetFriendMids_args
read_GetFriendMids_args iprot = to_GetFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_args)
decode_GetFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_args
decode_GetFriendMids_args iprot bs = to_GetFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_args) bs
typemap_GetFriendMids_args :: T.TypeMap
typemap_GetFriendMids_args = Map.fromList []
default_GetFriendMids_args :: GetFriendMids_args
default_GetFriendMids_args = GetFriendMids_args{
}
data GetFriendMids_result = GetFriendMids_result  { getFriendMids_result_success :: (Vector.Vector LT.Text)
  , getFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendMids_result_success record   `H.hashWithSalt` getFriendMids_result_e record  
instance QC.Arbitrary GetFriendMids_result where 
  arbitrary = M.liftM GetFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj}
    , if obj == default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj}
    ]
from_GetFriendMids_result :: GetFriendMids_result -> T.ThriftVal
from_GetFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10567 -> (1, ("e",from_TalkException _v10567))) <$> getFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10567 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10569 -> T.TString $ E.encodeUtf8 _v10569) $ Vector.toList _v10567))) $ getFriendMids_result_success record
    , (\_v10567 -> (1, ("e",from_TalkException _v10567))) <$> getFriendMids_result_e record
    ]
    )
write_GetFriendMids_result :: T.Protocol p => p -> GetFriendMids_result -> P.IO ()
write_GetFriendMids_result oprot record = T.writeVal oprot $ from_GetFriendMids_result record
encode_GetFriendMids_result :: T.StatelessProtocol p => p -> GetFriendMids_result -> LBS.ByteString
encode_GetFriendMids_result oprot record = T.serializeVal oprot $ from_GetFriendMids_result record
to_GetFriendMids_result :: T.ThriftVal -> GetFriendMids_result
to_GetFriendMids_result (T.TStruct fields) = GetFriendMids_result{
  getFriendMids_result_success = P.maybe (getFriendMids_result_success default_GetFriendMids_result) (\(_,_val10571) -> (case _val10571 of {T.TList _ _val10572 -> (Vector.fromList $ P.map (\_v10573 -> (case _v10573 of {T.TString _val10574 -> E.decodeUtf8 _val10574; _ -> P.error "wrong type"})) _val10572); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val10571) -> P.Just (case _val10571 of {T.TStruct _val10575 -> (to_TalkException (T.TStruct _val10575)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendMids_result _ = P.error "not a struct"
read_GetFriendMids_result :: T.Protocol p => p -> P.IO GetFriendMids_result
read_GetFriendMids_result iprot = to_GetFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_result)
decode_GetFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_result
decode_GetFriendMids_result iprot bs = to_GetFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_result) bs
typemap_GetFriendMids_result :: T.TypeMap
typemap_GetFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFriendMids_result :: GetFriendMids_result
default_GetFriendMids_result = GetFriendMids_result{
  getFriendMids_result_success = Vector.empty,
  getFriendMids_result_e = P.Nothing}
data GetMetaProfile_args = GetMetaProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMetaProfile_args where 
  arbitrary = QC.elements [GetMetaProfile_args]
from_GetMetaProfile_args :: GetMetaProfile_args -> T.ThriftVal
from_GetMetaProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMetaProfile_args :: T.Protocol p => p -> GetMetaProfile_args -> P.IO ()
write_GetMetaProfile_args oprot record = T.writeVal oprot $ from_GetMetaProfile_args record
encode_GetMetaProfile_args :: T.StatelessProtocol p => p -> GetMetaProfile_args -> LBS.ByteString
encode_GetMetaProfile_args oprot record = T.serializeVal oprot $ from_GetMetaProfile_args record
to_GetMetaProfile_args :: T.ThriftVal -> GetMetaProfile_args
to_GetMetaProfile_args (T.TStruct fields) = GetMetaProfile_args{

  }
to_GetMetaProfile_args _ = P.error "not a struct"
read_GetMetaProfile_args :: T.Protocol p => p -> P.IO GetMetaProfile_args
read_GetMetaProfile_args iprot = to_GetMetaProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_args)
decode_GetMetaProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_args
decode_GetMetaProfile_args iprot bs = to_GetMetaProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_args) bs
typemap_GetMetaProfile_args :: T.TypeMap
typemap_GetMetaProfile_args = Map.fromList []
default_GetMetaProfile_args :: GetMetaProfile_args
default_GetMetaProfile_args = GetMetaProfile_args{
}
data GetMetaProfile_result = GetMetaProfile_result  { getMetaProfile_result_success :: MetaProfile
  , getMetaProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMetaProfile_result_success record   `H.hashWithSalt` getMetaProfile_result_e record  
instance QC.Arbitrary GetMetaProfile_result where 
  arbitrary = M.liftM GetMetaProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMetaProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj}
    , if obj == default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj}
    ]
from_GetMetaProfile_result :: GetMetaProfile_result -> T.ThriftVal
from_GetMetaProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10583 -> (1, ("e",from_TalkException _v10583))) <$> getMetaProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10583 -> P.Just (0, ("success",from_MetaProfile _v10583))) $ getMetaProfile_result_success record
    , (\_v10583 -> (1, ("e",from_TalkException _v10583))) <$> getMetaProfile_result_e record
    ]
    )
write_GetMetaProfile_result :: T.Protocol p => p -> GetMetaProfile_result -> P.IO ()
write_GetMetaProfile_result oprot record = T.writeVal oprot $ from_GetMetaProfile_result record
encode_GetMetaProfile_result :: T.StatelessProtocol p => p -> GetMetaProfile_result -> LBS.ByteString
encode_GetMetaProfile_result oprot record = T.serializeVal oprot $ from_GetMetaProfile_result record
to_GetMetaProfile_result :: T.ThriftVal -> GetMetaProfile_result
to_GetMetaProfile_result (T.TStruct fields) = GetMetaProfile_result{
  getMetaProfile_result_success = P.maybe (getMetaProfile_result_success default_GetMetaProfile_result) (\(_,_val10585) -> (case _val10585 of {T.TStruct _val10586 -> (to_MetaProfile (T.TStruct _val10586)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMetaProfile_result_e = P.maybe (P.Nothing) (\(_,_val10585) -> P.Just (case _val10585 of {T.TStruct _val10587 -> (to_TalkException (T.TStruct _val10587)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMetaProfile_result _ = P.error "not a struct"
read_GetMetaProfile_result :: T.Protocol p => p -> P.IO GetMetaProfile_result
read_GetMetaProfile_result iprot = to_GetMetaProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_result)
decode_GetMetaProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_result
decode_GetMetaProfile_result iprot bs = to_GetMetaProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_result) bs
typemap_GetMetaProfile_result :: T.TypeMap
typemap_GetMetaProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MetaProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMetaProfile_result :: GetMetaProfile_result
default_GetMetaProfile_result = GetMetaProfile_result{
  getMetaProfile_result_success = default_MetaProfile,
  getMetaProfile_result_e = P.Nothing}
data SendMessageForChannel_args = SendMessageForChannel_args  { sendMessageForChannel_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_args_message record  
instance QC.Arbitrary SendMessageForChannel_args where 
  arbitrary = M.liftM SendMessageForChannel_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj} then P.Nothing else P.Just $ default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj}
    ]
from_SendMessageForChannel_args :: SendMessageForChannel_args -> T.ThriftVal
from_SendMessageForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10590 -> P.Just (2, ("message",from_Message _v10590))) $ sendMessageForChannel_args_message record
  ]
write_SendMessageForChannel_args :: T.Protocol p => p -> SendMessageForChannel_args -> P.IO ()
write_SendMessageForChannel_args oprot record = T.writeVal oprot $ from_SendMessageForChannel_args record
encode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> SendMessageForChannel_args -> LBS.ByteString
encode_SendMessageForChannel_args oprot record = T.serializeVal oprot $ from_SendMessageForChannel_args record
to_SendMessageForChannel_args :: T.ThriftVal -> SendMessageForChannel_args
to_SendMessageForChannel_args (T.TStruct fields) = SendMessageForChannel_args{
  sendMessageForChannel_args_message = P.maybe (sendMessageForChannel_args_message default_SendMessageForChannel_args) (\(_,_val10592) -> (case _val10592 of {T.TStruct _val10593 -> (to_Message (T.TStruct _val10593)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageForChannel_args _ = P.error "not a struct"
read_SendMessageForChannel_args :: T.Protocol p => p -> P.IO SendMessageForChannel_args
read_SendMessageForChannel_args iprot = to_SendMessageForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args)
decode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_args
decode_SendMessageForChannel_args iprot bs = to_SendMessageForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args) bs
typemap_SendMessageForChannel_args :: T.TypeMap
typemap_SendMessageForChannel_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageForChannel_args :: SendMessageForChannel_args
default_SendMessageForChannel_args = SendMessageForChannel_args{
  sendMessageForChannel_args_message = default_Message}
data SendMessageForChannel_result = SendMessageForChannel_result  { sendMessageForChannel_result_success :: Message
  , sendMessageForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_result_success record   `H.hashWithSalt` sendMessageForChannel_result_e record  
instance QC.Arbitrary SendMessageForChannel_result where 
  arbitrary = M.liftM SendMessageForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj}
    , if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj}
    ]
from_SendMessageForChannel_result :: SendMessageForChannel_result -> T.ThriftVal
from_SendMessageForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10596 -> (1, ("e",from_TalkException _v10596))) <$> sendMessageForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10596 -> P.Just (0, ("success",from_Message _v10596))) $ sendMessageForChannel_result_success record
    , (\_v10596 -> (1, ("e",from_TalkException _v10596))) <$> sendMessageForChannel_result_e record
    ]
    )
write_SendMessageForChannel_result :: T.Protocol p => p -> SendMessageForChannel_result -> P.IO ()
write_SendMessageForChannel_result oprot record = T.writeVal oprot $ from_SendMessageForChannel_result record
encode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> SendMessageForChannel_result -> LBS.ByteString
encode_SendMessageForChannel_result oprot record = T.serializeVal oprot $ from_SendMessageForChannel_result record
to_SendMessageForChannel_result :: T.ThriftVal -> SendMessageForChannel_result
to_SendMessageForChannel_result (T.TStruct fields) = SendMessageForChannel_result{
  sendMessageForChannel_result_success = P.maybe (sendMessageForChannel_result_success default_SendMessageForChannel_result) (\(_,_val10598) -> (case _val10598 of {T.TStruct _val10599 -> (to_Message (T.TStruct _val10599)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10598) -> P.Just (case _val10598 of {T.TStruct _val10600 -> (to_TalkException (T.TStruct _val10600)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageForChannel_result _ = P.error "not a struct"
read_SendMessageForChannel_result :: T.Protocol p => p -> P.IO SendMessageForChannel_result
read_SendMessageForChannel_result iprot = to_SendMessageForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result)
decode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_result
decode_SendMessageForChannel_result iprot bs = to_SendMessageForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result) bs
typemap_SendMessageForChannel_result :: T.TypeMap
typemap_SendMessageForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageForChannel_result :: SendMessageForChannel_result
default_SendMessageForChannel_result = SendMessageForChannel_result{
  sendMessageForChannel_result_success = default_Message,
  sendMessageForChannel_result_e = P.Nothing}
data ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ActiveBuddySubscriberCount_args where 
  arbitrary = QC.elements [ActiveBuddySubscriberCount_args]
from_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args -> T.ThriftVal
from_ActiveBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> ActiveBuddySubscriberCount_args -> P.IO ()
write_ActiveBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_args record
encode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_args -> LBS.ByteString
encode_ActiveBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_args record
to_ActiveBuddySubscriberCount_args :: T.ThriftVal -> ActiveBuddySubscriberCount_args
to_ActiveBuddySubscriberCount_args (T.TStruct fields) = ActiveBuddySubscriberCount_args{

  }
to_ActiveBuddySubscriberCount_args _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_args
read_ActiveBuddySubscriberCount_args iprot = to_ActiveBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args)
decode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_args
decode_ActiveBuddySubscriberCount_args iprot bs = to_ActiveBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args) bs
typemap_ActiveBuddySubscriberCount_args :: T.TypeMap
typemap_ActiveBuddySubscriberCount_args = Map.fromList []
default_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args
default_ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args{
}
data ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result  { activeBuddySubscriberCount_result_success :: I.Int64
  , activeBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` activeBuddySubscriberCount_result_success record   `H.hashWithSalt` activeBuddySubscriberCount_result_e record  
instance QC.Arbitrary ActiveBuddySubscriberCount_result where 
  arbitrary = M.liftM ActiveBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ActiveBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj}
    , if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj}
    ]
from_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result -> T.ThriftVal
from_ActiveBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10608 -> (1, ("e",from_TalkException _v10608))) <$> activeBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10608 -> P.Just (0, ("success",T.TI64 _v10608))) $ activeBuddySubscriberCount_result_success record
    , (\_v10608 -> (1, ("e",from_TalkException _v10608))) <$> activeBuddySubscriberCount_result_e record
    ]
    )
write_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> ActiveBuddySubscriberCount_result -> P.IO ()
write_ActiveBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_result record
encode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_result -> LBS.ByteString
encode_ActiveBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_result record
to_ActiveBuddySubscriberCount_result :: T.ThriftVal -> ActiveBuddySubscriberCount_result
to_ActiveBuddySubscriberCount_result (T.TStruct fields) = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = P.maybe (activeBuddySubscriberCount_result_success default_ActiveBuddySubscriberCount_result) (\(_,_val10610) -> (case _val10610 of {T.TI64 _val10611 -> _val10611; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  activeBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val10610) -> P.Just (case _val10610 of {T.TStruct _val10612 -> (to_TalkException (T.TStruct _val10612)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ActiveBuddySubscriberCount_result _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_result
read_ActiveBuddySubscriberCount_result iprot = to_ActiveBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result)
decode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_result
decode_ActiveBuddySubscriberCount_result iprot bs = to_ActiveBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result) bs
typemap_ActiveBuddySubscriberCount_result :: T.TypeMap
typemap_ActiveBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result
default_ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = 0,
  activeBuddySubscriberCount_result_e = P.Nothing}
data GetCallCreditPurchaseHistory_args = GetCallCreditPurchaseHistory_args  { getCallCreditPurchaseHistory_args_request :: CoinHistoryCondition
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditPurchaseHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditPurchaseHistory_args_request record  
instance QC.Arbitrary GetCallCreditPurchaseHistory_args where 
  arbitrary = M.liftM GetCallCreditPurchaseHistory_args (QC.arbitrary)
  shrink obj | obj == default_GetCallCreditPurchaseHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditPurchaseHistory_args{getCallCreditPurchaseHistory_args_request = getCallCreditPurchaseHistory_args_request obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_args{getCallCreditPurchaseHistory_args_request = getCallCreditPurchaseHistory_args_request obj}
    ]
from_GetCallCreditPurchaseHistory_args :: GetCallCreditPurchaseHistory_args -> T.ThriftVal
from_GetCallCreditPurchaseHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10615 -> P.Just (2, ("request",from_CoinHistoryCondition _v10615))) $ getCallCreditPurchaseHistory_args_request record
  ]
write_GetCallCreditPurchaseHistory_args :: T.Protocol p => p -> GetCallCreditPurchaseHistory_args -> P.IO ()
write_GetCallCreditPurchaseHistory_args oprot record = T.writeVal oprot $ from_GetCallCreditPurchaseHistory_args record
encode_GetCallCreditPurchaseHistory_args :: T.StatelessProtocol p => p -> GetCallCreditPurchaseHistory_args -> LBS.ByteString
encode_GetCallCreditPurchaseHistory_args oprot record = T.serializeVal oprot $ from_GetCallCreditPurchaseHistory_args record
to_GetCallCreditPurchaseHistory_args :: T.ThriftVal -> GetCallCreditPurchaseHistory_args
to_GetCallCreditPurchaseHistory_args (T.TStruct fields) = GetCallCreditPurchaseHistory_args{
  getCallCreditPurchaseHistory_args_request = P.maybe (getCallCreditPurchaseHistory_args_request default_GetCallCreditPurchaseHistory_args) (\(_,_val10617) -> (case _val10617 of {T.TStruct _val10618 -> (to_CoinHistoryCondition (T.TStruct _val10618)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCallCreditPurchaseHistory_args _ = P.error "not a struct"
read_GetCallCreditPurchaseHistory_args :: T.Protocol p => p -> P.IO GetCallCreditPurchaseHistory_args
read_GetCallCreditPurchaseHistory_args iprot = to_GetCallCreditPurchaseHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_args)
decode_GetCallCreditPurchaseHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditPurchaseHistory_args
decode_GetCallCreditPurchaseHistory_args iprot bs = to_GetCallCreditPurchaseHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_args) bs
typemap_GetCallCreditPurchaseHistory_args :: T.TypeMap
typemap_GetCallCreditPurchaseHistory_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinHistoryCondition)))]
default_GetCallCreditPurchaseHistory_args :: GetCallCreditPurchaseHistory_args
default_GetCallCreditPurchaseHistory_args = GetCallCreditPurchaseHistory_args{
  getCallCreditPurchaseHistory_args_request = default_CoinHistoryCondition}
data GetCallCreditPurchaseHistory_result = GetCallCreditPurchaseHistory_result  { getCallCreditPurchaseHistory_result_success :: CoinHistoryResult
  , getCallCreditPurchaseHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditPurchaseHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditPurchaseHistory_result_success record   `H.hashWithSalt` getCallCreditPurchaseHistory_result_e record  
instance QC.Arbitrary GetCallCreditPurchaseHistory_result where 
  arbitrary = M.liftM GetCallCreditPurchaseHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCallCreditPurchaseHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = getCallCreditPurchaseHistory_result_success obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = getCallCreditPurchaseHistory_result_success obj}
    , if obj == default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = getCallCreditPurchaseHistory_result_e obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = getCallCreditPurchaseHistory_result_e obj}
    ]
from_GetCallCreditPurchaseHistory_result :: GetCallCreditPurchaseHistory_result -> T.ThriftVal
from_GetCallCreditPurchaseHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10621 -> (1, ("e",from_TalkException _v10621))) <$> getCallCreditPurchaseHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10621 -> P.Just (0, ("success",from_CoinHistoryResult _v10621))) $ getCallCreditPurchaseHistory_result_success record
    , (\_v10621 -> (1, ("e",from_TalkException _v10621))) <$> getCallCreditPurchaseHistory_result_e record
    ]
    )
write_GetCallCreditPurchaseHistory_result :: T.Protocol p => p -> GetCallCreditPurchaseHistory_result -> P.IO ()
write_GetCallCreditPurchaseHistory_result oprot record = T.writeVal oprot $ from_GetCallCreditPurchaseHistory_result record
encode_GetCallCreditPurchaseHistory_result :: T.StatelessProtocol p => p -> GetCallCreditPurchaseHistory_result -> LBS.ByteString
encode_GetCallCreditPurchaseHistory_result oprot record = T.serializeVal oprot $ from_GetCallCreditPurchaseHistory_result record
to_GetCallCreditPurchaseHistory_result :: T.ThriftVal -> GetCallCreditPurchaseHistory_result
to_GetCallCreditPurchaseHistory_result (T.TStruct fields) = GetCallCreditPurchaseHistory_result{
  getCallCreditPurchaseHistory_result_success = P.maybe (getCallCreditPurchaseHistory_result_success default_GetCallCreditPurchaseHistory_result) (\(_,_val10623) -> (case _val10623 of {T.TStruct _val10624 -> (to_CoinHistoryResult (T.TStruct _val10624)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCallCreditPurchaseHistory_result_e = P.maybe (P.Nothing) (\(_,_val10623) -> P.Just (case _val10623 of {T.TStruct _val10625 -> (to_TalkException (T.TStruct _val10625)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCallCreditPurchaseHistory_result _ = P.error "not a struct"
read_GetCallCreditPurchaseHistory_result :: T.Protocol p => p -> P.IO GetCallCreditPurchaseHistory_result
read_GetCallCreditPurchaseHistory_result iprot = to_GetCallCreditPurchaseHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_result)
decode_GetCallCreditPurchaseHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditPurchaseHistory_result
decode_GetCallCreditPurchaseHistory_result iprot bs = to_GetCallCreditPurchaseHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_result) bs
typemap_GetCallCreditPurchaseHistory_result :: T.TypeMap
typemap_GetCallCreditPurchaseHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CoinHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCallCreditPurchaseHistory_result :: GetCallCreditPurchaseHistory_result
default_GetCallCreditPurchaseHistory_result = GetCallCreditPurchaseHistory_result{
  getCallCreditPurchaseHistory_result_success = default_CoinHistoryResult,
  getCallCreditPurchaseHistory_result_e = P.Nothing}
data IsRoomMember_args = IsRoomMember_args  { isRoomMember_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsRoomMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isRoomMember_args_roomId record  
instance QC.Arbitrary IsRoomMember_args where 
  arbitrary = M.liftM IsRoomMember_args (QC.arbitrary)
  shrink obj | obj == default_IsRoomMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsRoomMember_args{isRoomMember_args_roomId = isRoomMember_args_roomId obj} then P.Nothing else P.Just $ default_IsRoomMember_args{isRoomMember_args_roomId = isRoomMember_args_roomId obj}
    ]
from_IsRoomMember_args :: IsRoomMember_args -> T.ThriftVal
from_IsRoomMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10628 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10628))) $ isRoomMember_args_roomId record
  ]
write_IsRoomMember_args :: T.Protocol p => p -> IsRoomMember_args -> P.IO ()
write_IsRoomMember_args oprot record = T.writeVal oprot $ from_IsRoomMember_args record
encode_IsRoomMember_args :: T.StatelessProtocol p => p -> IsRoomMember_args -> LBS.ByteString
encode_IsRoomMember_args oprot record = T.serializeVal oprot $ from_IsRoomMember_args record
to_IsRoomMember_args :: T.ThriftVal -> IsRoomMember_args
to_IsRoomMember_args (T.TStruct fields) = IsRoomMember_args{
  isRoomMember_args_roomId = P.maybe (isRoomMember_args_roomId default_IsRoomMember_args) (\(_,_val10630) -> (case _val10630 of {T.TString _val10631 -> E.decodeUtf8 _val10631; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsRoomMember_args _ = P.error "not a struct"
read_IsRoomMember_args :: T.Protocol p => p -> P.IO IsRoomMember_args
read_IsRoomMember_args iprot = to_IsRoomMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsRoomMember_args)
decode_IsRoomMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsRoomMember_args
decode_IsRoomMember_args iprot bs = to_IsRoomMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsRoomMember_args) bs
typemap_IsRoomMember_args :: T.TypeMap
typemap_IsRoomMember_args = Map.fromList [(1,("roomId",T.T_STRING))]
default_IsRoomMember_args :: IsRoomMember_args
default_IsRoomMember_args = IsRoomMember_args{
  isRoomMember_args_roomId = ""}
data IsRoomMember_result = IsRoomMember_result  { isRoomMember_result_success :: P.Bool
  , isRoomMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsRoomMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isRoomMember_result_success record   `H.hashWithSalt` isRoomMember_result_e record  
instance QC.Arbitrary IsRoomMember_result where 
  arbitrary = M.liftM IsRoomMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsRoomMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsRoomMember_result{isRoomMember_result_success = isRoomMember_result_success obj} then P.Nothing else P.Just $ default_IsRoomMember_result{isRoomMember_result_success = isRoomMember_result_success obj}
    , if obj == default_IsRoomMember_result{isRoomMember_result_e = isRoomMember_result_e obj} then P.Nothing else P.Just $ default_IsRoomMember_result{isRoomMember_result_e = isRoomMember_result_e obj}
    ]
from_IsRoomMember_result :: IsRoomMember_result -> T.ThriftVal
from_IsRoomMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10634 -> (1, ("e",from_TalkException _v10634))) <$> isRoomMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10634 -> P.Just (0, ("success",T.TBool _v10634))) $ isRoomMember_result_success record
    , (\_v10634 -> (1, ("e",from_TalkException _v10634))) <$> isRoomMember_result_e record
    ]
    )
write_IsRoomMember_result :: T.Protocol p => p -> IsRoomMember_result -> P.IO ()
write_IsRoomMember_result oprot record = T.writeVal oprot $ from_IsRoomMember_result record
encode_IsRoomMember_result :: T.StatelessProtocol p => p -> IsRoomMember_result -> LBS.ByteString
encode_IsRoomMember_result oprot record = T.serializeVal oprot $ from_IsRoomMember_result record
to_IsRoomMember_result :: T.ThriftVal -> IsRoomMember_result
to_IsRoomMember_result (T.TStruct fields) = IsRoomMember_result{
  isRoomMember_result_success = P.maybe (isRoomMember_result_success default_IsRoomMember_result) (\(_,_val10636) -> (case _val10636 of {T.TBool _val10637 -> _val10637; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isRoomMember_result_e = P.maybe (P.Nothing) (\(_,_val10636) -> P.Just (case _val10636 of {T.TStruct _val10638 -> (to_TalkException (T.TStruct _val10638)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsRoomMember_result _ = P.error "not a struct"
read_IsRoomMember_result :: T.Protocol p => p -> P.IO IsRoomMember_result
read_IsRoomMember_result iprot = to_IsRoomMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsRoomMember_result)
decode_IsRoomMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsRoomMember_result
decode_IsRoomMember_result iprot bs = to_IsRoomMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsRoomMember_result) bs
typemap_IsRoomMember_result :: T.TypeMap
typemap_IsRoomMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsRoomMember_result :: IsRoomMember_result
default_IsRoomMember_result = IsRoomMember_result{
  isRoomMember_result_success = P.False,
  isRoomMember_result_e = P.Nothing}
data SendSystemOAMessage_args = SendSystemOAMessage_args  { sendSystemOAMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendSystemOAMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendSystemOAMessage_args_message record  
instance QC.Arbitrary SendSystemOAMessage_args where 
  arbitrary = M.liftM SendSystemOAMessage_args (QC.arbitrary)
  shrink obj | obj == default_SendSystemOAMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendSystemOAMessage_args{sendSystemOAMessage_args_message = sendSystemOAMessage_args_message obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_args{sendSystemOAMessage_args_message = sendSystemOAMessage_args_message obj}
    ]
from_SendSystemOAMessage_args :: SendSystemOAMessage_args -> T.ThriftVal
from_SendSystemOAMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10641 -> P.Just (1, ("message",from_Message _v10641))) $ sendSystemOAMessage_args_message record
  ]
write_SendSystemOAMessage_args :: T.Protocol p => p -> SendSystemOAMessage_args -> P.IO ()
write_SendSystemOAMessage_args oprot record = T.writeVal oprot $ from_SendSystemOAMessage_args record
encode_SendSystemOAMessage_args :: T.StatelessProtocol p => p -> SendSystemOAMessage_args -> LBS.ByteString
encode_SendSystemOAMessage_args oprot record = T.serializeVal oprot $ from_SendSystemOAMessage_args record
to_SendSystemOAMessage_args :: T.ThriftVal -> SendSystemOAMessage_args
to_SendSystemOAMessage_args (T.TStruct fields) = SendSystemOAMessage_args{
  sendSystemOAMessage_args_message = P.maybe (sendSystemOAMessage_args_message default_SendSystemOAMessage_args) (\(_,_val10643) -> (case _val10643 of {T.TStruct _val10644 -> (to_Message (T.TStruct _val10644)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendSystemOAMessage_args _ = P.error "not a struct"
read_SendSystemOAMessage_args :: T.Protocol p => p -> P.IO SendSystemOAMessage_args
read_SendSystemOAMessage_args iprot = to_SendSystemOAMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_args)
decode_SendSystemOAMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendSystemOAMessage_args
decode_SendSystemOAMessage_args iprot bs = to_SendSystemOAMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_args) bs
typemap_SendSystemOAMessage_args :: T.TypeMap
typemap_SendSystemOAMessage_args = Map.fromList [(1,("message",(T.T_STRUCT typemap_Message)))]
default_SendSystemOAMessage_args :: SendSystemOAMessage_args
default_SendSystemOAMessage_args = SendSystemOAMessage_args{
  sendSystemOAMessage_args_message = default_Message}
data SendSystemOAMessage_result = SendSystemOAMessage_result  { sendSystemOAMessage_result_success :: Message
  , sendSystemOAMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendSystemOAMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendSystemOAMessage_result_success record   `H.hashWithSalt` sendSystemOAMessage_result_e record  
instance QC.Arbitrary SendSystemOAMessage_result where 
  arbitrary = M.liftM SendSystemOAMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendSystemOAMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = sendSystemOAMessage_result_success obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = sendSystemOAMessage_result_success obj}
    , if obj == default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = sendSystemOAMessage_result_e obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = sendSystemOAMessage_result_e obj}
    ]
from_SendSystemOAMessage_result :: SendSystemOAMessage_result -> T.ThriftVal
from_SendSystemOAMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10647 -> (1, ("e",from_TalkException _v10647))) <$> sendSystemOAMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10647 -> P.Just (0, ("success",from_Message _v10647))) $ sendSystemOAMessage_result_success record
    , (\_v10647 -> (1, ("e",from_TalkException _v10647))) <$> sendSystemOAMessage_result_e record
    ]
    )
write_SendSystemOAMessage_result :: T.Protocol p => p -> SendSystemOAMessage_result -> P.IO ()
write_SendSystemOAMessage_result oprot record = T.writeVal oprot $ from_SendSystemOAMessage_result record
encode_SendSystemOAMessage_result :: T.StatelessProtocol p => p -> SendSystemOAMessage_result -> LBS.ByteString
encode_SendSystemOAMessage_result oprot record = T.serializeVal oprot $ from_SendSystemOAMessage_result record
to_SendSystemOAMessage_result :: T.ThriftVal -> SendSystemOAMessage_result
to_SendSystemOAMessage_result (T.TStruct fields) = SendSystemOAMessage_result{
  sendSystemOAMessage_result_success = P.maybe (sendSystemOAMessage_result_success default_SendSystemOAMessage_result) (\(_,_val10649) -> (case _val10649 of {T.TStruct _val10650 -> (to_Message (T.TStruct _val10650)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendSystemOAMessage_result_e = P.maybe (P.Nothing) (\(_,_val10649) -> P.Just (case _val10649 of {T.TStruct _val10651 -> (to_TalkException (T.TStruct _val10651)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendSystemOAMessage_result _ = P.error "not a struct"
read_SendSystemOAMessage_result :: T.Protocol p => p -> P.IO SendSystemOAMessage_result
read_SendSystemOAMessage_result iprot = to_SendSystemOAMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_result)
decode_SendSystemOAMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendSystemOAMessage_result
decode_SendSystemOAMessage_result iprot bs = to_SendSystemOAMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_result) bs
typemap_SendSystemOAMessage_result :: T.TypeMap
typemap_SendSystemOAMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendSystemOAMessage_result :: SendSystemOAMessage_result
default_SendSystemOAMessage_result = SendSystemOAMessage_result{
  sendSystemOAMessage_result_success = default_Message,
  sendSystemOAMessage_result_e = P.Nothing}
data AcquirePaidCallRoute_args = AcquirePaidCallRoute_args  { acquirePaidCallRoute_args_paidCallType :: PaidCallType
  , acquirePaidCallRoute_args_dialedNumber :: LT.Text
  , acquirePaidCallRoute_args_language :: LT.Text
  , acquirePaidCallRoute_args_networkCode :: LT.Text
  , acquirePaidCallRoute_args_disableCallerId :: P.Bool
  , acquirePaidCallRoute_args_referer :: LT.Text
  , acquirePaidCallRoute_args_adSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallRoute_args_paidCallType record   `H.hashWithSalt` acquirePaidCallRoute_args_dialedNumber record   `H.hashWithSalt` acquirePaidCallRoute_args_language record   `H.hashWithSalt` acquirePaidCallRoute_args_networkCode record   `H.hashWithSalt` acquirePaidCallRoute_args_disableCallerId record   `H.hashWithSalt` acquirePaidCallRoute_args_referer record   `H.hashWithSalt` acquirePaidCallRoute_args_adSessionId record  
instance QC.Arbitrary AcquirePaidCallRoute_args where 
  arbitrary = M.liftM AcquirePaidCallRoute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_paidCallType = acquirePaidCallRoute_args_paidCallType obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_paidCallType = acquirePaidCallRoute_args_paidCallType obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_dialedNumber = acquirePaidCallRoute_args_dialedNumber obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_dialedNumber = acquirePaidCallRoute_args_dialedNumber obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_language = acquirePaidCallRoute_args_language obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_language = acquirePaidCallRoute_args_language obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_networkCode = acquirePaidCallRoute_args_networkCode obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_networkCode = acquirePaidCallRoute_args_networkCode obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_disableCallerId = acquirePaidCallRoute_args_disableCallerId obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_disableCallerId = acquirePaidCallRoute_args_disableCallerId obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_referer = acquirePaidCallRoute_args_referer obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_referer = acquirePaidCallRoute_args_referer obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_adSessionId = acquirePaidCallRoute_args_adSessionId obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_adSessionId = acquirePaidCallRoute_args_adSessionId obj}
    ]
from_AcquirePaidCallRoute_args :: AcquirePaidCallRoute_args -> T.ThriftVal
from_AcquirePaidCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10654 -> P.Just (2, ("paidCallType",T.TI32 $ P.fromIntegral $ P.fromEnum _v10654))) $ acquirePaidCallRoute_args_paidCallType record
  , (\_v10654 -> P.Just (3, ("dialedNumber",T.TString $ E.encodeUtf8 _v10654))) $ acquirePaidCallRoute_args_dialedNumber record
  , (\_v10654 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v10654))) $ acquirePaidCallRoute_args_language record
  , (\_v10654 -> P.Just (5, ("networkCode",T.TString $ E.encodeUtf8 _v10654))) $ acquirePaidCallRoute_args_networkCode record
  , (\_v10654 -> P.Just (6, ("disableCallerId",T.TBool _v10654))) $ acquirePaidCallRoute_args_disableCallerId record
  , (\_v10654 -> P.Just (7, ("referer",T.TString $ E.encodeUtf8 _v10654))) $ acquirePaidCallRoute_args_referer record
  , (\_v10654 -> P.Just (8, ("adSessionId",T.TString $ E.encodeUtf8 _v10654))) $ acquirePaidCallRoute_args_adSessionId record
  ]
write_AcquirePaidCallRoute_args :: T.Protocol p => p -> AcquirePaidCallRoute_args -> P.IO ()
write_AcquirePaidCallRoute_args oprot record = T.writeVal oprot $ from_AcquirePaidCallRoute_args record
encode_AcquirePaidCallRoute_args :: T.StatelessProtocol p => p -> AcquirePaidCallRoute_args -> LBS.ByteString
encode_AcquirePaidCallRoute_args oprot record = T.serializeVal oprot $ from_AcquirePaidCallRoute_args record
to_AcquirePaidCallRoute_args :: T.ThriftVal -> AcquirePaidCallRoute_args
to_AcquirePaidCallRoute_args (T.TStruct fields) = AcquirePaidCallRoute_args{
  acquirePaidCallRoute_args_paidCallType = P.maybe (acquirePaidCallRoute_args_paidCallType default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TI32 _val10657 -> P.toEnum $ P.fromIntegral _val10657; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acquirePaidCallRoute_args_dialedNumber = P.maybe (acquirePaidCallRoute_args_dialedNumber default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TString _val10658 -> E.decodeUtf8 _val10658; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  acquirePaidCallRoute_args_language = P.maybe (acquirePaidCallRoute_args_language default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TString _val10659 -> E.decodeUtf8 _val10659; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  acquirePaidCallRoute_args_networkCode = P.maybe (acquirePaidCallRoute_args_networkCode default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TString _val10660 -> E.decodeUtf8 _val10660; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  acquirePaidCallRoute_args_disableCallerId = P.maybe (acquirePaidCallRoute_args_disableCallerId default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TBool _val10661 -> _val10661; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  acquirePaidCallRoute_args_referer = P.maybe (acquirePaidCallRoute_args_referer default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TString _val10662 -> E.decodeUtf8 _val10662; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  acquirePaidCallRoute_args_adSessionId = P.maybe (acquirePaidCallRoute_args_adSessionId default_AcquirePaidCallRoute_args) (\(_,_val10656) -> (case _val10656 of {T.TString _val10663 -> E.decodeUtf8 _val10663; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_AcquirePaidCallRoute_args _ = P.error "not a struct"
read_AcquirePaidCallRoute_args :: T.Protocol p => p -> P.IO AcquirePaidCallRoute_args
read_AcquirePaidCallRoute_args iprot = to_AcquirePaidCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_args)
decode_AcquirePaidCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallRoute_args
decode_AcquirePaidCallRoute_args iprot bs = to_AcquirePaidCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_args) bs
typemap_AcquirePaidCallRoute_args :: T.TypeMap
typemap_AcquirePaidCallRoute_args = Map.fromList [(2,("paidCallType",T.T_I32)),(3,("dialedNumber",T.T_STRING)),(4,("language",T.T_STRING)),(5,("networkCode",T.T_STRING)),(6,("disableCallerId",T.T_BOOL)),(7,("referer",T.T_STRING)),(8,("adSessionId",T.T_STRING))]
default_AcquirePaidCallRoute_args :: AcquirePaidCallRoute_args
default_AcquirePaidCallRoute_args = AcquirePaidCallRoute_args{
  acquirePaidCallRoute_args_paidCallType = (P.toEnum 0),
  acquirePaidCallRoute_args_dialedNumber = "",
  acquirePaidCallRoute_args_language = "",
  acquirePaidCallRoute_args_networkCode = "",
  acquirePaidCallRoute_args_disableCallerId = P.False,
  acquirePaidCallRoute_args_referer = "",
  acquirePaidCallRoute_args_adSessionId = ""}
data AcquirePaidCallRoute_result = AcquirePaidCallRoute_result  { acquirePaidCallRoute_result_success :: PaidCallResponse
  , acquirePaidCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallRoute_result_success record   `H.hashWithSalt` acquirePaidCallRoute_result_e record  
instance QC.Arbitrary AcquirePaidCallRoute_result where 
  arbitrary = M.liftM AcquirePaidCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = acquirePaidCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = acquirePaidCallRoute_result_success obj}
    , if obj == default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = acquirePaidCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = acquirePaidCallRoute_result_e obj}
    ]
from_AcquirePaidCallRoute_result :: AcquirePaidCallRoute_result -> T.ThriftVal
from_AcquirePaidCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10666 -> (1, ("e",from_TalkException _v10666))) <$> acquirePaidCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10666 -> P.Just (0, ("success",from_PaidCallResponse _v10666))) $ acquirePaidCallRoute_result_success record
    , (\_v10666 -> (1, ("e",from_TalkException _v10666))) <$> acquirePaidCallRoute_result_e record
    ]
    )
write_AcquirePaidCallRoute_result :: T.Protocol p => p -> AcquirePaidCallRoute_result -> P.IO ()
write_AcquirePaidCallRoute_result oprot record = T.writeVal oprot $ from_AcquirePaidCallRoute_result record
encode_AcquirePaidCallRoute_result :: T.StatelessProtocol p => p -> AcquirePaidCallRoute_result -> LBS.ByteString
encode_AcquirePaidCallRoute_result oprot record = T.serializeVal oprot $ from_AcquirePaidCallRoute_result record
to_AcquirePaidCallRoute_result :: T.ThriftVal -> AcquirePaidCallRoute_result
to_AcquirePaidCallRoute_result (T.TStruct fields) = AcquirePaidCallRoute_result{
  acquirePaidCallRoute_result_success = P.maybe (acquirePaidCallRoute_result_success default_AcquirePaidCallRoute_result) (\(_,_val10668) -> (case _val10668 of {T.TStruct _val10669 -> (to_PaidCallResponse (T.TStruct _val10669)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquirePaidCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val10668) -> P.Just (case _val10668 of {T.TStruct _val10670 -> (to_TalkException (T.TStruct _val10670)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquirePaidCallRoute_result _ = P.error "not a struct"
read_AcquirePaidCallRoute_result :: T.Protocol p => p -> P.IO AcquirePaidCallRoute_result
read_AcquirePaidCallRoute_result iprot = to_AcquirePaidCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_result)
decode_AcquirePaidCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallRoute_result
decode_AcquirePaidCallRoute_result iprot bs = to_AcquirePaidCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_result) bs
typemap_AcquirePaidCallRoute_result :: T.TypeMap
typemap_AcquirePaidCallRoute_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquirePaidCallRoute_result :: AcquirePaidCallRoute_result
default_AcquirePaidCallRoute_result = AcquirePaidCallRoute_result{
  acquirePaidCallRoute_result_success = default_PaidCallResponse,
  acquirePaidCallRoute_result_e = P.Nothing}
data GetGroupsForChannel_args = GetGroupsForChannel_args  { getGroupsForChannel_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_args_groupIds record  
instance QC.Arbitrary GetGroupsForChannel_args where 
  arbitrary = M.liftM GetGroupsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj}
    ]
from_GetGroupsForChannel_args :: GetGroupsForChannel_args -> T.ThriftVal
from_GetGroupsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10673 -> P.Just (1, ("groupIds",T.TList T.T_STRING $ P.map (\_v10675 -> T.TString $ E.encodeUtf8 _v10675) $ Vector.toList _v10673))) $ getGroupsForChannel_args_groupIds record
  ]
write_GetGroupsForChannel_args :: T.Protocol p => p -> GetGroupsForChannel_args -> P.IO ()
write_GetGroupsForChannel_args oprot record = T.writeVal oprot $ from_GetGroupsForChannel_args record
encode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> GetGroupsForChannel_args -> LBS.ByteString
encode_GetGroupsForChannel_args oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_args record
to_GetGroupsForChannel_args :: T.ThriftVal -> GetGroupsForChannel_args
to_GetGroupsForChannel_args (T.TStruct fields) = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = P.maybe (getGroupsForChannel_args_groupIds default_GetGroupsForChannel_args) (\(_,_val10677) -> (case _val10677 of {T.TList _ _val10678 -> (Vector.fromList $ P.map (\_v10679 -> (case _v10679 of {T.TString _val10680 -> E.decodeUtf8 _val10680; _ -> P.error "wrong type"})) _val10678); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_args _ = P.error "not a struct"
read_GetGroupsForChannel_args :: T.Protocol p => p -> P.IO GetGroupsForChannel_args
read_GetGroupsForChannel_args iprot = to_GetGroupsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args)
decode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_args
decode_GetGroupsForChannel_args iprot bs = to_GetGroupsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args) bs
typemap_GetGroupsForChannel_args :: T.TypeMap
typemap_GetGroupsForChannel_args = Map.fromList [(1,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroupsForChannel_args :: GetGroupsForChannel_args
default_GetGroupsForChannel_args = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = Vector.empty}
data GetGroupsForChannel_result = GetGroupsForChannel_result  { getGroupsForChannel_result_success :: (Vector.Vector Group)
  , getGroupsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_result_success record   `H.hashWithSalt` getGroupsForChannel_result_e record  
instance QC.Arbitrary GetGroupsForChannel_result where 
  arbitrary = M.liftM GetGroupsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj}
    , if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj}
    ]
from_GetGroupsForChannel_result :: GetGroupsForChannel_result -> T.ThriftVal
from_GetGroupsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10683 -> (1, ("e",from_TalkException _v10683))) <$> getGroupsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10683 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v10685 -> from_Group _v10685) $ Vector.toList _v10683))) $ getGroupsForChannel_result_success record
    , (\_v10683 -> (1, ("e",from_TalkException _v10683))) <$> getGroupsForChannel_result_e record
    ]
    )
write_GetGroupsForChannel_result :: T.Protocol p => p -> GetGroupsForChannel_result -> P.IO ()
write_GetGroupsForChannel_result oprot record = T.writeVal oprot $ from_GetGroupsForChannel_result record
encode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> GetGroupsForChannel_result -> LBS.ByteString
encode_GetGroupsForChannel_result oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_result record
to_GetGroupsForChannel_result :: T.ThriftVal -> GetGroupsForChannel_result
to_GetGroupsForChannel_result (T.TStruct fields) = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = P.maybe (getGroupsForChannel_result_success default_GetGroupsForChannel_result) (\(_,_val10687) -> (case _val10687 of {T.TList _ _val10688 -> (Vector.fromList $ P.map (\_v10689 -> (case _v10689 of {T.TStruct _val10690 -> (to_Group (T.TStruct _val10690)); _ -> P.error "wrong type"})) _val10688); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10687) -> P.Just (case _val10687 of {T.TStruct _val10691 -> (to_TalkException (T.TStruct _val10691)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_result _ = P.error "not a struct"
read_GetGroupsForChannel_result :: T.Protocol p => p -> P.IO GetGroupsForChannel_result
read_GetGroupsForChannel_result iprot = to_GetGroupsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result)
decode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_result
decode_GetGroupsForChannel_result iprot bs = to_GetGroupsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result) bs
typemap_GetGroupsForChannel_result :: T.TypeMap
typemap_GetGroupsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupsForChannel_result :: GetGroupsForChannel_result
default_GetGroupsForChannel_result = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = Vector.empty,
  getGroupsForChannel_result_e = P.Nothing}
data GetUserCreateTime_args = GetUserCreateTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserCreateTime_args where 
  arbitrary = QC.elements [GetUserCreateTime_args]
from_GetUserCreateTime_args :: GetUserCreateTime_args -> T.ThriftVal
from_GetUserCreateTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserCreateTime_args :: T.Protocol p => p -> GetUserCreateTime_args -> P.IO ()
write_GetUserCreateTime_args oprot record = T.writeVal oprot $ from_GetUserCreateTime_args record
encode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> GetUserCreateTime_args -> LBS.ByteString
encode_GetUserCreateTime_args oprot record = T.serializeVal oprot $ from_GetUserCreateTime_args record
to_GetUserCreateTime_args :: T.ThriftVal -> GetUserCreateTime_args
to_GetUserCreateTime_args (T.TStruct fields) = GetUserCreateTime_args{

  }
to_GetUserCreateTime_args _ = P.error "not a struct"
read_GetUserCreateTime_args :: T.Protocol p => p -> P.IO GetUserCreateTime_args
read_GetUserCreateTime_args iprot = to_GetUserCreateTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args)
decode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_args
decode_GetUserCreateTime_args iprot bs = to_GetUserCreateTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args) bs
typemap_GetUserCreateTime_args :: T.TypeMap
typemap_GetUserCreateTime_args = Map.fromList []
default_GetUserCreateTime_args :: GetUserCreateTime_args
default_GetUserCreateTime_args = GetUserCreateTime_args{
}
data GetUserCreateTime_result = GetUserCreateTime_result  { getUserCreateTime_result_success :: I.Int64
  , getUserCreateTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCreateTime_result_success record   `H.hashWithSalt` getUserCreateTime_result_e record  
instance QC.Arbitrary GetUserCreateTime_result where 
  arbitrary = M.liftM GetUserCreateTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCreateTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj}
    , if obj == default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj}
    ]
from_GetUserCreateTime_result :: GetUserCreateTime_result -> T.ThriftVal
from_GetUserCreateTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10699 -> (1, ("e",from_TalkException _v10699))) <$> getUserCreateTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10699 -> P.Just (0, ("success",T.TI64 _v10699))) $ getUserCreateTime_result_success record
    , (\_v10699 -> (1, ("e",from_TalkException _v10699))) <$> getUserCreateTime_result_e record
    ]
    )
write_GetUserCreateTime_result :: T.Protocol p => p -> GetUserCreateTime_result -> P.IO ()
write_GetUserCreateTime_result oprot record = T.writeVal oprot $ from_GetUserCreateTime_result record
encode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> GetUserCreateTime_result -> LBS.ByteString
encode_GetUserCreateTime_result oprot record = T.serializeVal oprot $ from_GetUserCreateTime_result record
to_GetUserCreateTime_result :: T.ThriftVal -> GetUserCreateTime_result
to_GetUserCreateTime_result (T.TStruct fields) = GetUserCreateTime_result{
  getUserCreateTime_result_success = P.maybe (getUserCreateTime_result_success default_GetUserCreateTime_result) (\(_,_val10701) -> (case _val10701 of {T.TI64 _val10702 -> _val10702; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCreateTime_result_e = P.maybe (P.Nothing) (\(_,_val10701) -> P.Just (case _val10701 of {T.TStruct _val10703 -> (to_TalkException (T.TStruct _val10703)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCreateTime_result _ = P.error "not a struct"
read_GetUserCreateTime_result :: T.Protocol p => p -> P.IO GetUserCreateTime_result
read_GetUserCreateTime_result iprot = to_GetUserCreateTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result)
decode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_result
decode_GetUserCreateTime_result iprot bs = to_GetUserCreateTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result) bs
typemap_GetUserCreateTime_result :: T.TypeMap
typemap_GetUserCreateTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCreateTime_result :: GetUserCreateTime_result
default_GetUserCreateTime_result = GetUserCreateTime_result{
  getUserCreateTime_result_success = 0,
  getUserCreateTime_result_e = P.Nothing}
data RegisterChannelCP_args = RegisterChannelCP_args  { registerChannelCP_args_cpId :: LT.Text
  , registerChannelCP_args_registerPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_args_cpId record   `H.hashWithSalt` registerChannelCP_args_registerPassword record  
instance QC.Arbitrary RegisterChannelCP_args where 
  arbitrary = M.liftM RegisterChannelCP_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj}
    , if obj == default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj}
    ]
from_RegisterChannelCP_args :: RegisterChannelCP_args -> T.ThriftVal
from_RegisterChannelCP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10706 -> P.Just (2, ("cpId",T.TString $ E.encodeUtf8 _v10706))) $ registerChannelCP_args_cpId record
  , (\_v10706 -> P.Just (3, ("registerPassword",T.TString $ E.encodeUtf8 _v10706))) $ registerChannelCP_args_registerPassword record
  ]
write_RegisterChannelCP_args :: T.Protocol p => p -> RegisterChannelCP_args -> P.IO ()
write_RegisterChannelCP_args oprot record = T.writeVal oprot $ from_RegisterChannelCP_args record
encode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> RegisterChannelCP_args -> LBS.ByteString
encode_RegisterChannelCP_args oprot record = T.serializeVal oprot $ from_RegisterChannelCP_args record
to_RegisterChannelCP_args :: T.ThriftVal -> RegisterChannelCP_args
to_RegisterChannelCP_args (T.TStruct fields) = RegisterChannelCP_args{
  registerChannelCP_args_cpId = P.maybe (registerChannelCP_args_cpId default_RegisterChannelCP_args) (\(_,_val10708) -> (case _val10708 of {T.TString _val10709 -> E.decodeUtf8 _val10709; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerChannelCP_args_registerPassword = P.maybe (registerChannelCP_args_registerPassword default_RegisterChannelCP_args) (\(_,_val10708) -> (case _val10708 of {T.TString _val10710 -> E.decodeUtf8 _val10710; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterChannelCP_args _ = P.error "not a struct"
read_RegisterChannelCP_args :: T.Protocol p => p -> P.IO RegisterChannelCP_args
read_RegisterChannelCP_args iprot = to_RegisterChannelCP_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args)
decode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_args
decode_RegisterChannelCP_args iprot bs = to_RegisterChannelCP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args) bs
typemap_RegisterChannelCP_args :: T.TypeMap
typemap_RegisterChannelCP_args = Map.fromList [(2,("cpId",T.T_STRING)),(3,("registerPassword",T.T_STRING))]
default_RegisterChannelCP_args :: RegisterChannelCP_args
default_RegisterChannelCP_args = RegisterChannelCP_args{
  registerChannelCP_args_cpId = "",
  registerChannelCP_args_registerPassword = ""}
data RegisterChannelCP_result = RegisterChannelCP_result  { registerChannelCP_result_success :: LT.Text
  , registerChannelCP_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_result_success record   `H.hashWithSalt` registerChannelCP_result_e record  
instance QC.Arbitrary RegisterChannelCP_result where 
  arbitrary = M.liftM RegisterChannelCP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj}
    , if obj == default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj}
    ]
from_RegisterChannelCP_result :: RegisterChannelCP_result -> T.ThriftVal
from_RegisterChannelCP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10713 -> (1, ("e",from_TalkException _v10713))) <$> registerChannelCP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10713 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10713))) $ registerChannelCP_result_success record
    , (\_v10713 -> (1, ("e",from_TalkException _v10713))) <$> registerChannelCP_result_e record
    ]
    )
write_RegisterChannelCP_result :: T.Protocol p => p -> RegisterChannelCP_result -> P.IO ()
write_RegisterChannelCP_result oprot record = T.writeVal oprot $ from_RegisterChannelCP_result record
encode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> RegisterChannelCP_result -> LBS.ByteString
encode_RegisterChannelCP_result oprot record = T.serializeVal oprot $ from_RegisterChannelCP_result record
to_RegisterChannelCP_result :: T.ThriftVal -> RegisterChannelCP_result
to_RegisterChannelCP_result (T.TStruct fields) = RegisterChannelCP_result{
  registerChannelCP_result_success = P.maybe (registerChannelCP_result_success default_RegisterChannelCP_result) (\(_,_val10715) -> (case _val10715 of {T.TString _val10716 -> E.decodeUtf8 _val10716; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerChannelCP_result_e = P.maybe (P.Nothing) (\(_,_val10715) -> P.Just (case _val10715 of {T.TStruct _val10717 -> (to_TalkException (T.TStruct _val10717)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterChannelCP_result _ = P.error "not a struct"
read_RegisterChannelCP_result :: T.Protocol p => p -> P.IO RegisterChannelCP_result
read_RegisterChannelCP_result iprot = to_RegisterChannelCP_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result)
decode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_result
decode_RegisterChannelCP_result iprot bs = to_RegisterChannelCP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result) bs
typemap_RegisterChannelCP_result :: T.TypeMap
typemap_RegisterChannelCP_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterChannelCP_result :: RegisterChannelCP_result
default_RegisterChannelCP_result = RegisterChannelCP_result{
  registerChannelCP_result_success = "",
  registerChannelCP_result_e = P.Nothing}
data ReserveCallCreditPurchase_args = ReserveCallCreditPurchase_args  { reserveCallCreditPurchase_args_request :: CoinPurchaseReservation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCallCreditPurchase_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCallCreditPurchase_args_request record  
instance QC.Arbitrary ReserveCallCreditPurchase_args where 
  arbitrary = M.liftM ReserveCallCreditPurchase_args (QC.arbitrary)
  shrink obj | obj == default_ReserveCallCreditPurchase_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCallCreditPurchase_args{reserveCallCreditPurchase_args_request = reserveCallCreditPurchase_args_request obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_args{reserveCallCreditPurchase_args_request = reserveCallCreditPurchase_args_request obj}
    ]
from_ReserveCallCreditPurchase_args :: ReserveCallCreditPurchase_args -> T.ThriftVal
from_ReserveCallCreditPurchase_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10720 -> P.Just (2, ("request",from_CoinPurchaseReservation _v10720))) $ reserveCallCreditPurchase_args_request record
  ]
write_ReserveCallCreditPurchase_args :: T.Protocol p => p -> ReserveCallCreditPurchase_args -> P.IO ()
write_ReserveCallCreditPurchase_args oprot record = T.writeVal oprot $ from_ReserveCallCreditPurchase_args record
encode_ReserveCallCreditPurchase_args :: T.StatelessProtocol p => p -> ReserveCallCreditPurchase_args -> LBS.ByteString
encode_ReserveCallCreditPurchase_args oprot record = T.serializeVal oprot $ from_ReserveCallCreditPurchase_args record
to_ReserveCallCreditPurchase_args :: T.ThriftVal -> ReserveCallCreditPurchase_args
to_ReserveCallCreditPurchase_args (T.TStruct fields) = ReserveCallCreditPurchase_args{
  reserveCallCreditPurchase_args_request = P.maybe (reserveCallCreditPurchase_args_request default_ReserveCallCreditPurchase_args) (\(_,_val10722) -> (case _val10722 of {T.TStruct _val10723 -> (to_CoinPurchaseReservation (T.TStruct _val10723)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ReserveCallCreditPurchase_args _ = P.error "not a struct"
read_ReserveCallCreditPurchase_args :: T.Protocol p => p -> P.IO ReserveCallCreditPurchase_args
read_ReserveCallCreditPurchase_args iprot = to_ReserveCallCreditPurchase_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_args)
decode_ReserveCallCreditPurchase_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCallCreditPurchase_args
decode_ReserveCallCreditPurchase_args iprot bs = to_ReserveCallCreditPurchase_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_args) bs
typemap_ReserveCallCreditPurchase_args :: T.TypeMap
typemap_ReserveCallCreditPurchase_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinPurchaseReservation)))]
default_ReserveCallCreditPurchase_args :: ReserveCallCreditPurchase_args
default_ReserveCallCreditPurchase_args = ReserveCallCreditPurchase_args{
  reserveCallCreditPurchase_args_request = default_CoinPurchaseReservation}
data ReserveCallCreditPurchase_result = ReserveCallCreditPurchase_result  { reserveCallCreditPurchase_result_success :: PaymentReservationResult
  , reserveCallCreditPurchase_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCallCreditPurchase_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCallCreditPurchase_result_success record   `H.hashWithSalt` reserveCallCreditPurchase_result_e record  
instance QC.Arbitrary ReserveCallCreditPurchase_result where 
  arbitrary = M.liftM ReserveCallCreditPurchase_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCallCreditPurchase_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = reserveCallCreditPurchase_result_success obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = reserveCallCreditPurchase_result_success obj}
    , if obj == default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = reserveCallCreditPurchase_result_e obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = reserveCallCreditPurchase_result_e obj}
    ]
from_ReserveCallCreditPurchase_result :: ReserveCallCreditPurchase_result -> T.ThriftVal
from_ReserveCallCreditPurchase_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10726 -> (1, ("e",from_TalkException _v10726))) <$> reserveCallCreditPurchase_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10726 -> P.Just (0, ("success",from_PaymentReservationResult _v10726))) $ reserveCallCreditPurchase_result_success record
    , (\_v10726 -> (1, ("e",from_TalkException _v10726))) <$> reserveCallCreditPurchase_result_e record
    ]
    )
write_ReserveCallCreditPurchase_result :: T.Protocol p => p -> ReserveCallCreditPurchase_result -> P.IO ()
write_ReserveCallCreditPurchase_result oprot record = T.writeVal oprot $ from_ReserveCallCreditPurchase_result record
encode_ReserveCallCreditPurchase_result :: T.StatelessProtocol p => p -> ReserveCallCreditPurchase_result -> LBS.ByteString
encode_ReserveCallCreditPurchase_result oprot record = T.serializeVal oprot $ from_ReserveCallCreditPurchase_result record
to_ReserveCallCreditPurchase_result :: T.ThriftVal -> ReserveCallCreditPurchase_result
to_ReserveCallCreditPurchase_result (T.TStruct fields) = ReserveCallCreditPurchase_result{
  reserveCallCreditPurchase_result_success = P.maybe (reserveCallCreditPurchase_result_success default_ReserveCallCreditPurchase_result) (\(_,_val10728) -> (case _val10728 of {T.TStruct _val10729 -> (to_PaymentReservationResult (T.TStruct _val10729)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCallCreditPurchase_result_e = P.maybe (P.Nothing) (\(_,_val10728) -> P.Just (case _val10728 of {T.TStruct _val10730 -> (to_TalkException (T.TStruct _val10730)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCallCreditPurchase_result _ = P.error "not a struct"
read_ReserveCallCreditPurchase_result :: T.Protocol p => p -> P.IO ReserveCallCreditPurchase_result
read_ReserveCallCreditPurchase_result iprot = to_ReserveCallCreditPurchase_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_result)
decode_ReserveCallCreditPurchase_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCallCreditPurchase_result
decode_ReserveCallCreditPurchase_result iprot bs = to_ReserveCallCreditPurchase_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_result) bs
typemap_ReserveCallCreditPurchase_result :: T.TypeMap
typemap_ReserveCallCreditPurchase_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaymentReservationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReserveCallCreditPurchase_result :: ReserveCallCreditPurchase_result
default_ReserveCallCreditPurchase_result = ReserveCallCreditPurchase_result{
  reserveCallCreditPurchase_result_success = default_PaymentReservationResult,
  reserveCallCreditPurchase_result_e = P.Nothing}
data AcquirePaidCallCurrencyExchangeRate_args = AcquirePaidCallCurrencyExchangeRate_args  { acquirePaidCallCurrencyExchangeRate_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallCurrencyExchangeRate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_args_language record  
instance QC.Arbitrary AcquirePaidCallCurrencyExchangeRate_args where 
  arbitrary = M.liftM AcquirePaidCallCurrencyExchangeRate_args (QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallCurrencyExchangeRate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallCurrencyExchangeRate_args{acquirePaidCallCurrencyExchangeRate_args_language = acquirePaidCallCurrencyExchangeRate_args_language obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_args{acquirePaidCallCurrencyExchangeRate_args_language = acquirePaidCallCurrencyExchangeRate_args_language obj}
    ]
from_AcquirePaidCallCurrencyExchangeRate_args :: AcquirePaidCallCurrencyExchangeRate_args -> T.ThriftVal
from_AcquirePaidCallCurrencyExchangeRate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10733 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v10733))) $ acquirePaidCallCurrencyExchangeRate_args_language record
  ]
write_AcquirePaidCallCurrencyExchangeRate_args :: T.Protocol p => p -> AcquirePaidCallCurrencyExchangeRate_args -> P.IO ()
write_AcquirePaidCallCurrencyExchangeRate_args oprot record = T.writeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_args record
encode_AcquirePaidCallCurrencyExchangeRate_args :: T.StatelessProtocol p => p -> AcquirePaidCallCurrencyExchangeRate_args -> LBS.ByteString
encode_AcquirePaidCallCurrencyExchangeRate_args oprot record = T.serializeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_args record
to_AcquirePaidCallCurrencyExchangeRate_args :: T.ThriftVal -> AcquirePaidCallCurrencyExchangeRate_args
to_AcquirePaidCallCurrencyExchangeRate_args (T.TStruct fields) = AcquirePaidCallCurrencyExchangeRate_args{
  acquirePaidCallCurrencyExchangeRate_args_language = P.maybe (acquirePaidCallCurrencyExchangeRate_args_language default_AcquirePaidCallCurrencyExchangeRate_args) (\(_,_val10735) -> (case _val10735 of {T.TString _val10736 -> E.decodeUtf8 _val10736; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquirePaidCallCurrencyExchangeRate_args _ = P.error "not a struct"
read_AcquirePaidCallCurrencyExchangeRate_args :: T.Protocol p => p -> P.IO AcquirePaidCallCurrencyExchangeRate_args
read_AcquirePaidCallCurrencyExchangeRate_args iprot = to_AcquirePaidCallCurrencyExchangeRate_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_args)
decode_AcquirePaidCallCurrencyExchangeRate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallCurrencyExchangeRate_args
decode_AcquirePaidCallCurrencyExchangeRate_args iprot bs = to_AcquirePaidCallCurrencyExchangeRate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_args) bs
typemap_AcquirePaidCallCurrencyExchangeRate_args :: T.TypeMap
typemap_AcquirePaidCallCurrencyExchangeRate_args = Map.fromList [(2,("language",T.T_STRING))]
default_AcquirePaidCallCurrencyExchangeRate_args :: AcquirePaidCallCurrencyExchangeRate_args
default_AcquirePaidCallCurrencyExchangeRate_args = AcquirePaidCallCurrencyExchangeRate_args{
  acquirePaidCallCurrencyExchangeRate_args_language = ""}
data AcquirePaidCallCurrencyExchangeRate_result = AcquirePaidCallCurrencyExchangeRate_result  { acquirePaidCallCurrencyExchangeRate_result_success :: (Vector.Vector PaidCallCurrencyExchangeRate)
  , acquirePaidCallCurrencyExchangeRate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallCurrencyExchangeRate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_result_success record   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_result_e record  
instance QC.Arbitrary AcquirePaidCallCurrencyExchangeRate_result where 
  arbitrary = M.liftM AcquirePaidCallCurrencyExchangeRate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallCurrencyExchangeRate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = acquirePaidCallCurrencyExchangeRate_result_success obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = acquirePaidCallCurrencyExchangeRate_result_success obj}
    , if obj == default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = acquirePaidCallCurrencyExchangeRate_result_e obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = acquirePaidCallCurrencyExchangeRate_result_e obj}
    ]
from_AcquirePaidCallCurrencyExchangeRate_result :: AcquirePaidCallCurrencyExchangeRate_result -> T.ThriftVal
from_AcquirePaidCallCurrencyExchangeRate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10739 -> (1, ("e",from_TalkException _v10739))) <$> acquirePaidCallCurrencyExchangeRate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10739 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate) $ P.map (\_v10741 -> from_PaidCallCurrencyExchangeRate _v10741) $ Vector.toList _v10739))) $ acquirePaidCallCurrencyExchangeRate_result_success record
    , (\_v10739 -> (1, ("e",from_TalkException _v10739))) <$> acquirePaidCallCurrencyExchangeRate_result_e record
    ]
    )
write_AcquirePaidCallCurrencyExchangeRate_result :: T.Protocol p => p -> AcquirePaidCallCurrencyExchangeRate_result -> P.IO ()
write_AcquirePaidCallCurrencyExchangeRate_result oprot record = T.writeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_result record
encode_AcquirePaidCallCurrencyExchangeRate_result :: T.StatelessProtocol p => p -> AcquirePaidCallCurrencyExchangeRate_result -> LBS.ByteString
encode_AcquirePaidCallCurrencyExchangeRate_result oprot record = T.serializeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_result record
to_AcquirePaidCallCurrencyExchangeRate_result :: T.ThriftVal -> AcquirePaidCallCurrencyExchangeRate_result
to_AcquirePaidCallCurrencyExchangeRate_result (T.TStruct fields) = AcquirePaidCallCurrencyExchangeRate_result{
  acquirePaidCallCurrencyExchangeRate_result_success = P.maybe (acquirePaidCallCurrencyExchangeRate_result_success default_AcquirePaidCallCurrencyExchangeRate_result) (\(_,_val10743) -> (case _val10743 of {T.TList _ _val10744 -> (Vector.fromList $ P.map (\_v10745 -> (case _v10745 of {T.TStruct _val10746 -> (to_PaidCallCurrencyExchangeRate (T.TStruct _val10746)); _ -> P.error "wrong type"})) _val10744); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquirePaidCallCurrencyExchangeRate_result_e = P.maybe (P.Nothing) (\(_,_val10743) -> P.Just (case _val10743 of {T.TStruct _val10747 -> (to_TalkException (T.TStruct _val10747)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquirePaidCallCurrencyExchangeRate_result _ = P.error "not a struct"
read_AcquirePaidCallCurrencyExchangeRate_result :: T.Protocol p => p -> P.IO AcquirePaidCallCurrencyExchangeRate_result
read_AcquirePaidCallCurrencyExchangeRate_result iprot = to_AcquirePaidCallCurrencyExchangeRate_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_result)
decode_AcquirePaidCallCurrencyExchangeRate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallCurrencyExchangeRate_result
decode_AcquirePaidCallCurrencyExchangeRate_result iprot bs = to_AcquirePaidCallCurrencyExchangeRate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_result) bs
typemap_AcquirePaidCallCurrencyExchangeRate_result :: T.TypeMap
typemap_AcquirePaidCallCurrencyExchangeRate_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquirePaidCallCurrencyExchangeRate_result :: AcquirePaidCallCurrencyExchangeRate_result
default_AcquirePaidCallCurrencyExchangeRate_result = AcquirePaidCallCurrencyExchangeRate_result{
  acquirePaidCallCurrencyExchangeRate_result_success = Vector.empty,
  acquirePaidCallCurrencyExchangeRate_result_e = P.Nothing}
data GetRoomMemberMidsForAppPlatform_args = GetRoomMemberMidsForAppPlatform_args  { getRoomMemberMidsForAppPlatform_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomMemberMidsForAppPlatform_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_args_roomId record  
instance QC.Arbitrary GetRoomMemberMidsForAppPlatform_args where 
  arbitrary = M.liftM GetRoomMemberMidsForAppPlatform_args (QC.arbitrary)
  shrink obj | obj == default_GetRoomMemberMidsForAppPlatform_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomMemberMidsForAppPlatform_args{getRoomMemberMidsForAppPlatform_args_roomId = getRoomMemberMidsForAppPlatform_args_roomId obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_args{getRoomMemberMidsForAppPlatform_args_roomId = getRoomMemberMidsForAppPlatform_args_roomId obj}
    ]
from_GetRoomMemberMidsForAppPlatform_args :: GetRoomMemberMidsForAppPlatform_args -> T.ThriftVal
from_GetRoomMemberMidsForAppPlatform_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10750 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10750))) $ getRoomMemberMidsForAppPlatform_args_roomId record
  ]
write_GetRoomMemberMidsForAppPlatform_args :: T.Protocol p => p -> GetRoomMemberMidsForAppPlatform_args -> P.IO ()
write_GetRoomMemberMidsForAppPlatform_args oprot record = T.writeVal oprot $ from_GetRoomMemberMidsForAppPlatform_args record
encode_GetRoomMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> GetRoomMemberMidsForAppPlatform_args -> LBS.ByteString
encode_GetRoomMemberMidsForAppPlatform_args oprot record = T.serializeVal oprot $ from_GetRoomMemberMidsForAppPlatform_args record
to_GetRoomMemberMidsForAppPlatform_args :: T.ThriftVal -> GetRoomMemberMidsForAppPlatform_args
to_GetRoomMemberMidsForAppPlatform_args (T.TStruct fields) = GetRoomMemberMidsForAppPlatform_args{
  getRoomMemberMidsForAppPlatform_args_roomId = P.maybe (getRoomMemberMidsForAppPlatform_args_roomId default_GetRoomMemberMidsForAppPlatform_args) (\(_,_val10752) -> (case _val10752 of {T.TString _val10753 -> E.decodeUtf8 _val10753; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomMemberMidsForAppPlatform_args _ = P.error "not a struct"
read_GetRoomMemberMidsForAppPlatform_args :: T.Protocol p => p -> P.IO GetRoomMemberMidsForAppPlatform_args
read_GetRoomMemberMidsForAppPlatform_args iprot = to_GetRoomMemberMidsForAppPlatform_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_args)
decode_GetRoomMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomMemberMidsForAppPlatform_args
decode_GetRoomMemberMidsForAppPlatform_args iprot bs = to_GetRoomMemberMidsForAppPlatform_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_args) bs
typemap_GetRoomMemberMidsForAppPlatform_args :: T.TypeMap
typemap_GetRoomMemberMidsForAppPlatform_args = Map.fromList [(1,("roomId",T.T_STRING))]
default_GetRoomMemberMidsForAppPlatform_args :: GetRoomMemberMidsForAppPlatform_args
default_GetRoomMemberMidsForAppPlatform_args = GetRoomMemberMidsForAppPlatform_args{
  getRoomMemberMidsForAppPlatform_args_roomId = ""}
data GetRoomMemberMidsForAppPlatform_result = GetRoomMemberMidsForAppPlatform_result  { getRoomMemberMidsForAppPlatform_result_success :: (Vector.Vector LT.Text)
  , getRoomMemberMidsForAppPlatform_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomMemberMidsForAppPlatform_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_result_success record   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_result_e record  
instance QC.Arbitrary GetRoomMemberMidsForAppPlatform_result where 
  arbitrary = M.liftM GetRoomMemberMidsForAppPlatform_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoomMemberMidsForAppPlatform_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = getRoomMemberMidsForAppPlatform_result_success obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = getRoomMemberMidsForAppPlatform_result_success obj}
    , if obj == default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = getRoomMemberMidsForAppPlatform_result_e obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = getRoomMemberMidsForAppPlatform_result_e obj}
    ]
from_GetRoomMemberMidsForAppPlatform_result :: GetRoomMemberMidsForAppPlatform_result -> T.ThriftVal
from_GetRoomMemberMidsForAppPlatform_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10756 -> (1, ("e",from_TalkException _v10756))) <$> getRoomMemberMidsForAppPlatform_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10756 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10758 -> T.TString $ E.encodeUtf8 _v10758) $ Vector.toList _v10756))) $ getRoomMemberMidsForAppPlatform_result_success record
    , (\_v10756 -> (1, ("e",from_TalkException _v10756))) <$> getRoomMemberMidsForAppPlatform_result_e record
    ]
    )
write_GetRoomMemberMidsForAppPlatform_result :: T.Protocol p => p -> GetRoomMemberMidsForAppPlatform_result -> P.IO ()
write_GetRoomMemberMidsForAppPlatform_result oprot record = T.writeVal oprot $ from_GetRoomMemberMidsForAppPlatform_result record
encode_GetRoomMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> GetRoomMemberMidsForAppPlatform_result -> LBS.ByteString
encode_GetRoomMemberMidsForAppPlatform_result oprot record = T.serializeVal oprot $ from_GetRoomMemberMidsForAppPlatform_result record
to_GetRoomMemberMidsForAppPlatform_result :: T.ThriftVal -> GetRoomMemberMidsForAppPlatform_result
to_GetRoomMemberMidsForAppPlatform_result (T.TStruct fields) = GetRoomMemberMidsForAppPlatform_result{
  getRoomMemberMidsForAppPlatform_result_success = P.maybe (getRoomMemberMidsForAppPlatform_result_success default_GetRoomMemberMidsForAppPlatform_result) (\(_,_val10760) -> (case _val10760 of {T.TList _ _val10761 -> (Vector.fromList $ P.map (\_v10762 -> (case _v10762 of {T.TString _val10763 -> E.decodeUtf8 _val10763; _ -> P.error "wrong type"})) _val10761); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoomMemberMidsForAppPlatform_result_e = P.maybe (P.Nothing) (\(_,_val10760) -> P.Just (case _val10760 of {T.TStruct _val10764 -> (to_TalkException (T.TStruct _val10764)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomMemberMidsForAppPlatform_result _ = P.error "not a struct"
read_GetRoomMemberMidsForAppPlatform_result :: T.Protocol p => p -> P.IO GetRoomMemberMidsForAppPlatform_result
read_GetRoomMemberMidsForAppPlatform_result iprot = to_GetRoomMemberMidsForAppPlatform_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_result)
decode_GetRoomMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomMemberMidsForAppPlatform_result
decode_GetRoomMemberMidsForAppPlatform_result iprot bs = to_GetRoomMemberMidsForAppPlatform_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_result) bs
typemap_GetRoomMemberMidsForAppPlatform_result :: T.TypeMap
typemap_GetRoomMemberMidsForAppPlatform_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoomMemberMidsForAppPlatform_result :: GetRoomMemberMidsForAppPlatform_result
default_GetRoomMemberMidsForAppPlatform_result = GetRoomMemberMidsForAppPlatform_result{
  getRoomMemberMidsForAppPlatform_result_success = Vector.empty,
  getRoomMemberMidsForAppPlatform_result_e = P.Nothing}
data GetPaidCallBalanceList_args = GetPaidCallBalanceList_args  { getPaidCallBalanceList_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallBalanceList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallBalanceList_args_language record  
instance QC.Arbitrary GetPaidCallBalanceList_args where 
  arbitrary = M.liftM GetPaidCallBalanceList_args (QC.arbitrary)
  shrink obj | obj == default_GetPaidCallBalanceList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallBalanceList_args{getPaidCallBalanceList_args_language = getPaidCallBalanceList_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_args{getPaidCallBalanceList_args_language = getPaidCallBalanceList_args_language obj}
    ]
from_GetPaidCallBalanceList_args :: GetPaidCallBalanceList_args -> T.ThriftVal
from_GetPaidCallBalanceList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10767 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v10767))) $ getPaidCallBalanceList_args_language record
  ]
write_GetPaidCallBalanceList_args :: T.Protocol p => p -> GetPaidCallBalanceList_args -> P.IO ()
write_GetPaidCallBalanceList_args oprot record = T.writeVal oprot $ from_GetPaidCallBalanceList_args record
encode_GetPaidCallBalanceList_args :: T.StatelessProtocol p => p -> GetPaidCallBalanceList_args -> LBS.ByteString
encode_GetPaidCallBalanceList_args oprot record = T.serializeVal oprot $ from_GetPaidCallBalanceList_args record
to_GetPaidCallBalanceList_args :: T.ThriftVal -> GetPaidCallBalanceList_args
to_GetPaidCallBalanceList_args (T.TStruct fields) = GetPaidCallBalanceList_args{
  getPaidCallBalanceList_args_language = P.maybe (getPaidCallBalanceList_args_language default_GetPaidCallBalanceList_args) (\(_,_val10769) -> (case _val10769 of {T.TString _val10770 -> E.decodeUtf8 _val10770; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPaidCallBalanceList_args _ = P.error "not a struct"
read_GetPaidCallBalanceList_args :: T.Protocol p => p -> P.IO GetPaidCallBalanceList_args
read_GetPaidCallBalanceList_args iprot = to_GetPaidCallBalanceList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_args)
decode_GetPaidCallBalanceList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallBalanceList_args
decode_GetPaidCallBalanceList_args iprot bs = to_GetPaidCallBalanceList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_args) bs
typemap_GetPaidCallBalanceList_args :: T.TypeMap
typemap_GetPaidCallBalanceList_args = Map.fromList [(2,("language",T.T_STRING))]
default_GetPaidCallBalanceList_args :: GetPaidCallBalanceList_args
default_GetPaidCallBalanceList_args = GetPaidCallBalanceList_args{
  getPaidCallBalanceList_args_language = ""}
data GetPaidCallBalanceList_result = GetPaidCallBalanceList_result  { getPaidCallBalanceList_result_success :: (Vector.Vector PaidCallBalance)
  , getPaidCallBalanceList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallBalanceList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallBalanceList_result_success record   `H.hashWithSalt` getPaidCallBalanceList_result_e record  
instance QC.Arbitrary GetPaidCallBalanceList_result where 
  arbitrary = M.liftM GetPaidCallBalanceList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallBalanceList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = getPaidCallBalanceList_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = getPaidCallBalanceList_result_success obj}
    , if obj == default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = getPaidCallBalanceList_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = getPaidCallBalanceList_result_e obj}
    ]
from_GetPaidCallBalanceList_result :: GetPaidCallBalanceList_result -> T.ThriftVal
from_GetPaidCallBalanceList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10773 -> (1, ("e",from_TalkException _v10773))) <$> getPaidCallBalanceList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10773 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallBalance) $ P.map (\_v10775 -> from_PaidCallBalance _v10775) $ Vector.toList _v10773))) $ getPaidCallBalanceList_result_success record
    , (\_v10773 -> (1, ("e",from_TalkException _v10773))) <$> getPaidCallBalanceList_result_e record
    ]
    )
write_GetPaidCallBalanceList_result :: T.Protocol p => p -> GetPaidCallBalanceList_result -> P.IO ()
write_GetPaidCallBalanceList_result oprot record = T.writeVal oprot $ from_GetPaidCallBalanceList_result record
encode_GetPaidCallBalanceList_result :: T.StatelessProtocol p => p -> GetPaidCallBalanceList_result -> LBS.ByteString
encode_GetPaidCallBalanceList_result oprot record = T.serializeVal oprot $ from_GetPaidCallBalanceList_result record
to_GetPaidCallBalanceList_result :: T.ThriftVal -> GetPaidCallBalanceList_result
to_GetPaidCallBalanceList_result (T.TStruct fields) = GetPaidCallBalanceList_result{
  getPaidCallBalanceList_result_success = P.maybe (getPaidCallBalanceList_result_success default_GetPaidCallBalanceList_result) (\(_,_val10777) -> (case _val10777 of {T.TList _ _val10778 -> (Vector.fromList $ P.map (\_v10779 -> (case _v10779 of {T.TStruct _val10780 -> (to_PaidCallBalance (T.TStruct _val10780)); _ -> P.error "wrong type"})) _val10778); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallBalanceList_result_e = P.maybe (P.Nothing) (\(_,_val10777) -> P.Just (case _val10777 of {T.TStruct _val10781 -> (to_TalkException (T.TStruct _val10781)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallBalanceList_result _ = P.error "not a struct"
read_GetPaidCallBalanceList_result :: T.Protocol p => p -> P.IO GetPaidCallBalanceList_result
read_GetPaidCallBalanceList_result iprot = to_GetPaidCallBalanceList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_result)
decode_GetPaidCallBalanceList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallBalanceList_result
decode_GetPaidCallBalanceList_result iprot bs = to_GetPaidCallBalanceList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_result) bs
typemap_GetPaidCallBalanceList_result :: T.TypeMap
typemap_GetPaidCallBalanceList_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallBalance)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallBalanceList_result :: GetPaidCallBalanceList_result
default_GetPaidCallBalanceList_result = GetPaidCallBalanceList_result{
  getPaidCallBalanceList_result_success = Vector.empty,
  getPaidCallBalanceList_result_e = P.Nothing}
data GetPersonalInfos_args = GetPersonalInfos_args  { getPersonalInfos_args_requiredPersonalInfos :: (Set.HashSet PersonalInfo)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPersonalInfos_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPersonalInfos_args_requiredPersonalInfos record  
instance QC.Arbitrary GetPersonalInfos_args where 
  arbitrary = M.liftM GetPersonalInfos_args (QC.arbitrary)
  shrink obj | obj == default_GetPersonalInfos_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPersonalInfos_args{getPersonalInfos_args_requiredPersonalInfos = getPersonalInfos_args_requiredPersonalInfos obj} then P.Nothing else P.Just $ default_GetPersonalInfos_args{getPersonalInfos_args_requiredPersonalInfos = getPersonalInfos_args_requiredPersonalInfos obj}
    ]
from_GetPersonalInfos_args :: GetPersonalInfos_args -> T.ThriftVal
from_GetPersonalInfos_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10784 -> P.Just (1, ("requiredPersonalInfos",T.TSet T.T_I32 $ P.map (\_v10786 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v10786) $ Set.toList _v10784))) $ getPersonalInfos_args_requiredPersonalInfos record
  ]
write_GetPersonalInfos_args :: T.Protocol p => p -> GetPersonalInfos_args -> P.IO ()
write_GetPersonalInfos_args oprot record = T.writeVal oprot $ from_GetPersonalInfos_args record
encode_GetPersonalInfos_args :: T.StatelessProtocol p => p -> GetPersonalInfos_args -> LBS.ByteString
encode_GetPersonalInfos_args oprot record = T.serializeVal oprot $ from_GetPersonalInfos_args record
to_GetPersonalInfos_args :: T.ThriftVal -> GetPersonalInfos_args
to_GetPersonalInfos_args (T.TStruct fields) = GetPersonalInfos_args{
  getPersonalInfos_args_requiredPersonalInfos = P.maybe (getPersonalInfos_args_requiredPersonalInfos default_GetPersonalInfos_args) (\(_,_val10788) -> (case _val10788 of {T.TSet _ _val10789 -> (Set.fromList $ P.map (\_v10790 -> (case _v10790 of {T.TI32 _val10791 -> P.toEnum $ P.fromIntegral _val10791; _ -> P.error "wrong type"})) _val10789); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPersonalInfos_args _ = P.error "not a struct"
read_GetPersonalInfos_args :: T.Protocol p => p -> P.IO GetPersonalInfos_args
read_GetPersonalInfos_args iprot = to_GetPersonalInfos_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPersonalInfos_args)
decode_GetPersonalInfos_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPersonalInfos_args
decode_GetPersonalInfos_args iprot bs = to_GetPersonalInfos_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPersonalInfos_args) bs
typemap_GetPersonalInfos_args :: T.TypeMap
typemap_GetPersonalInfos_args = Map.fromList [(1,("requiredPersonalInfos",(T.T_SET T.T_I32)))]
default_GetPersonalInfos_args :: GetPersonalInfos_args
default_GetPersonalInfos_args = GetPersonalInfos_args{
  getPersonalInfos_args_requiredPersonalInfos = Set.empty}
data GetPersonalInfos_result = GetPersonalInfos_result  { getPersonalInfos_result_success :: (Map.HashMap PersonalInfo LT.Text)
  , getPersonalInfos_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPersonalInfos_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPersonalInfos_result_success record   `H.hashWithSalt` getPersonalInfos_result_e record  
instance QC.Arbitrary GetPersonalInfos_result where 
  arbitrary = M.liftM GetPersonalInfos_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPersonalInfos_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPersonalInfos_result{getPersonalInfos_result_success = getPersonalInfos_result_success obj} then P.Nothing else P.Just $ default_GetPersonalInfos_result{getPersonalInfos_result_success = getPersonalInfos_result_success obj}
    , if obj == default_GetPersonalInfos_result{getPersonalInfos_result_e = getPersonalInfos_result_e obj} then P.Nothing else P.Just $ default_GetPersonalInfos_result{getPersonalInfos_result_e = getPersonalInfos_result_e obj}
    ]
from_GetPersonalInfos_result :: GetPersonalInfos_result -> T.ThriftVal
from_GetPersonalInfos_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10794 -> (1, ("e",from_TalkException _v10794))) <$> getPersonalInfos_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10794 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k10795,_v10796) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k10795, T.TString $ E.encodeUtf8 _v10796)) $ Map.toList _v10794))) $ getPersonalInfos_result_success record
    , (\_v10794 -> (1, ("e",from_TalkException _v10794))) <$> getPersonalInfos_result_e record
    ]
    )
write_GetPersonalInfos_result :: T.Protocol p => p -> GetPersonalInfos_result -> P.IO ()
write_GetPersonalInfos_result oprot record = T.writeVal oprot $ from_GetPersonalInfos_result record
encode_GetPersonalInfos_result :: T.StatelessProtocol p => p -> GetPersonalInfos_result -> LBS.ByteString
encode_GetPersonalInfos_result oprot record = T.serializeVal oprot $ from_GetPersonalInfos_result record
to_GetPersonalInfos_result :: T.ThriftVal -> GetPersonalInfos_result
to_GetPersonalInfos_result (T.TStruct fields) = GetPersonalInfos_result{
  getPersonalInfos_result_success = P.maybe (getPersonalInfos_result_success default_GetPersonalInfos_result) (\(_,_val10798) -> (case _val10798 of {T.TMap _ _ _val10799 -> (Map.fromList $ P.map (\(_k10801,_v10800) -> ((case _k10801 of {T.TI32 _val10802 -> P.toEnum $ P.fromIntegral _val10802; _ -> P.error "wrong type"}),(case _v10800 of {T.TString _val10803 -> E.decodeUtf8 _val10803; _ -> P.error "wrong type"}))) _val10799); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPersonalInfos_result_e = P.maybe (P.Nothing) (\(_,_val10798) -> P.Just (case _val10798 of {T.TStruct _val10804 -> (to_TalkException (T.TStruct _val10804)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPersonalInfos_result _ = P.error "not a struct"
read_GetPersonalInfos_result :: T.Protocol p => p -> P.IO GetPersonalInfos_result
read_GetPersonalInfos_result iprot = to_GetPersonalInfos_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPersonalInfos_result)
decode_GetPersonalInfos_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPersonalInfos_result
decode_GetPersonalInfos_result iprot bs = to_GetPersonalInfos_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPersonalInfos_result) bs
typemap_GetPersonalInfos_result :: T.TypeMap
typemap_GetPersonalInfos_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPersonalInfos_result :: GetPersonalInfos_result
default_GetPersonalInfos_result = GetPersonalInfos_result{
  getPersonalInfos_result_success = Map.empty,
  getPersonalInfos_result_e = P.Nothing}
data GetPrimaryClientsForChannel_args = GetPrimaryClientsForChannel_args  { getPrimaryClientsForChannel_args_userMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientsForChannel_args_userMids record  
instance QC.Arbitrary GetPrimaryClientsForChannel_args where 
  arbitrary = M.liftM GetPrimaryClientsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientsForChannel_args{getPrimaryClientsForChannel_args_userMids = getPrimaryClientsForChannel_args_userMids obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_args{getPrimaryClientsForChannel_args_userMids = getPrimaryClientsForChannel_args_userMids obj}
    ]
from_GetPrimaryClientsForChannel_args :: GetPrimaryClientsForChannel_args -> T.ThriftVal
from_GetPrimaryClientsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10807 -> P.Just (1, ("userMids",T.TList T.T_STRING $ P.map (\_v10809 -> T.TString $ E.encodeUtf8 _v10809) $ Vector.toList _v10807))) $ getPrimaryClientsForChannel_args_userMids record
  ]
write_GetPrimaryClientsForChannel_args :: T.Protocol p => p -> GetPrimaryClientsForChannel_args -> P.IO ()
write_GetPrimaryClientsForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientsForChannel_args record
encode_GetPrimaryClientsForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientsForChannel_args -> LBS.ByteString
encode_GetPrimaryClientsForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientsForChannel_args record
to_GetPrimaryClientsForChannel_args :: T.ThriftVal -> GetPrimaryClientsForChannel_args
to_GetPrimaryClientsForChannel_args (T.TStruct fields) = GetPrimaryClientsForChannel_args{
  getPrimaryClientsForChannel_args_userMids = P.maybe (getPrimaryClientsForChannel_args_userMids default_GetPrimaryClientsForChannel_args) (\(_,_val10811) -> (case _val10811 of {T.TList _ _val10812 -> (Vector.fromList $ P.map (\_v10813 -> (case _v10813 of {T.TString _val10814 -> E.decodeUtf8 _val10814; _ -> P.error "wrong type"})) _val10812); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientsForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientsForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientsForChannel_args
read_GetPrimaryClientsForChannel_args iprot = to_GetPrimaryClientsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_args)
decode_GetPrimaryClientsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientsForChannel_args
decode_GetPrimaryClientsForChannel_args iprot bs = to_GetPrimaryClientsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_args) bs
typemap_GetPrimaryClientsForChannel_args :: T.TypeMap
typemap_GetPrimaryClientsForChannel_args = Map.fromList [(1,("userMids",(T.T_LIST T.T_STRING)))]
default_GetPrimaryClientsForChannel_args :: GetPrimaryClientsForChannel_args
default_GetPrimaryClientsForChannel_args = GetPrimaryClientsForChannel_args{
  getPrimaryClientsForChannel_args_userMids = Vector.empty}
data GetPrimaryClientsForChannel_result = GetPrimaryClientsForChannel_result  { getPrimaryClientsForChannel_result_success :: (Vector.Vector SimpleChannelClient)
  , getPrimaryClientsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientsForChannel_result_success record   `H.hashWithSalt` getPrimaryClientsForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientsForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = getPrimaryClientsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = getPrimaryClientsForChannel_result_success obj}
    , if obj == default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = getPrimaryClientsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = getPrimaryClientsForChannel_result_e obj}
    ]
from_GetPrimaryClientsForChannel_result :: GetPrimaryClientsForChannel_result -> T.ThriftVal
from_GetPrimaryClientsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10817 -> (1, ("e",from_TalkException _v10817))) <$> getPrimaryClientsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10817 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelClient) $ P.map (\_v10819 -> from_SimpleChannelClient _v10819) $ Vector.toList _v10817))) $ getPrimaryClientsForChannel_result_success record
    , (\_v10817 -> (1, ("e",from_TalkException _v10817))) <$> getPrimaryClientsForChannel_result_e record
    ]
    )
write_GetPrimaryClientsForChannel_result :: T.Protocol p => p -> GetPrimaryClientsForChannel_result -> P.IO ()
write_GetPrimaryClientsForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientsForChannel_result record
encode_GetPrimaryClientsForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientsForChannel_result -> LBS.ByteString
encode_GetPrimaryClientsForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientsForChannel_result record
to_GetPrimaryClientsForChannel_result :: T.ThriftVal -> GetPrimaryClientsForChannel_result
to_GetPrimaryClientsForChannel_result (T.TStruct fields) = GetPrimaryClientsForChannel_result{
  getPrimaryClientsForChannel_result_success = P.maybe (getPrimaryClientsForChannel_result_success default_GetPrimaryClientsForChannel_result) (\(_,_val10821) -> (case _val10821 of {T.TList _ _val10822 -> (Vector.fromList $ P.map (\_v10823 -> (case _v10823 of {T.TStruct _val10824 -> (to_SimpleChannelClient (T.TStruct _val10824)); _ -> P.error "wrong type"})) _val10822); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10821) -> P.Just (case _val10821 of {T.TStruct _val10825 -> (to_TalkException (T.TStruct _val10825)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientsForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientsForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientsForChannel_result
read_GetPrimaryClientsForChannel_result iprot = to_GetPrimaryClientsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_result)
decode_GetPrimaryClientsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientsForChannel_result
decode_GetPrimaryClientsForChannel_result iprot bs = to_GetPrimaryClientsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_result) bs
typemap_GetPrimaryClientsForChannel_result :: T.TypeMap
typemap_GetPrimaryClientsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelClient)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientsForChannel_result :: GetPrimaryClientsForChannel_result
default_GetPrimaryClientsForChannel_result = GetPrimaryClientsForChannel_result{
  getPrimaryClientsForChannel_result_success = Vector.empty,
  getPrimaryClientsForChannel_result_e = P.Nothing}
data AddBuddyToContact_args = AddBuddyToContact_args  { addBuddyToContact_args_buddyMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddBuddyToContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addBuddyToContact_args_buddyMid record  
instance QC.Arbitrary AddBuddyToContact_args where 
  arbitrary = M.liftM AddBuddyToContact_args (QC.arbitrary)
  shrink obj | obj == default_AddBuddyToContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddBuddyToContact_args{addBuddyToContact_args_buddyMid = addBuddyToContact_args_buddyMid obj} then P.Nothing else P.Just $ default_AddBuddyToContact_args{addBuddyToContact_args_buddyMid = addBuddyToContact_args_buddyMid obj}
    ]
from_AddBuddyToContact_args :: AddBuddyToContact_args -> T.ThriftVal
from_AddBuddyToContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10828 -> P.Just (1, ("buddyMid",T.TString $ E.encodeUtf8 _v10828))) $ addBuddyToContact_args_buddyMid record
  ]
write_AddBuddyToContact_args :: T.Protocol p => p -> AddBuddyToContact_args -> P.IO ()
write_AddBuddyToContact_args oprot record = T.writeVal oprot $ from_AddBuddyToContact_args record
encode_AddBuddyToContact_args :: T.StatelessProtocol p => p -> AddBuddyToContact_args -> LBS.ByteString
encode_AddBuddyToContact_args oprot record = T.serializeVal oprot $ from_AddBuddyToContact_args record
to_AddBuddyToContact_args :: T.ThriftVal -> AddBuddyToContact_args
to_AddBuddyToContact_args (T.TStruct fields) = AddBuddyToContact_args{
  addBuddyToContact_args_buddyMid = P.maybe (addBuddyToContact_args_buddyMid default_AddBuddyToContact_args) (\(_,_val10830) -> (case _val10830 of {T.TString _val10831 -> E.decodeUtf8 _val10831; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddBuddyToContact_args _ = P.error "not a struct"
read_AddBuddyToContact_args :: T.Protocol p => p -> P.IO AddBuddyToContact_args
read_AddBuddyToContact_args iprot = to_AddBuddyToContact_args <$> T.readVal iprot (T.T_STRUCT typemap_AddBuddyToContact_args)
decode_AddBuddyToContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddBuddyToContact_args
decode_AddBuddyToContact_args iprot bs = to_AddBuddyToContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddBuddyToContact_args) bs
typemap_AddBuddyToContact_args :: T.TypeMap
typemap_AddBuddyToContact_args = Map.fromList [(1,("buddyMid",T.T_STRING))]
default_AddBuddyToContact_args :: AddBuddyToContact_args
default_AddBuddyToContact_args = AddBuddyToContact_args{
  addBuddyToContact_args_buddyMid = ""}
data AddBuddyToContact_result = AddBuddyToContact_result  { addBuddyToContact_result_success :: ContactTransition
  , addBuddyToContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddBuddyToContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addBuddyToContact_result_success record   `H.hashWithSalt` addBuddyToContact_result_e record  
instance QC.Arbitrary AddBuddyToContact_result where 
  arbitrary = M.liftM AddBuddyToContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddBuddyToContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddBuddyToContact_result{addBuddyToContact_result_success = addBuddyToContact_result_success obj} then P.Nothing else P.Just $ default_AddBuddyToContact_result{addBuddyToContact_result_success = addBuddyToContact_result_success obj}
    , if obj == default_AddBuddyToContact_result{addBuddyToContact_result_e = addBuddyToContact_result_e obj} then P.Nothing else P.Just $ default_AddBuddyToContact_result{addBuddyToContact_result_e = addBuddyToContact_result_e obj}
    ]
from_AddBuddyToContact_result :: AddBuddyToContact_result -> T.ThriftVal
from_AddBuddyToContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10834 -> (1, ("e",from_TalkException _v10834))) <$> addBuddyToContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10834 -> P.Just (0, ("success",from_ContactTransition _v10834))) $ addBuddyToContact_result_success record
    , (\_v10834 -> (1, ("e",from_TalkException _v10834))) <$> addBuddyToContact_result_e record
    ]
    )
write_AddBuddyToContact_result :: T.Protocol p => p -> AddBuddyToContact_result -> P.IO ()
write_AddBuddyToContact_result oprot record = T.writeVal oprot $ from_AddBuddyToContact_result record
encode_AddBuddyToContact_result :: T.StatelessProtocol p => p -> AddBuddyToContact_result -> LBS.ByteString
encode_AddBuddyToContact_result oprot record = T.serializeVal oprot $ from_AddBuddyToContact_result record
to_AddBuddyToContact_result :: T.ThriftVal -> AddBuddyToContact_result
to_AddBuddyToContact_result (T.TStruct fields) = AddBuddyToContact_result{
  addBuddyToContact_result_success = P.maybe (addBuddyToContact_result_success default_AddBuddyToContact_result) (\(_,_val10836) -> (case _val10836 of {T.TStruct _val10837 -> (to_ContactTransition (T.TStruct _val10837)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  addBuddyToContact_result_e = P.maybe (P.Nothing) (\(_,_val10836) -> P.Just (case _val10836 of {T.TStruct _val10838 -> (to_TalkException (T.TStruct _val10838)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddBuddyToContact_result _ = P.error "not a struct"
read_AddBuddyToContact_result :: T.Protocol p => p -> P.IO AddBuddyToContact_result
read_AddBuddyToContact_result iprot = to_AddBuddyToContact_result <$> T.readVal iprot (T.T_STRUCT typemap_AddBuddyToContact_result)
decode_AddBuddyToContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddBuddyToContact_result
decode_AddBuddyToContact_result iprot bs = to_AddBuddyToContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddBuddyToContact_result) bs
typemap_AddBuddyToContact_result :: T.TypeMap
typemap_AddBuddyToContact_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ContactTransition))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddBuddyToContact_result :: AddBuddyToContact_result
default_AddBuddyToContact_result = AddBuddyToContact_result{
  addBuddyToContact_result_success = default_ContactTransition,
  addBuddyToContact_result_e = P.Nothing}
data GetGroupMemberMidsForAppPlatform_args = GetGroupMemberMidsForAppPlatform_args  { getGroupMemberMidsForAppPlatform_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMidsForAppPlatform_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_args_groupId record  
instance QC.Arbitrary GetGroupMemberMidsForAppPlatform_args where 
  arbitrary = M.liftM GetGroupMemberMidsForAppPlatform_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMidsForAppPlatform_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMidsForAppPlatform_args{getGroupMemberMidsForAppPlatform_args_groupId = getGroupMemberMidsForAppPlatform_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_args{getGroupMemberMidsForAppPlatform_args_groupId = getGroupMemberMidsForAppPlatform_args_groupId obj}
    ]
from_GetGroupMemberMidsForAppPlatform_args :: GetGroupMemberMidsForAppPlatform_args -> T.ThriftVal
from_GetGroupMemberMidsForAppPlatform_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10841 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10841))) $ getGroupMemberMidsForAppPlatform_args_groupId record
  ]
write_GetGroupMemberMidsForAppPlatform_args :: T.Protocol p => p -> GetGroupMemberMidsForAppPlatform_args -> P.IO ()
write_GetGroupMemberMidsForAppPlatform_args oprot record = T.writeVal oprot $ from_GetGroupMemberMidsForAppPlatform_args record
encode_GetGroupMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> GetGroupMemberMidsForAppPlatform_args -> LBS.ByteString
encode_GetGroupMemberMidsForAppPlatform_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMidsForAppPlatform_args record
to_GetGroupMemberMidsForAppPlatform_args :: T.ThriftVal -> GetGroupMemberMidsForAppPlatform_args
to_GetGroupMemberMidsForAppPlatform_args (T.TStruct fields) = GetGroupMemberMidsForAppPlatform_args{
  getGroupMemberMidsForAppPlatform_args_groupId = P.maybe (getGroupMemberMidsForAppPlatform_args_groupId default_GetGroupMemberMidsForAppPlatform_args) (\(_,_val10843) -> (case _val10843 of {T.TString _val10844 -> E.decodeUtf8 _val10844; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMidsForAppPlatform_args _ = P.error "not a struct"
read_GetGroupMemberMidsForAppPlatform_args :: T.Protocol p => p -> P.IO GetGroupMemberMidsForAppPlatform_args
read_GetGroupMemberMidsForAppPlatform_args iprot = to_GetGroupMemberMidsForAppPlatform_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_args)
decode_GetGroupMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMidsForAppPlatform_args
decode_GetGroupMemberMidsForAppPlatform_args iprot bs = to_GetGroupMemberMidsForAppPlatform_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_args) bs
typemap_GetGroupMemberMidsForAppPlatform_args :: T.TypeMap
typemap_GetGroupMemberMidsForAppPlatform_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMidsForAppPlatform_args :: GetGroupMemberMidsForAppPlatform_args
default_GetGroupMemberMidsForAppPlatform_args = GetGroupMemberMidsForAppPlatform_args{
  getGroupMemberMidsForAppPlatform_args_groupId = ""}
data GetGroupMemberMidsForAppPlatform_result = GetGroupMemberMidsForAppPlatform_result  { getGroupMemberMidsForAppPlatform_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMidsForAppPlatform_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMidsForAppPlatform_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_result_success record   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_result_e record  
instance QC.Arbitrary GetGroupMemberMidsForAppPlatform_result where 
  arbitrary = M.liftM GetGroupMemberMidsForAppPlatform_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMidsForAppPlatform_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = getGroupMemberMidsForAppPlatform_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = getGroupMemberMidsForAppPlatform_result_success obj}
    , if obj == default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = getGroupMemberMidsForAppPlatform_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = getGroupMemberMidsForAppPlatform_result_e obj}
    ]
from_GetGroupMemberMidsForAppPlatform_result :: GetGroupMemberMidsForAppPlatform_result -> T.ThriftVal
from_GetGroupMemberMidsForAppPlatform_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10847 -> (1, ("e",from_TalkException _v10847))) <$> getGroupMemberMidsForAppPlatform_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10847 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10849 -> T.TString $ E.encodeUtf8 _v10849) $ Vector.toList _v10847))) $ getGroupMemberMidsForAppPlatform_result_success record
    , (\_v10847 -> (1, ("e",from_TalkException _v10847))) <$> getGroupMemberMidsForAppPlatform_result_e record
    ]
    )
write_GetGroupMemberMidsForAppPlatform_result :: T.Protocol p => p -> GetGroupMemberMidsForAppPlatform_result -> P.IO ()
write_GetGroupMemberMidsForAppPlatform_result oprot record = T.writeVal oprot $ from_GetGroupMemberMidsForAppPlatform_result record
encode_GetGroupMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> GetGroupMemberMidsForAppPlatform_result -> LBS.ByteString
encode_GetGroupMemberMidsForAppPlatform_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMidsForAppPlatform_result record
to_GetGroupMemberMidsForAppPlatform_result :: T.ThriftVal -> GetGroupMemberMidsForAppPlatform_result
to_GetGroupMemberMidsForAppPlatform_result (T.TStruct fields) = GetGroupMemberMidsForAppPlatform_result{
  getGroupMemberMidsForAppPlatform_result_success = P.maybe (getGroupMemberMidsForAppPlatform_result_success default_GetGroupMemberMidsForAppPlatform_result) (\(_,_val10851) -> (case _val10851 of {T.TList _ _val10852 -> (Vector.fromList $ P.map (\_v10853 -> (case _v10853 of {T.TString _val10854 -> E.decodeUtf8 _val10854; _ -> P.error "wrong type"})) _val10852); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMidsForAppPlatform_result_e = P.maybe (P.Nothing) (\(_,_val10851) -> P.Just (case _val10851 of {T.TStruct _val10855 -> (to_TalkException (T.TStruct _val10855)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMidsForAppPlatform_result _ = P.error "not a struct"
read_GetGroupMemberMidsForAppPlatform_result :: T.Protocol p => p -> P.IO GetGroupMemberMidsForAppPlatform_result
read_GetGroupMemberMidsForAppPlatform_result iprot = to_GetGroupMemberMidsForAppPlatform_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_result)
decode_GetGroupMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMidsForAppPlatform_result
decode_GetGroupMemberMidsForAppPlatform_result iprot bs = to_GetGroupMemberMidsForAppPlatform_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_result) bs
typemap_GetGroupMemberMidsForAppPlatform_result :: T.TypeMap
typemap_GetGroupMemberMidsForAppPlatform_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMidsForAppPlatform_result :: GetGroupMemberMidsForAppPlatform_result
default_GetGroupMemberMidsForAppPlatform_result = GetGroupMemberMidsForAppPlatform_result{
  getGroupMemberMidsForAppPlatform_result_success = Vector.empty,
  getGroupMemberMidsForAppPlatform_result_e = P.Nothing}
data GetUserLanguage_args = GetUserLanguage_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserLanguage_args where 
  arbitrary = QC.elements [GetUserLanguage_args]
from_GetUserLanguage_args :: GetUserLanguage_args -> T.ThriftVal
from_GetUserLanguage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserLanguage_args :: T.Protocol p => p -> GetUserLanguage_args -> P.IO ()
write_GetUserLanguage_args oprot record = T.writeVal oprot $ from_GetUserLanguage_args record
encode_GetUserLanguage_args :: T.StatelessProtocol p => p -> GetUserLanguage_args -> LBS.ByteString
encode_GetUserLanguage_args oprot record = T.serializeVal oprot $ from_GetUserLanguage_args record
to_GetUserLanguage_args :: T.ThriftVal -> GetUserLanguage_args
to_GetUserLanguage_args (T.TStruct fields) = GetUserLanguage_args{

  }
to_GetUserLanguage_args _ = P.error "not a struct"
read_GetUserLanguage_args :: T.Protocol p => p -> P.IO GetUserLanguage_args
read_GetUserLanguage_args iprot = to_GetUserLanguage_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_args)
decode_GetUserLanguage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_args
decode_GetUserLanguage_args iprot bs = to_GetUserLanguage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_args) bs
typemap_GetUserLanguage_args :: T.TypeMap
typemap_GetUserLanguage_args = Map.fromList []
default_GetUserLanguage_args :: GetUserLanguage_args
default_GetUserLanguage_args = GetUserLanguage_args{
}
data GetUserLanguage_result = GetUserLanguage_result  { getUserLanguage_result_success :: LT.Text
  , getUserLanguage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLanguage_result_success record   `H.hashWithSalt` getUserLanguage_result_e record  
instance QC.Arbitrary GetUserLanguage_result where 
  arbitrary = M.liftM GetUserLanguage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLanguage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj}
    , if obj == default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj}
    ]
from_GetUserLanguage_result :: GetUserLanguage_result -> T.ThriftVal
from_GetUserLanguage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10863 -> (1, ("e",from_TalkException _v10863))) <$> getUserLanguage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10863 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10863))) $ getUserLanguage_result_success record
    , (\_v10863 -> (1, ("e",from_TalkException _v10863))) <$> getUserLanguage_result_e record
    ]
    )
write_GetUserLanguage_result :: T.Protocol p => p -> GetUserLanguage_result -> P.IO ()
write_GetUserLanguage_result oprot record = T.writeVal oprot $ from_GetUserLanguage_result record
encode_GetUserLanguage_result :: T.StatelessProtocol p => p -> GetUserLanguage_result -> LBS.ByteString
encode_GetUserLanguage_result oprot record = T.serializeVal oprot $ from_GetUserLanguage_result record
to_GetUserLanguage_result :: T.ThriftVal -> GetUserLanguage_result
to_GetUserLanguage_result (T.TStruct fields) = GetUserLanguage_result{
  getUserLanguage_result_success = P.maybe (getUserLanguage_result_success default_GetUserLanguage_result) (\(_,_val10865) -> (case _val10865 of {T.TString _val10866 -> E.decodeUtf8 _val10866; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLanguage_result_e = P.maybe (P.Nothing) (\(_,_val10865) -> P.Just (case _val10865 of {T.TStruct _val10867 -> (to_TalkException (T.TStruct _val10867)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLanguage_result _ = P.error "not a struct"
read_GetUserLanguage_result :: T.Protocol p => p -> P.IO GetUserLanguage_result
read_GetUserLanguage_result iprot = to_GetUserLanguage_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_result)
decode_GetUserLanguage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_result
decode_GetUserLanguage_result iprot bs = to_GetUserLanguage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_result) bs
typemap_GetUserLanguage_result :: T.TypeMap
typemap_GetUserLanguage_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLanguage_result :: GetUserLanguage_result
default_GetUserLanguage_result = GetUserLanguage_result{
  getUserLanguage_result_success = "",
  getUserLanguage_result_e = P.Nothing}
data LookupPaidCall_args = LookupPaidCall_args  { lookupPaidCall_args_dialedNumber :: LT.Text
  , lookupPaidCall_args_language :: LT.Text
  , lookupPaidCall_args_referer :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupPaidCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupPaidCall_args_dialedNumber record   `H.hashWithSalt` lookupPaidCall_args_language record   `H.hashWithSalt` lookupPaidCall_args_referer record  
instance QC.Arbitrary LookupPaidCall_args where 
  arbitrary = M.liftM LookupPaidCall_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupPaidCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupPaidCall_args{lookupPaidCall_args_dialedNumber = lookupPaidCall_args_dialedNumber obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_dialedNumber = lookupPaidCall_args_dialedNumber obj}
    , if obj == default_LookupPaidCall_args{lookupPaidCall_args_language = lookupPaidCall_args_language obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_language = lookupPaidCall_args_language obj}
    , if obj == default_LookupPaidCall_args{lookupPaidCall_args_referer = lookupPaidCall_args_referer obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_referer = lookupPaidCall_args_referer obj}
    ]
from_LookupPaidCall_args :: LookupPaidCall_args -> T.ThriftVal
from_LookupPaidCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10870 -> P.Just (2, ("dialedNumber",T.TString $ E.encodeUtf8 _v10870))) $ lookupPaidCall_args_dialedNumber record
  , (\_v10870 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v10870))) $ lookupPaidCall_args_language record
  , (\_v10870 -> P.Just (4, ("referer",T.TString $ E.encodeUtf8 _v10870))) $ lookupPaidCall_args_referer record
  ]
write_LookupPaidCall_args :: T.Protocol p => p -> LookupPaidCall_args -> P.IO ()
write_LookupPaidCall_args oprot record = T.writeVal oprot $ from_LookupPaidCall_args record
encode_LookupPaidCall_args :: T.StatelessProtocol p => p -> LookupPaidCall_args -> LBS.ByteString
encode_LookupPaidCall_args oprot record = T.serializeVal oprot $ from_LookupPaidCall_args record
to_LookupPaidCall_args :: T.ThriftVal -> LookupPaidCall_args
to_LookupPaidCall_args (T.TStruct fields) = LookupPaidCall_args{
  lookupPaidCall_args_dialedNumber = P.maybe (lookupPaidCall_args_dialedNumber default_LookupPaidCall_args) (\(_,_val10872) -> (case _val10872 of {T.TString _val10873 -> E.decodeUtf8 _val10873; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  lookupPaidCall_args_language = P.maybe (lookupPaidCall_args_language default_LookupPaidCall_args) (\(_,_val10872) -> (case _val10872 of {T.TString _val10874 -> E.decodeUtf8 _val10874; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  lookupPaidCall_args_referer = P.maybe (lookupPaidCall_args_referer default_LookupPaidCall_args) (\(_,_val10872) -> (case _val10872 of {T.TString _val10875 -> E.decodeUtf8 _val10875; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_LookupPaidCall_args _ = P.error "not a struct"
read_LookupPaidCall_args :: T.Protocol p => p -> P.IO LookupPaidCall_args
read_LookupPaidCall_args iprot = to_LookupPaidCall_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupPaidCall_args)
decode_LookupPaidCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupPaidCall_args
decode_LookupPaidCall_args iprot bs = to_LookupPaidCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupPaidCall_args) bs
typemap_LookupPaidCall_args :: T.TypeMap
typemap_LookupPaidCall_args = Map.fromList [(2,("dialedNumber",T.T_STRING)),(3,("language",T.T_STRING)),(4,("referer",T.T_STRING))]
default_LookupPaidCall_args :: LookupPaidCall_args
default_LookupPaidCall_args = LookupPaidCall_args{
  lookupPaidCall_args_dialedNumber = "",
  lookupPaidCall_args_language = "",
  lookupPaidCall_args_referer = ""}
data LookupPaidCall_result = LookupPaidCall_result  { lookupPaidCall_result_success :: PaidCallResponse
  , lookupPaidCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupPaidCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupPaidCall_result_success record   `H.hashWithSalt` lookupPaidCall_result_e record  
instance QC.Arbitrary LookupPaidCall_result where 
  arbitrary = M.liftM LookupPaidCall_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupPaidCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupPaidCall_result{lookupPaidCall_result_success = lookupPaidCall_result_success obj} then P.Nothing else P.Just $ default_LookupPaidCall_result{lookupPaidCall_result_success = lookupPaidCall_result_success obj}
    , if obj == default_LookupPaidCall_result{lookupPaidCall_result_e = lookupPaidCall_result_e obj} then P.Nothing else P.Just $ default_LookupPaidCall_result{lookupPaidCall_result_e = lookupPaidCall_result_e obj}
    ]
from_LookupPaidCall_result :: LookupPaidCall_result -> T.ThriftVal
from_LookupPaidCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10878 -> (1, ("e",from_TalkException _v10878))) <$> lookupPaidCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10878 -> P.Just (0, ("success",from_PaidCallResponse _v10878))) $ lookupPaidCall_result_success record
    , (\_v10878 -> (1, ("e",from_TalkException _v10878))) <$> lookupPaidCall_result_e record
    ]
    )
write_LookupPaidCall_result :: T.Protocol p => p -> LookupPaidCall_result -> P.IO ()
write_LookupPaidCall_result oprot record = T.writeVal oprot $ from_LookupPaidCall_result record
encode_LookupPaidCall_result :: T.StatelessProtocol p => p -> LookupPaidCall_result -> LBS.ByteString
encode_LookupPaidCall_result oprot record = T.serializeVal oprot $ from_LookupPaidCall_result record
to_LookupPaidCall_result :: T.ThriftVal -> LookupPaidCall_result
to_LookupPaidCall_result (T.TStruct fields) = LookupPaidCall_result{
  lookupPaidCall_result_success = P.maybe (lookupPaidCall_result_success default_LookupPaidCall_result) (\(_,_val10880) -> (case _val10880 of {T.TStruct _val10881 -> (to_PaidCallResponse (T.TStruct _val10881)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupPaidCall_result_e = P.maybe (P.Nothing) (\(_,_val10880) -> P.Just (case _val10880 of {T.TStruct _val10882 -> (to_TalkException (T.TStruct _val10882)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupPaidCall_result _ = P.error "not a struct"
read_LookupPaidCall_result :: T.Protocol p => p -> P.IO LookupPaidCall_result
read_LookupPaidCall_result iprot = to_LookupPaidCall_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupPaidCall_result)
decode_LookupPaidCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupPaidCall_result
decode_LookupPaidCall_result iprot bs = to_LookupPaidCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupPaidCall_result) bs
typemap_LookupPaidCall_result :: T.TypeMap
typemap_LookupPaidCall_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupPaidCall_result :: LookupPaidCall_result
default_LookupPaidCall_result = LookupPaidCall_result{
  lookupPaidCall_result_success = default_PaidCallResponse,
  lookupPaidCall_result_e = P.Nothing}
data GetExtendedProfile_args = GetExtendedProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetExtendedProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetExtendedProfile_args where 
  arbitrary = QC.elements [GetExtendedProfile_args]
from_GetExtendedProfile_args :: GetExtendedProfile_args -> T.ThriftVal
from_GetExtendedProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetExtendedProfile_args :: T.Protocol p => p -> GetExtendedProfile_args -> P.IO ()
write_GetExtendedProfile_args oprot record = T.writeVal oprot $ from_GetExtendedProfile_args record
encode_GetExtendedProfile_args :: T.StatelessProtocol p => p -> GetExtendedProfile_args -> LBS.ByteString
encode_GetExtendedProfile_args oprot record = T.serializeVal oprot $ from_GetExtendedProfile_args record
to_GetExtendedProfile_args :: T.ThriftVal -> GetExtendedProfile_args
to_GetExtendedProfile_args (T.TStruct fields) = GetExtendedProfile_args{

  }
to_GetExtendedProfile_args _ = P.error "not a struct"
read_GetExtendedProfile_args :: T.Protocol p => p -> P.IO GetExtendedProfile_args
read_GetExtendedProfile_args iprot = to_GetExtendedProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetExtendedProfile_args)
decode_GetExtendedProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetExtendedProfile_args
decode_GetExtendedProfile_args iprot bs = to_GetExtendedProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetExtendedProfile_args) bs
typemap_GetExtendedProfile_args :: T.TypeMap
typemap_GetExtendedProfile_args = Map.fromList []
default_GetExtendedProfile_args :: GetExtendedProfile_args
default_GetExtendedProfile_args = GetExtendedProfile_args{
}
data GetExtendedProfile_result = GetExtendedProfile_result  { getExtendedProfile_result_success :: ExtendedProfile
  , getExtendedProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetExtendedProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getExtendedProfile_result_success record   `H.hashWithSalt` getExtendedProfile_result_e record  
instance QC.Arbitrary GetExtendedProfile_result where 
  arbitrary = M.liftM GetExtendedProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetExtendedProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetExtendedProfile_result{getExtendedProfile_result_success = getExtendedProfile_result_success obj} then P.Nothing else P.Just $ default_GetExtendedProfile_result{getExtendedProfile_result_success = getExtendedProfile_result_success obj}
    , if obj == default_GetExtendedProfile_result{getExtendedProfile_result_e = getExtendedProfile_result_e obj} then P.Nothing else P.Just $ default_GetExtendedProfile_result{getExtendedProfile_result_e = getExtendedProfile_result_e obj}
    ]
from_GetExtendedProfile_result :: GetExtendedProfile_result -> T.ThriftVal
from_GetExtendedProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10890 -> (1, ("e",from_TalkException _v10890))) <$> getExtendedProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10890 -> P.Just (0, ("success",from_ExtendedProfile _v10890))) $ getExtendedProfile_result_success record
    , (\_v10890 -> (1, ("e",from_TalkException _v10890))) <$> getExtendedProfile_result_e record
    ]
    )
write_GetExtendedProfile_result :: T.Protocol p => p -> GetExtendedProfile_result -> P.IO ()
write_GetExtendedProfile_result oprot record = T.writeVal oprot $ from_GetExtendedProfile_result record
encode_GetExtendedProfile_result :: T.StatelessProtocol p => p -> GetExtendedProfile_result -> LBS.ByteString
encode_GetExtendedProfile_result oprot record = T.serializeVal oprot $ from_GetExtendedProfile_result record
to_GetExtendedProfile_result :: T.ThriftVal -> GetExtendedProfile_result
to_GetExtendedProfile_result (T.TStruct fields) = GetExtendedProfile_result{
  getExtendedProfile_result_success = P.maybe (getExtendedProfile_result_success default_GetExtendedProfile_result) (\(_,_val10892) -> (case _val10892 of {T.TStruct _val10893 -> (to_ExtendedProfile (T.TStruct _val10893)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getExtendedProfile_result_e = P.maybe (P.Nothing) (\(_,_val10892) -> P.Just (case _val10892 of {T.TStruct _val10894 -> (to_TalkException (T.TStruct _val10894)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetExtendedProfile_result _ = P.error "not a struct"
read_GetExtendedProfile_result :: T.Protocol p => p -> P.IO GetExtendedProfile_result
read_GetExtendedProfile_result iprot = to_GetExtendedProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetExtendedProfile_result)
decode_GetExtendedProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetExtendedProfile_result
decode_GetExtendedProfile_result iprot bs = to_GetExtendedProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetExtendedProfile_result) bs
typemap_GetExtendedProfile_result :: T.TypeMap
typemap_GetExtendedProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ExtendedProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetExtendedProfile_result :: GetExtendedProfile_result
default_GetExtendedProfile_result = GetExtendedProfile_result{
  getExtendedProfile_result_success = default_ExtendedProfile,
  getExtendedProfile_result_e = P.Nothing}
data GetReverseCompactContacts_args = GetReverseCompactContacts_args  { getReverseCompactContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReverseCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReverseCompactContacts_args_ids record  
instance QC.Arbitrary GetReverseCompactContacts_args where 
  arbitrary = M.liftM GetReverseCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetReverseCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReverseCompactContacts_args{getReverseCompactContacts_args_ids = getReverseCompactContacts_args_ids obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_args{getReverseCompactContacts_args_ids = getReverseCompactContacts_args_ids obj}
    ]
from_GetReverseCompactContacts_args :: GetReverseCompactContacts_args -> T.ThriftVal
from_GetReverseCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10897 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v10899 -> T.TString $ E.encodeUtf8 _v10899) $ Vector.toList _v10897))) $ getReverseCompactContacts_args_ids record
  ]
write_GetReverseCompactContacts_args :: T.Protocol p => p -> GetReverseCompactContacts_args -> P.IO ()
write_GetReverseCompactContacts_args oprot record = T.writeVal oprot $ from_GetReverseCompactContacts_args record
encode_GetReverseCompactContacts_args :: T.StatelessProtocol p => p -> GetReverseCompactContacts_args -> LBS.ByteString
encode_GetReverseCompactContacts_args oprot record = T.serializeVal oprot $ from_GetReverseCompactContacts_args record
to_GetReverseCompactContacts_args :: T.ThriftVal -> GetReverseCompactContacts_args
to_GetReverseCompactContacts_args (T.TStruct fields) = GetReverseCompactContacts_args{
  getReverseCompactContacts_args_ids = P.maybe (getReverseCompactContacts_args_ids default_GetReverseCompactContacts_args) (\(_,_val10901) -> (case _val10901 of {T.TList _ _val10902 -> (Vector.fromList $ P.map (\_v10903 -> (case _v10903 of {T.TString _val10904 -> E.decodeUtf8 _val10904; _ -> P.error "wrong type"})) _val10902); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetReverseCompactContacts_args _ = P.error "not a struct"
read_GetReverseCompactContacts_args :: T.Protocol p => p -> P.IO GetReverseCompactContacts_args
read_GetReverseCompactContacts_args iprot = to_GetReverseCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_args)
decode_GetReverseCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReverseCompactContacts_args
decode_GetReverseCompactContacts_args iprot bs = to_GetReverseCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_args) bs
typemap_GetReverseCompactContacts_args :: T.TypeMap
typemap_GetReverseCompactContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING)))]
default_GetReverseCompactContacts_args :: GetReverseCompactContacts_args
default_GetReverseCompactContacts_args = GetReverseCompactContacts_args{
  getReverseCompactContacts_args_ids = Vector.empty}
data GetReverseCompactContacts_result = GetReverseCompactContacts_result  { getReverseCompactContacts_result_success :: (Map.HashMap LT.Text CompactContact)
  , getReverseCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReverseCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReverseCompactContacts_result_success record   `H.hashWithSalt` getReverseCompactContacts_result_e record  
instance QC.Arbitrary GetReverseCompactContacts_result where 
  arbitrary = M.liftM GetReverseCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetReverseCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = getReverseCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = getReverseCompactContacts_result_success obj}
    , if obj == default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = getReverseCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = getReverseCompactContacts_result_e obj}
    ]
from_GetReverseCompactContacts_result :: GetReverseCompactContacts_result -> T.ThriftVal
from_GetReverseCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10907 -> (1, ("e",from_TalkException _v10907))) <$> getReverseCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10907 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_CompactContact) $ P.map (\(_k10908,_v10909) -> (T.TString $ E.encodeUtf8 _k10908, from_CompactContact _v10909)) $ Map.toList _v10907))) $ getReverseCompactContacts_result_success record
    , (\_v10907 -> (1, ("e",from_TalkException _v10907))) <$> getReverseCompactContacts_result_e record
    ]
    )
write_GetReverseCompactContacts_result :: T.Protocol p => p -> GetReverseCompactContacts_result -> P.IO ()
write_GetReverseCompactContacts_result oprot record = T.writeVal oprot $ from_GetReverseCompactContacts_result record
encode_GetReverseCompactContacts_result :: T.StatelessProtocol p => p -> GetReverseCompactContacts_result -> LBS.ByteString
encode_GetReverseCompactContacts_result oprot record = T.serializeVal oprot $ from_GetReverseCompactContacts_result record
to_GetReverseCompactContacts_result :: T.ThriftVal -> GetReverseCompactContacts_result
to_GetReverseCompactContacts_result (T.TStruct fields) = GetReverseCompactContacts_result{
  getReverseCompactContacts_result_success = P.maybe (getReverseCompactContacts_result_success default_GetReverseCompactContacts_result) (\(_,_val10911) -> (case _val10911 of {T.TMap _ _ _val10912 -> (Map.fromList $ P.map (\(_k10914,_v10913) -> ((case _k10914 of {T.TString _val10915 -> E.decodeUtf8 _val10915; _ -> P.error "wrong type"}),(case _v10913 of {T.TStruct _val10916 -> (to_CompactContact (T.TStruct _val10916)); _ -> P.error "wrong type"}))) _val10912); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getReverseCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val10911) -> P.Just (case _val10911 of {T.TStruct _val10917 -> (to_TalkException (T.TStruct _val10917)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetReverseCompactContacts_result _ = P.error "not a struct"
read_GetReverseCompactContacts_result :: T.Protocol p => p -> P.IO GetReverseCompactContacts_result
read_GetReverseCompactContacts_result iprot = to_GetReverseCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_result)
decode_GetReverseCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReverseCompactContacts_result
decode_GetReverseCompactContacts_result iprot bs = to_GetReverseCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_result) bs
typemap_GetReverseCompactContacts_result :: T.TypeMap
typemap_GetReverseCompactContacts_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetReverseCompactContacts_result :: GetReverseCompactContacts_result
default_GetReverseCompactContacts_result = GetReverseCompactContacts_result{
  getReverseCompactContacts_result_success = Map.empty,
  getReverseCompactContacts_result_e = P.Nothing}
data GetPaidCallAdStatus_args = GetPaidCallAdStatus_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallAdStatus_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPaidCallAdStatus_args where 
  arbitrary = QC.elements [GetPaidCallAdStatus_args]
from_GetPaidCallAdStatus_args :: GetPaidCallAdStatus_args -> T.ThriftVal
from_GetPaidCallAdStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPaidCallAdStatus_args :: T.Protocol p => p -> GetPaidCallAdStatus_args -> P.IO ()
write_GetPaidCallAdStatus_args oprot record = T.writeVal oprot $ from_GetPaidCallAdStatus_args record
encode_GetPaidCallAdStatus_args :: T.StatelessProtocol p => p -> GetPaidCallAdStatus_args -> LBS.ByteString
encode_GetPaidCallAdStatus_args oprot record = T.serializeVal oprot $ from_GetPaidCallAdStatus_args record
to_GetPaidCallAdStatus_args :: T.ThriftVal -> GetPaidCallAdStatus_args
to_GetPaidCallAdStatus_args (T.TStruct fields) = GetPaidCallAdStatus_args{

  }
to_GetPaidCallAdStatus_args _ = P.error "not a struct"
read_GetPaidCallAdStatus_args :: T.Protocol p => p -> P.IO GetPaidCallAdStatus_args
read_GetPaidCallAdStatus_args iprot = to_GetPaidCallAdStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_args)
decode_GetPaidCallAdStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallAdStatus_args
decode_GetPaidCallAdStatus_args iprot bs = to_GetPaidCallAdStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_args) bs
typemap_GetPaidCallAdStatus_args :: T.TypeMap
typemap_GetPaidCallAdStatus_args = Map.fromList []
default_GetPaidCallAdStatus_args :: GetPaidCallAdStatus_args
default_GetPaidCallAdStatus_args = GetPaidCallAdStatus_args{
}
data GetPaidCallAdStatus_result = GetPaidCallAdStatus_result  { getPaidCallAdStatus_result_success :: PaidCallAdResult
  , getPaidCallAdStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallAdStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallAdStatus_result_success record   `H.hashWithSalt` getPaidCallAdStatus_result_e record  
instance QC.Arbitrary GetPaidCallAdStatus_result where 
  arbitrary = M.liftM GetPaidCallAdStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallAdStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = getPaidCallAdStatus_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = getPaidCallAdStatus_result_success obj}
    , if obj == default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = getPaidCallAdStatus_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = getPaidCallAdStatus_result_e obj}
    ]
from_GetPaidCallAdStatus_result :: GetPaidCallAdStatus_result -> T.ThriftVal
from_GetPaidCallAdStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10925 -> (1, ("e",from_TalkException _v10925))) <$> getPaidCallAdStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10925 -> P.Just (0, ("success",from_PaidCallAdResult _v10925))) $ getPaidCallAdStatus_result_success record
    , (\_v10925 -> (1, ("e",from_TalkException _v10925))) <$> getPaidCallAdStatus_result_e record
    ]
    )
write_GetPaidCallAdStatus_result :: T.Protocol p => p -> GetPaidCallAdStatus_result -> P.IO ()
write_GetPaidCallAdStatus_result oprot record = T.writeVal oprot $ from_GetPaidCallAdStatus_result record
encode_GetPaidCallAdStatus_result :: T.StatelessProtocol p => p -> GetPaidCallAdStatus_result -> LBS.ByteString
encode_GetPaidCallAdStatus_result oprot record = T.serializeVal oprot $ from_GetPaidCallAdStatus_result record
to_GetPaidCallAdStatus_result :: T.ThriftVal -> GetPaidCallAdStatus_result
to_GetPaidCallAdStatus_result (T.TStruct fields) = GetPaidCallAdStatus_result{
  getPaidCallAdStatus_result_success = P.maybe (getPaidCallAdStatus_result_success default_GetPaidCallAdStatus_result) (\(_,_val10927) -> (case _val10927 of {T.TStruct _val10928 -> (to_PaidCallAdResult (T.TStruct _val10928)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallAdStatus_result_e = P.maybe (P.Nothing) (\(_,_val10927) -> P.Just (case _val10927 of {T.TStruct _val10929 -> (to_TalkException (T.TStruct _val10929)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallAdStatus_result _ = P.error "not a struct"
read_GetPaidCallAdStatus_result :: T.Protocol p => p -> P.IO GetPaidCallAdStatus_result
read_GetPaidCallAdStatus_result iprot = to_GetPaidCallAdStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_result)
decode_GetPaidCallAdStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallAdStatus_result
decode_GetPaidCallAdStatus_result iprot bs = to_GetPaidCallAdStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_result) bs
typemap_GetPaidCallAdStatus_result :: T.TypeMap
typemap_GetPaidCallAdStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallAdResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallAdStatus_result :: GetPaidCallAdStatus_result
default_GetPaidCallAdStatus_result = GetPaidCallAdStatus_result{
  getPaidCallAdStatus_result_success = default_PaidCallAdResult,
  getPaidCallAdStatus_result_e = P.Nothing}
data FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args  { findContactByUseridWithoutAbuseBlockForChannel_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_args_userid record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_args where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10932 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v10932))) $ findContactByUseridWithoutAbuseBlockForChannel_args_userid record
  ]
write_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
encode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
to_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_args
to_FindContactByUseridWithoutAbuseBlockForChannel_args (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_args_userid default_FindContactByUseridWithoutAbuseBlockForChannel_args) (\(_,_val10934) -> (case _val10934 of {T.TString _val10935 -> E.decodeUtf8 _val10935; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_args _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_args
read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args)
decode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_args
decode_FindContactByUseridWithoutAbuseBlockForChannel_args iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args
default_FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = ""}
data FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result  { findContactByUseridWithoutAbuseBlockForChannel_result_success :: Contact
  , findContactByUseridWithoutAbuseBlockForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_success record   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_e record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_result where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj}
    , if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10938 -> (1, ("e",from_TalkException _v10938))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10938 -> P.Just (0, ("success",from_Contact _v10938))) $ findContactByUseridWithoutAbuseBlockForChannel_result_success record
    , (\_v10938 -> (1, ("e",from_TalkException _v10938))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record
    ]
    )
write_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
encode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
to_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_result
to_FindContactByUseridWithoutAbuseBlockForChannel_result (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_result_success default_FindContactByUseridWithoutAbuseBlockForChannel_result) (\(_,_val10940) -> (case _val10940 of {T.TStruct _val10941 -> (to_Contact (T.TStruct _val10941)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10940) -> P.Just (case _val10940 of {T.TStruct _val10942 -> (to_TalkException (T.TStruct _val10942)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_result _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_result
read_FindContactByUseridWithoutAbuseBlockForChannel_result iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result)
decode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_result
decode_FindContactByUseridWithoutAbuseBlockForChannel_result iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result
default_FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = default_Contact,
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Nothing}
data GetGroupMemberMids_args = GetGroupMemberMids_args  { getGroupMemberMids_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_args_groupId record  
instance QC.Arbitrary GetGroupMemberMids_args where 
  arbitrary = M.liftM GetGroupMemberMids_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj}
    ]
from_GetGroupMemberMids_args :: GetGroupMemberMids_args -> T.ThriftVal
from_GetGroupMemberMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10945 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10945))) $ getGroupMemberMids_args_groupId record
  ]
write_GetGroupMemberMids_args :: T.Protocol p => p -> GetGroupMemberMids_args -> P.IO ()
write_GetGroupMemberMids_args oprot record = T.writeVal oprot $ from_GetGroupMemberMids_args record
encode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> GetGroupMemberMids_args -> LBS.ByteString
encode_GetGroupMemberMids_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_args record
to_GetGroupMemberMids_args :: T.ThriftVal -> GetGroupMemberMids_args
to_GetGroupMemberMids_args (T.TStruct fields) = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = P.maybe (getGroupMemberMids_args_groupId default_GetGroupMemberMids_args) (\(_,_val10947) -> (case _val10947 of {T.TString _val10948 -> E.decodeUtf8 _val10948; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_args _ = P.error "not a struct"
read_GetGroupMemberMids_args :: T.Protocol p => p -> P.IO GetGroupMemberMids_args
read_GetGroupMemberMids_args iprot = to_GetGroupMemberMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args)
decode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_args
decode_GetGroupMemberMids_args iprot bs = to_GetGroupMemberMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args) bs
typemap_GetGroupMemberMids_args :: T.TypeMap
typemap_GetGroupMemberMids_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMids_args :: GetGroupMemberMids_args
default_GetGroupMemberMids_args = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = ""}
data GetGroupMemberMids_result = GetGroupMemberMids_result  { getGroupMemberMids_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_result_success record   `H.hashWithSalt` getGroupMemberMids_result_e record  
instance QC.Arbitrary GetGroupMemberMids_result where 
  arbitrary = M.liftM GetGroupMemberMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj}
    , if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj}
    ]
from_GetGroupMemberMids_result :: GetGroupMemberMids_result -> T.ThriftVal
from_GetGroupMemberMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10951 -> (1, ("e",from_TalkException _v10951))) <$> getGroupMemberMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10951 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10953 -> T.TString $ E.encodeUtf8 _v10953) $ Vector.toList _v10951))) $ getGroupMemberMids_result_success record
    , (\_v10951 -> (1, ("e",from_TalkException _v10951))) <$> getGroupMemberMids_result_e record
    ]
    )
write_GetGroupMemberMids_result :: T.Protocol p => p -> GetGroupMemberMids_result -> P.IO ()
write_GetGroupMemberMids_result oprot record = T.writeVal oprot $ from_GetGroupMemberMids_result record
encode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> GetGroupMemberMids_result -> LBS.ByteString
encode_GetGroupMemberMids_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_result record
to_GetGroupMemberMids_result :: T.ThriftVal -> GetGroupMemberMids_result
to_GetGroupMemberMids_result (T.TStruct fields) = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = P.maybe (getGroupMemberMids_result_success default_GetGroupMemberMids_result) (\(_,_val10955) -> (case _val10955 of {T.TList _ _val10956 -> (Vector.fromList $ P.map (\_v10957 -> (case _v10957 of {T.TString _val10958 -> E.decodeUtf8 _val10958; _ -> P.error "wrong type"})) _val10956); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMids_result_e = P.maybe (P.Nothing) (\(_,_val10955) -> P.Just (case _val10955 of {T.TStruct _val10959 -> (to_TalkException (T.TStruct _val10959)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_result _ = P.error "not a struct"
read_GetGroupMemberMids_result :: T.Protocol p => p -> P.IO GetGroupMemberMids_result
read_GetGroupMemberMids_result iprot = to_GetGroupMemberMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result)
decode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_result
decode_GetGroupMemberMids_result iprot bs = to_GetGroupMemberMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result) bs
typemap_GetGroupMemberMids_result :: T.TypeMap
typemap_GetGroupMemberMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMids_result :: GetGroupMemberMids_result
default_GetGroupMemberMids_result = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = Vector.empty,
  getGroupMemberMids_result_e = P.Nothing}
data SendMessageWithoutRelationship_args = SendMessageWithoutRelationship_args  { sendMessageWithoutRelationship_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageWithoutRelationship_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageWithoutRelationship_args_message record  
instance QC.Arbitrary SendMessageWithoutRelationship_args where 
  arbitrary = M.liftM SendMessageWithoutRelationship_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageWithoutRelationship_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageWithoutRelationship_args{sendMessageWithoutRelationship_args_message = sendMessageWithoutRelationship_args_message obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_args{sendMessageWithoutRelationship_args_message = sendMessageWithoutRelationship_args_message obj}
    ]
from_SendMessageWithoutRelationship_args :: SendMessageWithoutRelationship_args -> T.ThriftVal
from_SendMessageWithoutRelationship_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10962 -> P.Just (2, ("message",from_Message _v10962))) $ sendMessageWithoutRelationship_args_message record
  ]
write_SendMessageWithoutRelationship_args :: T.Protocol p => p -> SendMessageWithoutRelationship_args -> P.IO ()
write_SendMessageWithoutRelationship_args oprot record = T.writeVal oprot $ from_SendMessageWithoutRelationship_args record
encode_SendMessageWithoutRelationship_args :: T.StatelessProtocol p => p -> SendMessageWithoutRelationship_args -> LBS.ByteString
encode_SendMessageWithoutRelationship_args oprot record = T.serializeVal oprot $ from_SendMessageWithoutRelationship_args record
to_SendMessageWithoutRelationship_args :: T.ThriftVal -> SendMessageWithoutRelationship_args
to_SendMessageWithoutRelationship_args (T.TStruct fields) = SendMessageWithoutRelationship_args{
  sendMessageWithoutRelationship_args_message = P.maybe (sendMessageWithoutRelationship_args_message default_SendMessageWithoutRelationship_args) (\(_,_val10964) -> (case _val10964 of {T.TStruct _val10965 -> (to_Message (T.TStruct _val10965)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageWithoutRelationship_args _ = P.error "not a struct"
read_SendMessageWithoutRelationship_args :: T.Protocol p => p -> P.IO SendMessageWithoutRelationship_args
read_SendMessageWithoutRelationship_args iprot = to_SendMessageWithoutRelationship_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_args)
decode_SendMessageWithoutRelationship_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageWithoutRelationship_args
decode_SendMessageWithoutRelationship_args iprot bs = to_SendMessageWithoutRelationship_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_args) bs
typemap_SendMessageWithoutRelationship_args :: T.TypeMap
typemap_SendMessageWithoutRelationship_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageWithoutRelationship_args :: SendMessageWithoutRelationship_args
default_SendMessageWithoutRelationship_args = SendMessageWithoutRelationship_args{
  sendMessageWithoutRelationship_args_message = default_Message}
data SendMessageWithoutRelationship_result = SendMessageWithoutRelationship_result  { sendMessageWithoutRelationship_result_success :: Message
  , sendMessageWithoutRelationship_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageWithoutRelationship_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageWithoutRelationship_result_success record   `H.hashWithSalt` sendMessageWithoutRelationship_result_e record  
instance QC.Arbitrary SendMessageWithoutRelationship_result where 
  arbitrary = M.liftM SendMessageWithoutRelationship_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageWithoutRelationship_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = sendMessageWithoutRelationship_result_success obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = sendMessageWithoutRelationship_result_success obj}
    , if obj == default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = sendMessageWithoutRelationship_result_e obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = sendMessageWithoutRelationship_result_e obj}
    ]
from_SendMessageWithoutRelationship_result :: SendMessageWithoutRelationship_result -> T.ThriftVal
from_SendMessageWithoutRelationship_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10968 -> (1, ("e",from_TalkException _v10968))) <$> sendMessageWithoutRelationship_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10968 -> P.Just (0, ("success",from_Message _v10968))) $ sendMessageWithoutRelationship_result_success record
    , (\_v10968 -> (1, ("e",from_TalkException _v10968))) <$> sendMessageWithoutRelationship_result_e record
    ]
    )
write_SendMessageWithoutRelationship_result :: T.Protocol p => p -> SendMessageWithoutRelationship_result -> P.IO ()
write_SendMessageWithoutRelationship_result oprot record = T.writeVal oprot $ from_SendMessageWithoutRelationship_result record
encode_SendMessageWithoutRelationship_result :: T.StatelessProtocol p => p -> SendMessageWithoutRelationship_result -> LBS.ByteString
encode_SendMessageWithoutRelationship_result oprot record = T.serializeVal oprot $ from_SendMessageWithoutRelationship_result record
to_SendMessageWithoutRelationship_result :: T.ThriftVal -> SendMessageWithoutRelationship_result
to_SendMessageWithoutRelationship_result (T.TStruct fields) = SendMessageWithoutRelationship_result{
  sendMessageWithoutRelationship_result_success = P.maybe (sendMessageWithoutRelationship_result_success default_SendMessageWithoutRelationship_result) (\(_,_val10970) -> (case _val10970 of {T.TStruct _val10971 -> (to_Message (T.TStruct _val10971)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageWithoutRelationship_result_e = P.maybe (P.Nothing) (\(_,_val10970) -> P.Just (case _val10970 of {T.TStruct _val10972 -> (to_TalkException (T.TStruct _val10972)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageWithoutRelationship_result _ = P.error "not a struct"
read_SendMessageWithoutRelationship_result :: T.Protocol p => p -> P.IO SendMessageWithoutRelationship_result
read_SendMessageWithoutRelationship_result iprot = to_SendMessageWithoutRelationship_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_result)
decode_SendMessageWithoutRelationship_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageWithoutRelationship_result
decode_SendMessageWithoutRelationship_result iprot bs = to_SendMessageWithoutRelationship_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_result) bs
typemap_SendMessageWithoutRelationship_result :: T.TypeMap
typemap_SendMessageWithoutRelationship_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageWithoutRelationship_result :: SendMessageWithoutRelationship_result
default_SendMessageWithoutRelationship_result = SendMessageWithoutRelationship_result{
  sendMessageWithoutRelationship_result_success = default_Message,
  sendMessageWithoutRelationship_result_e = P.Nothing}
data DisplayBuddySubscriberCountInBulk_args = DisplayBuddySubscriberCountInBulk_args  { displayBuddySubscriberCountInBulk_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCountInBulk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCountInBulk_args_mids record  
instance QC.Arbitrary DisplayBuddySubscriberCountInBulk_args where 
  arbitrary = M.liftM DisplayBuddySubscriberCountInBulk_args (QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCountInBulk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCountInBulk_args{displayBuddySubscriberCountInBulk_args_mids = displayBuddySubscriberCountInBulk_args_mids obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_args{displayBuddySubscriberCountInBulk_args_mids = displayBuddySubscriberCountInBulk_args_mids obj}
    ]
from_DisplayBuddySubscriberCountInBulk_args :: DisplayBuddySubscriberCountInBulk_args -> T.ThriftVal
from_DisplayBuddySubscriberCountInBulk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10975 -> P.Just (1, ("mids",T.TList T.T_STRING $ P.map (\_v10977 -> T.TString $ E.encodeUtf8 _v10977) $ Vector.toList _v10975))) $ displayBuddySubscriberCountInBulk_args_mids record
  ]
write_DisplayBuddySubscriberCountInBulk_args :: T.Protocol p => p -> DisplayBuddySubscriberCountInBulk_args -> P.IO ()
write_DisplayBuddySubscriberCountInBulk_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCountInBulk_args record
encode_DisplayBuddySubscriberCountInBulk_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCountInBulk_args -> LBS.ByteString
encode_DisplayBuddySubscriberCountInBulk_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCountInBulk_args record
to_DisplayBuddySubscriberCountInBulk_args :: T.ThriftVal -> DisplayBuddySubscriberCountInBulk_args
to_DisplayBuddySubscriberCountInBulk_args (T.TStruct fields) = DisplayBuddySubscriberCountInBulk_args{
  displayBuddySubscriberCountInBulk_args_mids = P.maybe (displayBuddySubscriberCountInBulk_args_mids default_DisplayBuddySubscriberCountInBulk_args) (\(_,_val10979) -> (case _val10979 of {T.TList _ _val10980 -> (Vector.fromList $ P.map (\_v10981 -> (case _v10981 of {T.TString _val10982 -> E.decodeUtf8 _val10982; _ -> P.error "wrong type"})) _val10980); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCountInBulk_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCountInBulk_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCountInBulk_args
read_DisplayBuddySubscriberCountInBulk_args iprot = to_DisplayBuddySubscriberCountInBulk_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_args)
decode_DisplayBuddySubscriberCountInBulk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCountInBulk_args
decode_DisplayBuddySubscriberCountInBulk_args iprot bs = to_DisplayBuddySubscriberCountInBulk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_args) bs
typemap_DisplayBuddySubscriberCountInBulk_args :: T.TypeMap
typemap_DisplayBuddySubscriberCountInBulk_args = Map.fromList [(1,("mids",(T.T_LIST T.T_STRING)))]
default_DisplayBuddySubscriberCountInBulk_args :: DisplayBuddySubscriberCountInBulk_args
default_DisplayBuddySubscriberCountInBulk_args = DisplayBuddySubscriberCountInBulk_args{
  displayBuddySubscriberCountInBulk_args_mids = Vector.empty}
data DisplayBuddySubscriberCountInBulk_result = DisplayBuddySubscriberCountInBulk_result  { displayBuddySubscriberCountInBulk_result_success :: (Map.HashMap LT.Text I.Int64)
  , displayBuddySubscriberCountInBulk_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCountInBulk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCountInBulk_result_success record   `H.hashWithSalt` displayBuddySubscriberCountInBulk_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCountInBulk_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCountInBulk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCountInBulk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = displayBuddySubscriberCountInBulk_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = displayBuddySubscriberCountInBulk_result_success obj}
    , if obj == default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = displayBuddySubscriberCountInBulk_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = displayBuddySubscriberCountInBulk_result_e obj}
    ]
from_DisplayBuddySubscriberCountInBulk_result :: DisplayBuddySubscriberCountInBulk_result -> T.ThriftVal
from_DisplayBuddySubscriberCountInBulk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10985 -> (1, ("e",from_TalkException _v10985))) <$> displayBuddySubscriberCountInBulk_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10985 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_I64 $ P.map (\(_k10986,_v10987) -> (T.TString $ E.encodeUtf8 _k10986, T.TI64 _v10987)) $ Map.toList _v10985))) $ displayBuddySubscriberCountInBulk_result_success record
    , (\_v10985 -> (1, ("e",from_TalkException _v10985))) <$> displayBuddySubscriberCountInBulk_result_e record
    ]
    )
write_DisplayBuddySubscriberCountInBulk_result :: T.Protocol p => p -> DisplayBuddySubscriberCountInBulk_result -> P.IO ()
write_DisplayBuddySubscriberCountInBulk_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCountInBulk_result record
encode_DisplayBuddySubscriberCountInBulk_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCountInBulk_result -> LBS.ByteString
encode_DisplayBuddySubscriberCountInBulk_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCountInBulk_result record
to_DisplayBuddySubscriberCountInBulk_result :: T.ThriftVal -> DisplayBuddySubscriberCountInBulk_result
to_DisplayBuddySubscriberCountInBulk_result (T.TStruct fields) = DisplayBuddySubscriberCountInBulk_result{
  displayBuddySubscriberCountInBulk_result_success = P.maybe (displayBuddySubscriberCountInBulk_result_success default_DisplayBuddySubscriberCountInBulk_result) (\(_,_val10989) -> (case _val10989 of {T.TMap _ _ _val10990 -> (Map.fromList $ P.map (\(_k10992,_v10991) -> ((case _k10992 of {T.TString _val10993 -> E.decodeUtf8 _val10993; _ -> P.error "wrong type"}),(case _v10991 of {T.TI64 _val10994 -> _val10994; _ -> P.error "wrong type"}))) _val10990); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCountInBulk_result_e = P.maybe (P.Nothing) (\(_,_val10989) -> P.Just (case _val10989 of {T.TStruct _val10995 -> (to_TalkException (T.TStruct _val10995)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCountInBulk_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCountInBulk_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCountInBulk_result
read_DisplayBuddySubscriberCountInBulk_result iprot = to_DisplayBuddySubscriberCountInBulk_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_result)
decode_DisplayBuddySubscriberCountInBulk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCountInBulk_result
decode_DisplayBuddySubscriberCountInBulk_result iprot bs = to_DisplayBuddySubscriberCountInBulk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_result) bs
typemap_DisplayBuddySubscriberCountInBulk_result :: T.TypeMap
typemap_DisplayBuddySubscriberCountInBulk_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_I64))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCountInBulk_result :: DisplayBuddySubscriberCountInBulk_result
default_DisplayBuddySubscriberCountInBulk_result = DisplayBuddySubscriberCountInBulk_result{
  displayBuddySubscriberCountInBulk_result_success = Map.empty,
  displayBuddySubscriberCountInBulk_result_e = P.Nothing}
data LookupRoomMembers_args = LookupRoomMembers_args  { lookupRoomMembers_args_roomId :: LT.Text
  , lookupRoomMembers_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupRoomMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupRoomMembers_args_roomId record   `H.hashWithSalt` lookupRoomMembers_args_mids record  
instance QC.Arbitrary LookupRoomMembers_args where 
  arbitrary = M.liftM LookupRoomMembers_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupRoomMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupRoomMembers_args{lookupRoomMembers_args_roomId = lookupRoomMembers_args_roomId obj} then P.Nothing else P.Just $ default_LookupRoomMembers_args{lookupRoomMembers_args_roomId = lookupRoomMembers_args_roomId obj}
    , if obj == default_LookupRoomMembers_args{lookupRoomMembers_args_mids = lookupRoomMembers_args_mids obj} then P.Nothing else P.Just $ default_LookupRoomMembers_args{lookupRoomMembers_args_mids = lookupRoomMembers_args_mids obj}
    ]
from_LookupRoomMembers_args :: LookupRoomMembers_args -> T.ThriftVal
from_LookupRoomMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10998 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10998))) $ lookupRoomMembers_args_roomId record
  , (\_v10998 -> P.Just (2, ("mids",T.TList T.T_STRING $ P.map (\_v11000 -> T.TString $ E.encodeUtf8 _v11000) $ Vector.toList _v10998))) $ lookupRoomMembers_args_mids record
  ]
write_LookupRoomMembers_args :: T.Protocol p => p -> LookupRoomMembers_args -> P.IO ()
write_LookupRoomMembers_args oprot record = T.writeVal oprot $ from_LookupRoomMembers_args record
encode_LookupRoomMembers_args :: T.StatelessProtocol p => p -> LookupRoomMembers_args -> LBS.ByteString
encode_LookupRoomMembers_args oprot record = T.serializeVal oprot $ from_LookupRoomMembers_args record
to_LookupRoomMembers_args :: T.ThriftVal -> LookupRoomMembers_args
to_LookupRoomMembers_args (T.TStruct fields) = LookupRoomMembers_args{
  lookupRoomMembers_args_roomId = P.maybe (lookupRoomMembers_args_roomId default_LookupRoomMembers_args) (\(_,_val11002) -> (case _val11002 of {T.TString _val11003 -> E.decodeUtf8 _val11003; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lookupRoomMembers_args_mids = P.maybe (lookupRoomMembers_args_mids default_LookupRoomMembers_args) (\(_,_val11002) -> (case _val11002 of {T.TList _ _val11004 -> (Vector.fromList $ P.map (\_v11005 -> (case _v11005 of {T.TString _val11006 -> E.decodeUtf8 _val11006; _ -> P.error "wrong type"})) _val11004); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LookupRoomMembers_args _ = P.error "not a struct"
read_LookupRoomMembers_args :: T.Protocol p => p -> P.IO LookupRoomMembers_args
read_LookupRoomMembers_args iprot = to_LookupRoomMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupRoomMembers_args)
decode_LookupRoomMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupRoomMembers_args
decode_LookupRoomMembers_args iprot bs = to_LookupRoomMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupRoomMembers_args) bs
typemap_LookupRoomMembers_args :: T.TypeMap
typemap_LookupRoomMembers_args = Map.fromList [(1,("roomId",T.T_STRING)),(2,("mids",(T.T_LIST T.T_STRING)))]
default_LookupRoomMembers_args :: LookupRoomMembers_args
default_LookupRoomMembers_args = LookupRoomMembers_args{
  lookupRoomMembers_args_roomId = "",
  lookupRoomMembers_args_mids = Vector.empty}
data LookupRoomMembers_result = LookupRoomMembers_result  { lookupRoomMembers_result_success :: (Vector.Vector SimpleChannelContact)
  , lookupRoomMembers_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupRoomMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupRoomMembers_result_success record   `H.hashWithSalt` lookupRoomMembers_result_e record  
instance QC.Arbitrary LookupRoomMembers_result where 
  arbitrary = M.liftM LookupRoomMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupRoomMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupRoomMembers_result{lookupRoomMembers_result_success = lookupRoomMembers_result_success obj} then P.Nothing else P.Just $ default_LookupRoomMembers_result{lookupRoomMembers_result_success = lookupRoomMembers_result_success obj}
    , if obj == default_LookupRoomMembers_result{lookupRoomMembers_result_e = lookupRoomMembers_result_e obj} then P.Nothing else P.Just $ default_LookupRoomMembers_result{lookupRoomMembers_result_e = lookupRoomMembers_result_e obj}
    ]
from_LookupRoomMembers_result :: LookupRoomMembers_result -> T.ThriftVal
from_LookupRoomMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11009 -> (1, ("e",from_TalkException _v11009))) <$> lookupRoomMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11009 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v11011 -> from_SimpleChannelContact _v11011) $ Vector.toList _v11009))) $ lookupRoomMembers_result_success record
    , (\_v11009 -> (1, ("e",from_TalkException _v11009))) <$> lookupRoomMembers_result_e record
    ]
    )
write_LookupRoomMembers_result :: T.Protocol p => p -> LookupRoomMembers_result -> P.IO ()
write_LookupRoomMembers_result oprot record = T.writeVal oprot $ from_LookupRoomMembers_result record
encode_LookupRoomMembers_result :: T.StatelessProtocol p => p -> LookupRoomMembers_result -> LBS.ByteString
encode_LookupRoomMembers_result oprot record = T.serializeVal oprot $ from_LookupRoomMembers_result record
to_LookupRoomMembers_result :: T.ThriftVal -> LookupRoomMembers_result
to_LookupRoomMembers_result (T.TStruct fields) = LookupRoomMembers_result{
  lookupRoomMembers_result_success = P.maybe (lookupRoomMembers_result_success default_LookupRoomMembers_result) (\(_,_val11013) -> (case _val11013 of {T.TList _ _val11014 -> (Vector.fromList $ P.map (\_v11015 -> (case _v11015 of {T.TStruct _val11016 -> (to_SimpleChannelContact (T.TStruct _val11016)); _ -> P.error "wrong type"})) _val11014); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupRoomMembers_result_e = P.maybe (P.Nothing) (\(_,_val11013) -> P.Just (case _val11013 of {T.TStruct _val11017 -> (to_TalkException (T.TStruct _val11017)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupRoomMembers_result _ = P.error "not a struct"
read_LookupRoomMembers_result :: T.Protocol p => p -> P.IO LookupRoomMembers_result
read_LookupRoomMembers_result iprot = to_LookupRoomMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupRoomMembers_result)
decode_LookupRoomMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupRoomMembers_result
decode_LookupRoomMembers_result iprot bs = to_LookupRoomMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupRoomMembers_result) bs
typemap_LookupRoomMembers_result :: T.TypeMap
typemap_LookupRoomMembers_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupRoomMembers_result :: LookupRoomMembers_result
default_LookupRoomMembers_result = LookupRoomMembers_result{
  lookupRoomMembers_result_success = Vector.empty,
  lookupRoomMembers_result_e = P.Nothing}
data GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMidsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteMidsForChannel_args]
from_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args -> T.ThriftVal
from_GetFavoriteMidsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> GetFavoriteMidsForChannel_args -> P.IO ()
write_GetFavoriteMidsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_args record
encode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_args -> LBS.ByteString
encode_GetFavoriteMidsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_args record
to_GetFavoriteMidsForChannel_args :: T.ThriftVal -> GetFavoriteMidsForChannel_args
to_GetFavoriteMidsForChannel_args (T.TStruct fields) = GetFavoriteMidsForChannel_args{

  }
to_GetFavoriteMidsForChannel_args _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_args
read_GetFavoriteMidsForChannel_args iprot = to_GetFavoriteMidsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args)
decode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_args
decode_GetFavoriteMidsForChannel_args iprot bs = to_GetFavoriteMidsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args) bs
typemap_GetFavoriteMidsForChannel_args :: T.TypeMap
typemap_GetFavoriteMidsForChannel_args = Map.fromList []
default_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args
default_GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args{
}
data GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result  { getFavoriteMidsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMidsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMidsForChannel_result_success record   `H.hashWithSalt` getFavoriteMidsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteMidsForChannel_result where 
  arbitrary = M.liftM GetFavoriteMidsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMidsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj}
    , if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj}
    ]
from_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result -> T.ThriftVal
from_GetFavoriteMidsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11025 -> (1, ("e",from_TalkException _v11025))) <$> getFavoriteMidsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11025 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v11027 -> T.TString $ E.encodeUtf8 _v11027) $ Vector.toList _v11025))) $ getFavoriteMidsForChannel_result_success record
    , (\_v11025 -> (1, ("e",from_TalkException _v11025))) <$> getFavoriteMidsForChannel_result_e record
    ]
    )
write_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> GetFavoriteMidsForChannel_result -> P.IO ()
write_GetFavoriteMidsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_result record
encode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_result -> LBS.ByteString
encode_GetFavoriteMidsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_result record
to_GetFavoriteMidsForChannel_result :: T.ThriftVal -> GetFavoriteMidsForChannel_result
to_GetFavoriteMidsForChannel_result (T.TStruct fields) = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = P.maybe (getFavoriteMidsForChannel_result_success default_GetFavoriteMidsForChannel_result) (\(_,_val11029) -> (case _val11029 of {T.TList _ _val11030 -> (Vector.fromList $ P.map (\_v11031 -> (case _v11031 of {T.TString _val11032 -> E.decodeUtf8 _val11032; _ -> P.error "wrong type"})) _val11030); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMidsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val11029) -> P.Just (case _val11029 of {T.TStruct _val11033 -> (to_TalkException (T.TStruct _val11033)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMidsForChannel_result _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_result
read_GetFavoriteMidsForChannel_result iprot = to_GetFavoriteMidsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result)
decode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_result
decode_GetFavoriteMidsForChannel_result iprot bs = to_GetFavoriteMidsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result) bs
typemap_GetFavoriteMidsForChannel_result :: T.TypeMap
typemap_GetFavoriteMidsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result
default_GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = Vector.empty,
  getFavoriteMidsForChannel_result_e = P.Nothing}
data GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIdsForChannel_args where 
  arbitrary = QC.elements [GetAllContactIdsForChannel_args]
from_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args -> T.ThriftVal
from_GetAllContactIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIdsForChannel_args :: T.Protocol p => p -> GetAllContactIdsForChannel_args -> P.IO ()
write_GetAllContactIdsForChannel_args oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_args record
encode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_args -> LBS.ByteString
encode_GetAllContactIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_args record
to_GetAllContactIdsForChannel_args :: T.ThriftVal -> GetAllContactIdsForChannel_args
to_GetAllContactIdsForChannel_args (T.TStruct fields) = GetAllContactIdsForChannel_args{

  }
to_GetAllContactIdsForChannel_args _ = P.error "not a struct"
read_GetAllContactIdsForChannel_args :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_args
read_GetAllContactIdsForChannel_args iprot = to_GetAllContactIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args)
decode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_args
decode_GetAllContactIdsForChannel_args iprot bs = to_GetAllContactIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args) bs
typemap_GetAllContactIdsForChannel_args :: T.TypeMap
typemap_GetAllContactIdsForChannel_args = Map.fromList []
default_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args
default_GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args{
}
data GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result  { getAllContactIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getAllContactIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIdsForChannel_result_success record   `H.hashWithSalt` getAllContactIdsForChannel_result_e record  
instance QC.Arbitrary GetAllContactIdsForChannel_result where 
  arbitrary = M.liftM GetAllContactIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj}
    , if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj}
    ]
from_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result -> T.ThriftVal
from_GetAllContactIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11041 -> (1, ("e",from_TalkException _v11041))) <$> getAllContactIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11041 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v11043 -> T.TString $ E.encodeUtf8 _v11043) $ Vector.toList _v11041))) $ getAllContactIdsForChannel_result_success record
    , (\_v11041 -> (1, ("e",from_TalkException _v11041))) <$> getAllContactIdsForChannel_result_e record
    ]
    )
write_GetAllContactIdsForChannel_result :: T.Protocol p => p -> GetAllContactIdsForChannel_result -> P.IO ()
write_GetAllContactIdsForChannel_result oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_result record
encode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_result -> LBS.ByteString
encode_GetAllContactIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_result record
to_GetAllContactIdsForChannel_result :: T.ThriftVal -> GetAllContactIdsForChannel_result
to_GetAllContactIdsForChannel_result (T.TStruct fields) = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = P.maybe (getAllContactIdsForChannel_result_success default_GetAllContactIdsForChannel_result) (\(_,_val11045) -> (case _val11045 of {T.TList _ _val11046 -> (Vector.fromList $ P.map (\_v11047 -> (case _v11047 of {T.TString _val11048 -> E.decodeUtf8 _val11048; _ -> P.error "wrong type"})) _val11046); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val11045) -> P.Just (case _val11045 of {T.TStruct _val11049 -> (to_TalkException (T.TStruct _val11049)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIdsForChannel_result _ = P.error "not a struct"
read_GetAllContactIdsForChannel_result :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_result
read_GetAllContactIdsForChannel_result iprot = to_GetAllContactIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result)
decode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_result
decode_GetAllContactIdsForChannel_result iprot bs = to_GetAllContactIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result) bs
typemap_GetAllContactIdsForChannel_result :: T.TypeMap
typemap_GetAllContactIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result
default_GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = Vector.empty,
  getAllContactIdsForChannel_result_e = P.Nothing}
data DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DisplayBuddySubscriberCount_args where 
  arbitrary = QC.elements [DisplayBuddySubscriberCount_args]
from_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args -> T.ThriftVal
from_DisplayBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> DisplayBuddySubscriberCount_args -> P.IO ()
write_DisplayBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_args record
encode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_args -> LBS.ByteString
encode_DisplayBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_args record
to_DisplayBuddySubscriberCount_args :: T.ThriftVal -> DisplayBuddySubscriberCount_args
to_DisplayBuddySubscriberCount_args (T.TStruct fields) = DisplayBuddySubscriberCount_args{

  }
to_DisplayBuddySubscriberCount_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_args
read_DisplayBuddySubscriberCount_args iprot = to_DisplayBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args)
decode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_args
decode_DisplayBuddySubscriberCount_args iprot bs = to_DisplayBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args) bs
typemap_DisplayBuddySubscriberCount_args :: T.TypeMap
typemap_DisplayBuddySubscriberCount_args = Map.fromList []
default_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args
default_DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args{
}
data DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result  { displayBuddySubscriberCount_result_success :: I.Int64
  , displayBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCount_result_success record   `H.hashWithSalt` displayBuddySubscriberCount_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCount_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj}
    , if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj}
    ]
from_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result -> T.ThriftVal
from_DisplayBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11057 -> (1, ("e",from_TalkException _v11057))) <$> displayBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11057 -> P.Just (0, ("success",T.TI64 _v11057))) $ displayBuddySubscriberCount_result_success record
    , (\_v11057 -> (1, ("e",from_TalkException _v11057))) <$> displayBuddySubscriberCount_result_e record
    ]
    )
write_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> DisplayBuddySubscriberCount_result -> P.IO ()
write_DisplayBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_result record
encode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_result -> LBS.ByteString
encode_DisplayBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_result record
to_DisplayBuddySubscriberCount_result :: T.ThriftVal -> DisplayBuddySubscriberCount_result
to_DisplayBuddySubscriberCount_result (T.TStruct fields) = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = P.maybe (displayBuddySubscriberCount_result_success default_DisplayBuddySubscriberCount_result) (\(_,_val11059) -> (case _val11059 of {T.TI64 _val11060 -> _val11060; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val11059) -> P.Just (case _val11059 of {T.TStruct _val11061 -> (to_TalkException (T.TStruct _val11061)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCount_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_result
read_DisplayBuddySubscriberCount_result iprot = to_DisplayBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result)
decode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_result
decode_DisplayBuddySubscriberCount_result iprot bs = to_DisplayBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result) bs
typemap_DisplayBuddySubscriberCount_result :: T.TypeMap
typemap_DisplayBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result
default_DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = 0,
  displayBuddySubscriberCount_result_e = P.Nothing}
data GetProfileForChannel_args = GetProfileForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfileForChannel_args where 
  arbitrary = QC.elements [GetProfileForChannel_args]
from_GetProfileForChannel_args :: GetProfileForChannel_args -> T.ThriftVal
from_GetProfileForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfileForChannel_args :: T.Protocol p => p -> GetProfileForChannel_args -> P.IO ()
write_GetProfileForChannel_args oprot record = T.writeVal oprot $ from_GetProfileForChannel_args record
encode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> GetProfileForChannel_args -> LBS.ByteString
encode_GetProfileForChannel_args oprot record = T.serializeVal oprot $ from_GetProfileForChannel_args record
to_GetProfileForChannel_args :: T.ThriftVal -> GetProfileForChannel_args
to_GetProfileForChannel_args (T.TStruct fields) = GetProfileForChannel_args{

  }
to_GetProfileForChannel_args _ = P.error "not a struct"
read_GetProfileForChannel_args :: T.Protocol p => p -> P.IO GetProfileForChannel_args
read_GetProfileForChannel_args iprot = to_GetProfileForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args)
decode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_args
decode_GetProfileForChannel_args iprot bs = to_GetProfileForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args) bs
typemap_GetProfileForChannel_args :: T.TypeMap
typemap_GetProfileForChannel_args = Map.fromList []
default_GetProfileForChannel_args :: GetProfileForChannel_args
default_GetProfileForChannel_args = GetProfileForChannel_args{
}
data GetProfileForChannel_result = GetProfileForChannel_result  { getProfileForChannel_result_success :: Profile
  , getProfileForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfileForChannel_result_success record   `H.hashWithSalt` getProfileForChannel_result_e record  
instance QC.Arbitrary GetProfileForChannel_result where 
  arbitrary = M.liftM GetProfileForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfileForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj}
    , if obj == default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj}
    ]
from_GetProfileForChannel_result :: GetProfileForChannel_result -> T.ThriftVal
from_GetProfileForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11069 -> (1, ("e",from_TalkException _v11069))) <$> getProfileForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11069 -> P.Just (0, ("success",from_Profile _v11069))) $ getProfileForChannel_result_success record
    , (\_v11069 -> (1, ("e",from_TalkException _v11069))) <$> getProfileForChannel_result_e record
    ]
    )
write_GetProfileForChannel_result :: T.Protocol p => p -> GetProfileForChannel_result -> P.IO ()
write_GetProfileForChannel_result oprot record = T.writeVal oprot $ from_GetProfileForChannel_result record
encode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> GetProfileForChannel_result -> LBS.ByteString
encode_GetProfileForChannel_result oprot record = T.serializeVal oprot $ from_GetProfileForChannel_result record
to_GetProfileForChannel_result :: T.ThriftVal -> GetProfileForChannel_result
to_GetProfileForChannel_result (T.TStruct fields) = GetProfileForChannel_result{
  getProfileForChannel_result_success = P.maybe (getProfileForChannel_result_success default_GetProfileForChannel_result) (\(_,_val11071) -> (case _val11071 of {T.TStruct _val11072 -> (to_Profile (T.TStruct _val11072)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfileForChannel_result_e = P.maybe (P.Nothing) (\(_,_val11071) -> P.Just (case _val11071 of {T.TStruct _val11073 -> (to_TalkException (T.TStruct _val11073)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfileForChannel_result _ = P.error "not a struct"
read_GetProfileForChannel_result :: T.Protocol p => p -> P.IO GetProfileForChannel_result
read_GetProfileForChannel_result iprot = to_GetProfileForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result)
decode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_result
decode_GetProfileForChannel_result iprot bs = to_GetProfileForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result) bs
typemap_GetProfileForChannel_result :: T.TypeMap
typemap_GetProfileForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfileForChannel_result :: GetProfileForChannel_result
default_GetProfileForChannel_result = GetProfileForChannel_result{
  getProfileForChannel_result_success = default_Profile,
  getProfileForChannel_result_e = P.Nothing}
data GetUserTickets_args = GetUserTickets_args  { getUserTickets_args_userMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTickets_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTickets_args_userMids record  
instance QC.Arbitrary GetUserTickets_args where 
  arbitrary = M.liftM GetUserTickets_args (QC.arbitrary)
  shrink obj | obj == default_GetUserTickets_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTickets_args{getUserTickets_args_userMids = getUserTickets_args_userMids obj} then P.Nothing else P.Just $ default_GetUserTickets_args{getUserTickets_args_userMids = getUserTickets_args_userMids obj}
    ]
from_GetUserTickets_args :: GetUserTickets_args -> T.ThriftVal
from_GetUserTickets_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11076 -> P.Just (1, ("userMids",T.TList T.T_STRING $ P.map (\_v11078 -> T.TString $ E.encodeUtf8 _v11078) $ Vector.toList _v11076))) $ getUserTickets_args_userMids record
  ]
write_GetUserTickets_args :: T.Protocol p => p -> GetUserTickets_args -> P.IO ()
write_GetUserTickets_args oprot record = T.writeVal oprot $ from_GetUserTickets_args record
encode_GetUserTickets_args :: T.StatelessProtocol p => p -> GetUserTickets_args -> LBS.ByteString
encode_GetUserTickets_args oprot record = T.serializeVal oprot $ from_GetUserTickets_args record
to_GetUserTickets_args :: T.ThriftVal -> GetUserTickets_args
to_GetUserTickets_args (T.TStruct fields) = GetUserTickets_args{
  getUserTickets_args_userMids = P.maybe (getUserTickets_args_userMids default_GetUserTickets_args) (\(_,_val11080) -> (case _val11080 of {T.TList _ _val11081 -> (Vector.fromList $ P.map (\_v11082 -> (case _v11082 of {T.TString _val11083 -> E.decodeUtf8 _val11083; _ -> P.error "wrong type"})) _val11081); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTickets_args _ = P.error "not a struct"
read_GetUserTickets_args :: T.Protocol p => p -> P.IO GetUserTickets_args
read_GetUserTickets_args iprot = to_GetUserTickets_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTickets_args)
decode_GetUserTickets_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTickets_args
decode_GetUserTickets_args iprot bs = to_GetUserTickets_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTickets_args) bs
typemap_GetUserTickets_args :: T.TypeMap
typemap_GetUserTickets_args = Map.fromList [(1,("userMids",(T.T_LIST T.T_STRING)))]
default_GetUserTickets_args :: GetUserTickets_args
default_GetUserTickets_args = GetUserTickets_args{
  getUserTickets_args_userMids = Vector.empty}
data GetUserTickets_result = GetUserTickets_result  { getUserTickets_result_success :: (Vector.Vector UserTicketResponse)
  , getUserTickets_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTickets_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTickets_result_success record   `H.hashWithSalt` getUserTickets_result_e record  
instance QC.Arbitrary GetUserTickets_result where 
  arbitrary = M.liftM GetUserTickets_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserTickets_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTickets_result{getUserTickets_result_success = getUserTickets_result_success obj} then P.Nothing else P.Just $ default_GetUserTickets_result{getUserTickets_result_success = getUserTickets_result_success obj}
    , if obj == default_GetUserTickets_result{getUserTickets_result_e = getUserTickets_result_e obj} then P.Nothing else P.Just $ default_GetUserTickets_result{getUserTickets_result_e = getUserTickets_result_e obj}
    ]
from_GetUserTickets_result :: GetUserTickets_result -> T.ThriftVal
from_GetUserTickets_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11086 -> (1, ("e",from_TalkException _v11086))) <$> getUserTickets_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11086 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_UserTicketResponse) $ P.map (\_v11088 -> from_UserTicketResponse _v11088) $ Vector.toList _v11086))) $ getUserTickets_result_success record
    , (\_v11086 -> (1, ("e",from_TalkException _v11086))) <$> getUserTickets_result_e record
    ]
    )
write_GetUserTickets_result :: T.Protocol p => p -> GetUserTickets_result -> P.IO ()
write_GetUserTickets_result oprot record = T.writeVal oprot $ from_GetUserTickets_result record
encode_GetUserTickets_result :: T.StatelessProtocol p => p -> GetUserTickets_result -> LBS.ByteString
encode_GetUserTickets_result oprot record = T.serializeVal oprot $ from_GetUserTickets_result record
to_GetUserTickets_result :: T.ThriftVal -> GetUserTickets_result
to_GetUserTickets_result (T.TStruct fields) = GetUserTickets_result{
  getUserTickets_result_success = P.maybe (getUserTickets_result_success default_GetUserTickets_result) (\(_,_val11090) -> (case _val11090 of {T.TList _ _val11091 -> (Vector.fromList $ P.map (\_v11092 -> (case _v11092 of {T.TStruct _val11093 -> (to_UserTicketResponse (T.TStruct _val11093)); _ -> P.error "wrong type"})) _val11091); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserTickets_result_e = P.maybe (P.Nothing) (\(_,_val11090) -> P.Just (case _val11090 of {T.TStruct _val11094 -> (to_TalkException (T.TStruct _val11094)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTickets_result _ = P.error "not a struct"
read_GetUserTickets_result :: T.Protocol p => p -> P.IO GetUserTickets_result
read_GetUserTickets_result iprot = to_GetUserTickets_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTickets_result)
decode_GetUserTickets_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTickets_result
decode_GetUserTickets_result iprot bs = to_GetUserTickets_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTickets_result) bs
typemap_GetUserTickets_result :: T.TypeMap
typemap_GetUserTickets_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_UserTicketResponse)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserTickets_result :: GetUserTickets_result
default_GetUserTickets_result = GetUserTickets_result{
  getUserTickets_result_success = Vector.empty,
  getUserTickets_result_e = P.Nothing}
data GetOAFriendMids_args = GetOAFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetOAFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetOAFriendMids_args where 
  arbitrary = QC.elements [GetOAFriendMids_args]
from_GetOAFriendMids_args :: GetOAFriendMids_args -> T.ThriftVal
from_GetOAFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetOAFriendMids_args :: T.Protocol p => p -> GetOAFriendMids_args -> P.IO ()
write_GetOAFriendMids_args oprot record = T.writeVal oprot $ from_GetOAFriendMids_args record
encode_GetOAFriendMids_args :: T.StatelessProtocol p => p -> GetOAFriendMids_args -> LBS.ByteString
encode_GetOAFriendMids_args oprot record = T.serializeVal oprot $ from_GetOAFriendMids_args record
to_GetOAFriendMids_args :: T.ThriftVal -> GetOAFriendMids_args
to_GetOAFriendMids_args (T.TStruct fields) = GetOAFriendMids_args{

  }
to_GetOAFriendMids_args _ = P.error "not a struct"
read_GetOAFriendMids_args :: T.Protocol p => p -> P.IO GetOAFriendMids_args
read_GetOAFriendMids_args iprot = to_GetOAFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetOAFriendMids_args)
decode_GetOAFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetOAFriendMids_args
decode_GetOAFriendMids_args iprot bs = to_GetOAFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetOAFriendMids_args) bs
typemap_GetOAFriendMids_args :: T.TypeMap
typemap_GetOAFriendMids_args = Map.fromList []
default_GetOAFriendMids_args :: GetOAFriendMids_args
default_GetOAFriendMids_args = GetOAFriendMids_args{
}
data GetOAFriendMids_result = GetOAFriendMids_result  { getOAFriendMids_result_success :: (Vector.Vector LT.Text)
  , getOAFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetOAFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getOAFriendMids_result_success record   `H.hashWithSalt` getOAFriendMids_result_e record  
instance QC.Arbitrary GetOAFriendMids_result where 
  arbitrary = M.liftM GetOAFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetOAFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetOAFriendMids_result{getOAFriendMids_result_success = getOAFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetOAFriendMids_result{getOAFriendMids_result_success = getOAFriendMids_result_success obj}
    , if obj == default_GetOAFriendMids_result{getOAFriendMids_result_e = getOAFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetOAFriendMids_result{getOAFriendMids_result_e = getOAFriendMids_result_e obj}
    ]
from_GetOAFriendMids_result :: GetOAFriendMids_result -> T.ThriftVal
from_GetOAFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11102 -> (1, ("e",from_TalkException _v11102))) <$> getOAFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11102 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v11104 -> T.TString $ E.encodeUtf8 _v11104) $ Vector.toList _v11102))) $ getOAFriendMids_result_success record
    , (\_v11102 -> (1, ("e",from_TalkException _v11102))) <$> getOAFriendMids_result_e record
    ]
    )
write_GetOAFriendMids_result :: T.Protocol p => p -> GetOAFriendMids_result -> P.IO ()
write_GetOAFriendMids_result oprot record = T.writeVal oprot $ from_GetOAFriendMids_result record
encode_GetOAFriendMids_result :: T.StatelessProtocol p => p -> GetOAFriendMids_result -> LBS.ByteString
encode_GetOAFriendMids_result oprot record = T.serializeVal oprot $ from_GetOAFriendMids_result record
to_GetOAFriendMids_result :: T.ThriftVal -> GetOAFriendMids_result
to_GetOAFriendMids_result (T.TStruct fields) = GetOAFriendMids_result{
  getOAFriendMids_result_success = P.maybe (getOAFriendMids_result_success default_GetOAFriendMids_result) (\(_,_val11106) -> (case _val11106 of {T.TList _ _val11107 -> (Vector.fromList $ P.map (\_v11108 -> (case _v11108 of {T.TString _val11109 -> E.decodeUtf8 _val11109; _ -> P.error "wrong type"})) _val11107); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getOAFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val11106) -> P.Just (case _val11106 of {T.TStruct _val11110 -> (to_TalkException (T.TStruct _val11110)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetOAFriendMids_result _ = P.error "not a struct"
read_GetOAFriendMids_result :: T.Protocol p => p -> P.IO GetOAFriendMids_result
read_GetOAFriendMids_result iprot = to_GetOAFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetOAFriendMids_result)
decode_GetOAFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetOAFriendMids_result
decode_GetOAFriendMids_result iprot bs = to_GetOAFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetOAFriendMids_result) bs
typemap_GetOAFriendMids_result :: T.TypeMap
typemap_GetOAFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetOAFriendMids_result :: GetOAFriendMids_result
default_GetOAFriendMids_result = GetOAFriendMids_result{
  getOAFriendMids_result_success = Vector.empty,
  getOAFriendMids_result_e = P.Nothing}
data SearchPaidCallUserRate_args = SearchPaidCallUserRate_args  { searchPaidCallUserRate_args_countryCode :: LT.Text
  , searchPaidCallUserRate_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchPaidCallUserRate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchPaidCallUserRate_args_countryCode record   `H.hashWithSalt` searchPaidCallUserRate_args_language record  
instance QC.Arbitrary SearchPaidCallUserRate_args where 
  arbitrary = M.liftM SearchPaidCallUserRate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchPaidCallUserRate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_countryCode = searchPaidCallUserRate_args_countryCode obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_countryCode = searchPaidCallUserRate_args_countryCode obj}
    , if obj == default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_language = searchPaidCallUserRate_args_language obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_language = searchPaidCallUserRate_args_language obj}
    ]
from_SearchPaidCallUserRate_args :: SearchPaidCallUserRate_args -> T.ThriftVal
from_SearchPaidCallUserRate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11113 -> P.Just (2, ("countryCode",T.TString $ E.encodeUtf8 _v11113))) $ searchPaidCallUserRate_args_countryCode record
  , (\_v11113 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v11113))) $ searchPaidCallUserRate_args_language record
  ]
write_SearchPaidCallUserRate_args :: T.Protocol p => p -> SearchPaidCallUserRate_args -> P.IO ()
write_SearchPaidCallUserRate_args oprot record = T.writeVal oprot $ from_SearchPaidCallUserRate_args record
encode_SearchPaidCallUserRate_args :: T.StatelessProtocol p => p -> SearchPaidCallUserRate_args -> LBS.ByteString
encode_SearchPaidCallUserRate_args oprot record = T.serializeVal oprot $ from_SearchPaidCallUserRate_args record
to_SearchPaidCallUserRate_args :: T.ThriftVal -> SearchPaidCallUserRate_args
to_SearchPaidCallUserRate_args (T.TStruct fields) = SearchPaidCallUserRate_args{
  searchPaidCallUserRate_args_countryCode = P.maybe (searchPaidCallUserRate_args_countryCode default_SearchPaidCallUserRate_args) (\(_,_val11115) -> (case _val11115 of {T.TString _val11116 -> E.decodeUtf8 _val11116; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchPaidCallUserRate_args_language = P.maybe (searchPaidCallUserRate_args_language default_SearchPaidCallUserRate_args) (\(_,_val11115) -> (case _val11115 of {T.TString _val11117 -> E.decodeUtf8 _val11117; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SearchPaidCallUserRate_args _ = P.error "not a struct"
read_SearchPaidCallUserRate_args :: T.Protocol p => p -> P.IO SearchPaidCallUserRate_args
read_SearchPaidCallUserRate_args iprot = to_SearchPaidCallUserRate_args <$> T.readVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_args)
decode_SearchPaidCallUserRate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchPaidCallUserRate_args
decode_SearchPaidCallUserRate_args iprot bs = to_SearchPaidCallUserRate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_args) bs
typemap_SearchPaidCallUserRate_args :: T.TypeMap
typemap_SearchPaidCallUserRate_args = Map.fromList [(2,("countryCode",T.T_STRING)),(3,("language",T.T_STRING))]
default_SearchPaidCallUserRate_args :: SearchPaidCallUserRate_args
default_SearchPaidCallUserRate_args = SearchPaidCallUserRate_args{
  searchPaidCallUserRate_args_countryCode = "",
  searchPaidCallUserRate_args_language = ""}
data SearchPaidCallUserRate_result = SearchPaidCallUserRate_result  { searchPaidCallUserRate_result_success :: (Vector.Vector PaidCallUserRate)
  , searchPaidCallUserRate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchPaidCallUserRate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchPaidCallUserRate_result_success record   `H.hashWithSalt` searchPaidCallUserRate_result_e record  
instance QC.Arbitrary SearchPaidCallUserRate_result where 
  arbitrary = M.liftM SearchPaidCallUserRate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchPaidCallUserRate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = searchPaidCallUserRate_result_success obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = searchPaidCallUserRate_result_success obj}
    , if obj == default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = searchPaidCallUserRate_result_e obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = searchPaidCallUserRate_result_e obj}
    ]
from_SearchPaidCallUserRate_result :: SearchPaidCallUserRate_result -> T.ThriftVal
from_SearchPaidCallUserRate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11120 -> (1, ("e",from_TalkException _v11120))) <$> searchPaidCallUserRate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11120 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallUserRate) $ P.map (\_v11122 -> from_PaidCallUserRate _v11122) $ Vector.toList _v11120))) $ searchPaidCallUserRate_result_success record
    , (\_v11120 -> (1, ("e",from_TalkException _v11120))) <$> searchPaidCallUserRate_result_e record
    ]
    )
write_SearchPaidCallUserRate_result :: T.Protocol p => p -> SearchPaidCallUserRate_result -> P.IO ()
write_SearchPaidCallUserRate_result oprot record = T.writeVal oprot $ from_SearchPaidCallUserRate_result record
encode_SearchPaidCallUserRate_result :: T.StatelessProtocol p => p -> SearchPaidCallUserRate_result -> LBS.ByteString
encode_SearchPaidCallUserRate_result oprot record = T.serializeVal oprot $ from_SearchPaidCallUserRate_result record
to_SearchPaidCallUserRate_result :: T.ThriftVal -> SearchPaidCallUserRate_result
to_SearchPaidCallUserRate_result (T.TStruct fields) = SearchPaidCallUserRate_result{
  searchPaidCallUserRate_result_success = P.maybe (searchPaidCallUserRate_result_success default_SearchPaidCallUserRate_result) (\(_,_val11124) -> (case _val11124 of {T.TList _ _val11125 -> (Vector.fromList $ P.map (\_v11126 -> (case _v11126 of {T.TStruct _val11127 -> (to_PaidCallUserRate (T.TStruct _val11127)); _ -> P.error "wrong type"})) _val11125); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  searchPaidCallUserRate_result_e = P.maybe (P.Nothing) (\(_,_val11124) -> P.Just (case _val11124 of {T.TStruct _val11128 -> (to_TalkException (T.TStruct _val11128)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchPaidCallUserRate_result _ = P.error "not a struct"
read_SearchPaidCallUserRate_result :: T.Protocol p => p -> P.IO SearchPaidCallUserRate_result
read_SearchPaidCallUserRate_result iprot = to_SearchPaidCallUserRate_result <$> T.readVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_result)
decode_SearchPaidCallUserRate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchPaidCallUserRate_result
decode_SearchPaidCallUserRate_result iprot bs = to_SearchPaidCallUserRate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_result) bs
typemap_SearchPaidCallUserRate_result :: T.TypeMap
typemap_SearchPaidCallUserRate_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallUserRate)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SearchPaidCallUserRate_result :: SearchPaidCallUserRate_result
default_SearchPaidCallUserRate_result = SearchPaidCallUserRate_result{
  searchPaidCallUserRate_result_success = Vector.empty,
  searchPaidCallUserRate_result_e = P.Nothing}
data GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetJoinedGroupIdsForChannel_args]
from_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_args -> P.IO ()
write_GetJoinedGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
encode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_args -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
to_GetJoinedGroupIdsForChannel_args :: T.ThriftVal -> GetJoinedGroupIdsForChannel_args
to_GetJoinedGroupIdsForChannel_args (T.TStruct fields) = GetJoinedGroupIdsForChannel_args{

  }
to_GetJoinedGroupIdsForChannel_args _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_args
read_GetJoinedGroupIdsForChannel_args iprot = to_GetJoinedGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args)
decode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_args
decode_GetJoinedGroupIdsForChannel_args iprot bs = to_GetJoinedGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args) bs
typemap_GetJoinedGroupIdsForChannel_args :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_args = Map.fromList []
default_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args
default_GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args{
}
data GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result  { getJoinedGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getJoinedGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_success record   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_result where 
  arbitrary = M.liftM GetJoinedGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj}
    , if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj}
    ]
from_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11136 -> (1, ("e",from_TalkException _v11136))) <$> getJoinedGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11136 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v11138 -> T.TString $ E.encodeUtf8 _v11138) $ Vector.toList _v11136))) $ getJoinedGroupIdsForChannel_result_success record
    , (\_v11136 -> (1, ("e",from_TalkException _v11136))) <$> getJoinedGroupIdsForChannel_result_e record
    ]
    )
write_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_result -> P.IO ()
write_GetJoinedGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
encode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_result -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
to_GetJoinedGroupIdsForChannel_result :: T.ThriftVal -> GetJoinedGroupIdsForChannel_result
to_GetJoinedGroupIdsForChannel_result (T.TStruct fields) = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = P.maybe (getJoinedGroupIdsForChannel_result_success default_GetJoinedGroupIdsForChannel_result) (\(_,_val11140) -> (case _val11140 of {T.TList _ _val11141 -> (Vector.fromList $ P.map (\_v11142 -> (case _v11142 of {T.TString _val11143 -> E.decodeUtf8 _val11143; _ -> P.error "wrong type"})) _val11141); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val11140) -> P.Just (case _val11140 of {T.TStruct _val11144 -> (to_TalkException (T.TStruct _val11144)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedGroupIdsForChannel_result _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_result
read_GetJoinedGroupIdsForChannel_result iprot = to_GetJoinedGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result)
decode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_result
decode_GetJoinedGroupIdsForChannel_result iprot bs = to_GetJoinedGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result) bs
typemap_GetJoinedGroupIdsForChannel_result :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result
default_GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = Vector.empty,
  getJoinedGroupIdsForChannel_result_e = P.Nothing}
data AcquireGroupCallRoute_args = AcquireGroupCallRoute_args  { acquireGroupCallRoute_args_chatMid :: LT.Text
  , acquireGroupCallRoute_args_mediaType :: GroupCallMediaType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireGroupCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireGroupCallRoute_args_chatMid record   `H.hashWithSalt` acquireGroupCallRoute_args_mediaType record  
instance QC.Arbitrary AcquireGroupCallRoute_args where 
  arbitrary = M.liftM AcquireGroupCallRoute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcquireGroupCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_chatMid = acquireGroupCallRoute_args_chatMid obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_chatMid = acquireGroupCallRoute_args_chatMid obj}
    , if obj == default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_mediaType = acquireGroupCallRoute_args_mediaType obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_mediaType = acquireGroupCallRoute_args_mediaType obj}
    ]
from_AcquireGroupCallRoute_args :: AcquireGroupCallRoute_args -> T.ThriftVal
from_AcquireGroupCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11147 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v11147))) $ acquireGroupCallRoute_args_chatMid record
  , (\_v11147 -> P.Just (3, ("mediaType",T.TI32 $ P.fromIntegral $ P.fromEnum _v11147))) $ acquireGroupCallRoute_args_mediaType record
  ]
write_AcquireGroupCallRoute_args :: T.Protocol p => p -> AcquireGroupCallRoute_args -> P.IO ()
write_AcquireGroupCallRoute_args oprot record = T.writeVal oprot $ from_AcquireGroupCallRoute_args record
encode_AcquireGroupCallRoute_args :: T.StatelessProtocol p => p -> AcquireGroupCallRoute_args -> LBS.ByteString
encode_AcquireGroupCallRoute_args oprot record = T.serializeVal oprot $ from_AcquireGroupCallRoute_args record
to_AcquireGroupCallRoute_args :: T.ThriftVal -> AcquireGroupCallRoute_args
to_AcquireGroupCallRoute_args (T.TStruct fields) = AcquireGroupCallRoute_args{
  acquireGroupCallRoute_args_chatMid = P.maybe (acquireGroupCallRoute_args_chatMid default_AcquireGroupCallRoute_args) (\(_,_val11149) -> (case _val11149 of {T.TString _val11150 -> E.decodeUtf8 _val11150; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acquireGroupCallRoute_args_mediaType = P.maybe (acquireGroupCallRoute_args_mediaType default_AcquireGroupCallRoute_args) (\(_,_val11149) -> (case _val11149 of {T.TI32 _val11151 -> P.toEnum $ P.fromIntegral _val11151; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AcquireGroupCallRoute_args _ = P.error "not a struct"
read_AcquireGroupCallRoute_args :: T.Protocol p => p -> P.IO AcquireGroupCallRoute_args
read_AcquireGroupCallRoute_args iprot = to_AcquireGroupCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_args)
decode_AcquireGroupCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireGroupCallRoute_args
decode_AcquireGroupCallRoute_args iprot bs = to_AcquireGroupCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_args) bs
typemap_AcquireGroupCallRoute_args :: T.TypeMap
typemap_AcquireGroupCallRoute_args = Map.fromList [(2,("chatMid",T.T_STRING)),(3,("mediaType",T.T_I32))]
default_AcquireGroupCallRoute_args :: AcquireGroupCallRoute_args
default_AcquireGroupCallRoute_args = AcquireGroupCallRoute_args{
  acquireGroupCallRoute_args_chatMid = "",
  acquireGroupCallRoute_args_mediaType = (P.toEnum 0)}
data AcquireGroupCallRoute_result = AcquireGroupCallRoute_result  { acquireGroupCallRoute_result_success :: GroupCallRoute
  , acquireGroupCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireGroupCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireGroupCallRoute_result_success record   `H.hashWithSalt` acquireGroupCallRoute_result_e record  
instance QC.Arbitrary AcquireGroupCallRoute_result where 
  arbitrary = M.liftM AcquireGroupCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireGroupCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = acquireGroupCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = acquireGroupCallRoute_result_success obj}
    , if obj == default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = acquireGroupCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = acquireGroupCallRoute_result_e obj}
    ]
from_AcquireGroupCallRoute_result :: AcquireGroupCallRoute_result -> T.ThriftVal
from_AcquireGroupCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11154 -> (1, ("e",from_TalkException _v11154))) <$> acquireGroupCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11154 -> P.Just (0, ("success",from_GroupCallRoute _v11154))) $ acquireGroupCallRoute_result_success record
    , (\_v11154 -> (1, ("e",from_TalkException _v11154))) <$> acquireGroupCallRoute_result_e record
    ]
    )
write_AcquireGroupCallRoute_result :: T.Protocol p => p -> AcquireGroupCallRoute_result -> P.IO ()
write_AcquireGroupCallRoute_result oprot record = T.writeVal oprot $ from_AcquireGroupCallRoute_result record
encode_AcquireGroupCallRoute_result :: T.StatelessProtocol p => p -> AcquireGroupCallRoute_result -> LBS.ByteString
encode_AcquireGroupCallRoute_result oprot record = T.serializeVal oprot $ from_AcquireGroupCallRoute_result record
to_AcquireGroupCallRoute_result :: T.ThriftVal -> AcquireGroupCallRoute_result
to_AcquireGroupCallRoute_result (T.TStruct fields) = AcquireGroupCallRoute_result{
  acquireGroupCallRoute_result_success = P.maybe (acquireGroupCallRoute_result_success default_AcquireGroupCallRoute_result) (\(_,_val11156) -> (case _val11156 of {T.TStruct _val11157 -> (to_GroupCallRoute (T.TStruct _val11157)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireGroupCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val11156) -> P.Just (case _val11156 of {T.TStruct _val11158 -> (to_TalkException (T.TStruct _val11158)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireGroupCallRoute_result _ = P.error "not a struct"
read_AcquireGroupCallRoute_result :: T.Protocol p => p -> P.IO AcquireGroupCallRoute_result
read_AcquireGroupCallRoute_result iprot = to_AcquireGroupCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_result)
decode_AcquireGroupCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireGroupCallRoute_result
decode_AcquireGroupCallRoute_result iprot bs = to_AcquireGroupCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_result) bs
typemap_AcquireGroupCallRoute_result :: T.TypeMap
typemap_AcquireGroupCallRoute_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GroupCallRoute))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireGroupCallRoute_result :: AcquireGroupCallRoute_result
default_AcquireGroupCallRoute_result = AcquireGroupCallRoute_result{
  acquireGroupCallRoute_result_success = default_GroupCallRoute,
  acquireGroupCallRoute_result_e = P.Nothing}
data GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserMidsWhoAddedMe_args where 
  arbitrary = QC.elements [GetUserMidsWhoAddedMe_args]
from_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args -> T.ThriftVal
from_GetUserMidsWhoAddedMe_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> GetUserMidsWhoAddedMe_args -> P.IO ()
write_GetUserMidsWhoAddedMe_args oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_args record
encode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_args -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_args oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_args record
to_GetUserMidsWhoAddedMe_args :: T.ThriftVal -> GetUserMidsWhoAddedMe_args
to_GetUserMidsWhoAddedMe_args (T.TStruct fields) = GetUserMidsWhoAddedMe_args{

  }
to_GetUserMidsWhoAddedMe_args _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_args
read_GetUserMidsWhoAddedMe_args iprot = to_GetUserMidsWhoAddedMe_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args)
decode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_args
decode_GetUserMidsWhoAddedMe_args iprot bs = to_GetUserMidsWhoAddedMe_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args) bs
typemap_GetUserMidsWhoAddedMe_args :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_args = Map.fromList []
default_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args
default_GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args{
}
data GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result  { getUserMidsWhoAddedMe_result_success :: (Vector.Vector LT.Text)
  , getUserMidsWhoAddedMe_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserMidsWhoAddedMe_result_success record   `H.hashWithSalt` getUserMidsWhoAddedMe_result_e record  
instance QC.Arbitrary GetUserMidsWhoAddedMe_result where 
  arbitrary = M.liftM GetUserMidsWhoAddedMe_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserMidsWhoAddedMe_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj}
    , if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj}
    ]
from_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result -> T.ThriftVal
from_GetUserMidsWhoAddedMe_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11166 -> (1, ("e",from_TalkException _v11166))) <$> getUserMidsWhoAddedMe_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11166 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v11168 -> T.TString $ E.encodeUtf8 _v11168) $ Vector.toList _v11166))) $ getUserMidsWhoAddedMe_result_success record
    , (\_v11166 -> (1, ("e",from_TalkException _v11166))) <$> getUserMidsWhoAddedMe_result_e record
    ]
    )
write_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> GetUserMidsWhoAddedMe_result -> P.IO ()
write_GetUserMidsWhoAddedMe_result oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_result record
encode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_result -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_result oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_result record
to_GetUserMidsWhoAddedMe_result :: T.ThriftVal -> GetUserMidsWhoAddedMe_result
to_GetUserMidsWhoAddedMe_result (T.TStruct fields) = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = P.maybe (getUserMidsWhoAddedMe_result_success default_GetUserMidsWhoAddedMe_result) (\(_,_val11170) -> (case _val11170 of {T.TList _ _val11171 -> (Vector.fromList $ P.map (\_v11172 -> (case _v11172 of {T.TString _val11173 -> E.decodeUtf8 _val11173; _ -> P.error "wrong type"})) _val11171); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserMidsWhoAddedMe_result_e = P.maybe (P.Nothing) (\(_,_val11170) -> P.Just (case _val11170 of {T.TStruct _val11174 -> (to_TalkException (T.TStruct _val11174)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserMidsWhoAddedMe_result _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_result
read_GetUserMidsWhoAddedMe_result iprot = to_GetUserMidsWhoAddedMe_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result)
decode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_result
decode_GetUserMidsWhoAddedMe_result iprot bs = to_GetUserMidsWhoAddedMe_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result) bs
typemap_GetUserMidsWhoAddedMe_result :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result
default_GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = Vector.empty,
  getUserMidsWhoAddedMe_result_e = P.Nothing}
data GetIdentityCredential_args = GetIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityCredential_args where 
  arbitrary = QC.elements [GetIdentityCredential_args]
from_GetIdentityCredential_args :: GetIdentityCredential_args -> T.ThriftVal
from_GetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityCredential_args :: T.Protocol p => p -> GetIdentityCredential_args -> P.IO ()
write_GetIdentityCredential_args oprot record = T.writeVal oprot $ from_GetIdentityCredential_args record
encode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> GetIdentityCredential_args -> LBS.ByteString
encode_GetIdentityCredential_args oprot record = T.serializeVal oprot $ from_GetIdentityCredential_args record
to_GetIdentityCredential_args :: T.ThriftVal -> GetIdentityCredential_args
to_GetIdentityCredential_args (T.TStruct fields) = GetIdentityCredential_args{

  }
to_GetIdentityCredential_args _ = P.error "not a struct"
read_GetIdentityCredential_args :: T.Protocol p => p -> P.IO GetIdentityCredential_args
read_GetIdentityCredential_args iprot = to_GetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args)
decode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_args
decode_GetIdentityCredential_args iprot bs = to_GetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args) bs
typemap_GetIdentityCredential_args :: T.TypeMap
typemap_GetIdentityCredential_args = Map.fromList []
default_GetIdentityCredential_args :: GetIdentityCredential_args
default_GetIdentityCredential_args = GetIdentityCredential_args{
}
data GetIdentityCredential_result = GetIdentityCredential_result  { getIdentityCredential_result_success :: IdentityCredential
  , getIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityCredential_result_success record   `H.hashWithSalt` getIdentityCredential_result_e record  
instance QC.Arbitrary GetIdentityCredential_result where 
  arbitrary = M.liftM GetIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj}
    , if obj == default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj}
    ]
from_GetIdentityCredential_result :: GetIdentityCredential_result -> T.ThriftVal
from_GetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11182 -> (1, ("e",from_TalkException _v11182))) <$> getIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11182 -> P.Just (0, ("success",from_IdentityCredential _v11182))) $ getIdentityCredential_result_success record
    , (\_v11182 -> (1, ("e",from_TalkException _v11182))) <$> getIdentityCredential_result_e record
    ]
    )
write_GetIdentityCredential_result :: T.Protocol p => p -> GetIdentityCredential_result -> P.IO ()
write_GetIdentityCredential_result oprot record = T.writeVal oprot $ from_GetIdentityCredential_result record
encode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> GetIdentityCredential_result -> LBS.ByteString
encode_GetIdentityCredential_result oprot record = T.serializeVal oprot $ from_GetIdentityCredential_result record
to_GetIdentityCredential_result :: T.ThriftVal -> GetIdentityCredential_result
to_GetIdentityCredential_result (T.TStruct fields) = GetIdentityCredential_result{
  getIdentityCredential_result_success = P.maybe (getIdentityCredential_result_success default_GetIdentityCredential_result) (\(_,_val11184) -> (case _val11184 of {T.TStruct _val11185 -> (to_IdentityCredential (T.TStruct _val11185)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val11184) -> P.Just (case _val11184 of {T.TStruct _val11186 -> (to_TalkException (T.TStruct _val11186)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityCredential_result _ = P.error "not a struct"
read_GetIdentityCredential_result :: T.Protocol p => p -> P.IO GetIdentityCredential_result
read_GetIdentityCredential_result iprot = to_GetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result)
decode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_result
decode_GetIdentityCredential_result iprot bs = to_GetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result) bs
typemap_GetIdentityCredential_result :: T.TypeMap
typemap_GetIdentityCredential_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_IdentityCredential))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityCredential_result :: GetIdentityCredential_result
default_GetIdentityCredential_result = GetIdentityCredential_result{
  getIdentityCredential_result_success = default_IdentityCredential,
  getIdentityCredential_result_e = P.Nothing}
data AddOperationForChannel_args = AddOperationForChannel_args  { addOperationForChannel_args_opType :: OpType
  , addOperationForChannel_args_param1 :: LT.Text
  , addOperationForChannel_args_param2 :: LT.Text
  , addOperationForChannel_args_param3 :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_args_opType record   `H.hashWithSalt` addOperationForChannel_args_param1 record   `H.hashWithSalt` addOperationForChannel_args_param2 record   `H.hashWithSalt` addOperationForChannel_args_param3 record  
instance QC.Arbitrary AddOperationForChannel_args where 
  arbitrary = M.liftM AddOperationForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj}
    ]
from_AddOperationForChannel_args :: AddOperationForChannel_args -> T.ThriftVal
from_AddOperationForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11189 -> P.Just (1, ("opType",T.TI32 $ P.fromIntegral $ P.fromEnum _v11189))) $ addOperationForChannel_args_opType record
  , (\_v11189 -> P.Just (2, ("param1",T.TString $ E.encodeUtf8 _v11189))) $ addOperationForChannel_args_param1 record
  , (\_v11189 -> P.Just (3, ("param2",T.TString $ E.encodeUtf8 _v11189))) $ addOperationForChannel_args_param2 record
  , (\_v11189 -> P.Just (4, ("param3",T.TString $ E.encodeUtf8 _v11189))) $ addOperationForChannel_args_param3 record
  ]
write_AddOperationForChannel_args :: T.Protocol p => p -> AddOperationForChannel_args -> P.IO ()
write_AddOperationForChannel_args oprot record = T.writeVal oprot $ from_AddOperationForChannel_args record
encode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> AddOperationForChannel_args -> LBS.ByteString
encode_AddOperationForChannel_args oprot record = T.serializeVal oprot $ from_AddOperationForChannel_args record
to_AddOperationForChannel_args :: T.ThriftVal -> AddOperationForChannel_args
to_AddOperationForChannel_args (T.TStruct fields) = AddOperationForChannel_args{
  addOperationForChannel_args_opType = P.maybe (addOperationForChannel_args_opType default_AddOperationForChannel_args) (\(_,_val11191) -> (case _val11191 of {T.TI32 _val11192 -> P.toEnum $ P.fromIntegral _val11192; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addOperationForChannel_args_param1 = P.maybe (addOperationForChannel_args_param1 default_AddOperationForChannel_args) (\(_,_val11191) -> (case _val11191 of {T.TString _val11193 -> E.decodeUtf8 _val11193; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addOperationForChannel_args_param2 = P.maybe (addOperationForChannel_args_param2 default_AddOperationForChannel_args) (\(_,_val11191) -> (case _val11191 of {T.TString _val11194 -> E.decodeUtf8 _val11194; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  addOperationForChannel_args_param3 = P.maybe (addOperationForChannel_args_param3 default_AddOperationForChannel_args) (\(_,_val11191) -> (case _val11191 of {T.TString _val11195 -> E.decodeUtf8 _val11195; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_AddOperationForChannel_args _ = P.error "not a struct"
read_AddOperationForChannel_args :: T.Protocol p => p -> P.IO AddOperationForChannel_args
read_AddOperationForChannel_args iprot = to_AddOperationForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args)
decode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_args
decode_AddOperationForChannel_args iprot bs = to_AddOperationForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args) bs
typemap_AddOperationForChannel_args :: T.TypeMap
typemap_AddOperationForChannel_args = Map.fromList [(1,("opType",T.T_I32)),(2,("param1",T.T_STRING)),(3,("param2",T.T_STRING)),(4,("param3",T.T_STRING))]
default_AddOperationForChannel_args :: AddOperationForChannel_args
default_AddOperationForChannel_args = AddOperationForChannel_args{
  addOperationForChannel_args_opType = (P.toEnum 0),
  addOperationForChannel_args_param1 = "",
  addOperationForChannel_args_param2 = "",
  addOperationForChannel_args_param3 = ""}
data AddOperationForChannel_result = AddOperationForChannel_result  { addOperationForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_result_e record  
instance QC.Arbitrary AddOperationForChannel_result where 
  arbitrary = M.liftM AddOperationForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj} then P.Nothing else P.Just $ default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj}
    ]
from_AddOperationForChannel_result :: AddOperationForChannel_result -> T.ThriftVal
from_AddOperationForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11198 -> (1, ("e",from_TalkException _v11198))) <$> addOperationForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11198 -> (1, ("e",from_TalkException _v11198))) <$> addOperationForChannel_result_e record
    ]
    )
write_AddOperationForChannel_result :: T.Protocol p => p -> AddOperationForChannel_result -> P.IO ()
write_AddOperationForChannel_result oprot record = T.writeVal oprot $ from_AddOperationForChannel_result record
encode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> AddOperationForChannel_result -> LBS.ByteString
encode_AddOperationForChannel_result oprot record = T.serializeVal oprot $ from_AddOperationForChannel_result record
to_AddOperationForChannel_result :: T.ThriftVal -> AddOperationForChannel_result
to_AddOperationForChannel_result (T.TStruct fields) = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.maybe (P.Nothing) (\(_,_val11200) -> P.Just (case _val11200 of {T.TStruct _val11201 -> (to_TalkException (T.TStruct _val11201)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddOperationForChannel_result _ = P.error "not a struct"
read_AddOperationForChannel_result :: T.Protocol p => p -> P.IO AddOperationForChannel_result
read_AddOperationForChannel_result iprot = to_AddOperationForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result)
decode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_result
decode_AddOperationForChannel_result iprot bs = to_AddOperationForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result) bs
typemap_AddOperationForChannel_result :: T.TypeMap
typemap_AddOperationForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddOperationForChannel_result :: AddOperationForChannel_result
default_AddOperationForChannel_result = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.Nothing}
data GetSimpleChannelContacts_args = GetSimpleChannelContacts_args  { getSimpleChannelContacts_args_ids :: (Vector.Vector LT.Text)
  , getSimpleChannelContacts_args_statusSticonFallbackDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_args_ids record   `H.hashWithSalt` getSimpleChannelContacts_args_statusSticonFallbackDisabled record  
instance QC.Arbitrary GetSimpleChannelContacts_args where 
  arbitrary = M.liftM GetSimpleChannelContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj}
    , if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_statusSticonFallbackDisabled = getSimpleChannelContacts_args_statusSticonFallbackDisabled obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_statusSticonFallbackDisabled = getSimpleChannelContacts_args_statusSticonFallbackDisabled obj}
    ]
from_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args -> T.ThriftVal
from_GetSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11204 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v11206 -> T.TString $ E.encodeUtf8 _v11206) $ Vector.toList _v11204))) $ getSimpleChannelContacts_args_ids record
  , (\_v11204 -> P.Just (2, ("statusSticonFallbackDisabled",T.TBool _v11204))) $ getSimpleChannelContacts_args_statusSticonFallbackDisabled record
  ]
write_GetSimpleChannelContacts_args :: T.Protocol p => p -> GetSimpleChannelContacts_args -> P.IO ()
write_GetSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_args record
encode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_args -> LBS.ByteString
encode_GetSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_args record
to_GetSimpleChannelContacts_args :: T.ThriftVal -> GetSimpleChannelContacts_args
to_GetSimpleChannelContacts_args (T.TStruct fields) = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = P.maybe (getSimpleChannelContacts_args_ids default_GetSimpleChannelContacts_args) (\(_,_val11208) -> (case _val11208 of {T.TList _ _val11209 -> (Vector.fromList $ P.map (\_v11210 -> (case _v11210 of {T.TString _val11211 -> E.decodeUtf8 _val11211; _ -> P.error "wrong type"})) _val11209); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSimpleChannelContacts_args_statusSticonFallbackDisabled = P.maybe (getSimpleChannelContacts_args_statusSticonFallbackDisabled default_GetSimpleChannelContacts_args) (\(_,_val11208) -> (case _val11208 of {T.TBool _val11212 -> _val11212; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSimpleChannelContacts_args _ = P.error "not a struct"
read_GetSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_args
read_GetSimpleChannelContacts_args iprot = to_GetSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args)
decode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_args
decode_GetSimpleChannelContacts_args iprot bs = to_GetSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args) bs
typemap_GetSimpleChannelContacts_args :: T.TypeMap
typemap_GetSimpleChannelContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING))),(2,("statusSticonFallbackDisabled",T.T_BOOL))]
default_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args
default_GetSimpleChannelContacts_args = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = Vector.empty,
  getSimpleChannelContacts_args_statusSticonFallbackDisabled = P.False}
data GetSimpleChannelContacts_result = GetSimpleChannelContacts_result  { getSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_result_success record   `H.hashWithSalt` getSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetSimpleChannelContacts_result where 
  arbitrary = M.liftM GetSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj}
    , if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj}
    ]
from_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result -> T.ThriftVal
from_GetSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11215 -> (1, ("e",from_TalkException _v11215))) <$> getSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11215 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v11217 -> from_SimpleChannelContact _v11217) $ Vector.toList _v11215))) $ getSimpleChannelContacts_result_success record
    , (\_v11215 -> (1, ("e",from_TalkException _v11215))) <$> getSimpleChannelContacts_result_e record
    ]
    )
write_GetSimpleChannelContacts_result :: T.Protocol p => p -> GetSimpleChannelContacts_result -> P.IO ()
write_GetSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_result record
encode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_result -> LBS.ByteString
encode_GetSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_result record
to_GetSimpleChannelContacts_result :: T.ThriftVal -> GetSimpleChannelContacts_result
to_GetSimpleChannelContacts_result (T.TStruct fields) = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = P.maybe (getSimpleChannelContacts_result_success default_GetSimpleChannelContacts_result) (\(_,_val11219) -> (case _val11219 of {T.TList _ _val11220 -> (Vector.fromList $ P.map (\_v11221 -> (case _v11221 of {T.TStruct _val11222 -> (to_SimpleChannelContact (T.TStruct _val11222)); _ -> P.error "wrong type"})) _val11220); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val11219) -> P.Just (case _val11219 of {T.TStruct _val11223 -> (to_TalkException (T.TStruct _val11223)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_result _ = P.error "not a struct"
read_GetSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_result
read_GetSimpleChannelContacts_result iprot = to_GetSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result)
decode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_result
decode_GetSimpleChannelContacts_result iprot bs = to_GetSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result) bs
typemap_GetSimpleChannelContacts_result :: T.TypeMap
typemap_GetSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result
default_GetSimpleChannelContacts_result = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = Vector.empty,
  getSimpleChannelContacts_result_e = P.Nothing}
data GetUserLastSentMessageTimeStamp_args = GetUserLastSentMessageTimeStamp_args  { getUserLastSentMessageTimeStamp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLastSentMessageTimeStamp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLastSentMessageTimeStamp_args_mid record  
instance QC.Arbitrary GetUserLastSentMessageTimeStamp_args where 
  arbitrary = M.liftM GetUserLastSentMessageTimeStamp_args (QC.arbitrary)
  shrink obj | obj == default_GetUserLastSentMessageTimeStamp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLastSentMessageTimeStamp_args{getUserLastSentMessageTimeStamp_args_mid = getUserLastSentMessageTimeStamp_args_mid obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_args{getUserLastSentMessageTimeStamp_args_mid = getUserLastSentMessageTimeStamp_args_mid obj}
    ]
from_GetUserLastSentMessageTimeStamp_args :: GetUserLastSentMessageTimeStamp_args -> T.ThriftVal
from_GetUserLastSentMessageTimeStamp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v11226 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v11226))) $ getUserLastSentMessageTimeStamp_args_mid record
  ]
write_GetUserLastSentMessageTimeStamp_args :: T.Protocol p => p -> GetUserLastSentMessageTimeStamp_args -> P.IO ()
write_GetUserLastSentMessageTimeStamp_args oprot record = T.writeVal oprot $ from_GetUserLastSentMessageTimeStamp_args record
encode_GetUserLastSentMessageTimeStamp_args :: T.StatelessProtocol p => p -> GetUserLastSentMessageTimeStamp_args -> LBS.ByteString
encode_GetUserLastSentMessageTimeStamp_args oprot record = T.serializeVal oprot $ from_GetUserLastSentMessageTimeStamp_args record
to_GetUserLastSentMessageTimeStamp_args :: T.ThriftVal -> GetUserLastSentMessageTimeStamp_args
to_GetUserLastSentMessageTimeStamp_args (T.TStruct fields) = GetUserLastSentMessageTimeStamp_args{
  getUserLastSentMessageTimeStamp_args_mid = P.maybe (getUserLastSentMessageTimeStamp_args_mid default_GetUserLastSentMessageTimeStamp_args) (\(_,_val11228) -> (case _val11228 of {T.TString _val11229 -> E.decodeUtf8 _val11229; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLastSentMessageTimeStamp_args _ = P.error "not a struct"
read_GetUserLastSentMessageTimeStamp_args :: T.Protocol p => p -> P.IO GetUserLastSentMessageTimeStamp_args
read_GetUserLastSentMessageTimeStamp_args iprot = to_GetUserLastSentMessageTimeStamp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_args)
decode_GetUserLastSentMessageTimeStamp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLastSentMessageTimeStamp_args
decode_GetUserLastSentMessageTimeStamp_args iprot bs = to_GetUserLastSentMessageTimeStamp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_args) bs
typemap_GetUserLastSentMessageTimeStamp_args :: T.TypeMap
typemap_GetUserLastSentMessageTimeStamp_args = Map.fromList [(1,("mid",T.T_STRING))]
default_GetUserLastSentMessageTimeStamp_args :: GetUserLastSentMessageTimeStamp_args
default_GetUserLastSentMessageTimeStamp_args = GetUserLastSentMessageTimeStamp_args{
  getUserLastSentMessageTimeStamp_args_mid = ""}
data GetUserLastSentMessageTimeStamp_result = GetUserLastSentMessageTimeStamp_result  { getUserLastSentMessageTimeStamp_result_success :: I.Int64
  , getUserLastSentMessageTimeStamp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLastSentMessageTimeStamp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLastSentMessageTimeStamp_result_success record   `H.hashWithSalt` getUserLastSentMessageTimeStamp_result_e record  
instance QC.Arbitrary GetUserLastSentMessageTimeStamp_result where 
  arbitrary = M.liftM GetUserLastSentMessageTimeStamp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLastSentMessageTimeStamp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = getUserLastSentMessageTimeStamp_result_success obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = getUserLastSentMessageTimeStamp_result_success obj}
    , if obj == default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = getUserLastSentMessageTimeStamp_result_e obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = getUserLastSentMessageTimeStamp_result_e obj}
    ]
from_GetUserLastSentMessageTimeStamp_result :: GetUserLastSentMessageTimeStamp_result -> T.ThriftVal
from_GetUserLastSentMessageTimeStamp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v11232 -> (1, ("e",from_TalkException _v11232))) <$> getUserLastSentMessageTimeStamp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v11232 -> P.Just (0, ("success",T.TI64 _v11232))) $ getUserLastSentMessageTimeStamp_result_success record
    , (\_v11232 -> (1, ("e",from_TalkException _v11232))) <$> getUserLastSentMessageTimeStamp_result_e record
    ]
    )
write_GetUserLastSentMessageTimeStamp_result :: T.Protocol p => p -> GetUserLastSentMessageTimeStamp_result -> P.IO ()
write_GetUserLastSentMessageTimeStamp_result oprot record = T.writeVal oprot $ from_GetUserLastSentMessageTimeStamp_result record
encode_GetUserLastSentMessageTimeStamp_result :: T.StatelessProtocol p => p -> GetUserLastSentMessageTimeStamp_result -> LBS.ByteString
encode_GetUserLastSentMessageTimeStamp_result oprot record = T.serializeVal oprot $ from_GetUserLastSentMessageTimeStamp_result record
to_GetUserLastSentMessageTimeStamp_result :: T.ThriftVal -> GetUserLastSentMessageTimeStamp_result
to_GetUserLastSentMessageTimeStamp_result (T.TStruct fields) = GetUserLastSentMessageTimeStamp_result{
  getUserLastSentMessageTimeStamp_result_success = P.maybe (getUserLastSentMessageTimeStamp_result_success default_GetUserLastSentMessageTimeStamp_result) (\(_,_val11234) -> (case _val11234 of {T.TI64 _val11235 -> _val11235; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLastSentMessageTimeStamp_result_e = P.maybe (P.Nothing) (\(_,_val11234) -> P.Just (case _val11234 of {T.TStruct _val11236 -> (to_TalkException (T.TStruct _val11236)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLastSentMessageTimeStamp_result _ = P.error "not a struct"
read_GetUserLastSentMessageTimeStamp_result :: T.Protocol p => p -> P.IO GetUserLastSentMessageTimeStamp_result
read_GetUserLastSentMessageTimeStamp_result iprot = to_GetUserLastSentMessageTimeStamp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_result)
decode_GetUserLastSentMessageTimeStamp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLastSentMessageTimeStamp_result
decode_GetUserLastSentMessageTimeStamp_result iprot bs = to_GetUserLastSentMessageTimeStamp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_result) bs
typemap_GetUserLastSentMessageTimeStamp_result :: T.TypeMap
typemap_GetUserLastSentMessageTimeStamp_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLastSentMessageTimeStamp_result :: GetUserLastSentMessageTimeStamp_result
default_GetUserLastSentMessageTimeStamp_result = GetUserLastSentMessageTimeStamp_result{
  getUserLastSentMessageTimeStamp_result_success = 0,
  getUserLastSentMessageTimeStamp_result_e = P.Nothing}
process_getUserStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetUserStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserStatus handler (getUserStatus_args_mid args)
        let res = default_GetUserStatus_result{getUserStatus_result_success = val}
        T.writeMessage oprot ("getUserStatus", T.M_REPLY, seqid) $
          write_GetUserStatus_result oprot res)
      (\e  -> do
        let res = default_GetUserStatus_result{getUserStatus_result_e = P.Just e}
        T.writeMessage oprot ("getUserStatus", T.M_REPLY, seqid) $
          write_GetUserStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttributeForChannel (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttributeForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttributeForChannel handler (updateProfileAttributeForChannel_args_profileAttribute args) (updateProfileAttributeForChannel_args_value args)
        let res = default_UpdateProfileAttributeForChannel_result
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateExtendedProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateExtendedProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateExtendedProfileAttribute handler (updateExtendedProfileAttribute_args_attr args) (updateExtendedProfileAttribute_args_extendedProfile args)
        let res = default_UpdateExtendedProfileAttribute_result
        T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateExtendedProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateExtendedProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetAllSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllSimpleChannelContacts handler (getAllSimpleChannelContacts_args_statusSticonFallbackDisabled args)
        let res = default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetAllSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetAllSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserIdentities (seqid, iprot, oprot, handler) = do
  args <- read_GetUserIdentities_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserIdentities handler
        let res = default_GetUserIdentities_result{getUserIdentities_result_success = val}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res)
      (\e  -> do
        let res = default_GetUserIdentities_result{getUserIdentities_result_e = P.Just e}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserIdentities", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_markPaidCallAd (seqid, iprot, oprot, handler) = do
  args <- read_MarkPaidCallAd_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.markPaidCallAd handler (markPaidCallAd_args_dialedNumber args) (markPaidCallAd_args_language args) (markPaidCallAd_args_disableCallerId args)
        let res = default_MarkPaidCallAd_result{markPaidCallAd_result_success = val}
        T.writeMessage oprot ("markPaidCallAd", T.M_REPLY, seqid) $
          write_MarkPaidCallAd_result oprot res)
      (\e  -> do
        let res = default_MarkPaidCallAd_result{markPaidCallAd_result_e = P.Just e}
        T.writeMessage oprot ("markPaidCallAd", T.M_REPLY, seqid) $
          write_MarkPaidCallAd_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("markPaidCallAd", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isGroupMember (seqid, iprot, oprot, handler) = do
  args <- read_IsGroupMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isGroupMember handler (isGroupMember_args_groupId args)
        let res = default_IsGroupMember_result{isGroupMember_result_success = val}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res)
      (\e  -> do
        let res = default_IsGroupMember_result{isGroupMember_result_e = P.Just e}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isGroupMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPhoneInfoFromPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_GetPhoneInfoFromPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPhoneInfoFromPhoneNumber handler (getPhoneInfoFromPhoneNumber_args_region args) (getPhoneInfoFromPhoneNumber_args_phoneNumber args)
        let res = default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = val}
        T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_REPLY, seqid) $
          write_GetPhoneInfoFromPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_REPLY, seqid) $
          write_GetPhoneInfoFromPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_redeemPaidCallVoucher (seqid, iprot, oprot, handler) = do
  args <- read_RedeemPaidCallVoucher_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.redeemPaidCallVoucher handler (redeemPaidCallVoucher_args_serial args) (redeemPaidCallVoucher_args_language args)
        let res = default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = val}
        T.writeMessage oprot ("redeemPaidCallVoucher", T.M_REPLY, seqid) $
          write_RedeemPaidCallVoucher_result oprot res)
      (\e  -> do
        let res = default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = P.Just e}
        T.writeMessage oprot ("redeemPaidCallVoucher", T.M_REPLY, seqid) $
          write_RedeemPaidCallVoucher_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("redeemPaidCallVoucher", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPreferredDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetPreferredDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPreferredDisplayName handler (getPreferredDisplayName_args_mids args)
        let res = default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = val}
        T.writeMessage oprot ("getPreferredDisplayName", T.M_REPLY, seqid) $
          write_GetPreferredDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getPreferredDisplayName", T.M_REPLY, seqid) $
          write_GetPreferredDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPreferredDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContactsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetContactsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContactsForChannel handler (getContactsForChannel_args_ids args)
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_success = val}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContactsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCallCreditProducts (seqid, iprot, oprot, handler) = do
  args <- read_GetCallCreditProducts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCallCreditProducts handler (getCallCreditProducts_args_appStoreCode args) (getCallCreditProducts_args_pgCode args) (getCallCreditProducts_args_country args) (getCallCreditProducts_args_language args)
        let res = default_GetCallCreditProducts_result{getCallCreditProducts_result_success = val}
        T.writeMessage oprot ("getCallCreditProducts", T.M_REPLY, seqid) $
          write_GetCallCreditProducts_result oprot res)
      (\e  -> do
        let res = default_GetCallCreditProducts_result{getCallCreditProducts_result_e = P.Just e}
        T.writeMessage oprot ("getCallCreditProducts", T.M_REPLY, seqid) $
          write_GetCallCreditProducts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCallCreditProducts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContacts handler (getCompactContacts_args_lastModifiedTimestamp args)
        let res = default_GetCompactContacts_result{getCompactContacts_result_success = val}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetCompactContacts_result{getCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyNotiCenterEvent (seqid, iprot, oprot, handler) = do
  args <- read_NotifyNotiCenterEvent_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyNotiCenterEvent handler (notifyNotiCenterEvent_args_event args)
        let res = default_NotifyNotiCenterEvent_result
        T.writeMessage oprot ("notifyNotiCenterEvent", T.M_REPLY, seqid) $
          write_NotifyNotiCenterEvent_result oprot res)
      (\e  -> do
        let res = default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = P.Just e}
        T.writeMessage oprot ("notifyNotiCenterEvent", T.M_REPLY, seqid) $
          write_NotifyNotiCenterEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyNotiCenterEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isInContact (seqid, iprot, oprot, handler) = do
  args <- read_IsInContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isInContact handler (isInContact_args_mid args)
        let res = default_IsInContact_result{isInContact_result_success = val}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res)
      (\e  -> do
        let res = default_IsInContact_result{isInContact_result_e = P.Just e}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isInContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupGroupMembers (seqid, iprot, oprot, handler) = do
  args <- read_LookupGroupMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupGroupMembers handler (lookupGroupMembers_args_groupId args) (lookupGroupMembers_args_mids args)
        let res = default_LookupGroupMembers_result{lookupGroupMembers_result_success = val}
        T.writeMessage oprot ("lookupGroupMembers", T.M_REPLY, seqid) $
          write_LookupGroupMembers_result oprot res)
      (\e  -> do
        let res = default_LookupGroupMembers_result{lookupGroupMembers_result_e = P.Just e}
        T.writeMessage oprot ("lookupGroupMembers", T.M_REPLY, seqid) $
          write_LookupGroupMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupGroupMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoomInformation (seqid, iprot, oprot, handler) = do
  args <- read_GetRoomInformation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoomInformation handler (getRoomInformation_args_roomMid args)
        let res = default_GetRoomInformation_result{getRoomInformation_result_success = val}
        T.writeMessage oprot ("getRoomInformation", T.M_REPLY, seqid) $
          write_GetRoomInformation_result oprot res)
      (\e  -> do
        let res = default_GetRoomInformation_result{getRoomInformation_result_e = P.Just e}
        T.writeMessage oprot ("getRoomInformation", T.M_REPLY, seqid) $
          write_GetRoomInformation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoomInformation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupCall (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupCall_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupCall handler (getGroupCall_args_chatMid args)
        let res = default_GetGroupCall_result{getGroupCall_result_success = val}
        T.writeMessage oprot ("getGroupCall", T.M_REPLY, seqid) $
          write_GetGroupCall_result oprot res)
      (\e  -> do
        let res = default_GetGroupCall_result{getGroupCall_result_e = P.Just e}
        T.writeMessage oprot ("getGroupCall", T.M_REPLY, seqid) $
          write_GetGroupCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isAllowSecondaryDeviceLogin (seqid, iprot, oprot, handler) = do
  args <- read_IsAllowSecondaryDeviceLogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isAllowSecondaryDeviceLogin handler
        let res = default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = val}
        T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_REPLY, seqid) $
          write_IsAllowSecondaryDeviceLogin_result oprot res)
      (\e  -> do
        let res = default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = P.Just e}
        T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_REPLY, seqid) $
          write_IsAllowSecondaryDeviceLogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientForChannel handler
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createRoomWithBuddy (seqid, iprot, oprot, handler) = do
  args <- read_CreateRoomWithBuddy_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createRoomWithBuddy handler (createRoomWithBuddy_args_reqSeq args) (createRoomWithBuddy_args_buddyMid args) (createRoomWithBuddy_args_contactIds args)
        let res = default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = val}
        T.writeMessage oprot ("createRoomWithBuddy", T.M_REPLY, seqid) $
          write_CreateRoomWithBuddy_result oprot res)
      (\e  -> do
        let res = default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = P.Just e}
        T.writeMessage oprot ("createRoomWithBuddy", T.M_REPLY, seqid) $
          write_CreateRoomWithBuddy_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createRoomWithBuddy", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDisplayName handler (getDisplayName_args_mid args)
        let res = default_GetDisplayName_result{getDisplayName_result_success = val}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetDisplayName_result{getDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallMetadata (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallMetadata_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallMetadata handler (getPaidCallMetadata_args_language args)
        let res = default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = val}
        T.writeMessage oprot ("getPaidCallMetadata", T.M_REPLY, seqid) $
          write_GetPaidCallMetadata_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallMetadata", T.M_REPLY, seqid) $
          write_GetPaidCallMetadata_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallMetadata", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMid (seqid, iprot, oprot, handler) = do
  args <- read_GetMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMid handler
        let res = default_GetMid_result{getMid_result_success = val}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res)
      (\e  -> do
        let res = default_GetMid_result{getMid_result_e = P.Just e}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCountryForBilling (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCountryForBilling_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCountryForBilling handler (getUserCountryForBilling_args_country args) (getUserCountryForBilling_args_remoteIp args)
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = val}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res)
      (\e  -> do
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = P.Just e}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCountryForBilling", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteGroupIdsForChannel handler
        let res = default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallHistory handler (getPaidCallHistory_args_start args) (getPaidCallHistory_args_size args) (getPaidCallHistory_args_language args)
        let res = default_GetPaidCallHistory_result{getPaidCallHistory_result_success = val}
        T.writeMessage oprot ("getPaidCallHistory", T.M_REPLY, seqid) $
          write_GetPaidCallHistory_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallHistory_result{getPaidCallHistory_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallHistory", T.M_REPLY, seqid) $
          write_GetPaidCallHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendPinCodeOperation (seqid, iprot, oprot, handler) = do
  args <- read_SendPinCodeOperation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendPinCodeOperation handler (sendPinCodeOperation_args_verifier args)
        let res = default_SendPinCodeOperation_result
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res)
      (\e  -> do
        let res = default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = P.Just e}
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendPinCodeOperation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoGroupCall (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoGroupCall_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoGroupCall handler (inviteIntoGroupCall_args_chatMid args) (inviteIntoGroupCall_args_memberMids args) (inviteIntoGroupCall_args_mediaType args)
        let res = default_InviteIntoGroupCall_result
        T.writeMessage oprot ("inviteIntoGroupCall", T.M_REPLY, seqid) $
          write_InviteIntoGroupCall_result oprot res)
      (\e  -> do
        let res = default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoGroupCall", T.M_REPLY, seqid) $
          write_InviteIntoGroupCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoGroupCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendMids handler
        let res = default_GetFriendMids_result{getFriendMids_result_success = val}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetFriendMids_result{getFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMetaProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetMetaProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMetaProfile handler
        let res = default_GetMetaProfile_result{getMetaProfile_result_success = val}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res)
      (\e  -> do
        let res = default_GetMetaProfile_result{getMetaProfile_result_e = P.Just e}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMetaProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageForChannel (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageForChannel handler (sendMessageForChannel_args_message args)
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_success = val}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res)
      (\e  -> do
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_activeBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_ActiveBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.activeBuddySubscriberCount handler
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("activeBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCallCreditPurchaseHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetCallCreditPurchaseHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCallCreditPurchaseHistory handler (getCallCreditPurchaseHistory_args_request args)
        let res = default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = val}
        T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCallCreditPurchaseHistory_result oprot res)
      (\e  -> do
        let res = default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = P.Just e}
        T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCallCreditPurchaseHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isRoomMember (seqid, iprot, oprot, handler) = do
  args <- read_IsRoomMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isRoomMember handler (isRoomMember_args_roomId args)
        let res = default_IsRoomMember_result{isRoomMember_result_success = val}
        T.writeMessage oprot ("isRoomMember", T.M_REPLY, seqid) $
          write_IsRoomMember_result oprot res)
      (\e  -> do
        let res = default_IsRoomMember_result{isRoomMember_result_e = P.Just e}
        T.writeMessage oprot ("isRoomMember", T.M_REPLY, seqid) $
          write_IsRoomMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isRoomMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendSystemOAMessage (seqid, iprot, oprot, handler) = do
  args <- read_SendSystemOAMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendSystemOAMessage handler (sendSystemOAMessage_args_message args)
        let res = default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = val}
        T.writeMessage oprot ("sendSystemOAMessage", T.M_REPLY, seqid) $
          write_SendSystemOAMessage_result oprot res)
      (\e  -> do
        let res = default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = P.Just e}
        T.writeMessage oprot ("sendSystemOAMessage", T.M_REPLY, seqid) $
          write_SendSystemOAMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendSystemOAMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquirePaidCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquirePaidCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquirePaidCallRoute handler (acquirePaidCallRoute_args_paidCallType args) (acquirePaidCallRoute_args_dialedNumber args) (acquirePaidCallRoute_args_language args) (acquirePaidCallRoute_args_networkCode args) (acquirePaidCallRoute_args_disableCallerId args) (acquirePaidCallRoute_args_referer args) (acquirePaidCallRoute_args_adSessionId args)
        let res = default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = val}
        T.writeMessage oprot ("acquirePaidCallRoute", T.M_REPLY, seqid) $
          write_AcquirePaidCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquirePaidCallRoute", T.M_REPLY, seqid) $
          write_AcquirePaidCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquirePaidCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupsForChannel handler (getGroupsForChannel_args_groupIds args)
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_success = val}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCreateTime (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCreateTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCreateTime handler
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_success = val}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res)
      (\e  -> do
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_e = P.Just e}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCreateTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerChannelCP (seqid, iprot, oprot, handler) = do
  args <- read_RegisterChannelCP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerChannelCP handler (registerChannelCP_args_cpId args) (registerChannelCP_args_registerPassword args)
        let res = default_RegisterChannelCP_result{registerChannelCP_result_success = val}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res)
      (\e  -> do
        let res = default_RegisterChannelCP_result{registerChannelCP_result_e = P.Just e}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerChannelCP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCallCreditPurchase (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCallCreditPurchase_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCallCreditPurchase handler (reserveCallCreditPurchase_args_request args)
        let res = default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = val}
        T.writeMessage oprot ("reserveCallCreditPurchase", T.M_REPLY, seqid) $
          write_ReserveCallCreditPurchase_result oprot res)
      (\e  -> do
        let res = default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = P.Just e}
        T.writeMessage oprot ("reserveCallCreditPurchase", T.M_REPLY, seqid) $
          write_ReserveCallCreditPurchase_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCallCreditPurchase", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquirePaidCallCurrencyExchangeRate (seqid, iprot, oprot, handler) = do
  args <- read_AcquirePaidCallCurrencyExchangeRate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquirePaidCallCurrencyExchangeRate handler (acquirePaidCallCurrencyExchangeRate_args_language args)
        let res = default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = val}
        T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_REPLY, seqid) $
          write_AcquirePaidCallCurrencyExchangeRate_result oprot res)
      (\e  -> do
        let res = default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = P.Just e}
        T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_REPLY, seqid) $
          write_AcquirePaidCallCurrencyExchangeRate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoomMemberMidsForAppPlatform (seqid, iprot, oprot, handler) = do
  args <- read_GetRoomMemberMidsForAppPlatform_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoomMemberMidsForAppPlatform handler (getRoomMemberMidsForAppPlatform_args_roomId args)
        let res = default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = val}
        T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetRoomMemberMidsForAppPlatform_result oprot res)
      (\e  -> do
        let res = default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = P.Just e}
        T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetRoomMemberMidsForAppPlatform_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallBalanceList (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallBalanceList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallBalanceList handler (getPaidCallBalanceList_args_language args)
        let res = default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = val}
        T.writeMessage oprot ("getPaidCallBalanceList", T.M_REPLY, seqid) $
          write_GetPaidCallBalanceList_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallBalanceList", T.M_REPLY, seqid) $
          write_GetPaidCallBalanceList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallBalanceList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPersonalInfos (seqid, iprot, oprot, handler) = do
  args <- read_GetPersonalInfos_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPersonalInfos handler (getPersonalInfos_args_requiredPersonalInfos args)
        let res = default_GetPersonalInfos_result{getPersonalInfos_result_success = val}
        T.writeMessage oprot ("getPersonalInfos", T.M_REPLY, seqid) $
          write_GetPersonalInfos_result oprot res)
      (\e  -> do
        let res = default_GetPersonalInfos_result{getPersonalInfos_result_e = P.Just e}
        T.writeMessage oprot ("getPersonalInfos", T.M_REPLY, seqid) $
          write_GetPersonalInfos_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPersonalInfos", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientsForChannel handler (getPrimaryClientsForChannel_args_userMids args)
        let res = default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addBuddyToContact (seqid, iprot, oprot, handler) = do
  args <- read_AddBuddyToContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.addBuddyToContact handler (addBuddyToContact_args_buddyMid args)
        let res = default_AddBuddyToContact_result{addBuddyToContact_result_success = val}
        T.writeMessage oprot ("addBuddyToContact", T.M_REPLY, seqid) $
          write_AddBuddyToContact_result oprot res)
      (\e  -> do
        let res = default_AddBuddyToContact_result{addBuddyToContact_result_e = P.Just e}
        T.writeMessage oprot ("addBuddyToContact", T.M_REPLY, seqid) $
          write_AddBuddyToContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addBuddyToContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMidsForAppPlatform (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMidsForAppPlatform_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMidsForAppPlatform handler (getGroupMemberMidsForAppPlatform_args_groupId args)
        let res = default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = val}
        T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetGroupMemberMidsForAppPlatform_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetGroupMemberMidsForAppPlatform_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLanguage (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLanguage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLanguage handler
        let res = default_GetUserLanguage_result{getUserLanguage_result_success = val}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res)
      (\e  -> do
        let res = default_GetUserLanguage_result{getUserLanguage_result_e = P.Just e}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLanguage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupPaidCall (seqid, iprot, oprot, handler) = do
  args <- read_LookupPaidCall_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupPaidCall handler (lookupPaidCall_args_dialedNumber args) (lookupPaidCall_args_language args) (lookupPaidCall_args_referer args)
        let res = default_LookupPaidCall_result{lookupPaidCall_result_success = val}
        T.writeMessage oprot ("lookupPaidCall", T.M_REPLY, seqid) $
          write_LookupPaidCall_result oprot res)
      (\e  -> do
        let res = default_LookupPaidCall_result{lookupPaidCall_result_e = P.Just e}
        T.writeMessage oprot ("lookupPaidCall", T.M_REPLY, seqid) $
          write_LookupPaidCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupPaidCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getExtendedProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetExtendedProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getExtendedProfile handler
        let res = default_GetExtendedProfile_result{getExtendedProfile_result_success = val}
        T.writeMessage oprot ("getExtendedProfile", T.M_REPLY, seqid) $
          write_GetExtendedProfile_result oprot res)
      (\e  -> do
        let res = default_GetExtendedProfile_result{getExtendedProfile_result_e = P.Just e}
        T.writeMessage oprot ("getExtendedProfile", T.M_REPLY, seqid) $
          write_GetExtendedProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getExtendedProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getReverseCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetReverseCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getReverseCompactContacts handler (getReverseCompactContacts_args_ids args)
        let res = default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = val}
        T.writeMessage oprot ("getReverseCompactContacts", T.M_REPLY, seqid) $
          write_GetReverseCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getReverseCompactContacts", T.M_REPLY, seqid) $
          write_GetReverseCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getReverseCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallAdStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallAdStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallAdStatus handler
        let res = default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = val}
        T.writeMessage oprot ("getPaidCallAdStatus", T.M_REPLY, seqid) $
          write_GetPaidCallAdStatus_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallAdStatus", T.M_REPLY, seqid) $
          write_GetPaidCallAdStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallAdStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUseridWithoutAbuseBlockForChannel (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUseridWithoutAbuseBlockForChannel handler (findContactByUseridWithoutAbuseBlockForChannel_args_userid args)
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = val}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res)
      (\e  -> do
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMids (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMids handler (getGroupMemberMids_args_groupId args)
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_success = val}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageWithoutRelationship (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageWithoutRelationship_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageWithoutRelationship handler (sendMessageWithoutRelationship_args_message args)
        let res = default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = val}
        T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_REPLY, seqid) $
          write_SendMessageWithoutRelationship_result oprot res)
      (\e  -> do
        let res = default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_REPLY, seqid) $
          write_SendMessageWithoutRelationship_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCountInBulk (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCountInBulk_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCountInBulk handler (displayBuddySubscriberCountInBulk_args_mids args)
        let res = default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCountInBulk_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCountInBulk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupRoomMembers (seqid, iprot, oprot, handler) = do
  args <- read_LookupRoomMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupRoomMembers handler (lookupRoomMembers_args_roomId args) (lookupRoomMembers_args_mids args)
        let res = default_LookupRoomMembers_result{lookupRoomMembers_result_success = val}
        T.writeMessage oprot ("lookupRoomMembers", T.M_REPLY, seqid) $
          write_LookupRoomMembers_result oprot res)
      (\e  -> do
        let res = default_LookupRoomMembers_result{lookupRoomMembers_result_e = P.Just e}
        T.writeMessage oprot ("lookupRoomMembers", T.M_REPLY, seqid) $
          write_LookupRoomMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupRoomMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMidsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMidsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMidsForChannel handler
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIdsForChannel handler
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = val}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCount handler
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfileForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetProfileForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfileForChannel handler
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_success = val}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res)
      (\e  -> do
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfileForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserTickets (seqid, iprot, oprot, handler) = do
  args <- read_GetUserTickets_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserTickets handler (getUserTickets_args_userMids args)
        let res = default_GetUserTickets_result{getUserTickets_result_success = val}
        T.writeMessage oprot ("getUserTickets", T.M_REPLY, seqid) $
          write_GetUserTickets_result oprot res)
      (\e  -> do
        let res = default_GetUserTickets_result{getUserTickets_result_e = P.Just e}
        T.writeMessage oprot ("getUserTickets", T.M_REPLY, seqid) $
          write_GetUserTickets_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserTickets", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getOAFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetOAFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getOAFriendMids handler
        let res = default_GetOAFriendMids_result{getOAFriendMids_result_success = val}
        T.writeMessage oprot ("getOAFriendMids", T.M_REPLY, seqid) $
          write_GetOAFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetOAFriendMids_result{getOAFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getOAFriendMids", T.M_REPLY, seqid) $
          write_GetOAFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getOAFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_searchPaidCallUserRate (seqid, iprot, oprot, handler) = do
  args <- read_SearchPaidCallUserRate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.searchPaidCallUserRate handler (searchPaidCallUserRate_args_countryCode args) (searchPaidCallUserRate_args_language args)
        let res = default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = val}
        T.writeMessage oprot ("searchPaidCallUserRate", T.M_REPLY, seqid) $
          write_SearchPaidCallUserRate_result oprot res)
      (\e  -> do
        let res = default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = P.Just e}
        T.writeMessage oprot ("searchPaidCallUserRate", T.M_REPLY, seqid) $
          write_SearchPaidCallUserRate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("searchPaidCallUserRate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedGroupIdsForChannel handler
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireGroupCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquireGroupCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireGroupCallRoute handler (acquireGroupCallRoute_args_chatMid args) (acquireGroupCallRoute_args_mediaType args)
        let res = default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = val}
        T.writeMessage oprot ("acquireGroupCallRoute", T.M_REPLY, seqid) $
          write_AcquireGroupCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquireGroupCallRoute", T.M_REPLY, seqid) $
          write_AcquireGroupCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireGroupCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserMidsWhoAddedMe (seqid, iprot, oprot, handler) = do
  args <- read_GetUserMidsWhoAddedMe_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserMidsWhoAddedMe handler
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = val}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res)
      (\e  -> do
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = P.Just e}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityCredential handler
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_success = val}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addOperationForChannel (seqid, iprot, oprot, handler) = do
  args <- read_AddOperationForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.addOperationForChannel handler (addOperationForChannel_args_opType args) (addOperationForChannel_args_param1 args) (addOperationForChannel_args_param2 args) (addOperationForChannel_args_param3 args)
        let res = default_AddOperationForChannel_result
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res)
      (\e  -> do
        let res = default_AddOperationForChannel_result{addOperationForChannel_result_e = P.Just e}
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addOperationForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSimpleChannelContacts handler (getSimpleChannelContacts_args_ids args) (getSimpleChannelContacts_args_statusSticonFallbackDisabled args)
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLastSentMessageTimeStamp (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLastSentMessageTimeStamp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLastSentMessageTimeStamp handler (getUserLastSentMessageTimeStamp_args_mid args)
        let res = default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = val}
        T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_REPLY, seqid) $
          write_GetUserLastSentMessageTimeStamp_result oprot res)
      (\e  -> do
        let res = default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = P.Just e}
        T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_REPLY, seqid) $
          write_GetUserLastSentMessageTimeStamp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getUserStatus" -> process_getUserStatus (seqid,iprot,oprot,handler)
  "updateProfileAttributeForChannel" -> process_updateProfileAttributeForChannel (seqid,iprot,oprot,handler)
  "updateExtendedProfileAttribute" -> process_updateExtendedProfileAttribute (seqid,iprot,oprot,handler)
  "getAllSimpleChannelContacts" -> process_getAllSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserIdentities" -> process_getUserIdentities (seqid,iprot,oprot,handler)
  "markPaidCallAd" -> process_markPaidCallAd (seqid,iprot,oprot,handler)
  "isGroupMember" -> process_isGroupMember (seqid,iprot,oprot,handler)
  "getPhoneInfoFromPhoneNumber" -> process_getPhoneInfoFromPhoneNumber (seqid,iprot,oprot,handler)
  "redeemPaidCallVoucher" -> process_redeemPaidCallVoucher (seqid,iprot,oprot,handler)
  "getPreferredDisplayName" -> process_getPreferredDisplayName (seqid,iprot,oprot,handler)
  "getContactsForChannel" -> process_getContactsForChannel (seqid,iprot,oprot,handler)
  "getCallCreditProducts" -> process_getCallCreditProducts (seqid,iprot,oprot,handler)
  "getCompactContacts" -> process_getCompactContacts (seqid,iprot,oprot,handler)
  "notifyNotiCenterEvent" -> process_notifyNotiCenterEvent (seqid,iprot,oprot,handler)
  "isInContact" -> process_isInContact (seqid,iprot,oprot,handler)
  "lookupGroupMembers" -> process_lookupGroupMembers (seqid,iprot,oprot,handler)
  "getRoomInformation" -> process_getRoomInformation (seqid,iprot,oprot,handler)
  "getGroupCall" -> process_getGroupCall (seqid,iprot,oprot,handler)
  "isAllowSecondaryDeviceLogin" -> process_isAllowSecondaryDeviceLogin (seqid,iprot,oprot,handler)
  "getPrimaryClientForChannel" -> process_getPrimaryClientForChannel (seqid,iprot,oprot,handler)
  "createRoomWithBuddy" -> process_createRoomWithBuddy (seqid,iprot,oprot,handler)
  "getDisplayName" -> process_getDisplayName (seqid,iprot,oprot,handler)
  "getPaidCallMetadata" -> process_getPaidCallMetadata (seqid,iprot,oprot,handler)
  "getMid" -> process_getMid (seqid,iprot,oprot,handler)
  "getUserCountryForBilling" -> process_getUserCountryForBilling (seqid,iprot,oprot,handler)
  "getFavoriteGroupIdsForChannel" -> process_getFavoriteGroupIdsForChannel (seqid,iprot,oprot,handler)
  "getPaidCallHistory" -> process_getPaidCallHistory (seqid,iprot,oprot,handler)
  "sendPinCodeOperation" -> process_sendPinCodeOperation (seqid,iprot,oprot,handler)
  "inviteIntoGroupCall" -> process_inviteIntoGroupCall (seqid,iprot,oprot,handler)
  "getFriendMids" -> process_getFriendMids (seqid,iprot,oprot,handler)
  "getMetaProfile" -> process_getMetaProfile (seqid,iprot,oprot,handler)
  "sendMessageForChannel" -> process_sendMessageForChannel (seqid,iprot,oprot,handler)
  "activeBuddySubscriberCount" -> process_activeBuddySubscriberCount (seqid,iprot,oprot,handler)
  "getCallCreditPurchaseHistory" -> process_getCallCreditPurchaseHistory (seqid,iprot,oprot,handler)
  "isRoomMember" -> process_isRoomMember (seqid,iprot,oprot,handler)
  "sendSystemOAMessage" -> process_sendSystemOAMessage (seqid,iprot,oprot,handler)
  "acquirePaidCallRoute" -> process_acquirePaidCallRoute (seqid,iprot,oprot,handler)
  "getGroupsForChannel" -> process_getGroupsForChannel (seqid,iprot,oprot,handler)
  "getUserCreateTime" -> process_getUserCreateTime (seqid,iprot,oprot,handler)
  "registerChannelCP" -> process_registerChannelCP (seqid,iprot,oprot,handler)
  "reserveCallCreditPurchase" -> process_reserveCallCreditPurchase (seqid,iprot,oprot,handler)
  "acquirePaidCallCurrencyExchangeRate" -> process_acquirePaidCallCurrencyExchangeRate (seqid,iprot,oprot,handler)
  "getRoomMemberMidsForAppPlatform" -> process_getRoomMemberMidsForAppPlatform (seqid,iprot,oprot,handler)
  "getPaidCallBalanceList" -> process_getPaidCallBalanceList (seqid,iprot,oprot,handler)
  "getPersonalInfos" -> process_getPersonalInfos (seqid,iprot,oprot,handler)
  "getPrimaryClientsForChannel" -> process_getPrimaryClientsForChannel (seqid,iprot,oprot,handler)
  "addBuddyToContact" -> process_addBuddyToContact (seqid,iprot,oprot,handler)
  "getGroupMemberMidsForAppPlatform" -> process_getGroupMemberMidsForAppPlatform (seqid,iprot,oprot,handler)
  "getUserLanguage" -> process_getUserLanguage (seqid,iprot,oprot,handler)
  "lookupPaidCall" -> process_lookupPaidCall (seqid,iprot,oprot,handler)
  "getExtendedProfile" -> process_getExtendedProfile (seqid,iprot,oprot,handler)
  "getReverseCompactContacts" -> process_getReverseCompactContacts (seqid,iprot,oprot,handler)
  "getPaidCallAdStatus" -> process_getPaidCallAdStatus (seqid,iprot,oprot,handler)
  "findContactByUseridWithoutAbuseBlockForChannel" -> process_findContactByUseridWithoutAbuseBlockForChannel (seqid,iprot,oprot,handler)
  "getGroupMemberMids" -> process_getGroupMemberMids (seqid,iprot,oprot,handler)
  "sendMessageWithoutRelationship" -> process_sendMessageWithoutRelationship (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCountInBulk" -> process_displayBuddySubscriberCountInBulk (seqid,iprot,oprot,handler)
  "lookupRoomMembers" -> process_lookupRoomMembers (seqid,iprot,oprot,handler)
  "getFavoriteMidsForChannel" -> process_getFavoriteMidsForChannel (seqid,iprot,oprot,handler)
  "getAllContactIdsForChannel" -> process_getAllContactIdsForChannel (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCount" -> process_displayBuddySubscriberCount (seqid,iprot,oprot,handler)
  "getProfileForChannel" -> process_getProfileForChannel (seqid,iprot,oprot,handler)
  "getUserTickets" -> process_getUserTickets (seqid,iprot,oprot,handler)
  "getOAFriendMids" -> process_getOAFriendMids (seqid,iprot,oprot,handler)
  "searchPaidCallUserRate" -> process_searchPaidCallUserRate (seqid,iprot,oprot,handler)
  "getJoinedGroupIdsForChannel" -> process_getJoinedGroupIdsForChannel (seqid,iprot,oprot,handler)
  "acquireGroupCallRoute" -> process_acquireGroupCallRoute (seqid,iprot,oprot,handler)
  "getUserMidsWhoAddedMe" -> process_getUserMidsWhoAddedMe (seqid,iprot,oprot,handler)
  "getIdentityCredential" -> process_getIdentityCredential (seqid,iprot,oprot,handler)
  "addOperationForChannel" -> process_addOperationForChannel (seqid,iprot,oprot,handler)
  "getSimpleChannelContacts" -> process_getSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserLastSentMessageTimeStamp" -> process_getUserLastSentMessageTimeStamp (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
