{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module CallService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified CallService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetUserStatus_args = GetUserStatus_args  { getUserStatus_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserStatus_args_mid record  
instance QC.Arbitrary GetUserStatus_args where 
  arbitrary = M.liftM GetUserStatus_args (QC.arbitrary)
  shrink obj | obj == default_GetUserStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserStatus_args{getUserStatus_args_mid = getUserStatus_args_mid obj} then P.Nothing else P.Just $ default_GetUserStatus_args{getUserStatus_args_mid = getUserStatus_args_mid obj}
    ]
from_GetUserStatus_args :: GetUserStatus_args -> T.ThriftVal
from_GetUserStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9573 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v9573))) $ getUserStatus_args_mid record
  ]
write_GetUserStatus_args :: T.Protocol p => p -> GetUserStatus_args -> P.IO ()
write_GetUserStatus_args oprot record = T.writeVal oprot $ from_GetUserStatus_args record
encode_GetUserStatus_args :: T.StatelessProtocol p => p -> GetUserStatus_args -> LBS.ByteString
encode_GetUserStatus_args oprot record = T.serializeVal oprot $ from_GetUserStatus_args record
to_GetUserStatus_args :: T.ThriftVal -> GetUserStatus_args
to_GetUserStatus_args (T.TStruct fields) = GetUserStatus_args{
  getUserStatus_args_mid = P.maybe (getUserStatus_args_mid default_GetUserStatus_args) (\(_,_val9575) -> (case _val9575 of {T.TString _val9576 -> E.decodeUtf8 _val9576; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserStatus_args _ = P.error "not a struct"
read_GetUserStatus_args :: T.Protocol p => p -> P.IO GetUserStatus_args
read_GetUserStatus_args iprot = to_GetUserStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserStatus_args)
decode_GetUserStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserStatus_args
decode_GetUserStatus_args iprot bs = to_GetUserStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserStatus_args) bs
typemap_GetUserStatus_args :: T.TypeMap
typemap_GetUserStatus_args = Map.fromList [(1,("mid",T.T_STRING))]
default_GetUserStatus_args :: GetUserStatus_args
default_GetUserStatus_args = GetUserStatus_args{
  getUserStatus_args_mid = ""}
data GetUserStatus_result = GetUserStatus_result  { getUserStatus_result_success :: UserStatus
  , getUserStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserStatus_result_success record   `H.hashWithSalt` getUserStatus_result_e record  
instance QC.Arbitrary GetUserStatus_result where 
  arbitrary = M.liftM GetUserStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserStatus_result{getUserStatus_result_success = getUserStatus_result_success obj} then P.Nothing else P.Just $ default_GetUserStatus_result{getUserStatus_result_success = getUserStatus_result_success obj}
    , if obj == default_GetUserStatus_result{getUserStatus_result_e = getUserStatus_result_e obj} then P.Nothing else P.Just $ default_GetUserStatus_result{getUserStatus_result_e = getUserStatus_result_e obj}
    ]
from_GetUserStatus_result :: GetUserStatus_result -> T.ThriftVal
from_GetUserStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9579 -> (1, ("e",from_TalkException _v9579))) <$> getUserStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9579 -> P.Just (0, ("success",T.TI32 $ P.fromIntegral $ P.fromEnum _v9579))) $ getUserStatus_result_success record
    , (\_v9579 -> (1, ("e",from_TalkException _v9579))) <$> getUserStatus_result_e record
    ]
    )
write_GetUserStatus_result :: T.Protocol p => p -> GetUserStatus_result -> P.IO ()
write_GetUserStatus_result oprot record = T.writeVal oprot $ from_GetUserStatus_result record
encode_GetUserStatus_result :: T.StatelessProtocol p => p -> GetUserStatus_result -> LBS.ByteString
encode_GetUserStatus_result oprot record = T.serializeVal oprot $ from_GetUserStatus_result record
to_GetUserStatus_result :: T.ThriftVal -> GetUserStatus_result
to_GetUserStatus_result (T.TStruct fields) = GetUserStatus_result{
  getUserStatus_result_success = P.maybe (getUserStatus_result_success default_GetUserStatus_result) (\(_,_val9581) -> (case _val9581 of {T.TI32 _val9582 -> P.toEnum $ P.fromIntegral _val9582; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserStatus_result_e = P.maybe (P.Nothing) (\(_,_val9581) -> P.Just (case _val9581 of {T.TStruct _val9583 -> (to_TalkException (T.TStruct _val9583)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserStatus_result _ = P.error "not a struct"
read_GetUserStatus_result :: T.Protocol p => p -> P.IO GetUserStatus_result
read_GetUserStatus_result iprot = to_GetUserStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserStatus_result)
decode_GetUserStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserStatus_result
decode_GetUserStatus_result iprot bs = to_GetUserStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserStatus_result) bs
typemap_GetUserStatus_result :: T.TypeMap
typemap_GetUserStatus_result = Map.fromList [(0,("success",T.T_I32)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserStatus_result :: GetUserStatus_result
default_GetUserStatus_result = GetUserStatus_result{
  getUserStatus_result_success = (P.toEnum 0),
  getUserStatus_result_e = P.Nothing}
data UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args  { updateProfileAttributeForChannel_args_profileAttribute :: ProfileAttribute
  , updateProfileAttributeForChannel_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_args_profileAttribute record   `H.hashWithSalt` updateProfileAttributeForChannel_args_value record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_args where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj}
    , if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj}
    ]
from_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args -> T.ThriftVal
from_UpdateProfileAttributeForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9586 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v9586))) $ updateProfileAttributeForChannel_args_profileAttribute record
  , (\_v9586 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v9586))) $ updateProfileAttributeForChannel_args_value record
  ]
write_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> UpdateProfileAttributeForChannel_args -> P.IO ()
write_UpdateProfileAttributeForChannel_args oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_args record
encode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_args -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_args record
to_UpdateProfileAttributeForChannel_args :: T.ThriftVal -> UpdateProfileAttributeForChannel_args
to_UpdateProfileAttributeForChannel_args (T.TStruct fields) = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = P.maybe (updateProfileAttributeForChannel_args_profileAttribute default_UpdateProfileAttributeForChannel_args) (\(_,_val9588) -> (case _val9588 of {T.TI32 _val9589 -> P.toEnum $ P.fromIntegral _val9589; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttributeForChannel_args_value = P.maybe (updateProfileAttributeForChannel_args_value default_UpdateProfileAttributeForChannel_args) (\(_,_val9588) -> (case _val9588 of {T.TString _val9590 -> E.decodeUtf8 _val9590; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttributeForChannel_args _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_args
read_UpdateProfileAttributeForChannel_args iprot = to_UpdateProfileAttributeForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args)
decode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_args
decode_UpdateProfileAttributeForChannel_args iprot bs = to_UpdateProfileAttributeForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args) bs
typemap_UpdateProfileAttributeForChannel_args :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_args = Map.fromList [(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args
default_UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = (P.toEnum 0),
  updateProfileAttributeForChannel_args_value = ""}
data UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result  { updateProfileAttributeForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_result_e record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_result where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj}
    ]
from_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result -> T.ThriftVal
from_UpdateProfileAttributeForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9593 -> (1, ("e",from_TalkException _v9593))) <$> updateProfileAttributeForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9593 -> (1, ("e",from_TalkException _v9593))) <$> updateProfileAttributeForChannel_result_e record
    ]
    )
write_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> UpdateProfileAttributeForChannel_result -> P.IO ()
write_UpdateProfileAttributeForChannel_result oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_result record
encode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_result -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_result record
to_UpdateProfileAttributeForChannel_result :: T.ThriftVal -> UpdateProfileAttributeForChannel_result
to_UpdateProfileAttributeForChannel_result (T.TStruct fields) = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.maybe (P.Nothing) (\(_,_val9595) -> P.Just (case _val9595 of {T.TStruct _val9596 -> (to_TalkException (T.TStruct _val9596)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttributeForChannel_result _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_result
read_UpdateProfileAttributeForChannel_result iprot = to_UpdateProfileAttributeForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result)
decode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_result
decode_UpdateProfileAttributeForChannel_result iprot bs = to_UpdateProfileAttributeForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result) bs
typemap_UpdateProfileAttributeForChannel_result :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result
default_UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.Nothing}
data UpdateExtendedProfileAttribute_args = UpdateExtendedProfileAttribute_args  { updateExtendedProfileAttribute_args_attr :: ExtendedProfileAttribute
  , updateExtendedProfileAttribute_args_extendedProfile :: ExtendedProfile
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateExtendedProfileAttribute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateExtendedProfileAttribute_args_attr record   `H.hashWithSalt` updateExtendedProfileAttribute_args_extendedProfile record  
instance QC.Arbitrary UpdateExtendedProfileAttribute_args where 
  arbitrary = M.liftM UpdateExtendedProfileAttribute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateExtendedProfileAttribute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_attr = updateExtendedProfileAttribute_args_attr obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_attr = updateExtendedProfileAttribute_args_attr obj}
    , if obj == default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_extendedProfile = updateExtendedProfileAttribute_args_extendedProfile obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_args{updateExtendedProfileAttribute_args_extendedProfile = updateExtendedProfileAttribute_args_extendedProfile obj}
    ]
from_UpdateExtendedProfileAttribute_args :: UpdateExtendedProfileAttribute_args -> T.ThriftVal
from_UpdateExtendedProfileAttribute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9599 -> P.Just (1, ("attr",T.TI32 $ P.fromIntegral $ P.fromEnum _v9599))) $ updateExtendedProfileAttribute_args_attr record
  , (\_v9599 -> P.Just (2, ("extendedProfile",from_ExtendedProfile _v9599))) $ updateExtendedProfileAttribute_args_extendedProfile record
  ]
write_UpdateExtendedProfileAttribute_args :: T.Protocol p => p -> UpdateExtendedProfileAttribute_args -> P.IO ()
write_UpdateExtendedProfileAttribute_args oprot record = T.writeVal oprot $ from_UpdateExtendedProfileAttribute_args record
encode_UpdateExtendedProfileAttribute_args :: T.StatelessProtocol p => p -> UpdateExtendedProfileAttribute_args -> LBS.ByteString
encode_UpdateExtendedProfileAttribute_args oprot record = T.serializeVal oprot $ from_UpdateExtendedProfileAttribute_args record
to_UpdateExtendedProfileAttribute_args :: T.ThriftVal -> UpdateExtendedProfileAttribute_args
to_UpdateExtendedProfileAttribute_args (T.TStruct fields) = UpdateExtendedProfileAttribute_args{
  updateExtendedProfileAttribute_args_attr = P.maybe (updateExtendedProfileAttribute_args_attr default_UpdateExtendedProfileAttribute_args) (\(_,_val9601) -> (case _val9601 of {T.TI32 _val9602 -> P.toEnum $ P.fromIntegral _val9602; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateExtendedProfileAttribute_args_extendedProfile = P.maybe (updateExtendedProfileAttribute_args_extendedProfile default_UpdateExtendedProfileAttribute_args) (\(_,_val9601) -> (case _val9601 of {T.TStruct _val9603 -> (to_ExtendedProfile (T.TStruct _val9603)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateExtendedProfileAttribute_args _ = P.error "not a struct"
read_UpdateExtendedProfileAttribute_args :: T.Protocol p => p -> P.IO UpdateExtendedProfileAttribute_args
read_UpdateExtendedProfileAttribute_args iprot = to_UpdateExtendedProfileAttribute_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_args)
decode_UpdateExtendedProfileAttribute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateExtendedProfileAttribute_args
decode_UpdateExtendedProfileAttribute_args iprot bs = to_UpdateExtendedProfileAttribute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_args) bs
typemap_UpdateExtendedProfileAttribute_args :: T.TypeMap
typemap_UpdateExtendedProfileAttribute_args = Map.fromList [(1,("attr",T.T_I32)),(2,("extendedProfile",(T.T_STRUCT typemap_ExtendedProfile)))]
default_UpdateExtendedProfileAttribute_args :: UpdateExtendedProfileAttribute_args
default_UpdateExtendedProfileAttribute_args = UpdateExtendedProfileAttribute_args{
  updateExtendedProfileAttribute_args_attr = (P.toEnum 0),
  updateExtendedProfileAttribute_args_extendedProfile = default_ExtendedProfile}
data UpdateExtendedProfileAttribute_result = UpdateExtendedProfileAttribute_result  { updateExtendedProfileAttribute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateExtendedProfileAttribute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateExtendedProfileAttribute_result_e record  
instance QC.Arbitrary UpdateExtendedProfileAttribute_result where 
  arbitrary = M.liftM UpdateExtendedProfileAttribute_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateExtendedProfileAttribute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = updateExtendedProfileAttribute_result_e obj} then P.Nothing else P.Just $ default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = updateExtendedProfileAttribute_result_e obj}
    ]
from_UpdateExtendedProfileAttribute_result :: UpdateExtendedProfileAttribute_result -> T.ThriftVal
from_UpdateExtendedProfileAttribute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9606 -> (1, ("e",from_TalkException _v9606))) <$> updateExtendedProfileAttribute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9606 -> (1, ("e",from_TalkException _v9606))) <$> updateExtendedProfileAttribute_result_e record
    ]
    )
write_UpdateExtendedProfileAttribute_result :: T.Protocol p => p -> UpdateExtendedProfileAttribute_result -> P.IO ()
write_UpdateExtendedProfileAttribute_result oprot record = T.writeVal oprot $ from_UpdateExtendedProfileAttribute_result record
encode_UpdateExtendedProfileAttribute_result :: T.StatelessProtocol p => p -> UpdateExtendedProfileAttribute_result -> LBS.ByteString
encode_UpdateExtendedProfileAttribute_result oprot record = T.serializeVal oprot $ from_UpdateExtendedProfileAttribute_result record
to_UpdateExtendedProfileAttribute_result :: T.ThriftVal -> UpdateExtendedProfileAttribute_result
to_UpdateExtendedProfileAttribute_result (T.TStruct fields) = UpdateExtendedProfileAttribute_result{
  updateExtendedProfileAttribute_result_e = P.maybe (P.Nothing) (\(_,_val9608) -> P.Just (case _val9608 of {T.TStruct _val9609 -> (to_TalkException (T.TStruct _val9609)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateExtendedProfileAttribute_result _ = P.error "not a struct"
read_UpdateExtendedProfileAttribute_result :: T.Protocol p => p -> P.IO UpdateExtendedProfileAttribute_result
read_UpdateExtendedProfileAttribute_result iprot = to_UpdateExtendedProfileAttribute_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_result)
decode_UpdateExtendedProfileAttribute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateExtendedProfileAttribute_result
decode_UpdateExtendedProfileAttribute_result iprot bs = to_UpdateExtendedProfileAttribute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateExtendedProfileAttribute_result) bs
typemap_UpdateExtendedProfileAttribute_result :: T.TypeMap
typemap_UpdateExtendedProfileAttribute_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateExtendedProfileAttribute_result :: UpdateExtendedProfileAttribute_result
default_UpdateExtendedProfileAttribute_result = UpdateExtendedProfileAttribute_result{
  updateExtendedProfileAttribute_result_e = P.Nothing}
data GetAllSimpleChannelContacts_args = GetAllSimpleChannelContacts_args  { getAllSimpleChannelContacts_args_statusSticonFallbackDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllSimpleChannelContacts_args_statusSticonFallbackDisabled record  
instance QC.Arbitrary GetAllSimpleChannelContacts_args where 
  arbitrary = M.liftM GetAllSimpleChannelContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetAllSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllSimpleChannelContacts_args{getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = getAllSimpleChannelContacts_args_statusSticonFallbackDisabled obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_args{getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = getAllSimpleChannelContacts_args_statusSticonFallbackDisabled obj}
    ]
from_GetAllSimpleChannelContacts_args :: GetAllSimpleChannelContacts_args -> T.ThriftVal
from_GetAllSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9612 -> P.Just (1, ("statusSticonFallbackDisabled",T.TBool _v9612))) $ getAllSimpleChannelContacts_args_statusSticonFallbackDisabled record
  ]
write_GetAllSimpleChannelContacts_args :: T.Protocol p => p -> GetAllSimpleChannelContacts_args -> P.IO ()
write_GetAllSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetAllSimpleChannelContacts_args record
encode_GetAllSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetAllSimpleChannelContacts_args -> LBS.ByteString
encode_GetAllSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetAllSimpleChannelContacts_args record
to_GetAllSimpleChannelContacts_args :: T.ThriftVal -> GetAllSimpleChannelContacts_args
to_GetAllSimpleChannelContacts_args (T.TStruct fields) = GetAllSimpleChannelContacts_args{
  getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = P.maybe (getAllSimpleChannelContacts_args_statusSticonFallbackDisabled default_GetAllSimpleChannelContacts_args) (\(_,_val9614) -> (case _val9614 of {T.TBool _val9615 -> _val9615; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllSimpleChannelContacts_args _ = P.error "not a struct"
read_GetAllSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetAllSimpleChannelContacts_args
read_GetAllSimpleChannelContacts_args iprot = to_GetAllSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_args)
decode_GetAllSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllSimpleChannelContacts_args
decode_GetAllSimpleChannelContacts_args iprot bs = to_GetAllSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_args) bs
typemap_GetAllSimpleChannelContacts_args :: T.TypeMap
typemap_GetAllSimpleChannelContacts_args = Map.fromList [(1,("statusSticonFallbackDisabled",T.T_BOOL))]
default_GetAllSimpleChannelContacts_args :: GetAllSimpleChannelContacts_args
default_GetAllSimpleChannelContacts_args = GetAllSimpleChannelContacts_args{
  getAllSimpleChannelContacts_args_statusSticonFallbackDisabled = P.False}
data GetAllSimpleChannelContacts_result = GetAllSimpleChannelContacts_result  { getAllSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getAllSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllSimpleChannelContacts_result_success record   `H.hashWithSalt` getAllSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetAllSimpleChannelContacts_result where 
  arbitrary = M.liftM GetAllSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = getAllSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = getAllSimpleChannelContacts_result_success obj}
    , if obj == default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = getAllSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = getAllSimpleChannelContacts_result_e obj}
    ]
from_GetAllSimpleChannelContacts_result :: GetAllSimpleChannelContacts_result -> T.ThriftVal
from_GetAllSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9618 -> (1, ("e",from_TalkException _v9618))) <$> getAllSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9618 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v9620 -> from_SimpleChannelContact _v9620) $ Vector.toList _v9618))) $ getAllSimpleChannelContacts_result_success record
    , (\_v9618 -> (1, ("e",from_TalkException _v9618))) <$> getAllSimpleChannelContacts_result_e record
    ]
    )
write_GetAllSimpleChannelContacts_result :: T.Protocol p => p -> GetAllSimpleChannelContacts_result -> P.IO ()
write_GetAllSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetAllSimpleChannelContacts_result record
encode_GetAllSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetAllSimpleChannelContacts_result -> LBS.ByteString
encode_GetAllSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetAllSimpleChannelContacts_result record
to_GetAllSimpleChannelContacts_result :: T.ThriftVal -> GetAllSimpleChannelContacts_result
to_GetAllSimpleChannelContacts_result (T.TStruct fields) = GetAllSimpleChannelContacts_result{
  getAllSimpleChannelContacts_result_success = P.maybe (getAllSimpleChannelContacts_result_success default_GetAllSimpleChannelContacts_result) (\(_,_val9622) -> (case _val9622 of {T.TList _ _val9623 -> (Vector.fromList $ P.map (\_v9624 -> (case _v9624 of {T.TStruct _val9625 -> (to_SimpleChannelContact (T.TStruct _val9625)); _ -> P.error "wrong type"})) _val9623); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val9622) -> P.Just (case _val9622 of {T.TStruct _val9626 -> (to_TalkException (T.TStruct _val9626)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllSimpleChannelContacts_result _ = P.error "not a struct"
read_GetAllSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetAllSimpleChannelContacts_result
read_GetAllSimpleChannelContacts_result iprot = to_GetAllSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_result)
decode_GetAllSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllSimpleChannelContacts_result
decode_GetAllSimpleChannelContacts_result iprot bs = to_GetAllSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllSimpleChannelContacts_result) bs
typemap_GetAllSimpleChannelContacts_result :: T.TypeMap
typemap_GetAllSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllSimpleChannelContacts_result :: GetAllSimpleChannelContacts_result
default_GetAllSimpleChannelContacts_result = GetAllSimpleChannelContacts_result{
  getAllSimpleChannelContacts_result_success = Vector.empty,
  getAllSimpleChannelContacts_result_e = P.Nothing}
data GetUserIdentities_args = GetUserIdentities_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserIdentities_args where 
  arbitrary = QC.elements [GetUserIdentities_args]
from_GetUserIdentities_args :: GetUserIdentities_args -> T.ThriftVal
from_GetUserIdentities_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserIdentities_args :: T.Protocol p => p -> GetUserIdentities_args -> P.IO ()
write_GetUserIdentities_args oprot record = T.writeVal oprot $ from_GetUserIdentities_args record
encode_GetUserIdentities_args :: T.StatelessProtocol p => p -> GetUserIdentities_args -> LBS.ByteString
encode_GetUserIdentities_args oprot record = T.serializeVal oprot $ from_GetUserIdentities_args record
to_GetUserIdentities_args :: T.ThriftVal -> GetUserIdentities_args
to_GetUserIdentities_args (T.TStruct fields) = GetUserIdentities_args{

  }
to_GetUserIdentities_args _ = P.error "not a struct"
read_GetUserIdentities_args :: T.Protocol p => p -> P.IO GetUserIdentities_args
read_GetUserIdentities_args iprot = to_GetUserIdentities_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_args)
decode_GetUserIdentities_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_args
decode_GetUserIdentities_args iprot bs = to_GetUserIdentities_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_args) bs
typemap_GetUserIdentities_args :: T.TypeMap
typemap_GetUserIdentities_args = Map.fromList []
default_GetUserIdentities_args :: GetUserIdentities_args
default_GetUserIdentities_args = GetUserIdentities_args{
}
data GetUserIdentities_result = GetUserIdentities_result  { getUserIdentities_result_success :: (Map.HashMap RegistrationType LT.Text)
  , getUserIdentities_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserIdentities_result_success record   `H.hashWithSalt` getUserIdentities_result_e record  
instance QC.Arbitrary GetUserIdentities_result where 
  arbitrary = M.liftM GetUserIdentities_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserIdentities_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj}
    , if obj == default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj}
    ]
from_GetUserIdentities_result :: GetUserIdentities_result -> T.ThriftVal
from_GetUserIdentities_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9634 -> (1, ("e",from_TalkException _v9634))) <$> getUserIdentities_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9634 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k9635,_v9636) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k9635, T.TString $ E.encodeUtf8 _v9636)) $ Map.toList _v9634))) $ getUserIdentities_result_success record
    , (\_v9634 -> (1, ("e",from_TalkException _v9634))) <$> getUserIdentities_result_e record
    ]
    )
write_GetUserIdentities_result :: T.Protocol p => p -> GetUserIdentities_result -> P.IO ()
write_GetUserIdentities_result oprot record = T.writeVal oprot $ from_GetUserIdentities_result record
encode_GetUserIdentities_result :: T.StatelessProtocol p => p -> GetUserIdentities_result -> LBS.ByteString
encode_GetUserIdentities_result oprot record = T.serializeVal oprot $ from_GetUserIdentities_result record
to_GetUserIdentities_result :: T.ThriftVal -> GetUserIdentities_result
to_GetUserIdentities_result (T.TStruct fields) = GetUserIdentities_result{
  getUserIdentities_result_success = P.maybe (getUserIdentities_result_success default_GetUserIdentities_result) (\(_,_val9638) -> (case _val9638 of {T.TMap _ _ _val9639 -> (Map.fromList $ P.map (\(_k9641,_v9640) -> ((case _k9641 of {T.TI32 _val9642 -> P.toEnum $ P.fromIntegral _val9642; _ -> P.error "wrong type"}),(case _v9640 of {T.TString _val9643 -> E.decodeUtf8 _val9643; _ -> P.error "wrong type"}))) _val9639); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserIdentities_result_e = P.maybe (P.Nothing) (\(_,_val9638) -> P.Just (case _val9638 of {T.TStruct _val9644 -> (to_TalkException (T.TStruct _val9644)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserIdentities_result _ = P.error "not a struct"
read_GetUserIdentities_result :: T.Protocol p => p -> P.IO GetUserIdentities_result
read_GetUserIdentities_result iprot = to_GetUserIdentities_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_result)
decode_GetUserIdentities_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_result
decode_GetUserIdentities_result iprot bs = to_GetUserIdentities_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_result) bs
typemap_GetUserIdentities_result :: T.TypeMap
typemap_GetUserIdentities_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserIdentities_result :: GetUserIdentities_result
default_GetUserIdentities_result = GetUserIdentities_result{
  getUserIdentities_result_success = Map.empty,
  getUserIdentities_result_e = P.Nothing}
data MarkPaidCallAd_args = MarkPaidCallAd_args  { markPaidCallAd_args_dialedNumber :: LT.Text
  , markPaidCallAd_args_language :: LT.Text
  , markPaidCallAd_args_disableCallerId :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkPaidCallAd_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` markPaidCallAd_args_dialedNumber record   `H.hashWithSalt` markPaidCallAd_args_language record   `H.hashWithSalt` markPaidCallAd_args_disableCallerId record  
instance QC.Arbitrary MarkPaidCallAd_args where 
  arbitrary = M.liftM MarkPaidCallAd_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_MarkPaidCallAd_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_dialedNumber = markPaidCallAd_args_dialedNumber obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_dialedNumber = markPaidCallAd_args_dialedNumber obj}
    , if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_language = markPaidCallAd_args_language obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_language = markPaidCallAd_args_language obj}
    , if obj == default_MarkPaidCallAd_args{markPaidCallAd_args_disableCallerId = markPaidCallAd_args_disableCallerId obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_args{markPaidCallAd_args_disableCallerId = markPaidCallAd_args_disableCallerId obj}
    ]
from_MarkPaidCallAd_args :: MarkPaidCallAd_args -> T.ThriftVal
from_MarkPaidCallAd_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9647 -> P.Just (2, ("dialedNumber",T.TString $ E.encodeUtf8 _v9647))) $ markPaidCallAd_args_dialedNumber record
  , (\_v9647 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v9647))) $ markPaidCallAd_args_language record
  , (\_v9647 -> P.Just (4, ("disableCallerId",T.TBool _v9647))) $ markPaidCallAd_args_disableCallerId record
  ]
write_MarkPaidCallAd_args :: T.Protocol p => p -> MarkPaidCallAd_args -> P.IO ()
write_MarkPaidCallAd_args oprot record = T.writeVal oprot $ from_MarkPaidCallAd_args record
encode_MarkPaidCallAd_args :: T.StatelessProtocol p => p -> MarkPaidCallAd_args -> LBS.ByteString
encode_MarkPaidCallAd_args oprot record = T.serializeVal oprot $ from_MarkPaidCallAd_args record
to_MarkPaidCallAd_args :: T.ThriftVal -> MarkPaidCallAd_args
to_MarkPaidCallAd_args (T.TStruct fields) = MarkPaidCallAd_args{
  markPaidCallAd_args_dialedNumber = P.maybe (markPaidCallAd_args_dialedNumber default_MarkPaidCallAd_args) (\(_,_val9649) -> (case _val9649 of {T.TString _val9650 -> E.decodeUtf8 _val9650; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  markPaidCallAd_args_language = P.maybe (markPaidCallAd_args_language default_MarkPaidCallAd_args) (\(_,_val9649) -> (case _val9649 of {T.TString _val9651 -> E.decodeUtf8 _val9651; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  markPaidCallAd_args_disableCallerId = P.maybe (markPaidCallAd_args_disableCallerId default_MarkPaidCallAd_args) (\(_,_val9649) -> (case _val9649 of {T.TBool _val9652 -> _val9652; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_MarkPaidCallAd_args _ = P.error "not a struct"
read_MarkPaidCallAd_args :: T.Protocol p => p -> P.IO MarkPaidCallAd_args
read_MarkPaidCallAd_args iprot = to_MarkPaidCallAd_args <$> T.readVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_args)
decode_MarkPaidCallAd_args :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkPaidCallAd_args
decode_MarkPaidCallAd_args iprot bs = to_MarkPaidCallAd_args $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_args) bs
typemap_MarkPaidCallAd_args :: T.TypeMap
typemap_MarkPaidCallAd_args = Map.fromList [(2,("dialedNumber",T.T_STRING)),(3,("language",T.T_STRING)),(4,("disableCallerId",T.T_BOOL))]
default_MarkPaidCallAd_args :: MarkPaidCallAd_args
default_MarkPaidCallAd_args = MarkPaidCallAd_args{
  markPaidCallAd_args_dialedNumber = "",
  markPaidCallAd_args_language = "",
  markPaidCallAd_args_disableCallerId = P.False}
data MarkPaidCallAd_result = MarkPaidCallAd_result  { markPaidCallAd_result_success :: PaidCallDialing
  , markPaidCallAd_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MarkPaidCallAd_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` markPaidCallAd_result_success record   `H.hashWithSalt` markPaidCallAd_result_e record  
instance QC.Arbitrary MarkPaidCallAd_result where 
  arbitrary = M.liftM MarkPaidCallAd_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MarkPaidCallAd_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MarkPaidCallAd_result{markPaidCallAd_result_success = markPaidCallAd_result_success obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_result{markPaidCallAd_result_success = markPaidCallAd_result_success obj}
    , if obj == default_MarkPaidCallAd_result{markPaidCallAd_result_e = markPaidCallAd_result_e obj} then P.Nothing else P.Just $ default_MarkPaidCallAd_result{markPaidCallAd_result_e = markPaidCallAd_result_e obj}
    ]
from_MarkPaidCallAd_result :: MarkPaidCallAd_result -> T.ThriftVal
from_MarkPaidCallAd_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9655 -> (1, ("e",from_TalkException _v9655))) <$> markPaidCallAd_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9655 -> P.Just (0, ("success",from_PaidCallDialing _v9655))) $ markPaidCallAd_result_success record
    , (\_v9655 -> (1, ("e",from_TalkException _v9655))) <$> markPaidCallAd_result_e record
    ]
    )
write_MarkPaidCallAd_result :: T.Protocol p => p -> MarkPaidCallAd_result -> P.IO ()
write_MarkPaidCallAd_result oprot record = T.writeVal oprot $ from_MarkPaidCallAd_result record
encode_MarkPaidCallAd_result :: T.StatelessProtocol p => p -> MarkPaidCallAd_result -> LBS.ByteString
encode_MarkPaidCallAd_result oprot record = T.serializeVal oprot $ from_MarkPaidCallAd_result record
to_MarkPaidCallAd_result :: T.ThriftVal -> MarkPaidCallAd_result
to_MarkPaidCallAd_result (T.TStruct fields) = MarkPaidCallAd_result{
  markPaidCallAd_result_success = P.maybe (markPaidCallAd_result_success default_MarkPaidCallAd_result) (\(_,_val9657) -> (case _val9657 of {T.TStruct _val9658 -> (to_PaidCallDialing (T.TStruct _val9658)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  markPaidCallAd_result_e = P.maybe (P.Nothing) (\(_,_val9657) -> P.Just (case _val9657 of {T.TStruct _val9659 -> (to_TalkException (T.TStruct _val9659)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_MarkPaidCallAd_result _ = P.error "not a struct"
read_MarkPaidCallAd_result :: T.Protocol p => p -> P.IO MarkPaidCallAd_result
read_MarkPaidCallAd_result iprot = to_MarkPaidCallAd_result <$> T.readVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_result)
decode_MarkPaidCallAd_result :: T.StatelessProtocol p => p -> LBS.ByteString -> MarkPaidCallAd_result
decode_MarkPaidCallAd_result iprot bs = to_MarkPaidCallAd_result $ T.deserializeVal iprot (T.T_STRUCT typemap_MarkPaidCallAd_result) bs
typemap_MarkPaidCallAd_result :: T.TypeMap
typemap_MarkPaidCallAd_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallDialing))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_MarkPaidCallAd_result :: MarkPaidCallAd_result
default_MarkPaidCallAd_result = MarkPaidCallAd_result{
  markPaidCallAd_result_success = default_PaidCallDialing,
  markPaidCallAd_result_e = P.Nothing}
data IsGroupMember_args = IsGroupMember_args  { isGroupMember_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_args_groupId record  
instance QC.Arbitrary IsGroupMember_args where 
  arbitrary = M.liftM IsGroupMember_args (QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj} then P.Nothing else P.Just $ default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj}
    ]
from_IsGroupMember_args :: IsGroupMember_args -> T.ThriftVal
from_IsGroupMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9662 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v9662))) $ isGroupMember_args_groupId record
  ]
write_IsGroupMember_args :: T.Protocol p => p -> IsGroupMember_args -> P.IO ()
write_IsGroupMember_args oprot record = T.writeVal oprot $ from_IsGroupMember_args record
encode_IsGroupMember_args :: T.StatelessProtocol p => p -> IsGroupMember_args -> LBS.ByteString
encode_IsGroupMember_args oprot record = T.serializeVal oprot $ from_IsGroupMember_args record
to_IsGroupMember_args :: T.ThriftVal -> IsGroupMember_args
to_IsGroupMember_args (T.TStruct fields) = IsGroupMember_args{
  isGroupMember_args_groupId = P.maybe (isGroupMember_args_groupId default_IsGroupMember_args) (\(_,_val9664) -> (case _val9664 of {T.TString _val9665 -> E.decodeUtf8 _val9665; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_args _ = P.error "not a struct"
read_IsGroupMember_args :: T.Protocol p => p -> P.IO IsGroupMember_args
read_IsGroupMember_args iprot = to_IsGroupMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_args)
decode_IsGroupMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_args
decode_IsGroupMember_args iprot bs = to_IsGroupMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_args) bs
typemap_IsGroupMember_args :: T.TypeMap
typemap_IsGroupMember_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_IsGroupMember_args :: IsGroupMember_args
default_IsGroupMember_args = IsGroupMember_args{
  isGroupMember_args_groupId = ""}
data IsGroupMember_result = IsGroupMember_result  { isGroupMember_result_success :: P.Bool
  , isGroupMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_result_success record   `H.hashWithSalt` isGroupMember_result_e record  
instance QC.Arbitrary IsGroupMember_result where 
  arbitrary = M.liftM IsGroupMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj}
    , if obj == default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj}
    ]
from_IsGroupMember_result :: IsGroupMember_result -> T.ThriftVal
from_IsGroupMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9668 -> (1, ("e",from_TalkException _v9668))) <$> isGroupMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9668 -> P.Just (0, ("success",T.TBool _v9668))) $ isGroupMember_result_success record
    , (\_v9668 -> (1, ("e",from_TalkException _v9668))) <$> isGroupMember_result_e record
    ]
    )
write_IsGroupMember_result :: T.Protocol p => p -> IsGroupMember_result -> P.IO ()
write_IsGroupMember_result oprot record = T.writeVal oprot $ from_IsGroupMember_result record
encode_IsGroupMember_result :: T.StatelessProtocol p => p -> IsGroupMember_result -> LBS.ByteString
encode_IsGroupMember_result oprot record = T.serializeVal oprot $ from_IsGroupMember_result record
to_IsGroupMember_result :: T.ThriftVal -> IsGroupMember_result
to_IsGroupMember_result (T.TStruct fields) = IsGroupMember_result{
  isGroupMember_result_success = P.maybe (isGroupMember_result_success default_IsGroupMember_result) (\(_,_val9670) -> (case _val9670 of {T.TBool _val9671 -> _val9671; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isGroupMember_result_e = P.maybe (P.Nothing) (\(_,_val9670) -> P.Just (case _val9670 of {T.TStruct _val9672 -> (to_TalkException (T.TStruct _val9672)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_result _ = P.error "not a struct"
read_IsGroupMember_result :: T.Protocol p => p -> P.IO IsGroupMember_result
read_IsGroupMember_result iprot = to_IsGroupMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_result)
decode_IsGroupMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_result
decode_IsGroupMember_result iprot bs = to_IsGroupMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_result) bs
typemap_IsGroupMember_result :: T.TypeMap
typemap_IsGroupMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsGroupMember_result :: IsGroupMember_result
default_IsGroupMember_result = IsGroupMember_result{
  isGroupMember_result_success = P.False,
  isGroupMember_result_e = P.Nothing}
data GetPhoneInfoFromPhoneNumber_args = GetPhoneInfoFromPhoneNumber_args  { getPhoneInfoFromPhoneNumber_args_region :: LT.Text
  , getPhoneInfoFromPhoneNumber_args_phoneNumber :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPhoneInfoFromPhoneNumber_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_args_region record   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_args_phoneNumber record  
instance QC.Arbitrary GetPhoneInfoFromPhoneNumber_args where 
  arbitrary = M.liftM GetPhoneInfoFromPhoneNumber_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPhoneInfoFromPhoneNumber_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_region = getPhoneInfoFromPhoneNumber_args_region obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_region = getPhoneInfoFromPhoneNumber_args_region obj}
    , if obj == default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_phoneNumber = getPhoneInfoFromPhoneNumber_args_phoneNumber obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_args{getPhoneInfoFromPhoneNumber_args_phoneNumber = getPhoneInfoFromPhoneNumber_args_phoneNumber obj}
    ]
from_GetPhoneInfoFromPhoneNumber_args :: GetPhoneInfoFromPhoneNumber_args -> T.ThriftVal
from_GetPhoneInfoFromPhoneNumber_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9675 -> P.Just (1, ("region",T.TString $ E.encodeUtf8 _v9675))) $ getPhoneInfoFromPhoneNumber_args_region record
  , (\_v9675 -> P.Just (2, ("phoneNumber",T.TString $ E.encodeUtf8 _v9675))) $ getPhoneInfoFromPhoneNumber_args_phoneNumber record
  ]
write_GetPhoneInfoFromPhoneNumber_args :: T.Protocol p => p -> GetPhoneInfoFromPhoneNumber_args -> P.IO ()
write_GetPhoneInfoFromPhoneNumber_args oprot record = T.writeVal oprot $ from_GetPhoneInfoFromPhoneNumber_args record
encode_GetPhoneInfoFromPhoneNumber_args :: T.StatelessProtocol p => p -> GetPhoneInfoFromPhoneNumber_args -> LBS.ByteString
encode_GetPhoneInfoFromPhoneNumber_args oprot record = T.serializeVal oprot $ from_GetPhoneInfoFromPhoneNumber_args record
to_GetPhoneInfoFromPhoneNumber_args :: T.ThriftVal -> GetPhoneInfoFromPhoneNumber_args
to_GetPhoneInfoFromPhoneNumber_args (T.TStruct fields) = GetPhoneInfoFromPhoneNumber_args{
  getPhoneInfoFromPhoneNumber_args_region = P.maybe (getPhoneInfoFromPhoneNumber_args_region default_GetPhoneInfoFromPhoneNumber_args) (\(_,_val9677) -> (case _val9677 of {T.TString _val9678 -> E.decodeUtf8 _val9678; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getPhoneInfoFromPhoneNumber_args_phoneNumber = P.maybe (getPhoneInfoFromPhoneNumber_args_phoneNumber default_GetPhoneInfoFromPhoneNumber_args) (\(_,_val9677) -> (case _val9677 of {T.TString _val9679 -> E.decodeUtf8 _val9679; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPhoneInfoFromPhoneNumber_args _ = P.error "not a struct"
read_GetPhoneInfoFromPhoneNumber_args :: T.Protocol p => p -> P.IO GetPhoneInfoFromPhoneNumber_args
read_GetPhoneInfoFromPhoneNumber_args iprot = to_GetPhoneInfoFromPhoneNumber_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_args)
decode_GetPhoneInfoFromPhoneNumber_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPhoneInfoFromPhoneNumber_args
decode_GetPhoneInfoFromPhoneNumber_args iprot bs = to_GetPhoneInfoFromPhoneNumber_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_args) bs
typemap_GetPhoneInfoFromPhoneNumber_args :: T.TypeMap
typemap_GetPhoneInfoFromPhoneNumber_args = Map.fromList [(1,("region",T.T_STRING)),(2,("phoneNumber",T.T_STRING))]
default_GetPhoneInfoFromPhoneNumber_args :: GetPhoneInfoFromPhoneNumber_args
default_GetPhoneInfoFromPhoneNumber_args = GetPhoneInfoFromPhoneNumber_args{
  getPhoneInfoFromPhoneNumber_args_region = "",
  getPhoneInfoFromPhoneNumber_args_phoneNumber = ""}
data GetPhoneInfoFromPhoneNumber_result = GetPhoneInfoFromPhoneNumber_result  { getPhoneInfoFromPhoneNumber_result_success :: PhoneInfoForChannel
  , getPhoneInfoFromPhoneNumber_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPhoneInfoFromPhoneNumber_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_result_success record   `H.hashWithSalt` getPhoneInfoFromPhoneNumber_result_e record  
instance QC.Arbitrary GetPhoneInfoFromPhoneNumber_result where 
  arbitrary = M.liftM GetPhoneInfoFromPhoneNumber_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPhoneInfoFromPhoneNumber_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = getPhoneInfoFromPhoneNumber_result_success obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = getPhoneInfoFromPhoneNumber_result_success obj}
    , if obj == default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = getPhoneInfoFromPhoneNumber_result_e obj} then P.Nothing else P.Just $ default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = getPhoneInfoFromPhoneNumber_result_e obj}
    ]
from_GetPhoneInfoFromPhoneNumber_result :: GetPhoneInfoFromPhoneNumber_result -> T.ThriftVal
from_GetPhoneInfoFromPhoneNumber_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9682 -> (1, ("e",from_TalkException _v9682))) <$> getPhoneInfoFromPhoneNumber_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9682 -> P.Just (0, ("success",from_PhoneInfoForChannel _v9682))) $ getPhoneInfoFromPhoneNumber_result_success record
    , (\_v9682 -> (1, ("e",from_TalkException _v9682))) <$> getPhoneInfoFromPhoneNumber_result_e record
    ]
    )
write_GetPhoneInfoFromPhoneNumber_result :: T.Protocol p => p -> GetPhoneInfoFromPhoneNumber_result -> P.IO ()
write_GetPhoneInfoFromPhoneNumber_result oprot record = T.writeVal oprot $ from_GetPhoneInfoFromPhoneNumber_result record
encode_GetPhoneInfoFromPhoneNumber_result :: T.StatelessProtocol p => p -> GetPhoneInfoFromPhoneNumber_result -> LBS.ByteString
encode_GetPhoneInfoFromPhoneNumber_result oprot record = T.serializeVal oprot $ from_GetPhoneInfoFromPhoneNumber_result record
to_GetPhoneInfoFromPhoneNumber_result :: T.ThriftVal -> GetPhoneInfoFromPhoneNumber_result
to_GetPhoneInfoFromPhoneNumber_result (T.TStruct fields) = GetPhoneInfoFromPhoneNumber_result{
  getPhoneInfoFromPhoneNumber_result_success = P.maybe (getPhoneInfoFromPhoneNumber_result_success default_GetPhoneInfoFromPhoneNumber_result) (\(_,_val9684) -> (case _val9684 of {T.TStruct _val9685 -> (to_PhoneInfoForChannel (T.TStruct _val9685)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPhoneInfoFromPhoneNumber_result_e = P.maybe (P.Nothing) (\(_,_val9684) -> P.Just (case _val9684 of {T.TStruct _val9686 -> (to_TalkException (T.TStruct _val9686)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPhoneInfoFromPhoneNumber_result _ = P.error "not a struct"
read_GetPhoneInfoFromPhoneNumber_result :: T.Protocol p => p -> P.IO GetPhoneInfoFromPhoneNumber_result
read_GetPhoneInfoFromPhoneNumber_result iprot = to_GetPhoneInfoFromPhoneNumber_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_result)
decode_GetPhoneInfoFromPhoneNumber_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPhoneInfoFromPhoneNumber_result
decode_GetPhoneInfoFromPhoneNumber_result iprot bs = to_GetPhoneInfoFromPhoneNumber_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPhoneInfoFromPhoneNumber_result) bs
typemap_GetPhoneInfoFromPhoneNumber_result :: T.TypeMap
typemap_GetPhoneInfoFromPhoneNumber_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PhoneInfoForChannel))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPhoneInfoFromPhoneNumber_result :: GetPhoneInfoFromPhoneNumber_result
default_GetPhoneInfoFromPhoneNumber_result = GetPhoneInfoFromPhoneNumber_result{
  getPhoneInfoFromPhoneNumber_result_success = default_PhoneInfoForChannel,
  getPhoneInfoFromPhoneNumber_result_e = P.Nothing}
data RedeemPaidCallVoucher_args = RedeemPaidCallVoucher_args  { redeemPaidCallVoucher_args_serial :: LT.Text
  , redeemPaidCallVoucher_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RedeemPaidCallVoucher_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` redeemPaidCallVoucher_args_serial record   `H.hashWithSalt` redeemPaidCallVoucher_args_language record  
instance QC.Arbitrary RedeemPaidCallVoucher_args where 
  arbitrary = M.liftM RedeemPaidCallVoucher_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RedeemPaidCallVoucher_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_serial = redeemPaidCallVoucher_args_serial obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_serial = redeemPaidCallVoucher_args_serial obj}
    , if obj == default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_language = redeemPaidCallVoucher_args_language obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_args{redeemPaidCallVoucher_args_language = redeemPaidCallVoucher_args_language obj}
    ]
from_RedeemPaidCallVoucher_args :: RedeemPaidCallVoucher_args -> T.ThriftVal
from_RedeemPaidCallVoucher_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9689 -> P.Just (2, ("serial",T.TString $ E.encodeUtf8 _v9689))) $ redeemPaidCallVoucher_args_serial record
  , (\_v9689 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v9689))) $ redeemPaidCallVoucher_args_language record
  ]
write_RedeemPaidCallVoucher_args :: T.Protocol p => p -> RedeemPaidCallVoucher_args -> P.IO ()
write_RedeemPaidCallVoucher_args oprot record = T.writeVal oprot $ from_RedeemPaidCallVoucher_args record
encode_RedeemPaidCallVoucher_args :: T.StatelessProtocol p => p -> RedeemPaidCallVoucher_args -> LBS.ByteString
encode_RedeemPaidCallVoucher_args oprot record = T.serializeVal oprot $ from_RedeemPaidCallVoucher_args record
to_RedeemPaidCallVoucher_args :: T.ThriftVal -> RedeemPaidCallVoucher_args
to_RedeemPaidCallVoucher_args (T.TStruct fields) = RedeemPaidCallVoucher_args{
  redeemPaidCallVoucher_args_serial = P.maybe (redeemPaidCallVoucher_args_serial default_RedeemPaidCallVoucher_args) (\(_,_val9691) -> (case _val9691 of {T.TString _val9692 -> E.decodeUtf8 _val9692; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  redeemPaidCallVoucher_args_language = P.maybe (redeemPaidCallVoucher_args_language default_RedeemPaidCallVoucher_args) (\(_,_val9691) -> (case _val9691 of {T.TString _val9693 -> E.decodeUtf8 _val9693; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RedeemPaidCallVoucher_args _ = P.error "not a struct"
read_RedeemPaidCallVoucher_args :: T.Protocol p => p -> P.IO RedeemPaidCallVoucher_args
read_RedeemPaidCallVoucher_args iprot = to_RedeemPaidCallVoucher_args <$> T.readVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_args)
decode_RedeemPaidCallVoucher_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RedeemPaidCallVoucher_args
decode_RedeemPaidCallVoucher_args iprot bs = to_RedeemPaidCallVoucher_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_args) bs
typemap_RedeemPaidCallVoucher_args :: T.TypeMap
typemap_RedeemPaidCallVoucher_args = Map.fromList [(2,("serial",T.T_STRING)),(3,("language",T.T_STRING))]
default_RedeemPaidCallVoucher_args :: RedeemPaidCallVoucher_args
default_RedeemPaidCallVoucher_args = RedeemPaidCallVoucher_args{
  redeemPaidCallVoucher_args_serial = "",
  redeemPaidCallVoucher_args_language = ""}
data RedeemPaidCallVoucher_result = RedeemPaidCallVoucher_result  { redeemPaidCallVoucher_result_success :: PaidCallRedeemResult
  , redeemPaidCallVoucher_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RedeemPaidCallVoucher_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` redeemPaidCallVoucher_result_success record   `H.hashWithSalt` redeemPaidCallVoucher_result_e record  
instance QC.Arbitrary RedeemPaidCallVoucher_result where 
  arbitrary = M.liftM RedeemPaidCallVoucher_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RedeemPaidCallVoucher_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = redeemPaidCallVoucher_result_success obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = redeemPaidCallVoucher_result_success obj}
    , if obj == default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = redeemPaidCallVoucher_result_e obj} then P.Nothing else P.Just $ default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = redeemPaidCallVoucher_result_e obj}
    ]
from_RedeemPaidCallVoucher_result :: RedeemPaidCallVoucher_result -> T.ThriftVal
from_RedeemPaidCallVoucher_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9696 -> (1, ("e",from_TalkException _v9696))) <$> redeemPaidCallVoucher_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9696 -> P.Just (0, ("success",from_PaidCallRedeemResult _v9696))) $ redeemPaidCallVoucher_result_success record
    , (\_v9696 -> (1, ("e",from_TalkException _v9696))) <$> redeemPaidCallVoucher_result_e record
    ]
    )
write_RedeemPaidCallVoucher_result :: T.Protocol p => p -> RedeemPaidCallVoucher_result -> P.IO ()
write_RedeemPaidCallVoucher_result oprot record = T.writeVal oprot $ from_RedeemPaidCallVoucher_result record
encode_RedeemPaidCallVoucher_result :: T.StatelessProtocol p => p -> RedeemPaidCallVoucher_result -> LBS.ByteString
encode_RedeemPaidCallVoucher_result oprot record = T.serializeVal oprot $ from_RedeemPaidCallVoucher_result record
to_RedeemPaidCallVoucher_result :: T.ThriftVal -> RedeemPaidCallVoucher_result
to_RedeemPaidCallVoucher_result (T.TStruct fields) = RedeemPaidCallVoucher_result{
  redeemPaidCallVoucher_result_success = P.maybe (redeemPaidCallVoucher_result_success default_RedeemPaidCallVoucher_result) (\(_,_val9698) -> (case _val9698 of {T.TStruct _val9699 -> (to_PaidCallRedeemResult (T.TStruct _val9699)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  redeemPaidCallVoucher_result_e = P.maybe (P.Nothing) (\(_,_val9698) -> P.Just (case _val9698 of {T.TStruct _val9700 -> (to_TalkException (T.TStruct _val9700)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RedeemPaidCallVoucher_result _ = P.error "not a struct"
read_RedeemPaidCallVoucher_result :: T.Protocol p => p -> P.IO RedeemPaidCallVoucher_result
read_RedeemPaidCallVoucher_result iprot = to_RedeemPaidCallVoucher_result <$> T.readVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_result)
decode_RedeemPaidCallVoucher_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RedeemPaidCallVoucher_result
decode_RedeemPaidCallVoucher_result iprot bs = to_RedeemPaidCallVoucher_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RedeemPaidCallVoucher_result) bs
typemap_RedeemPaidCallVoucher_result :: T.TypeMap
typemap_RedeemPaidCallVoucher_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallRedeemResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RedeemPaidCallVoucher_result :: RedeemPaidCallVoucher_result
default_RedeemPaidCallVoucher_result = RedeemPaidCallVoucher_result{
  redeemPaidCallVoucher_result_success = default_PaidCallRedeemResult,
  redeemPaidCallVoucher_result_e = P.Nothing}
data GetPreferredDisplayName_args = GetPreferredDisplayName_args  { getPreferredDisplayName_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreferredDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreferredDisplayName_args_mids record  
instance QC.Arbitrary GetPreferredDisplayName_args where 
  arbitrary = M.liftM GetPreferredDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetPreferredDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreferredDisplayName_args{getPreferredDisplayName_args_mids = getPreferredDisplayName_args_mids obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_args{getPreferredDisplayName_args_mids = getPreferredDisplayName_args_mids obj}
    ]
from_GetPreferredDisplayName_args :: GetPreferredDisplayName_args -> T.ThriftVal
from_GetPreferredDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9703 -> P.Just (1, ("mids",T.TList T.T_STRING $ P.map (\_v9705 -> T.TString $ E.encodeUtf8 _v9705) $ Vector.toList _v9703))) $ getPreferredDisplayName_args_mids record
  ]
write_GetPreferredDisplayName_args :: T.Protocol p => p -> GetPreferredDisplayName_args -> P.IO ()
write_GetPreferredDisplayName_args oprot record = T.writeVal oprot $ from_GetPreferredDisplayName_args record
encode_GetPreferredDisplayName_args :: T.StatelessProtocol p => p -> GetPreferredDisplayName_args -> LBS.ByteString
encode_GetPreferredDisplayName_args oprot record = T.serializeVal oprot $ from_GetPreferredDisplayName_args record
to_GetPreferredDisplayName_args :: T.ThriftVal -> GetPreferredDisplayName_args
to_GetPreferredDisplayName_args (T.TStruct fields) = GetPreferredDisplayName_args{
  getPreferredDisplayName_args_mids = P.maybe (getPreferredDisplayName_args_mids default_GetPreferredDisplayName_args) (\(_,_val9707) -> (case _val9707 of {T.TList _ _val9708 -> (Vector.fromList $ P.map (\_v9709 -> (case _v9709 of {T.TString _val9710 -> E.decodeUtf8 _val9710; _ -> P.error "wrong type"})) _val9708); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreferredDisplayName_args _ = P.error "not a struct"
read_GetPreferredDisplayName_args :: T.Protocol p => p -> P.IO GetPreferredDisplayName_args
read_GetPreferredDisplayName_args iprot = to_GetPreferredDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_args)
decode_GetPreferredDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreferredDisplayName_args
decode_GetPreferredDisplayName_args iprot bs = to_GetPreferredDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_args) bs
typemap_GetPreferredDisplayName_args :: T.TypeMap
typemap_GetPreferredDisplayName_args = Map.fromList [(1,("mids",(T.T_LIST T.T_STRING)))]
default_GetPreferredDisplayName_args :: GetPreferredDisplayName_args
default_GetPreferredDisplayName_args = GetPreferredDisplayName_args{
  getPreferredDisplayName_args_mids = Vector.empty}
data GetPreferredDisplayName_result = GetPreferredDisplayName_result  { getPreferredDisplayName_result_success :: (Map.HashMap LT.Text LT.Text)
  , getPreferredDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPreferredDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPreferredDisplayName_result_success record   `H.hashWithSalt` getPreferredDisplayName_result_e record  
instance QC.Arbitrary GetPreferredDisplayName_result where 
  arbitrary = M.liftM GetPreferredDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPreferredDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = getPreferredDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = getPreferredDisplayName_result_success obj}
    , if obj == default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = getPreferredDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = getPreferredDisplayName_result_e obj}
    ]
from_GetPreferredDisplayName_result :: GetPreferredDisplayName_result -> T.ThriftVal
from_GetPreferredDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9713 -> (1, ("e",from_TalkException _v9713))) <$> getPreferredDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9713 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k9714,_v9715) -> (T.TString $ E.encodeUtf8 _k9714, T.TString $ E.encodeUtf8 _v9715)) $ Map.toList _v9713))) $ getPreferredDisplayName_result_success record
    , (\_v9713 -> (1, ("e",from_TalkException _v9713))) <$> getPreferredDisplayName_result_e record
    ]
    )
write_GetPreferredDisplayName_result :: T.Protocol p => p -> GetPreferredDisplayName_result -> P.IO ()
write_GetPreferredDisplayName_result oprot record = T.writeVal oprot $ from_GetPreferredDisplayName_result record
encode_GetPreferredDisplayName_result :: T.StatelessProtocol p => p -> GetPreferredDisplayName_result -> LBS.ByteString
encode_GetPreferredDisplayName_result oprot record = T.serializeVal oprot $ from_GetPreferredDisplayName_result record
to_GetPreferredDisplayName_result :: T.ThriftVal -> GetPreferredDisplayName_result
to_GetPreferredDisplayName_result (T.TStruct fields) = GetPreferredDisplayName_result{
  getPreferredDisplayName_result_success = P.maybe (getPreferredDisplayName_result_success default_GetPreferredDisplayName_result) (\(_,_val9717) -> (case _val9717 of {T.TMap _ _ _val9718 -> (Map.fromList $ P.map (\(_k9720,_v9719) -> ((case _k9720 of {T.TString _val9721 -> E.decodeUtf8 _val9721; _ -> P.error "wrong type"}),(case _v9719 of {T.TString _val9722 -> E.decodeUtf8 _val9722; _ -> P.error "wrong type"}))) _val9718); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPreferredDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val9717) -> P.Just (case _val9717 of {T.TStruct _val9723 -> (to_TalkException (T.TStruct _val9723)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPreferredDisplayName_result _ = P.error "not a struct"
read_GetPreferredDisplayName_result :: T.Protocol p => p -> P.IO GetPreferredDisplayName_result
read_GetPreferredDisplayName_result iprot = to_GetPreferredDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_result)
decode_GetPreferredDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPreferredDisplayName_result
decode_GetPreferredDisplayName_result iprot bs = to_GetPreferredDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPreferredDisplayName_result) bs
typemap_GetPreferredDisplayName_result :: T.TypeMap
typemap_GetPreferredDisplayName_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPreferredDisplayName_result :: GetPreferredDisplayName_result
default_GetPreferredDisplayName_result = GetPreferredDisplayName_result{
  getPreferredDisplayName_result_success = Map.empty,
  getPreferredDisplayName_result_e = P.Nothing}
data GetContactsForChannel_args = GetContactsForChannel_args  { getContactsForChannel_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_args_ids record  
instance QC.Arbitrary GetContactsForChannel_args where 
  arbitrary = M.liftM GetContactsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj} then P.Nothing else P.Just $ default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj}
    ]
from_GetContactsForChannel_args :: GetContactsForChannel_args -> T.ThriftVal
from_GetContactsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9726 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v9728 -> T.TString $ E.encodeUtf8 _v9728) $ Vector.toList _v9726))) $ getContactsForChannel_args_ids record
  ]
write_GetContactsForChannel_args :: T.Protocol p => p -> GetContactsForChannel_args -> P.IO ()
write_GetContactsForChannel_args oprot record = T.writeVal oprot $ from_GetContactsForChannel_args record
encode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> GetContactsForChannel_args -> LBS.ByteString
encode_GetContactsForChannel_args oprot record = T.serializeVal oprot $ from_GetContactsForChannel_args record
to_GetContactsForChannel_args :: T.ThriftVal -> GetContactsForChannel_args
to_GetContactsForChannel_args (T.TStruct fields) = GetContactsForChannel_args{
  getContactsForChannel_args_ids = P.maybe (getContactsForChannel_args_ids default_GetContactsForChannel_args) (\(_,_val9730) -> (case _val9730 of {T.TList _ _val9731 -> (Vector.fromList $ P.map (\_v9732 -> (case _v9732 of {T.TString _val9733 -> E.decodeUtf8 _val9733; _ -> P.error "wrong type"})) _val9731); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContactsForChannel_args _ = P.error "not a struct"
read_GetContactsForChannel_args :: T.Protocol p => p -> P.IO GetContactsForChannel_args
read_GetContactsForChannel_args iprot = to_GetContactsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args)
decode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_args
decode_GetContactsForChannel_args iprot bs = to_GetContactsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args) bs
typemap_GetContactsForChannel_args :: T.TypeMap
typemap_GetContactsForChannel_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContactsForChannel_args :: GetContactsForChannel_args
default_GetContactsForChannel_args = GetContactsForChannel_args{
  getContactsForChannel_args_ids = Vector.empty}
data GetContactsForChannel_result = GetContactsForChannel_result  { getContactsForChannel_result_success :: (Vector.Vector Contact)
  , getContactsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_result_success record   `H.hashWithSalt` getContactsForChannel_result_e record  
instance QC.Arbitrary GetContactsForChannel_result where 
  arbitrary = M.liftM GetContactsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj}
    , if obj == default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj}
    ]
from_GetContactsForChannel_result :: GetContactsForChannel_result -> T.ThriftVal
from_GetContactsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9736 -> (1, ("e",from_TalkException _v9736))) <$> getContactsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9736 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v9738 -> from_Contact _v9738) $ Vector.toList _v9736))) $ getContactsForChannel_result_success record
    , (\_v9736 -> (1, ("e",from_TalkException _v9736))) <$> getContactsForChannel_result_e record
    ]
    )
write_GetContactsForChannel_result :: T.Protocol p => p -> GetContactsForChannel_result -> P.IO ()
write_GetContactsForChannel_result oprot record = T.writeVal oprot $ from_GetContactsForChannel_result record
encode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> GetContactsForChannel_result -> LBS.ByteString
encode_GetContactsForChannel_result oprot record = T.serializeVal oprot $ from_GetContactsForChannel_result record
to_GetContactsForChannel_result :: T.ThriftVal -> GetContactsForChannel_result
to_GetContactsForChannel_result (T.TStruct fields) = GetContactsForChannel_result{
  getContactsForChannel_result_success = P.maybe (getContactsForChannel_result_success default_GetContactsForChannel_result) (\(_,_val9740) -> (case _val9740 of {T.TList _ _val9741 -> (Vector.fromList $ P.map (\_v9742 -> (case _v9742 of {T.TStruct _val9743 -> (to_Contact (T.TStruct _val9743)); _ -> P.error "wrong type"})) _val9741); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContactsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val9740) -> P.Just (case _val9740 of {T.TStruct _val9744 -> (to_TalkException (T.TStruct _val9744)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContactsForChannel_result _ = P.error "not a struct"
read_GetContactsForChannel_result :: T.Protocol p => p -> P.IO GetContactsForChannel_result
read_GetContactsForChannel_result iprot = to_GetContactsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result)
decode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_result
decode_GetContactsForChannel_result iprot bs = to_GetContactsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result) bs
typemap_GetContactsForChannel_result :: T.TypeMap
typemap_GetContactsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContactsForChannel_result :: GetContactsForChannel_result
default_GetContactsForChannel_result = GetContactsForChannel_result{
  getContactsForChannel_result_success = Vector.empty,
  getContactsForChannel_result_e = P.Nothing}
data GetCallCreditProducts_args = GetCallCreditProducts_args  { getCallCreditProducts_args_appStoreCode :: PaymentType
  , getCallCreditProducts_args_pgCode :: PaymentPgType
  , getCallCreditProducts_args_country :: LT.Text
  , getCallCreditProducts_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditProducts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditProducts_args_appStoreCode record   `H.hashWithSalt` getCallCreditProducts_args_pgCode record   `H.hashWithSalt` getCallCreditProducts_args_country record   `H.hashWithSalt` getCallCreditProducts_args_language record  
instance QC.Arbitrary GetCallCreditProducts_args where 
  arbitrary = M.liftM GetCallCreditProducts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetCallCreditProducts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_appStoreCode = getCallCreditProducts_args_appStoreCode obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_appStoreCode = getCallCreditProducts_args_appStoreCode obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_pgCode = getCallCreditProducts_args_pgCode obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_pgCode = getCallCreditProducts_args_pgCode obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_country = getCallCreditProducts_args_country obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_country = getCallCreditProducts_args_country obj}
    , if obj == default_GetCallCreditProducts_args{getCallCreditProducts_args_language = getCallCreditProducts_args_language obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_args{getCallCreditProducts_args_language = getCallCreditProducts_args_language obj}
    ]
from_GetCallCreditProducts_args :: GetCallCreditProducts_args -> T.ThriftVal
from_GetCallCreditProducts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9747 -> P.Just (2, ("appStoreCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v9747))) $ getCallCreditProducts_args_appStoreCode record
  , (\_v9747 -> P.Just (3, ("pgCode",T.TI32 $ P.fromIntegral $ P.fromEnum _v9747))) $ getCallCreditProducts_args_pgCode record
  , (\_v9747 -> P.Just (4, ("country",T.TString $ E.encodeUtf8 _v9747))) $ getCallCreditProducts_args_country record
  , (\_v9747 -> P.Just (5, ("language",T.TString $ E.encodeUtf8 _v9747))) $ getCallCreditProducts_args_language record
  ]
write_GetCallCreditProducts_args :: T.Protocol p => p -> GetCallCreditProducts_args -> P.IO ()
write_GetCallCreditProducts_args oprot record = T.writeVal oprot $ from_GetCallCreditProducts_args record
encode_GetCallCreditProducts_args :: T.StatelessProtocol p => p -> GetCallCreditProducts_args -> LBS.ByteString
encode_GetCallCreditProducts_args oprot record = T.serializeVal oprot $ from_GetCallCreditProducts_args record
to_GetCallCreditProducts_args :: T.ThriftVal -> GetCallCreditProducts_args
to_GetCallCreditProducts_args (T.TStruct fields) = GetCallCreditProducts_args{
  getCallCreditProducts_args_appStoreCode = P.maybe (getCallCreditProducts_args_appStoreCode default_GetCallCreditProducts_args) (\(_,_val9749) -> (case _val9749 of {T.TI32 _val9750 -> P.toEnum $ P.fromIntegral _val9750; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getCallCreditProducts_args_pgCode = P.maybe (getCallCreditProducts_args_pgCode default_GetCallCreditProducts_args) (\(_,_val9749) -> (case _val9749 of {T.TI32 _val9751 -> P.toEnum $ P.fromIntegral _val9751; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getCallCreditProducts_args_country = P.maybe (getCallCreditProducts_args_country default_GetCallCreditProducts_args) (\(_,_val9749) -> (case _val9749 of {T.TString _val9752 -> E.decodeUtf8 _val9752; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getCallCreditProducts_args_language = P.maybe (getCallCreditProducts_args_language default_GetCallCreditProducts_args) (\(_,_val9749) -> (case _val9749 of {T.TString _val9753 -> E.decodeUtf8 _val9753; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetCallCreditProducts_args _ = P.error "not a struct"
read_GetCallCreditProducts_args :: T.Protocol p => p -> P.IO GetCallCreditProducts_args
read_GetCallCreditProducts_args iprot = to_GetCallCreditProducts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_args)
decode_GetCallCreditProducts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditProducts_args
decode_GetCallCreditProducts_args iprot bs = to_GetCallCreditProducts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_args) bs
typemap_GetCallCreditProducts_args :: T.TypeMap
typemap_GetCallCreditProducts_args = Map.fromList [(2,("appStoreCode",T.T_I32)),(3,("pgCode",T.T_I32)),(4,("country",T.T_STRING)),(5,("language",T.T_STRING))]
default_GetCallCreditProducts_args :: GetCallCreditProducts_args
default_GetCallCreditProducts_args = GetCallCreditProducts_args{
  getCallCreditProducts_args_appStoreCode = (P.toEnum 0),
  getCallCreditProducts_args_pgCode = (P.toEnum 0),
  getCallCreditProducts_args_country = "",
  getCallCreditProducts_args_language = ""}
data GetCallCreditProducts_result = GetCallCreditProducts_result  { getCallCreditProducts_result_success :: (Vector.Vector CoinProductItem)
  , getCallCreditProducts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditProducts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditProducts_result_success record   `H.hashWithSalt` getCallCreditProducts_result_e record  
instance QC.Arbitrary GetCallCreditProducts_result where 
  arbitrary = M.liftM GetCallCreditProducts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCallCreditProducts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditProducts_result{getCallCreditProducts_result_success = getCallCreditProducts_result_success obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_result{getCallCreditProducts_result_success = getCallCreditProducts_result_success obj}
    , if obj == default_GetCallCreditProducts_result{getCallCreditProducts_result_e = getCallCreditProducts_result_e obj} then P.Nothing else P.Just $ default_GetCallCreditProducts_result{getCallCreditProducts_result_e = getCallCreditProducts_result_e obj}
    ]
from_GetCallCreditProducts_result :: GetCallCreditProducts_result -> T.ThriftVal
from_GetCallCreditProducts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9756 -> (1, ("e",from_TalkException _v9756))) <$> getCallCreditProducts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9756 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CoinProductItem) $ P.map (\_v9758 -> from_CoinProductItem _v9758) $ Vector.toList _v9756))) $ getCallCreditProducts_result_success record
    , (\_v9756 -> (1, ("e",from_TalkException _v9756))) <$> getCallCreditProducts_result_e record
    ]
    )
write_GetCallCreditProducts_result :: T.Protocol p => p -> GetCallCreditProducts_result -> P.IO ()
write_GetCallCreditProducts_result oprot record = T.writeVal oprot $ from_GetCallCreditProducts_result record
encode_GetCallCreditProducts_result :: T.StatelessProtocol p => p -> GetCallCreditProducts_result -> LBS.ByteString
encode_GetCallCreditProducts_result oprot record = T.serializeVal oprot $ from_GetCallCreditProducts_result record
to_GetCallCreditProducts_result :: T.ThriftVal -> GetCallCreditProducts_result
to_GetCallCreditProducts_result (T.TStruct fields) = GetCallCreditProducts_result{
  getCallCreditProducts_result_success = P.maybe (getCallCreditProducts_result_success default_GetCallCreditProducts_result) (\(_,_val9760) -> (case _val9760 of {T.TList _ _val9761 -> (Vector.fromList $ P.map (\_v9762 -> (case _v9762 of {T.TStruct _val9763 -> (to_CoinProductItem (T.TStruct _val9763)); _ -> P.error "wrong type"})) _val9761); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCallCreditProducts_result_e = P.maybe (P.Nothing) (\(_,_val9760) -> P.Just (case _val9760 of {T.TStruct _val9764 -> (to_TalkException (T.TStruct _val9764)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCallCreditProducts_result _ = P.error "not a struct"
read_GetCallCreditProducts_result :: T.Protocol p => p -> P.IO GetCallCreditProducts_result
read_GetCallCreditProducts_result iprot = to_GetCallCreditProducts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_result)
decode_GetCallCreditProducts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditProducts_result
decode_GetCallCreditProducts_result iprot bs = to_GetCallCreditProducts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditProducts_result) bs
typemap_GetCallCreditProducts_result :: T.TypeMap
typemap_GetCallCreditProducts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CoinProductItem)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCallCreditProducts_result :: GetCallCreditProducts_result
default_GetCallCreditProducts_result = GetCallCreditProducts_result{
  getCallCreditProducts_result_success = Vector.empty,
  getCallCreditProducts_result_e = P.Nothing}
data GetCompactContacts_args = GetCompactContacts_args  { getCompactContacts_args_lastModifiedTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_args_lastModifiedTimestamp record  
instance QC.Arbitrary GetCompactContacts_args where 
  arbitrary = M.liftM GetCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj} then P.Nothing else P.Just $ default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj}
    ]
from_GetCompactContacts_args :: GetCompactContacts_args -> T.ThriftVal
from_GetCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9767 -> P.Just (2, ("lastModifiedTimestamp",T.TI64 _v9767))) $ getCompactContacts_args_lastModifiedTimestamp record
  ]
write_GetCompactContacts_args :: T.Protocol p => p -> GetCompactContacts_args -> P.IO ()
write_GetCompactContacts_args oprot record = T.writeVal oprot $ from_GetCompactContacts_args record
encode_GetCompactContacts_args :: T.StatelessProtocol p => p -> GetCompactContacts_args -> LBS.ByteString
encode_GetCompactContacts_args oprot record = T.serializeVal oprot $ from_GetCompactContacts_args record
to_GetCompactContacts_args :: T.ThriftVal -> GetCompactContacts_args
to_GetCompactContacts_args (T.TStruct fields) = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = P.maybe (getCompactContacts_args_lastModifiedTimestamp default_GetCompactContacts_args) (\(_,_val9769) -> (case _val9769 of {T.TI64 _val9770 -> _val9770; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContacts_args _ = P.error "not a struct"
read_GetCompactContacts_args :: T.Protocol p => p -> P.IO GetCompactContacts_args
read_GetCompactContacts_args iprot = to_GetCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_args)
decode_GetCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_args
decode_GetCompactContacts_args iprot bs = to_GetCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_args) bs
typemap_GetCompactContacts_args :: T.TypeMap
typemap_GetCompactContacts_args = Map.fromList [(2,("lastModifiedTimestamp",T.T_I64))]
default_GetCompactContacts_args :: GetCompactContacts_args
default_GetCompactContacts_args = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = 0}
data GetCompactContacts_result = GetCompactContacts_result  { getCompactContacts_result_success :: (Vector.Vector CompactContact)
  , getCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_result_success record   `H.hashWithSalt` getCompactContacts_result_e record  
instance QC.Arbitrary GetCompactContacts_result where 
  arbitrary = M.liftM GetCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj}
    , if obj == default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj}
    ]
from_GetCompactContacts_result :: GetCompactContacts_result -> T.ThriftVal
from_GetCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9773 -> (1, ("e",from_TalkException _v9773))) <$> getCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9773 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v9775 -> from_CompactContact _v9775) $ Vector.toList _v9773))) $ getCompactContacts_result_success record
    , (\_v9773 -> (1, ("e",from_TalkException _v9773))) <$> getCompactContacts_result_e record
    ]
    )
write_GetCompactContacts_result :: T.Protocol p => p -> GetCompactContacts_result -> P.IO ()
write_GetCompactContacts_result oprot record = T.writeVal oprot $ from_GetCompactContacts_result record
encode_GetCompactContacts_result :: T.StatelessProtocol p => p -> GetCompactContacts_result -> LBS.ByteString
encode_GetCompactContacts_result oprot record = T.serializeVal oprot $ from_GetCompactContacts_result record
to_GetCompactContacts_result :: T.ThriftVal -> GetCompactContacts_result
to_GetCompactContacts_result (T.TStruct fields) = GetCompactContacts_result{
  getCompactContacts_result_success = P.maybe (getCompactContacts_result_success default_GetCompactContacts_result) (\(_,_val9777) -> (case _val9777 of {T.TList _ _val9778 -> (Vector.fromList $ P.map (\_v9779 -> (case _v9779 of {T.TStruct _val9780 -> (to_CompactContact (T.TStruct _val9780)); _ -> P.error "wrong type"})) _val9778); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val9777) -> P.Just (case _val9777 of {T.TStruct _val9781 -> (to_TalkException (T.TStruct _val9781)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContacts_result _ = P.error "not a struct"
read_GetCompactContacts_result :: T.Protocol p => p -> P.IO GetCompactContacts_result
read_GetCompactContacts_result iprot = to_GetCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_result)
decode_GetCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_result
decode_GetCompactContacts_result iprot bs = to_GetCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_result) bs
typemap_GetCompactContacts_result :: T.TypeMap
typemap_GetCompactContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContacts_result :: GetCompactContacts_result
default_GetCompactContacts_result = GetCompactContacts_result{
  getCompactContacts_result_success = Vector.empty,
  getCompactContacts_result_e = P.Nothing}
data NotifyNotiCenterEvent_args = NotifyNotiCenterEvent_args  { notifyNotiCenterEvent_args_event :: NotiCenterEventData
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyNotiCenterEvent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyNotiCenterEvent_args_event record  
instance QC.Arbitrary NotifyNotiCenterEvent_args where 
  arbitrary = M.liftM NotifyNotiCenterEvent_args (QC.arbitrary)
  shrink obj | obj == default_NotifyNotiCenterEvent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyNotiCenterEvent_args{notifyNotiCenterEvent_args_event = notifyNotiCenterEvent_args_event obj} then P.Nothing else P.Just $ default_NotifyNotiCenterEvent_args{notifyNotiCenterEvent_args_event = notifyNotiCenterEvent_args_event obj}
    ]
from_NotifyNotiCenterEvent_args :: NotifyNotiCenterEvent_args -> T.ThriftVal
from_NotifyNotiCenterEvent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9784 -> P.Just (1, ("event",from_NotiCenterEventData _v9784))) $ notifyNotiCenterEvent_args_event record
  ]
write_NotifyNotiCenterEvent_args :: T.Protocol p => p -> NotifyNotiCenterEvent_args -> P.IO ()
write_NotifyNotiCenterEvent_args oprot record = T.writeVal oprot $ from_NotifyNotiCenterEvent_args record
encode_NotifyNotiCenterEvent_args :: T.StatelessProtocol p => p -> NotifyNotiCenterEvent_args -> LBS.ByteString
encode_NotifyNotiCenterEvent_args oprot record = T.serializeVal oprot $ from_NotifyNotiCenterEvent_args record
to_NotifyNotiCenterEvent_args :: T.ThriftVal -> NotifyNotiCenterEvent_args
to_NotifyNotiCenterEvent_args (T.TStruct fields) = NotifyNotiCenterEvent_args{
  notifyNotiCenterEvent_args_event = P.maybe (notifyNotiCenterEvent_args_event default_NotifyNotiCenterEvent_args) (\(_,_val9786) -> (case _val9786 of {T.TStruct _val9787 -> (to_NotiCenterEventData (T.TStruct _val9787)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyNotiCenterEvent_args _ = P.error "not a struct"
read_NotifyNotiCenterEvent_args :: T.Protocol p => p -> P.IO NotifyNotiCenterEvent_args
read_NotifyNotiCenterEvent_args iprot = to_NotifyNotiCenterEvent_args <$> T.readVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_args)
decode_NotifyNotiCenterEvent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyNotiCenterEvent_args
decode_NotifyNotiCenterEvent_args iprot bs = to_NotifyNotiCenterEvent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_args) bs
typemap_NotifyNotiCenterEvent_args :: T.TypeMap
typemap_NotifyNotiCenterEvent_args = Map.fromList [(1,("event",(T.T_STRUCT typemap_NotiCenterEventData)))]
default_NotifyNotiCenterEvent_args :: NotifyNotiCenterEvent_args
default_NotifyNotiCenterEvent_args = NotifyNotiCenterEvent_args{
  notifyNotiCenterEvent_args_event = default_NotiCenterEventData}
data NotifyNotiCenterEvent_result = NotifyNotiCenterEvent_result  { notifyNotiCenterEvent_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotifyNotiCenterEvent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` notifyNotiCenterEvent_result_e record  
instance QC.Arbitrary NotifyNotiCenterEvent_result where 
  arbitrary = M.liftM NotifyNotiCenterEvent_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotifyNotiCenterEvent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = notifyNotiCenterEvent_result_e obj} then P.Nothing else P.Just $ default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = notifyNotiCenterEvent_result_e obj}
    ]
from_NotifyNotiCenterEvent_result :: NotifyNotiCenterEvent_result -> T.ThriftVal
from_NotifyNotiCenterEvent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9790 -> (1, ("e",from_TalkException _v9790))) <$> notifyNotiCenterEvent_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9790 -> (1, ("e",from_TalkException _v9790))) <$> notifyNotiCenterEvent_result_e record
    ]
    )
write_NotifyNotiCenterEvent_result :: T.Protocol p => p -> NotifyNotiCenterEvent_result -> P.IO ()
write_NotifyNotiCenterEvent_result oprot record = T.writeVal oprot $ from_NotifyNotiCenterEvent_result record
encode_NotifyNotiCenterEvent_result :: T.StatelessProtocol p => p -> NotifyNotiCenterEvent_result -> LBS.ByteString
encode_NotifyNotiCenterEvent_result oprot record = T.serializeVal oprot $ from_NotifyNotiCenterEvent_result record
to_NotifyNotiCenterEvent_result :: T.ThriftVal -> NotifyNotiCenterEvent_result
to_NotifyNotiCenterEvent_result (T.TStruct fields) = NotifyNotiCenterEvent_result{
  notifyNotiCenterEvent_result_e = P.maybe (P.Nothing) (\(_,_val9792) -> P.Just (case _val9792 of {T.TStruct _val9793 -> (to_TalkException (T.TStruct _val9793)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_NotifyNotiCenterEvent_result _ = P.error "not a struct"
read_NotifyNotiCenterEvent_result :: T.Protocol p => p -> P.IO NotifyNotiCenterEvent_result
read_NotifyNotiCenterEvent_result iprot = to_NotifyNotiCenterEvent_result <$> T.readVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_result)
decode_NotifyNotiCenterEvent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> NotifyNotiCenterEvent_result
decode_NotifyNotiCenterEvent_result iprot bs = to_NotifyNotiCenterEvent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_NotifyNotiCenterEvent_result) bs
typemap_NotifyNotiCenterEvent_result :: T.TypeMap
typemap_NotifyNotiCenterEvent_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_NotifyNotiCenterEvent_result :: NotifyNotiCenterEvent_result
default_NotifyNotiCenterEvent_result = NotifyNotiCenterEvent_result{
  notifyNotiCenterEvent_result_e = P.Nothing}
data IsInContact_args = IsInContact_args  { isInContact_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_args_mid record  
instance QC.Arbitrary IsInContact_args where 
  arbitrary = M.liftM IsInContact_args (QC.arbitrary)
  shrink obj | obj == default_IsInContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj} then P.Nothing else P.Just $ default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj}
    ]
from_IsInContact_args :: IsInContact_args -> T.ThriftVal
from_IsInContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9796 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v9796))) $ isInContact_args_mid record
  ]
write_IsInContact_args :: T.Protocol p => p -> IsInContact_args -> P.IO ()
write_IsInContact_args oprot record = T.writeVal oprot $ from_IsInContact_args record
encode_IsInContact_args :: T.StatelessProtocol p => p -> IsInContact_args -> LBS.ByteString
encode_IsInContact_args oprot record = T.serializeVal oprot $ from_IsInContact_args record
to_IsInContact_args :: T.ThriftVal -> IsInContact_args
to_IsInContact_args (T.TStruct fields) = IsInContact_args{
  isInContact_args_mid = P.maybe (isInContact_args_mid default_IsInContact_args) (\(_,_val9798) -> (case _val9798 of {T.TString _val9799 -> E.decodeUtf8 _val9799; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsInContact_args _ = P.error "not a struct"
read_IsInContact_args :: T.Protocol p => p -> P.IO IsInContact_args
read_IsInContact_args iprot = to_IsInContact_args <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_args)
decode_IsInContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_args
decode_IsInContact_args iprot bs = to_IsInContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_args) bs
typemap_IsInContact_args :: T.TypeMap
typemap_IsInContact_args = Map.fromList [(2,("mid",T.T_STRING))]
default_IsInContact_args :: IsInContact_args
default_IsInContact_args = IsInContact_args{
  isInContact_args_mid = ""}
data IsInContact_result = IsInContact_result  { isInContact_result_success :: P.Bool
  , isInContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_result_success record   `H.hashWithSalt` isInContact_result_e record  
instance QC.Arbitrary IsInContact_result where 
  arbitrary = M.liftM IsInContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsInContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_result{isInContact_result_success = isInContact_result_success obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_success = isInContact_result_success obj}
    , if obj == default_IsInContact_result{isInContact_result_e = isInContact_result_e obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_e = isInContact_result_e obj}
    ]
from_IsInContact_result :: IsInContact_result -> T.ThriftVal
from_IsInContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9802 -> (1, ("e",from_TalkException _v9802))) <$> isInContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9802 -> P.Just (0, ("success",T.TBool _v9802))) $ isInContact_result_success record
    , (\_v9802 -> (1, ("e",from_TalkException _v9802))) <$> isInContact_result_e record
    ]
    )
write_IsInContact_result :: T.Protocol p => p -> IsInContact_result -> P.IO ()
write_IsInContact_result oprot record = T.writeVal oprot $ from_IsInContact_result record
encode_IsInContact_result :: T.StatelessProtocol p => p -> IsInContact_result -> LBS.ByteString
encode_IsInContact_result oprot record = T.serializeVal oprot $ from_IsInContact_result record
to_IsInContact_result :: T.ThriftVal -> IsInContact_result
to_IsInContact_result (T.TStruct fields) = IsInContact_result{
  isInContact_result_success = P.maybe (isInContact_result_success default_IsInContact_result) (\(_,_val9804) -> (case _val9804 of {T.TBool _val9805 -> _val9805; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isInContact_result_e = P.maybe (P.Nothing) (\(_,_val9804) -> P.Just (case _val9804 of {T.TStruct _val9806 -> (to_TalkException (T.TStruct _val9806)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsInContact_result _ = P.error "not a struct"
read_IsInContact_result :: T.Protocol p => p -> P.IO IsInContact_result
read_IsInContact_result iprot = to_IsInContact_result <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_result)
decode_IsInContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_result
decode_IsInContact_result iprot bs = to_IsInContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_result) bs
typemap_IsInContact_result :: T.TypeMap
typemap_IsInContact_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsInContact_result :: IsInContact_result
default_IsInContact_result = IsInContact_result{
  isInContact_result_success = P.False,
  isInContact_result_e = P.Nothing}
data LookupGroupMembers_args = LookupGroupMembers_args  { lookupGroupMembers_args_groupId :: LT.Text
  , lookupGroupMembers_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupGroupMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupGroupMembers_args_groupId record   `H.hashWithSalt` lookupGroupMembers_args_mids record  
instance QC.Arbitrary LookupGroupMembers_args where 
  arbitrary = M.liftM LookupGroupMembers_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupGroupMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupGroupMembers_args{lookupGroupMembers_args_groupId = lookupGroupMembers_args_groupId obj} then P.Nothing else P.Just $ default_LookupGroupMembers_args{lookupGroupMembers_args_groupId = lookupGroupMembers_args_groupId obj}
    , if obj == default_LookupGroupMembers_args{lookupGroupMembers_args_mids = lookupGroupMembers_args_mids obj} then P.Nothing else P.Just $ default_LookupGroupMembers_args{lookupGroupMembers_args_mids = lookupGroupMembers_args_mids obj}
    ]
from_LookupGroupMembers_args :: LookupGroupMembers_args -> T.ThriftVal
from_LookupGroupMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9809 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v9809))) $ lookupGroupMembers_args_groupId record
  , (\_v9809 -> P.Just (2, ("mids",T.TList T.T_STRING $ P.map (\_v9811 -> T.TString $ E.encodeUtf8 _v9811) $ Vector.toList _v9809))) $ lookupGroupMembers_args_mids record
  ]
write_LookupGroupMembers_args :: T.Protocol p => p -> LookupGroupMembers_args -> P.IO ()
write_LookupGroupMembers_args oprot record = T.writeVal oprot $ from_LookupGroupMembers_args record
encode_LookupGroupMembers_args :: T.StatelessProtocol p => p -> LookupGroupMembers_args -> LBS.ByteString
encode_LookupGroupMembers_args oprot record = T.serializeVal oprot $ from_LookupGroupMembers_args record
to_LookupGroupMembers_args :: T.ThriftVal -> LookupGroupMembers_args
to_LookupGroupMembers_args (T.TStruct fields) = LookupGroupMembers_args{
  lookupGroupMembers_args_groupId = P.maybe (lookupGroupMembers_args_groupId default_LookupGroupMembers_args) (\(_,_val9813) -> (case _val9813 of {T.TString _val9814 -> E.decodeUtf8 _val9814; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lookupGroupMembers_args_mids = P.maybe (lookupGroupMembers_args_mids default_LookupGroupMembers_args) (\(_,_val9813) -> (case _val9813 of {T.TList _ _val9815 -> (Vector.fromList $ P.map (\_v9816 -> (case _v9816 of {T.TString _val9817 -> E.decodeUtf8 _val9817; _ -> P.error "wrong type"})) _val9815); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LookupGroupMembers_args _ = P.error "not a struct"
read_LookupGroupMembers_args :: T.Protocol p => p -> P.IO LookupGroupMembers_args
read_LookupGroupMembers_args iprot = to_LookupGroupMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupGroupMembers_args)
decode_LookupGroupMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupGroupMembers_args
decode_LookupGroupMembers_args iprot bs = to_LookupGroupMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupGroupMembers_args) bs
typemap_LookupGroupMembers_args :: T.TypeMap
typemap_LookupGroupMembers_args = Map.fromList [(1,("groupId",T.T_STRING)),(2,("mids",(T.T_LIST T.T_STRING)))]
default_LookupGroupMembers_args :: LookupGroupMembers_args
default_LookupGroupMembers_args = LookupGroupMembers_args{
  lookupGroupMembers_args_groupId = "",
  lookupGroupMembers_args_mids = Vector.empty}
data LookupGroupMembers_result = LookupGroupMembers_result  { lookupGroupMembers_result_success :: (Vector.Vector SimpleChannelContact)
  , lookupGroupMembers_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupGroupMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupGroupMembers_result_success record   `H.hashWithSalt` lookupGroupMembers_result_e record  
instance QC.Arbitrary LookupGroupMembers_result where 
  arbitrary = M.liftM LookupGroupMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupGroupMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupGroupMembers_result{lookupGroupMembers_result_success = lookupGroupMembers_result_success obj} then P.Nothing else P.Just $ default_LookupGroupMembers_result{lookupGroupMembers_result_success = lookupGroupMembers_result_success obj}
    , if obj == default_LookupGroupMembers_result{lookupGroupMembers_result_e = lookupGroupMembers_result_e obj} then P.Nothing else P.Just $ default_LookupGroupMembers_result{lookupGroupMembers_result_e = lookupGroupMembers_result_e obj}
    ]
from_LookupGroupMembers_result :: LookupGroupMembers_result -> T.ThriftVal
from_LookupGroupMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9820 -> (1, ("e",from_TalkException _v9820))) <$> lookupGroupMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9820 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v9822 -> from_SimpleChannelContact _v9822) $ Vector.toList _v9820))) $ lookupGroupMembers_result_success record
    , (\_v9820 -> (1, ("e",from_TalkException _v9820))) <$> lookupGroupMembers_result_e record
    ]
    )
write_LookupGroupMembers_result :: T.Protocol p => p -> LookupGroupMembers_result -> P.IO ()
write_LookupGroupMembers_result oprot record = T.writeVal oprot $ from_LookupGroupMembers_result record
encode_LookupGroupMembers_result :: T.StatelessProtocol p => p -> LookupGroupMembers_result -> LBS.ByteString
encode_LookupGroupMembers_result oprot record = T.serializeVal oprot $ from_LookupGroupMembers_result record
to_LookupGroupMembers_result :: T.ThriftVal -> LookupGroupMembers_result
to_LookupGroupMembers_result (T.TStruct fields) = LookupGroupMembers_result{
  lookupGroupMembers_result_success = P.maybe (lookupGroupMembers_result_success default_LookupGroupMembers_result) (\(_,_val9824) -> (case _val9824 of {T.TList _ _val9825 -> (Vector.fromList $ P.map (\_v9826 -> (case _v9826 of {T.TStruct _val9827 -> (to_SimpleChannelContact (T.TStruct _val9827)); _ -> P.error "wrong type"})) _val9825); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupGroupMembers_result_e = P.maybe (P.Nothing) (\(_,_val9824) -> P.Just (case _val9824 of {T.TStruct _val9828 -> (to_TalkException (T.TStruct _val9828)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupGroupMembers_result _ = P.error "not a struct"
read_LookupGroupMembers_result :: T.Protocol p => p -> P.IO LookupGroupMembers_result
read_LookupGroupMembers_result iprot = to_LookupGroupMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupGroupMembers_result)
decode_LookupGroupMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupGroupMembers_result
decode_LookupGroupMembers_result iprot bs = to_LookupGroupMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupGroupMembers_result) bs
typemap_LookupGroupMembers_result :: T.TypeMap
typemap_LookupGroupMembers_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupGroupMembers_result :: LookupGroupMembers_result
default_LookupGroupMembers_result = LookupGroupMembers_result{
  lookupGroupMembers_result_success = Vector.empty,
  lookupGroupMembers_result_e = P.Nothing}
data GetRoomInformation_args = GetRoomInformation_args  { getRoomInformation_args_roomMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomInformation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomInformation_args_roomMid record  
instance QC.Arbitrary GetRoomInformation_args where 
  arbitrary = M.liftM GetRoomInformation_args (QC.arbitrary)
  shrink obj | obj == default_GetRoomInformation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomInformation_args{getRoomInformation_args_roomMid = getRoomInformation_args_roomMid obj} then P.Nothing else P.Just $ default_GetRoomInformation_args{getRoomInformation_args_roomMid = getRoomInformation_args_roomMid obj}
    ]
from_GetRoomInformation_args :: GetRoomInformation_args -> T.ThriftVal
from_GetRoomInformation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9831 -> P.Just (1, ("roomMid",T.TString $ E.encodeUtf8 _v9831))) $ getRoomInformation_args_roomMid record
  ]
write_GetRoomInformation_args :: T.Protocol p => p -> GetRoomInformation_args -> P.IO ()
write_GetRoomInformation_args oprot record = T.writeVal oprot $ from_GetRoomInformation_args record
encode_GetRoomInformation_args :: T.StatelessProtocol p => p -> GetRoomInformation_args -> LBS.ByteString
encode_GetRoomInformation_args oprot record = T.serializeVal oprot $ from_GetRoomInformation_args record
to_GetRoomInformation_args :: T.ThriftVal -> GetRoomInformation_args
to_GetRoomInformation_args (T.TStruct fields) = GetRoomInformation_args{
  getRoomInformation_args_roomMid = P.maybe (getRoomInformation_args_roomMid default_GetRoomInformation_args) (\(_,_val9833) -> (case _val9833 of {T.TString _val9834 -> E.decodeUtf8 _val9834; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomInformation_args _ = P.error "not a struct"
read_GetRoomInformation_args :: T.Protocol p => p -> P.IO GetRoomInformation_args
read_GetRoomInformation_args iprot = to_GetRoomInformation_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomInformation_args)
decode_GetRoomInformation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomInformation_args
decode_GetRoomInformation_args iprot bs = to_GetRoomInformation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomInformation_args) bs
typemap_GetRoomInformation_args :: T.TypeMap
typemap_GetRoomInformation_args = Map.fromList [(1,("roomMid",T.T_STRING))]
default_GetRoomInformation_args :: GetRoomInformation_args
default_GetRoomInformation_args = GetRoomInformation_args{
  getRoomInformation_args_roomMid = ""}
data GetRoomInformation_result = GetRoomInformation_result  { getRoomInformation_result_success :: Room
  , getRoomInformation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomInformation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomInformation_result_success record   `H.hashWithSalt` getRoomInformation_result_e record  
instance QC.Arbitrary GetRoomInformation_result where 
  arbitrary = M.liftM GetRoomInformation_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoomInformation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomInformation_result{getRoomInformation_result_success = getRoomInformation_result_success obj} then P.Nothing else P.Just $ default_GetRoomInformation_result{getRoomInformation_result_success = getRoomInformation_result_success obj}
    , if obj == default_GetRoomInformation_result{getRoomInformation_result_e = getRoomInformation_result_e obj} then P.Nothing else P.Just $ default_GetRoomInformation_result{getRoomInformation_result_e = getRoomInformation_result_e obj}
    ]
from_GetRoomInformation_result :: GetRoomInformation_result -> T.ThriftVal
from_GetRoomInformation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9837 -> (1, ("e",from_TalkException _v9837))) <$> getRoomInformation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9837 -> P.Just (0, ("success",from_Room _v9837))) $ getRoomInformation_result_success record
    , (\_v9837 -> (1, ("e",from_TalkException _v9837))) <$> getRoomInformation_result_e record
    ]
    )
write_GetRoomInformation_result :: T.Protocol p => p -> GetRoomInformation_result -> P.IO ()
write_GetRoomInformation_result oprot record = T.writeVal oprot $ from_GetRoomInformation_result record
encode_GetRoomInformation_result :: T.StatelessProtocol p => p -> GetRoomInformation_result -> LBS.ByteString
encode_GetRoomInformation_result oprot record = T.serializeVal oprot $ from_GetRoomInformation_result record
to_GetRoomInformation_result :: T.ThriftVal -> GetRoomInformation_result
to_GetRoomInformation_result (T.TStruct fields) = GetRoomInformation_result{
  getRoomInformation_result_success = P.maybe (getRoomInformation_result_success default_GetRoomInformation_result) (\(_,_val9839) -> (case _val9839 of {T.TStruct _val9840 -> (to_Room (T.TStruct _val9840)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoomInformation_result_e = P.maybe (P.Nothing) (\(_,_val9839) -> P.Just (case _val9839 of {T.TStruct _val9841 -> (to_TalkException (T.TStruct _val9841)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomInformation_result _ = P.error "not a struct"
read_GetRoomInformation_result :: T.Protocol p => p -> P.IO GetRoomInformation_result
read_GetRoomInformation_result iprot = to_GetRoomInformation_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomInformation_result)
decode_GetRoomInformation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomInformation_result
decode_GetRoomInformation_result iprot bs = to_GetRoomInformation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomInformation_result) bs
typemap_GetRoomInformation_result :: T.TypeMap
typemap_GetRoomInformation_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoomInformation_result :: GetRoomInformation_result
default_GetRoomInformation_result = GetRoomInformation_result{
  getRoomInformation_result_success = default_Room,
  getRoomInformation_result_e = P.Nothing}
data GetGroupCall_args = GetGroupCall_args  { getGroupCall_args_chatMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupCall_args_chatMid record  
instance QC.Arbitrary GetGroupCall_args where 
  arbitrary = M.liftM GetGroupCall_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupCall_args{getGroupCall_args_chatMid = getGroupCall_args_chatMid obj} then P.Nothing else P.Just $ default_GetGroupCall_args{getGroupCall_args_chatMid = getGroupCall_args_chatMid obj}
    ]
from_GetGroupCall_args :: GetGroupCall_args -> T.ThriftVal
from_GetGroupCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9844 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v9844))) $ getGroupCall_args_chatMid record
  ]
write_GetGroupCall_args :: T.Protocol p => p -> GetGroupCall_args -> P.IO ()
write_GetGroupCall_args oprot record = T.writeVal oprot $ from_GetGroupCall_args record
encode_GetGroupCall_args :: T.StatelessProtocol p => p -> GetGroupCall_args -> LBS.ByteString
encode_GetGroupCall_args oprot record = T.serializeVal oprot $ from_GetGroupCall_args record
to_GetGroupCall_args :: T.ThriftVal -> GetGroupCall_args
to_GetGroupCall_args (T.TStruct fields) = GetGroupCall_args{
  getGroupCall_args_chatMid = P.maybe (getGroupCall_args_chatMid default_GetGroupCall_args) (\(_,_val9846) -> (case _val9846 of {T.TString _val9847 -> E.decodeUtf8 _val9847; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetGroupCall_args _ = P.error "not a struct"
read_GetGroupCall_args :: T.Protocol p => p -> P.IO GetGroupCall_args
read_GetGroupCall_args iprot = to_GetGroupCall_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupCall_args)
decode_GetGroupCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupCall_args
decode_GetGroupCall_args iprot bs = to_GetGroupCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupCall_args) bs
typemap_GetGroupCall_args :: T.TypeMap
typemap_GetGroupCall_args = Map.fromList [(2,("chatMid",T.T_STRING))]
default_GetGroupCall_args :: GetGroupCall_args
default_GetGroupCall_args = GetGroupCall_args{
  getGroupCall_args_chatMid = ""}
data GetGroupCall_result = GetGroupCall_result  { getGroupCall_result_success :: GroupCall
  , getGroupCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupCall_result_success record   `H.hashWithSalt` getGroupCall_result_e record  
instance QC.Arbitrary GetGroupCall_result where 
  arbitrary = M.liftM GetGroupCall_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupCall_result{getGroupCall_result_success = getGroupCall_result_success obj} then P.Nothing else P.Just $ default_GetGroupCall_result{getGroupCall_result_success = getGroupCall_result_success obj}
    , if obj == default_GetGroupCall_result{getGroupCall_result_e = getGroupCall_result_e obj} then P.Nothing else P.Just $ default_GetGroupCall_result{getGroupCall_result_e = getGroupCall_result_e obj}
    ]
from_GetGroupCall_result :: GetGroupCall_result -> T.ThriftVal
from_GetGroupCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9850 -> (1, ("e",from_TalkException _v9850))) <$> getGroupCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9850 -> P.Just (0, ("success",from_GroupCall _v9850))) $ getGroupCall_result_success record
    , (\_v9850 -> (1, ("e",from_TalkException _v9850))) <$> getGroupCall_result_e record
    ]
    )
write_GetGroupCall_result :: T.Protocol p => p -> GetGroupCall_result -> P.IO ()
write_GetGroupCall_result oprot record = T.writeVal oprot $ from_GetGroupCall_result record
encode_GetGroupCall_result :: T.StatelessProtocol p => p -> GetGroupCall_result -> LBS.ByteString
encode_GetGroupCall_result oprot record = T.serializeVal oprot $ from_GetGroupCall_result record
to_GetGroupCall_result :: T.ThriftVal -> GetGroupCall_result
to_GetGroupCall_result (T.TStruct fields) = GetGroupCall_result{
  getGroupCall_result_success = P.maybe (getGroupCall_result_success default_GetGroupCall_result) (\(_,_val9852) -> (case _val9852 of {T.TStruct _val9853 -> (to_GroupCall (T.TStruct _val9853)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupCall_result_e = P.maybe (P.Nothing) (\(_,_val9852) -> P.Just (case _val9852 of {T.TStruct _val9854 -> (to_TalkException (T.TStruct _val9854)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupCall_result _ = P.error "not a struct"
read_GetGroupCall_result :: T.Protocol p => p -> P.IO GetGroupCall_result
read_GetGroupCall_result iprot = to_GetGroupCall_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupCall_result)
decode_GetGroupCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupCall_result
decode_GetGroupCall_result iprot bs = to_GetGroupCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupCall_result) bs
typemap_GetGroupCall_result :: T.TypeMap
typemap_GetGroupCall_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GroupCall))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupCall_result :: GetGroupCall_result
default_GetGroupCall_result = GetGroupCall_result{
  getGroupCall_result_success = default_GroupCall,
  getGroupCall_result_e = P.Nothing}
data IsAllowSecondaryDeviceLogin_args = IsAllowSecondaryDeviceLogin_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsAllowSecondaryDeviceLogin_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary IsAllowSecondaryDeviceLogin_args where 
  arbitrary = QC.elements [IsAllowSecondaryDeviceLogin_args]
from_IsAllowSecondaryDeviceLogin_args :: IsAllowSecondaryDeviceLogin_args -> T.ThriftVal
from_IsAllowSecondaryDeviceLogin_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_IsAllowSecondaryDeviceLogin_args :: T.Protocol p => p -> IsAllowSecondaryDeviceLogin_args -> P.IO ()
write_IsAllowSecondaryDeviceLogin_args oprot record = T.writeVal oprot $ from_IsAllowSecondaryDeviceLogin_args record
encode_IsAllowSecondaryDeviceLogin_args :: T.StatelessProtocol p => p -> IsAllowSecondaryDeviceLogin_args -> LBS.ByteString
encode_IsAllowSecondaryDeviceLogin_args oprot record = T.serializeVal oprot $ from_IsAllowSecondaryDeviceLogin_args record
to_IsAllowSecondaryDeviceLogin_args :: T.ThriftVal -> IsAllowSecondaryDeviceLogin_args
to_IsAllowSecondaryDeviceLogin_args (T.TStruct fields) = IsAllowSecondaryDeviceLogin_args{

  }
to_IsAllowSecondaryDeviceLogin_args _ = P.error "not a struct"
read_IsAllowSecondaryDeviceLogin_args :: T.Protocol p => p -> P.IO IsAllowSecondaryDeviceLogin_args
read_IsAllowSecondaryDeviceLogin_args iprot = to_IsAllowSecondaryDeviceLogin_args <$> T.readVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_args)
decode_IsAllowSecondaryDeviceLogin_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsAllowSecondaryDeviceLogin_args
decode_IsAllowSecondaryDeviceLogin_args iprot bs = to_IsAllowSecondaryDeviceLogin_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_args) bs
typemap_IsAllowSecondaryDeviceLogin_args :: T.TypeMap
typemap_IsAllowSecondaryDeviceLogin_args = Map.fromList []
default_IsAllowSecondaryDeviceLogin_args :: IsAllowSecondaryDeviceLogin_args
default_IsAllowSecondaryDeviceLogin_args = IsAllowSecondaryDeviceLogin_args{
}
data IsAllowSecondaryDeviceLogin_result = IsAllowSecondaryDeviceLogin_result  { isAllowSecondaryDeviceLogin_result_success :: P.Bool
  , isAllowSecondaryDeviceLogin_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsAllowSecondaryDeviceLogin_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isAllowSecondaryDeviceLogin_result_success record   `H.hashWithSalt` isAllowSecondaryDeviceLogin_result_e record  
instance QC.Arbitrary IsAllowSecondaryDeviceLogin_result where 
  arbitrary = M.liftM IsAllowSecondaryDeviceLogin_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsAllowSecondaryDeviceLogin_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = isAllowSecondaryDeviceLogin_result_success obj} then P.Nothing else P.Just $ default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = isAllowSecondaryDeviceLogin_result_success obj}
    , if obj == default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = isAllowSecondaryDeviceLogin_result_e obj} then P.Nothing else P.Just $ default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = isAllowSecondaryDeviceLogin_result_e obj}
    ]
from_IsAllowSecondaryDeviceLogin_result :: IsAllowSecondaryDeviceLogin_result -> T.ThriftVal
from_IsAllowSecondaryDeviceLogin_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9862 -> (1, ("e",from_TalkException _v9862))) <$> isAllowSecondaryDeviceLogin_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9862 -> P.Just (0, ("success",T.TBool _v9862))) $ isAllowSecondaryDeviceLogin_result_success record
    , (\_v9862 -> (1, ("e",from_TalkException _v9862))) <$> isAllowSecondaryDeviceLogin_result_e record
    ]
    )
write_IsAllowSecondaryDeviceLogin_result :: T.Protocol p => p -> IsAllowSecondaryDeviceLogin_result -> P.IO ()
write_IsAllowSecondaryDeviceLogin_result oprot record = T.writeVal oprot $ from_IsAllowSecondaryDeviceLogin_result record
encode_IsAllowSecondaryDeviceLogin_result :: T.StatelessProtocol p => p -> IsAllowSecondaryDeviceLogin_result -> LBS.ByteString
encode_IsAllowSecondaryDeviceLogin_result oprot record = T.serializeVal oprot $ from_IsAllowSecondaryDeviceLogin_result record
to_IsAllowSecondaryDeviceLogin_result :: T.ThriftVal -> IsAllowSecondaryDeviceLogin_result
to_IsAllowSecondaryDeviceLogin_result (T.TStruct fields) = IsAllowSecondaryDeviceLogin_result{
  isAllowSecondaryDeviceLogin_result_success = P.maybe (isAllowSecondaryDeviceLogin_result_success default_IsAllowSecondaryDeviceLogin_result) (\(_,_val9864) -> (case _val9864 of {T.TBool _val9865 -> _val9865; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isAllowSecondaryDeviceLogin_result_e = P.maybe (P.Nothing) (\(_,_val9864) -> P.Just (case _val9864 of {T.TStruct _val9866 -> (to_TalkException (T.TStruct _val9866)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsAllowSecondaryDeviceLogin_result _ = P.error "not a struct"
read_IsAllowSecondaryDeviceLogin_result :: T.Protocol p => p -> P.IO IsAllowSecondaryDeviceLogin_result
read_IsAllowSecondaryDeviceLogin_result iprot = to_IsAllowSecondaryDeviceLogin_result <$> T.readVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_result)
decode_IsAllowSecondaryDeviceLogin_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsAllowSecondaryDeviceLogin_result
decode_IsAllowSecondaryDeviceLogin_result iprot bs = to_IsAllowSecondaryDeviceLogin_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsAllowSecondaryDeviceLogin_result) bs
typemap_IsAllowSecondaryDeviceLogin_result :: T.TypeMap
typemap_IsAllowSecondaryDeviceLogin_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsAllowSecondaryDeviceLogin_result :: IsAllowSecondaryDeviceLogin_result
default_IsAllowSecondaryDeviceLogin_result = IsAllowSecondaryDeviceLogin_result{
  isAllowSecondaryDeviceLogin_result_success = P.False,
  isAllowSecondaryDeviceLogin_result_e = P.Nothing}
data GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPrimaryClientForChannel_args where 
  arbitrary = QC.elements [GetPrimaryClientForChannel_args]
from_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args -> T.ThriftVal
from_GetPrimaryClientForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPrimaryClientForChannel_args :: T.Protocol p => p -> GetPrimaryClientForChannel_args -> P.IO ()
write_GetPrimaryClientForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_args record
encode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_args -> LBS.ByteString
encode_GetPrimaryClientForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_args record
to_GetPrimaryClientForChannel_args :: T.ThriftVal -> GetPrimaryClientForChannel_args
to_GetPrimaryClientForChannel_args (T.TStruct fields) = GetPrimaryClientForChannel_args{

  }
to_GetPrimaryClientForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_args
read_GetPrimaryClientForChannel_args iprot = to_GetPrimaryClientForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args)
decode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_args
decode_GetPrimaryClientForChannel_args iprot bs = to_GetPrimaryClientForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args) bs
typemap_GetPrimaryClientForChannel_args :: T.TypeMap
typemap_GetPrimaryClientForChannel_args = Map.fromList []
default_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args
default_GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args{
}
data GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result  { getPrimaryClientForChannel_result_success :: SimpleChannelClient
  , getPrimaryClientForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientForChannel_result_success record   `H.hashWithSalt` getPrimaryClientForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj}
    , if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj}
    ]
from_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result -> T.ThriftVal
from_GetPrimaryClientForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9874 -> (1, ("e",from_TalkException _v9874))) <$> getPrimaryClientForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9874 -> P.Just (0, ("success",from_SimpleChannelClient _v9874))) $ getPrimaryClientForChannel_result_success record
    , (\_v9874 -> (1, ("e",from_TalkException _v9874))) <$> getPrimaryClientForChannel_result_e record
    ]
    )
write_GetPrimaryClientForChannel_result :: T.Protocol p => p -> GetPrimaryClientForChannel_result -> P.IO ()
write_GetPrimaryClientForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_result record
encode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_result -> LBS.ByteString
encode_GetPrimaryClientForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_result record
to_GetPrimaryClientForChannel_result :: T.ThriftVal -> GetPrimaryClientForChannel_result
to_GetPrimaryClientForChannel_result (T.TStruct fields) = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = P.maybe (getPrimaryClientForChannel_result_success default_GetPrimaryClientForChannel_result) (\(_,_val9876) -> (case _val9876 of {T.TStruct _val9877 -> (to_SimpleChannelClient (T.TStruct _val9877)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientForChannel_result_e = P.maybe (P.Nothing) (\(_,_val9876) -> P.Just (case _val9876 of {T.TStruct _val9878 -> (to_TalkException (T.TStruct _val9878)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_result
read_GetPrimaryClientForChannel_result iprot = to_GetPrimaryClientForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result)
decode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_result
decode_GetPrimaryClientForChannel_result iprot bs = to_GetPrimaryClientForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result) bs
typemap_GetPrimaryClientForChannel_result :: T.TypeMap
typemap_GetPrimaryClientForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SimpleChannelClient))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result
default_GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = default_SimpleChannelClient,
  getPrimaryClientForChannel_result_e = P.Nothing}
data CreateRoomWithBuddy_args = CreateRoomWithBuddy_args  { createRoomWithBuddy_args_reqSeq :: I.Int32
  , createRoomWithBuddy_args_buddyMid :: LT.Text
  , createRoomWithBuddy_args_contactIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomWithBuddy_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomWithBuddy_args_reqSeq record   `H.hashWithSalt` createRoomWithBuddy_args_buddyMid record   `H.hashWithSalt` createRoomWithBuddy_args_contactIds record  
instance QC.Arbitrary CreateRoomWithBuddy_args where 
  arbitrary = M.liftM CreateRoomWithBuddy_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateRoomWithBuddy_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_reqSeq = createRoomWithBuddy_args_reqSeq obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_reqSeq = createRoomWithBuddy_args_reqSeq obj}
    , if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_buddyMid = createRoomWithBuddy_args_buddyMid obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_buddyMid = createRoomWithBuddy_args_buddyMid obj}
    , if obj == default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_contactIds = createRoomWithBuddy_args_contactIds obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_args{createRoomWithBuddy_args_contactIds = createRoomWithBuddy_args_contactIds obj}
    ]
from_CreateRoomWithBuddy_args :: CreateRoomWithBuddy_args -> T.ThriftVal
from_CreateRoomWithBuddy_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9881 -> P.Just (1, ("reqSeq",T.TI32 _v9881))) $ createRoomWithBuddy_args_reqSeq record
  , (\_v9881 -> P.Just (2, ("buddyMid",T.TString $ E.encodeUtf8 _v9881))) $ createRoomWithBuddy_args_buddyMid record
  , (\_v9881 -> P.Just (3, ("contactIds",T.TList T.T_STRING $ P.map (\_v9883 -> T.TString $ E.encodeUtf8 _v9883) $ Vector.toList _v9881))) $ createRoomWithBuddy_args_contactIds record
  ]
write_CreateRoomWithBuddy_args :: T.Protocol p => p -> CreateRoomWithBuddy_args -> P.IO ()
write_CreateRoomWithBuddy_args oprot record = T.writeVal oprot $ from_CreateRoomWithBuddy_args record
encode_CreateRoomWithBuddy_args :: T.StatelessProtocol p => p -> CreateRoomWithBuddy_args -> LBS.ByteString
encode_CreateRoomWithBuddy_args oprot record = T.serializeVal oprot $ from_CreateRoomWithBuddy_args record
to_CreateRoomWithBuddy_args :: T.ThriftVal -> CreateRoomWithBuddy_args
to_CreateRoomWithBuddy_args (T.TStruct fields) = CreateRoomWithBuddy_args{
  createRoomWithBuddy_args_reqSeq = P.maybe (createRoomWithBuddy_args_reqSeq default_CreateRoomWithBuddy_args) (\(_,_val9885) -> (case _val9885 of {T.TI32 _val9886 -> _val9886; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createRoomWithBuddy_args_buddyMid = P.maybe (createRoomWithBuddy_args_buddyMid default_CreateRoomWithBuddy_args) (\(_,_val9885) -> (case _val9885 of {T.TString _val9887 -> E.decodeUtf8 _val9887; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createRoomWithBuddy_args_contactIds = P.maybe (createRoomWithBuddy_args_contactIds default_CreateRoomWithBuddy_args) (\(_,_val9885) -> (case _val9885 of {T.TList _ _val9888 -> (Vector.fromList $ P.map (\_v9889 -> (case _v9889 of {T.TString _val9890 -> E.decodeUtf8 _val9890; _ -> P.error "wrong type"})) _val9888); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateRoomWithBuddy_args _ = P.error "not a struct"
read_CreateRoomWithBuddy_args :: T.Protocol p => p -> P.IO CreateRoomWithBuddy_args
read_CreateRoomWithBuddy_args iprot = to_CreateRoomWithBuddy_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_args)
decode_CreateRoomWithBuddy_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomWithBuddy_args
decode_CreateRoomWithBuddy_args iprot bs = to_CreateRoomWithBuddy_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_args) bs
typemap_CreateRoomWithBuddy_args :: T.TypeMap
typemap_CreateRoomWithBuddy_args = Map.fromList [(1,("reqSeq",T.T_I32)),(2,("buddyMid",T.T_STRING)),(3,("contactIds",(T.T_LIST T.T_STRING)))]
default_CreateRoomWithBuddy_args :: CreateRoomWithBuddy_args
default_CreateRoomWithBuddy_args = CreateRoomWithBuddy_args{
  createRoomWithBuddy_args_reqSeq = 0,
  createRoomWithBuddy_args_buddyMid = "",
  createRoomWithBuddy_args_contactIds = Vector.empty}
data CreateRoomWithBuddy_result = CreateRoomWithBuddy_result  { createRoomWithBuddy_result_success :: Room
  , createRoomWithBuddy_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateRoomWithBuddy_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createRoomWithBuddy_result_success record   `H.hashWithSalt` createRoomWithBuddy_result_e record  
instance QC.Arbitrary CreateRoomWithBuddy_result where 
  arbitrary = M.liftM CreateRoomWithBuddy_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateRoomWithBuddy_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = createRoomWithBuddy_result_success obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = createRoomWithBuddy_result_success obj}
    , if obj == default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = createRoomWithBuddy_result_e obj} then P.Nothing else P.Just $ default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = createRoomWithBuddy_result_e obj}
    ]
from_CreateRoomWithBuddy_result :: CreateRoomWithBuddy_result -> T.ThriftVal
from_CreateRoomWithBuddy_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9893 -> (1, ("e",from_TalkException _v9893))) <$> createRoomWithBuddy_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9893 -> P.Just (0, ("success",from_Room _v9893))) $ createRoomWithBuddy_result_success record
    , (\_v9893 -> (1, ("e",from_TalkException _v9893))) <$> createRoomWithBuddy_result_e record
    ]
    )
write_CreateRoomWithBuddy_result :: T.Protocol p => p -> CreateRoomWithBuddy_result -> P.IO ()
write_CreateRoomWithBuddy_result oprot record = T.writeVal oprot $ from_CreateRoomWithBuddy_result record
encode_CreateRoomWithBuddy_result :: T.StatelessProtocol p => p -> CreateRoomWithBuddy_result -> LBS.ByteString
encode_CreateRoomWithBuddy_result oprot record = T.serializeVal oprot $ from_CreateRoomWithBuddy_result record
to_CreateRoomWithBuddy_result :: T.ThriftVal -> CreateRoomWithBuddy_result
to_CreateRoomWithBuddy_result (T.TStruct fields) = CreateRoomWithBuddy_result{
  createRoomWithBuddy_result_success = P.maybe (createRoomWithBuddy_result_success default_CreateRoomWithBuddy_result) (\(_,_val9895) -> (case _val9895 of {T.TStruct _val9896 -> (to_Room (T.TStruct _val9896)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createRoomWithBuddy_result_e = P.maybe (P.Nothing) (\(_,_val9895) -> P.Just (case _val9895 of {T.TStruct _val9897 -> (to_TalkException (T.TStruct _val9897)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_CreateRoomWithBuddy_result _ = P.error "not a struct"
read_CreateRoomWithBuddy_result :: T.Protocol p => p -> P.IO CreateRoomWithBuddy_result
read_CreateRoomWithBuddy_result iprot = to_CreateRoomWithBuddy_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_result)
decode_CreateRoomWithBuddy_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateRoomWithBuddy_result
decode_CreateRoomWithBuddy_result iprot bs = to_CreateRoomWithBuddy_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateRoomWithBuddy_result) bs
typemap_CreateRoomWithBuddy_result :: T.TypeMap
typemap_CreateRoomWithBuddy_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Room))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_CreateRoomWithBuddy_result :: CreateRoomWithBuddy_result
default_CreateRoomWithBuddy_result = CreateRoomWithBuddy_result{
  createRoomWithBuddy_result_success = default_Room,
  createRoomWithBuddy_result_e = P.Nothing}
data GetDisplayName_args = GetDisplayName_args  { getDisplayName_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_args_mid record  
instance QC.Arbitrary GetDisplayName_args where 
  arbitrary = M.liftM GetDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj} then P.Nothing else P.Just $ default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj}
    ]
from_GetDisplayName_args :: GetDisplayName_args -> T.ThriftVal
from_GetDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9900 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v9900))) $ getDisplayName_args_mid record
  ]
write_GetDisplayName_args :: T.Protocol p => p -> GetDisplayName_args -> P.IO ()
write_GetDisplayName_args oprot record = T.writeVal oprot $ from_GetDisplayName_args record
encode_GetDisplayName_args :: T.StatelessProtocol p => p -> GetDisplayName_args -> LBS.ByteString
encode_GetDisplayName_args oprot record = T.serializeVal oprot $ from_GetDisplayName_args record
to_GetDisplayName_args :: T.ThriftVal -> GetDisplayName_args
to_GetDisplayName_args (T.TStruct fields) = GetDisplayName_args{
  getDisplayName_args_mid = P.maybe (getDisplayName_args_mid default_GetDisplayName_args) (\(_,_val9902) -> (case _val9902 of {T.TString _val9903 -> E.decodeUtf8 _val9903; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDisplayName_args _ = P.error "not a struct"
read_GetDisplayName_args :: T.Protocol p => p -> P.IO GetDisplayName_args
read_GetDisplayName_args iprot = to_GetDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_args)
decode_GetDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_args
decode_GetDisplayName_args iprot bs = to_GetDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_args) bs
typemap_GetDisplayName_args :: T.TypeMap
typemap_GetDisplayName_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetDisplayName_args :: GetDisplayName_args
default_GetDisplayName_args = GetDisplayName_args{
  getDisplayName_args_mid = ""}
data GetDisplayName_result = GetDisplayName_result  { getDisplayName_result_success :: LT.Text
  , getDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_result_success record   `H.hashWithSalt` getDisplayName_result_e record  
instance QC.Arbitrary GetDisplayName_result where 
  arbitrary = M.liftM GetDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj}
    , if obj == default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj}
    ]
from_GetDisplayName_result :: GetDisplayName_result -> T.ThriftVal
from_GetDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9906 -> (1, ("e",from_TalkException _v9906))) <$> getDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9906 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v9906))) $ getDisplayName_result_success record
    , (\_v9906 -> (1, ("e",from_TalkException _v9906))) <$> getDisplayName_result_e record
    ]
    )
write_GetDisplayName_result :: T.Protocol p => p -> GetDisplayName_result -> P.IO ()
write_GetDisplayName_result oprot record = T.writeVal oprot $ from_GetDisplayName_result record
encode_GetDisplayName_result :: T.StatelessProtocol p => p -> GetDisplayName_result -> LBS.ByteString
encode_GetDisplayName_result oprot record = T.serializeVal oprot $ from_GetDisplayName_result record
to_GetDisplayName_result :: T.ThriftVal -> GetDisplayName_result
to_GetDisplayName_result (T.TStruct fields) = GetDisplayName_result{
  getDisplayName_result_success = P.maybe (getDisplayName_result_success default_GetDisplayName_result) (\(_,_val9908) -> (case _val9908 of {T.TString _val9909 -> E.decodeUtf8 _val9909; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val9908) -> P.Just (case _val9908 of {T.TStruct _val9910 -> (to_TalkException (T.TStruct _val9910)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDisplayName_result _ = P.error "not a struct"
read_GetDisplayName_result :: T.Protocol p => p -> P.IO GetDisplayName_result
read_GetDisplayName_result iprot = to_GetDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_result)
decode_GetDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_result
decode_GetDisplayName_result iprot bs = to_GetDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_result) bs
typemap_GetDisplayName_result :: T.TypeMap
typemap_GetDisplayName_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetDisplayName_result :: GetDisplayName_result
default_GetDisplayName_result = GetDisplayName_result{
  getDisplayName_result_success = "",
  getDisplayName_result_e = P.Nothing}
data GetPaidCallMetadata_args = GetPaidCallMetadata_args  { getPaidCallMetadata_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallMetadata_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallMetadata_args_language record  
instance QC.Arbitrary GetPaidCallMetadata_args where 
  arbitrary = M.liftM GetPaidCallMetadata_args (QC.arbitrary)
  shrink obj | obj == default_GetPaidCallMetadata_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallMetadata_args{getPaidCallMetadata_args_language = getPaidCallMetadata_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_args{getPaidCallMetadata_args_language = getPaidCallMetadata_args_language obj}
    ]
from_GetPaidCallMetadata_args :: GetPaidCallMetadata_args -> T.ThriftVal
from_GetPaidCallMetadata_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9913 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v9913))) $ getPaidCallMetadata_args_language record
  ]
write_GetPaidCallMetadata_args :: T.Protocol p => p -> GetPaidCallMetadata_args -> P.IO ()
write_GetPaidCallMetadata_args oprot record = T.writeVal oprot $ from_GetPaidCallMetadata_args record
encode_GetPaidCallMetadata_args :: T.StatelessProtocol p => p -> GetPaidCallMetadata_args -> LBS.ByteString
encode_GetPaidCallMetadata_args oprot record = T.serializeVal oprot $ from_GetPaidCallMetadata_args record
to_GetPaidCallMetadata_args :: T.ThriftVal -> GetPaidCallMetadata_args
to_GetPaidCallMetadata_args (T.TStruct fields) = GetPaidCallMetadata_args{
  getPaidCallMetadata_args_language = P.maybe (getPaidCallMetadata_args_language default_GetPaidCallMetadata_args) (\(_,_val9915) -> (case _val9915 of {T.TString _val9916 -> E.decodeUtf8 _val9916; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPaidCallMetadata_args _ = P.error "not a struct"
read_GetPaidCallMetadata_args :: T.Protocol p => p -> P.IO GetPaidCallMetadata_args
read_GetPaidCallMetadata_args iprot = to_GetPaidCallMetadata_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_args)
decode_GetPaidCallMetadata_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallMetadata_args
decode_GetPaidCallMetadata_args iprot bs = to_GetPaidCallMetadata_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_args) bs
typemap_GetPaidCallMetadata_args :: T.TypeMap
typemap_GetPaidCallMetadata_args = Map.fromList [(2,("language",T.T_STRING))]
default_GetPaidCallMetadata_args :: GetPaidCallMetadata_args
default_GetPaidCallMetadata_args = GetPaidCallMetadata_args{
  getPaidCallMetadata_args_language = ""}
data GetPaidCallMetadata_result = GetPaidCallMetadata_result  { getPaidCallMetadata_result_success :: PaidCallMetadataResult
  , getPaidCallMetadata_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallMetadata_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallMetadata_result_success record   `H.hashWithSalt` getPaidCallMetadata_result_e record  
instance QC.Arbitrary GetPaidCallMetadata_result where 
  arbitrary = M.liftM GetPaidCallMetadata_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallMetadata_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = getPaidCallMetadata_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = getPaidCallMetadata_result_success obj}
    , if obj == default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = getPaidCallMetadata_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = getPaidCallMetadata_result_e obj}
    ]
from_GetPaidCallMetadata_result :: GetPaidCallMetadata_result -> T.ThriftVal
from_GetPaidCallMetadata_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9919 -> (1, ("e",from_TalkException _v9919))) <$> getPaidCallMetadata_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9919 -> P.Just (0, ("success",from_PaidCallMetadataResult _v9919))) $ getPaidCallMetadata_result_success record
    , (\_v9919 -> (1, ("e",from_TalkException _v9919))) <$> getPaidCallMetadata_result_e record
    ]
    )
write_GetPaidCallMetadata_result :: T.Protocol p => p -> GetPaidCallMetadata_result -> P.IO ()
write_GetPaidCallMetadata_result oprot record = T.writeVal oprot $ from_GetPaidCallMetadata_result record
encode_GetPaidCallMetadata_result :: T.StatelessProtocol p => p -> GetPaidCallMetadata_result -> LBS.ByteString
encode_GetPaidCallMetadata_result oprot record = T.serializeVal oprot $ from_GetPaidCallMetadata_result record
to_GetPaidCallMetadata_result :: T.ThriftVal -> GetPaidCallMetadata_result
to_GetPaidCallMetadata_result (T.TStruct fields) = GetPaidCallMetadata_result{
  getPaidCallMetadata_result_success = P.maybe (getPaidCallMetadata_result_success default_GetPaidCallMetadata_result) (\(_,_val9921) -> (case _val9921 of {T.TStruct _val9922 -> (to_PaidCallMetadataResult (T.TStruct _val9922)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallMetadata_result_e = P.maybe (P.Nothing) (\(_,_val9921) -> P.Just (case _val9921 of {T.TStruct _val9923 -> (to_TalkException (T.TStruct _val9923)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallMetadata_result _ = P.error "not a struct"
read_GetPaidCallMetadata_result :: T.Protocol p => p -> P.IO GetPaidCallMetadata_result
read_GetPaidCallMetadata_result iprot = to_GetPaidCallMetadata_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_result)
decode_GetPaidCallMetadata_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallMetadata_result
decode_GetPaidCallMetadata_result iprot bs = to_GetPaidCallMetadata_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallMetadata_result) bs
typemap_GetPaidCallMetadata_result :: T.TypeMap
typemap_GetPaidCallMetadata_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallMetadataResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallMetadata_result :: GetPaidCallMetadata_result
default_GetPaidCallMetadata_result = GetPaidCallMetadata_result{
  getPaidCallMetadata_result_success = default_PaidCallMetadataResult,
  getPaidCallMetadata_result_e = P.Nothing}
data GetMid_args = GetMid_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMid_args where 
  arbitrary = QC.elements [GetMid_args]
from_GetMid_args :: GetMid_args -> T.ThriftVal
from_GetMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMid_args :: T.Protocol p => p -> GetMid_args -> P.IO ()
write_GetMid_args oprot record = T.writeVal oprot $ from_GetMid_args record
encode_GetMid_args :: T.StatelessProtocol p => p -> GetMid_args -> LBS.ByteString
encode_GetMid_args oprot record = T.serializeVal oprot $ from_GetMid_args record
to_GetMid_args :: T.ThriftVal -> GetMid_args
to_GetMid_args (T.TStruct fields) = GetMid_args{

  }
to_GetMid_args _ = P.error "not a struct"
read_GetMid_args :: T.Protocol p => p -> P.IO GetMid_args
read_GetMid_args iprot = to_GetMid_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_args)
decode_GetMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_args
decode_GetMid_args iprot bs = to_GetMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_args) bs
typemap_GetMid_args :: T.TypeMap
typemap_GetMid_args = Map.fromList []
default_GetMid_args :: GetMid_args
default_GetMid_args = GetMid_args{
}
data GetMid_result = GetMid_result  { getMid_result_success :: LT.Text
  , getMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMid_result_success record   `H.hashWithSalt` getMid_result_e record  
instance QC.Arbitrary GetMid_result where 
  arbitrary = M.liftM GetMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMid_result{getMid_result_success = getMid_result_success obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_success = getMid_result_success obj}
    , if obj == default_GetMid_result{getMid_result_e = getMid_result_e obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_e = getMid_result_e obj}
    ]
from_GetMid_result :: GetMid_result -> T.ThriftVal
from_GetMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9931 -> (1, ("e",from_TalkException _v9931))) <$> getMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9931 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v9931))) $ getMid_result_success record
    , (\_v9931 -> (1, ("e",from_TalkException _v9931))) <$> getMid_result_e record
    ]
    )
write_GetMid_result :: T.Protocol p => p -> GetMid_result -> P.IO ()
write_GetMid_result oprot record = T.writeVal oprot $ from_GetMid_result record
encode_GetMid_result :: T.StatelessProtocol p => p -> GetMid_result -> LBS.ByteString
encode_GetMid_result oprot record = T.serializeVal oprot $ from_GetMid_result record
to_GetMid_result :: T.ThriftVal -> GetMid_result
to_GetMid_result (T.TStruct fields) = GetMid_result{
  getMid_result_success = P.maybe (getMid_result_success default_GetMid_result) (\(_,_val9933) -> (case _val9933 of {T.TString _val9934 -> E.decodeUtf8 _val9934; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMid_result_e = P.maybe (P.Nothing) (\(_,_val9933) -> P.Just (case _val9933 of {T.TStruct _val9935 -> (to_TalkException (T.TStruct _val9935)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMid_result _ = P.error "not a struct"
read_GetMid_result :: T.Protocol p => p -> P.IO GetMid_result
read_GetMid_result iprot = to_GetMid_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_result)
decode_GetMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_result
decode_GetMid_result iprot bs = to_GetMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_result) bs
typemap_GetMid_result :: T.TypeMap
typemap_GetMid_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMid_result :: GetMid_result
default_GetMid_result = GetMid_result{
  getMid_result_success = "",
  getMid_result_e = P.Nothing}
data GetUserCountryForBilling_args = GetUserCountryForBilling_args  { getUserCountryForBilling_args_country :: LT.Text
  , getUserCountryForBilling_args_remoteIp :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_args_country record   `H.hashWithSalt` getUserCountryForBilling_args_remoteIp record  
instance QC.Arbitrary GetUserCountryForBilling_args where 
  arbitrary = M.liftM GetUserCountryForBilling_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj}
    , if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj}
    ]
from_GetUserCountryForBilling_args :: GetUserCountryForBilling_args -> T.ThriftVal
from_GetUserCountryForBilling_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9938 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v9938))) $ getUserCountryForBilling_args_country record
  , (\_v9938 -> P.Just (3, ("remoteIp",T.TString $ E.encodeUtf8 _v9938))) $ getUserCountryForBilling_args_remoteIp record
  ]
write_GetUserCountryForBilling_args :: T.Protocol p => p -> GetUserCountryForBilling_args -> P.IO ()
write_GetUserCountryForBilling_args oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_args record
encode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> GetUserCountryForBilling_args -> LBS.ByteString
encode_GetUserCountryForBilling_args oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_args record
to_GetUserCountryForBilling_args :: T.ThriftVal -> GetUserCountryForBilling_args
to_GetUserCountryForBilling_args (T.TStruct fields) = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = P.maybe (getUserCountryForBilling_args_country default_GetUserCountryForBilling_args) (\(_,_val9940) -> (case _val9940 of {T.TString _val9941 -> E.decodeUtf8 _val9941; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getUserCountryForBilling_args_remoteIp = P.maybe (getUserCountryForBilling_args_remoteIp default_GetUserCountryForBilling_args) (\(_,_val9940) -> (case _val9940 of {T.TString _val9942 -> E.decodeUtf8 _val9942; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetUserCountryForBilling_args _ = P.error "not a struct"
read_GetUserCountryForBilling_args :: T.Protocol p => p -> P.IO GetUserCountryForBilling_args
read_GetUserCountryForBilling_args iprot = to_GetUserCountryForBilling_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args)
decode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_args
decode_GetUserCountryForBilling_args iprot bs = to_GetUserCountryForBilling_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args) bs
typemap_GetUserCountryForBilling_args :: T.TypeMap
typemap_GetUserCountryForBilling_args = Map.fromList [(2,("country",T.T_STRING)),(3,("remoteIp",T.T_STRING))]
default_GetUserCountryForBilling_args :: GetUserCountryForBilling_args
default_GetUserCountryForBilling_args = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = "",
  getUserCountryForBilling_args_remoteIp = ""}
data GetUserCountryForBilling_result = GetUserCountryForBilling_result  { getUserCountryForBilling_result_success :: LT.Text
  , getUserCountryForBilling_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_result_success record   `H.hashWithSalt` getUserCountryForBilling_result_e record  
instance QC.Arbitrary GetUserCountryForBilling_result where 
  arbitrary = M.liftM GetUserCountryForBilling_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj}
    , if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj}
    ]
from_GetUserCountryForBilling_result :: GetUserCountryForBilling_result -> T.ThriftVal
from_GetUserCountryForBilling_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9945 -> (1, ("e",from_TalkException _v9945))) <$> getUserCountryForBilling_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9945 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v9945))) $ getUserCountryForBilling_result_success record
    , (\_v9945 -> (1, ("e",from_TalkException _v9945))) <$> getUserCountryForBilling_result_e record
    ]
    )
write_GetUserCountryForBilling_result :: T.Protocol p => p -> GetUserCountryForBilling_result -> P.IO ()
write_GetUserCountryForBilling_result oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_result record
encode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> GetUserCountryForBilling_result -> LBS.ByteString
encode_GetUserCountryForBilling_result oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_result record
to_GetUserCountryForBilling_result :: T.ThriftVal -> GetUserCountryForBilling_result
to_GetUserCountryForBilling_result (T.TStruct fields) = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = P.maybe (getUserCountryForBilling_result_success default_GetUserCountryForBilling_result) (\(_,_val9947) -> (case _val9947 of {T.TString _val9948 -> E.decodeUtf8 _val9948; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCountryForBilling_result_e = P.maybe (P.Nothing) (\(_,_val9947) -> P.Just (case _val9947 of {T.TStruct _val9949 -> (to_TalkException (T.TStruct _val9949)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCountryForBilling_result _ = P.error "not a struct"
read_GetUserCountryForBilling_result :: T.Protocol p => p -> P.IO GetUserCountryForBilling_result
read_GetUserCountryForBilling_result iprot = to_GetUserCountryForBilling_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result)
decode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_result
decode_GetUserCountryForBilling_result iprot bs = to_GetUserCountryForBilling_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result) bs
typemap_GetUserCountryForBilling_result :: T.TypeMap
typemap_GetUserCountryForBilling_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCountryForBilling_result :: GetUserCountryForBilling_result
default_GetUserCountryForBilling_result = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = "",
  getUserCountryForBilling_result_e = P.Nothing}
data GetFavoriteGroupIdsForChannel_args = GetFavoriteGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteGroupIdsForChannel_args]
from_GetFavoriteGroupIdsForChannel_args :: GetFavoriteGroupIdsForChannel_args -> T.ThriftVal
from_GetFavoriteGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteGroupIdsForChannel_args :: T.Protocol p => p -> GetFavoriteGroupIdsForChannel_args -> P.IO ()
write_GetFavoriteGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteGroupIdsForChannel_args record
encode_GetFavoriteGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteGroupIdsForChannel_args -> LBS.ByteString
encode_GetFavoriteGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteGroupIdsForChannel_args record
to_GetFavoriteGroupIdsForChannel_args :: T.ThriftVal -> GetFavoriteGroupIdsForChannel_args
to_GetFavoriteGroupIdsForChannel_args (T.TStruct fields) = GetFavoriteGroupIdsForChannel_args{

  }
to_GetFavoriteGroupIdsForChannel_args _ = P.error "not a struct"
read_GetFavoriteGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteGroupIdsForChannel_args
read_GetFavoriteGroupIdsForChannel_args iprot = to_GetFavoriteGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_args)
decode_GetFavoriteGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteGroupIdsForChannel_args
decode_GetFavoriteGroupIdsForChannel_args iprot bs = to_GetFavoriteGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_args) bs
typemap_GetFavoriteGroupIdsForChannel_args :: T.TypeMap
typemap_GetFavoriteGroupIdsForChannel_args = Map.fromList []
default_GetFavoriteGroupIdsForChannel_args :: GetFavoriteGroupIdsForChannel_args
default_GetFavoriteGroupIdsForChannel_args = GetFavoriteGroupIdsForChannel_args{
}
data GetFavoriteGroupIdsForChannel_result = GetFavoriteGroupIdsForChannel_result  { getFavoriteGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteGroupIdsForChannel_result_success record   `H.hashWithSalt` getFavoriteGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteGroupIdsForChannel_result where 
  arbitrary = M.liftM GetFavoriteGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = getFavoriteGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = getFavoriteGroupIdsForChannel_result_success obj}
    , if obj == default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = getFavoriteGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = getFavoriteGroupIdsForChannel_result_e obj}
    ]
from_GetFavoriteGroupIdsForChannel_result :: GetFavoriteGroupIdsForChannel_result -> T.ThriftVal
from_GetFavoriteGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9957 -> (1, ("e",from_TalkException _v9957))) <$> getFavoriteGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9957 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v9959 -> T.TString $ E.encodeUtf8 _v9959) $ Vector.toList _v9957))) $ getFavoriteGroupIdsForChannel_result_success record
    , (\_v9957 -> (1, ("e",from_TalkException _v9957))) <$> getFavoriteGroupIdsForChannel_result_e record
    ]
    )
write_GetFavoriteGroupIdsForChannel_result :: T.Protocol p => p -> GetFavoriteGroupIdsForChannel_result -> P.IO ()
write_GetFavoriteGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteGroupIdsForChannel_result record
encode_GetFavoriteGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteGroupIdsForChannel_result -> LBS.ByteString
encode_GetFavoriteGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteGroupIdsForChannel_result record
to_GetFavoriteGroupIdsForChannel_result :: T.ThriftVal -> GetFavoriteGroupIdsForChannel_result
to_GetFavoriteGroupIdsForChannel_result (T.TStruct fields) = GetFavoriteGroupIdsForChannel_result{
  getFavoriteGroupIdsForChannel_result_success = P.maybe (getFavoriteGroupIdsForChannel_result_success default_GetFavoriteGroupIdsForChannel_result) (\(_,_val9961) -> (case _val9961 of {T.TList _ _val9962 -> (Vector.fromList $ P.map (\_v9963 -> (case _v9963 of {T.TString _val9964 -> E.decodeUtf8 _val9964; _ -> P.error "wrong type"})) _val9962); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val9961) -> P.Just (case _val9961 of {T.TStruct _val9965 -> (to_TalkException (T.TStruct _val9965)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteGroupIdsForChannel_result _ = P.error "not a struct"
read_GetFavoriteGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteGroupIdsForChannel_result
read_GetFavoriteGroupIdsForChannel_result iprot = to_GetFavoriteGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_result)
decode_GetFavoriteGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteGroupIdsForChannel_result
decode_GetFavoriteGroupIdsForChannel_result iprot bs = to_GetFavoriteGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteGroupIdsForChannel_result) bs
typemap_GetFavoriteGroupIdsForChannel_result :: T.TypeMap
typemap_GetFavoriteGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteGroupIdsForChannel_result :: GetFavoriteGroupIdsForChannel_result
default_GetFavoriteGroupIdsForChannel_result = GetFavoriteGroupIdsForChannel_result{
  getFavoriteGroupIdsForChannel_result_success = Vector.empty,
  getFavoriteGroupIdsForChannel_result_e = P.Nothing}
data GetPaidCallHistory_args = GetPaidCallHistory_args  { getPaidCallHistory_args_start :: I.Int64
  , getPaidCallHistory_args_size :: I.Int32
  , getPaidCallHistory_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallHistory_args_start record   `H.hashWithSalt` getPaidCallHistory_args_size record   `H.hashWithSalt` getPaidCallHistory_args_language record  
instance QC.Arbitrary GetPaidCallHistory_args where 
  arbitrary = M.liftM GetPaidCallHistory_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPaidCallHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_start = getPaidCallHistory_args_start obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_start = getPaidCallHistory_args_start obj}
    , if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_size = getPaidCallHistory_args_size obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_size = getPaidCallHistory_args_size obj}
    , if obj == default_GetPaidCallHistory_args{getPaidCallHistory_args_language = getPaidCallHistory_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_args{getPaidCallHistory_args_language = getPaidCallHistory_args_language obj}
    ]
from_GetPaidCallHistory_args :: GetPaidCallHistory_args -> T.ThriftVal
from_GetPaidCallHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9968 -> P.Just (2, ("start",T.TI64 _v9968))) $ getPaidCallHistory_args_start record
  , (\_v9968 -> P.Just (3, ("size",T.TI32 _v9968))) $ getPaidCallHistory_args_size record
  , (\_v9968 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v9968))) $ getPaidCallHistory_args_language record
  ]
write_GetPaidCallHistory_args :: T.Protocol p => p -> GetPaidCallHistory_args -> P.IO ()
write_GetPaidCallHistory_args oprot record = T.writeVal oprot $ from_GetPaidCallHistory_args record
encode_GetPaidCallHistory_args :: T.StatelessProtocol p => p -> GetPaidCallHistory_args -> LBS.ByteString
encode_GetPaidCallHistory_args oprot record = T.serializeVal oprot $ from_GetPaidCallHistory_args record
to_GetPaidCallHistory_args :: T.ThriftVal -> GetPaidCallHistory_args
to_GetPaidCallHistory_args (T.TStruct fields) = GetPaidCallHistory_args{
  getPaidCallHistory_args_start = P.maybe (getPaidCallHistory_args_start default_GetPaidCallHistory_args) (\(_,_val9970) -> (case _val9970 of {T.TI64 _val9971 -> _val9971; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPaidCallHistory_args_size = P.maybe (getPaidCallHistory_args_size default_GetPaidCallHistory_args) (\(_,_val9970) -> (case _val9970 of {T.TI32 _val9972 -> _val9972; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getPaidCallHistory_args_language = P.maybe (getPaidCallHistory_args_language default_GetPaidCallHistory_args) (\(_,_val9970) -> (case _val9970 of {T.TString _val9973 -> E.decodeUtf8 _val9973; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetPaidCallHistory_args _ = P.error "not a struct"
read_GetPaidCallHistory_args :: T.Protocol p => p -> P.IO GetPaidCallHistory_args
read_GetPaidCallHistory_args iprot = to_GetPaidCallHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_args)
decode_GetPaidCallHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallHistory_args
decode_GetPaidCallHistory_args iprot bs = to_GetPaidCallHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_args) bs
typemap_GetPaidCallHistory_args :: T.TypeMap
typemap_GetPaidCallHistory_args = Map.fromList [(2,("start",T.T_I64)),(3,("size",T.T_I32)),(4,("language",T.T_STRING))]
default_GetPaidCallHistory_args :: GetPaidCallHistory_args
default_GetPaidCallHistory_args = GetPaidCallHistory_args{
  getPaidCallHistory_args_start = 0,
  getPaidCallHistory_args_size = 0,
  getPaidCallHistory_args_language = ""}
data GetPaidCallHistory_result = GetPaidCallHistory_result  { getPaidCallHistory_result_success :: PaidCallHistoryResult
  , getPaidCallHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallHistory_result_success record   `H.hashWithSalt` getPaidCallHistory_result_e record  
instance QC.Arbitrary GetPaidCallHistory_result where 
  arbitrary = M.liftM GetPaidCallHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallHistory_result{getPaidCallHistory_result_success = getPaidCallHistory_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_result{getPaidCallHistory_result_success = getPaidCallHistory_result_success obj}
    , if obj == default_GetPaidCallHistory_result{getPaidCallHistory_result_e = getPaidCallHistory_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallHistory_result{getPaidCallHistory_result_e = getPaidCallHistory_result_e obj}
    ]
from_GetPaidCallHistory_result :: GetPaidCallHistory_result -> T.ThriftVal
from_GetPaidCallHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9976 -> (1, ("e",from_TalkException _v9976))) <$> getPaidCallHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9976 -> P.Just (0, ("success",from_PaidCallHistoryResult _v9976))) $ getPaidCallHistory_result_success record
    , (\_v9976 -> (1, ("e",from_TalkException _v9976))) <$> getPaidCallHistory_result_e record
    ]
    )
write_GetPaidCallHistory_result :: T.Protocol p => p -> GetPaidCallHistory_result -> P.IO ()
write_GetPaidCallHistory_result oprot record = T.writeVal oprot $ from_GetPaidCallHistory_result record
encode_GetPaidCallHistory_result :: T.StatelessProtocol p => p -> GetPaidCallHistory_result -> LBS.ByteString
encode_GetPaidCallHistory_result oprot record = T.serializeVal oprot $ from_GetPaidCallHistory_result record
to_GetPaidCallHistory_result :: T.ThriftVal -> GetPaidCallHistory_result
to_GetPaidCallHistory_result (T.TStruct fields) = GetPaidCallHistory_result{
  getPaidCallHistory_result_success = P.maybe (getPaidCallHistory_result_success default_GetPaidCallHistory_result) (\(_,_val9978) -> (case _val9978 of {T.TStruct _val9979 -> (to_PaidCallHistoryResult (T.TStruct _val9979)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallHistory_result_e = P.maybe (P.Nothing) (\(_,_val9978) -> P.Just (case _val9978 of {T.TStruct _val9980 -> (to_TalkException (T.TStruct _val9980)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallHistory_result _ = P.error "not a struct"
read_GetPaidCallHistory_result :: T.Protocol p => p -> P.IO GetPaidCallHistory_result
read_GetPaidCallHistory_result iprot = to_GetPaidCallHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_result)
decode_GetPaidCallHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallHistory_result
decode_GetPaidCallHistory_result iprot bs = to_GetPaidCallHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallHistory_result) bs
typemap_GetPaidCallHistory_result :: T.TypeMap
typemap_GetPaidCallHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallHistory_result :: GetPaidCallHistory_result
default_GetPaidCallHistory_result = GetPaidCallHistory_result{
  getPaidCallHistory_result_success = default_PaidCallHistoryResult,
  getPaidCallHistory_result_e = P.Nothing}
data SendPinCodeOperation_args = SendPinCodeOperation_args  { sendPinCodeOperation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_args_verifier record  
instance QC.Arbitrary SendPinCodeOperation_args where 
  arbitrary = M.liftM SendPinCodeOperation_args (QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj}
    ]
from_SendPinCodeOperation_args :: SendPinCodeOperation_args -> T.ThriftVal
from_SendPinCodeOperation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9983 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v9983))) $ sendPinCodeOperation_args_verifier record
  ]
write_SendPinCodeOperation_args :: T.Protocol p => p -> SendPinCodeOperation_args -> P.IO ()
write_SendPinCodeOperation_args oprot record = T.writeVal oprot $ from_SendPinCodeOperation_args record
encode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> SendPinCodeOperation_args -> LBS.ByteString
encode_SendPinCodeOperation_args oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_args record
to_SendPinCodeOperation_args :: T.ThriftVal -> SendPinCodeOperation_args
to_SendPinCodeOperation_args (T.TStruct fields) = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = P.maybe (sendPinCodeOperation_args_verifier default_SendPinCodeOperation_args) (\(_,_val9985) -> (case _val9985 of {T.TString _val9986 -> E.decodeUtf8 _val9986; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_args _ = P.error "not a struct"
read_SendPinCodeOperation_args :: T.Protocol p => p -> P.IO SendPinCodeOperation_args
read_SendPinCodeOperation_args iprot = to_SendPinCodeOperation_args <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args)
decode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_args
decode_SendPinCodeOperation_args iprot bs = to_SendPinCodeOperation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args) bs
typemap_SendPinCodeOperation_args :: T.TypeMap
typemap_SendPinCodeOperation_args = Map.fromList [(1,("verifier",T.T_STRING))]
default_SendPinCodeOperation_args :: SendPinCodeOperation_args
default_SendPinCodeOperation_args = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = ""}
data SendPinCodeOperation_result = SendPinCodeOperation_result  { sendPinCodeOperation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_result_e record  
instance QC.Arbitrary SendPinCodeOperation_result where 
  arbitrary = M.liftM SendPinCodeOperation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj}
    ]
from_SendPinCodeOperation_result :: SendPinCodeOperation_result -> T.ThriftVal
from_SendPinCodeOperation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v9989 -> (1, ("e",from_TalkException _v9989))) <$> sendPinCodeOperation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v9989 -> (1, ("e",from_TalkException _v9989))) <$> sendPinCodeOperation_result_e record
    ]
    )
write_SendPinCodeOperation_result :: T.Protocol p => p -> SendPinCodeOperation_result -> P.IO ()
write_SendPinCodeOperation_result oprot record = T.writeVal oprot $ from_SendPinCodeOperation_result record
encode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> SendPinCodeOperation_result -> LBS.ByteString
encode_SendPinCodeOperation_result oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_result record
to_SendPinCodeOperation_result :: T.ThriftVal -> SendPinCodeOperation_result
to_SendPinCodeOperation_result (T.TStruct fields) = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.maybe (P.Nothing) (\(_,_val9991) -> P.Just (case _val9991 of {T.TStruct _val9992 -> (to_TalkException (T.TStruct _val9992)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_result _ = P.error "not a struct"
read_SendPinCodeOperation_result :: T.Protocol p => p -> P.IO SendPinCodeOperation_result
read_SendPinCodeOperation_result iprot = to_SendPinCodeOperation_result <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result)
decode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_result
decode_SendPinCodeOperation_result iprot bs = to_SendPinCodeOperation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result) bs
typemap_SendPinCodeOperation_result :: T.TypeMap
typemap_SendPinCodeOperation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendPinCodeOperation_result :: SendPinCodeOperation_result
default_SendPinCodeOperation_result = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.Nothing}
data InviteIntoGroupCall_args = InviteIntoGroupCall_args  { inviteIntoGroupCall_args_chatMid :: LT.Text
  , inviteIntoGroupCall_args_memberMids :: (Vector.Vector LT.Text)
  , inviteIntoGroupCall_args_mediaType :: GroupCallMediaType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroupCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroupCall_args_chatMid record   `H.hashWithSalt` inviteIntoGroupCall_args_memberMids record   `H.hashWithSalt` inviteIntoGroupCall_args_mediaType record  
instance QC.Arbitrary InviteIntoGroupCall_args where 
  arbitrary = M.liftM InviteIntoGroupCall_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroupCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_chatMid = inviteIntoGroupCall_args_chatMid obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_chatMid = inviteIntoGroupCall_args_chatMid obj}
    , if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_memberMids = inviteIntoGroupCall_args_memberMids obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_memberMids = inviteIntoGroupCall_args_memberMids obj}
    , if obj == default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_mediaType = inviteIntoGroupCall_args_mediaType obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_args{inviteIntoGroupCall_args_mediaType = inviteIntoGroupCall_args_mediaType obj}
    ]
from_InviteIntoGroupCall_args :: InviteIntoGroupCall_args -> T.ThriftVal
from_InviteIntoGroupCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v9995 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v9995))) $ inviteIntoGroupCall_args_chatMid record
  , (\_v9995 -> P.Just (3, ("memberMids",T.TList T.T_STRING $ P.map (\_v9997 -> T.TString $ E.encodeUtf8 _v9997) $ Vector.toList _v9995))) $ inviteIntoGroupCall_args_memberMids record
  , (\_v9995 -> P.Just (4, ("mediaType",T.TI32 $ P.fromIntegral $ P.fromEnum _v9995))) $ inviteIntoGroupCall_args_mediaType record
  ]
write_InviteIntoGroupCall_args :: T.Protocol p => p -> InviteIntoGroupCall_args -> P.IO ()
write_InviteIntoGroupCall_args oprot record = T.writeVal oprot $ from_InviteIntoGroupCall_args record
encode_InviteIntoGroupCall_args :: T.StatelessProtocol p => p -> InviteIntoGroupCall_args -> LBS.ByteString
encode_InviteIntoGroupCall_args oprot record = T.serializeVal oprot $ from_InviteIntoGroupCall_args record
to_InviteIntoGroupCall_args :: T.ThriftVal -> InviteIntoGroupCall_args
to_InviteIntoGroupCall_args (T.TStruct fields) = InviteIntoGroupCall_args{
  inviteIntoGroupCall_args_chatMid = P.maybe (inviteIntoGroupCall_args_chatMid default_InviteIntoGroupCall_args) (\(_,_val9999) -> (case _val9999 of {T.TString _val10000 -> E.decodeUtf8 _val10000; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  inviteIntoGroupCall_args_memberMids = P.maybe (inviteIntoGroupCall_args_memberMids default_InviteIntoGroupCall_args) (\(_,_val9999) -> (case _val9999 of {T.TList _ _val10001 -> (Vector.fromList $ P.map (\_v10002 -> (case _v10002 of {T.TString _val10003 -> E.decodeUtf8 _val10003; _ -> P.error "wrong type"})) _val10001); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  inviteIntoGroupCall_args_mediaType = P.maybe (inviteIntoGroupCall_args_mediaType default_InviteIntoGroupCall_args) (\(_,_val9999) -> (case _val9999 of {T.TI32 _val10004 -> P.toEnum $ P.fromIntegral _val10004; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_InviteIntoGroupCall_args _ = P.error "not a struct"
read_InviteIntoGroupCall_args :: T.Protocol p => p -> P.IO InviteIntoGroupCall_args
read_InviteIntoGroupCall_args iprot = to_InviteIntoGroupCall_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_args)
decode_InviteIntoGroupCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroupCall_args
decode_InviteIntoGroupCall_args iprot bs = to_InviteIntoGroupCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_args) bs
typemap_InviteIntoGroupCall_args :: T.TypeMap
typemap_InviteIntoGroupCall_args = Map.fromList [(2,("chatMid",T.T_STRING)),(3,("memberMids",(T.T_LIST T.T_STRING))),(4,("mediaType",T.T_I32))]
default_InviteIntoGroupCall_args :: InviteIntoGroupCall_args
default_InviteIntoGroupCall_args = InviteIntoGroupCall_args{
  inviteIntoGroupCall_args_chatMid = "",
  inviteIntoGroupCall_args_memberMids = Vector.empty,
  inviteIntoGroupCall_args_mediaType = (P.toEnum 0)}
data InviteIntoGroupCall_result = InviteIntoGroupCall_result  { inviteIntoGroupCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteIntoGroupCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteIntoGroupCall_result_e record  
instance QC.Arbitrary InviteIntoGroupCall_result where 
  arbitrary = M.liftM InviteIntoGroupCall_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteIntoGroupCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = inviteIntoGroupCall_result_e obj} then P.Nothing else P.Just $ default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = inviteIntoGroupCall_result_e obj}
    ]
from_InviteIntoGroupCall_result :: InviteIntoGroupCall_result -> T.ThriftVal
from_InviteIntoGroupCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10007 -> (1, ("e",from_TalkException _v10007))) <$> inviteIntoGroupCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10007 -> (1, ("e",from_TalkException _v10007))) <$> inviteIntoGroupCall_result_e record
    ]
    )
write_InviteIntoGroupCall_result :: T.Protocol p => p -> InviteIntoGroupCall_result -> P.IO ()
write_InviteIntoGroupCall_result oprot record = T.writeVal oprot $ from_InviteIntoGroupCall_result record
encode_InviteIntoGroupCall_result :: T.StatelessProtocol p => p -> InviteIntoGroupCall_result -> LBS.ByteString
encode_InviteIntoGroupCall_result oprot record = T.serializeVal oprot $ from_InviteIntoGroupCall_result record
to_InviteIntoGroupCall_result :: T.ThriftVal -> InviteIntoGroupCall_result
to_InviteIntoGroupCall_result (T.TStruct fields) = InviteIntoGroupCall_result{
  inviteIntoGroupCall_result_e = P.maybe (P.Nothing) (\(_,_val10009) -> P.Just (case _val10009 of {T.TStruct _val10010 -> (to_TalkException (T.TStruct _val10010)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_InviteIntoGroupCall_result _ = P.error "not a struct"
read_InviteIntoGroupCall_result :: T.Protocol p => p -> P.IO InviteIntoGroupCall_result
read_InviteIntoGroupCall_result iprot = to_InviteIntoGroupCall_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_result)
decode_InviteIntoGroupCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteIntoGroupCall_result
decode_InviteIntoGroupCall_result iprot bs = to_InviteIntoGroupCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteIntoGroupCall_result) bs
typemap_InviteIntoGroupCall_result :: T.TypeMap
typemap_InviteIntoGroupCall_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_InviteIntoGroupCall_result :: InviteIntoGroupCall_result
default_InviteIntoGroupCall_result = InviteIntoGroupCall_result{
  inviteIntoGroupCall_result_e = P.Nothing}
data GetFriendMids_args = GetFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFriendMids_args where 
  arbitrary = QC.elements [GetFriendMids_args]
from_GetFriendMids_args :: GetFriendMids_args -> T.ThriftVal
from_GetFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFriendMids_args :: T.Protocol p => p -> GetFriendMids_args -> P.IO ()
write_GetFriendMids_args oprot record = T.writeVal oprot $ from_GetFriendMids_args record
encode_GetFriendMids_args :: T.StatelessProtocol p => p -> GetFriendMids_args -> LBS.ByteString
encode_GetFriendMids_args oprot record = T.serializeVal oprot $ from_GetFriendMids_args record
to_GetFriendMids_args :: T.ThriftVal -> GetFriendMids_args
to_GetFriendMids_args (T.TStruct fields) = GetFriendMids_args{

  }
to_GetFriendMids_args _ = P.error "not a struct"
read_GetFriendMids_args :: T.Protocol p => p -> P.IO GetFriendMids_args
read_GetFriendMids_args iprot = to_GetFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_args)
decode_GetFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_args
decode_GetFriendMids_args iprot bs = to_GetFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_args) bs
typemap_GetFriendMids_args :: T.TypeMap
typemap_GetFriendMids_args = Map.fromList []
default_GetFriendMids_args :: GetFriendMids_args
default_GetFriendMids_args = GetFriendMids_args{
}
data GetFriendMids_result = GetFriendMids_result  { getFriendMids_result_success :: (Vector.Vector LT.Text)
  , getFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendMids_result_success record   `H.hashWithSalt` getFriendMids_result_e record  
instance QC.Arbitrary GetFriendMids_result where 
  arbitrary = M.liftM GetFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj}
    , if obj == default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj}
    ]
from_GetFriendMids_result :: GetFriendMids_result -> T.ThriftVal
from_GetFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10018 -> (1, ("e",from_TalkException _v10018))) <$> getFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10018 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10020 -> T.TString $ E.encodeUtf8 _v10020) $ Vector.toList _v10018))) $ getFriendMids_result_success record
    , (\_v10018 -> (1, ("e",from_TalkException _v10018))) <$> getFriendMids_result_e record
    ]
    )
write_GetFriendMids_result :: T.Protocol p => p -> GetFriendMids_result -> P.IO ()
write_GetFriendMids_result oprot record = T.writeVal oprot $ from_GetFriendMids_result record
encode_GetFriendMids_result :: T.StatelessProtocol p => p -> GetFriendMids_result -> LBS.ByteString
encode_GetFriendMids_result oprot record = T.serializeVal oprot $ from_GetFriendMids_result record
to_GetFriendMids_result :: T.ThriftVal -> GetFriendMids_result
to_GetFriendMids_result (T.TStruct fields) = GetFriendMids_result{
  getFriendMids_result_success = P.maybe (getFriendMids_result_success default_GetFriendMids_result) (\(_,_val10022) -> (case _val10022 of {T.TList _ _val10023 -> (Vector.fromList $ P.map (\_v10024 -> (case _v10024 of {T.TString _val10025 -> E.decodeUtf8 _val10025; _ -> P.error "wrong type"})) _val10023); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val10022) -> P.Just (case _val10022 of {T.TStruct _val10026 -> (to_TalkException (T.TStruct _val10026)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendMids_result _ = P.error "not a struct"
read_GetFriendMids_result :: T.Protocol p => p -> P.IO GetFriendMids_result
read_GetFriendMids_result iprot = to_GetFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_result)
decode_GetFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_result
decode_GetFriendMids_result iprot bs = to_GetFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_result) bs
typemap_GetFriendMids_result :: T.TypeMap
typemap_GetFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFriendMids_result :: GetFriendMids_result
default_GetFriendMids_result = GetFriendMids_result{
  getFriendMids_result_success = Vector.empty,
  getFriendMids_result_e = P.Nothing}
data GetMetaProfile_args = GetMetaProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMetaProfile_args where 
  arbitrary = QC.elements [GetMetaProfile_args]
from_GetMetaProfile_args :: GetMetaProfile_args -> T.ThriftVal
from_GetMetaProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMetaProfile_args :: T.Protocol p => p -> GetMetaProfile_args -> P.IO ()
write_GetMetaProfile_args oprot record = T.writeVal oprot $ from_GetMetaProfile_args record
encode_GetMetaProfile_args :: T.StatelessProtocol p => p -> GetMetaProfile_args -> LBS.ByteString
encode_GetMetaProfile_args oprot record = T.serializeVal oprot $ from_GetMetaProfile_args record
to_GetMetaProfile_args :: T.ThriftVal -> GetMetaProfile_args
to_GetMetaProfile_args (T.TStruct fields) = GetMetaProfile_args{

  }
to_GetMetaProfile_args _ = P.error "not a struct"
read_GetMetaProfile_args :: T.Protocol p => p -> P.IO GetMetaProfile_args
read_GetMetaProfile_args iprot = to_GetMetaProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_args)
decode_GetMetaProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_args
decode_GetMetaProfile_args iprot bs = to_GetMetaProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_args) bs
typemap_GetMetaProfile_args :: T.TypeMap
typemap_GetMetaProfile_args = Map.fromList []
default_GetMetaProfile_args :: GetMetaProfile_args
default_GetMetaProfile_args = GetMetaProfile_args{
}
data GetMetaProfile_result = GetMetaProfile_result  { getMetaProfile_result_success :: MetaProfile
  , getMetaProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMetaProfile_result_success record   `H.hashWithSalt` getMetaProfile_result_e record  
instance QC.Arbitrary GetMetaProfile_result where 
  arbitrary = M.liftM GetMetaProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMetaProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj}
    , if obj == default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj}
    ]
from_GetMetaProfile_result :: GetMetaProfile_result -> T.ThriftVal
from_GetMetaProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10034 -> (1, ("e",from_TalkException _v10034))) <$> getMetaProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10034 -> P.Just (0, ("success",from_MetaProfile _v10034))) $ getMetaProfile_result_success record
    , (\_v10034 -> (1, ("e",from_TalkException _v10034))) <$> getMetaProfile_result_e record
    ]
    )
write_GetMetaProfile_result :: T.Protocol p => p -> GetMetaProfile_result -> P.IO ()
write_GetMetaProfile_result oprot record = T.writeVal oprot $ from_GetMetaProfile_result record
encode_GetMetaProfile_result :: T.StatelessProtocol p => p -> GetMetaProfile_result -> LBS.ByteString
encode_GetMetaProfile_result oprot record = T.serializeVal oprot $ from_GetMetaProfile_result record
to_GetMetaProfile_result :: T.ThriftVal -> GetMetaProfile_result
to_GetMetaProfile_result (T.TStruct fields) = GetMetaProfile_result{
  getMetaProfile_result_success = P.maybe (getMetaProfile_result_success default_GetMetaProfile_result) (\(_,_val10036) -> (case _val10036 of {T.TStruct _val10037 -> (to_MetaProfile (T.TStruct _val10037)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMetaProfile_result_e = P.maybe (P.Nothing) (\(_,_val10036) -> P.Just (case _val10036 of {T.TStruct _val10038 -> (to_TalkException (T.TStruct _val10038)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMetaProfile_result _ = P.error "not a struct"
read_GetMetaProfile_result :: T.Protocol p => p -> P.IO GetMetaProfile_result
read_GetMetaProfile_result iprot = to_GetMetaProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_result)
decode_GetMetaProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_result
decode_GetMetaProfile_result iprot bs = to_GetMetaProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_result) bs
typemap_GetMetaProfile_result :: T.TypeMap
typemap_GetMetaProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MetaProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMetaProfile_result :: GetMetaProfile_result
default_GetMetaProfile_result = GetMetaProfile_result{
  getMetaProfile_result_success = default_MetaProfile,
  getMetaProfile_result_e = P.Nothing}
data SendMessageForChannel_args = SendMessageForChannel_args  { sendMessageForChannel_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_args_message record  
instance QC.Arbitrary SendMessageForChannel_args where 
  arbitrary = M.liftM SendMessageForChannel_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj} then P.Nothing else P.Just $ default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj}
    ]
from_SendMessageForChannel_args :: SendMessageForChannel_args -> T.ThriftVal
from_SendMessageForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10041 -> P.Just (2, ("message",from_Message _v10041))) $ sendMessageForChannel_args_message record
  ]
write_SendMessageForChannel_args :: T.Protocol p => p -> SendMessageForChannel_args -> P.IO ()
write_SendMessageForChannel_args oprot record = T.writeVal oprot $ from_SendMessageForChannel_args record
encode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> SendMessageForChannel_args -> LBS.ByteString
encode_SendMessageForChannel_args oprot record = T.serializeVal oprot $ from_SendMessageForChannel_args record
to_SendMessageForChannel_args :: T.ThriftVal -> SendMessageForChannel_args
to_SendMessageForChannel_args (T.TStruct fields) = SendMessageForChannel_args{
  sendMessageForChannel_args_message = P.maybe (sendMessageForChannel_args_message default_SendMessageForChannel_args) (\(_,_val10043) -> (case _val10043 of {T.TStruct _val10044 -> (to_Message (T.TStruct _val10044)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageForChannel_args _ = P.error "not a struct"
read_SendMessageForChannel_args :: T.Protocol p => p -> P.IO SendMessageForChannel_args
read_SendMessageForChannel_args iprot = to_SendMessageForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args)
decode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_args
decode_SendMessageForChannel_args iprot bs = to_SendMessageForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args) bs
typemap_SendMessageForChannel_args :: T.TypeMap
typemap_SendMessageForChannel_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageForChannel_args :: SendMessageForChannel_args
default_SendMessageForChannel_args = SendMessageForChannel_args{
  sendMessageForChannel_args_message = default_Message}
data SendMessageForChannel_result = SendMessageForChannel_result  { sendMessageForChannel_result_success :: Message
  , sendMessageForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_result_success record   `H.hashWithSalt` sendMessageForChannel_result_e record  
instance QC.Arbitrary SendMessageForChannel_result where 
  arbitrary = M.liftM SendMessageForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj}
    , if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj}
    ]
from_SendMessageForChannel_result :: SendMessageForChannel_result -> T.ThriftVal
from_SendMessageForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10047 -> (1, ("e",from_TalkException _v10047))) <$> sendMessageForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10047 -> P.Just (0, ("success",from_Message _v10047))) $ sendMessageForChannel_result_success record
    , (\_v10047 -> (1, ("e",from_TalkException _v10047))) <$> sendMessageForChannel_result_e record
    ]
    )
write_SendMessageForChannel_result :: T.Protocol p => p -> SendMessageForChannel_result -> P.IO ()
write_SendMessageForChannel_result oprot record = T.writeVal oprot $ from_SendMessageForChannel_result record
encode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> SendMessageForChannel_result -> LBS.ByteString
encode_SendMessageForChannel_result oprot record = T.serializeVal oprot $ from_SendMessageForChannel_result record
to_SendMessageForChannel_result :: T.ThriftVal -> SendMessageForChannel_result
to_SendMessageForChannel_result (T.TStruct fields) = SendMessageForChannel_result{
  sendMessageForChannel_result_success = P.maybe (sendMessageForChannel_result_success default_SendMessageForChannel_result) (\(_,_val10049) -> (case _val10049 of {T.TStruct _val10050 -> (to_Message (T.TStruct _val10050)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10049) -> P.Just (case _val10049 of {T.TStruct _val10051 -> (to_TalkException (T.TStruct _val10051)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageForChannel_result _ = P.error "not a struct"
read_SendMessageForChannel_result :: T.Protocol p => p -> P.IO SendMessageForChannel_result
read_SendMessageForChannel_result iprot = to_SendMessageForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result)
decode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_result
decode_SendMessageForChannel_result iprot bs = to_SendMessageForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result) bs
typemap_SendMessageForChannel_result :: T.TypeMap
typemap_SendMessageForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageForChannel_result :: SendMessageForChannel_result
default_SendMessageForChannel_result = SendMessageForChannel_result{
  sendMessageForChannel_result_success = default_Message,
  sendMessageForChannel_result_e = P.Nothing}
data ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ActiveBuddySubscriberCount_args where 
  arbitrary = QC.elements [ActiveBuddySubscriberCount_args]
from_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args -> T.ThriftVal
from_ActiveBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> ActiveBuddySubscriberCount_args -> P.IO ()
write_ActiveBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_args record
encode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_args -> LBS.ByteString
encode_ActiveBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_args record
to_ActiveBuddySubscriberCount_args :: T.ThriftVal -> ActiveBuddySubscriberCount_args
to_ActiveBuddySubscriberCount_args (T.TStruct fields) = ActiveBuddySubscriberCount_args{

  }
to_ActiveBuddySubscriberCount_args _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_args
read_ActiveBuddySubscriberCount_args iprot = to_ActiveBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args)
decode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_args
decode_ActiveBuddySubscriberCount_args iprot bs = to_ActiveBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args) bs
typemap_ActiveBuddySubscriberCount_args :: T.TypeMap
typemap_ActiveBuddySubscriberCount_args = Map.fromList []
default_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args
default_ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args{
}
data ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result  { activeBuddySubscriberCount_result_success :: I.Int64
  , activeBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` activeBuddySubscriberCount_result_success record   `H.hashWithSalt` activeBuddySubscriberCount_result_e record  
instance QC.Arbitrary ActiveBuddySubscriberCount_result where 
  arbitrary = M.liftM ActiveBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ActiveBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj}
    , if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj}
    ]
from_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result -> T.ThriftVal
from_ActiveBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10059 -> (1, ("e",from_TalkException _v10059))) <$> activeBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10059 -> P.Just (0, ("success",T.TI64 _v10059))) $ activeBuddySubscriberCount_result_success record
    , (\_v10059 -> (1, ("e",from_TalkException _v10059))) <$> activeBuddySubscriberCount_result_e record
    ]
    )
write_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> ActiveBuddySubscriberCount_result -> P.IO ()
write_ActiveBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_result record
encode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_result -> LBS.ByteString
encode_ActiveBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_result record
to_ActiveBuddySubscriberCount_result :: T.ThriftVal -> ActiveBuddySubscriberCount_result
to_ActiveBuddySubscriberCount_result (T.TStruct fields) = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = P.maybe (activeBuddySubscriberCount_result_success default_ActiveBuddySubscriberCount_result) (\(_,_val10061) -> (case _val10061 of {T.TI64 _val10062 -> _val10062; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  activeBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val10061) -> P.Just (case _val10061 of {T.TStruct _val10063 -> (to_TalkException (T.TStruct _val10063)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ActiveBuddySubscriberCount_result _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_result
read_ActiveBuddySubscriberCount_result iprot = to_ActiveBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result)
decode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_result
decode_ActiveBuddySubscriberCount_result iprot bs = to_ActiveBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result) bs
typemap_ActiveBuddySubscriberCount_result :: T.TypeMap
typemap_ActiveBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result
default_ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = 0,
  activeBuddySubscriberCount_result_e = P.Nothing}
data GetCallCreditPurchaseHistory_args = GetCallCreditPurchaseHistory_args  { getCallCreditPurchaseHistory_args_request :: CoinHistoryCondition
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditPurchaseHistory_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditPurchaseHistory_args_request record  
instance QC.Arbitrary GetCallCreditPurchaseHistory_args where 
  arbitrary = M.liftM GetCallCreditPurchaseHistory_args (QC.arbitrary)
  shrink obj | obj == default_GetCallCreditPurchaseHistory_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditPurchaseHistory_args{getCallCreditPurchaseHistory_args_request = getCallCreditPurchaseHistory_args_request obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_args{getCallCreditPurchaseHistory_args_request = getCallCreditPurchaseHistory_args_request obj}
    ]
from_GetCallCreditPurchaseHistory_args :: GetCallCreditPurchaseHistory_args -> T.ThriftVal
from_GetCallCreditPurchaseHistory_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10066 -> P.Just (2, ("request",from_CoinHistoryCondition _v10066))) $ getCallCreditPurchaseHistory_args_request record
  ]
write_GetCallCreditPurchaseHistory_args :: T.Protocol p => p -> GetCallCreditPurchaseHistory_args -> P.IO ()
write_GetCallCreditPurchaseHistory_args oprot record = T.writeVal oprot $ from_GetCallCreditPurchaseHistory_args record
encode_GetCallCreditPurchaseHistory_args :: T.StatelessProtocol p => p -> GetCallCreditPurchaseHistory_args -> LBS.ByteString
encode_GetCallCreditPurchaseHistory_args oprot record = T.serializeVal oprot $ from_GetCallCreditPurchaseHistory_args record
to_GetCallCreditPurchaseHistory_args :: T.ThriftVal -> GetCallCreditPurchaseHistory_args
to_GetCallCreditPurchaseHistory_args (T.TStruct fields) = GetCallCreditPurchaseHistory_args{
  getCallCreditPurchaseHistory_args_request = P.maybe (getCallCreditPurchaseHistory_args_request default_GetCallCreditPurchaseHistory_args) (\(_,_val10068) -> (case _val10068 of {T.TStruct _val10069 -> (to_CoinHistoryCondition (T.TStruct _val10069)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCallCreditPurchaseHistory_args _ = P.error "not a struct"
read_GetCallCreditPurchaseHistory_args :: T.Protocol p => p -> P.IO GetCallCreditPurchaseHistory_args
read_GetCallCreditPurchaseHistory_args iprot = to_GetCallCreditPurchaseHistory_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_args)
decode_GetCallCreditPurchaseHistory_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditPurchaseHistory_args
decode_GetCallCreditPurchaseHistory_args iprot bs = to_GetCallCreditPurchaseHistory_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_args) bs
typemap_GetCallCreditPurchaseHistory_args :: T.TypeMap
typemap_GetCallCreditPurchaseHistory_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinHistoryCondition)))]
default_GetCallCreditPurchaseHistory_args :: GetCallCreditPurchaseHistory_args
default_GetCallCreditPurchaseHistory_args = GetCallCreditPurchaseHistory_args{
  getCallCreditPurchaseHistory_args_request = default_CoinHistoryCondition}
data GetCallCreditPurchaseHistory_result = GetCallCreditPurchaseHistory_result  { getCallCreditPurchaseHistory_result_success :: CoinHistoryResult
  , getCallCreditPurchaseHistory_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCallCreditPurchaseHistory_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCallCreditPurchaseHistory_result_success record   `H.hashWithSalt` getCallCreditPurchaseHistory_result_e record  
instance QC.Arbitrary GetCallCreditPurchaseHistory_result where 
  arbitrary = M.liftM GetCallCreditPurchaseHistory_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCallCreditPurchaseHistory_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = getCallCreditPurchaseHistory_result_success obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = getCallCreditPurchaseHistory_result_success obj}
    , if obj == default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = getCallCreditPurchaseHistory_result_e obj} then P.Nothing else P.Just $ default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = getCallCreditPurchaseHistory_result_e obj}
    ]
from_GetCallCreditPurchaseHistory_result :: GetCallCreditPurchaseHistory_result -> T.ThriftVal
from_GetCallCreditPurchaseHistory_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10072 -> (1, ("e",from_TalkException _v10072))) <$> getCallCreditPurchaseHistory_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10072 -> P.Just (0, ("success",from_CoinHistoryResult _v10072))) $ getCallCreditPurchaseHistory_result_success record
    , (\_v10072 -> (1, ("e",from_TalkException _v10072))) <$> getCallCreditPurchaseHistory_result_e record
    ]
    )
write_GetCallCreditPurchaseHistory_result :: T.Protocol p => p -> GetCallCreditPurchaseHistory_result -> P.IO ()
write_GetCallCreditPurchaseHistory_result oprot record = T.writeVal oprot $ from_GetCallCreditPurchaseHistory_result record
encode_GetCallCreditPurchaseHistory_result :: T.StatelessProtocol p => p -> GetCallCreditPurchaseHistory_result -> LBS.ByteString
encode_GetCallCreditPurchaseHistory_result oprot record = T.serializeVal oprot $ from_GetCallCreditPurchaseHistory_result record
to_GetCallCreditPurchaseHistory_result :: T.ThriftVal -> GetCallCreditPurchaseHistory_result
to_GetCallCreditPurchaseHistory_result (T.TStruct fields) = GetCallCreditPurchaseHistory_result{
  getCallCreditPurchaseHistory_result_success = P.maybe (getCallCreditPurchaseHistory_result_success default_GetCallCreditPurchaseHistory_result) (\(_,_val10074) -> (case _val10074 of {T.TStruct _val10075 -> (to_CoinHistoryResult (T.TStruct _val10075)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCallCreditPurchaseHistory_result_e = P.maybe (P.Nothing) (\(_,_val10074) -> P.Just (case _val10074 of {T.TStruct _val10076 -> (to_TalkException (T.TStruct _val10076)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCallCreditPurchaseHistory_result _ = P.error "not a struct"
read_GetCallCreditPurchaseHistory_result :: T.Protocol p => p -> P.IO GetCallCreditPurchaseHistory_result
read_GetCallCreditPurchaseHistory_result iprot = to_GetCallCreditPurchaseHistory_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_result)
decode_GetCallCreditPurchaseHistory_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCallCreditPurchaseHistory_result
decode_GetCallCreditPurchaseHistory_result iprot bs = to_GetCallCreditPurchaseHistory_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCallCreditPurchaseHistory_result) bs
typemap_GetCallCreditPurchaseHistory_result :: T.TypeMap
typemap_GetCallCreditPurchaseHistory_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CoinHistoryResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCallCreditPurchaseHistory_result :: GetCallCreditPurchaseHistory_result
default_GetCallCreditPurchaseHistory_result = GetCallCreditPurchaseHistory_result{
  getCallCreditPurchaseHistory_result_success = default_CoinHistoryResult,
  getCallCreditPurchaseHistory_result_e = P.Nothing}
data IsRoomMember_args = IsRoomMember_args  { isRoomMember_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsRoomMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isRoomMember_args_roomId record  
instance QC.Arbitrary IsRoomMember_args where 
  arbitrary = M.liftM IsRoomMember_args (QC.arbitrary)
  shrink obj | obj == default_IsRoomMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsRoomMember_args{isRoomMember_args_roomId = isRoomMember_args_roomId obj} then P.Nothing else P.Just $ default_IsRoomMember_args{isRoomMember_args_roomId = isRoomMember_args_roomId obj}
    ]
from_IsRoomMember_args :: IsRoomMember_args -> T.ThriftVal
from_IsRoomMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10079 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10079))) $ isRoomMember_args_roomId record
  ]
write_IsRoomMember_args :: T.Protocol p => p -> IsRoomMember_args -> P.IO ()
write_IsRoomMember_args oprot record = T.writeVal oprot $ from_IsRoomMember_args record
encode_IsRoomMember_args :: T.StatelessProtocol p => p -> IsRoomMember_args -> LBS.ByteString
encode_IsRoomMember_args oprot record = T.serializeVal oprot $ from_IsRoomMember_args record
to_IsRoomMember_args :: T.ThriftVal -> IsRoomMember_args
to_IsRoomMember_args (T.TStruct fields) = IsRoomMember_args{
  isRoomMember_args_roomId = P.maybe (isRoomMember_args_roomId default_IsRoomMember_args) (\(_,_val10081) -> (case _val10081 of {T.TString _val10082 -> E.decodeUtf8 _val10082; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsRoomMember_args _ = P.error "not a struct"
read_IsRoomMember_args :: T.Protocol p => p -> P.IO IsRoomMember_args
read_IsRoomMember_args iprot = to_IsRoomMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsRoomMember_args)
decode_IsRoomMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsRoomMember_args
decode_IsRoomMember_args iprot bs = to_IsRoomMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsRoomMember_args) bs
typemap_IsRoomMember_args :: T.TypeMap
typemap_IsRoomMember_args = Map.fromList [(1,("roomId",T.T_STRING))]
default_IsRoomMember_args :: IsRoomMember_args
default_IsRoomMember_args = IsRoomMember_args{
  isRoomMember_args_roomId = ""}
data IsRoomMember_result = IsRoomMember_result  { isRoomMember_result_success :: P.Bool
  , isRoomMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsRoomMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isRoomMember_result_success record   `H.hashWithSalt` isRoomMember_result_e record  
instance QC.Arbitrary IsRoomMember_result where 
  arbitrary = M.liftM IsRoomMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsRoomMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsRoomMember_result{isRoomMember_result_success = isRoomMember_result_success obj} then P.Nothing else P.Just $ default_IsRoomMember_result{isRoomMember_result_success = isRoomMember_result_success obj}
    , if obj == default_IsRoomMember_result{isRoomMember_result_e = isRoomMember_result_e obj} then P.Nothing else P.Just $ default_IsRoomMember_result{isRoomMember_result_e = isRoomMember_result_e obj}
    ]
from_IsRoomMember_result :: IsRoomMember_result -> T.ThriftVal
from_IsRoomMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10085 -> (1, ("e",from_TalkException _v10085))) <$> isRoomMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10085 -> P.Just (0, ("success",T.TBool _v10085))) $ isRoomMember_result_success record
    , (\_v10085 -> (1, ("e",from_TalkException _v10085))) <$> isRoomMember_result_e record
    ]
    )
write_IsRoomMember_result :: T.Protocol p => p -> IsRoomMember_result -> P.IO ()
write_IsRoomMember_result oprot record = T.writeVal oprot $ from_IsRoomMember_result record
encode_IsRoomMember_result :: T.StatelessProtocol p => p -> IsRoomMember_result -> LBS.ByteString
encode_IsRoomMember_result oprot record = T.serializeVal oprot $ from_IsRoomMember_result record
to_IsRoomMember_result :: T.ThriftVal -> IsRoomMember_result
to_IsRoomMember_result (T.TStruct fields) = IsRoomMember_result{
  isRoomMember_result_success = P.maybe (isRoomMember_result_success default_IsRoomMember_result) (\(_,_val10087) -> (case _val10087 of {T.TBool _val10088 -> _val10088; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isRoomMember_result_e = P.maybe (P.Nothing) (\(_,_val10087) -> P.Just (case _val10087 of {T.TStruct _val10089 -> (to_TalkException (T.TStruct _val10089)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsRoomMember_result _ = P.error "not a struct"
read_IsRoomMember_result :: T.Protocol p => p -> P.IO IsRoomMember_result
read_IsRoomMember_result iprot = to_IsRoomMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsRoomMember_result)
decode_IsRoomMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsRoomMember_result
decode_IsRoomMember_result iprot bs = to_IsRoomMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsRoomMember_result) bs
typemap_IsRoomMember_result :: T.TypeMap
typemap_IsRoomMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsRoomMember_result :: IsRoomMember_result
default_IsRoomMember_result = IsRoomMember_result{
  isRoomMember_result_success = P.False,
  isRoomMember_result_e = P.Nothing}
data SendSystemOAMessage_args = SendSystemOAMessage_args  { sendSystemOAMessage_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendSystemOAMessage_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendSystemOAMessage_args_message record  
instance QC.Arbitrary SendSystemOAMessage_args where 
  arbitrary = M.liftM SendSystemOAMessage_args (QC.arbitrary)
  shrink obj | obj == default_SendSystemOAMessage_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendSystemOAMessage_args{sendSystemOAMessage_args_message = sendSystemOAMessage_args_message obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_args{sendSystemOAMessage_args_message = sendSystemOAMessage_args_message obj}
    ]
from_SendSystemOAMessage_args :: SendSystemOAMessage_args -> T.ThriftVal
from_SendSystemOAMessage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10092 -> P.Just (1, ("message",from_Message _v10092))) $ sendSystemOAMessage_args_message record
  ]
write_SendSystemOAMessage_args :: T.Protocol p => p -> SendSystemOAMessage_args -> P.IO ()
write_SendSystemOAMessage_args oprot record = T.writeVal oprot $ from_SendSystemOAMessage_args record
encode_SendSystemOAMessage_args :: T.StatelessProtocol p => p -> SendSystemOAMessage_args -> LBS.ByteString
encode_SendSystemOAMessage_args oprot record = T.serializeVal oprot $ from_SendSystemOAMessage_args record
to_SendSystemOAMessage_args :: T.ThriftVal -> SendSystemOAMessage_args
to_SendSystemOAMessage_args (T.TStruct fields) = SendSystemOAMessage_args{
  sendSystemOAMessage_args_message = P.maybe (sendSystemOAMessage_args_message default_SendSystemOAMessage_args) (\(_,_val10094) -> (case _val10094 of {T.TStruct _val10095 -> (to_Message (T.TStruct _val10095)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendSystemOAMessage_args _ = P.error "not a struct"
read_SendSystemOAMessage_args :: T.Protocol p => p -> P.IO SendSystemOAMessage_args
read_SendSystemOAMessage_args iprot = to_SendSystemOAMessage_args <$> T.readVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_args)
decode_SendSystemOAMessage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendSystemOAMessage_args
decode_SendSystemOAMessage_args iprot bs = to_SendSystemOAMessage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_args) bs
typemap_SendSystemOAMessage_args :: T.TypeMap
typemap_SendSystemOAMessage_args = Map.fromList [(1,("message",(T.T_STRUCT typemap_Message)))]
default_SendSystemOAMessage_args :: SendSystemOAMessage_args
default_SendSystemOAMessage_args = SendSystemOAMessage_args{
  sendSystemOAMessage_args_message = default_Message}
data SendSystemOAMessage_result = SendSystemOAMessage_result  { sendSystemOAMessage_result_success :: Message
  , sendSystemOAMessage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendSystemOAMessage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendSystemOAMessage_result_success record   `H.hashWithSalt` sendSystemOAMessage_result_e record  
instance QC.Arbitrary SendSystemOAMessage_result where 
  arbitrary = M.liftM SendSystemOAMessage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendSystemOAMessage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = sendSystemOAMessage_result_success obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = sendSystemOAMessage_result_success obj}
    , if obj == default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = sendSystemOAMessage_result_e obj} then P.Nothing else P.Just $ default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = sendSystemOAMessage_result_e obj}
    ]
from_SendSystemOAMessage_result :: SendSystemOAMessage_result -> T.ThriftVal
from_SendSystemOAMessage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10098 -> (1, ("e",from_TalkException _v10098))) <$> sendSystemOAMessage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10098 -> P.Just (0, ("success",from_Message _v10098))) $ sendSystemOAMessage_result_success record
    , (\_v10098 -> (1, ("e",from_TalkException _v10098))) <$> sendSystemOAMessage_result_e record
    ]
    )
write_SendSystemOAMessage_result :: T.Protocol p => p -> SendSystemOAMessage_result -> P.IO ()
write_SendSystemOAMessage_result oprot record = T.writeVal oprot $ from_SendSystemOAMessage_result record
encode_SendSystemOAMessage_result :: T.StatelessProtocol p => p -> SendSystemOAMessage_result -> LBS.ByteString
encode_SendSystemOAMessage_result oprot record = T.serializeVal oprot $ from_SendSystemOAMessage_result record
to_SendSystemOAMessage_result :: T.ThriftVal -> SendSystemOAMessage_result
to_SendSystemOAMessage_result (T.TStruct fields) = SendSystemOAMessage_result{
  sendSystemOAMessage_result_success = P.maybe (sendSystemOAMessage_result_success default_SendSystemOAMessage_result) (\(_,_val10100) -> (case _val10100 of {T.TStruct _val10101 -> (to_Message (T.TStruct _val10101)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendSystemOAMessage_result_e = P.maybe (P.Nothing) (\(_,_val10100) -> P.Just (case _val10100 of {T.TStruct _val10102 -> (to_TalkException (T.TStruct _val10102)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendSystemOAMessage_result _ = P.error "not a struct"
read_SendSystemOAMessage_result :: T.Protocol p => p -> P.IO SendSystemOAMessage_result
read_SendSystemOAMessage_result iprot = to_SendSystemOAMessage_result <$> T.readVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_result)
decode_SendSystemOAMessage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendSystemOAMessage_result
decode_SendSystemOAMessage_result iprot bs = to_SendSystemOAMessage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendSystemOAMessage_result) bs
typemap_SendSystemOAMessage_result :: T.TypeMap
typemap_SendSystemOAMessage_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendSystemOAMessage_result :: SendSystemOAMessage_result
default_SendSystemOAMessage_result = SendSystemOAMessage_result{
  sendSystemOAMessage_result_success = default_Message,
  sendSystemOAMessage_result_e = P.Nothing}
data AcquirePaidCallRoute_args = AcquirePaidCallRoute_args  { acquirePaidCallRoute_args_paidCallType :: PaidCallType
  , acquirePaidCallRoute_args_dialedNumber :: LT.Text
  , acquirePaidCallRoute_args_language :: LT.Text
  , acquirePaidCallRoute_args_networkCode :: LT.Text
  , acquirePaidCallRoute_args_disableCallerId :: P.Bool
  , acquirePaidCallRoute_args_referer :: LT.Text
  , acquirePaidCallRoute_args_adSessionId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallRoute_args_paidCallType record   `H.hashWithSalt` acquirePaidCallRoute_args_dialedNumber record   `H.hashWithSalt` acquirePaidCallRoute_args_language record   `H.hashWithSalt` acquirePaidCallRoute_args_networkCode record   `H.hashWithSalt` acquirePaidCallRoute_args_disableCallerId record   `H.hashWithSalt` acquirePaidCallRoute_args_referer record   `H.hashWithSalt` acquirePaidCallRoute_args_adSessionId record  
instance QC.Arbitrary AcquirePaidCallRoute_args where 
  arbitrary = M.liftM AcquirePaidCallRoute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_paidCallType = acquirePaidCallRoute_args_paidCallType obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_paidCallType = acquirePaidCallRoute_args_paidCallType obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_dialedNumber = acquirePaidCallRoute_args_dialedNumber obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_dialedNumber = acquirePaidCallRoute_args_dialedNumber obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_language = acquirePaidCallRoute_args_language obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_language = acquirePaidCallRoute_args_language obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_networkCode = acquirePaidCallRoute_args_networkCode obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_networkCode = acquirePaidCallRoute_args_networkCode obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_disableCallerId = acquirePaidCallRoute_args_disableCallerId obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_disableCallerId = acquirePaidCallRoute_args_disableCallerId obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_referer = acquirePaidCallRoute_args_referer obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_referer = acquirePaidCallRoute_args_referer obj}
    , if obj == default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_adSessionId = acquirePaidCallRoute_args_adSessionId obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_args{acquirePaidCallRoute_args_adSessionId = acquirePaidCallRoute_args_adSessionId obj}
    ]
from_AcquirePaidCallRoute_args :: AcquirePaidCallRoute_args -> T.ThriftVal
from_AcquirePaidCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10105 -> P.Just (2, ("paidCallType",T.TI32 $ P.fromIntegral $ P.fromEnum _v10105))) $ acquirePaidCallRoute_args_paidCallType record
  , (\_v10105 -> P.Just (3, ("dialedNumber",T.TString $ E.encodeUtf8 _v10105))) $ acquirePaidCallRoute_args_dialedNumber record
  , (\_v10105 -> P.Just (4, ("language",T.TString $ E.encodeUtf8 _v10105))) $ acquirePaidCallRoute_args_language record
  , (\_v10105 -> P.Just (5, ("networkCode",T.TString $ E.encodeUtf8 _v10105))) $ acquirePaidCallRoute_args_networkCode record
  , (\_v10105 -> P.Just (6, ("disableCallerId",T.TBool _v10105))) $ acquirePaidCallRoute_args_disableCallerId record
  , (\_v10105 -> P.Just (7, ("referer",T.TString $ E.encodeUtf8 _v10105))) $ acquirePaidCallRoute_args_referer record
  , (\_v10105 -> P.Just (8, ("adSessionId",T.TString $ E.encodeUtf8 _v10105))) $ acquirePaidCallRoute_args_adSessionId record
  ]
write_AcquirePaidCallRoute_args :: T.Protocol p => p -> AcquirePaidCallRoute_args -> P.IO ()
write_AcquirePaidCallRoute_args oprot record = T.writeVal oprot $ from_AcquirePaidCallRoute_args record
encode_AcquirePaidCallRoute_args :: T.StatelessProtocol p => p -> AcquirePaidCallRoute_args -> LBS.ByteString
encode_AcquirePaidCallRoute_args oprot record = T.serializeVal oprot $ from_AcquirePaidCallRoute_args record
to_AcquirePaidCallRoute_args :: T.ThriftVal -> AcquirePaidCallRoute_args
to_AcquirePaidCallRoute_args (T.TStruct fields) = AcquirePaidCallRoute_args{
  acquirePaidCallRoute_args_paidCallType = P.maybe (acquirePaidCallRoute_args_paidCallType default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TI32 _val10108 -> P.toEnum $ P.fromIntegral _val10108; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acquirePaidCallRoute_args_dialedNumber = P.maybe (acquirePaidCallRoute_args_dialedNumber default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TString _val10109 -> E.decodeUtf8 _val10109; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  acquirePaidCallRoute_args_language = P.maybe (acquirePaidCallRoute_args_language default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TString _val10110 -> E.decodeUtf8 _val10110; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  acquirePaidCallRoute_args_networkCode = P.maybe (acquirePaidCallRoute_args_networkCode default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TString _val10111 -> E.decodeUtf8 _val10111; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  acquirePaidCallRoute_args_disableCallerId = P.maybe (acquirePaidCallRoute_args_disableCallerId default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TBool _val10112 -> _val10112; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  acquirePaidCallRoute_args_referer = P.maybe (acquirePaidCallRoute_args_referer default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TString _val10113 -> E.decodeUtf8 _val10113; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  acquirePaidCallRoute_args_adSessionId = P.maybe (acquirePaidCallRoute_args_adSessionId default_AcquirePaidCallRoute_args) (\(_,_val10107) -> (case _val10107 of {T.TString _val10114 -> E.decodeUtf8 _val10114; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_AcquirePaidCallRoute_args _ = P.error "not a struct"
read_AcquirePaidCallRoute_args :: T.Protocol p => p -> P.IO AcquirePaidCallRoute_args
read_AcquirePaidCallRoute_args iprot = to_AcquirePaidCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_args)
decode_AcquirePaidCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallRoute_args
decode_AcquirePaidCallRoute_args iprot bs = to_AcquirePaidCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_args) bs
typemap_AcquirePaidCallRoute_args :: T.TypeMap
typemap_AcquirePaidCallRoute_args = Map.fromList [(2,("paidCallType",T.T_I32)),(3,("dialedNumber",T.T_STRING)),(4,("language",T.T_STRING)),(5,("networkCode",T.T_STRING)),(6,("disableCallerId",T.T_BOOL)),(7,("referer",T.T_STRING)),(8,("adSessionId",T.T_STRING))]
default_AcquirePaidCallRoute_args :: AcquirePaidCallRoute_args
default_AcquirePaidCallRoute_args = AcquirePaidCallRoute_args{
  acquirePaidCallRoute_args_paidCallType = (P.toEnum 0),
  acquirePaidCallRoute_args_dialedNumber = "",
  acquirePaidCallRoute_args_language = "",
  acquirePaidCallRoute_args_networkCode = "",
  acquirePaidCallRoute_args_disableCallerId = P.False,
  acquirePaidCallRoute_args_referer = "",
  acquirePaidCallRoute_args_adSessionId = ""}
data AcquirePaidCallRoute_result = AcquirePaidCallRoute_result  { acquirePaidCallRoute_result_success :: PaidCallResponse
  , acquirePaidCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallRoute_result_success record   `H.hashWithSalt` acquirePaidCallRoute_result_e record  
instance QC.Arbitrary AcquirePaidCallRoute_result where 
  arbitrary = M.liftM AcquirePaidCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = acquirePaidCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = acquirePaidCallRoute_result_success obj}
    , if obj == default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = acquirePaidCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = acquirePaidCallRoute_result_e obj}
    ]
from_AcquirePaidCallRoute_result :: AcquirePaidCallRoute_result -> T.ThriftVal
from_AcquirePaidCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10117 -> (1, ("e",from_TalkException _v10117))) <$> acquirePaidCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10117 -> P.Just (0, ("success",from_PaidCallResponse _v10117))) $ acquirePaidCallRoute_result_success record
    , (\_v10117 -> (1, ("e",from_TalkException _v10117))) <$> acquirePaidCallRoute_result_e record
    ]
    )
write_AcquirePaidCallRoute_result :: T.Protocol p => p -> AcquirePaidCallRoute_result -> P.IO ()
write_AcquirePaidCallRoute_result oprot record = T.writeVal oprot $ from_AcquirePaidCallRoute_result record
encode_AcquirePaidCallRoute_result :: T.StatelessProtocol p => p -> AcquirePaidCallRoute_result -> LBS.ByteString
encode_AcquirePaidCallRoute_result oprot record = T.serializeVal oprot $ from_AcquirePaidCallRoute_result record
to_AcquirePaidCallRoute_result :: T.ThriftVal -> AcquirePaidCallRoute_result
to_AcquirePaidCallRoute_result (T.TStruct fields) = AcquirePaidCallRoute_result{
  acquirePaidCallRoute_result_success = P.maybe (acquirePaidCallRoute_result_success default_AcquirePaidCallRoute_result) (\(_,_val10119) -> (case _val10119 of {T.TStruct _val10120 -> (to_PaidCallResponse (T.TStruct _val10120)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquirePaidCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val10119) -> P.Just (case _val10119 of {T.TStruct _val10121 -> (to_TalkException (T.TStruct _val10121)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquirePaidCallRoute_result _ = P.error "not a struct"
read_AcquirePaidCallRoute_result :: T.Protocol p => p -> P.IO AcquirePaidCallRoute_result
read_AcquirePaidCallRoute_result iprot = to_AcquirePaidCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_result)
decode_AcquirePaidCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallRoute_result
decode_AcquirePaidCallRoute_result iprot bs = to_AcquirePaidCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallRoute_result) bs
typemap_AcquirePaidCallRoute_result :: T.TypeMap
typemap_AcquirePaidCallRoute_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquirePaidCallRoute_result :: AcquirePaidCallRoute_result
default_AcquirePaidCallRoute_result = AcquirePaidCallRoute_result{
  acquirePaidCallRoute_result_success = default_PaidCallResponse,
  acquirePaidCallRoute_result_e = P.Nothing}
data GetGroupsForChannel_args = GetGroupsForChannel_args  { getGroupsForChannel_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_args_groupIds record  
instance QC.Arbitrary GetGroupsForChannel_args where 
  arbitrary = M.liftM GetGroupsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj}
    ]
from_GetGroupsForChannel_args :: GetGroupsForChannel_args -> T.ThriftVal
from_GetGroupsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10124 -> P.Just (1, ("groupIds",T.TList T.T_STRING $ P.map (\_v10126 -> T.TString $ E.encodeUtf8 _v10126) $ Vector.toList _v10124))) $ getGroupsForChannel_args_groupIds record
  ]
write_GetGroupsForChannel_args :: T.Protocol p => p -> GetGroupsForChannel_args -> P.IO ()
write_GetGroupsForChannel_args oprot record = T.writeVal oprot $ from_GetGroupsForChannel_args record
encode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> GetGroupsForChannel_args -> LBS.ByteString
encode_GetGroupsForChannel_args oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_args record
to_GetGroupsForChannel_args :: T.ThriftVal -> GetGroupsForChannel_args
to_GetGroupsForChannel_args (T.TStruct fields) = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = P.maybe (getGroupsForChannel_args_groupIds default_GetGroupsForChannel_args) (\(_,_val10128) -> (case _val10128 of {T.TList _ _val10129 -> (Vector.fromList $ P.map (\_v10130 -> (case _v10130 of {T.TString _val10131 -> E.decodeUtf8 _val10131; _ -> P.error "wrong type"})) _val10129); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_args _ = P.error "not a struct"
read_GetGroupsForChannel_args :: T.Protocol p => p -> P.IO GetGroupsForChannel_args
read_GetGroupsForChannel_args iprot = to_GetGroupsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args)
decode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_args
decode_GetGroupsForChannel_args iprot bs = to_GetGroupsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args) bs
typemap_GetGroupsForChannel_args :: T.TypeMap
typemap_GetGroupsForChannel_args = Map.fromList [(1,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroupsForChannel_args :: GetGroupsForChannel_args
default_GetGroupsForChannel_args = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = Vector.empty}
data GetGroupsForChannel_result = GetGroupsForChannel_result  { getGroupsForChannel_result_success :: (Vector.Vector Group)
  , getGroupsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_result_success record   `H.hashWithSalt` getGroupsForChannel_result_e record  
instance QC.Arbitrary GetGroupsForChannel_result where 
  arbitrary = M.liftM GetGroupsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj}
    , if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj}
    ]
from_GetGroupsForChannel_result :: GetGroupsForChannel_result -> T.ThriftVal
from_GetGroupsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10134 -> (1, ("e",from_TalkException _v10134))) <$> getGroupsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10134 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v10136 -> from_Group _v10136) $ Vector.toList _v10134))) $ getGroupsForChannel_result_success record
    , (\_v10134 -> (1, ("e",from_TalkException _v10134))) <$> getGroupsForChannel_result_e record
    ]
    )
write_GetGroupsForChannel_result :: T.Protocol p => p -> GetGroupsForChannel_result -> P.IO ()
write_GetGroupsForChannel_result oprot record = T.writeVal oprot $ from_GetGroupsForChannel_result record
encode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> GetGroupsForChannel_result -> LBS.ByteString
encode_GetGroupsForChannel_result oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_result record
to_GetGroupsForChannel_result :: T.ThriftVal -> GetGroupsForChannel_result
to_GetGroupsForChannel_result (T.TStruct fields) = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = P.maybe (getGroupsForChannel_result_success default_GetGroupsForChannel_result) (\(_,_val10138) -> (case _val10138 of {T.TList _ _val10139 -> (Vector.fromList $ P.map (\_v10140 -> (case _v10140 of {T.TStruct _val10141 -> (to_Group (T.TStruct _val10141)); _ -> P.error "wrong type"})) _val10139); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10138) -> P.Just (case _val10138 of {T.TStruct _val10142 -> (to_TalkException (T.TStruct _val10142)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_result _ = P.error "not a struct"
read_GetGroupsForChannel_result :: T.Protocol p => p -> P.IO GetGroupsForChannel_result
read_GetGroupsForChannel_result iprot = to_GetGroupsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result)
decode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_result
decode_GetGroupsForChannel_result iprot bs = to_GetGroupsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result) bs
typemap_GetGroupsForChannel_result :: T.TypeMap
typemap_GetGroupsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupsForChannel_result :: GetGroupsForChannel_result
default_GetGroupsForChannel_result = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = Vector.empty,
  getGroupsForChannel_result_e = P.Nothing}
data GetUserCreateTime_args = GetUserCreateTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserCreateTime_args where 
  arbitrary = QC.elements [GetUserCreateTime_args]
from_GetUserCreateTime_args :: GetUserCreateTime_args -> T.ThriftVal
from_GetUserCreateTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserCreateTime_args :: T.Protocol p => p -> GetUserCreateTime_args -> P.IO ()
write_GetUserCreateTime_args oprot record = T.writeVal oprot $ from_GetUserCreateTime_args record
encode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> GetUserCreateTime_args -> LBS.ByteString
encode_GetUserCreateTime_args oprot record = T.serializeVal oprot $ from_GetUserCreateTime_args record
to_GetUserCreateTime_args :: T.ThriftVal -> GetUserCreateTime_args
to_GetUserCreateTime_args (T.TStruct fields) = GetUserCreateTime_args{

  }
to_GetUserCreateTime_args _ = P.error "not a struct"
read_GetUserCreateTime_args :: T.Protocol p => p -> P.IO GetUserCreateTime_args
read_GetUserCreateTime_args iprot = to_GetUserCreateTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args)
decode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_args
decode_GetUserCreateTime_args iprot bs = to_GetUserCreateTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args) bs
typemap_GetUserCreateTime_args :: T.TypeMap
typemap_GetUserCreateTime_args = Map.fromList []
default_GetUserCreateTime_args :: GetUserCreateTime_args
default_GetUserCreateTime_args = GetUserCreateTime_args{
}
data GetUserCreateTime_result = GetUserCreateTime_result  { getUserCreateTime_result_success :: I.Int64
  , getUserCreateTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCreateTime_result_success record   `H.hashWithSalt` getUserCreateTime_result_e record  
instance QC.Arbitrary GetUserCreateTime_result where 
  arbitrary = M.liftM GetUserCreateTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCreateTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj}
    , if obj == default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj}
    ]
from_GetUserCreateTime_result :: GetUserCreateTime_result -> T.ThriftVal
from_GetUserCreateTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10150 -> (1, ("e",from_TalkException _v10150))) <$> getUserCreateTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10150 -> P.Just (0, ("success",T.TI64 _v10150))) $ getUserCreateTime_result_success record
    , (\_v10150 -> (1, ("e",from_TalkException _v10150))) <$> getUserCreateTime_result_e record
    ]
    )
write_GetUserCreateTime_result :: T.Protocol p => p -> GetUserCreateTime_result -> P.IO ()
write_GetUserCreateTime_result oprot record = T.writeVal oprot $ from_GetUserCreateTime_result record
encode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> GetUserCreateTime_result -> LBS.ByteString
encode_GetUserCreateTime_result oprot record = T.serializeVal oprot $ from_GetUserCreateTime_result record
to_GetUserCreateTime_result :: T.ThriftVal -> GetUserCreateTime_result
to_GetUserCreateTime_result (T.TStruct fields) = GetUserCreateTime_result{
  getUserCreateTime_result_success = P.maybe (getUserCreateTime_result_success default_GetUserCreateTime_result) (\(_,_val10152) -> (case _val10152 of {T.TI64 _val10153 -> _val10153; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCreateTime_result_e = P.maybe (P.Nothing) (\(_,_val10152) -> P.Just (case _val10152 of {T.TStruct _val10154 -> (to_TalkException (T.TStruct _val10154)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCreateTime_result _ = P.error "not a struct"
read_GetUserCreateTime_result :: T.Protocol p => p -> P.IO GetUserCreateTime_result
read_GetUserCreateTime_result iprot = to_GetUserCreateTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result)
decode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_result
decode_GetUserCreateTime_result iprot bs = to_GetUserCreateTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result) bs
typemap_GetUserCreateTime_result :: T.TypeMap
typemap_GetUserCreateTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCreateTime_result :: GetUserCreateTime_result
default_GetUserCreateTime_result = GetUserCreateTime_result{
  getUserCreateTime_result_success = 0,
  getUserCreateTime_result_e = P.Nothing}
data RegisterChannelCP_args = RegisterChannelCP_args  { registerChannelCP_args_cpId :: LT.Text
  , registerChannelCP_args_registerPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_args_cpId record   `H.hashWithSalt` registerChannelCP_args_registerPassword record  
instance QC.Arbitrary RegisterChannelCP_args where 
  arbitrary = M.liftM RegisterChannelCP_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj}
    , if obj == default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj}
    ]
from_RegisterChannelCP_args :: RegisterChannelCP_args -> T.ThriftVal
from_RegisterChannelCP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10157 -> P.Just (2, ("cpId",T.TString $ E.encodeUtf8 _v10157))) $ registerChannelCP_args_cpId record
  , (\_v10157 -> P.Just (3, ("registerPassword",T.TString $ E.encodeUtf8 _v10157))) $ registerChannelCP_args_registerPassword record
  ]
write_RegisterChannelCP_args :: T.Protocol p => p -> RegisterChannelCP_args -> P.IO ()
write_RegisterChannelCP_args oprot record = T.writeVal oprot $ from_RegisterChannelCP_args record
encode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> RegisterChannelCP_args -> LBS.ByteString
encode_RegisterChannelCP_args oprot record = T.serializeVal oprot $ from_RegisterChannelCP_args record
to_RegisterChannelCP_args :: T.ThriftVal -> RegisterChannelCP_args
to_RegisterChannelCP_args (T.TStruct fields) = RegisterChannelCP_args{
  registerChannelCP_args_cpId = P.maybe (registerChannelCP_args_cpId default_RegisterChannelCP_args) (\(_,_val10159) -> (case _val10159 of {T.TString _val10160 -> E.decodeUtf8 _val10160; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerChannelCP_args_registerPassword = P.maybe (registerChannelCP_args_registerPassword default_RegisterChannelCP_args) (\(_,_val10159) -> (case _val10159 of {T.TString _val10161 -> E.decodeUtf8 _val10161; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterChannelCP_args _ = P.error "not a struct"
read_RegisterChannelCP_args :: T.Protocol p => p -> P.IO RegisterChannelCP_args
read_RegisterChannelCP_args iprot = to_RegisterChannelCP_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args)
decode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_args
decode_RegisterChannelCP_args iprot bs = to_RegisterChannelCP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args) bs
typemap_RegisterChannelCP_args :: T.TypeMap
typemap_RegisterChannelCP_args = Map.fromList [(2,("cpId",T.T_STRING)),(3,("registerPassword",T.T_STRING))]
default_RegisterChannelCP_args :: RegisterChannelCP_args
default_RegisterChannelCP_args = RegisterChannelCP_args{
  registerChannelCP_args_cpId = "",
  registerChannelCP_args_registerPassword = ""}
data RegisterChannelCP_result = RegisterChannelCP_result  { registerChannelCP_result_success :: LT.Text
  , registerChannelCP_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_result_success record   `H.hashWithSalt` registerChannelCP_result_e record  
instance QC.Arbitrary RegisterChannelCP_result where 
  arbitrary = M.liftM RegisterChannelCP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj}
    , if obj == default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj}
    ]
from_RegisterChannelCP_result :: RegisterChannelCP_result -> T.ThriftVal
from_RegisterChannelCP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10164 -> (1, ("e",from_TalkException _v10164))) <$> registerChannelCP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10164 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10164))) $ registerChannelCP_result_success record
    , (\_v10164 -> (1, ("e",from_TalkException _v10164))) <$> registerChannelCP_result_e record
    ]
    )
write_RegisterChannelCP_result :: T.Protocol p => p -> RegisterChannelCP_result -> P.IO ()
write_RegisterChannelCP_result oprot record = T.writeVal oprot $ from_RegisterChannelCP_result record
encode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> RegisterChannelCP_result -> LBS.ByteString
encode_RegisterChannelCP_result oprot record = T.serializeVal oprot $ from_RegisterChannelCP_result record
to_RegisterChannelCP_result :: T.ThriftVal -> RegisterChannelCP_result
to_RegisterChannelCP_result (T.TStruct fields) = RegisterChannelCP_result{
  registerChannelCP_result_success = P.maybe (registerChannelCP_result_success default_RegisterChannelCP_result) (\(_,_val10166) -> (case _val10166 of {T.TString _val10167 -> E.decodeUtf8 _val10167; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerChannelCP_result_e = P.maybe (P.Nothing) (\(_,_val10166) -> P.Just (case _val10166 of {T.TStruct _val10168 -> (to_TalkException (T.TStruct _val10168)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterChannelCP_result _ = P.error "not a struct"
read_RegisterChannelCP_result :: T.Protocol p => p -> P.IO RegisterChannelCP_result
read_RegisterChannelCP_result iprot = to_RegisterChannelCP_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result)
decode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_result
decode_RegisterChannelCP_result iprot bs = to_RegisterChannelCP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result) bs
typemap_RegisterChannelCP_result :: T.TypeMap
typemap_RegisterChannelCP_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterChannelCP_result :: RegisterChannelCP_result
default_RegisterChannelCP_result = RegisterChannelCP_result{
  registerChannelCP_result_success = "",
  registerChannelCP_result_e = P.Nothing}
data ReserveCallCreditPurchase_args = ReserveCallCreditPurchase_args  { reserveCallCreditPurchase_args_request :: CoinPurchaseReservation
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCallCreditPurchase_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCallCreditPurchase_args_request record  
instance QC.Arbitrary ReserveCallCreditPurchase_args where 
  arbitrary = M.liftM ReserveCallCreditPurchase_args (QC.arbitrary)
  shrink obj | obj == default_ReserveCallCreditPurchase_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCallCreditPurchase_args{reserveCallCreditPurchase_args_request = reserveCallCreditPurchase_args_request obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_args{reserveCallCreditPurchase_args_request = reserveCallCreditPurchase_args_request obj}
    ]
from_ReserveCallCreditPurchase_args :: ReserveCallCreditPurchase_args -> T.ThriftVal
from_ReserveCallCreditPurchase_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10171 -> P.Just (2, ("request",from_CoinPurchaseReservation _v10171))) $ reserveCallCreditPurchase_args_request record
  ]
write_ReserveCallCreditPurchase_args :: T.Protocol p => p -> ReserveCallCreditPurchase_args -> P.IO ()
write_ReserveCallCreditPurchase_args oprot record = T.writeVal oprot $ from_ReserveCallCreditPurchase_args record
encode_ReserveCallCreditPurchase_args :: T.StatelessProtocol p => p -> ReserveCallCreditPurchase_args -> LBS.ByteString
encode_ReserveCallCreditPurchase_args oprot record = T.serializeVal oprot $ from_ReserveCallCreditPurchase_args record
to_ReserveCallCreditPurchase_args :: T.ThriftVal -> ReserveCallCreditPurchase_args
to_ReserveCallCreditPurchase_args (T.TStruct fields) = ReserveCallCreditPurchase_args{
  reserveCallCreditPurchase_args_request = P.maybe (reserveCallCreditPurchase_args_request default_ReserveCallCreditPurchase_args) (\(_,_val10173) -> (case _val10173 of {T.TStruct _val10174 -> (to_CoinPurchaseReservation (T.TStruct _val10174)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ReserveCallCreditPurchase_args _ = P.error "not a struct"
read_ReserveCallCreditPurchase_args :: T.Protocol p => p -> P.IO ReserveCallCreditPurchase_args
read_ReserveCallCreditPurchase_args iprot = to_ReserveCallCreditPurchase_args <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_args)
decode_ReserveCallCreditPurchase_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCallCreditPurchase_args
decode_ReserveCallCreditPurchase_args iprot bs = to_ReserveCallCreditPurchase_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_args) bs
typemap_ReserveCallCreditPurchase_args :: T.TypeMap
typemap_ReserveCallCreditPurchase_args = Map.fromList [(2,("request",(T.T_STRUCT typemap_CoinPurchaseReservation)))]
default_ReserveCallCreditPurchase_args :: ReserveCallCreditPurchase_args
default_ReserveCallCreditPurchase_args = ReserveCallCreditPurchase_args{
  reserveCallCreditPurchase_args_request = default_CoinPurchaseReservation}
data ReserveCallCreditPurchase_result = ReserveCallCreditPurchase_result  { reserveCallCreditPurchase_result_success :: PaymentReservationResult
  , reserveCallCreditPurchase_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ReserveCallCreditPurchase_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` reserveCallCreditPurchase_result_success record   `H.hashWithSalt` reserveCallCreditPurchase_result_e record  
instance QC.Arbitrary ReserveCallCreditPurchase_result where 
  arbitrary = M.liftM ReserveCallCreditPurchase_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ReserveCallCreditPurchase_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = reserveCallCreditPurchase_result_success obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = reserveCallCreditPurchase_result_success obj}
    , if obj == default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = reserveCallCreditPurchase_result_e obj} then P.Nothing else P.Just $ default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = reserveCallCreditPurchase_result_e obj}
    ]
from_ReserveCallCreditPurchase_result :: ReserveCallCreditPurchase_result -> T.ThriftVal
from_ReserveCallCreditPurchase_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10177 -> (1, ("e",from_TalkException _v10177))) <$> reserveCallCreditPurchase_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10177 -> P.Just (0, ("success",from_PaymentReservationResult _v10177))) $ reserveCallCreditPurchase_result_success record
    , (\_v10177 -> (1, ("e",from_TalkException _v10177))) <$> reserveCallCreditPurchase_result_e record
    ]
    )
write_ReserveCallCreditPurchase_result :: T.Protocol p => p -> ReserveCallCreditPurchase_result -> P.IO ()
write_ReserveCallCreditPurchase_result oprot record = T.writeVal oprot $ from_ReserveCallCreditPurchase_result record
encode_ReserveCallCreditPurchase_result :: T.StatelessProtocol p => p -> ReserveCallCreditPurchase_result -> LBS.ByteString
encode_ReserveCallCreditPurchase_result oprot record = T.serializeVal oprot $ from_ReserveCallCreditPurchase_result record
to_ReserveCallCreditPurchase_result :: T.ThriftVal -> ReserveCallCreditPurchase_result
to_ReserveCallCreditPurchase_result (T.TStruct fields) = ReserveCallCreditPurchase_result{
  reserveCallCreditPurchase_result_success = P.maybe (reserveCallCreditPurchase_result_success default_ReserveCallCreditPurchase_result) (\(_,_val10179) -> (case _val10179 of {T.TStruct _val10180 -> (to_PaymentReservationResult (T.TStruct _val10180)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  reserveCallCreditPurchase_result_e = P.maybe (P.Nothing) (\(_,_val10179) -> P.Just (case _val10179 of {T.TStruct _val10181 -> (to_TalkException (T.TStruct _val10181)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ReserveCallCreditPurchase_result _ = P.error "not a struct"
read_ReserveCallCreditPurchase_result :: T.Protocol p => p -> P.IO ReserveCallCreditPurchase_result
read_ReserveCallCreditPurchase_result iprot = to_ReserveCallCreditPurchase_result <$> T.readVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_result)
decode_ReserveCallCreditPurchase_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ReserveCallCreditPurchase_result
decode_ReserveCallCreditPurchase_result iprot bs = to_ReserveCallCreditPurchase_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ReserveCallCreditPurchase_result) bs
typemap_ReserveCallCreditPurchase_result :: T.TypeMap
typemap_ReserveCallCreditPurchase_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaymentReservationResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ReserveCallCreditPurchase_result :: ReserveCallCreditPurchase_result
default_ReserveCallCreditPurchase_result = ReserveCallCreditPurchase_result{
  reserveCallCreditPurchase_result_success = default_PaymentReservationResult,
  reserveCallCreditPurchase_result_e = P.Nothing}
data AcquirePaidCallCurrencyExchangeRate_args = AcquirePaidCallCurrencyExchangeRate_args  { acquirePaidCallCurrencyExchangeRate_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallCurrencyExchangeRate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_args_language record  
instance QC.Arbitrary AcquirePaidCallCurrencyExchangeRate_args where 
  arbitrary = M.liftM AcquirePaidCallCurrencyExchangeRate_args (QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallCurrencyExchangeRate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallCurrencyExchangeRate_args{acquirePaidCallCurrencyExchangeRate_args_language = acquirePaidCallCurrencyExchangeRate_args_language obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_args{acquirePaidCallCurrencyExchangeRate_args_language = acquirePaidCallCurrencyExchangeRate_args_language obj}
    ]
from_AcquirePaidCallCurrencyExchangeRate_args :: AcquirePaidCallCurrencyExchangeRate_args -> T.ThriftVal
from_AcquirePaidCallCurrencyExchangeRate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10184 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v10184))) $ acquirePaidCallCurrencyExchangeRate_args_language record
  ]
write_AcquirePaidCallCurrencyExchangeRate_args :: T.Protocol p => p -> AcquirePaidCallCurrencyExchangeRate_args -> P.IO ()
write_AcquirePaidCallCurrencyExchangeRate_args oprot record = T.writeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_args record
encode_AcquirePaidCallCurrencyExchangeRate_args :: T.StatelessProtocol p => p -> AcquirePaidCallCurrencyExchangeRate_args -> LBS.ByteString
encode_AcquirePaidCallCurrencyExchangeRate_args oprot record = T.serializeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_args record
to_AcquirePaidCallCurrencyExchangeRate_args :: T.ThriftVal -> AcquirePaidCallCurrencyExchangeRate_args
to_AcquirePaidCallCurrencyExchangeRate_args (T.TStruct fields) = AcquirePaidCallCurrencyExchangeRate_args{
  acquirePaidCallCurrencyExchangeRate_args_language = P.maybe (acquirePaidCallCurrencyExchangeRate_args_language default_AcquirePaidCallCurrencyExchangeRate_args) (\(_,_val10186) -> (case _val10186 of {T.TString _val10187 -> E.decodeUtf8 _val10187; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AcquirePaidCallCurrencyExchangeRate_args _ = P.error "not a struct"
read_AcquirePaidCallCurrencyExchangeRate_args :: T.Protocol p => p -> P.IO AcquirePaidCallCurrencyExchangeRate_args
read_AcquirePaidCallCurrencyExchangeRate_args iprot = to_AcquirePaidCallCurrencyExchangeRate_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_args)
decode_AcquirePaidCallCurrencyExchangeRate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallCurrencyExchangeRate_args
decode_AcquirePaidCallCurrencyExchangeRate_args iprot bs = to_AcquirePaidCallCurrencyExchangeRate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_args) bs
typemap_AcquirePaidCallCurrencyExchangeRate_args :: T.TypeMap
typemap_AcquirePaidCallCurrencyExchangeRate_args = Map.fromList [(2,("language",T.T_STRING))]
default_AcquirePaidCallCurrencyExchangeRate_args :: AcquirePaidCallCurrencyExchangeRate_args
default_AcquirePaidCallCurrencyExchangeRate_args = AcquirePaidCallCurrencyExchangeRate_args{
  acquirePaidCallCurrencyExchangeRate_args_language = ""}
data AcquirePaidCallCurrencyExchangeRate_result = AcquirePaidCallCurrencyExchangeRate_result  { acquirePaidCallCurrencyExchangeRate_result_success :: (Vector.Vector PaidCallCurrencyExchangeRate)
  , acquirePaidCallCurrencyExchangeRate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquirePaidCallCurrencyExchangeRate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_result_success record   `H.hashWithSalt` acquirePaidCallCurrencyExchangeRate_result_e record  
instance QC.Arbitrary AcquirePaidCallCurrencyExchangeRate_result where 
  arbitrary = M.liftM AcquirePaidCallCurrencyExchangeRate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquirePaidCallCurrencyExchangeRate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = acquirePaidCallCurrencyExchangeRate_result_success obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = acquirePaidCallCurrencyExchangeRate_result_success obj}
    , if obj == default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = acquirePaidCallCurrencyExchangeRate_result_e obj} then P.Nothing else P.Just $ default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = acquirePaidCallCurrencyExchangeRate_result_e obj}
    ]
from_AcquirePaidCallCurrencyExchangeRate_result :: AcquirePaidCallCurrencyExchangeRate_result -> T.ThriftVal
from_AcquirePaidCallCurrencyExchangeRate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10190 -> (1, ("e",from_TalkException _v10190))) <$> acquirePaidCallCurrencyExchangeRate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10190 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate) $ P.map (\_v10192 -> from_PaidCallCurrencyExchangeRate _v10192) $ Vector.toList _v10190))) $ acquirePaidCallCurrencyExchangeRate_result_success record
    , (\_v10190 -> (1, ("e",from_TalkException _v10190))) <$> acquirePaidCallCurrencyExchangeRate_result_e record
    ]
    )
write_AcquirePaidCallCurrencyExchangeRate_result :: T.Protocol p => p -> AcquirePaidCallCurrencyExchangeRate_result -> P.IO ()
write_AcquirePaidCallCurrencyExchangeRate_result oprot record = T.writeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_result record
encode_AcquirePaidCallCurrencyExchangeRate_result :: T.StatelessProtocol p => p -> AcquirePaidCallCurrencyExchangeRate_result -> LBS.ByteString
encode_AcquirePaidCallCurrencyExchangeRate_result oprot record = T.serializeVal oprot $ from_AcquirePaidCallCurrencyExchangeRate_result record
to_AcquirePaidCallCurrencyExchangeRate_result :: T.ThriftVal -> AcquirePaidCallCurrencyExchangeRate_result
to_AcquirePaidCallCurrencyExchangeRate_result (T.TStruct fields) = AcquirePaidCallCurrencyExchangeRate_result{
  acquirePaidCallCurrencyExchangeRate_result_success = P.maybe (acquirePaidCallCurrencyExchangeRate_result_success default_AcquirePaidCallCurrencyExchangeRate_result) (\(_,_val10194) -> (case _val10194 of {T.TList _ _val10195 -> (Vector.fromList $ P.map (\_v10196 -> (case _v10196 of {T.TStruct _val10197 -> (to_PaidCallCurrencyExchangeRate (T.TStruct _val10197)); _ -> P.error "wrong type"})) _val10195); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquirePaidCallCurrencyExchangeRate_result_e = P.maybe (P.Nothing) (\(_,_val10194) -> P.Just (case _val10194 of {T.TStruct _val10198 -> (to_TalkException (T.TStruct _val10198)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquirePaidCallCurrencyExchangeRate_result _ = P.error "not a struct"
read_AcquirePaidCallCurrencyExchangeRate_result :: T.Protocol p => p -> P.IO AcquirePaidCallCurrencyExchangeRate_result
read_AcquirePaidCallCurrencyExchangeRate_result iprot = to_AcquirePaidCallCurrencyExchangeRate_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_result)
decode_AcquirePaidCallCurrencyExchangeRate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquirePaidCallCurrencyExchangeRate_result
decode_AcquirePaidCallCurrencyExchangeRate_result iprot bs = to_AcquirePaidCallCurrencyExchangeRate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquirePaidCallCurrencyExchangeRate_result) bs
typemap_AcquirePaidCallCurrencyExchangeRate_result :: T.TypeMap
typemap_AcquirePaidCallCurrencyExchangeRate_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallCurrencyExchangeRate)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquirePaidCallCurrencyExchangeRate_result :: AcquirePaidCallCurrencyExchangeRate_result
default_AcquirePaidCallCurrencyExchangeRate_result = AcquirePaidCallCurrencyExchangeRate_result{
  acquirePaidCallCurrencyExchangeRate_result_success = Vector.empty,
  acquirePaidCallCurrencyExchangeRate_result_e = P.Nothing}
data GetRoomMemberMidsForAppPlatform_args = GetRoomMemberMidsForAppPlatform_args  { getRoomMemberMidsForAppPlatform_args_roomId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomMemberMidsForAppPlatform_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_args_roomId record  
instance QC.Arbitrary GetRoomMemberMidsForAppPlatform_args where 
  arbitrary = M.liftM GetRoomMemberMidsForAppPlatform_args (QC.arbitrary)
  shrink obj | obj == default_GetRoomMemberMidsForAppPlatform_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomMemberMidsForAppPlatform_args{getRoomMemberMidsForAppPlatform_args_roomId = getRoomMemberMidsForAppPlatform_args_roomId obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_args{getRoomMemberMidsForAppPlatform_args_roomId = getRoomMemberMidsForAppPlatform_args_roomId obj}
    ]
from_GetRoomMemberMidsForAppPlatform_args :: GetRoomMemberMidsForAppPlatform_args -> T.ThriftVal
from_GetRoomMemberMidsForAppPlatform_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10201 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10201))) $ getRoomMemberMidsForAppPlatform_args_roomId record
  ]
write_GetRoomMemberMidsForAppPlatform_args :: T.Protocol p => p -> GetRoomMemberMidsForAppPlatform_args -> P.IO ()
write_GetRoomMemberMidsForAppPlatform_args oprot record = T.writeVal oprot $ from_GetRoomMemberMidsForAppPlatform_args record
encode_GetRoomMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> GetRoomMemberMidsForAppPlatform_args -> LBS.ByteString
encode_GetRoomMemberMidsForAppPlatform_args oprot record = T.serializeVal oprot $ from_GetRoomMemberMidsForAppPlatform_args record
to_GetRoomMemberMidsForAppPlatform_args :: T.ThriftVal -> GetRoomMemberMidsForAppPlatform_args
to_GetRoomMemberMidsForAppPlatform_args (T.TStruct fields) = GetRoomMemberMidsForAppPlatform_args{
  getRoomMemberMidsForAppPlatform_args_roomId = P.maybe (getRoomMemberMidsForAppPlatform_args_roomId default_GetRoomMemberMidsForAppPlatform_args) (\(_,_val10203) -> (case _val10203 of {T.TString _val10204 -> E.decodeUtf8 _val10204; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomMemberMidsForAppPlatform_args _ = P.error "not a struct"
read_GetRoomMemberMidsForAppPlatform_args :: T.Protocol p => p -> P.IO GetRoomMemberMidsForAppPlatform_args
read_GetRoomMemberMidsForAppPlatform_args iprot = to_GetRoomMemberMidsForAppPlatform_args <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_args)
decode_GetRoomMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomMemberMidsForAppPlatform_args
decode_GetRoomMemberMidsForAppPlatform_args iprot bs = to_GetRoomMemberMidsForAppPlatform_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_args) bs
typemap_GetRoomMemberMidsForAppPlatform_args :: T.TypeMap
typemap_GetRoomMemberMidsForAppPlatform_args = Map.fromList [(1,("roomId",T.T_STRING))]
default_GetRoomMemberMidsForAppPlatform_args :: GetRoomMemberMidsForAppPlatform_args
default_GetRoomMemberMidsForAppPlatform_args = GetRoomMemberMidsForAppPlatform_args{
  getRoomMemberMidsForAppPlatform_args_roomId = ""}
data GetRoomMemberMidsForAppPlatform_result = GetRoomMemberMidsForAppPlatform_result  { getRoomMemberMidsForAppPlatform_result_success :: (Vector.Vector LT.Text)
  , getRoomMemberMidsForAppPlatform_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetRoomMemberMidsForAppPlatform_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_result_success record   `H.hashWithSalt` getRoomMemberMidsForAppPlatform_result_e record  
instance QC.Arbitrary GetRoomMemberMidsForAppPlatform_result where 
  arbitrary = M.liftM GetRoomMemberMidsForAppPlatform_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetRoomMemberMidsForAppPlatform_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = getRoomMemberMidsForAppPlatform_result_success obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = getRoomMemberMidsForAppPlatform_result_success obj}
    , if obj == default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = getRoomMemberMidsForAppPlatform_result_e obj} then P.Nothing else P.Just $ default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = getRoomMemberMidsForAppPlatform_result_e obj}
    ]
from_GetRoomMemberMidsForAppPlatform_result :: GetRoomMemberMidsForAppPlatform_result -> T.ThriftVal
from_GetRoomMemberMidsForAppPlatform_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10207 -> (1, ("e",from_TalkException _v10207))) <$> getRoomMemberMidsForAppPlatform_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10207 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10209 -> T.TString $ E.encodeUtf8 _v10209) $ Vector.toList _v10207))) $ getRoomMemberMidsForAppPlatform_result_success record
    , (\_v10207 -> (1, ("e",from_TalkException _v10207))) <$> getRoomMemberMidsForAppPlatform_result_e record
    ]
    )
write_GetRoomMemberMidsForAppPlatform_result :: T.Protocol p => p -> GetRoomMemberMidsForAppPlatform_result -> P.IO ()
write_GetRoomMemberMidsForAppPlatform_result oprot record = T.writeVal oprot $ from_GetRoomMemberMidsForAppPlatform_result record
encode_GetRoomMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> GetRoomMemberMidsForAppPlatform_result -> LBS.ByteString
encode_GetRoomMemberMidsForAppPlatform_result oprot record = T.serializeVal oprot $ from_GetRoomMemberMidsForAppPlatform_result record
to_GetRoomMemberMidsForAppPlatform_result :: T.ThriftVal -> GetRoomMemberMidsForAppPlatform_result
to_GetRoomMemberMidsForAppPlatform_result (T.TStruct fields) = GetRoomMemberMidsForAppPlatform_result{
  getRoomMemberMidsForAppPlatform_result_success = P.maybe (getRoomMemberMidsForAppPlatform_result_success default_GetRoomMemberMidsForAppPlatform_result) (\(_,_val10211) -> (case _val10211 of {T.TList _ _val10212 -> (Vector.fromList $ P.map (\_v10213 -> (case _v10213 of {T.TString _val10214 -> E.decodeUtf8 _val10214; _ -> P.error "wrong type"})) _val10212); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getRoomMemberMidsForAppPlatform_result_e = P.maybe (P.Nothing) (\(_,_val10211) -> P.Just (case _val10211 of {T.TStruct _val10215 -> (to_TalkException (T.TStruct _val10215)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetRoomMemberMidsForAppPlatform_result _ = P.error "not a struct"
read_GetRoomMemberMidsForAppPlatform_result :: T.Protocol p => p -> P.IO GetRoomMemberMidsForAppPlatform_result
read_GetRoomMemberMidsForAppPlatform_result iprot = to_GetRoomMemberMidsForAppPlatform_result <$> T.readVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_result)
decode_GetRoomMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetRoomMemberMidsForAppPlatform_result
decode_GetRoomMemberMidsForAppPlatform_result iprot bs = to_GetRoomMemberMidsForAppPlatform_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetRoomMemberMidsForAppPlatform_result) bs
typemap_GetRoomMemberMidsForAppPlatform_result :: T.TypeMap
typemap_GetRoomMemberMidsForAppPlatform_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetRoomMemberMidsForAppPlatform_result :: GetRoomMemberMidsForAppPlatform_result
default_GetRoomMemberMidsForAppPlatform_result = GetRoomMemberMidsForAppPlatform_result{
  getRoomMemberMidsForAppPlatform_result_success = Vector.empty,
  getRoomMemberMidsForAppPlatform_result_e = P.Nothing}
data GetPaidCallBalanceList_args = GetPaidCallBalanceList_args  { getPaidCallBalanceList_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallBalanceList_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallBalanceList_args_language record  
instance QC.Arbitrary GetPaidCallBalanceList_args where 
  arbitrary = M.liftM GetPaidCallBalanceList_args (QC.arbitrary)
  shrink obj | obj == default_GetPaidCallBalanceList_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallBalanceList_args{getPaidCallBalanceList_args_language = getPaidCallBalanceList_args_language obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_args{getPaidCallBalanceList_args_language = getPaidCallBalanceList_args_language obj}
    ]
from_GetPaidCallBalanceList_args :: GetPaidCallBalanceList_args -> T.ThriftVal
from_GetPaidCallBalanceList_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10218 -> P.Just (2, ("language",T.TString $ E.encodeUtf8 _v10218))) $ getPaidCallBalanceList_args_language record
  ]
write_GetPaidCallBalanceList_args :: T.Protocol p => p -> GetPaidCallBalanceList_args -> P.IO ()
write_GetPaidCallBalanceList_args oprot record = T.writeVal oprot $ from_GetPaidCallBalanceList_args record
encode_GetPaidCallBalanceList_args :: T.StatelessProtocol p => p -> GetPaidCallBalanceList_args -> LBS.ByteString
encode_GetPaidCallBalanceList_args oprot record = T.serializeVal oprot $ from_GetPaidCallBalanceList_args record
to_GetPaidCallBalanceList_args :: T.ThriftVal -> GetPaidCallBalanceList_args
to_GetPaidCallBalanceList_args (T.TStruct fields) = GetPaidCallBalanceList_args{
  getPaidCallBalanceList_args_language = P.maybe (getPaidCallBalanceList_args_language default_GetPaidCallBalanceList_args) (\(_,_val10220) -> (case _val10220 of {T.TString _val10221 -> E.decodeUtf8 _val10221; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPaidCallBalanceList_args _ = P.error "not a struct"
read_GetPaidCallBalanceList_args :: T.Protocol p => p -> P.IO GetPaidCallBalanceList_args
read_GetPaidCallBalanceList_args iprot = to_GetPaidCallBalanceList_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_args)
decode_GetPaidCallBalanceList_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallBalanceList_args
decode_GetPaidCallBalanceList_args iprot bs = to_GetPaidCallBalanceList_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_args) bs
typemap_GetPaidCallBalanceList_args :: T.TypeMap
typemap_GetPaidCallBalanceList_args = Map.fromList [(2,("language",T.T_STRING))]
default_GetPaidCallBalanceList_args :: GetPaidCallBalanceList_args
default_GetPaidCallBalanceList_args = GetPaidCallBalanceList_args{
  getPaidCallBalanceList_args_language = ""}
data GetPaidCallBalanceList_result = GetPaidCallBalanceList_result  { getPaidCallBalanceList_result_success :: (Vector.Vector PaidCallBalance)
  , getPaidCallBalanceList_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallBalanceList_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallBalanceList_result_success record   `H.hashWithSalt` getPaidCallBalanceList_result_e record  
instance QC.Arbitrary GetPaidCallBalanceList_result where 
  arbitrary = M.liftM GetPaidCallBalanceList_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallBalanceList_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = getPaidCallBalanceList_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = getPaidCallBalanceList_result_success obj}
    , if obj == default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = getPaidCallBalanceList_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = getPaidCallBalanceList_result_e obj}
    ]
from_GetPaidCallBalanceList_result :: GetPaidCallBalanceList_result -> T.ThriftVal
from_GetPaidCallBalanceList_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10224 -> (1, ("e",from_TalkException _v10224))) <$> getPaidCallBalanceList_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10224 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallBalance) $ P.map (\_v10226 -> from_PaidCallBalance _v10226) $ Vector.toList _v10224))) $ getPaidCallBalanceList_result_success record
    , (\_v10224 -> (1, ("e",from_TalkException _v10224))) <$> getPaidCallBalanceList_result_e record
    ]
    )
write_GetPaidCallBalanceList_result :: T.Protocol p => p -> GetPaidCallBalanceList_result -> P.IO ()
write_GetPaidCallBalanceList_result oprot record = T.writeVal oprot $ from_GetPaidCallBalanceList_result record
encode_GetPaidCallBalanceList_result :: T.StatelessProtocol p => p -> GetPaidCallBalanceList_result -> LBS.ByteString
encode_GetPaidCallBalanceList_result oprot record = T.serializeVal oprot $ from_GetPaidCallBalanceList_result record
to_GetPaidCallBalanceList_result :: T.ThriftVal -> GetPaidCallBalanceList_result
to_GetPaidCallBalanceList_result (T.TStruct fields) = GetPaidCallBalanceList_result{
  getPaidCallBalanceList_result_success = P.maybe (getPaidCallBalanceList_result_success default_GetPaidCallBalanceList_result) (\(_,_val10228) -> (case _val10228 of {T.TList _ _val10229 -> (Vector.fromList $ P.map (\_v10230 -> (case _v10230 of {T.TStruct _val10231 -> (to_PaidCallBalance (T.TStruct _val10231)); _ -> P.error "wrong type"})) _val10229); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallBalanceList_result_e = P.maybe (P.Nothing) (\(_,_val10228) -> P.Just (case _val10228 of {T.TStruct _val10232 -> (to_TalkException (T.TStruct _val10232)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallBalanceList_result _ = P.error "not a struct"
read_GetPaidCallBalanceList_result :: T.Protocol p => p -> P.IO GetPaidCallBalanceList_result
read_GetPaidCallBalanceList_result iprot = to_GetPaidCallBalanceList_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_result)
decode_GetPaidCallBalanceList_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallBalanceList_result
decode_GetPaidCallBalanceList_result iprot bs = to_GetPaidCallBalanceList_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallBalanceList_result) bs
typemap_GetPaidCallBalanceList_result :: T.TypeMap
typemap_GetPaidCallBalanceList_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallBalance)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallBalanceList_result :: GetPaidCallBalanceList_result
default_GetPaidCallBalanceList_result = GetPaidCallBalanceList_result{
  getPaidCallBalanceList_result_success = Vector.empty,
  getPaidCallBalanceList_result_e = P.Nothing}
data GetPersonalInfos_args = GetPersonalInfos_args  { getPersonalInfos_args_requiredPersonalInfos :: (Set.HashSet PersonalInfo)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPersonalInfos_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPersonalInfos_args_requiredPersonalInfos record  
instance QC.Arbitrary GetPersonalInfos_args where 
  arbitrary = M.liftM GetPersonalInfos_args (QC.arbitrary)
  shrink obj | obj == default_GetPersonalInfos_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPersonalInfos_args{getPersonalInfos_args_requiredPersonalInfos = getPersonalInfos_args_requiredPersonalInfos obj} then P.Nothing else P.Just $ default_GetPersonalInfos_args{getPersonalInfos_args_requiredPersonalInfos = getPersonalInfos_args_requiredPersonalInfos obj}
    ]
from_GetPersonalInfos_args :: GetPersonalInfos_args -> T.ThriftVal
from_GetPersonalInfos_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10235 -> P.Just (1, ("requiredPersonalInfos",T.TSet T.T_I32 $ P.map (\_v10237 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v10237) $ Set.toList _v10235))) $ getPersonalInfos_args_requiredPersonalInfos record
  ]
write_GetPersonalInfos_args :: T.Protocol p => p -> GetPersonalInfos_args -> P.IO ()
write_GetPersonalInfos_args oprot record = T.writeVal oprot $ from_GetPersonalInfos_args record
encode_GetPersonalInfos_args :: T.StatelessProtocol p => p -> GetPersonalInfos_args -> LBS.ByteString
encode_GetPersonalInfos_args oprot record = T.serializeVal oprot $ from_GetPersonalInfos_args record
to_GetPersonalInfos_args :: T.ThriftVal -> GetPersonalInfos_args
to_GetPersonalInfos_args (T.TStruct fields) = GetPersonalInfos_args{
  getPersonalInfos_args_requiredPersonalInfos = P.maybe (getPersonalInfos_args_requiredPersonalInfos default_GetPersonalInfos_args) (\(_,_val10239) -> (case _val10239 of {T.TSet _ _val10240 -> (Set.fromList $ P.map (\_v10241 -> (case _v10241 of {T.TI32 _val10242 -> P.toEnum $ P.fromIntegral _val10242; _ -> P.error "wrong type"})) _val10240); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPersonalInfos_args _ = P.error "not a struct"
read_GetPersonalInfos_args :: T.Protocol p => p -> P.IO GetPersonalInfos_args
read_GetPersonalInfos_args iprot = to_GetPersonalInfos_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPersonalInfos_args)
decode_GetPersonalInfos_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPersonalInfos_args
decode_GetPersonalInfos_args iprot bs = to_GetPersonalInfos_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPersonalInfos_args) bs
typemap_GetPersonalInfos_args :: T.TypeMap
typemap_GetPersonalInfos_args = Map.fromList [(1,("requiredPersonalInfos",(T.T_SET T.T_I32)))]
default_GetPersonalInfos_args :: GetPersonalInfos_args
default_GetPersonalInfos_args = GetPersonalInfos_args{
  getPersonalInfos_args_requiredPersonalInfos = Set.empty}
data GetPersonalInfos_result = GetPersonalInfos_result  { getPersonalInfos_result_success :: (Map.HashMap PersonalInfo LT.Text)
  , getPersonalInfos_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPersonalInfos_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPersonalInfos_result_success record   `H.hashWithSalt` getPersonalInfos_result_e record  
instance QC.Arbitrary GetPersonalInfos_result where 
  arbitrary = M.liftM GetPersonalInfos_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPersonalInfos_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPersonalInfos_result{getPersonalInfos_result_success = getPersonalInfos_result_success obj} then P.Nothing else P.Just $ default_GetPersonalInfos_result{getPersonalInfos_result_success = getPersonalInfos_result_success obj}
    , if obj == default_GetPersonalInfos_result{getPersonalInfos_result_e = getPersonalInfos_result_e obj} then P.Nothing else P.Just $ default_GetPersonalInfos_result{getPersonalInfos_result_e = getPersonalInfos_result_e obj}
    ]
from_GetPersonalInfos_result :: GetPersonalInfos_result -> T.ThriftVal
from_GetPersonalInfos_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10245 -> (1, ("e",from_TalkException _v10245))) <$> getPersonalInfos_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10245 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k10246,_v10247) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k10246, T.TString $ E.encodeUtf8 _v10247)) $ Map.toList _v10245))) $ getPersonalInfos_result_success record
    , (\_v10245 -> (1, ("e",from_TalkException _v10245))) <$> getPersonalInfos_result_e record
    ]
    )
write_GetPersonalInfos_result :: T.Protocol p => p -> GetPersonalInfos_result -> P.IO ()
write_GetPersonalInfos_result oprot record = T.writeVal oprot $ from_GetPersonalInfos_result record
encode_GetPersonalInfos_result :: T.StatelessProtocol p => p -> GetPersonalInfos_result -> LBS.ByteString
encode_GetPersonalInfos_result oprot record = T.serializeVal oprot $ from_GetPersonalInfos_result record
to_GetPersonalInfos_result :: T.ThriftVal -> GetPersonalInfos_result
to_GetPersonalInfos_result (T.TStruct fields) = GetPersonalInfos_result{
  getPersonalInfos_result_success = P.maybe (getPersonalInfos_result_success default_GetPersonalInfos_result) (\(_,_val10249) -> (case _val10249 of {T.TMap _ _ _val10250 -> (Map.fromList $ P.map (\(_k10252,_v10251) -> ((case _k10252 of {T.TI32 _val10253 -> P.toEnum $ P.fromIntegral _val10253; _ -> P.error "wrong type"}),(case _v10251 of {T.TString _val10254 -> E.decodeUtf8 _val10254; _ -> P.error "wrong type"}))) _val10250); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPersonalInfos_result_e = P.maybe (P.Nothing) (\(_,_val10249) -> P.Just (case _val10249 of {T.TStruct _val10255 -> (to_TalkException (T.TStruct _val10255)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPersonalInfos_result _ = P.error "not a struct"
read_GetPersonalInfos_result :: T.Protocol p => p -> P.IO GetPersonalInfos_result
read_GetPersonalInfos_result iprot = to_GetPersonalInfos_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPersonalInfos_result)
decode_GetPersonalInfos_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPersonalInfos_result
decode_GetPersonalInfos_result iprot bs = to_GetPersonalInfos_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPersonalInfos_result) bs
typemap_GetPersonalInfos_result :: T.TypeMap
typemap_GetPersonalInfos_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPersonalInfos_result :: GetPersonalInfos_result
default_GetPersonalInfos_result = GetPersonalInfos_result{
  getPersonalInfos_result_success = Map.empty,
  getPersonalInfos_result_e = P.Nothing}
data GetPrimaryClientsForChannel_args = GetPrimaryClientsForChannel_args  { getPrimaryClientsForChannel_args_userMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientsForChannel_args_userMids record  
instance QC.Arbitrary GetPrimaryClientsForChannel_args where 
  arbitrary = M.liftM GetPrimaryClientsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientsForChannel_args{getPrimaryClientsForChannel_args_userMids = getPrimaryClientsForChannel_args_userMids obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_args{getPrimaryClientsForChannel_args_userMids = getPrimaryClientsForChannel_args_userMids obj}
    ]
from_GetPrimaryClientsForChannel_args :: GetPrimaryClientsForChannel_args -> T.ThriftVal
from_GetPrimaryClientsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10258 -> P.Just (1, ("userMids",T.TList T.T_STRING $ P.map (\_v10260 -> T.TString $ E.encodeUtf8 _v10260) $ Vector.toList _v10258))) $ getPrimaryClientsForChannel_args_userMids record
  ]
write_GetPrimaryClientsForChannel_args :: T.Protocol p => p -> GetPrimaryClientsForChannel_args -> P.IO ()
write_GetPrimaryClientsForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientsForChannel_args record
encode_GetPrimaryClientsForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientsForChannel_args -> LBS.ByteString
encode_GetPrimaryClientsForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientsForChannel_args record
to_GetPrimaryClientsForChannel_args :: T.ThriftVal -> GetPrimaryClientsForChannel_args
to_GetPrimaryClientsForChannel_args (T.TStruct fields) = GetPrimaryClientsForChannel_args{
  getPrimaryClientsForChannel_args_userMids = P.maybe (getPrimaryClientsForChannel_args_userMids default_GetPrimaryClientsForChannel_args) (\(_,_val10262) -> (case _val10262 of {T.TList _ _val10263 -> (Vector.fromList $ P.map (\_v10264 -> (case _v10264 of {T.TString _val10265 -> E.decodeUtf8 _val10265; _ -> P.error "wrong type"})) _val10263); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientsForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientsForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientsForChannel_args
read_GetPrimaryClientsForChannel_args iprot = to_GetPrimaryClientsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_args)
decode_GetPrimaryClientsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientsForChannel_args
decode_GetPrimaryClientsForChannel_args iprot bs = to_GetPrimaryClientsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_args) bs
typemap_GetPrimaryClientsForChannel_args :: T.TypeMap
typemap_GetPrimaryClientsForChannel_args = Map.fromList [(1,("userMids",(T.T_LIST T.T_STRING)))]
default_GetPrimaryClientsForChannel_args :: GetPrimaryClientsForChannel_args
default_GetPrimaryClientsForChannel_args = GetPrimaryClientsForChannel_args{
  getPrimaryClientsForChannel_args_userMids = Vector.empty}
data GetPrimaryClientsForChannel_result = GetPrimaryClientsForChannel_result  { getPrimaryClientsForChannel_result_success :: (Vector.Vector SimpleChannelClient)
  , getPrimaryClientsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientsForChannel_result_success record   `H.hashWithSalt` getPrimaryClientsForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientsForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = getPrimaryClientsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = getPrimaryClientsForChannel_result_success obj}
    , if obj == default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = getPrimaryClientsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = getPrimaryClientsForChannel_result_e obj}
    ]
from_GetPrimaryClientsForChannel_result :: GetPrimaryClientsForChannel_result -> T.ThriftVal
from_GetPrimaryClientsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10268 -> (1, ("e",from_TalkException _v10268))) <$> getPrimaryClientsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10268 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelClient) $ P.map (\_v10270 -> from_SimpleChannelClient _v10270) $ Vector.toList _v10268))) $ getPrimaryClientsForChannel_result_success record
    , (\_v10268 -> (1, ("e",from_TalkException _v10268))) <$> getPrimaryClientsForChannel_result_e record
    ]
    )
write_GetPrimaryClientsForChannel_result :: T.Protocol p => p -> GetPrimaryClientsForChannel_result -> P.IO ()
write_GetPrimaryClientsForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientsForChannel_result record
encode_GetPrimaryClientsForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientsForChannel_result -> LBS.ByteString
encode_GetPrimaryClientsForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientsForChannel_result record
to_GetPrimaryClientsForChannel_result :: T.ThriftVal -> GetPrimaryClientsForChannel_result
to_GetPrimaryClientsForChannel_result (T.TStruct fields) = GetPrimaryClientsForChannel_result{
  getPrimaryClientsForChannel_result_success = P.maybe (getPrimaryClientsForChannel_result_success default_GetPrimaryClientsForChannel_result) (\(_,_val10272) -> (case _val10272 of {T.TList _ _val10273 -> (Vector.fromList $ P.map (\_v10274 -> (case _v10274 of {T.TStruct _val10275 -> (to_SimpleChannelClient (T.TStruct _val10275)); _ -> P.error "wrong type"})) _val10273); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10272) -> P.Just (case _val10272 of {T.TStruct _val10276 -> (to_TalkException (T.TStruct _val10276)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientsForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientsForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientsForChannel_result
read_GetPrimaryClientsForChannel_result iprot = to_GetPrimaryClientsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_result)
decode_GetPrimaryClientsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientsForChannel_result
decode_GetPrimaryClientsForChannel_result iprot bs = to_GetPrimaryClientsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientsForChannel_result) bs
typemap_GetPrimaryClientsForChannel_result :: T.TypeMap
typemap_GetPrimaryClientsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelClient)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientsForChannel_result :: GetPrimaryClientsForChannel_result
default_GetPrimaryClientsForChannel_result = GetPrimaryClientsForChannel_result{
  getPrimaryClientsForChannel_result_success = Vector.empty,
  getPrimaryClientsForChannel_result_e = P.Nothing}
data AddBuddyToContact_args = AddBuddyToContact_args  { addBuddyToContact_args_buddyMid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddBuddyToContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addBuddyToContact_args_buddyMid record  
instance QC.Arbitrary AddBuddyToContact_args where 
  arbitrary = M.liftM AddBuddyToContact_args (QC.arbitrary)
  shrink obj | obj == default_AddBuddyToContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddBuddyToContact_args{addBuddyToContact_args_buddyMid = addBuddyToContact_args_buddyMid obj} then P.Nothing else P.Just $ default_AddBuddyToContact_args{addBuddyToContact_args_buddyMid = addBuddyToContact_args_buddyMid obj}
    ]
from_AddBuddyToContact_args :: AddBuddyToContact_args -> T.ThriftVal
from_AddBuddyToContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10279 -> P.Just (1, ("buddyMid",T.TString $ E.encodeUtf8 _v10279))) $ addBuddyToContact_args_buddyMid record
  ]
write_AddBuddyToContact_args :: T.Protocol p => p -> AddBuddyToContact_args -> P.IO ()
write_AddBuddyToContact_args oprot record = T.writeVal oprot $ from_AddBuddyToContact_args record
encode_AddBuddyToContact_args :: T.StatelessProtocol p => p -> AddBuddyToContact_args -> LBS.ByteString
encode_AddBuddyToContact_args oprot record = T.serializeVal oprot $ from_AddBuddyToContact_args record
to_AddBuddyToContact_args :: T.ThriftVal -> AddBuddyToContact_args
to_AddBuddyToContact_args (T.TStruct fields) = AddBuddyToContact_args{
  addBuddyToContact_args_buddyMid = P.maybe (addBuddyToContact_args_buddyMid default_AddBuddyToContact_args) (\(_,_val10281) -> (case _val10281 of {T.TString _val10282 -> E.decodeUtf8 _val10282; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddBuddyToContact_args _ = P.error "not a struct"
read_AddBuddyToContact_args :: T.Protocol p => p -> P.IO AddBuddyToContact_args
read_AddBuddyToContact_args iprot = to_AddBuddyToContact_args <$> T.readVal iprot (T.T_STRUCT typemap_AddBuddyToContact_args)
decode_AddBuddyToContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddBuddyToContact_args
decode_AddBuddyToContact_args iprot bs = to_AddBuddyToContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddBuddyToContact_args) bs
typemap_AddBuddyToContact_args :: T.TypeMap
typemap_AddBuddyToContact_args = Map.fromList [(1,("buddyMid",T.T_STRING))]
default_AddBuddyToContact_args :: AddBuddyToContact_args
default_AddBuddyToContact_args = AddBuddyToContact_args{
  addBuddyToContact_args_buddyMid = ""}
data AddBuddyToContact_result = AddBuddyToContact_result  { addBuddyToContact_result_success :: ContactTransition
  , addBuddyToContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddBuddyToContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addBuddyToContact_result_success record   `H.hashWithSalt` addBuddyToContact_result_e record  
instance QC.Arbitrary AddBuddyToContact_result where 
  arbitrary = M.liftM AddBuddyToContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddBuddyToContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddBuddyToContact_result{addBuddyToContact_result_success = addBuddyToContact_result_success obj} then P.Nothing else P.Just $ default_AddBuddyToContact_result{addBuddyToContact_result_success = addBuddyToContact_result_success obj}
    , if obj == default_AddBuddyToContact_result{addBuddyToContact_result_e = addBuddyToContact_result_e obj} then P.Nothing else P.Just $ default_AddBuddyToContact_result{addBuddyToContact_result_e = addBuddyToContact_result_e obj}
    ]
from_AddBuddyToContact_result :: AddBuddyToContact_result -> T.ThriftVal
from_AddBuddyToContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10285 -> (1, ("e",from_TalkException _v10285))) <$> addBuddyToContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10285 -> P.Just (0, ("success",from_ContactTransition _v10285))) $ addBuddyToContact_result_success record
    , (\_v10285 -> (1, ("e",from_TalkException _v10285))) <$> addBuddyToContact_result_e record
    ]
    )
write_AddBuddyToContact_result :: T.Protocol p => p -> AddBuddyToContact_result -> P.IO ()
write_AddBuddyToContact_result oprot record = T.writeVal oprot $ from_AddBuddyToContact_result record
encode_AddBuddyToContact_result :: T.StatelessProtocol p => p -> AddBuddyToContact_result -> LBS.ByteString
encode_AddBuddyToContact_result oprot record = T.serializeVal oprot $ from_AddBuddyToContact_result record
to_AddBuddyToContact_result :: T.ThriftVal -> AddBuddyToContact_result
to_AddBuddyToContact_result (T.TStruct fields) = AddBuddyToContact_result{
  addBuddyToContact_result_success = P.maybe (addBuddyToContact_result_success default_AddBuddyToContact_result) (\(_,_val10287) -> (case _val10287 of {T.TStruct _val10288 -> (to_ContactTransition (T.TStruct _val10288)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  addBuddyToContact_result_e = P.maybe (P.Nothing) (\(_,_val10287) -> P.Just (case _val10287 of {T.TStruct _val10289 -> (to_TalkException (T.TStruct _val10289)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddBuddyToContact_result _ = P.error "not a struct"
read_AddBuddyToContact_result :: T.Protocol p => p -> P.IO AddBuddyToContact_result
read_AddBuddyToContact_result iprot = to_AddBuddyToContact_result <$> T.readVal iprot (T.T_STRUCT typemap_AddBuddyToContact_result)
decode_AddBuddyToContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddBuddyToContact_result
decode_AddBuddyToContact_result iprot bs = to_AddBuddyToContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddBuddyToContact_result) bs
typemap_AddBuddyToContact_result :: T.TypeMap
typemap_AddBuddyToContact_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ContactTransition))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddBuddyToContact_result :: AddBuddyToContact_result
default_AddBuddyToContact_result = AddBuddyToContact_result{
  addBuddyToContact_result_success = default_ContactTransition,
  addBuddyToContact_result_e = P.Nothing}
data GetGroupMemberMidsForAppPlatform_args = GetGroupMemberMidsForAppPlatform_args  { getGroupMemberMidsForAppPlatform_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMidsForAppPlatform_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_args_groupId record  
instance QC.Arbitrary GetGroupMemberMidsForAppPlatform_args where 
  arbitrary = M.liftM GetGroupMemberMidsForAppPlatform_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMidsForAppPlatform_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMidsForAppPlatform_args{getGroupMemberMidsForAppPlatform_args_groupId = getGroupMemberMidsForAppPlatform_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_args{getGroupMemberMidsForAppPlatform_args_groupId = getGroupMemberMidsForAppPlatform_args_groupId obj}
    ]
from_GetGroupMemberMidsForAppPlatform_args :: GetGroupMemberMidsForAppPlatform_args -> T.ThriftVal
from_GetGroupMemberMidsForAppPlatform_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10292 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10292))) $ getGroupMemberMidsForAppPlatform_args_groupId record
  ]
write_GetGroupMemberMidsForAppPlatform_args :: T.Protocol p => p -> GetGroupMemberMidsForAppPlatform_args -> P.IO ()
write_GetGroupMemberMidsForAppPlatform_args oprot record = T.writeVal oprot $ from_GetGroupMemberMidsForAppPlatform_args record
encode_GetGroupMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> GetGroupMemberMidsForAppPlatform_args -> LBS.ByteString
encode_GetGroupMemberMidsForAppPlatform_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMidsForAppPlatform_args record
to_GetGroupMemberMidsForAppPlatform_args :: T.ThriftVal -> GetGroupMemberMidsForAppPlatform_args
to_GetGroupMemberMidsForAppPlatform_args (T.TStruct fields) = GetGroupMemberMidsForAppPlatform_args{
  getGroupMemberMidsForAppPlatform_args_groupId = P.maybe (getGroupMemberMidsForAppPlatform_args_groupId default_GetGroupMemberMidsForAppPlatform_args) (\(_,_val10294) -> (case _val10294 of {T.TString _val10295 -> E.decodeUtf8 _val10295; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMidsForAppPlatform_args _ = P.error "not a struct"
read_GetGroupMemberMidsForAppPlatform_args :: T.Protocol p => p -> P.IO GetGroupMemberMidsForAppPlatform_args
read_GetGroupMemberMidsForAppPlatform_args iprot = to_GetGroupMemberMidsForAppPlatform_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_args)
decode_GetGroupMemberMidsForAppPlatform_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMidsForAppPlatform_args
decode_GetGroupMemberMidsForAppPlatform_args iprot bs = to_GetGroupMemberMidsForAppPlatform_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_args) bs
typemap_GetGroupMemberMidsForAppPlatform_args :: T.TypeMap
typemap_GetGroupMemberMidsForAppPlatform_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMidsForAppPlatform_args :: GetGroupMemberMidsForAppPlatform_args
default_GetGroupMemberMidsForAppPlatform_args = GetGroupMemberMidsForAppPlatform_args{
  getGroupMemberMidsForAppPlatform_args_groupId = ""}
data GetGroupMemberMidsForAppPlatform_result = GetGroupMemberMidsForAppPlatform_result  { getGroupMemberMidsForAppPlatform_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMidsForAppPlatform_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMidsForAppPlatform_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_result_success record   `H.hashWithSalt` getGroupMemberMidsForAppPlatform_result_e record  
instance QC.Arbitrary GetGroupMemberMidsForAppPlatform_result where 
  arbitrary = M.liftM GetGroupMemberMidsForAppPlatform_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMidsForAppPlatform_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = getGroupMemberMidsForAppPlatform_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = getGroupMemberMidsForAppPlatform_result_success obj}
    , if obj == default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = getGroupMemberMidsForAppPlatform_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = getGroupMemberMidsForAppPlatform_result_e obj}
    ]
from_GetGroupMemberMidsForAppPlatform_result :: GetGroupMemberMidsForAppPlatform_result -> T.ThriftVal
from_GetGroupMemberMidsForAppPlatform_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10298 -> (1, ("e",from_TalkException _v10298))) <$> getGroupMemberMidsForAppPlatform_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10298 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10300 -> T.TString $ E.encodeUtf8 _v10300) $ Vector.toList _v10298))) $ getGroupMemberMidsForAppPlatform_result_success record
    , (\_v10298 -> (1, ("e",from_TalkException _v10298))) <$> getGroupMemberMidsForAppPlatform_result_e record
    ]
    )
write_GetGroupMemberMidsForAppPlatform_result :: T.Protocol p => p -> GetGroupMemberMidsForAppPlatform_result -> P.IO ()
write_GetGroupMemberMidsForAppPlatform_result oprot record = T.writeVal oprot $ from_GetGroupMemberMidsForAppPlatform_result record
encode_GetGroupMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> GetGroupMemberMidsForAppPlatform_result -> LBS.ByteString
encode_GetGroupMemberMidsForAppPlatform_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMidsForAppPlatform_result record
to_GetGroupMemberMidsForAppPlatform_result :: T.ThriftVal -> GetGroupMemberMidsForAppPlatform_result
to_GetGroupMemberMidsForAppPlatform_result (T.TStruct fields) = GetGroupMemberMidsForAppPlatform_result{
  getGroupMemberMidsForAppPlatform_result_success = P.maybe (getGroupMemberMidsForAppPlatform_result_success default_GetGroupMemberMidsForAppPlatform_result) (\(_,_val10302) -> (case _val10302 of {T.TList _ _val10303 -> (Vector.fromList $ P.map (\_v10304 -> (case _v10304 of {T.TString _val10305 -> E.decodeUtf8 _val10305; _ -> P.error "wrong type"})) _val10303); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMidsForAppPlatform_result_e = P.maybe (P.Nothing) (\(_,_val10302) -> P.Just (case _val10302 of {T.TStruct _val10306 -> (to_TalkException (T.TStruct _val10306)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMidsForAppPlatform_result _ = P.error "not a struct"
read_GetGroupMemberMidsForAppPlatform_result :: T.Protocol p => p -> P.IO GetGroupMemberMidsForAppPlatform_result
read_GetGroupMemberMidsForAppPlatform_result iprot = to_GetGroupMemberMidsForAppPlatform_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_result)
decode_GetGroupMemberMidsForAppPlatform_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMidsForAppPlatform_result
decode_GetGroupMemberMidsForAppPlatform_result iprot bs = to_GetGroupMemberMidsForAppPlatform_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMidsForAppPlatform_result) bs
typemap_GetGroupMemberMidsForAppPlatform_result :: T.TypeMap
typemap_GetGroupMemberMidsForAppPlatform_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMidsForAppPlatform_result :: GetGroupMemberMidsForAppPlatform_result
default_GetGroupMemberMidsForAppPlatform_result = GetGroupMemberMidsForAppPlatform_result{
  getGroupMemberMidsForAppPlatform_result_success = Vector.empty,
  getGroupMemberMidsForAppPlatform_result_e = P.Nothing}
data GetUserLanguage_args = GetUserLanguage_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserLanguage_args where 
  arbitrary = QC.elements [GetUserLanguage_args]
from_GetUserLanguage_args :: GetUserLanguage_args -> T.ThriftVal
from_GetUserLanguage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserLanguage_args :: T.Protocol p => p -> GetUserLanguage_args -> P.IO ()
write_GetUserLanguage_args oprot record = T.writeVal oprot $ from_GetUserLanguage_args record
encode_GetUserLanguage_args :: T.StatelessProtocol p => p -> GetUserLanguage_args -> LBS.ByteString
encode_GetUserLanguage_args oprot record = T.serializeVal oprot $ from_GetUserLanguage_args record
to_GetUserLanguage_args :: T.ThriftVal -> GetUserLanguage_args
to_GetUserLanguage_args (T.TStruct fields) = GetUserLanguage_args{

  }
to_GetUserLanguage_args _ = P.error "not a struct"
read_GetUserLanguage_args :: T.Protocol p => p -> P.IO GetUserLanguage_args
read_GetUserLanguage_args iprot = to_GetUserLanguage_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_args)
decode_GetUserLanguage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_args
decode_GetUserLanguage_args iprot bs = to_GetUserLanguage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_args) bs
typemap_GetUserLanguage_args :: T.TypeMap
typemap_GetUserLanguage_args = Map.fromList []
default_GetUserLanguage_args :: GetUserLanguage_args
default_GetUserLanguage_args = GetUserLanguage_args{
}
data GetUserLanguage_result = GetUserLanguage_result  { getUserLanguage_result_success :: LT.Text
  , getUserLanguage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLanguage_result_success record   `H.hashWithSalt` getUserLanguage_result_e record  
instance QC.Arbitrary GetUserLanguage_result where 
  arbitrary = M.liftM GetUserLanguage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLanguage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj}
    , if obj == default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj}
    ]
from_GetUserLanguage_result :: GetUserLanguage_result -> T.ThriftVal
from_GetUserLanguage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10314 -> (1, ("e",from_TalkException _v10314))) <$> getUserLanguage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10314 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v10314))) $ getUserLanguage_result_success record
    , (\_v10314 -> (1, ("e",from_TalkException _v10314))) <$> getUserLanguage_result_e record
    ]
    )
write_GetUserLanguage_result :: T.Protocol p => p -> GetUserLanguage_result -> P.IO ()
write_GetUserLanguage_result oprot record = T.writeVal oprot $ from_GetUserLanguage_result record
encode_GetUserLanguage_result :: T.StatelessProtocol p => p -> GetUserLanguage_result -> LBS.ByteString
encode_GetUserLanguage_result oprot record = T.serializeVal oprot $ from_GetUserLanguage_result record
to_GetUserLanguage_result :: T.ThriftVal -> GetUserLanguage_result
to_GetUserLanguage_result (T.TStruct fields) = GetUserLanguage_result{
  getUserLanguage_result_success = P.maybe (getUserLanguage_result_success default_GetUserLanguage_result) (\(_,_val10316) -> (case _val10316 of {T.TString _val10317 -> E.decodeUtf8 _val10317; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLanguage_result_e = P.maybe (P.Nothing) (\(_,_val10316) -> P.Just (case _val10316 of {T.TStruct _val10318 -> (to_TalkException (T.TStruct _val10318)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLanguage_result _ = P.error "not a struct"
read_GetUserLanguage_result :: T.Protocol p => p -> P.IO GetUserLanguage_result
read_GetUserLanguage_result iprot = to_GetUserLanguage_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_result)
decode_GetUserLanguage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_result
decode_GetUserLanguage_result iprot bs = to_GetUserLanguage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_result) bs
typemap_GetUserLanguage_result :: T.TypeMap
typemap_GetUserLanguage_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLanguage_result :: GetUserLanguage_result
default_GetUserLanguage_result = GetUserLanguage_result{
  getUserLanguage_result_success = "",
  getUserLanguage_result_e = P.Nothing}
data LookupPaidCall_args = LookupPaidCall_args  { lookupPaidCall_args_dialedNumber :: LT.Text
  , lookupPaidCall_args_language :: LT.Text
  , lookupPaidCall_args_referer :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupPaidCall_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupPaidCall_args_dialedNumber record   `H.hashWithSalt` lookupPaidCall_args_language record   `H.hashWithSalt` lookupPaidCall_args_referer record  
instance QC.Arbitrary LookupPaidCall_args where 
  arbitrary = M.liftM LookupPaidCall_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupPaidCall_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupPaidCall_args{lookupPaidCall_args_dialedNumber = lookupPaidCall_args_dialedNumber obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_dialedNumber = lookupPaidCall_args_dialedNumber obj}
    , if obj == default_LookupPaidCall_args{lookupPaidCall_args_language = lookupPaidCall_args_language obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_language = lookupPaidCall_args_language obj}
    , if obj == default_LookupPaidCall_args{lookupPaidCall_args_referer = lookupPaidCall_args_referer obj} then P.Nothing else P.Just $ default_LookupPaidCall_args{lookupPaidCall_args_referer = lookupPaidCall_args_referer obj}
    ]
from_LookupPaidCall_args :: LookupPaidCall_args -> T.ThriftVal
from_LookupPaidCall_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10321 -> P.Just (2, ("dialedNumber",T.TString $ E.encodeUtf8 _v10321))) $ lookupPaidCall_args_dialedNumber record
  , (\_v10321 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v10321))) $ lookupPaidCall_args_language record
  , (\_v10321 -> P.Just (4, ("referer",T.TString $ E.encodeUtf8 _v10321))) $ lookupPaidCall_args_referer record
  ]
write_LookupPaidCall_args :: T.Protocol p => p -> LookupPaidCall_args -> P.IO ()
write_LookupPaidCall_args oprot record = T.writeVal oprot $ from_LookupPaidCall_args record
encode_LookupPaidCall_args :: T.StatelessProtocol p => p -> LookupPaidCall_args -> LBS.ByteString
encode_LookupPaidCall_args oprot record = T.serializeVal oprot $ from_LookupPaidCall_args record
to_LookupPaidCall_args :: T.ThriftVal -> LookupPaidCall_args
to_LookupPaidCall_args (T.TStruct fields) = LookupPaidCall_args{
  lookupPaidCall_args_dialedNumber = P.maybe (lookupPaidCall_args_dialedNumber default_LookupPaidCall_args) (\(_,_val10323) -> (case _val10323 of {T.TString _val10324 -> E.decodeUtf8 _val10324; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  lookupPaidCall_args_language = P.maybe (lookupPaidCall_args_language default_LookupPaidCall_args) (\(_,_val10323) -> (case _val10323 of {T.TString _val10325 -> E.decodeUtf8 _val10325; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  lookupPaidCall_args_referer = P.maybe (lookupPaidCall_args_referer default_LookupPaidCall_args) (\(_,_val10323) -> (case _val10323 of {T.TString _val10326 -> E.decodeUtf8 _val10326; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_LookupPaidCall_args _ = P.error "not a struct"
read_LookupPaidCall_args :: T.Protocol p => p -> P.IO LookupPaidCall_args
read_LookupPaidCall_args iprot = to_LookupPaidCall_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupPaidCall_args)
decode_LookupPaidCall_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupPaidCall_args
decode_LookupPaidCall_args iprot bs = to_LookupPaidCall_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupPaidCall_args) bs
typemap_LookupPaidCall_args :: T.TypeMap
typemap_LookupPaidCall_args = Map.fromList [(2,("dialedNumber",T.T_STRING)),(3,("language",T.T_STRING)),(4,("referer",T.T_STRING))]
default_LookupPaidCall_args :: LookupPaidCall_args
default_LookupPaidCall_args = LookupPaidCall_args{
  lookupPaidCall_args_dialedNumber = "",
  lookupPaidCall_args_language = "",
  lookupPaidCall_args_referer = ""}
data LookupPaidCall_result = LookupPaidCall_result  { lookupPaidCall_result_success :: PaidCallResponse
  , lookupPaidCall_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupPaidCall_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupPaidCall_result_success record   `H.hashWithSalt` lookupPaidCall_result_e record  
instance QC.Arbitrary LookupPaidCall_result where 
  arbitrary = M.liftM LookupPaidCall_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupPaidCall_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupPaidCall_result{lookupPaidCall_result_success = lookupPaidCall_result_success obj} then P.Nothing else P.Just $ default_LookupPaidCall_result{lookupPaidCall_result_success = lookupPaidCall_result_success obj}
    , if obj == default_LookupPaidCall_result{lookupPaidCall_result_e = lookupPaidCall_result_e obj} then P.Nothing else P.Just $ default_LookupPaidCall_result{lookupPaidCall_result_e = lookupPaidCall_result_e obj}
    ]
from_LookupPaidCall_result :: LookupPaidCall_result -> T.ThriftVal
from_LookupPaidCall_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10329 -> (1, ("e",from_TalkException _v10329))) <$> lookupPaidCall_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10329 -> P.Just (0, ("success",from_PaidCallResponse _v10329))) $ lookupPaidCall_result_success record
    , (\_v10329 -> (1, ("e",from_TalkException _v10329))) <$> lookupPaidCall_result_e record
    ]
    )
write_LookupPaidCall_result :: T.Protocol p => p -> LookupPaidCall_result -> P.IO ()
write_LookupPaidCall_result oprot record = T.writeVal oprot $ from_LookupPaidCall_result record
encode_LookupPaidCall_result :: T.StatelessProtocol p => p -> LookupPaidCall_result -> LBS.ByteString
encode_LookupPaidCall_result oprot record = T.serializeVal oprot $ from_LookupPaidCall_result record
to_LookupPaidCall_result :: T.ThriftVal -> LookupPaidCall_result
to_LookupPaidCall_result (T.TStruct fields) = LookupPaidCall_result{
  lookupPaidCall_result_success = P.maybe (lookupPaidCall_result_success default_LookupPaidCall_result) (\(_,_val10331) -> (case _val10331 of {T.TStruct _val10332 -> (to_PaidCallResponse (T.TStruct _val10332)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupPaidCall_result_e = P.maybe (P.Nothing) (\(_,_val10331) -> P.Just (case _val10331 of {T.TStruct _val10333 -> (to_TalkException (T.TStruct _val10333)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupPaidCall_result _ = P.error "not a struct"
read_LookupPaidCall_result :: T.Protocol p => p -> P.IO LookupPaidCall_result
read_LookupPaidCall_result iprot = to_LookupPaidCall_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupPaidCall_result)
decode_LookupPaidCall_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupPaidCall_result
decode_LookupPaidCall_result iprot bs = to_LookupPaidCall_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupPaidCall_result) bs
typemap_LookupPaidCall_result :: T.TypeMap
typemap_LookupPaidCall_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallResponse))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupPaidCall_result :: LookupPaidCall_result
default_LookupPaidCall_result = LookupPaidCall_result{
  lookupPaidCall_result_success = default_PaidCallResponse,
  lookupPaidCall_result_e = P.Nothing}
data GetExtendedProfile_args = GetExtendedProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetExtendedProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetExtendedProfile_args where 
  arbitrary = QC.elements [GetExtendedProfile_args]
from_GetExtendedProfile_args :: GetExtendedProfile_args -> T.ThriftVal
from_GetExtendedProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetExtendedProfile_args :: T.Protocol p => p -> GetExtendedProfile_args -> P.IO ()
write_GetExtendedProfile_args oprot record = T.writeVal oprot $ from_GetExtendedProfile_args record
encode_GetExtendedProfile_args :: T.StatelessProtocol p => p -> GetExtendedProfile_args -> LBS.ByteString
encode_GetExtendedProfile_args oprot record = T.serializeVal oprot $ from_GetExtendedProfile_args record
to_GetExtendedProfile_args :: T.ThriftVal -> GetExtendedProfile_args
to_GetExtendedProfile_args (T.TStruct fields) = GetExtendedProfile_args{

  }
to_GetExtendedProfile_args _ = P.error "not a struct"
read_GetExtendedProfile_args :: T.Protocol p => p -> P.IO GetExtendedProfile_args
read_GetExtendedProfile_args iprot = to_GetExtendedProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetExtendedProfile_args)
decode_GetExtendedProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetExtendedProfile_args
decode_GetExtendedProfile_args iprot bs = to_GetExtendedProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetExtendedProfile_args) bs
typemap_GetExtendedProfile_args :: T.TypeMap
typemap_GetExtendedProfile_args = Map.fromList []
default_GetExtendedProfile_args :: GetExtendedProfile_args
default_GetExtendedProfile_args = GetExtendedProfile_args{
}
data GetExtendedProfile_result = GetExtendedProfile_result  { getExtendedProfile_result_success :: ExtendedProfile
  , getExtendedProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetExtendedProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getExtendedProfile_result_success record   `H.hashWithSalt` getExtendedProfile_result_e record  
instance QC.Arbitrary GetExtendedProfile_result where 
  arbitrary = M.liftM GetExtendedProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetExtendedProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetExtendedProfile_result{getExtendedProfile_result_success = getExtendedProfile_result_success obj} then P.Nothing else P.Just $ default_GetExtendedProfile_result{getExtendedProfile_result_success = getExtendedProfile_result_success obj}
    , if obj == default_GetExtendedProfile_result{getExtendedProfile_result_e = getExtendedProfile_result_e obj} then P.Nothing else P.Just $ default_GetExtendedProfile_result{getExtendedProfile_result_e = getExtendedProfile_result_e obj}
    ]
from_GetExtendedProfile_result :: GetExtendedProfile_result -> T.ThriftVal
from_GetExtendedProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10341 -> (1, ("e",from_TalkException _v10341))) <$> getExtendedProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10341 -> P.Just (0, ("success",from_ExtendedProfile _v10341))) $ getExtendedProfile_result_success record
    , (\_v10341 -> (1, ("e",from_TalkException _v10341))) <$> getExtendedProfile_result_e record
    ]
    )
write_GetExtendedProfile_result :: T.Protocol p => p -> GetExtendedProfile_result -> P.IO ()
write_GetExtendedProfile_result oprot record = T.writeVal oprot $ from_GetExtendedProfile_result record
encode_GetExtendedProfile_result :: T.StatelessProtocol p => p -> GetExtendedProfile_result -> LBS.ByteString
encode_GetExtendedProfile_result oprot record = T.serializeVal oprot $ from_GetExtendedProfile_result record
to_GetExtendedProfile_result :: T.ThriftVal -> GetExtendedProfile_result
to_GetExtendedProfile_result (T.TStruct fields) = GetExtendedProfile_result{
  getExtendedProfile_result_success = P.maybe (getExtendedProfile_result_success default_GetExtendedProfile_result) (\(_,_val10343) -> (case _val10343 of {T.TStruct _val10344 -> (to_ExtendedProfile (T.TStruct _val10344)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getExtendedProfile_result_e = P.maybe (P.Nothing) (\(_,_val10343) -> P.Just (case _val10343 of {T.TStruct _val10345 -> (to_TalkException (T.TStruct _val10345)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetExtendedProfile_result _ = P.error "not a struct"
read_GetExtendedProfile_result :: T.Protocol p => p -> P.IO GetExtendedProfile_result
read_GetExtendedProfile_result iprot = to_GetExtendedProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetExtendedProfile_result)
decode_GetExtendedProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetExtendedProfile_result
decode_GetExtendedProfile_result iprot bs = to_GetExtendedProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetExtendedProfile_result) bs
typemap_GetExtendedProfile_result :: T.TypeMap
typemap_GetExtendedProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ExtendedProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetExtendedProfile_result :: GetExtendedProfile_result
default_GetExtendedProfile_result = GetExtendedProfile_result{
  getExtendedProfile_result_success = default_ExtendedProfile,
  getExtendedProfile_result_e = P.Nothing}
data GetReverseCompactContacts_args = GetReverseCompactContacts_args  { getReverseCompactContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReverseCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReverseCompactContacts_args_ids record  
instance QC.Arbitrary GetReverseCompactContacts_args where 
  arbitrary = M.liftM GetReverseCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetReverseCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReverseCompactContacts_args{getReverseCompactContacts_args_ids = getReverseCompactContacts_args_ids obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_args{getReverseCompactContacts_args_ids = getReverseCompactContacts_args_ids obj}
    ]
from_GetReverseCompactContacts_args :: GetReverseCompactContacts_args -> T.ThriftVal
from_GetReverseCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10348 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v10350 -> T.TString $ E.encodeUtf8 _v10350) $ Vector.toList _v10348))) $ getReverseCompactContacts_args_ids record
  ]
write_GetReverseCompactContacts_args :: T.Protocol p => p -> GetReverseCompactContacts_args -> P.IO ()
write_GetReverseCompactContacts_args oprot record = T.writeVal oprot $ from_GetReverseCompactContacts_args record
encode_GetReverseCompactContacts_args :: T.StatelessProtocol p => p -> GetReverseCompactContacts_args -> LBS.ByteString
encode_GetReverseCompactContacts_args oprot record = T.serializeVal oprot $ from_GetReverseCompactContacts_args record
to_GetReverseCompactContacts_args :: T.ThriftVal -> GetReverseCompactContacts_args
to_GetReverseCompactContacts_args (T.TStruct fields) = GetReverseCompactContacts_args{
  getReverseCompactContacts_args_ids = P.maybe (getReverseCompactContacts_args_ids default_GetReverseCompactContacts_args) (\(_,_val10352) -> (case _val10352 of {T.TList _ _val10353 -> (Vector.fromList $ P.map (\_v10354 -> (case _v10354 of {T.TString _val10355 -> E.decodeUtf8 _val10355; _ -> P.error "wrong type"})) _val10353); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetReverseCompactContacts_args _ = P.error "not a struct"
read_GetReverseCompactContacts_args :: T.Protocol p => p -> P.IO GetReverseCompactContacts_args
read_GetReverseCompactContacts_args iprot = to_GetReverseCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_args)
decode_GetReverseCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReverseCompactContacts_args
decode_GetReverseCompactContacts_args iprot bs = to_GetReverseCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_args) bs
typemap_GetReverseCompactContacts_args :: T.TypeMap
typemap_GetReverseCompactContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING)))]
default_GetReverseCompactContacts_args :: GetReverseCompactContacts_args
default_GetReverseCompactContacts_args = GetReverseCompactContacts_args{
  getReverseCompactContacts_args_ids = Vector.empty}
data GetReverseCompactContacts_result = GetReverseCompactContacts_result  { getReverseCompactContacts_result_success :: (Map.HashMap LT.Text CompactContact)
  , getReverseCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetReverseCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getReverseCompactContacts_result_success record   `H.hashWithSalt` getReverseCompactContacts_result_e record  
instance QC.Arbitrary GetReverseCompactContacts_result where 
  arbitrary = M.liftM GetReverseCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetReverseCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = getReverseCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = getReverseCompactContacts_result_success obj}
    , if obj == default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = getReverseCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = getReverseCompactContacts_result_e obj}
    ]
from_GetReverseCompactContacts_result :: GetReverseCompactContacts_result -> T.ThriftVal
from_GetReverseCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10358 -> (1, ("e",from_TalkException _v10358))) <$> getReverseCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10358 -> P.Just (0, ("success",T.TMap T.T_STRING (T.T_STRUCT typemap_CompactContact) $ P.map (\(_k10359,_v10360) -> (T.TString $ E.encodeUtf8 _k10359, from_CompactContact _v10360)) $ Map.toList _v10358))) $ getReverseCompactContacts_result_success record
    , (\_v10358 -> (1, ("e",from_TalkException _v10358))) <$> getReverseCompactContacts_result_e record
    ]
    )
write_GetReverseCompactContacts_result :: T.Protocol p => p -> GetReverseCompactContacts_result -> P.IO ()
write_GetReverseCompactContacts_result oprot record = T.writeVal oprot $ from_GetReverseCompactContacts_result record
encode_GetReverseCompactContacts_result :: T.StatelessProtocol p => p -> GetReverseCompactContacts_result -> LBS.ByteString
encode_GetReverseCompactContacts_result oprot record = T.serializeVal oprot $ from_GetReverseCompactContacts_result record
to_GetReverseCompactContacts_result :: T.ThriftVal -> GetReverseCompactContacts_result
to_GetReverseCompactContacts_result (T.TStruct fields) = GetReverseCompactContacts_result{
  getReverseCompactContacts_result_success = P.maybe (getReverseCompactContacts_result_success default_GetReverseCompactContacts_result) (\(_,_val10362) -> (case _val10362 of {T.TMap _ _ _val10363 -> (Map.fromList $ P.map (\(_k10365,_v10364) -> ((case _k10365 of {T.TString _val10366 -> E.decodeUtf8 _val10366; _ -> P.error "wrong type"}),(case _v10364 of {T.TStruct _val10367 -> (to_CompactContact (T.TStruct _val10367)); _ -> P.error "wrong type"}))) _val10363); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getReverseCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val10362) -> P.Just (case _val10362 of {T.TStruct _val10368 -> (to_TalkException (T.TStruct _val10368)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetReverseCompactContacts_result _ = P.error "not a struct"
read_GetReverseCompactContacts_result :: T.Protocol p => p -> P.IO GetReverseCompactContacts_result
read_GetReverseCompactContacts_result iprot = to_GetReverseCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_result)
decode_GetReverseCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetReverseCompactContacts_result
decode_GetReverseCompactContacts_result iprot bs = to_GetReverseCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetReverseCompactContacts_result) bs
typemap_GetReverseCompactContacts_result :: T.TypeMap
typemap_GetReverseCompactContacts_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetReverseCompactContacts_result :: GetReverseCompactContacts_result
default_GetReverseCompactContacts_result = GetReverseCompactContacts_result{
  getReverseCompactContacts_result_success = Map.empty,
  getReverseCompactContacts_result_e = P.Nothing}
data GetPaidCallAdStatus_args = GetPaidCallAdStatus_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallAdStatus_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPaidCallAdStatus_args where 
  arbitrary = QC.elements [GetPaidCallAdStatus_args]
from_GetPaidCallAdStatus_args :: GetPaidCallAdStatus_args -> T.ThriftVal
from_GetPaidCallAdStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPaidCallAdStatus_args :: T.Protocol p => p -> GetPaidCallAdStatus_args -> P.IO ()
write_GetPaidCallAdStatus_args oprot record = T.writeVal oprot $ from_GetPaidCallAdStatus_args record
encode_GetPaidCallAdStatus_args :: T.StatelessProtocol p => p -> GetPaidCallAdStatus_args -> LBS.ByteString
encode_GetPaidCallAdStatus_args oprot record = T.serializeVal oprot $ from_GetPaidCallAdStatus_args record
to_GetPaidCallAdStatus_args :: T.ThriftVal -> GetPaidCallAdStatus_args
to_GetPaidCallAdStatus_args (T.TStruct fields) = GetPaidCallAdStatus_args{

  }
to_GetPaidCallAdStatus_args _ = P.error "not a struct"
read_GetPaidCallAdStatus_args :: T.Protocol p => p -> P.IO GetPaidCallAdStatus_args
read_GetPaidCallAdStatus_args iprot = to_GetPaidCallAdStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_args)
decode_GetPaidCallAdStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallAdStatus_args
decode_GetPaidCallAdStatus_args iprot bs = to_GetPaidCallAdStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_args) bs
typemap_GetPaidCallAdStatus_args :: T.TypeMap
typemap_GetPaidCallAdStatus_args = Map.fromList []
default_GetPaidCallAdStatus_args :: GetPaidCallAdStatus_args
default_GetPaidCallAdStatus_args = GetPaidCallAdStatus_args{
}
data GetPaidCallAdStatus_result = GetPaidCallAdStatus_result  { getPaidCallAdStatus_result_success :: PaidCallAdResult
  , getPaidCallAdStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPaidCallAdStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPaidCallAdStatus_result_success record   `H.hashWithSalt` getPaidCallAdStatus_result_e record  
instance QC.Arbitrary GetPaidCallAdStatus_result where 
  arbitrary = M.liftM GetPaidCallAdStatus_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPaidCallAdStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = getPaidCallAdStatus_result_success obj} then P.Nothing else P.Just $ default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = getPaidCallAdStatus_result_success obj}
    , if obj == default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = getPaidCallAdStatus_result_e obj} then P.Nothing else P.Just $ default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = getPaidCallAdStatus_result_e obj}
    ]
from_GetPaidCallAdStatus_result :: GetPaidCallAdStatus_result -> T.ThriftVal
from_GetPaidCallAdStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10376 -> (1, ("e",from_TalkException _v10376))) <$> getPaidCallAdStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10376 -> P.Just (0, ("success",from_PaidCallAdResult _v10376))) $ getPaidCallAdStatus_result_success record
    , (\_v10376 -> (1, ("e",from_TalkException _v10376))) <$> getPaidCallAdStatus_result_e record
    ]
    )
write_GetPaidCallAdStatus_result :: T.Protocol p => p -> GetPaidCallAdStatus_result -> P.IO ()
write_GetPaidCallAdStatus_result oprot record = T.writeVal oprot $ from_GetPaidCallAdStatus_result record
encode_GetPaidCallAdStatus_result :: T.StatelessProtocol p => p -> GetPaidCallAdStatus_result -> LBS.ByteString
encode_GetPaidCallAdStatus_result oprot record = T.serializeVal oprot $ from_GetPaidCallAdStatus_result record
to_GetPaidCallAdStatus_result :: T.ThriftVal -> GetPaidCallAdStatus_result
to_GetPaidCallAdStatus_result (T.TStruct fields) = GetPaidCallAdStatus_result{
  getPaidCallAdStatus_result_success = P.maybe (getPaidCallAdStatus_result_success default_GetPaidCallAdStatus_result) (\(_,_val10378) -> (case _val10378 of {T.TStruct _val10379 -> (to_PaidCallAdResult (T.TStruct _val10379)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPaidCallAdStatus_result_e = P.maybe (P.Nothing) (\(_,_val10378) -> P.Just (case _val10378 of {T.TStruct _val10380 -> (to_TalkException (T.TStruct _val10380)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPaidCallAdStatus_result _ = P.error "not a struct"
read_GetPaidCallAdStatus_result :: T.Protocol p => p -> P.IO GetPaidCallAdStatus_result
read_GetPaidCallAdStatus_result iprot = to_GetPaidCallAdStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_result)
decode_GetPaidCallAdStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPaidCallAdStatus_result
decode_GetPaidCallAdStatus_result iprot bs = to_GetPaidCallAdStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPaidCallAdStatus_result) bs
typemap_GetPaidCallAdStatus_result :: T.TypeMap
typemap_GetPaidCallAdStatus_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PaidCallAdResult))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPaidCallAdStatus_result :: GetPaidCallAdStatus_result
default_GetPaidCallAdStatus_result = GetPaidCallAdStatus_result{
  getPaidCallAdStatus_result_success = default_PaidCallAdResult,
  getPaidCallAdStatus_result_e = P.Nothing}
data FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args  { findContactByUseridWithoutAbuseBlockForChannel_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_args_userid record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_args where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10383 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v10383))) $ findContactByUseridWithoutAbuseBlockForChannel_args_userid record
  ]
write_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
encode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
to_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_args
to_FindContactByUseridWithoutAbuseBlockForChannel_args (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_args_userid default_FindContactByUseridWithoutAbuseBlockForChannel_args) (\(_,_val10385) -> (case _val10385 of {T.TString _val10386 -> E.decodeUtf8 _val10386; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_args _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_args
read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args)
decode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_args
decode_FindContactByUseridWithoutAbuseBlockForChannel_args iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args
default_FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = ""}
data FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result  { findContactByUseridWithoutAbuseBlockForChannel_result_success :: Contact
  , findContactByUseridWithoutAbuseBlockForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_success record   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_e record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_result where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj}
    , if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10389 -> (1, ("e",from_TalkException _v10389))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10389 -> P.Just (0, ("success",from_Contact _v10389))) $ findContactByUseridWithoutAbuseBlockForChannel_result_success record
    , (\_v10389 -> (1, ("e",from_TalkException _v10389))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record
    ]
    )
write_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
encode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
to_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_result
to_FindContactByUseridWithoutAbuseBlockForChannel_result (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_result_success default_FindContactByUseridWithoutAbuseBlockForChannel_result) (\(_,_val10391) -> (case _val10391 of {T.TStruct _val10392 -> (to_Contact (T.TStruct _val10392)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10391) -> P.Just (case _val10391 of {T.TStruct _val10393 -> (to_TalkException (T.TStruct _val10393)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_result _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_result
read_FindContactByUseridWithoutAbuseBlockForChannel_result iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result)
decode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_result
decode_FindContactByUseridWithoutAbuseBlockForChannel_result iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result
default_FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = default_Contact,
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Nothing}
data GetGroupMemberMids_args = GetGroupMemberMids_args  { getGroupMemberMids_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_args_groupId record  
instance QC.Arbitrary GetGroupMemberMids_args where 
  arbitrary = M.liftM GetGroupMemberMids_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj}
    ]
from_GetGroupMemberMids_args :: GetGroupMemberMids_args -> T.ThriftVal
from_GetGroupMemberMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10396 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v10396))) $ getGroupMemberMids_args_groupId record
  ]
write_GetGroupMemberMids_args :: T.Protocol p => p -> GetGroupMemberMids_args -> P.IO ()
write_GetGroupMemberMids_args oprot record = T.writeVal oprot $ from_GetGroupMemberMids_args record
encode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> GetGroupMemberMids_args -> LBS.ByteString
encode_GetGroupMemberMids_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_args record
to_GetGroupMemberMids_args :: T.ThriftVal -> GetGroupMemberMids_args
to_GetGroupMemberMids_args (T.TStruct fields) = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = P.maybe (getGroupMemberMids_args_groupId default_GetGroupMemberMids_args) (\(_,_val10398) -> (case _val10398 of {T.TString _val10399 -> E.decodeUtf8 _val10399; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_args _ = P.error "not a struct"
read_GetGroupMemberMids_args :: T.Protocol p => p -> P.IO GetGroupMemberMids_args
read_GetGroupMemberMids_args iprot = to_GetGroupMemberMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args)
decode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_args
decode_GetGroupMemberMids_args iprot bs = to_GetGroupMemberMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args) bs
typemap_GetGroupMemberMids_args :: T.TypeMap
typemap_GetGroupMemberMids_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMids_args :: GetGroupMemberMids_args
default_GetGroupMemberMids_args = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = ""}
data GetGroupMemberMids_result = GetGroupMemberMids_result  { getGroupMemberMids_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_result_success record   `H.hashWithSalt` getGroupMemberMids_result_e record  
instance QC.Arbitrary GetGroupMemberMids_result where 
  arbitrary = M.liftM GetGroupMemberMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj}
    , if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj}
    ]
from_GetGroupMemberMids_result :: GetGroupMemberMids_result -> T.ThriftVal
from_GetGroupMemberMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10402 -> (1, ("e",from_TalkException _v10402))) <$> getGroupMemberMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10402 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10404 -> T.TString $ E.encodeUtf8 _v10404) $ Vector.toList _v10402))) $ getGroupMemberMids_result_success record
    , (\_v10402 -> (1, ("e",from_TalkException _v10402))) <$> getGroupMemberMids_result_e record
    ]
    )
write_GetGroupMemberMids_result :: T.Protocol p => p -> GetGroupMemberMids_result -> P.IO ()
write_GetGroupMemberMids_result oprot record = T.writeVal oprot $ from_GetGroupMemberMids_result record
encode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> GetGroupMemberMids_result -> LBS.ByteString
encode_GetGroupMemberMids_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_result record
to_GetGroupMemberMids_result :: T.ThriftVal -> GetGroupMemberMids_result
to_GetGroupMemberMids_result (T.TStruct fields) = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = P.maybe (getGroupMemberMids_result_success default_GetGroupMemberMids_result) (\(_,_val10406) -> (case _val10406 of {T.TList _ _val10407 -> (Vector.fromList $ P.map (\_v10408 -> (case _v10408 of {T.TString _val10409 -> E.decodeUtf8 _val10409; _ -> P.error "wrong type"})) _val10407); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMids_result_e = P.maybe (P.Nothing) (\(_,_val10406) -> P.Just (case _val10406 of {T.TStruct _val10410 -> (to_TalkException (T.TStruct _val10410)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_result _ = P.error "not a struct"
read_GetGroupMemberMids_result :: T.Protocol p => p -> P.IO GetGroupMemberMids_result
read_GetGroupMemberMids_result iprot = to_GetGroupMemberMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result)
decode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_result
decode_GetGroupMemberMids_result iprot bs = to_GetGroupMemberMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result) bs
typemap_GetGroupMemberMids_result :: T.TypeMap
typemap_GetGroupMemberMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMids_result :: GetGroupMemberMids_result
default_GetGroupMemberMids_result = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = Vector.empty,
  getGroupMemberMids_result_e = P.Nothing}
data SendMessageWithoutRelationship_args = SendMessageWithoutRelationship_args  { sendMessageWithoutRelationship_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageWithoutRelationship_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageWithoutRelationship_args_message record  
instance QC.Arbitrary SendMessageWithoutRelationship_args where 
  arbitrary = M.liftM SendMessageWithoutRelationship_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageWithoutRelationship_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageWithoutRelationship_args{sendMessageWithoutRelationship_args_message = sendMessageWithoutRelationship_args_message obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_args{sendMessageWithoutRelationship_args_message = sendMessageWithoutRelationship_args_message obj}
    ]
from_SendMessageWithoutRelationship_args :: SendMessageWithoutRelationship_args -> T.ThriftVal
from_SendMessageWithoutRelationship_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10413 -> P.Just (2, ("message",from_Message _v10413))) $ sendMessageWithoutRelationship_args_message record
  ]
write_SendMessageWithoutRelationship_args :: T.Protocol p => p -> SendMessageWithoutRelationship_args -> P.IO ()
write_SendMessageWithoutRelationship_args oprot record = T.writeVal oprot $ from_SendMessageWithoutRelationship_args record
encode_SendMessageWithoutRelationship_args :: T.StatelessProtocol p => p -> SendMessageWithoutRelationship_args -> LBS.ByteString
encode_SendMessageWithoutRelationship_args oprot record = T.serializeVal oprot $ from_SendMessageWithoutRelationship_args record
to_SendMessageWithoutRelationship_args :: T.ThriftVal -> SendMessageWithoutRelationship_args
to_SendMessageWithoutRelationship_args (T.TStruct fields) = SendMessageWithoutRelationship_args{
  sendMessageWithoutRelationship_args_message = P.maybe (sendMessageWithoutRelationship_args_message default_SendMessageWithoutRelationship_args) (\(_,_val10415) -> (case _val10415 of {T.TStruct _val10416 -> (to_Message (T.TStruct _val10416)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageWithoutRelationship_args _ = P.error "not a struct"
read_SendMessageWithoutRelationship_args :: T.Protocol p => p -> P.IO SendMessageWithoutRelationship_args
read_SendMessageWithoutRelationship_args iprot = to_SendMessageWithoutRelationship_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_args)
decode_SendMessageWithoutRelationship_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageWithoutRelationship_args
decode_SendMessageWithoutRelationship_args iprot bs = to_SendMessageWithoutRelationship_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_args) bs
typemap_SendMessageWithoutRelationship_args :: T.TypeMap
typemap_SendMessageWithoutRelationship_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageWithoutRelationship_args :: SendMessageWithoutRelationship_args
default_SendMessageWithoutRelationship_args = SendMessageWithoutRelationship_args{
  sendMessageWithoutRelationship_args_message = default_Message}
data SendMessageWithoutRelationship_result = SendMessageWithoutRelationship_result  { sendMessageWithoutRelationship_result_success :: Message
  , sendMessageWithoutRelationship_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageWithoutRelationship_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageWithoutRelationship_result_success record   `H.hashWithSalt` sendMessageWithoutRelationship_result_e record  
instance QC.Arbitrary SendMessageWithoutRelationship_result where 
  arbitrary = M.liftM SendMessageWithoutRelationship_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageWithoutRelationship_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = sendMessageWithoutRelationship_result_success obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = sendMessageWithoutRelationship_result_success obj}
    , if obj == default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = sendMessageWithoutRelationship_result_e obj} then P.Nothing else P.Just $ default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = sendMessageWithoutRelationship_result_e obj}
    ]
from_SendMessageWithoutRelationship_result :: SendMessageWithoutRelationship_result -> T.ThriftVal
from_SendMessageWithoutRelationship_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10419 -> (1, ("e",from_TalkException _v10419))) <$> sendMessageWithoutRelationship_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10419 -> P.Just (0, ("success",from_Message _v10419))) $ sendMessageWithoutRelationship_result_success record
    , (\_v10419 -> (1, ("e",from_TalkException _v10419))) <$> sendMessageWithoutRelationship_result_e record
    ]
    )
write_SendMessageWithoutRelationship_result :: T.Protocol p => p -> SendMessageWithoutRelationship_result -> P.IO ()
write_SendMessageWithoutRelationship_result oprot record = T.writeVal oprot $ from_SendMessageWithoutRelationship_result record
encode_SendMessageWithoutRelationship_result :: T.StatelessProtocol p => p -> SendMessageWithoutRelationship_result -> LBS.ByteString
encode_SendMessageWithoutRelationship_result oprot record = T.serializeVal oprot $ from_SendMessageWithoutRelationship_result record
to_SendMessageWithoutRelationship_result :: T.ThriftVal -> SendMessageWithoutRelationship_result
to_SendMessageWithoutRelationship_result (T.TStruct fields) = SendMessageWithoutRelationship_result{
  sendMessageWithoutRelationship_result_success = P.maybe (sendMessageWithoutRelationship_result_success default_SendMessageWithoutRelationship_result) (\(_,_val10421) -> (case _val10421 of {T.TStruct _val10422 -> (to_Message (T.TStruct _val10422)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageWithoutRelationship_result_e = P.maybe (P.Nothing) (\(_,_val10421) -> P.Just (case _val10421 of {T.TStruct _val10423 -> (to_TalkException (T.TStruct _val10423)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageWithoutRelationship_result _ = P.error "not a struct"
read_SendMessageWithoutRelationship_result :: T.Protocol p => p -> P.IO SendMessageWithoutRelationship_result
read_SendMessageWithoutRelationship_result iprot = to_SendMessageWithoutRelationship_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_result)
decode_SendMessageWithoutRelationship_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageWithoutRelationship_result
decode_SendMessageWithoutRelationship_result iprot bs = to_SendMessageWithoutRelationship_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageWithoutRelationship_result) bs
typemap_SendMessageWithoutRelationship_result :: T.TypeMap
typemap_SendMessageWithoutRelationship_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageWithoutRelationship_result :: SendMessageWithoutRelationship_result
default_SendMessageWithoutRelationship_result = SendMessageWithoutRelationship_result{
  sendMessageWithoutRelationship_result_success = default_Message,
  sendMessageWithoutRelationship_result_e = P.Nothing}
data DisplayBuddySubscriberCountInBulk_args = DisplayBuddySubscriberCountInBulk_args  { displayBuddySubscriberCountInBulk_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCountInBulk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCountInBulk_args_mids record  
instance QC.Arbitrary DisplayBuddySubscriberCountInBulk_args where 
  arbitrary = M.liftM DisplayBuddySubscriberCountInBulk_args (QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCountInBulk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCountInBulk_args{displayBuddySubscriberCountInBulk_args_mids = displayBuddySubscriberCountInBulk_args_mids obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_args{displayBuddySubscriberCountInBulk_args_mids = displayBuddySubscriberCountInBulk_args_mids obj}
    ]
from_DisplayBuddySubscriberCountInBulk_args :: DisplayBuddySubscriberCountInBulk_args -> T.ThriftVal
from_DisplayBuddySubscriberCountInBulk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10426 -> P.Just (1, ("mids",T.TList T.T_STRING $ P.map (\_v10428 -> T.TString $ E.encodeUtf8 _v10428) $ Vector.toList _v10426))) $ displayBuddySubscriberCountInBulk_args_mids record
  ]
write_DisplayBuddySubscriberCountInBulk_args :: T.Protocol p => p -> DisplayBuddySubscriberCountInBulk_args -> P.IO ()
write_DisplayBuddySubscriberCountInBulk_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCountInBulk_args record
encode_DisplayBuddySubscriberCountInBulk_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCountInBulk_args -> LBS.ByteString
encode_DisplayBuddySubscriberCountInBulk_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCountInBulk_args record
to_DisplayBuddySubscriberCountInBulk_args :: T.ThriftVal -> DisplayBuddySubscriberCountInBulk_args
to_DisplayBuddySubscriberCountInBulk_args (T.TStruct fields) = DisplayBuddySubscriberCountInBulk_args{
  displayBuddySubscriberCountInBulk_args_mids = P.maybe (displayBuddySubscriberCountInBulk_args_mids default_DisplayBuddySubscriberCountInBulk_args) (\(_,_val10430) -> (case _val10430 of {T.TList _ _val10431 -> (Vector.fromList $ P.map (\_v10432 -> (case _v10432 of {T.TString _val10433 -> E.decodeUtf8 _val10433; _ -> P.error "wrong type"})) _val10431); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCountInBulk_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCountInBulk_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCountInBulk_args
read_DisplayBuddySubscriberCountInBulk_args iprot = to_DisplayBuddySubscriberCountInBulk_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_args)
decode_DisplayBuddySubscriberCountInBulk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCountInBulk_args
decode_DisplayBuddySubscriberCountInBulk_args iprot bs = to_DisplayBuddySubscriberCountInBulk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_args) bs
typemap_DisplayBuddySubscriberCountInBulk_args :: T.TypeMap
typemap_DisplayBuddySubscriberCountInBulk_args = Map.fromList [(1,("mids",(T.T_LIST T.T_STRING)))]
default_DisplayBuddySubscriberCountInBulk_args :: DisplayBuddySubscriberCountInBulk_args
default_DisplayBuddySubscriberCountInBulk_args = DisplayBuddySubscriberCountInBulk_args{
  displayBuddySubscriberCountInBulk_args_mids = Vector.empty}
data DisplayBuddySubscriberCountInBulk_result = DisplayBuddySubscriberCountInBulk_result  { displayBuddySubscriberCountInBulk_result_success :: (Map.HashMap LT.Text I.Int64)
  , displayBuddySubscriberCountInBulk_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCountInBulk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCountInBulk_result_success record   `H.hashWithSalt` displayBuddySubscriberCountInBulk_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCountInBulk_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCountInBulk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCountInBulk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = displayBuddySubscriberCountInBulk_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = displayBuddySubscriberCountInBulk_result_success obj}
    , if obj == default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = displayBuddySubscriberCountInBulk_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = displayBuddySubscriberCountInBulk_result_e obj}
    ]
from_DisplayBuddySubscriberCountInBulk_result :: DisplayBuddySubscriberCountInBulk_result -> T.ThriftVal
from_DisplayBuddySubscriberCountInBulk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10436 -> (1, ("e",from_TalkException _v10436))) <$> displayBuddySubscriberCountInBulk_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10436 -> P.Just (0, ("success",T.TMap T.T_STRING T.T_I64 $ P.map (\(_k10437,_v10438) -> (T.TString $ E.encodeUtf8 _k10437, T.TI64 _v10438)) $ Map.toList _v10436))) $ displayBuddySubscriberCountInBulk_result_success record
    , (\_v10436 -> (1, ("e",from_TalkException _v10436))) <$> displayBuddySubscriberCountInBulk_result_e record
    ]
    )
write_DisplayBuddySubscriberCountInBulk_result :: T.Protocol p => p -> DisplayBuddySubscriberCountInBulk_result -> P.IO ()
write_DisplayBuddySubscriberCountInBulk_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCountInBulk_result record
encode_DisplayBuddySubscriberCountInBulk_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCountInBulk_result -> LBS.ByteString
encode_DisplayBuddySubscriberCountInBulk_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCountInBulk_result record
to_DisplayBuddySubscriberCountInBulk_result :: T.ThriftVal -> DisplayBuddySubscriberCountInBulk_result
to_DisplayBuddySubscriberCountInBulk_result (T.TStruct fields) = DisplayBuddySubscriberCountInBulk_result{
  displayBuddySubscriberCountInBulk_result_success = P.maybe (displayBuddySubscriberCountInBulk_result_success default_DisplayBuddySubscriberCountInBulk_result) (\(_,_val10440) -> (case _val10440 of {T.TMap _ _ _val10441 -> (Map.fromList $ P.map (\(_k10443,_v10442) -> ((case _k10443 of {T.TString _val10444 -> E.decodeUtf8 _val10444; _ -> P.error "wrong type"}),(case _v10442 of {T.TI64 _val10445 -> _val10445; _ -> P.error "wrong type"}))) _val10441); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCountInBulk_result_e = P.maybe (P.Nothing) (\(_,_val10440) -> P.Just (case _val10440 of {T.TStruct _val10446 -> (to_TalkException (T.TStruct _val10446)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCountInBulk_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCountInBulk_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCountInBulk_result
read_DisplayBuddySubscriberCountInBulk_result iprot = to_DisplayBuddySubscriberCountInBulk_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_result)
decode_DisplayBuddySubscriberCountInBulk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCountInBulk_result
decode_DisplayBuddySubscriberCountInBulk_result iprot bs = to_DisplayBuddySubscriberCountInBulk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCountInBulk_result) bs
typemap_DisplayBuddySubscriberCountInBulk_result :: T.TypeMap
typemap_DisplayBuddySubscriberCountInBulk_result = Map.fromList [(0,("success",(T.T_MAP T.T_STRING T.T_I64))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCountInBulk_result :: DisplayBuddySubscriberCountInBulk_result
default_DisplayBuddySubscriberCountInBulk_result = DisplayBuddySubscriberCountInBulk_result{
  displayBuddySubscriberCountInBulk_result_success = Map.empty,
  displayBuddySubscriberCountInBulk_result_e = P.Nothing}
data LookupRoomMembers_args = LookupRoomMembers_args  { lookupRoomMembers_args_roomId :: LT.Text
  , lookupRoomMembers_args_mids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupRoomMembers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupRoomMembers_args_roomId record   `H.hashWithSalt` lookupRoomMembers_args_mids record  
instance QC.Arbitrary LookupRoomMembers_args where 
  arbitrary = M.liftM LookupRoomMembers_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_LookupRoomMembers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupRoomMembers_args{lookupRoomMembers_args_roomId = lookupRoomMembers_args_roomId obj} then P.Nothing else P.Just $ default_LookupRoomMembers_args{lookupRoomMembers_args_roomId = lookupRoomMembers_args_roomId obj}
    , if obj == default_LookupRoomMembers_args{lookupRoomMembers_args_mids = lookupRoomMembers_args_mids obj} then P.Nothing else P.Just $ default_LookupRoomMembers_args{lookupRoomMembers_args_mids = lookupRoomMembers_args_mids obj}
    ]
from_LookupRoomMembers_args :: LookupRoomMembers_args -> T.ThriftVal
from_LookupRoomMembers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10449 -> P.Just (1, ("roomId",T.TString $ E.encodeUtf8 _v10449))) $ lookupRoomMembers_args_roomId record
  , (\_v10449 -> P.Just (2, ("mids",T.TList T.T_STRING $ P.map (\_v10451 -> T.TString $ E.encodeUtf8 _v10451) $ Vector.toList _v10449))) $ lookupRoomMembers_args_mids record
  ]
write_LookupRoomMembers_args :: T.Protocol p => p -> LookupRoomMembers_args -> P.IO ()
write_LookupRoomMembers_args oprot record = T.writeVal oprot $ from_LookupRoomMembers_args record
encode_LookupRoomMembers_args :: T.StatelessProtocol p => p -> LookupRoomMembers_args -> LBS.ByteString
encode_LookupRoomMembers_args oprot record = T.serializeVal oprot $ from_LookupRoomMembers_args record
to_LookupRoomMembers_args :: T.ThriftVal -> LookupRoomMembers_args
to_LookupRoomMembers_args (T.TStruct fields) = LookupRoomMembers_args{
  lookupRoomMembers_args_roomId = P.maybe (lookupRoomMembers_args_roomId default_LookupRoomMembers_args) (\(_,_val10453) -> (case _val10453 of {T.TString _val10454 -> E.decodeUtf8 _val10454; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lookupRoomMembers_args_mids = P.maybe (lookupRoomMembers_args_mids default_LookupRoomMembers_args) (\(_,_val10453) -> (case _val10453 of {T.TList _ _val10455 -> (Vector.fromList $ P.map (\_v10456 -> (case _v10456 of {T.TString _val10457 -> E.decodeUtf8 _val10457; _ -> P.error "wrong type"})) _val10455); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LookupRoomMembers_args _ = P.error "not a struct"
read_LookupRoomMembers_args :: T.Protocol p => p -> P.IO LookupRoomMembers_args
read_LookupRoomMembers_args iprot = to_LookupRoomMembers_args <$> T.readVal iprot (T.T_STRUCT typemap_LookupRoomMembers_args)
decode_LookupRoomMembers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupRoomMembers_args
decode_LookupRoomMembers_args iprot bs = to_LookupRoomMembers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupRoomMembers_args) bs
typemap_LookupRoomMembers_args :: T.TypeMap
typemap_LookupRoomMembers_args = Map.fromList [(1,("roomId",T.T_STRING)),(2,("mids",(T.T_LIST T.T_STRING)))]
default_LookupRoomMembers_args :: LookupRoomMembers_args
default_LookupRoomMembers_args = LookupRoomMembers_args{
  lookupRoomMembers_args_roomId = "",
  lookupRoomMembers_args_mids = Vector.empty}
data LookupRoomMembers_result = LookupRoomMembers_result  { lookupRoomMembers_result_success :: (Vector.Vector SimpleChannelContact)
  , lookupRoomMembers_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LookupRoomMembers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` lookupRoomMembers_result_success record   `H.hashWithSalt` lookupRoomMembers_result_e record  
instance QC.Arbitrary LookupRoomMembers_result where 
  arbitrary = M.liftM LookupRoomMembers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LookupRoomMembers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LookupRoomMembers_result{lookupRoomMembers_result_success = lookupRoomMembers_result_success obj} then P.Nothing else P.Just $ default_LookupRoomMembers_result{lookupRoomMembers_result_success = lookupRoomMembers_result_success obj}
    , if obj == default_LookupRoomMembers_result{lookupRoomMembers_result_e = lookupRoomMembers_result_e obj} then P.Nothing else P.Just $ default_LookupRoomMembers_result{lookupRoomMembers_result_e = lookupRoomMembers_result_e obj}
    ]
from_LookupRoomMembers_result :: LookupRoomMembers_result -> T.ThriftVal
from_LookupRoomMembers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10460 -> (1, ("e",from_TalkException _v10460))) <$> lookupRoomMembers_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10460 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v10462 -> from_SimpleChannelContact _v10462) $ Vector.toList _v10460))) $ lookupRoomMembers_result_success record
    , (\_v10460 -> (1, ("e",from_TalkException _v10460))) <$> lookupRoomMembers_result_e record
    ]
    )
write_LookupRoomMembers_result :: T.Protocol p => p -> LookupRoomMembers_result -> P.IO ()
write_LookupRoomMembers_result oprot record = T.writeVal oprot $ from_LookupRoomMembers_result record
encode_LookupRoomMembers_result :: T.StatelessProtocol p => p -> LookupRoomMembers_result -> LBS.ByteString
encode_LookupRoomMembers_result oprot record = T.serializeVal oprot $ from_LookupRoomMembers_result record
to_LookupRoomMembers_result :: T.ThriftVal -> LookupRoomMembers_result
to_LookupRoomMembers_result (T.TStruct fields) = LookupRoomMembers_result{
  lookupRoomMembers_result_success = P.maybe (lookupRoomMembers_result_success default_LookupRoomMembers_result) (\(_,_val10464) -> (case _val10464 of {T.TList _ _val10465 -> (Vector.fromList $ P.map (\_v10466 -> (case _v10466 of {T.TStruct _val10467 -> (to_SimpleChannelContact (T.TStruct _val10467)); _ -> P.error "wrong type"})) _val10465); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  lookupRoomMembers_result_e = P.maybe (P.Nothing) (\(_,_val10464) -> P.Just (case _val10464 of {T.TStruct _val10468 -> (to_TalkException (T.TStruct _val10468)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_LookupRoomMembers_result _ = P.error "not a struct"
read_LookupRoomMembers_result :: T.Protocol p => p -> P.IO LookupRoomMembers_result
read_LookupRoomMembers_result iprot = to_LookupRoomMembers_result <$> T.readVal iprot (T.T_STRUCT typemap_LookupRoomMembers_result)
decode_LookupRoomMembers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> LookupRoomMembers_result
decode_LookupRoomMembers_result iprot bs = to_LookupRoomMembers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_LookupRoomMembers_result) bs
typemap_LookupRoomMembers_result :: T.TypeMap
typemap_LookupRoomMembers_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_LookupRoomMembers_result :: LookupRoomMembers_result
default_LookupRoomMembers_result = LookupRoomMembers_result{
  lookupRoomMembers_result_success = Vector.empty,
  lookupRoomMembers_result_e = P.Nothing}
data GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMidsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteMidsForChannel_args]
from_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args -> T.ThriftVal
from_GetFavoriteMidsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> GetFavoriteMidsForChannel_args -> P.IO ()
write_GetFavoriteMidsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_args record
encode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_args -> LBS.ByteString
encode_GetFavoriteMidsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_args record
to_GetFavoriteMidsForChannel_args :: T.ThriftVal -> GetFavoriteMidsForChannel_args
to_GetFavoriteMidsForChannel_args (T.TStruct fields) = GetFavoriteMidsForChannel_args{

  }
to_GetFavoriteMidsForChannel_args _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_args
read_GetFavoriteMidsForChannel_args iprot = to_GetFavoriteMidsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args)
decode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_args
decode_GetFavoriteMidsForChannel_args iprot bs = to_GetFavoriteMidsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args) bs
typemap_GetFavoriteMidsForChannel_args :: T.TypeMap
typemap_GetFavoriteMidsForChannel_args = Map.fromList []
default_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args
default_GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args{
}
data GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result  { getFavoriteMidsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMidsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMidsForChannel_result_success record   `H.hashWithSalt` getFavoriteMidsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteMidsForChannel_result where 
  arbitrary = M.liftM GetFavoriteMidsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMidsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj}
    , if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj}
    ]
from_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result -> T.ThriftVal
from_GetFavoriteMidsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10476 -> (1, ("e",from_TalkException _v10476))) <$> getFavoriteMidsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10476 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10478 -> T.TString $ E.encodeUtf8 _v10478) $ Vector.toList _v10476))) $ getFavoriteMidsForChannel_result_success record
    , (\_v10476 -> (1, ("e",from_TalkException _v10476))) <$> getFavoriteMidsForChannel_result_e record
    ]
    )
write_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> GetFavoriteMidsForChannel_result -> P.IO ()
write_GetFavoriteMidsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_result record
encode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_result -> LBS.ByteString
encode_GetFavoriteMidsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_result record
to_GetFavoriteMidsForChannel_result :: T.ThriftVal -> GetFavoriteMidsForChannel_result
to_GetFavoriteMidsForChannel_result (T.TStruct fields) = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = P.maybe (getFavoriteMidsForChannel_result_success default_GetFavoriteMidsForChannel_result) (\(_,_val10480) -> (case _val10480 of {T.TList _ _val10481 -> (Vector.fromList $ P.map (\_v10482 -> (case _v10482 of {T.TString _val10483 -> E.decodeUtf8 _val10483; _ -> P.error "wrong type"})) _val10481); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMidsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10480) -> P.Just (case _val10480 of {T.TStruct _val10484 -> (to_TalkException (T.TStruct _val10484)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMidsForChannel_result _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_result
read_GetFavoriteMidsForChannel_result iprot = to_GetFavoriteMidsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result)
decode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_result
decode_GetFavoriteMidsForChannel_result iprot bs = to_GetFavoriteMidsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result) bs
typemap_GetFavoriteMidsForChannel_result :: T.TypeMap
typemap_GetFavoriteMidsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result
default_GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = Vector.empty,
  getFavoriteMidsForChannel_result_e = P.Nothing}
data GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIdsForChannel_args where 
  arbitrary = QC.elements [GetAllContactIdsForChannel_args]
from_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args -> T.ThriftVal
from_GetAllContactIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIdsForChannel_args :: T.Protocol p => p -> GetAllContactIdsForChannel_args -> P.IO ()
write_GetAllContactIdsForChannel_args oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_args record
encode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_args -> LBS.ByteString
encode_GetAllContactIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_args record
to_GetAllContactIdsForChannel_args :: T.ThriftVal -> GetAllContactIdsForChannel_args
to_GetAllContactIdsForChannel_args (T.TStruct fields) = GetAllContactIdsForChannel_args{

  }
to_GetAllContactIdsForChannel_args _ = P.error "not a struct"
read_GetAllContactIdsForChannel_args :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_args
read_GetAllContactIdsForChannel_args iprot = to_GetAllContactIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args)
decode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_args
decode_GetAllContactIdsForChannel_args iprot bs = to_GetAllContactIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args) bs
typemap_GetAllContactIdsForChannel_args :: T.TypeMap
typemap_GetAllContactIdsForChannel_args = Map.fromList []
default_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args
default_GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args{
}
data GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result  { getAllContactIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getAllContactIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIdsForChannel_result_success record   `H.hashWithSalt` getAllContactIdsForChannel_result_e record  
instance QC.Arbitrary GetAllContactIdsForChannel_result where 
  arbitrary = M.liftM GetAllContactIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj}
    , if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj}
    ]
from_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result -> T.ThriftVal
from_GetAllContactIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10492 -> (1, ("e",from_TalkException _v10492))) <$> getAllContactIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10492 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10494 -> T.TString $ E.encodeUtf8 _v10494) $ Vector.toList _v10492))) $ getAllContactIdsForChannel_result_success record
    , (\_v10492 -> (1, ("e",from_TalkException _v10492))) <$> getAllContactIdsForChannel_result_e record
    ]
    )
write_GetAllContactIdsForChannel_result :: T.Protocol p => p -> GetAllContactIdsForChannel_result -> P.IO ()
write_GetAllContactIdsForChannel_result oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_result record
encode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_result -> LBS.ByteString
encode_GetAllContactIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_result record
to_GetAllContactIdsForChannel_result :: T.ThriftVal -> GetAllContactIdsForChannel_result
to_GetAllContactIdsForChannel_result (T.TStruct fields) = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = P.maybe (getAllContactIdsForChannel_result_success default_GetAllContactIdsForChannel_result) (\(_,_val10496) -> (case _val10496 of {T.TList _ _val10497 -> (Vector.fromList $ P.map (\_v10498 -> (case _v10498 of {T.TString _val10499 -> E.decodeUtf8 _val10499; _ -> P.error "wrong type"})) _val10497); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10496) -> P.Just (case _val10496 of {T.TStruct _val10500 -> (to_TalkException (T.TStruct _val10500)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIdsForChannel_result _ = P.error "not a struct"
read_GetAllContactIdsForChannel_result :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_result
read_GetAllContactIdsForChannel_result iprot = to_GetAllContactIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result)
decode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_result
decode_GetAllContactIdsForChannel_result iprot bs = to_GetAllContactIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result) bs
typemap_GetAllContactIdsForChannel_result :: T.TypeMap
typemap_GetAllContactIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result
default_GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = Vector.empty,
  getAllContactIdsForChannel_result_e = P.Nothing}
data DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DisplayBuddySubscriberCount_args where 
  arbitrary = QC.elements [DisplayBuddySubscriberCount_args]
from_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args -> T.ThriftVal
from_DisplayBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> DisplayBuddySubscriberCount_args -> P.IO ()
write_DisplayBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_args record
encode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_args -> LBS.ByteString
encode_DisplayBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_args record
to_DisplayBuddySubscriberCount_args :: T.ThriftVal -> DisplayBuddySubscriberCount_args
to_DisplayBuddySubscriberCount_args (T.TStruct fields) = DisplayBuddySubscriberCount_args{

  }
to_DisplayBuddySubscriberCount_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_args
read_DisplayBuddySubscriberCount_args iprot = to_DisplayBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args)
decode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_args
decode_DisplayBuddySubscriberCount_args iprot bs = to_DisplayBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args) bs
typemap_DisplayBuddySubscriberCount_args :: T.TypeMap
typemap_DisplayBuddySubscriberCount_args = Map.fromList []
default_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args
default_DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args{
}
data DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result  { displayBuddySubscriberCount_result_success :: I.Int64
  , displayBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCount_result_success record   `H.hashWithSalt` displayBuddySubscriberCount_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCount_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj}
    , if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj}
    ]
from_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result -> T.ThriftVal
from_DisplayBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10508 -> (1, ("e",from_TalkException _v10508))) <$> displayBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10508 -> P.Just (0, ("success",T.TI64 _v10508))) $ displayBuddySubscriberCount_result_success record
    , (\_v10508 -> (1, ("e",from_TalkException _v10508))) <$> displayBuddySubscriberCount_result_e record
    ]
    )
write_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> DisplayBuddySubscriberCount_result -> P.IO ()
write_DisplayBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_result record
encode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_result -> LBS.ByteString
encode_DisplayBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_result record
to_DisplayBuddySubscriberCount_result :: T.ThriftVal -> DisplayBuddySubscriberCount_result
to_DisplayBuddySubscriberCount_result (T.TStruct fields) = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = P.maybe (displayBuddySubscriberCount_result_success default_DisplayBuddySubscriberCount_result) (\(_,_val10510) -> (case _val10510 of {T.TI64 _val10511 -> _val10511; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val10510) -> P.Just (case _val10510 of {T.TStruct _val10512 -> (to_TalkException (T.TStruct _val10512)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCount_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_result
read_DisplayBuddySubscriberCount_result iprot = to_DisplayBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result)
decode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_result
decode_DisplayBuddySubscriberCount_result iprot bs = to_DisplayBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result) bs
typemap_DisplayBuddySubscriberCount_result :: T.TypeMap
typemap_DisplayBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result
default_DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = 0,
  displayBuddySubscriberCount_result_e = P.Nothing}
data GetProfileForChannel_args = GetProfileForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfileForChannel_args where 
  arbitrary = QC.elements [GetProfileForChannel_args]
from_GetProfileForChannel_args :: GetProfileForChannel_args -> T.ThriftVal
from_GetProfileForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfileForChannel_args :: T.Protocol p => p -> GetProfileForChannel_args -> P.IO ()
write_GetProfileForChannel_args oprot record = T.writeVal oprot $ from_GetProfileForChannel_args record
encode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> GetProfileForChannel_args -> LBS.ByteString
encode_GetProfileForChannel_args oprot record = T.serializeVal oprot $ from_GetProfileForChannel_args record
to_GetProfileForChannel_args :: T.ThriftVal -> GetProfileForChannel_args
to_GetProfileForChannel_args (T.TStruct fields) = GetProfileForChannel_args{

  }
to_GetProfileForChannel_args _ = P.error "not a struct"
read_GetProfileForChannel_args :: T.Protocol p => p -> P.IO GetProfileForChannel_args
read_GetProfileForChannel_args iprot = to_GetProfileForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args)
decode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_args
decode_GetProfileForChannel_args iprot bs = to_GetProfileForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args) bs
typemap_GetProfileForChannel_args :: T.TypeMap
typemap_GetProfileForChannel_args = Map.fromList []
default_GetProfileForChannel_args :: GetProfileForChannel_args
default_GetProfileForChannel_args = GetProfileForChannel_args{
}
data GetProfileForChannel_result = GetProfileForChannel_result  { getProfileForChannel_result_success :: Profile
  , getProfileForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfileForChannel_result_success record   `H.hashWithSalt` getProfileForChannel_result_e record  
instance QC.Arbitrary GetProfileForChannel_result where 
  arbitrary = M.liftM GetProfileForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfileForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj}
    , if obj == default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj}
    ]
from_GetProfileForChannel_result :: GetProfileForChannel_result -> T.ThriftVal
from_GetProfileForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10520 -> (1, ("e",from_TalkException _v10520))) <$> getProfileForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10520 -> P.Just (0, ("success",from_Profile _v10520))) $ getProfileForChannel_result_success record
    , (\_v10520 -> (1, ("e",from_TalkException _v10520))) <$> getProfileForChannel_result_e record
    ]
    )
write_GetProfileForChannel_result :: T.Protocol p => p -> GetProfileForChannel_result -> P.IO ()
write_GetProfileForChannel_result oprot record = T.writeVal oprot $ from_GetProfileForChannel_result record
encode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> GetProfileForChannel_result -> LBS.ByteString
encode_GetProfileForChannel_result oprot record = T.serializeVal oprot $ from_GetProfileForChannel_result record
to_GetProfileForChannel_result :: T.ThriftVal -> GetProfileForChannel_result
to_GetProfileForChannel_result (T.TStruct fields) = GetProfileForChannel_result{
  getProfileForChannel_result_success = P.maybe (getProfileForChannel_result_success default_GetProfileForChannel_result) (\(_,_val10522) -> (case _val10522 of {T.TStruct _val10523 -> (to_Profile (T.TStruct _val10523)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfileForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10522) -> P.Just (case _val10522 of {T.TStruct _val10524 -> (to_TalkException (T.TStruct _val10524)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfileForChannel_result _ = P.error "not a struct"
read_GetProfileForChannel_result :: T.Protocol p => p -> P.IO GetProfileForChannel_result
read_GetProfileForChannel_result iprot = to_GetProfileForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result)
decode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_result
decode_GetProfileForChannel_result iprot bs = to_GetProfileForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result) bs
typemap_GetProfileForChannel_result :: T.TypeMap
typemap_GetProfileForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfileForChannel_result :: GetProfileForChannel_result
default_GetProfileForChannel_result = GetProfileForChannel_result{
  getProfileForChannel_result_success = default_Profile,
  getProfileForChannel_result_e = P.Nothing}
data GetUserTickets_args = GetUserTickets_args  { getUserTickets_args_userMids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTickets_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTickets_args_userMids record  
instance QC.Arbitrary GetUserTickets_args where 
  arbitrary = M.liftM GetUserTickets_args (QC.arbitrary)
  shrink obj | obj == default_GetUserTickets_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTickets_args{getUserTickets_args_userMids = getUserTickets_args_userMids obj} then P.Nothing else P.Just $ default_GetUserTickets_args{getUserTickets_args_userMids = getUserTickets_args_userMids obj}
    ]
from_GetUserTickets_args :: GetUserTickets_args -> T.ThriftVal
from_GetUserTickets_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10527 -> P.Just (1, ("userMids",T.TList T.T_STRING $ P.map (\_v10529 -> T.TString $ E.encodeUtf8 _v10529) $ Vector.toList _v10527))) $ getUserTickets_args_userMids record
  ]
write_GetUserTickets_args :: T.Protocol p => p -> GetUserTickets_args -> P.IO ()
write_GetUserTickets_args oprot record = T.writeVal oprot $ from_GetUserTickets_args record
encode_GetUserTickets_args :: T.StatelessProtocol p => p -> GetUserTickets_args -> LBS.ByteString
encode_GetUserTickets_args oprot record = T.serializeVal oprot $ from_GetUserTickets_args record
to_GetUserTickets_args :: T.ThriftVal -> GetUserTickets_args
to_GetUserTickets_args (T.TStruct fields) = GetUserTickets_args{
  getUserTickets_args_userMids = P.maybe (getUserTickets_args_userMids default_GetUserTickets_args) (\(_,_val10531) -> (case _val10531 of {T.TList _ _val10532 -> (Vector.fromList $ P.map (\_v10533 -> (case _v10533 of {T.TString _val10534 -> E.decodeUtf8 _val10534; _ -> P.error "wrong type"})) _val10532); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTickets_args _ = P.error "not a struct"
read_GetUserTickets_args :: T.Protocol p => p -> P.IO GetUserTickets_args
read_GetUserTickets_args iprot = to_GetUserTickets_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTickets_args)
decode_GetUserTickets_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTickets_args
decode_GetUserTickets_args iprot bs = to_GetUserTickets_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTickets_args) bs
typemap_GetUserTickets_args :: T.TypeMap
typemap_GetUserTickets_args = Map.fromList [(1,("userMids",(T.T_LIST T.T_STRING)))]
default_GetUserTickets_args :: GetUserTickets_args
default_GetUserTickets_args = GetUserTickets_args{
  getUserTickets_args_userMids = Vector.empty}
data GetUserTickets_result = GetUserTickets_result  { getUserTickets_result_success :: (Vector.Vector UserTicketResponse)
  , getUserTickets_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserTickets_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserTickets_result_success record   `H.hashWithSalt` getUserTickets_result_e record  
instance QC.Arbitrary GetUserTickets_result where 
  arbitrary = M.liftM GetUserTickets_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserTickets_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserTickets_result{getUserTickets_result_success = getUserTickets_result_success obj} then P.Nothing else P.Just $ default_GetUserTickets_result{getUserTickets_result_success = getUserTickets_result_success obj}
    , if obj == default_GetUserTickets_result{getUserTickets_result_e = getUserTickets_result_e obj} then P.Nothing else P.Just $ default_GetUserTickets_result{getUserTickets_result_e = getUserTickets_result_e obj}
    ]
from_GetUserTickets_result :: GetUserTickets_result -> T.ThriftVal
from_GetUserTickets_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10537 -> (1, ("e",from_TalkException _v10537))) <$> getUserTickets_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10537 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_UserTicketResponse) $ P.map (\_v10539 -> from_UserTicketResponse _v10539) $ Vector.toList _v10537))) $ getUserTickets_result_success record
    , (\_v10537 -> (1, ("e",from_TalkException _v10537))) <$> getUserTickets_result_e record
    ]
    )
write_GetUserTickets_result :: T.Protocol p => p -> GetUserTickets_result -> P.IO ()
write_GetUserTickets_result oprot record = T.writeVal oprot $ from_GetUserTickets_result record
encode_GetUserTickets_result :: T.StatelessProtocol p => p -> GetUserTickets_result -> LBS.ByteString
encode_GetUserTickets_result oprot record = T.serializeVal oprot $ from_GetUserTickets_result record
to_GetUserTickets_result :: T.ThriftVal -> GetUserTickets_result
to_GetUserTickets_result (T.TStruct fields) = GetUserTickets_result{
  getUserTickets_result_success = P.maybe (getUserTickets_result_success default_GetUserTickets_result) (\(_,_val10541) -> (case _val10541 of {T.TList _ _val10542 -> (Vector.fromList $ P.map (\_v10543 -> (case _v10543 of {T.TStruct _val10544 -> (to_UserTicketResponse (T.TStruct _val10544)); _ -> P.error "wrong type"})) _val10542); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserTickets_result_e = P.maybe (P.Nothing) (\(_,_val10541) -> P.Just (case _val10541 of {T.TStruct _val10545 -> (to_TalkException (T.TStruct _val10545)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserTickets_result _ = P.error "not a struct"
read_GetUserTickets_result :: T.Protocol p => p -> P.IO GetUserTickets_result
read_GetUserTickets_result iprot = to_GetUserTickets_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserTickets_result)
decode_GetUserTickets_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserTickets_result
decode_GetUserTickets_result iprot bs = to_GetUserTickets_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserTickets_result) bs
typemap_GetUserTickets_result :: T.TypeMap
typemap_GetUserTickets_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_UserTicketResponse)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserTickets_result :: GetUserTickets_result
default_GetUserTickets_result = GetUserTickets_result{
  getUserTickets_result_success = Vector.empty,
  getUserTickets_result_e = P.Nothing}
data GetOAFriendMids_args = GetOAFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetOAFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetOAFriendMids_args where 
  arbitrary = QC.elements [GetOAFriendMids_args]
from_GetOAFriendMids_args :: GetOAFriendMids_args -> T.ThriftVal
from_GetOAFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetOAFriendMids_args :: T.Protocol p => p -> GetOAFriendMids_args -> P.IO ()
write_GetOAFriendMids_args oprot record = T.writeVal oprot $ from_GetOAFriendMids_args record
encode_GetOAFriendMids_args :: T.StatelessProtocol p => p -> GetOAFriendMids_args -> LBS.ByteString
encode_GetOAFriendMids_args oprot record = T.serializeVal oprot $ from_GetOAFriendMids_args record
to_GetOAFriendMids_args :: T.ThriftVal -> GetOAFriendMids_args
to_GetOAFriendMids_args (T.TStruct fields) = GetOAFriendMids_args{

  }
to_GetOAFriendMids_args _ = P.error "not a struct"
read_GetOAFriendMids_args :: T.Protocol p => p -> P.IO GetOAFriendMids_args
read_GetOAFriendMids_args iprot = to_GetOAFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetOAFriendMids_args)
decode_GetOAFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetOAFriendMids_args
decode_GetOAFriendMids_args iprot bs = to_GetOAFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetOAFriendMids_args) bs
typemap_GetOAFriendMids_args :: T.TypeMap
typemap_GetOAFriendMids_args = Map.fromList []
default_GetOAFriendMids_args :: GetOAFriendMids_args
default_GetOAFriendMids_args = GetOAFriendMids_args{
}
data GetOAFriendMids_result = GetOAFriendMids_result  { getOAFriendMids_result_success :: (Vector.Vector LT.Text)
  , getOAFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetOAFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getOAFriendMids_result_success record   `H.hashWithSalt` getOAFriendMids_result_e record  
instance QC.Arbitrary GetOAFriendMids_result where 
  arbitrary = M.liftM GetOAFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetOAFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetOAFriendMids_result{getOAFriendMids_result_success = getOAFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetOAFriendMids_result{getOAFriendMids_result_success = getOAFriendMids_result_success obj}
    , if obj == default_GetOAFriendMids_result{getOAFriendMids_result_e = getOAFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetOAFriendMids_result{getOAFriendMids_result_e = getOAFriendMids_result_e obj}
    ]
from_GetOAFriendMids_result :: GetOAFriendMids_result -> T.ThriftVal
from_GetOAFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10553 -> (1, ("e",from_TalkException _v10553))) <$> getOAFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10553 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10555 -> T.TString $ E.encodeUtf8 _v10555) $ Vector.toList _v10553))) $ getOAFriendMids_result_success record
    , (\_v10553 -> (1, ("e",from_TalkException _v10553))) <$> getOAFriendMids_result_e record
    ]
    )
write_GetOAFriendMids_result :: T.Protocol p => p -> GetOAFriendMids_result -> P.IO ()
write_GetOAFriendMids_result oprot record = T.writeVal oprot $ from_GetOAFriendMids_result record
encode_GetOAFriendMids_result :: T.StatelessProtocol p => p -> GetOAFriendMids_result -> LBS.ByteString
encode_GetOAFriendMids_result oprot record = T.serializeVal oprot $ from_GetOAFriendMids_result record
to_GetOAFriendMids_result :: T.ThriftVal -> GetOAFriendMids_result
to_GetOAFriendMids_result (T.TStruct fields) = GetOAFriendMids_result{
  getOAFriendMids_result_success = P.maybe (getOAFriendMids_result_success default_GetOAFriendMids_result) (\(_,_val10557) -> (case _val10557 of {T.TList _ _val10558 -> (Vector.fromList $ P.map (\_v10559 -> (case _v10559 of {T.TString _val10560 -> E.decodeUtf8 _val10560; _ -> P.error "wrong type"})) _val10558); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getOAFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val10557) -> P.Just (case _val10557 of {T.TStruct _val10561 -> (to_TalkException (T.TStruct _val10561)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetOAFriendMids_result _ = P.error "not a struct"
read_GetOAFriendMids_result :: T.Protocol p => p -> P.IO GetOAFriendMids_result
read_GetOAFriendMids_result iprot = to_GetOAFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetOAFriendMids_result)
decode_GetOAFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetOAFriendMids_result
decode_GetOAFriendMids_result iprot bs = to_GetOAFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetOAFriendMids_result) bs
typemap_GetOAFriendMids_result :: T.TypeMap
typemap_GetOAFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetOAFriendMids_result :: GetOAFriendMids_result
default_GetOAFriendMids_result = GetOAFriendMids_result{
  getOAFriendMids_result_success = Vector.empty,
  getOAFriendMids_result_e = P.Nothing}
data SearchPaidCallUserRate_args = SearchPaidCallUserRate_args  { searchPaidCallUserRate_args_countryCode :: LT.Text
  , searchPaidCallUserRate_args_language :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchPaidCallUserRate_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchPaidCallUserRate_args_countryCode record   `H.hashWithSalt` searchPaidCallUserRate_args_language record  
instance QC.Arbitrary SearchPaidCallUserRate_args where 
  arbitrary = M.liftM SearchPaidCallUserRate_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SearchPaidCallUserRate_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_countryCode = searchPaidCallUserRate_args_countryCode obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_countryCode = searchPaidCallUserRate_args_countryCode obj}
    , if obj == default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_language = searchPaidCallUserRate_args_language obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_args{searchPaidCallUserRate_args_language = searchPaidCallUserRate_args_language obj}
    ]
from_SearchPaidCallUserRate_args :: SearchPaidCallUserRate_args -> T.ThriftVal
from_SearchPaidCallUserRate_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10564 -> P.Just (2, ("countryCode",T.TString $ E.encodeUtf8 _v10564))) $ searchPaidCallUserRate_args_countryCode record
  , (\_v10564 -> P.Just (3, ("language",T.TString $ E.encodeUtf8 _v10564))) $ searchPaidCallUserRate_args_language record
  ]
write_SearchPaidCallUserRate_args :: T.Protocol p => p -> SearchPaidCallUserRate_args -> P.IO ()
write_SearchPaidCallUserRate_args oprot record = T.writeVal oprot $ from_SearchPaidCallUserRate_args record
encode_SearchPaidCallUserRate_args :: T.StatelessProtocol p => p -> SearchPaidCallUserRate_args -> LBS.ByteString
encode_SearchPaidCallUserRate_args oprot record = T.serializeVal oprot $ from_SearchPaidCallUserRate_args record
to_SearchPaidCallUserRate_args :: T.ThriftVal -> SearchPaidCallUserRate_args
to_SearchPaidCallUserRate_args (T.TStruct fields) = SearchPaidCallUserRate_args{
  searchPaidCallUserRate_args_countryCode = P.maybe (searchPaidCallUserRate_args_countryCode default_SearchPaidCallUserRate_args) (\(_,_val10566) -> (case _val10566 of {T.TString _val10567 -> E.decodeUtf8 _val10567; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  searchPaidCallUserRate_args_language = P.maybe (searchPaidCallUserRate_args_language default_SearchPaidCallUserRate_args) (\(_,_val10566) -> (case _val10566 of {T.TString _val10568 -> E.decodeUtf8 _val10568; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SearchPaidCallUserRate_args _ = P.error "not a struct"
read_SearchPaidCallUserRate_args :: T.Protocol p => p -> P.IO SearchPaidCallUserRate_args
read_SearchPaidCallUserRate_args iprot = to_SearchPaidCallUserRate_args <$> T.readVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_args)
decode_SearchPaidCallUserRate_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchPaidCallUserRate_args
decode_SearchPaidCallUserRate_args iprot bs = to_SearchPaidCallUserRate_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_args) bs
typemap_SearchPaidCallUserRate_args :: T.TypeMap
typemap_SearchPaidCallUserRate_args = Map.fromList [(2,("countryCode",T.T_STRING)),(3,("language",T.T_STRING))]
default_SearchPaidCallUserRate_args :: SearchPaidCallUserRate_args
default_SearchPaidCallUserRate_args = SearchPaidCallUserRate_args{
  searchPaidCallUserRate_args_countryCode = "",
  searchPaidCallUserRate_args_language = ""}
data SearchPaidCallUserRate_result = SearchPaidCallUserRate_result  { searchPaidCallUserRate_result_success :: (Vector.Vector PaidCallUserRate)
  , searchPaidCallUserRate_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SearchPaidCallUserRate_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` searchPaidCallUserRate_result_success record   `H.hashWithSalt` searchPaidCallUserRate_result_e record  
instance QC.Arbitrary SearchPaidCallUserRate_result where 
  arbitrary = M.liftM SearchPaidCallUserRate_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SearchPaidCallUserRate_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = searchPaidCallUserRate_result_success obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = searchPaidCallUserRate_result_success obj}
    , if obj == default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = searchPaidCallUserRate_result_e obj} then P.Nothing else P.Just $ default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = searchPaidCallUserRate_result_e obj}
    ]
from_SearchPaidCallUserRate_result :: SearchPaidCallUserRate_result -> T.ThriftVal
from_SearchPaidCallUserRate_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10571 -> (1, ("e",from_TalkException _v10571))) <$> searchPaidCallUserRate_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10571 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_PaidCallUserRate) $ P.map (\_v10573 -> from_PaidCallUserRate _v10573) $ Vector.toList _v10571))) $ searchPaidCallUserRate_result_success record
    , (\_v10571 -> (1, ("e",from_TalkException _v10571))) <$> searchPaidCallUserRate_result_e record
    ]
    )
write_SearchPaidCallUserRate_result :: T.Protocol p => p -> SearchPaidCallUserRate_result -> P.IO ()
write_SearchPaidCallUserRate_result oprot record = T.writeVal oprot $ from_SearchPaidCallUserRate_result record
encode_SearchPaidCallUserRate_result :: T.StatelessProtocol p => p -> SearchPaidCallUserRate_result -> LBS.ByteString
encode_SearchPaidCallUserRate_result oprot record = T.serializeVal oprot $ from_SearchPaidCallUserRate_result record
to_SearchPaidCallUserRate_result :: T.ThriftVal -> SearchPaidCallUserRate_result
to_SearchPaidCallUserRate_result (T.TStruct fields) = SearchPaidCallUserRate_result{
  searchPaidCallUserRate_result_success = P.maybe (searchPaidCallUserRate_result_success default_SearchPaidCallUserRate_result) (\(_,_val10575) -> (case _val10575 of {T.TList _ _val10576 -> (Vector.fromList $ P.map (\_v10577 -> (case _v10577 of {T.TStruct _val10578 -> (to_PaidCallUserRate (T.TStruct _val10578)); _ -> P.error "wrong type"})) _val10576); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  searchPaidCallUserRate_result_e = P.maybe (P.Nothing) (\(_,_val10575) -> P.Just (case _val10575 of {T.TStruct _val10579 -> (to_TalkException (T.TStruct _val10579)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SearchPaidCallUserRate_result _ = P.error "not a struct"
read_SearchPaidCallUserRate_result :: T.Protocol p => p -> P.IO SearchPaidCallUserRate_result
read_SearchPaidCallUserRate_result iprot = to_SearchPaidCallUserRate_result <$> T.readVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_result)
decode_SearchPaidCallUserRate_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SearchPaidCallUserRate_result
decode_SearchPaidCallUserRate_result iprot bs = to_SearchPaidCallUserRate_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SearchPaidCallUserRate_result) bs
typemap_SearchPaidCallUserRate_result :: T.TypeMap
typemap_SearchPaidCallUserRate_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_PaidCallUserRate)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SearchPaidCallUserRate_result :: SearchPaidCallUserRate_result
default_SearchPaidCallUserRate_result = SearchPaidCallUserRate_result{
  searchPaidCallUserRate_result_success = Vector.empty,
  searchPaidCallUserRate_result_e = P.Nothing}
data GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetJoinedGroupIdsForChannel_args]
from_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_args -> P.IO ()
write_GetJoinedGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
encode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_args -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
to_GetJoinedGroupIdsForChannel_args :: T.ThriftVal -> GetJoinedGroupIdsForChannel_args
to_GetJoinedGroupIdsForChannel_args (T.TStruct fields) = GetJoinedGroupIdsForChannel_args{

  }
to_GetJoinedGroupIdsForChannel_args _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_args
read_GetJoinedGroupIdsForChannel_args iprot = to_GetJoinedGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args)
decode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_args
decode_GetJoinedGroupIdsForChannel_args iprot bs = to_GetJoinedGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args) bs
typemap_GetJoinedGroupIdsForChannel_args :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_args = Map.fromList []
default_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args
default_GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args{
}
data GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result  { getJoinedGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getJoinedGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_success record   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_result where 
  arbitrary = M.liftM GetJoinedGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj}
    , if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj}
    ]
from_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10587 -> (1, ("e",from_TalkException _v10587))) <$> getJoinedGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10587 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10589 -> T.TString $ E.encodeUtf8 _v10589) $ Vector.toList _v10587))) $ getJoinedGroupIdsForChannel_result_success record
    , (\_v10587 -> (1, ("e",from_TalkException _v10587))) <$> getJoinedGroupIdsForChannel_result_e record
    ]
    )
write_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_result -> P.IO ()
write_GetJoinedGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
encode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_result -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
to_GetJoinedGroupIdsForChannel_result :: T.ThriftVal -> GetJoinedGroupIdsForChannel_result
to_GetJoinedGroupIdsForChannel_result (T.TStruct fields) = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = P.maybe (getJoinedGroupIdsForChannel_result_success default_GetJoinedGroupIdsForChannel_result) (\(_,_val10591) -> (case _val10591 of {T.TList _ _val10592 -> (Vector.fromList $ P.map (\_v10593 -> (case _v10593 of {T.TString _val10594 -> E.decodeUtf8 _val10594; _ -> P.error "wrong type"})) _val10592); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10591) -> P.Just (case _val10591 of {T.TStruct _val10595 -> (to_TalkException (T.TStruct _val10595)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedGroupIdsForChannel_result _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_result
read_GetJoinedGroupIdsForChannel_result iprot = to_GetJoinedGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result)
decode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_result
decode_GetJoinedGroupIdsForChannel_result iprot bs = to_GetJoinedGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result) bs
typemap_GetJoinedGroupIdsForChannel_result :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result
default_GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = Vector.empty,
  getJoinedGroupIdsForChannel_result_e = P.Nothing}
data AcquireGroupCallRoute_args = AcquireGroupCallRoute_args  { acquireGroupCallRoute_args_chatMid :: LT.Text
  , acquireGroupCallRoute_args_mediaType :: GroupCallMediaType
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireGroupCallRoute_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireGroupCallRoute_args_chatMid record   `H.hashWithSalt` acquireGroupCallRoute_args_mediaType record  
instance QC.Arbitrary AcquireGroupCallRoute_args where 
  arbitrary = M.liftM AcquireGroupCallRoute_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AcquireGroupCallRoute_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_chatMid = acquireGroupCallRoute_args_chatMid obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_chatMid = acquireGroupCallRoute_args_chatMid obj}
    , if obj == default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_mediaType = acquireGroupCallRoute_args_mediaType obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_args{acquireGroupCallRoute_args_mediaType = acquireGroupCallRoute_args_mediaType obj}
    ]
from_AcquireGroupCallRoute_args :: AcquireGroupCallRoute_args -> T.ThriftVal
from_AcquireGroupCallRoute_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10598 -> P.Just (2, ("chatMid",T.TString $ E.encodeUtf8 _v10598))) $ acquireGroupCallRoute_args_chatMid record
  , (\_v10598 -> P.Just (3, ("mediaType",T.TI32 $ P.fromIntegral $ P.fromEnum _v10598))) $ acquireGroupCallRoute_args_mediaType record
  ]
write_AcquireGroupCallRoute_args :: T.Protocol p => p -> AcquireGroupCallRoute_args -> P.IO ()
write_AcquireGroupCallRoute_args oprot record = T.writeVal oprot $ from_AcquireGroupCallRoute_args record
encode_AcquireGroupCallRoute_args :: T.StatelessProtocol p => p -> AcquireGroupCallRoute_args -> LBS.ByteString
encode_AcquireGroupCallRoute_args oprot record = T.serializeVal oprot $ from_AcquireGroupCallRoute_args record
to_AcquireGroupCallRoute_args :: T.ThriftVal -> AcquireGroupCallRoute_args
to_AcquireGroupCallRoute_args (T.TStruct fields) = AcquireGroupCallRoute_args{
  acquireGroupCallRoute_args_chatMid = P.maybe (acquireGroupCallRoute_args_chatMid default_AcquireGroupCallRoute_args) (\(_,_val10600) -> (case _val10600 of {T.TString _val10601 -> E.decodeUtf8 _val10601; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  acquireGroupCallRoute_args_mediaType = P.maybe (acquireGroupCallRoute_args_mediaType default_AcquireGroupCallRoute_args) (\(_,_val10600) -> (case _val10600 of {T.TI32 _val10602 -> P.toEnum $ P.fromIntegral _val10602; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AcquireGroupCallRoute_args _ = P.error "not a struct"
read_AcquireGroupCallRoute_args :: T.Protocol p => p -> P.IO AcquireGroupCallRoute_args
read_AcquireGroupCallRoute_args iprot = to_AcquireGroupCallRoute_args <$> T.readVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_args)
decode_AcquireGroupCallRoute_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireGroupCallRoute_args
decode_AcquireGroupCallRoute_args iprot bs = to_AcquireGroupCallRoute_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_args) bs
typemap_AcquireGroupCallRoute_args :: T.TypeMap
typemap_AcquireGroupCallRoute_args = Map.fromList [(2,("chatMid",T.T_STRING)),(3,("mediaType",T.T_I32))]
default_AcquireGroupCallRoute_args :: AcquireGroupCallRoute_args
default_AcquireGroupCallRoute_args = AcquireGroupCallRoute_args{
  acquireGroupCallRoute_args_chatMid = "",
  acquireGroupCallRoute_args_mediaType = (P.toEnum 0)}
data AcquireGroupCallRoute_result = AcquireGroupCallRoute_result  { acquireGroupCallRoute_result_success :: GroupCallRoute
  , acquireGroupCallRoute_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AcquireGroupCallRoute_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` acquireGroupCallRoute_result_success record   `H.hashWithSalt` acquireGroupCallRoute_result_e record  
instance QC.Arbitrary AcquireGroupCallRoute_result where 
  arbitrary = M.liftM AcquireGroupCallRoute_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AcquireGroupCallRoute_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = acquireGroupCallRoute_result_success obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = acquireGroupCallRoute_result_success obj}
    , if obj == default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = acquireGroupCallRoute_result_e obj} then P.Nothing else P.Just $ default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = acquireGroupCallRoute_result_e obj}
    ]
from_AcquireGroupCallRoute_result :: AcquireGroupCallRoute_result -> T.ThriftVal
from_AcquireGroupCallRoute_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10605 -> (1, ("e",from_TalkException _v10605))) <$> acquireGroupCallRoute_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10605 -> P.Just (0, ("success",from_GroupCallRoute _v10605))) $ acquireGroupCallRoute_result_success record
    , (\_v10605 -> (1, ("e",from_TalkException _v10605))) <$> acquireGroupCallRoute_result_e record
    ]
    )
write_AcquireGroupCallRoute_result :: T.Protocol p => p -> AcquireGroupCallRoute_result -> P.IO ()
write_AcquireGroupCallRoute_result oprot record = T.writeVal oprot $ from_AcquireGroupCallRoute_result record
encode_AcquireGroupCallRoute_result :: T.StatelessProtocol p => p -> AcquireGroupCallRoute_result -> LBS.ByteString
encode_AcquireGroupCallRoute_result oprot record = T.serializeVal oprot $ from_AcquireGroupCallRoute_result record
to_AcquireGroupCallRoute_result :: T.ThriftVal -> AcquireGroupCallRoute_result
to_AcquireGroupCallRoute_result (T.TStruct fields) = AcquireGroupCallRoute_result{
  acquireGroupCallRoute_result_success = P.maybe (acquireGroupCallRoute_result_success default_AcquireGroupCallRoute_result) (\(_,_val10607) -> (case _val10607 of {T.TStruct _val10608 -> (to_GroupCallRoute (T.TStruct _val10608)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  acquireGroupCallRoute_result_e = P.maybe (P.Nothing) (\(_,_val10607) -> P.Just (case _val10607 of {T.TStruct _val10609 -> (to_TalkException (T.TStruct _val10609)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AcquireGroupCallRoute_result _ = P.error "not a struct"
read_AcquireGroupCallRoute_result :: T.Protocol p => p -> P.IO AcquireGroupCallRoute_result
read_AcquireGroupCallRoute_result iprot = to_AcquireGroupCallRoute_result <$> T.readVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_result)
decode_AcquireGroupCallRoute_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AcquireGroupCallRoute_result
decode_AcquireGroupCallRoute_result iprot bs = to_AcquireGroupCallRoute_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AcquireGroupCallRoute_result) bs
typemap_AcquireGroupCallRoute_result :: T.TypeMap
typemap_AcquireGroupCallRoute_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_GroupCallRoute))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AcquireGroupCallRoute_result :: AcquireGroupCallRoute_result
default_AcquireGroupCallRoute_result = AcquireGroupCallRoute_result{
  acquireGroupCallRoute_result_success = default_GroupCallRoute,
  acquireGroupCallRoute_result_e = P.Nothing}
data GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserMidsWhoAddedMe_args where 
  arbitrary = QC.elements [GetUserMidsWhoAddedMe_args]
from_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args -> T.ThriftVal
from_GetUserMidsWhoAddedMe_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> GetUserMidsWhoAddedMe_args -> P.IO ()
write_GetUserMidsWhoAddedMe_args oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_args record
encode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_args -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_args oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_args record
to_GetUserMidsWhoAddedMe_args :: T.ThriftVal -> GetUserMidsWhoAddedMe_args
to_GetUserMidsWhoAddedMe_args (T.TStruct fields) = GetUserMidsWhoAddedMe_args{

  }
to_GetUserMidsWhoAddedMe_args _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_args
read_GetUserMidsWhoAddedMe_args iprot = to_GetUserMidsWhoAddedMe_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args)
decode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_args
decode_GetUserMidsWhoAddedMe_args iprot bs = to_GetUserMidsWhoAddedMe_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args) bs
typemap_GetUserMidsWhoAddedMe_args :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_args = Map.fromList []
default_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args
default_GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args{
}
data GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result  { getUserMidsWhoAddedMe_result_success :: (Vector.Vector LT.Text)
  , getUserMidsWhoAddedMe_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserMidsWhoAddedMe_result_success record   `H.hashWithSalt` getUserMidsWhoAddedMe_result_e record  
instance QC.Arbitrary GetUserMidsWhoAddedMe_result where 
  arbitrary = M.liftM GetUserMidsWhoAddedMe_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserMidsWhoAddedMe_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj}
    , if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj}
    ]
from_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result -> T.ThriftVal
from_GetUserMidsWhoAddedMe_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10617 -> (1, ("e",from_TalkException _v10617))) <$> getUserMidsWhoAddedMe_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10617 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v10619 -> T.TString $ E.encodeUtf8 _v10619) $ Vector.toList _v10617))) $ getUserMidsWhoAddedMe_result_success record
    , (\_v10617 -> (1, ("e",from_TalkException _v10617))) <$> getUserMidsWhoAddedMe_result_e record
    ]
    )
write_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> GetUserMidsWhoAddedMe_result -> P.IO ()
write_GetUserMidsWhoAddedMe_result oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_result record
encode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_result -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_result oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_result record
to_GetUserMidsWhoAddedMe_result :: T.ThriftVal -> GetUserMidsWhoAddedMe_result
to_GetUserMidsWhoAddedMe_result (T.TStruct fields) = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = P.maybe (getUserMidsWhoAddedMe_result_success default_GetUserMidsWhoAddedMe_result) (\(_,_val10621) -> (case _val10621 of {T.TList _ _val10622 -> (Vector.fromList $ P.map (\_v10623 -> (case _v10623 of {T.TString _val10624 -> E.decodeUtf8 _val10624; _ -> P.error "wrong type"})) _val10622); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserMidsWhoAddedMe_result_e = P.maybe (P.Nothing) (\(_,_val10621) -> P.Just (case _val10621 of {T.TStruct _val10625 -> (to_TalkException (T.TStruct _val10625)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserMidsWhoAddedMe_result _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_result
read_GetUserMidsWhoAddedMe_result iprot = to_GetUserMidsWhoAddedMe_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result)
decode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_result
decode_GetUserMidsWhoAddedMe_result iprot bs = to_GetUserMidsWhoAddedMe_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result) bs
typemap_GetUserMidsWhoAddedMe_result :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result
default_GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = Vector.empty,
  getUserMidsWhoAddedMe_result_e = P.Nothing}
data GetIdentityCredential_args = GetIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityCredential_args where 
  arbitrary = QC.elements [GetIdentityCredential_args]
from_GetIdentityCredential_args :: GetIdentityCredential_args -> T.ThriftVal
from_GetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityCredential_args :: T.Protocol p => p -> GetIdentityCredential_args -> P.IO ()
write_GetIdentityCredential_args oprot record = T.writeVal oprot $ from_GetIdentityCredential_args record
encode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> GetIdentityCredential_args -> LBS.ByteString
encode_GetIdentityCredential_args oprot record = T.serializeVal oprot $ from_GetIdentityCredential_args record
to_GetIdentityCredential_args :: T.ThriftVal -> GetIdentityCredential_args
to_GetIdentityCredential_args (T.TStruct fields) = GetIdentityCredential_args{

  }
to_GetIdentityCredential_args _ = P.error "not a struct"
read_GetIdentityCredential_args :: T.Protocol p => p -> P.IO GetIdentityCredential_args
read_GetIdentityCredential_args iprot = to_GetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args)
decode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_args
decode_GetIdentityCredential_args iprot bs = to_GetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args) bs
typemap_GetIdentityCredential_args :: T.TypeMap
typemap_GetIdentityCredential_args = Map.fromList []
default_GetIdentityCredential_args :: GetIdentityCredential_args
default_GetIdentityCredential_args = GetIdentityCredential_args{
}
data GetIdentityCredential_result = GetIdentityCredential_result  { getIdentityCredential_result_success :: IdentityCredential
  , getIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityCredential_result_success record   `H.hashWithSalt` getIdentityCredential_result_e record  
instance QC.Arbitrary GetIdentityCredential_result where 
  arbitrary = M.liftM GetIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj}
    , if obj == default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj}
    ]
from_GetIdentityCredential_result :: GetIdentityCredential_result -> T.ThriftVal
from_GetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10633 -> (1, ("e",from_TalkException _v10633))) <$> getIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10633 -> P.Just (0, ("success",from_IdentityCredential _v10633))) $ getIdentityCredential_result_success record
    , (\_v10633 -> (1, ("e",from_TalkException _v10633))) <$> getIdentityCredential_result_e record
    ]
    )
write_GetIdentityCredential_result :: T.Protocol p => p -> GetIdentityCredential_result -> P.IO ()
write_GetIdentityCredential_result oprot record = T.writeVal oprot $ from_GetIdentityCredential_result record
encode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> GetIdentityCredential_result -> LBS.ByteString
encode_GetIdentityCredential_result oprot record = T.serializeVal oprot $ from_GetIdentityCredential_result record
to_GetIdentityCredential_result :: T.ThriftVal -> GetIdentityCredential_result
to_GetIdentityCredential_result (T.TStruct fields) = GetIdentityCredential_result{
  getIdentityCredential_result_success = P.maybe (getIdentityCredential_result_success default_GetIdentityCredential_result) (\(_,_val10635) -> (case _val10635 of {T.TStruct _val10636 -> (to_IdentityCredential (T.TStruct _val10636)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val10635) -> P.Just (case _val10635 of {T.TStruct _val10637 -> (to_TalkException (T.TStruct _val10637)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityCredential_result _ = P.error "not a struct"
read_GetIdentityCredential_result :: T.Protocol p => p -> P.IO GetIdentityCredential_result
read_GetIdentityCredential_result iprot = to_GetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result)
decode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_result
decode_GetIdentityCredential_result iprot bs = to_GetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result) bs
typemap_GetIdentityCredential_result :: T.TypeMap
typemap_GetIdentityCredential_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_IdentityCredential))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityCredential_result :: GetIdentityCredential_result
default_GetIdentityCredential_result = GetIdentityCredential_result{
  getIdentityCredential_result_success = default_IdentityCredential,
  getIdentityCredential_result_e = P.Nothing}
data AddOperationForChannel_args = AddOperationForChannel_args  { addOperationForChannel_args_opType :: OpType
  , addOperationForChannel_args_param1 :: LT.Text
  , addOperationForChannel_args_param2 :: LT.Text
  , addOperationForChannel_args_param3 :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_args_opType record   `H.hashWithSalt` addOperationForChannel_args_param1 record   `H.hashWithSalt` addOperationForChannel_args_param2 record   `H.hashWithSalt` addOperationForChannel_args_param3 record  
instance QC.Arbitrary AddOperationForChannel_args where 
  arbitrary = M.liftM AddOperationForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj}
    ]
from_AddOperationForChannel_args :: AddOperationForChannel_args -> T.ThriftVal
from_AddOperationForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10640 -> P.Just (1, ("opType",T.TI32 $ P.fromIntegral $ P.fromEnum _v10640))) $ addOperationForChannel_args_opType record
  , (\_v10640 -> P.Just (2, ("param1",T.TString $ E.encodeUtf8 _v10640))) $ addOperationForChannel_args_param1 record
  , (\_v10640 -> P.Just (3, ("param2",T.TString $ E.encodeUtf8 _v10640))) $ addOperationForChannel_args_param2 record
  , (\_v10640 -> P.Just (4, ("param3",T.TString $ E.encodeUtf8 _v10640))) $ addOperationForChannel_args_param3 record
  ]
write_AddOperationForChannel_args :: T.Protocol p => p -> AddOperationForChannel_args -> P.IO ()
write_AddOperationForChannel_args oprot record = T.writeVal oprot $ from_AddOperationForChannel_args record
encode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> AddOperationForChannel_args -> LBS.ByteString
encode_AddOperationForChannel_args oprot record = T.serializeVal oprot $ from_AddOperationForChannel_args record
to_AddOperationForChannel_args :: T.ThriftVal -> AddOperationForChannel_args
to_AddOperationForChannel_args (T.TStruct fields) = AddOperationForChannel_args{
  addOperationForChannel_args_opType = P.maybe (addOperationForChannel_args_opType default_AddOperationForChannel_args) (\(_,_val10642) -> (case _val10642 of {T.TI32 _val10643 -> P.toEnum $ P.fromIntegral _val10643; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addOperationForChannel_args_param1 = P.maybe (addOperationForChannel_args_param1 default_AddOperationForChannel_args) (\(_,_val10642) -> (case _val10642 of {T.TString _val10644 -> E.decodeUtf8 _val10644; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addOperationForChannel_args_param2 = P.maybe (addOperationForChannel_args_param2 default_AddOperationForChannel_args) (\(_,_val10642) -> (case _val10642 of {T.TString _val10645 -> E.decodeUtf8 _val10645; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  addOperationForChannel_args_param3 = P.maybe (addOperationForChannel_args_param3 default_AddOperationForChannel_args) (\(_,_val10642) -> (case _val10642 of {T.TString _val10646 -> E.decodeUtf8 _val10646; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_AddOperationForChannel_args _ = P.error "not a struct"
read_AddOperationForChannel_args :: T.Protocol p => p -> P.IO AddOperationForChannel_args
read_AddOperationForChannel_args iprot = to_AddOperationForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args)
decode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_args
decode_AddOperationForChannel_args iprot bs = to_AddOperationForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args) bs
typemap_AddOperationForChannel_args :: T.TypeMap
typemap_AddOperationForChannel_args = Map.fromList [(1,("opType",T.T_I32)),(2,("param1",T.T_STRING)),(3,("param2",T.T_STRING)),(4,("param3",T.T_STRING))]
default_AddOperationForChannel_args :: AddOperationForChannel_args
default_AddOperationForChannel_args = AddOperationForChannel_args{
  addOperationForChannel_args_opType = (P.toEnum 0),
  addOperationForChannel_args_param1 = "",
  addOperationForChannel_args_param2 = "",
  addOperationForChannel_args_param3 = ""}
data AddOperationForChannel_result = AddOperationForChannel_result  { addOperationForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_result_e record  
instance QC.Arbitrary AddOperationForChannel_result where 
  arbitrary = M.liftM AddOperationForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj} then P.Nothing else P.Just $ default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj}
    ]
from_AddOperationForChannel_result :: AddOperationForChannel_result -> T.ThriftVal
from_AddOperationForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10649 -> (1, ("e",from_TalkException _v10649))) <$> addOperationForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10649 -> (1, ("e",from_TalkException _v10649))) <$> addOperationForChannel_result_e record
    ]
    )
write_AddOperationForChannel_result :: T.Protocol p => p -> AddOperationForChannel_result -> P.IO ()
write_AddOperationForChannel_result oprot record = T.writeVal oprot $ from_AddOperationForChannel_result record
encode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> AddOperationForChannel_result -> LBS.ByteString
encode_AddOperationForChannel_result oprot record = T.serializeVal oprot $ from_AddOperationForChannel_result record
to_AddOperationForChannel_result :: T.ThriftVal -> AddOperationForChannel_result
to_AddOperationForChannel_result (T.TStruct fields) = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.maybe (P.Nothing) (\(_,_val10651) -> P.Just (case _val10651 of {T.TStruct _val10652 -> (to_TalkException (T.TStruct _val10652)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddOperationForChannel_result _ = P.error "not a struct"
read_AddOperationForChannel_result :: T.Protocol p => p -> P.IO AddOperationForChannel_result
read_AddOperationForChannel_result iprot = to_AddOperationForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result)
decode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_result
decode_AddOperationForChannel_result iprot bs = to_AddOperationForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result) bs
typemap_AddOperationForChannel_result :: T.TypeMap
typemap_AddOperationForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddOperationForChannel_result :: AddOperationForChannel_result
default_AddOperationForChannel_result = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.Nothing}
data GetSimpleChannelContacts_args = GetSimpleChannelContacts_args  { getSimpleChannelContacts_args_ids :: (Vector.Vector LT.Text)
  , getSimpleChannelContacts_args_statusSticonFallbackDisabled :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_args_ids record   `H.hashWithSalt` getSimpleChannelContacts_args_statusSticonFallbackDisabled record  
instance QC.Arbitrary GetSimpleChannelContacts_args where 
  arbitrary = M.liftM GetSimpleChannelContacts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj}
    , if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_statusSticonFallbackDisabled = getSimpleChannelContacts_args_statusSticonFallbackDisabled obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_statusSticonFallbackDisabled = getSimpleChannelContacts_args_statusSticonFallbackDisabled obj}
    ]
from_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args -> T.ThriftVal
from_GetSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10655 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v10657 -> T.TString $ E.encodeUtf8 _v10657) $ Vector.toList _v10655))) $ getSimpleChannelContacts_args_ids record
  , (\_v10655 -> P.Just (2, ("statusSticonFallbackDisabled",T.TBool _v10655))) $ getSimpleChannelContacts_args_statusSticonFallbackDisabled record
  ]
write_GetSimpleChannelContacts_args :: T.Protocol p => p -> GetSimpleChannelContacts_args -> P.IO ()
write_GetSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_args record
encode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_args -> LBS.ByteString
encode_GetSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_args record
to_GetSimpleChannelContacts_args :: T.ThriftVal -> GetSimpleChannelContacts_args
to_GetSimpleChannelContacts_args (T.TStruct fields) = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = P.maybe (getSimpleChannelContacts_args_ids default_GetSimpleChannelContacts_args) (\(_,_val10659) -> (case _val10659 of {T.TList _ _val10660 -> (Vector.fromList $ P.map (\_v10661 -> (case _v10661 of {T.TString _val10662 -> E.decodeUtf8 _val10662; _ -> P.error "wrong type"})) _val10660); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSimpleChannelContacts_args_statusSticonFallbackDisabled = P.maybe (getSimpleChannelContacts_args_statusSticonFallbackDisabled default_GetSimpleChannelContacts_args) (\(_,_val10659) -> (case _val10659 of {T.TBool _val10663 -> _val10663; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSimpleChannelContacts_args _ = P.error "not a struct"
read_GetSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_args
read_GetSimpleChannelContacts_args iprot = to_GetSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args)
decode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_args
decode_GetSimpleChannelContacts_args iprot bs = to_GetSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args) bs
typemap_GetSimpleChannelContacts_args :: T.TypeMap
typemap_GetSimpleChannelContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING))),(2,("statusSticonFallbackDisabled",T.T_BOOL))]
default_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args
default_GetSimpleChannelContacts_args = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = Vector.empty,
  getSimpleChannelContacts_args_statusSticonFallbackDisabled = P.False}
data GetSimpleChannelContacts_result = GetSimpleChannelContacts_result  { getSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_result_success record   `H.hashWithSalt` getSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetSimpleChannelContacts_result where 
  arbitrary = M.liftM GetSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj}
    , if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj}
    ]
from_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result -> T.ThriftVal
from_GetSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10666 -> (1, ("e",from_TalkException _v10666))) <$> getSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10666 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v10668 -> from_SimpleChannelContact _v10668) $ Vector.toList _v10666))) $ getSimpleChannelContacts_result_success record
    , (\_v10666 -> (1, ("e",from_TalkException _v10666))) <$> getSimpleChannelContacts_result_e record
    ]
    )
write_GetSimpleChannelContacts_result :: T.Protocol p => p -> GetSimpleChannelContacts_result -> P.IO ()
write_GetSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_result record
encode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_result -> LBS.ByteString
encode_GetSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_result record
to_GetSimpleChannelContacts_result :: T.ThriftVal -> GetSimpleChannelContacts_result
to_GetSimpleChannelContacts_result (T.TStruct fields) = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = P.maybe (getSimpleChannelContacts_result_success default_GetSimpleChannelContacts_result) (\(_,_val10670) -> (case _val10670 of {T.TList _ _val10671 -> (Vector.fromList $ P.map (\_v10672 -> (case _v10672 of {T.TStruct _val10673 -> (to_SimpleChannelContact (T.TStruct _val10673)); _ -> P.error "wrong type"})) _val10671); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val10670) -> P.Just (case _val10670 of {T.TStruct _val10674 -> (to_TalkException (T.TStruct _val10674)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_result _ = P.error "not a struct"
read_GetSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_result
read_GetSimpleChannelContacts_result iprot = to_GetSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result)
decode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_result
decode_GetSimpleChannelContacts_result iprot bs = to_GetSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result) bs
typemap_GetSimpleChannelContacts_result :: T.TypeMap
typemap_GetSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result
default_GetSimpleChannelContacts_result = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = Vector.empty,
  getSimpleChannelContacts_result_e = P.Nothing}
data GetUserLastSentMessageTimeStamp_args = GetUserLastSentMessageTimeStamp_args  { getUserLastSentMessageTimeStamp_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLastSentMessageTimeStamp_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLastSentMessageTimeStamp_args_mid record  
instance QC.Arbitrary GetUserLastSentMessageTimeStamp_args where 
  arbitrary = M.liftM GetUserLastSentMessageTimeStamp_args (QC.arbitrary)
  shrink obj | obj == default_GetUserLastSentMessageTimeStamp_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLastSentMessageTimeStamp_args{getUserLastSentMessageTimeStamp_args_mid = getUserLastSentMessageTimeStamp_args_mid obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_args{getUserLastSentMessageTimeStamp_args_mid = getUserLastSentMessageTimeStamp_args_mid obj}
    ]
from_GetUserLastSentMessageTimeStamp_args :: GetUserLastSentMessageTimeStamp_args -> T.ThriftVal
from_GetUserLastSentMessageTimeStamp_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10677 -> P.Just (1, ("mid",T.TString $ E.encodeUtf8 _v10677))) $ getUserLastSentMessageTimeStamp_args_mid record
  ]
write_GetUserLastSentMessageTimeStamp_args :: T.Protocol p => p -> GetUserLastSentMessageTimeStamp_args -> P.IO ()
write_GetUserLastSentMessageTimeStamp_args oprot record = T.writeVal oprot $ from_GetUserLastSentMessageTimeStamp_args record
encode_GetUserLastSentMessageTimeStamp_args :: T.StatelessProtocol p => p -> GetUserLastSentMessageTimeStamp_args -> LBS.ByteString
encode_GetUserLastSentMessageTimeStamp_args oprot record = T.serializeVal oprot $ from_GetUserLastSentMessageTimeStamp_args record
to_GetUserLastSentMessageTimeStamp_args :: T.ThriftVal -> GetUserLastSentMessageTimeStamp_args
to_GetUserLastSentMessageTimeStamp_args (T.TStruct fields) = GetUserLastSentMessageTimeStamp_args{
  getUserLastSentMessageTimeStamp_args_mid = P.maybe (getUserLastSentMessageTimeStamp_args_mid default_GetUserLastSentMessageTimeStamp_args) (\(_,_val10679) -> (case _val10679 of {T.TString _val10680 -> E.decodeUtf8 _val10680; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLastSentMessageTimeStamp_args _ = P.error "not a struct"
read_GetUserLastSentMessageTimeStamp_args :: T.Protocol p => p -> P.IO GetUserLastSentMessageTimeStamp_args
read_GetUserLastSentMessageTimeStamp_args iprot = to_GetUserLastSentMessageTimeStamp_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_args)
decode_GetUserLastSentMessageTimeStamp_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLastSentMessageTimeStamp_args
decode_GetUserLastSentMessageTimeStamp_args iprot bs = to_GetUserLastSentMessageTimeStamp_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_args) bs
typemap_GetUserLastSentMessageTimeStamp_args :: T.TypeMap
typemap_GetUserLastSentMessageTimeStamp_args = Map.fromList [(1,("mid",T.T_STRING))]
default_GetUserLastSentMessageTimeStamp_args :: GetUserLastSentMessageTimeStamp_args
default_GetUserLastSentMessageTimeStamp_args = GetUserLastSentMessageTimeStamp_args{
  getUserLastSentMessageTimeStamp_args_mid = ""}
data GetUserLastSentMessageTimeStamp_result = GetUserLastSentMessageTimeStamp_result  { getUserLastSentMessageTimeStamp_result_success :: I.Int64
  , getUserLastSentMessageTimeStamp_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLastSentMessageTimeStamp_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLastSentMessageTimeStamp_result_success record   `H.hashWithSalt` getUserLastSentMessageTimeStamp_result_e record  
instance QC.Arbitrary GetUserLastSentMessageTimeStamp_result where 
  arbitrary = M.liftM GetUserLastSentMessageTimeStamp_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLastSentMessageTimeStamp_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = getUserLastSentMessageTimeStamp_result_success obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = getUserLastSentMessageTimeStamp_result_success obj}
    , if obj == default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = getUserLastSentMessageTimeStamp_result_e obj} then P.Nothing else P.Just $ default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = getUserLastSentMessageTimeStamp_result_e obj}
    ]
from_GetUserLastSentMessageTimeStamp_result :: GetUserLastSentMessageTimeStamp_result -> T.ThriftVal
from_GetUserLastSentMessageTimeStamp_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v10683 -> (1, ("e",from_TalkException _v10683))) <$> getUserLastSentMessageTimeStamp_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v10683 -> P.Just (0, ("success",T.TI64 _v10683))) $ getUserLastSentMessageTimeStamp_result_success record
    , (\_v10683 -> (1, ("e",from_TalkException _v10683))) <$> getUserLastSentMessageTimeStamp_result_e record
    ]
    )
write_GetUserLastSentMessageTimeStamp_result :: T.Protocol p => p -> GetUserLastSentMessageTimeStamp_result -> P.IO ()
write_GetUserLastSentMessageTimeStamp_result oprot record = T.writeVal oprot $ from_GetUserLastSentMessageTimeStamp_result record
encode_GetUserLastSentMessageTimeStamp_result :: T.StatelessProtocol p => p -> GetUserLastSentMessageTimeStamp_result -> LBS.ByteString
encode_GetUserLastSentMessageTimeStamp_result oprot record = T.serializeVal oprot $ from_GetUserLastSentMessageTimeStamp_result record
to_GetUserLastSentMessageTimeStamp_result :: T.ThriftVal -> GetUserLastSentMessageTimeStamp_result
to_GetUserLastSentMessageTimeStamp_result (T.TStruct fields) = GetUserLastSentMessageTimeStamp_result{
  getUserLastSentMessageTimeStamp_result_success = P.maybe (getUserLastSentMessageTimeStamp_result_success default_GetUserLastSentMessageTimeStamp_result) (\(_,_val10685) -> (case _val10685 of {T.TI64 _val10686 -> _val10686; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLastSentMessageTimeStamp_result_e = P.maybe (P.Nothing) (\(_,_val10685) -> P.Just (case _val10685 of {T.TStruct _val10687 -> (to_TalkException (T.TStruct _val10687)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLastSentMessageTimeStamp_result _ = P.error "not a struct"
read_GetUserLastSentMessageTimeStamp_result :: T.Protocol p => p -> P.IO GetUserLastSentMessageTimeStamp_result
read_GetUserLastSentMessageTimeStamp_result iprot = to_GetUserLastSentMessageTimeStamp_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_result)
decode_GetUserLastSentMessageTimeStamp_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLastSentMessageTimeStamp_result
decode_GetUserLastSentMessageTimeStamp_result iprot bs = to_GetUserLastSentMessageTimeStamp_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLastSentMessageTimeStamp_result) bs
typemap_GetUserLastSentMessageTimeStamp_result :: T.TypeMap
typemap_GetUserLastSentMessageTimeStamp_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLastSentMessageTimeStamp_result :: GetUserLastSentMessageTimeStamp_result
default_GetUserLastSentMessageTimeStamp_result = GetUserLastSentMessageTimeStamp_result{
  getUserLastSentMessageTimeStamp_result_success = 0,
  getUserLastSentMessageTimeStamp_result_e = P.Nothing}
process_getUserStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetUserStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserStatus handler (getUserStatus_args_mid args)
        let res = default_GetUserStatus_result{getUserStatus_result_success = val}
        T.writeMessage oprot ("getUserStatus", T.M_REPLY, seqid) $
          write_GetUserStatus_result oprot res)
      (\e  -> do
        let res = default_GetUserStatus_result{getUserStatus_result_e = P.Just e}
        T.writeMessage oprot ("getUserStatus", T.M_REPLY, seqid) $
          write_GetUserStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttributeForChannel (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttributeForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttributeForChannel handler (updateProfileAttributeForChannel_args_profileAttribute args) (updateProfileAttributeForChannel_args_value args)
        let res = default_UpdateProfileAttributeForChannel_result
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateExtendedProfileAttribute (seqid, iprot, oprot, handler) = do
  args <- read_UpdateExtendedProfileAttribute_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateExtendedProfileAttribute handler (updateExtendedProfileAttribute_args_attr args) (updateExtendedProfileAttribute_args_extendedProfile args)
        let res = default_UpdateExtendedProfileAttribute_result
        T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateExtendedProfileAttribute_result oprot res)
      (\e  -> do
        let res = default_UpdateExtendedProfileAttribute_result{updateExtendedProfileAttribute_result_e = P.Just e}
        T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_REPLY, seqid) $
          write_UpdateExtendedProfileAttribute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateExtendedProfileAttribute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetAllSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllSimpleChannelContacts handler (getAllSimpleChannelContacts_args_statusSticonFallbackDisabled args)
        let res = default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetAllSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetAllSimpleChannelContacts_result{getAllSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetAllSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserIdentities (seqid, iprot, oprot, handler) = do
  args <- read_GetUserIdentities_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserIdentities handler
        let res = default_GetUserIdentities_result{getUserIdentities_result_success = val}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res)
      (\e  -> do
        let res = default_GetUserIdentities_result{getUserIdentities_result_e = P.Just e}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserIdentities", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_markPaidCallAd (seqid, iprot, oprot, handler) = do
  args <- read_MarkPaidCallAd_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.markPaidCallAd handler (markPaidCallAd_args_dialedNumber args) (markPaidCallAd_args_language args) (markPaidCallAd_args_disableCallerId args)
        let res = default_MarkPaidCallAd_result{markPaidCallAd_result_success = val}
        T.writeMessage oprot ("markPaidCallAd", T.M_REPLY, seqid) $
          write_MarkPaidCallAd_result oprot res)
      (\e  -> do
        let res = default_MarkPaidCallAd_result{markPaidCallAd_result_e = P.Just e}
        T.writeMessage oprot ("markPaidCallAd", T.M_REPLY, seqid) $
          write_MarkPaidCallAd_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("markPaidCallAd", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isGroupMember (seqid, iprot, oprot, handler) = do
  args <- read_IsGroupMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isGroupMember handler (isGroupMember_args_groupId args)
        let res = default_IsGroupMember_result{isGroupMember_result_success = val}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res)
      (\e  -> do
        let res = default_IsGroupMember_result{isGroupMember_result_e = P.Just e}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isGroupMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPhoneInfoFromPhoneNumber (seqid, iprot, oprot, handler) = do
  args <- read_GetPhoneInfoFromPhoneNumber_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPhoneInfoFromPhoneNumber handler (getPhoneInfoFromPhoneNumber_args_region args) (getPhoneInfoFromPhoneNumber_args_phoneNumber args)
        let res = default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_success = val}
        T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_REPLY, seqid) $
          write_GetPhoneInfoFromPhoneNumber_result oprot res)
      (\e  -> do
        let res = default_GetPhoneInfoFromPhoneNumber_result{getPhoneInfoFromPhoneNumber_result_e = P.Just e}
        T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_REPLY, seqid) $
          write_GetPhoneInfoFromPhoneNumber_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPhoneInfoFromPhoneNumber", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_redeemPaidCallVoucher (seqid, iprot, oprot, handler) = do
  args <- read_RedeemPaidCallVoucher_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.redeemPaidCallVoucher handler (redeemPaidCallVoucher_args_serial args) (redeemPaidCallVoucher_args_language args)
        let res = default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_success = val}
        T.writeMessage oprot ("redeemPaidCallVoucher", T.M_REPLY, seqid) $
          write_RedeemPaidCallVoucher_result oprot res)
      (\e  -> do
        let res = default_RedeemPaidCallVoucher_result{redeemPaidCallVoucher_result_e = P.Just e}
        T.writeMessage oprot ("redeemPaidCallVoucher", T.M_REPLY, seqid) $
          write_RedeemPaidCallVoucher_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("redeemPaidCallVoucher", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPreferredDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetPreferredDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPreferredDisplayName handler (getPreferredDisplayName_args_mids args)
        let res = default_GetPreferredDisplayName_result{getPreferredDisplayName_result_success = val}
        T.writeMessage oprot ("getPreferredDisplayName", T.M_REPLY, seqid) $
          write_GetPreferredDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetPreferredDisplayName_result{getPreferredDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getPreferredDisplayName", T.M_REPLY, seqid) $
          write_GetPreferredDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPreferredDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContactsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetContactsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContactsForChannel handler (getContactsForChannel_args_ids args)
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_success = val}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContactsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCallCreditProducts (seqid, iprot, oprot, handler) = do
  args <- read_GetCallCreditProducts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCallCreditProducts handler (getCallCreditProducts_args_appStoreCode args) (getCallCreditProducts_args_pgCode args) (getCallCreditProducts_args_country args) (getCallCreditProducts_args_language args)
        let res = default_GetCallCreditProducts_result{getCallCreditProducts_result_success = val}
        T.writeMessage oprot ("getCallCreditProducts", T.M_REPLY, seqid) $
          write_GetCallCreditProducts_result oprot res)
      (\e  -> do
        let res = default_GetCallCreditProducts_result{getCallCreditProducts_result_e = P.Just e}
        T.writeMessage oprot ("getCallCreditProducts", T.M_REPLY, seqid) $
          write_GetCallCreditProducts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCallCreditProducts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContacts handler (getCompactContacts_args_lastModifiedTimestamp args)
        let res = default_GetCompactContacts_result{getCompactContacts_result_success = val}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetCompactContacts_result{getCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_notifyNotiCenterEvent (seqid, iprot, oprot, handler) = do
  args <- read_NotifyNotiCenterEvent_args iprot
  (X.catch
    (X.catch
      (do
        Iface.notifyNotiCenterEvent handler (notifyNotiCenterEvent_args_event args)
        let res = default_NotifyNotiCenterEvent_result
        T.writeMessage oprot ("notifyNotiCenterEvent", T.M_REPLY, seqid) $
          write_NotifyNotiCenterEvent_result oprot res)
      (\e  -> do
        let res = default_NotifyNotiCenterEvent_result{notifyNotiCenterEvent_result_e = P.Just e}
        T.writeMessage oprot ("notifyNotiCenterEvent", T.M_REPLY, seqid) $
          write_NotifyNotiCenterEvent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("notifyNotiCenterEvent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isInContact (seqid, iprot, oprot, handler) = do
  args <- read_IsInContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isInContact handler (isInContact_args_mid args)
        let res = default_IsInContact_result{isInContact_result_success = val}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res)
      (\e  -> do
        let res = default_IsInContact_result{isInContact_result_e = P.Just e}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isInContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupGroupMembers (seqid, iprot, oprot, handler) = do
  args <- read_LookupGroupMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupGroupMembers handler (lookupGroupMembers_args_groupId args) (lookupGroupMembers_args_mids args)
        let res = default_LookupGroupMembers_result{lookupGroupMembers_result_success = val}
        T.writeMessage oprot ("lookupGroupMembers", T.M_REPLY, seqid) $
          write_LookupGroupMembers_result oprot res)
      (\e  -> do
        let res = default_LookupGroupMembers_result{lookupGroupMembers_result_e = P.Just e}
        T.writeMessage oprot ("lookupGroupMembers", T.M_REPLY, seqid) $
          write_LookupGroupMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupGroupMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoomInformation (seqid, iprot, oprot, handler) = do
  args <- read_GetRoomInformation_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoomInformation handler (getRoomInformation_args_roomMid args)
        let res = default_GetRoomInformation_result{getRoomInformation_result_success = val}
        T.writeMessage oprot ("getRoomInformation", T.M_REPLY, seqid) $
          write_GetRoomInformation_result oprot res)
      (\e  -> do
        let res = default_GetRoomInformation_result{getRoomInformation_result_e = P.Just e}
        T.writeMessage oprot ("getRoomInformation", T.M_REPLY, seqid) $
          write_GetRoomInformation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoomInformation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupCall (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupCall_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupCall handler (getGroupCall_args_chatMid args)
        let res = default_GetGroupCall_result{getGroupCall_result_success = val}
        T.writeMessage oprot ("getGroupCall", T.M_REPLY, seqid) $
          write_GetGroupCall_result oprot res)
      (\e  -> do
        let res = default_GetGroupCall_result{getGroupCall_result_e = P.Just e}
        T.writeMessage oprot ("getGroupCall", T.M_REPLY, seqid) $
          write_GetGroupCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isAllowSecondaryDeviceLogin (seqid, iprot, oprot, handler) = do
  args <- read_IsAllowSecondaryDeviceLogin_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isAllowSecondaryDeviceLogin handler
        let res = default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_success = val}
        T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_REPLY, seqid) $
          write_IsAllowSecondaryDeviceLogin_result oprot res)
      (\e  -> do
        let res = default_IsAllowSecondaryDeviceLogin_result{isAllowSecondaryDeviceLogin_result_e = P.Just e}
        T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_REPLY, seqid) $
          write_IsAllowSecondaryDeviceLogin_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isAllowSecondaryDeviceLogin", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientForChannel handler
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createRoomWithBuddy (seqid, iprot, oprot, handler) = do
  args <- read_CreateRoomWithBuddy_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.createRoomWithBuddy handler (createRoomWithBuddy_args_reqSeq args) (createRoomWithBuddy_args_buddyMid args) (createRoomWithBuddy_args_contactIds args)
        let res = default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_success = val}
        T.writeMessage oprot ("createRoomWithBuddy", T.M_REPLY, seqid) $
          write_CreateRoomWithBuddy_result oprot res)
      (\e  -> do
        let res = default_CreateRoomWithBuddy_result{createRoomWithBuddy_result_e = P.Just e}
        T.writeMessage oprot ("createRoomWithBuddy", T.M_REPLY, seqid) $
          write_CreateRoomWithBuddy_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createRoomWithBuddy", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDisplayName handler (getDisplayName_args_mid args)
        let res = default_GetDisplayName_result{getDisplayName_result_success = val}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetDisplayName_result{getDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallMetadata (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallMetadata_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallMetadata handler (getPaidCallMetadata_args_language args)
        let res = default_GetPaidCallMetadata_result{getPaidCallMetadata_result_success = val}
        T.writeMessage oprot ("getPaidCallMetadata", T.M_REPLY, seqid) $
          write_GetPaidCallMetadata_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallMetadata_result{getPaidCallMetadata_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallMetadata", T.M_REPLY, seqid) $
          write_GetPaidCallMetadata_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallMetadata", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMid (seqid, iprot, oprot, handler) = do
  args <- read_GetMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMid handler
        let res = default_GetMid_result{getMid_result_success = val}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res)
      (\e  -> do
        let res = default_GetMid_result{getMid_result_e = P.Just e}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCountryForBilling (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCountryForBilling_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCountryForBilling handler (getUserCountryForBilling_args_country args) (getUserCountryForBilling_args_remoteIp args)
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = val}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res)
      (\e  -> do
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = P.Just e}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCountryForBilling", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteGroupIdsForChannel handler
        let res = default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteGroupIdsForChannel_result{getFavoriteGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallHistory handler (getPaidCallHistory_args_start args) (getPaidCallHistory_args_size args) (getPaidCallHistory_args_language args)
        let res = default_GetPaidCallHistory_result{getPaidCallHistory_result_success = val}
        T.writeMessage oprot ("getPaidCallHistory", T.M_REPLY, seqid) $
          write_GetPaidCallHistory_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallHistory_result{getPaidCallHistory_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallHistory", T.M_REPLY, seqid) $
          write_GetPaidCallHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendPinCodeOperation (seqid, iprot, oprot, handler) = do
  args <- read_SendPinCodeOperation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendPinCodeOperation handler (sendPinCodeOperation_args_verifier args)
        let res = default_SendPinCodeOperation_result
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res)
      (\e  -> do
        let res = default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = P.Just e}
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendPinCodeOperation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteIntoGroupCall (seqid, iprot, oprot, handler) = do
  args <- read_InviteIntoGroupCall_args iprot
  (X.catch
    (X.catch
      (do
        Iface.inviteIntoGroupCall handler (inviteIntoGroupCall_args_chatMid args) (inviteIntoGroupCall_args_memberMids args) (inviteIntoGroupCall_args_mediaType args)
        let res = default_InviteIntoGroupCall_result
        T.writeMessage oprot ("inviteIntoGroupCall", T.M_REPLY, seqid) $
          write_InviteIntoGroupCall_result oprot res)
      (\e  -> do
        let res = default_InviteIntoGroupCall_result{inviteIntoGroupCall_result_e = P.Just e}
        T.writeMessage oprot ("inviteIntoGroupCall", T.M_REPLY, seqid) $
          write_InviteIntoGroupCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteIntoGroupCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendMids handler
        let res = default_GetFriendMids_result{getFriendMids_result_success = val}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetFriendMids_result{getFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMetaProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetMetaProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMetaProfile handler
        let res = default_GetMetaProfile_result{getMetaProfile_result_success = val}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res)
      (\e  -> do
        let res = default_GetMetaProfile_result{getMetaProfile_result_e = P.Just e}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMetaProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageForChannel (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageForChannel handler (sendMessageForChannel_args_message args)
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_success = val}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res)
      (\e  -> do
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_activeBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_ActiveBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.activeBuddySubscriberCount handler
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("activeBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCallCreditPurchaseHistory (seqid, iprot, oprot, handler) = do
  args <- read_GetCallCreditPurchaseHistory_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCallCreditPurchaseHistory handler (getCallCreditPurchaseHistory_args_request args)
        let res = default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_success = val}
        T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCallCreditPurchaseHistory_result oprot res)
      (\e  -> do
        let res = default_GetCallCreditPurchaseHistory_result{getCallCreditPurchaseHistory_result_e = P.Just e}
        T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_REPLY, seqid) $
          write_GetCallCreditPurchaseHistory_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCallCreditPurchaseHistory", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isRoomMember (seqid, iprot, oprot, handler) = do
  args <- read_IsRoomMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isRoomMember handler (isRoomMember_args_roomId args)
        let res = default_IsRoomMember_result{isRoomMember_result_success = val}
        T.writeMessage oprot ("isRoomMember", T.M_REPLY, seqid) $
          write_IsRoomMember_result oprot res)
      (\e  -> do
        let res = default_IsRoomMember_result{isRoomMember_result_e = P.Just e}
        T.writeMessage oprot ("isRoomMember", T.M_REPLY, seqid) $
          write_IsRoomMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isRoomMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendSystemOAMessage (seqid, iprot, oprot, handler) = do
  args <- read_SendSystemOAMessage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendSystemOAMessage handler (sendSystemOAMessage_args_message args)
        let res = default_SendSystemOAMessage_result{sendSystemOAMessage_result_success = val}
        T.writeMessage oprot ("sendSystemOAMessage", T.M_REPLY, seqid) $
          write_SendSystemOAMessage_result oprot res)
      (\e  -> do
        let res = default_SendSystemOAMessage_result{sendSystemOAMessage_result_e = P.Just e}
        T.writeMessage oprot ("sendSystemOAMessage", T.M_REPLY, seqid) $
          write_SendSystemOAMessage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendSystemOAMessage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquirePaidCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquirePaidCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquirePaidCallRoute handler (acquirePaidCallRoute_args_paidCallType args) (acquirePaidCallRoute_args_dialedNumber args) (acquirePaidCallRoute_args_language args) (acquirePaidCallRoute_args_networkCode args) (acquirePaidCallRoute_args_disableCallerId args) (acquirePaidCallRoute_args_referer args) (acquirePaidCallRoute_args_adSessionId args)
        let res = default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_success = val}
        T.writeMessage oprot ("acquirePaidCallRoute", T.M_REPLY, seqid) $
          write_AcquirePaidCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquirePaidCallRoute_result{acquirePaidCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquirePaidCallRoute", T.M_REPLY, seqid) $
          write_AcquirePaidCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquirePaidCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupsForChannel handler (getGroupsForChannel_args_groupIds args)
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_success = val}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCreateTime (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCreateTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCreateTime handler
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_success = val}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res)
      (\e  -> do
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_e = P.Just e}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCreateTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerChannelCP (seqid, iprot, oprot, handler) = do
  args <- read_RegisterChannelCP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerChannelCP handler (registerChannelCP_args_cpId args) (registerChannelCP_args_registerPassword args)
        let res = default_RegisterChannelCP_result{registerChannelCP_result_success = val}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res)
      (\e  -> do
        let res = default_RegisterChannelCP_result{registerChannelCP_result_e = P.Just e}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerChannelCP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_reserveCallCreditPurchase (seqid, iprot, oprot, handler) = do
  args <- read_ReserveCallCreditPurchase_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.reserveCallCreditPurchase handler (reserveCallCreditPurchase_args_request args)
        let res = default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_success = val}
        T.writeMessage oprot ("reserveCallCreditPurchase", T.M_REPLY, seqid) $
          write_ReserveCallCreditPurchase_result oprot res)
      (\e  -> do
        let res = default_ReserveCallCreditPurchase_result{reserveCallCreditPurchase_result_e = P.Just e}
        T.writeMessage oprot ("reserveCallCreditPurchase", T.M_REPLY, seqid) $
          write_ReserveCallCreditPurchase_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("reserveCallCreditPurchase", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquirePaidCallCurrencyExchangeRate (seqid, iprot, oprot, handler) = do
  args <- read_AcquirePaidCallCurrencyExchangeRate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquirePaidCallCurrencyExchangeRate handler (acquirePaidCallCurrencyExchangeRate_args_language args)
        let res = default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_success = val}
        T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_REPLY, seqid) $
          write_AcquirePaidCallCurrencyExchangeRate_result oprot res)
      (\e  -> do
        let res = default_AcquirePaidCallCurrencyExchangeRate_result{acquirePaidCallCurrencyExchangeRate_result_e = P.Just e}
        T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_REPLY, seqid) $
          write_AcquirePaidCallCurrencyExchangeRate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquirePaidCallCurrencyExchangeRate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getRoomMemberMidsForAppPlatform (seqid, iprot, oprot, handler) = do
  args <- read_GetRoomMemberMidsForAppPlatform_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getRoomMemberMidsForAppPlatform handler (getRoomMemberMidsForAppPlatform_args_roomId args)
        let res = default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_success = val}
        T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetRoomMemberMidsForAppPlatform_result oprot res)
      (\e  -> do
        let res = default_GetRoomMemberMidsForAppPlatform_result{getRoomMemberMidsForAppPlatform_result_e = P.Just e}
        T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetRoomMemberMidsForAppPlatform_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getRoomMemberMidsForAppPlatform", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallBalanceList (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallBalanceList_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallBalanceList handler (getPaidCallBalanceList_args_language args)
        let res = default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_success = val}
        T.writeMessage oprot ("getPaidCallBalanceList", T.M_REPLY, seqid) $
          write_GetPaidCallBalanceList_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallBalanceList_result{getPaidCallBalanceList_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallBalanceList", T.M_REPLY, seqid) $
          write_GetPaidCallBalanceList_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallBalanceList", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPersonalInfos (seqid, iprot, oprot, handler) = do
  args <- read_GetPersonalInfos_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPersonalInfos handler (getPersonalInfos_args_requiredPersonalInfos args)
        let res = default_GetPersonalInfos_result{getPersonalInfos_result_success = val}
        T.writeMessage oprot ("getPersonalInfos", T.M_REPLY, seqid) $
          write_GetPersonalInfos_result oprot res)
      (\e  -> do
        let res = default_GetPersonalInfos_result{getPersonalInfos_result_e = P.Just e}
        T.writeMessage oprot ("getPersonalInfos", T.M_REPLY, seqid) $
          write_GetPersonalInfos_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPersonalInfos", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientsForChannel handler (getPrimaryClientsForChannel_args_userMids args)
        let res = default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientsForChannel_result{getPrimaryClientsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addBuddyToContact (seqid, iprot, oprot, handler) = do
  args <- read_AddBuddyToContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.addBuddyToContact handler (addBuddyToContact_args_buddyMid args)
        let res = default_AddBuddyToContact_result{addBuddyToContact_result_success = val}
        T.writeMessage oprot ("addBuddyToContact", T.M_REPLY, seqid) $
          write_AddBuddyToContact_result oprot res)
      (\e  -> do
        let res = default_AddBuddyToContact_result{addBuddyToContact_result_e = P.Just e}
        T.writeMessage oprot ("addBuddyToContact", T.M_REPLY, seqid) $
          write_AddBuddyToContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addBuddyToContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMidsForAppPlatform (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMidsForAppPlatform_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMidsForAppPlatform handler (getGroupMemberMidsForAppPlatform_args_groupId args)
        let res = default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_success = val}
        T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetGroupMemberMidsForAppPlatform_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMidsForAppPlatform_result{getGroupMemberMidsForAppPlatform_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_REPLY, seqid) $
          write_GetGroupMemberMidsForAppPlatform_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMidsForAppPlatform", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLanguage (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLanguage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLanguage handler
        let res = default_GetUserLanguage_result{getUserLanguage_result_success = val}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res)
      (\e  -> do
        let res = default_GetUserLanguage_result{getUserLanguage_result_e = P.Just e}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLanguage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupPaidCall (seqid, iprot, oprot, handler) = do
  args <- read_LookupPaidCall_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupPaidCall handler (lookupPaidCall_args_dialedNumber args) (lookupPaidCall_args_language args) (lookupPaidCall_args_referer args)
        let res = default_LookupPaidCall_result{lookupPaidCall_result_success = val}
        T.writeMessage oprot ("lookupPaidCall", T.M_REPLY, seqid) $
          write_LookupPaidCall_result oprot res)
      (\e  -> do
        let res = default_LookupPaidCall_result{lookupPaidCall_result_e = P.Just e}
        T.writeMessage oprot ("lookupPaidCall", T.M_REPLY, seqid) $
          write_LookupPaidCall_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupPaidCall", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getExtendedProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetExtendedProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getExtendedProfile handler
        let res = default_GetExtendedProfile_result{getExtendedProfile_result_success = val}
        T.writeMessage oprot ("getExtendedProfile", T.M_REPLY, seqid) $
          write_GetExtendedProfile_result oprot res)
      (\e  -> do
        let res = default_GetExtendedProfile_result{getExtendedProfile_result_e = P.Just e}
        T.writeMessage oprot ("getExtendedProfile", T.M_REPLY, seqid) $
          write_GetExtendedProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getExtendedProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getReverseCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetReverseCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getReverseCompactContacts handler (getReverseCompactContacts_args_ids args)
        let res = default_GetReverseCompactContacts_result{getReverseCompactContacts_result_success = val}
        T.writeMessage oprot ("getReverseCompactContacts", T.M_REPLY, seqid) $
          write_GetReverseCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetReverseCompactContacts_result{getReverseCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getReverseCompactContacts", T.M_REPLY, seqid) $
          write_GetReverseCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getReverseCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPaidCallAdStatus (seqid, iprot, oprot, handler) = do
  args <- read_GetPaidCallAdStatus_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPaidCallAdStatus handler
        let res = default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_success = val}
        T.writeMessage oprot ("getPaidCallAdStatus", T.M_REPLY, seqid) $
          write_GetPaidCallAdStatus_result oprot res)
      (\e  -> do
        let res = default_GetPaidCallAdStatus_result{getPaidCallAdStatus_result_e = P.Just e}
        T.writeMessage oprot ("getPaidCallAdStatus", T.M_REPLY, seqid) $
          write_GetPaidCallAdStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPaidCallAdStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUseridWithoutAbuseBlockForChannel (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUseridWithoutAbuseBlockForChannel handler (findContactByUseridWithoutAbuseBlockForChannel_args_userid args)
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = val}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res)
      (\e  -> do
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMids (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMids handler (getGroupMemberMids_args_groupId args)
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_success = val}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageWithoutRelationship (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageWithoutRelationship_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageWithoutRelationship handler (sendMessageWithoutRelationship_args_message args)
        let res = default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_success = val}
        T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_REPLY, seqid) $
          write_SendMessageWithoutRelationship_result oprot res)
      (\e  -> do
        let res = default_SendMessageWithoutRelationship_result{sendMessageWithoutRelationship_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_REPLY, seqid) $
          write_SendMessageWithoutRelationship_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageWithoutRelationship", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCountInBulk (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCountInBulk_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCountInBulk handler (displayBuddySubscriberCountInBulk_args_mids args)
        let res = default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCountInBulk_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCountInBulk_result{displayBuddySubscriberCountInBulk_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCountInBulk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCountInBulk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_lookupRoomMembers (seqid, iprot, oprot, handler) = do
  args <- read_LookupRoomMembers_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.lookupRoomMembers handler (lookupRoomMembers_args_roomId args) (lookupRoomMembers_args_mids args)
        let res = default_LookupRoomMembers_result{lookupRoomMembers_result_success = val}
        T.writeMessage oprot ("lookupRoomMembers", T.M_REPLY, seqid) $
          write_LookupRoomMembers_result oprot res)
      (\e  -> do
        let res = default_LookupRoomMembers_result{lookupRoomMembers_result_e = P.Just e}
        T.writeMessage oprot ("lookupRoomMembers", T.M_REPLY, seqid) $
          write_LookupRoomMembers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("lookupRoomMembers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMidsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMidsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMidsForChannel handler
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIdsForChannel handler
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = val}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCount handler
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfileForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetProfileForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfileForChannel handler
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_success = val}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res)
      (\e  -> do
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfileForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserTickets (seqid, iprot, oprot, handler) = do
  args <- read_GetUserTickets_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserTickets handler (getUserTickets_args_userMids args)
        let res = default_GetUserTickets_result{getUserTickets_result_success = val}
        T.writeMessage oprot ("getUserTickets", T.M_REPLY, seqid) $
          write_GetUserTickets_result oprot res)
      (\e  -> do
        let res = default_GetUserTickets_result{getUserTickets_result_e = P.Just e}
        T.writeMessage oprot ("getUserTickets", T.M_REPLY, seqid) $
          write_GetUserTickets_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserTickets", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getOAFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetOAFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getOAFriendMids handler
        let res = default_GetOAFriendMids_result{getOAFriendMids_result_success = val}
        T.writeMessage oprot ("getOAFriendMids", T.M_REPLY, seqid) $
          write_GetOAFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetOAFriendMids_result{getOAFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getOAFriendMids", T.M_REPLY, seqid) $
          write_GetOAFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getOAFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_searchPaidCallUserRate (seqid, iprot, oprot, handler) = do
  args <- read_SearchPaidCallUserRate_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.searchPaidCallUserRate handler (searchPaidCallUserRate_args_countryCode args) (searchPaidCallUserRate_args_language args)
        let res = default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_success = val}
        T.writeMessage oprot ("searchPaidCallUserRate", T.M_REPLY, seqid) $
          write_SearchPaidCallUserRate_result oprot res)
      (\e  -> do
        let res = default_SearchPaidCallUserRate_result{searchPaidCallUserRate_result_e = P.Just e}
        T.writeMessage oprot ("searchPaidCallUserRate", T.M_REPLY, seqid) $
          write_SearchPaidCallUserRate_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("searchPaidCallUserRate", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedGroupIdsForChannel handler
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_acquireGroupCallRoute (seqid, iprot, oprot, handler) = do
  args <- read_AcquireGroupCallRoute_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.acquireGroupCallRoute handler (acquireGroupCallRoute_args_chatMid args) (acquireGroupCallRoute_args_mediaType args)
        let res = default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_success = val}
        T.writeMessage oprot ("acquireGroupCallRoute", T.M_REPLY, seqid) $
          write_AcquireGroupCallRoute_result oprot res)
      (\e  -> do
        let res = default_AcquireGroupCallRoute_result{acquireGroupCallRoute_result_e = P.Just e}
        T.writeMessage oprot ("acquireGroupCallRoute", T.M_REPLY, seqid) $
          write_AcquireGroupCallRoute_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("acquireGroupCallRoute", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserMidsWhoAddedMe (seqid, iprot, oprot, handler) = do
  args <- read_GetUserMidsWhoAddedMe_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserMidsWhoAddedMe handler
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = val}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res)
      (\e  -> do
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = P.Just e}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityCredential handler
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_success = val}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addOperationForChannel (seqid, iprot, oprot, handler) = do
  args <- read_AddOperationForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.addOperationForChannel handler (addOperationForChannel_args_opType args) (addOperationForChannel_args_param1 args) (addOperationForChannel_args_param2 args) (addOperationForChannel_args_param3 args)
        let res = default_AddOperationForChannel_result
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res)
      (\e  -> do
        let res = default_AddOperationForChannel_result{addOperationForChannel_result_e = P.Just e}
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addOperationForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSimpleChannelContacts handler (getSimpleChannelContacts_args_ids args) (getSimpleChannelContacts_args_statusSticonFallbackDisabled args)
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLastSentMessageTimeStamp (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLastSentMessageTimeStamp_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLastSentMessageTimeStamp handler (getUserLastSentMessageTimeStamp_args_mid args)
        let res = default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_success = val}
        T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_REPLY, seqid) $
          write_GetUserLastSentMessageTimeStamp_result oprot res)
      (\e  -> do
        let res = default_GetUserLastSentMessageTimeStamp_result{getUserLastSentMessageTimeStamp_result_e = P.Just e}
        T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_REPLY, seqid) $
          write_GetUserLastSentMessageTimeStamp_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLastSentMessageTimeStamp", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getUserStatus" -> process_getUserStatus (seqid,iprot,oprot,handler)
  "updateProfileAttributeForChannel" -> process_updateProfileAttributeForChannel (seqid,iprot,oprot,handler)
  "updateExtendedProfileAttribute" -> process_updateExtendedProfileAttribute (seqid,iprot,oprot,handler)
  "getAllSimpleChannelContacts" -> process_getAllSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserIdentities" -> process_getUserIdentities (seqid,iprot,oprot,handler)
  "markPaidCallAd" -> process_markPaidCallAd (seqid,iprot,oprot,handler)
  "isGroupMember" -> process_isGroupMember (seqid,iprot,oprot,handler)
  "getPhoneInfoFromPhoneNumber" -> process_getPhoneInfoFromPhoneNumber (seqid,iprot,oprot,handler)
  "redeemPaidCallVoucher" -> process_redeemPaidCallVoucher (seqid,iprot,oprot,handler)
  "getPreferredDisplayName" -> process_getPreferredDisplayName (seqid,iprot,oprot,handler)
  "getContactsForChannel" -> process_getContactsForChannel (seqid,iprot,oprot,handler)
  "getCallCreditProducts" -> process_getCallCreditProducts (seqid,iprot,oprot,handler)
  "getCompactContacts" -> process_getCompactContacts (seqid,iprot,oprot,handler)
  "notifyNotiCenterEvent" -> process_notifyNotiCenterEvent (seqid,iprot,oprot,handler)
  "isInContact" -> process_isInContact (seqid,iprot,oprot,handler)
  "lookupGroupMembers" -> process_lookupGroupMembers (seqid,iprot,oprot,handler)
  "getRoomInformation" -> process_getRoomInformation (seqid,iprot,oprot,handler)
  "getGroupCall" -> process_getGroupCall (seqid,iprot,oprot,handler)
  "isAllowSecondaryDeviceLogin" -> process_isAllowSecondaryDeviceLogin (seqid,iprot,oprot,handler)
  "getPrimaryClientForChannel" -> process_getPrimaryClientForChannel (seqid,iprot,oprot,handler)
  "createRoomWithBuddy" -> process_createRoomWithBuddy (seqid,iprot,oprot,handler)
  "getDisplayName" -> process_getDisplayName (seqid,iprot,oprot,handler)
  "getPaidCallMetadata" -> process_getPaidCallMetadata (seqid,iprot,oprot,handler)
  "getMid" -> process_getMid (seqid,iprot,oprot,handler)
  "getUserCountryForBilling" -> process_getUserCountryForBilling (seqid,iprot,oprot,handler)
  "getFavoriteGroupIdsForChannel" -> process_getFavoriteGroupIdsForChannel (seqid,iprot,oprot,handler)
  "getPaidCallHistory" -> process_getPaidCallHistory (seqid,iprot,oprot,handler)
  "sendPinCodeOperation" -> process_sendPinCodeOperation (seqid,iprot,oprot,handler)
  "inviteIntoGroupCall" -> process_inviteIntoGroupCall (seqid,iprot,oprot,handler)
  "getFriendMids" -> process_getFriendMids (seqid,iprot,oprot,handler)
  "getMetaProfile" -> process_getMetaProfile (seqid,iprot,oprot,handler)
  "sendMessageForChannel" -> process_sendMessageForChannel (seqid,iprot,oprot,handler)
  "activeBuddySubscriberCount" -> process_activeBuddySubscriberCount (seqid,iprot,oprot,handler)
  "getCallCreditPurchaseHistory" -> process_getCallCreditPurchaseHistory (seqid,iprot,oprot,handler)
  "isRoomMember" -> process_isRoomMember (seqid,iprot,oprot,handler)
  "sendSystemOAMessage" -> process_sendSystemOAMessage (seqid,iprot,oprot,handler)
  "acquirePaidCallRoute" -> process_acquirePaidCallRoute (seqid,iprot,oprot,handler)
  "getGroupsForChannel" -> process_getGroupsForChannel (seqid,iprot,oprot,handler)
  "getUserCreateTime" -> process_getUserCreateTime (seqid,iprot,oprot,handler)
  "registerChannelCP" -> process_registerChannelCP (seqid,iprot,oprot,handler)
  "reserveCallCreditPurchase" -> process_reserveCallCreditPurchase (seqid,iprot,oprot,handler)
  "acquirePaidCallCurrencyExchangeRate" -> process_acquirePaidCallCurrencyExchangeRate (seqid,iprot,oprot,handler)
  "getRoomMemberMidsForAppPlatform" -> process_getRoomMemberMidsForAppPlatform (seqid,iprot,oprot,handler)
  "getPaidCallBalanceList" -> process_getPaidCallBalanceList (seqid,iprot,oprot,handler)
  "getPersonalInfos" -> process_getPersonalInfos (seqid,iprot,oprot,handler)
  "getPrimaryClientsForChannel" -> process_getPrimaryClientsForChannel (seqid,iprot,oprot,handler)
  "addBuddyToContact" -> process_addBuddyToContact (seqid,iprot,oprot,handler)
  "getGroupMemberMidsForAppPlatform" -> process_getGroupMemberMidsForAppPlatform (seqid,iprot,oprot,handler)
  "getUserLanguage" -> process_getUserLanguage (seqid,iprot,oprot,handler)
  "lookupPaidCall" -> process_lookupPaidCall (seqid,iprot,oprot,handler)
  "getExtendedProfile" -> process_getExtendedProfile (seqid,iprot,oprot,handler)
  "getReverseCompactContacts" -> process_getReverseCompactContacts (seqid,iprot,oprot,handler)
  "getPaidCallAdStatus" -> process_getPaidCallAdStatus (seqid,iprot,oprot,handler)
  "findContactByUseridWithoutAbuseBlockForChannel" -> process_findContactByUseridWithoutAbuseBlockForChannel (seqid,iprot,oprot,handler)
  "getGroupMemberMids" -> process_getGroupMemberMids (seqid,iprot,oprot,handler)
  "sendMessageWithoutRelationship" -> process_sendMessageWithoutRelationship (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCountInBulk" -> process_displayBuddySubscriberCountInBulk (seqid,iprot,oprot,handler)
  "lookupRoomMembers" -> process_lookupRoomMembers (seqid,iprot,oprot,handler)
  "getFavoriteMidsForChannel" -> process_getFavoriteMidsForChannel (seqid,iprot,oprot,handler)
  "getAllContactIdsForChannel" -> process_getAllContactIdsForChannel (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCount" -> process_displayBuddySubscriberCount (seqid,iprot,oprot,handler)
  "getProfileForChannel" -> process_getProfileForChannel (seqid,iprot,oprot,handler)
  "getUserTickets" -> process_getUserTickets (seqid,iprot,oprot,handler)
  "getOAFriendMids" -> process_getOAFriendMids (seqid,iprot,oprot,handler)
  "searchPaidCallUserRate" -> process_searchPaidCallUserRate (seqid,iprot,oprot,handler)
  "getJoinedGroupIdsForChannel" -> process_getJoinedGroupIdsForChannel (seqid,iprot,oprot,handler)
  "acquireGroupCallRoute" -> process_acquireGroupCallRoute (seqid,iprot,oprot,handler)
  "getUserMidsWhoAddedMe" -> process_getUserMidsWhoAddedMe (seqid,iprot,oprot,handler)
  "getIdentityCredential" -> process_getIdentityCredential (seqid,iprot,oprot,handler)
  "addOperationForChannel" -> process_addOperationForChannel (seqid,iprot,oprot,handler)
  "getSimpleChannelContacts" -> process_getSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserLastSentMessageTimeStamp" -> process_getUserLastSentMessageTimeStamp (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
