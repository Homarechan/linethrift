{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.13.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module ChannelApplicationProvidedService where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


import Line_Types
import qualified ChannelApplicationProvidedService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary ActiveBuddySubscriberCount_args where 
  arbitrary = QC.elements [ActiveBuddySubscriberCount_args]
from_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args -> T.ThriftVal
from_ActiveBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> ActiveBuddySubscriberCount_args -> P.IO ()
write_ActiveBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_args record
encode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_args -> LBS.ByteString
encode_ActiveBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_args record
to_ActiveBuddySubscriberCount_args :: T.ThriftVal -> ActiveBuddySubscriberCount_args
to_ActiveBuddySubscriberCount_args (T.TStruct fields) = ActiveBuddySubscriberCount_args{

  }
to_ActiveBuddySubscriberCount_args _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_args :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_args
read_ActiveBuddySubscriberCount_args iprot = to_ActiveBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args)
decode_ActiveBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_args
decode_ActiveBuddySubscriberCount_args iprot bs = to_ActiveBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_args) bs
typemap_ActiveBuddySubscriberCount_args :: T.TypeMap
typemap_ActiveBuddySubscriberCount_args = Map.fromList []
default_ActiveBuddySubscriberCount_args :: ActiveBuddySubscriberCount_args
default_ActiveBuddySubscriberCount_args = ActiveBuddySubscriberCount_args{
}
data ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result  { activeBuddySubscriberCount_result_success :: I.Int64
  , activeBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ActiveBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` activeBuddySubscriberCount_result_success record   `H.hashWithSalt` activeBuddySubscriberCount_result_e record  
instance QC.Arbitrary ActiveBuddySubscriberCount_result where 
  arbitrary = M.liftM ActiveBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ActiveBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = activeBuddySubscriberCount_result_success obj}
    , if obj == default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = activeBuddySubscriberCount_result_e obj}
    ]
from_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result -> T.ThriftVal
from_ActiveBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4681 -> (1, ("e",from_TalkException _v4681))) <$> activeBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4681 -> P.Just (0, ("success",T.TI64 _v4681))) $ activeBuddySubscriberCount_result_success record
    , (\_v4681 -> (1, ("e",from_TalkException _v4681))) <$> activeBuddySubscriberCount_result_e record
    ]
    )
write_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> ActiveBuddySubscriberCount_result -> P.IO ()
write_ActiveBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_ActiveBuddySubscriberCount_result record
encode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> ActiveBuddySubscriberCount_result -> LBS.ByteString
encode_ActiveBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_ActiveBuddySubscriberCount_result record
to_ActiveBuddySubscriberCount_result :: T.ThriftVal -> ActiveBuddySubscriberCount_result
to_ActiveBuddySubscriberCount_result (T.TStruct fields) = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = P.maybe (activeBuddySubscriberCount_result_success default_ActiveBuddySubscriberCount_result) (\(_,_val4683) -> (case _val4683 of {T.TI64 _val4684 -> _val4684; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  activeBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val4683) -> P.Just (case _val4683 of {T.TStruct _val4685 -> (to_TalkException (T.TStruct _val4685)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ActiveBuddySubscriberCount_result _ = P.error "not a struct"
read_ActiveBuddySubscriberCount_result :: T.Protocol p => p -> P.IO ActiveBuddySubscriberCount_result
read_ActiveBuddySubscriberCount_result iprot = to_ActiveBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result)
decode_ActiveBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ActiveBuddySubscriberCount_result
decode_ActiveBuddySubscriberCount_result iprot bs = to_ActiveBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ActiveBuddySubscriberCount_result) bs
typemap_ActiveBuddySubscriberCount_result :: T.TypeMap
typemap_ActiveBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_ActiveBuddySubscriberCount_result :: ActiveBuddySubscriberCount_result
default_ActiveBuddySubscriberCount_result = ActiveBuddySubscriberCount_result{
  activeBuddySubscriberCount_result_success = 0,
  activeBuddySubscriberCount_result_e = P.Nothing}
data AddOperationForChannel_args = AddOperationForChannel_args  { addOperationForChannel_args_opType :: OpType
  , addOperationForChannel_args_param1 :: LT.Text
  , addOperationForChannel_args_param2 :: LT.Text
  , addOperationForChannel_args_param3 :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_args_opType record   `H.hashWithSalt` addOperationForChannel_args_param1 record   `H.hashWithSalt` addOperationForChannel_args_param2 record   `H.hashWithSalt` addOperationForChannel_args_param3 record  
instance QC.Arbitrary AddOperationForChannel_args where 
  arbitrary = M.liftM AddOperationForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_opType = addOperationForChannel_args_opType obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param1 = addOperationForChannel_args_param1 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param2 = addOperationForChannel_args_param2 obj}
    , if obj == default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj} then P.Nothing else P.Just $ default_AddOperationForChannel_args{addOperationForChannel_args_param3 = addOperationForChannel_args_param3 obj}
    ]
from_AddOperationForChannel_args :: AddOperationForChannel_args -> T.ThriftVal
from_AddOperationForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4688 -> P.Just (1, ("opType",T.TI32 $ P.fromIntegral $ P.fromEnum _v4688))) $ addOperationForChannel_args_opType record
  , (\_v4688 -> P.Just (2, ("param1",T.TString $ E.encodeUtf8 _v4688))) $ addOperationForChannel_args_param1 record
  , (\_v4688 -> P.Just (3, ("param2",T.TString $ E.encodeUtf8 _v4688))) $ addOperationForChannel_args_param2 record
  , (\_v4688 -> P.Just (4, ("param3",T.TString $ E.encodeUtf8 _v4688))) $ addOperationForChannel_args_param3 record
  ]
write_AddOperationForChannel_args :: T.Protocol p => p -> AddOperationForChannel_args -> P.IO ()
write_AddOperationForChannel_args oprot record = T.writeVal oprot $ from_AddOperationForChannel_args record
encode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> AddOperationForChannel_args -> LBS.ByteString
encode_AddOperationForChannel_args oprot record = T.serializeVal oprot $ from_AddOperationForChannel_args record
to_AddOperationForChannel_args :: T.ThriftVal -> AddOperationForChannel_args
to_AddOperationForChannel_args (T.TStruct fields) = AddOperationForChannel_args{
  addOperationForChannel_args_opType = P.maybe (addOperationForChannel_args_opType default_AddOperationForChannel_args) (\(_,_val4690) -> (case _val4690 of {T.TI32 _val4691 -> P.toEnum $ P.fromIntegral _val4691; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  addOperationForChannel_args_param1 = P.maybe (addOperationForChannel_args_param1 default_AddOperationForChannel_args) (\(_,_val4690) -> (case _val4690 of {T.TString _val4692 -> E.decodeUtf8 _val4692; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  addOperationForChannel_args_param2 = P.maybe (addOperationForChannel_args_param2 default_AddOperationForChannel_args) (\(_,_val4690) -> (case _val4690 of {T.TString _val4693 -> E.decodeUtf8 _val4693; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  addOperationForChannel_args_param3 = P.maybe (addOperationForChannel_args_param3 default_AddOperationForChannel_args) (\(_,_val4690) -> (case _val4690 of {T.TString _val4694 -> E.decodeUtf8 _val4694; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_AddOperationForChannel_args _ = P.error "not a struct"
read_AddOperationForChannel_args :: T.Protocol p => p -> P.IO AddOperationForChannel_args
read_AddOperationForChannel_args iprot = to_AddOperationForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args)
decode_AddOperationForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_args
decode_AddOperationForChannel_args iprot bs = to_AddOperationForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_args) bs
typemap_AddOperationForChannel_args :: T.TypeMap
typemap_AddOperationForChannel_args = Map.fromList [(1,("opType",T.T_I32)),(2,("param1",T.T_STRING)),(3,("param2",T.T_STRING)),(4,("param3",T.T_STRING))]
default_AddOperationForChannel_args :: AddOperationForChannel_args
default_AddOperationForChannel_args = AddOperationForChannel_args{
  addOperationForChannel_args_opType = (P.toEnum 0),
  addOperationForChannel_args_param1 = "",
  addOperationForChannel_args_param2 = "",
  addOperationForChannel_args_param3 = ""}
data AddOperationForChannel_result = AddOperationForChannel_result  { addOperationForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AddOperationForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` addOperationForChannel_result_e record  
instance QC.Arbitrary AddOperationForChannel_result where 
  arbitrary = M.liftM AddOperationForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AddOperationForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj} then P.Nothing else P.Just $ default_AddOperationForChannel_result{addOperationForChannel_result_e = addOperationForChannel_result_e obj}
    ]
from_AddOperationForChannel_result :: AddOperationForChannel_result -> T.ThriftVal
from_AddOperationForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4697 -> (1, ("e",from_TalkException _v4697))) <$> addOperationForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4697 -> (1, ("e",from_TalkException _v4697))) <$> addOperationForChannel_result_e record
    ]
    )
write_AddOperationForChannel_result :: T.Protocol p => p -> AddOperationForChannel_result -> P.IO ()
write_AddOperationForChannel_result oprot record = T.writeVal oprot $ from_AddOperationForChannel_result record
encode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> AddOperationForChannel_result -> LBS.ByteString
encode_AddOperationForChannel_result oprot record = T.serializeVal oprot $ from_AddOperationForChannel_result record
to_AddOperationForChannel_result :: T.ThriftVal -> AddOperationForChannel_result
to_AddOperationForChannel_result (T.TStruct fields) = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4699) -> P.Just (case _val4699 of {T.TStruct _val4700 -> (to_TalkException (T.TStruct _val4700)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AddOperationForChannel_result _ = P.error "not a struct"
read_AddOperationForChannel_result :: T.Protocol p => p -> P.IO AddOperationForChannel_result
read_AddOperationForChannel_result iprot = to_AddOperationForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result)
decode_AddOperationForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AddOperationForChannel_result
decode_AddOperationForChannel_result iprot bs = to_AddOperationForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AddOperationForChannel_result) bs
typemap_AddOperationForChannel_result :: T.TypeMap
typemap_AddOperationForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_AddOperationForChannel_result :: AddOperationForChannel_result
default_AddOperationForChannel_result = AddOperationForChannel_result{
  addOperationForChannel_result_e = P.Nothing}
data DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary DisplayBuddySubscriberCount_args where 
  arbitrary = QC.elements [DisplayBuddySubscriberCount_args]
from_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args -> T.ThriftVal
from_DisplayBuddySubscriberCount_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> DisplayBuddySubscriberCount_args -> P.IO ()
write_DisplayBuddySubscriberCount_args oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_args record
encode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_args -> LBS.ByteString
encode_DisplayBuddySubscriberCount_args oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_args record
to_DisplayBuddySubscriberCount_args :: T.ThriftVal -> DisplayBuddySubscriberCount_args
to_DisplayBuddySubscriberCount_args (T.TStruct fields) = DisplayBuddySubscriberCount_args{

  }
to_DisplayBuddySubscriberCount_args _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_args :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_args
read_DisplayBuddySubscriberCount_args iprot = to_DisplayBuddySubscriberCount_args <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args)
decode_DisplayBuddySubscriberCount_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_args
decode_DisplayBuddySubscriberCount_args iprot bs = to_DisplayBuddySubscriberCount_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_args) bs
typemap_DisplayBuddySubscriberCount_args :: T.TypeMap
typemap_DisplayBuddySubscriberCount_args = Map.fromList []
default_DisplayBuddySubscriberCount_args :: DisplayBuddySubscriberCount_args
default_DisplayBuddySubscriberCount_args = DisplayBuddySubscriberCount_args{
}
data DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result  { displayBuddySubscriberCount_result_success :: I.Int64
  , displayBuddySubscriberCount_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DisplayBuddySubscriberCount_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` displayBuddySubscriberCount_result_success record   `H.hashWithSalt` displayBuddySubscriberCount_result_e record  
instance QC.Arbitrary DisplayBuddySubscriberCount_result where 
  arbitrary = M.liftM DisplayBuddySubscriberCount_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DisplayBuddySubscriberCount_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = displayBuddySubscriberCount_result_success obj}
    , if obj == default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj} then P.Nothing else P.Just $ default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = displayBuddySubscriberCount_result_e obj}
    ]
from_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result -> T.ThriftVal
from_DisplayBuddySubscriberCount_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4708 -> (1, ("e",from_TalkException _v4708))) <$> displayBuddySubscriberCount_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4708 -> P.Just (0, ("success",T.TI64 _v4708))) $ displayBuddySubscriberCount_result_success record
    , (\_v4708 -> (1, ("e",from_TalkException _v4708))) <$> displayBuddySubscriberCount_result_e record
    ]
    )
write_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> DisplayBuddySubscriberCount_result -> P.IO ()
write_DisplayBuddySubscriberCount_result oprot record = T.writeVal oprot $ from_DisplayBuddySubscriberCount_result record
encode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> DisplayBuddySubscriberCount_result -> LBS.ByteString
encode_DisplayBuddySubscriberCount_result oprot record = T.serializeVal oprot $ from_DisplayBuddySubscriberCount_result record
to_DisplayBuddySubscriberCount_result :: T.ThriftVal -> DisplayBuddySubscriberCount_result
to_DisplayBuddySubscriberCount_result (T.TStruct fields) = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = P.maybe (displayBuddySubscriberCount_result_success default_DisplayBuddySubscriberCount_result) (\(_,_val4710) -> (case _val4710 of {T.TI64 _val4711 -> _val4711; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  displayBuddySubscriberCount_result_e = P.maybe (P.Nothing) (\(_,_val4710) -> P.Just (case _val4710 of {T.TStruct _val4712 -> (to_TalkException (T.TStruct _val4712)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_DisplayBuddySubscriberCount_result _ = P.error "not a struct"
read_DisplayBuddySubscriberCount_result :: T.Protocol p => p -> P.IO DisplayBuddySubscriberCount_result
read_DisplayBuddySubscriberCount_result iprot = to_DisplayBuddySubscriberCount_result <$> T.readVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result)
decode_DisplayBuddySubscriberCount_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DisplayBuddySubscriberCount_result
decode_DisplayBuddySubscriberCount_result iprot bs = to_DisplayBuddySubscriberCount_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DisplayBuddySubscriberCount_result) bs
typemap_DisplayBuddySubscriberCount_result :: T.TypeMap
typemap_DisplayBuddySubscriberCount_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_DisplayBuddySubscriberCount_result :: DisplayBuddySubscriberCount_result
default_DisplayBuddySubscriberCount_result = DisplayBuddySubscriberCount_result{
  displayBuddySubscriberCount_result_success = 0,
  displayBuddySubscriberCount_result_e = P.Nothing}
data FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args  { findContactByUseridWithoutAbuseBlockForChannel_args_userid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_args_userid record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_args where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_args (QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_args{findContactByUseridWithoutAbuseBlockForChannel_args_userid = findContactByUseridWithoutAbuseBlockForChannel_args_userid obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4715 -> P.Just (2, ("userid",T.TString $ E.encodeUtf8 _v4715))) $ findContactByUseridWithoutAbuseBlockForChannel_args_userid record
  ]
write_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
encode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_args -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_args oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_args record
to_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_args
to_FindContactByUseridWithoutAbuseBlockForChannel_args (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_args_userid default_FindContactByUseridWithoutAbuseBlockForChannel_args) (\(_,_val4717) -> (case _val4717 of {T.TString _val4718 -> E.decodeUtf8 _val4718; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_args _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_args
read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args)
decode_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_args
decode_FindContactByUseridWithoutAbuseBlockForChannel_args iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_args) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_args = Map.fromList [(2,("userid",T.T_STRING))]
default_FindContactByUseridWithoutAbuseBlockForChannel_args :: FindContactByUseridWithoutAbuseBlockForChannel_args
default_FindContactByUseridWithoutAbuseBlockForChannel_args = FindContactByUseridWithoutAbuseBlockForChannel_args{
  findContactByUseridWithoutAbuseBlockForChannel_args_userid = ""}
data FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result  { findContactByUseridWithoutAbuseBlockForChannel_result_success :: Contact
  , findContactByUseridWithoutAbuseBlockForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindContactByUseridWithoutAbuseBlockForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_success record   `H.hashWithSalt` findContactByUseridWithoutAbuseBlockForChannel_result_e record  
instance QC.Arbitrary FindContactByUseridWithoutAbuseBlockForChannel_result where 
  arbitrary = M.liftM FindContactByUseridWithoutAbuseBlockForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = findContactByUseridWithoutAbuseBlockForChannel_result_success obj}
    , if obj == default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj} then P.Nothing else P.Just $ default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = findContactByUseridWithoutAbuseBlockForChannel_result_e obj}
    ]
from_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result -> T.ThriftVal
from_FindContactByUseridWithoutAbuseBlockForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4721 -> (1, ("e",from_TalkException _v4721))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4721 -> P.Just (0, ("success",from_Contact _v4721))) $ findContactByUseridWithoutAbuseBlockForChannel_result_success record
    , (\_v4721 -> (1, ("e",from_TalkException _v4721))) <$> findContactByUseridWithoutAbuseBlockForChannel_result_e record
    ]
    )
write_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> P.IO ()
write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.writeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
encode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> FindContactByUseridWithoutAbuseBlockForChannel_result -> LBS.ByteString
encode_FindContactByUseridWithoutAbuseBlockForChannel_result oprot record = T.serializeVal oprot $ from_FindContactByUseridWithoutAbuseBlockForChannel_result record
to_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.ThriftVal -> FindContactByUseridWithoutAbuseBlockForChannel_result
to_FindContactByUseridWithoutAbuseBlockForChannel_result (T.TStruct fields) = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = P.maybe (findContactByUseridWithoutAbuseBlockForChannel_result_success default_FindContactByUseridWithoutAbuseBlockForChannel_result) (\(_,_val4723) -> (case _val4723 of {T.TStruct _val4724 -> (to_Contact (T.TStruct _val4724)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4723) -> P.Just (case _val4723 of {T.TStruct _val4725 -> (to_TalkException (T.TStruct _val4725)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_FindContactByUseridWithoutAbuseBlockForChannel_result _ = P.error "not a struct"
read_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.Protocol p => p -> P.IO FindContactByUseridWithoutAbuseBlockForChannel_result
read_FindContactByUseridWithoutAbuseBlockForChannel_result iprot = to_FindContactByUseridWithoutAbuseBlockForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result)
decode_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindContactByUseridWithoutAbuseBlockForChannel_result
decode_FindContactByUseridWithoutAbuseBlockForChannel_result iprot bs = to_FindContactByUseridWithoutAbuseBlockForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindContactByUseridWithoutAbuseBlockForChannel_result) bs
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result :: T.TypeMap
typemap_FindContactByUseridWithoutAbuseBlockForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Contact))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_FindContactByUseridWithoutAbuseBlockForChannel_result :: FindContactByUseridWithoutAbuseBlockForChannel_result
default_FindContactByUseridWithoutAbuseBlockForChannel_result = FindContactByUseridWithoutAbuseBlockForChannel_result{
  findContactByUseridWithoutAbuseBlockForChannel_result_success = default_Contact,
  findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Nothing}
data GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetAllContactIdsForChannel_args where 
  arbitrary = QC.elements [GetAllContactIdsForChannel_args]
from_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args -> T.ThriftVal
from_GetAllContactIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetAllContactIdsForChannel_args :: T.Protocol p => p -> GetAllContactIdsForChannel_args -> P.IO ()
write_GetAllContactIdsForChannel_args oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_args record
encode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_args -> LBS.ByteString
encode_GetAllContactIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_args record
to_GetAllContactIdsForChannel_args :: T.ThriftVal -> GetAllContactIdsForChannel_args
to_GetAllContactIdsForChannel_args (T.TStruct fields) = GetAllContactIdsForChannel_args{

  }
to_GetAllContactIdsForChannel_args _ = P.error "not a struct"
read_GetAllContactIdsForChannel_args :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_args
read_GetAllContactIdsForChannel_args iprot = to_GetAllContactIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args)
decode_GetAllContactIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_args
decode_GetAllContactIdsForChannel_args iprot bs = to_GetAllContactIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_args) bs
typemap_GetAllContactIdsForChannel_args :: T.TypeMap
typemap_GetAllContactIdsForChannel_args = Map.fromList []
default_GetAllContactIdsForChannel_args :: GetAllContactIdsForChannel_args
default_GetAllContactIdsForChannel_args = GetAllContactIdsForChannel_args{
}
data GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result  { getAllContactIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getAllContactIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAllContactIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAllContactIdsForChannel_result_success record   `H.hashWithSalt` getAllContactIdsForChannel_result_e record  
instance QC.Arbitrary GetAllContactIdsForChannel_result where 
  arbitrary = M.liftM GetAllContactIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAllContactIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = getAllContactIdsForChannel_result_success obj}
    , if obj == default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = getAllContactIdsForChannel_result_e obj}
    ]
from_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result -> T.ThriftVal
from_GetAllContactIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4733 -> (1, ("e",from_TalkException _v4733))) <$> getAllContactIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4733 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4735 -> T.TString $ E.encodeUtf8 _v4735) $ Vector.toList _v4733))) $ getAllContactIdsForChannel_result_success record
    , (\_v4733 -> (1, ("e",from_TalkException _v4733))) <$> getAllContactIdsForChannel_result_e record
    ]
    )
write_GetAllContactIdsForChannel_result :: T.Protocol p => p -> GetAllContactIdsForChannel_result -> P.IO ()
write_GetAllContactIdsForChannel_result oprot record = T.writeVal oprot $ from_GetAllContactIdsForChannel_result record
encode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> GetAllContactIdsForChannel_result -> LBS.ByteString
encode_GetAllContactIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetAllContactIdsForChannel_result record
to_GetAllContactIdsForChannel_result :: T.ThriftVal -> GetAllContactIdsForChannel_result
to_GetAllContactIdsForChannel_result (T.TStruct fields) = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = P.maybe (getAllContactIdsForChannel_result_success default_GetAllContactIdsForChannel_result) (\(_,_val4737) -> (case _val4737 of {T.TList _ _val4738 -> (Vector.fromList $ P.map (\_v4739 -> (case _v4739 of {T.TString _val4740 -> E.decodeUtf8 _val4740; _ -> P.error "wrong type"})) _val4738); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAllContactIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4737) -> P.Just (case _val4737 of {T.TStruct _val4741 -> (to_TalkException (T.TStruct _val4741)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAllContactIdsForChannel_result _ = P.error "not a struct"
read_GetAllContactIdsForChannel_result :: T.Protocol p => p -> P.IO GetAllContactIdsForChannel_result
read_GetAllContactIdsForChannel_result iprot = to_GetAllContactIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result)
decode_GetAllContactIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAllContactIdsForChannel_result
decode_GetAllContactIdsForChannel_result iprot bs = to_GetAllContactIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAllContactIdsForChannel_result) bs
typemap_GetAllContactIdsForChannel_result :: T.TypeMap
typemap_GetAllContactIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetAllContactIdsForChannel_result :: GetAllContactIdsForChannel_result
default_GetAllContactIdsForChannel_result = GetAllContactIdsForChannel_result{
  getAllContactIdsForChannel_result_success = Vector.empty,
  getAllContactIdsForChannel_result_e = P.Nothing}
data GetCompactContacts_args = GetCompactContacts_args  { getCompactContacts_args_lastModifiedTimestamp :: I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_args_lastModifiedTimestamp record  
instance QC.Arbitrary GetCompactContacts_args where 
  arbitrary = M.liftM GetCompactContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj} then P.Nothing else P.Just $ default_GetCompactContacts_args{getCompactContacts_args_lastModifiedTimestamp = getCompactContacts_args_lastModifiedTimestamp obj}
    ]
from_GetCompactContacts_args :: GetCompactContacts_args -> T.ThriftVal
from_GetCompactContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4744 -> P.Just (2, ("lastModifiedTimestamp",T.TI64 _v4744))) $ getCompactContacts_args_lastModifiedTimestamp record
  ]
write_GetCompactContacts_args :: T.Protocol p => p -> GetCompactContacts_args -> P.IO ()
write_GetCompactContacts_args oprot record = T.writeVal oprot $ from_GetCompactContacts_args record
encode_GetCompactContacts_args :: T.StatelessProtocol p => p -> GetCompactContacts_args -> LBS.ByteString
encode_GetCompactContacts_args oprot record = T.serializeVal oprot $ from_GetCompactContacts_args record
to_GetCompactContacts_args :: T.ThriftVal -> GetCompactContacts_args
to_GetCompactContacts_args (T.TStruct fields) = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = P.maybe (getCompactContacts_args_lastModifiedTimestamp default_GetCompactContacts_args) (\(_,_val4746) -> (case _val4746 of {T.TI64 _val4747 -> _val4747; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetCompactContacts_args _ = P.error "not a struct"
read_GetCompactContacts_args :: T.Protocol p => p -> P.IO GetCompactContacts_args
read_GetCompactContacts_args iprot = to_GetCompactContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_args)
decode_GetCompactContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_args
decode_GetCompactContacts_args iprot bs = to_GetCompactContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_args) bs
typemap_GetCompactContacts_args :: T.TypeMap
typemap_GetCompactContacts_args = Map.fromList [(2,("lastModifiedTimestamp",T.T_I64))]
default_GetCompactContacts_args :: GetCompactContacts_args
default_GetCompactContacts_args = GetCompactContacts_args{
  getCompactContacts_args_lastModifiedTimestamp = 0}
data GetCompactContacts_result = GetCompactContacts_result  { getCompactContacts_result_success :: (Vector.Vector CompactContact)
  , getCompactContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetCompactContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getCompactContacts_result_success record   `H.hashWithSalt` getCompactContacts_result_e record  
instance QC.Arbitrary GetCompactContacts_result where 
  arbitrary = M.liftM GetCompactContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetCompactContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_success = getCompactContacts_result_success obj}
    , if obj == default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj} then P.Nothing else P.Just $ default_GetCompactContacts_result{getCompactContacts_result_e = getCompactContacts_result_e obj}
    ]
from_GetCompactContacts_result :: GetCompactContacts_result -> T.ThriftVal
from_GetCompactContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4750 -> (1, ("e",from_TalkException _v4750))) <$> getCompactContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4750 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_CompactContact) $ P.map (\_v4752 -> from_CompactContact _v4752) $ Vector.toList _v4750))) $ getCompactContacts_result_success record
    , (\_v4750 -> (1, ("e",from_TalkException _v4750))) <$> getCompactContacts_result_e record
    ]
    )
write_GetCompactContacts_result :: T.Protocol p => p -> GetCompactContacts_result -> P.IO ()
write_GetCompactContacts_result oprot record = T.writeVal oprot $ from_GetCompactContacts_result record
encode_GetCompactContacts_result :: T.StatelessProtocol p => p -> GetCompactContacts_result -> LBS.ByteString
encode_GetCompactContacts_result oprot record = T.serializeVal oprot $ from_GetCompactContacts_result record
to_GetCompactContacts_result :: T.ThriftVal -> GetCompactContacts_result
to_GetCompactContacts_result (T.TStruct fields) = GetCompactContacts_result{
  getCompactContacts_result_success = P.maybe (getCompactContacts_result_success default_GetCompactContacts_result) (\(_,_val4754) -> (case _val4754 of {T.TList _ _val4755 -> (Vector.fromList $ P.map (\_v4756 -> (case _v4756 of {T.TStruct _val4757 -> (to_CompactContact (T.TStruct _val4757)); _ -> P.error "wrong type"})) _val4755); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getCompactContacts_result_e = P.maybe (P.Nothing) (\(_,_val4754) -> P.Just (case _val4754 of {T.TStruct _val4758 -> (to_TalkException (T.TStruct _val4758)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetCompactContacts_result _ = P.error "not a struct"
read_GetCompactContacts_result :: T.Protocol p => p -> P.IO GetCompactContacts_result
read_GetCompactContacts_result iprot = to_GetCompactContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetCompactContacts_result)
decode_GetCompactContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetCompactContacts_result
decode_GetCompactContacts_result iprot bs = to_GetCompactContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetCompactContacts_result) bs
typemap_GetCompactContacts_result :: T.TypeMap
typemap_GetCompactContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_CompactContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetCompactContacts_result :: GetCompactContacts_result
default_GetCompactContacts_result = GetCompactContacts_result{
  getCompactContacts_result_success = Vector.empty,
  getCompactContacts_result_e = P.Nothing}
data GetContactsForChannel_args = GetContactsForChannel_args  { getContactsForChannel_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_args_ids record  
instance QC.Arbitrary GetContactsForChannel_args where 
  arbitrary = M.liftM GetContactsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj} then P.Nothing else P.Just $ default_GetContactsForChannel_args{getContactsForChannel_args_ids = getContactsForChannel_args_ids obj}
    ]
from_GetContactsForChannel_args :: GetContactsForChannel_args -> T.ThriftVal
from_GetContactsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4761 -> P.Just (2, ("ids",T.TList T.T_STRING $ P.map (\_v4763 -> T.TString $ E.encodeUtf8 _v4763) $ Vector.toList _v4761))) $ getContactsForChannel_args_ids record
  ]
write_GetContactsForChannel_args :: T.Protocol p => p -> GetContactsForChannel_args -> P.IO ()
write_GetContactsForChannel_args oprot record = T.writeVal oprot $ from_GetContactsForChannel_args record
encode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> GetContactsForChannel_args -> LBS.ByteString
encode_GetContactsForChannel_args oprot record = T.serializeVal oprot $ from_GetContactsForChannel_args record
to_GetContactsForChannel_args :: T.ThriftVal -> GetContactsForChannel_args
to_GetContactsForChannel_args (T.TStruct fields) = GetContactsForChannel_args{
  getContactsForChannel_args_ids = P.maybe (getContactsForChannel_args_ids default_GetContactsForChannel_args) (\(_,_val4765) -> (case _val4765 of {T.TList _ _val4766 -> (Vector.fromList $ P.map (\_v4767 -> (case _v4767 of {T.TString _val4768 -> E.decodeUtf8 _val4768; _ -> P.error "wrong type"})) _val4766); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetContactsForChannel_args _ = P.error "not a struct"
read_GetContactsForChannel_args :: T.Protocol p => p -> P.IO GetContactsForChannel_args
read_GetContactsForChannel_args iprot = to_GetContactsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args)
decode_GetContactsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_args
decode_GetContactsForChannel_args iprot bs = to_GetContactsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_args) bs
typemap_GetContactsForChannel_args :: T.TypeMap
typemap_GetContactsForChannel_args = Map.fromList [(2,("ids",(T.T_LIST T.T_STRING)))]
default_GetContactsForChannel_args :: GetContactsForChannel_args
default_GetContactsForChannel_args = GetContactsForChannel_args{
  getContactsForChannel_args_ids = Vector.empty}
data GetContactsForChannel_result = GetContactsForChannel_result  { getContactsForChannel_result_success :: (Vector.Vector Contact)
  , getContactsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetContactsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getContactsForChannel_result_success record   `H.hashWithSalt` getContactsForChannel_result_e record  
instance QC.Arbitrary GetContactsForChannel_result where 
  arbitrary = M.liftM GetContactsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetContactsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_success = getContactsForChannel_result_success obj}
    , if obj == default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetContactsForChannel_result{getContactsForChannel_result_e = getContactsForChannel_result_e obj}
    ]
from_GetContactsForChannel_result :: GetContactsForChannel_result -> T.ThriftVal
from_GetContactsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4771 -> (1, ("e",from_TalkException _v4771))) <$> getContactsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4771 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Contact) $ P.map (\_v4773 -> from_Contact _v4773) $ Vector.toList _v4771))) $ getContactsForChannel_result_success record
    , (\_v4771 -> (1, ("e",from_TalkException _v4771))) <$> getContactsForChannel_result_e record
    ]
    )
write_GetContactsForChannel_result :: T.Protocol p => p -> GetContactsForChannel_result -> P.IO ()
write_GetContactsForChannel_result oprot record = T.writeVal oprot $ from_GetContactsForChannel_result record
encode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> GetContactsForChannel_result -> LBS.ByteString
encode_GetContactsForChannel_result oprot record = T.serializeVal oprot $ from_GetContactsForChannel_result record
to_GetContactsForChannel_result :: T.ThriftVal -> GetContactsForChannel_result
to_GetContactsForChannel_result (T.TStruct fields) = GetContactsForChannel_result{
  getContactsForChannel_result_success = P.maybe (getContactsForChannel_result_success default_GetContactsForChannel_result) (\(_,_val4775) -> (case _val4775 of {T.TList _ _val4776 -> (Vector.fromList $ P.map (\_v4777 -> (case _v4777 of {T.TStruct _val4778 -> (to_Contact (T.TStruct _val4778)); _ -> P.error "wrong type"})) _val4776); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getContactsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4775) -> P.Just (case _val4775 of {T.TStruct _val4779 -> (to_TalkException (T.TStruct _val4779)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetContactsForChannel_result _ = P.error "not a struct"
read_GetContactsForChannel_result :: T.Protocol p => p -> P.IO GetContactsForChannel_result
read_GetContactsForChannel_result iprot = to_GetContactsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result)
decode_GetContactsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetContactsForChannel_result
decode_GetContactsForChannel_result iprot bs = to_GetContactsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetContactsForChannel_result) bs
typemap_GetContactsForChannel_result :: T.TypeMap
typemap_GetContactsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Contact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetContactsForChannel_result :: GetContactsForChannel_result
default_GetContactsForChannel_result = GetContactsForChannel_result{
  getContactsForChannel_result_success = Vector.empty,
  getContactsForChannel_result_e = P.Nothing}
data GetDisplayName_args = GetDisplayName_args  { getDisplayName_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_args_mid record  
instance QC.Arbitrary GetDisplayName_args where 
  arbitrary = M.liftM GetDisplayName_args (QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj} then P.Nothing else P.Just $ default_GetDisplayName_args{getDisplayName_args_mid = getDisplayName_args_mid obj}
    ]
from_GetDisplayName_args :: GetDisplayName_args -> T.ThriftVal
from_GetDisplayName_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4782 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v4782))) $ getDisplayName_args_mid record
  ]
write_GetDisplayName_args :: T.Protocol p => p -> GetDisplayName_args -> P.IO ()
write_GetDisplayName_args oprot record = T.writeVal oprot $ from_GetDisplayName_args record
encode_GetDisplayName_args :: T.StatelessProtocol p => p -> GetDisplayName_args -> LBS.ByteString
encode_GetDisplayName_args oprot record = T.serializeVal oprot $ from_GetDisplayName_args record
to_GetDisplayName_args :: T.ThriftVal -> GetDisplayName_args
to_GetDisplayName_args (T.TStruct fields) = GetDisplayName_args{
  getDisplayName_args_mid = P.maybe (getDisplayName_args_mid default_GetDisplayName_args) (\(_,_val4784) -> (case _val4784 of {T.TString _val4785 -> E.decodeUtf8 _val4785; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDisplayName_args _ = P.error "not a struct"
read_GetDisplayName_args :: T.Protocol p => p -> P.IO GetDisplayName_args
read_GetDisplayName_args iprot = to_GetDisplayName_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_args)
decode_GetDisplayName_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_args
decode_GetDisplayName_args iprot bs = to_GetDisplayName_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_args) bs
typemap_GetDisplayName_args :: T.TypeMap
typemap_GetDisplayName_args = Map.fromList [(2,("mid",T.T_STRING))]
default_GetDisplayName_args :: GetDisplayName_args
default_GetDisplayName_args = GetDisplayName_args{
  getDisplayName_args_mid = ""}
data GetDisplayName_result = GetDisplayName_result  { getDisplayName_result_success :: LT.Text
  , getDisplayName_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDisplayName_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDisplayName_result_success record   `H.hashWithSalt` getDisplayName_result_e record  
instance QC.Arbitrary GetDisplayName_result where 
  arbitrary = M.liftM GetDisplayName_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDisplayName_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_success = getDisplayName_result_success obj}
    , if obj == default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj} then P.Nothing else P.Just $ default_GetDisplayName_result{getDisplayName_result_e = getDisplayName_result_e obj}
    ]
from_GetDisplayName_result :: GetDisplayName_result -> T.ThriftVal
from_GetDisplayName_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4788 -> (1, ("e",from_TalkException _v4788))) <$> getDisplayName_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4788 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4788))) $ getDisplayName_result_success record
    , (\_v4788 -> (1, ("e",from_TalkException _v4788))) <$> getDisplayName_result_e record
    ]
    )
write_GetDisplayName_result :: T.Protocol p => p -> GetDisplayName_result -> P.IO ()
write_GetDisplayName_result oprot record = T.writeVal oprot $ from_GetDisplayName_result record
encode_GetDisplayName_result :: T.StatelessProtocol p => p -> GetDisplayName_result -> LBS.ByteString
encode_GetDisplayName_result oprot record = T.serializeVal oprot $ from_GetDisplayName_result record
to_GetDisplayName_result :: T.ThriftVal -> GetDisplayName_result
to_GetDisplayName_result (T.TStruct fields) = GetDisplayName_result{
  getDisplayName_result_success = P.maybe (getDisplayName_result_success default_GetDisplayName_result) (\(_,_val4790) -> (case _val4790 of {T.TString _val4791 -> E.decodeUtf8 _val4791; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDisplayName_result_e = P.maybe (P.Nothing) (\(_,_val4790) -> P.Just (case _val4790 of {T.TStruct _val4792 -> (to_TalkException (T.TStruct _val4792)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDisplayName_result _ = P.error "not a struct"
read_GetDisplayName_result :: T.Protocol p => p -> P.IO GetDisplayName_result
read_GetDisplayName_result iprot = to_GetDisplayName_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDisplayName_result)
decode_GetDisplayName_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDisplayName_result
decode_GetDisplayName_result iprot bs = to_GetDisplayName_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDisplayName_result) bs
typemap_GetDisplayName_result :: T.TypeMap
typemap_GetDisplayName_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetDisplayName_result :: GetDisplayName_result
default_GetDisplayName_result = GetDisplayName_result{
  getDisplayName_result_success = "",
  getDisplayName_result_e = P.Nothing}
data GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFavoriteMidsForChannel_args where 
  arbitrary = QC.elements [GetFavoriteMidsForChannel_args]
from_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args -> T.ThriftVal
from_GetFavoriteMidsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> GetFavoriteMidsForChannel_args -> P.IO ()
write_GetFavoriteMidsForChannel_args oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_args record
encode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_args -> LBS.ByteString
encode_GetFavoriteMidsForChannel_args oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_args record
to_GetFavoriteMidsForChannel_args :: T.ThriftVal -> GetFavoriteMidsForChannel_args
to_GetFavoriteMidsForChannel_args (T.TStruct fields) = GetFavoriteMidsForChannel_args{

  }
to_GetFavoriteMidsForChannel_args _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_args :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_args
read_GetFavoriteMidsForChannel_args iprot = to_GetFavoriteMidsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args)
decode_GetFavoriteMidsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_args
decode_GetFavoriteMidsForChannel_args iprot bs = to_GetFavoriteMidsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_args) bs
typemap_GetFavoriteMidsForChannel_args :: T.TypeMap
typemap_GetFavoriteMidsForChannel_args = Map.fromList []
default_GetFavoriteMidsForChannel_args :: GetFavoriteMidsForChannel_args
default_GetFavoriteMidsForChannel_args = GetFavoriteMidsForChannel_args{
}
data GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result  { getFavoriteMidsForChannel_result_success :: (Vector.Vector LT.Text)
  , getFavoriteMidsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFavoriteMidsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFavoriteMidsForChannel_result_success record   `H.hashWithSalt` getFavoriteMidsForChannel_result_e record  
instance QC.Arbitrary GetFavoriteMidsForChannel_result where 
  arbitrary = M.liftM GetFavoriteMidsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFavoriteMidsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = getFavoriteMidsForChannel_result_success obj}
    , if obj == default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = getFavoriteMidsForChannel_result_e obj}
    ]
from_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result -> T.ThriftVal
from_GetFavoriteMidsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4800 -> (1, ("e",from_TalkException _v4800))) <$> getFavoriteMidsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4800 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4802 -> T.TString $ E.encodeUtf8 _v4802) $ Vector.toList _v4800))) $ getFavoriteMidsForChannel_result_success record
    , (\_v4800 -> (1, ("e",from_TalkException _v4800))) <$> getFavoriteMidsForChannel_result_e record
    ]
    )
write_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> GetFavoriteMidsForChannel_result -> P.IO ()
write_GetFavoriteMidsForChannel_result oprot record = T.writeVal oprot $ from_GetFavoriteMidsForChannel_result record
encode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> GetFavoriteMidsForChannel_result -> LBS.ByteString
encode_GetFavoriteMidsForChannel_result oprot record = T.serializeVal oprot $ from_GetFavoriteMidsForChannel_result record
to_GetFavoriteMidsForChannel_result :: T.ThriftVal -> GetFavoriteMidsForChannel_result
to_GetFavoriteMidsForChannel_result (T.TStruct fields) = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = P.maybe (getFavoriteMidsForChannel_result_success default_GetFavoriteMidsForChannel_result) (\(_,_val4804) -> (case _val4804 of {T.TList _ _val4805 -> (Vector.fromList $ P.map (\_v4806 -> (case _v4806 of {T.TString _val4807 -> E.decodeUtf8 _val4807; _ -> P.error "wrong type"})) _val4805); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFavoriteMidsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4804) -> P.Just (case _val4804 of {T.TStruct _val4808 -> (to_TalkException (T.TStruct _val4808)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFavoriteMidsForChannel_result _ = P.error "not a struct"
read_GetFavoriteMidsForChannel_result :: T.Protocol p => p -> P.IO GetFavoriteMidsForChannel_result
read_GetFavoriteMidsForChannel_result iprot = to_GetFavoriteMidsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result)
decode_GetFavoriteMidsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFavoriteMidsForChannel_result
decode_GetFavoriteMidsForChannel_result iprot bs = to_GetFavoriteMidsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFavoriteMidsForChannel_result) bs
typemap_GetFavoriteMidsForChannel_result :: T.TypeMap
typemap_GetFavoriteMidsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFavoriteMidsForChannel_result :: GetFavoriteMidsForChannel_result
default_GetFavoriteMidsForChannel_result = GetFavoriteMidsForChannel_result{
  getFavoriteMidsForChannel_result_success = Vector.empty,
  getFavoriteMidsForChannel_result_e = P.Nothing}
data GetFriendMids_args = GetFriendMids_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetFriendMids_args where 
  arbitrary = QC.elements [GetFriendMids_args]
from_GetFriendMids_args :: GetFriendMids_args -> T.ThriftVal
from_GetFriendMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetFriendMids_args :: T.Protocol p => p -> GetFriendMids_args -> P.IO ()
write_GetFriendMids_args oprot record = T.writeVal oprot $ from_GetFriendMids_args record
encode_GetFriendMids_args :: T.StatelessProtocol p => p -> GetFriendMids_args -> LBS.ByteString
encode_GetFriendMids_args oprot record = T.serializeVal oprot $ from_GetFriendMids_args record
to_GetFriendMids_args :: T.ThriftVal -> GetFriendMids_args
to_GetFriendMids_args (T.TStruct fields) = GetFriendMids_args{

  }
to_GetFriendMids_args _ = P.error "not a struct"
read_GetFriendMids_args :: T.Protocol p => p -> P.IO GetFriendMids_args
read_GetFriendMids_args iprot = to_GetFriendMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_args)
decode_GetFriendMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_args
decode_GetFriendMids_args iprot bs = to_GetFriendMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_args) bs
typemap_GetFriendMids_args :: T.TypeMap
typemap_GetFriendMids_args = Map.fromList []
default_GetFriendMids_args :: GetFriendMids_args
default_GetFriendMids_args = GetFriendMids_args{
}
data GetFriendMids_result = GetFriendMids_result  { getFriendMids_result_success :: (Vector.Vector LT.Text)
  , getFriendMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFriendMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFriendMids_result_success record   `H.hashWithSalt` getFriendMids_result_e record  
instance QC.Arbitrary GetFriendMids_result where 
  arbitrary = M.liftM GetFriendMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFriendMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_success = getFriendMids_result_success obj}
    , if obj == default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj} then P.Nothing else P.Just $ default_GetFriendMids_result{getFriendMids_result_e = getFriendMids_result_e obj}
    ]
from_GetFriendMids_result :: GetFriendMids_result -> T.ThriftVal
from_GetFriendMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4816 -> (1, ("e",from_TalkException _v4816))) <$> getFriendMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4816 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4818 -> T.TString $ E.encodeUtf8 _v4818) $ Vector.toList _v4816))) $ getFriendMids_result_success record
    , (\_v4816 -> (1, ("e",from_TalkException _v4816))) <$> getFriendMids_result_e record
    ]
    )
write_GetFriendMids_result :: T.Protocol p => p -> GetFriendMids_result -> P.IO ()
write_GetFriendMids_result oprot record = T.writeVal oprot $ from_GetFriendMids_result record
encode_GetFriendMids_result :: T.StatelessProtocol p => p -> GetFriendMids_result -> LBS.ByteString
encode_GetFriendMids_result oprot record = T.serializeVal oprot $ from_GetFriendMids_result record
to_GetFriendMids_result :: T.ThriftVal -> GetFriendMids_result
to_GetFriendMids_result (T.TStruct fields) = GetFriendMids_result{
  getFriendMids_result_success = P.maybe (getFriendMids_result_success default_GetFriendMids_result) (\(_,_val4820) -> (case _val4820 of {T.TList _ _val4821 -> (Vector.fromList $ P.map (\_v4822 -> (case _v4822 of {T.TString _val4823 -> E.decodeUtf8 _val4823; _ -> P.error "wrong type"})) _val4821); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFriendMids_result_e = P.maybe (P.Nothing) (\(_,_val4820) -> P.Just (case _val4820 of {T.TStruct _val4824 -> (to_TalkException (T.TStruct _val4824)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetFriendMids_result _ = P.error "not a struct"
read_GetFriendMids_result :: T.Protocol p => p -> P.IO GetFriendMids_result
read_GetFriendMids_result iprot = to_GetFriendMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFriendMids_result)
decode_GetFriendMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFriendMids_result
decode_GetFriendMids_result iprot bs = to_GetFriendMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFriendMids_result) bs
typemap_GetFriendMids_result :: T.TypeMap
typemap_GetFriendMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetFriendMids_result :: GetFriendMids_result
default_GetFriendMids_result = GetFriendMids_result{
  getFriendMids_result_success = Vector.empty,
  getFriendMids_result_e = P.Nothing}
data GetGroupMemberMids_args = GetGroupMemberMids_args  { getGroupMemberMids_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_args_groupId record  
instance QC.Arbitrary GetGroupMemberMids_args where 
  arbitrary = M.liftM GetGroupMemberMids_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_args{getGroupMemberMids_args_groupId = getGroupMemberMids_args_groupId obj}
    ]
from_GetGroupMemberMids_args :: GetGroupMemberMids_args -> T.ThriftVal
from_GetGroupMemberMids_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4827 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v4827))) $ getGroupMemberMids_args_groupId record
  ]
write_GetGroupMemberMids_args :: T.Protocol p => p -> GetGroupMemberMids_args -> P.IO ()
write_GetGroupMemberMids_args oprot record = T.writeVal oprot $ from_GetGroupMemberMids_args record
encode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> GetGroupMemberMids_args -> LBS.ByteString
encode_GetGroupMemberMids_args oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_args record
to_GetGroupMemberMids_args :: T.ThriftVal -> GetGroupMemberMids_args
to_GetGroupMemberMids_args (T.TStruct fields) = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = P.maybe (getGroupMemberMids_args_groupId default_GetGroupMemberMids_args) (\(_,_val4829) -> (case _val4829 of {T.TString _val4830 -> E.decodeUtf8 _val4830; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_args _ = P.error "not a struct"
read_GetGroupMemberMids_args :: T.Protocol p => p -> P.IO GetGroupMemberMids_args
read_GetGroupMemberMids_args iprot = to_GetGroupMemberMids_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args)
decode_GetGroupMemberMids_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_args
decode_GetGroupMemberMids_args iprot bs = to_GetGroupMemberMids_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_args) bs
typemap_GetGroupMemberMids_args :: T.TypeMap
typemap_GetGroupMemberMids_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_GetGroupMemberMids_args :: GetGroupMemberMids_args
default_GetGroupMemberMids_args = GetGroupMemberMids_args{
  getGroupMemberMids_args_groupId = ""}
data GetGroupMemberMids_result = GetGroupMemberMids_result  { getGroupMemberMids_result_success :: (Vector.Vector LT.Text)
  , getGroupMemberMids_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupMemberMids_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupMemberMids_result_success record   `H.hashWithSalt` getGroupMemberMids_result_e record  
instance QC.Arbitrary GetGroupMemberMids_result where 
  arbitrary = M.liftM GetGroupMemberMids_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupMemberMids_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_success = getGroupMemberMids_result_success obj}
    , if obj == default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj} then P.Nothing else P.Just $ default_GetGroupMemberMids_result{getGroupMemberMids_result_e = getGroupMemberMids_result_e obj}
    ]
from_GetGroupMemberMids_result :: GetGroupMemberMids_result -> T.ThriftVal
from_GetGroupMemberMids_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4833 -> (1, ("e",from_TalkException _v4833))) <$> getGroupMemberMids_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4833 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4835 -> T.TString $ E.encodeUtf8 _v4835) $ Vector.toList _v4833))) $ getGroupMemberMids_result_success record
    , (\_v4833 -> (1, ("e",from_TalkException _v4833))) <$> getGroupMemberMids_result_e record
    ]
    )
write_GetGroupMemberMids_result :: T.Protocol p => p -> GetGroupMemberMids_result -> P.IO ()
write_GetGroupMemberMids_result oprot record = T.writeVal oprot $ from_GetGroupMemberMids_result record
encode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> GetGroupMemberMids_result -> LBS.ByteString
encode_GetGroupMemberMids_result oprot record = T.serializeVal oprot $ from_GetGroupMemberMids_result record
to_GetGroupMemberMids_result :: T.ThriftVal -> GetGroupMemberMids_result
to_GetGroupMemberMids_result (T.TStruct fields) = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = P.maybe (getGroupMemberMids_result_success default_GetGroupMemberMids_result) (\(_,_val4837) -> (case _val4837 of {T.TList _ _val4838 -> (Vector.fromList $ P.map (\_v4839 -> (case _v4839 of {T.TString _val4840 -> E.decodeUtf8 _val4840; _ -> P.error "wrong type"})) _val4838); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupMemberMids_result_e = P.maybe (P.Nothing) (\(_,_val4837) -> P.Just (case _val4837 of {T.TStruct _val4841 -> (to_TalkException (T.TStruct _val4841)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupMemberMids_result _ = P.error "not a struct"
read_GetGroupMemberMids_result :: T.Protocol p => p -> P.IO GetGroupMemberMids_result
read_GetGroupMemberMids_result iprot = to_GetGroupMemberMids_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result)
decode_GetGroupMemberMids_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupMemberMids_result
decode_GetGroupMemberMids_result iprot bs = to_GetGroupMemberMids_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupMemberMids_result) bs
typemap_GetGroupMemberMids_result :: T.TypeMap
typemap_GetGroupMemberMids_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupMemberMids_result :: GetGroupMemberMids_result
default_GetGroupMemberMids_result = GetGroupMemberMids_result{
  getGroupMemberMids_result_success = Vector.empty,
  getGroupMemberMids_result_e = P.Nothing}
data GetGroupsForChannel_args = GetGroupsForChannel_args  { getGroupsForChannel_args_groupIds :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_args_groupIds record  
instance QC.Arbitrary GetGroupsForChannel_args where 
  arbitrary = M.liftM GetGroupsForChannel_args (QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_args{getGroupsForChannel_args_groupIds = getGroupsForChannel_args_groupIds obj}
    ]
from_GetGroupsForChannel_args :: GetGroupsForChannel_args -> T.ThriftVal
from_GetGroupsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4844 -> P.Just (1, ("groupIds",T.TList T.T_STRING $ P.map (\_v4846 -> T.TString $ E.encodeUtf8 _v4846) $ Vector.toList _v4844))) $ getGroupsForChannel_args_groupIds record
  ]
write_GetGroupsForChannel_args :: T.Protocol p => p -> GetGroupsForChannel_args -> P.IO ()
write_GetGroupsForChannel_args oprot record = T.writeVal oprot $ from_GetGroupsForChannel_args record
encode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> GetGroupsForChannel_args -> LBS.ByteString
encode_GetGroupsForChannel_args oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_args record
to_GetGroupsForChannel_args :: T.ThriftVal -> GetGroupsForChannel_args
to_GetGroupsForChannel_args (T.TStruct fields) = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = P.maybe (getGroupsForChannel_args_groupIds default_GetGroupsForChannel_args) (\(_,_val4848) -> (case _val4848 of {T.TList _ _val4849 -> (Vector.fromList $ P.map (\_v4850 -> (case _v4850 of {T.TString _val4851 -> E.decodeUtf8 _val4851; _ -> P.error "wrong type"})) _val4849); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_args _ = P.error "not a struct"
read_GetGroupsForChannel_args :: T.Protocol p => p -> P.IO GetGroupsForChannel_args
read_GetGroupsForChannel_args iprot = to_GetGroupsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args)
decode_GetGroupsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_args
decode_GetGroupsForChannel_args iprot bs = to_GetGroupsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_args) bs
typemap_GetGroupsForChannel_args :: T.TypeMap
typemap_GetGroupsForChannel_args = Map.fromList [(1,("groupIds",(T.T_LIST T.T_STRING)))]
default_GetGroupsForChannel_args :: GetGroupsForChannel_args
default_GetGroupsForChannel_args = GetGroupsForChannel_args{
  getGroupsForChannel_args_groupIds = Vector.empty}
data GetGroupsForChannel_result = GetGroupsForChannel_result  { getGroupsForChannel_result_success :: (Vector.Vector Group)
  , getGroupsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetGroupsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getGroupsForChannel_result_success record   `H.hashWithSalt` getGroupsForChannel_result_e record  
instance QC.Arbitrary GetGroupsForChannel_result where 
  arbitrary = M.liftM GetGroupsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetGroupsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_success = getGroupsForChannel_result_success obj}
    , if obj == default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetGroupsForChannel_result{getGroupsForChannel_result_e = getGroupsForChannel_result_e obj}
    ]
from_GetGroupsForChannel_result :: GetGroupsForChannel_result -> T.ThriftVal
from_GetGroupsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4854 -> (1, ("e",from_TalkException _v4854))) <$> getGroupsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4854 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_Group) $ P.map (\_v4856 -> from_Group _v4856) $ Vector.toList _v4854))) $ getGroupsForChannel_result_success record
    , (\_v4854 -> (1, ("e",from_TalkException _v4854))) <$> getGroupsForChannel_result_e record
    ]
    )
write_GetGroupsForChannel_result :: T.Protocol p => p -> GetGroupsForChannel_result -> P.IO ()
write_GetGroupsForChannel_result oprot record = T.writeVal oprot $ from_GetGroupsForChannel_result record
encode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> GetGroupsForChannel_result -> LBS.ByteString
encode_GetGroupsForChannel_result oprot record = T.serializeVal oprot $ from_GetGroupsForChannel_result record
to_GetGroupsForChannel_result :: T.ThriftVal -> GetGroupsForChannel_result
to_GetGroupsForChannel_result (T.TStruct fields) = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = P.maybe (getGroupsForChannel_result_success default_GetGroupsForChannel_result) (\(_,_val4858) -> (case _val4858 of {T.TList _ _val4859 -> (Vector.fromList $ P.map (\_v4860 -> (case _v4860 of {T.TStruct _val4861 -> (to_Group (T.TStruct _val4861)); _ -> P.error "wrong type"})) _val4859); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getGroupsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4858) -> P.Just (case _val4858 of {T.TStruct _val4862 -> (to_TalkException (T.TStruct _val4862)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetGroupsForChannel_result _ = P.error "not a struct"
read_GetGroupsForChannel_result :: T.Protocol p => p -> P.IO GetGroupsForChannel_result
read_GetGroupsForChannel_result iprot = to_GetGroupsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result)
decode_GetGroupsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetGroupsForChannel_result
decode_GetGroupsForChannel_result iprot bs = to_GetGroupsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetGroupsForChannel_result) bs
typemap_GetGroupsForChannel_result :: T.TypeMap
typemap_GetGroupsForChannel_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_Group)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetGroupsForChannel_result :: GetGroupsForChannel_result
default_GetGroupsForChannel_result = GetGroupsForChannel_result{
  getGroupsForChannel_result_success = Vector.empty,
  getGroupsForChannel_result_e = P.Nothing}
data GetIdentityCredential_args = GetIdentityCredential_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetIdentityCredential_args where 
  arbitrary = QC.elements [GetIdentityCredential_args]
from_GetIdentityCredential_args :: GetIdentityCredential_args -> T.ThriftVal
from_GetIdentityCredential_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetIdentityCredential_args :: T.Protocol p => p -> GetIdentityCredential_args -> P.IO ()
write_GetIdentityCredential_args oprot record = T.writeVal oprot $ from_GetIdentityCredential_args record
encode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> GetIdentityCredential_args -> LBS.ByteString
encode_GetIdentityCredential_args oprot record = T.serializeVal oprot $ from_GetIdentityCredential_args record
to_GetIdentityCredential_args :: T.ThriftVal -> GetIdentityCredential_args
to_GetIdentityCredential_args (T.TStruct fields) = GetIdentityCredential_args{

  }
to_GetIdentityCredential_args _ = P.error "not a struct"
read_GetIdentityCredential_args :: T.Protocol p => p -> P.IO GetIdentityCredential_args
read_GetIdentityCredential_args iprot = to_GetIdentityCredential_args <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args)
decode_GetIdentityCredential_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_args
decode_GetIdentityCredential_args iprot bs = to_GetIdentityCredential_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_args) bs
typemap_GetIdentityCredential_args :: T.TypeMap
typemap_GetIdentityCredential_args = Map.fromList []
default_GetIdentityCredential_args :: GetIdentityCredential_args
default_GetIdentityCredential_args = GetIdentityCredential_args{
}
data GetIdentityCredential_result = GetIdentityCredential_result  { getIdentityCredential_result_success :: IdentityCredential
  , getIdentityCredential_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetIdentityCredential_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getIdentityCredential_result_success record   `H.hashWithSalt` getIdentityCredential_result_e record  
instance QC.Arbitrary GetIdentityCredential_result where 
  arbitrary = M.liftM GetIdentityCredential_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetIdentityCredential_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_success = getIdentityCredential_result_success obj}
    , if obj == default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj} then P.Nothing else P.Just $ default_GetIdentityCredential_result{getIdentityCredential_result_e = getIdentityCredential_result_e obj}
    ]
from_GetIdentityCredential_result :: GetIdentityCredential_result -> T.ThriftVal
from_GetIdentityCredential_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4870 -> (1, ("e",from_TalkException _v4870))) <$> getIdentityCredential_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4870 -> P.Just (0, ("success",from_IdentityCredential _v4870))) $ getIdentityCredential_result_success record
    , (\_v4870 -> (1, ("e",from_TalkException _v4870))) <$> getIdentityCredential_result_e record
    ]
    )
write_GetIdentityCredential_result :: T.Protocol p => p -> GetIdentityCredential_result -> P.IO ()
write_GetIdentityCredential_result oprot record = T.writeVal oprot $ from_GetIdentityCredential_result record
encode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> GetIdentityCredential_result -> LBS.ByteString
encode_GetIdentityCredential_result oprot record = T.serializeVal oprot $ from_GetIdentityCredential_result record
to_GetIdentityCredential_result :: T.ThriftVal -> GetIdentityCredential_result
to_GetIdentityCredential_result (T.TStruct fields) = GetIdentityCredential_result{
  getIdentityCredential_result_success = P.maybe (getIdentityCredential_result_success default_GetIdentityCredential_result) (\(_,_val4872) -> (case _val4872 of {T.TStruct _val4873 -> (to_IdentityCredential (T.TStruct _val4873)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getIdentityCredential_result_e = P.maybe (P.Nothing) (\(_,_val4872) -> P.Just (case _val4872 of {T.TStruct _val4874 -> (to_TalkException (T.TStruct _val4874)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetIdentityCredential_result _ = P.error "not a struct"
read_GetIdentityCredential_result :: T.Protocol p => p -> P.IO GetIdentityCredential_result
read_GetIdentityCredential_result iprot = to_GetIdentityCredential_result <$> T.readVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result)
decode_GetIdentityCredential_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetIdentityCredential_result
decode_GetIdentityCredential_result iprot bs = to_GetIdentityCredential_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetIdentityCredential_result) bs
typemap_GetIdentityCredential_result :: T.TypeMap
typemap_GetIdentityCredential_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_IdentityCredential))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetIdentityCredential_result :: GetIdentityCredential_result
default_GetIdentityCredential_result = GetIdentityCredential_result{
  getIdentityCredential_result_success = default_IdentityCredential,
  getIdentityCredential_result_e = P.Nothing}
data GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_args where 
  arbitrary = QC.elements [GetJoinedGroupIdsForChannel_args]
from_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_args -> P.IO ()
write_GetJoinedGroupIdsForChannel_args oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
encode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_args -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_args oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_args record
to_GetJoinedGroupIdsForChannel_args :: T.ThriftVal -> GetJoinedGroupIdsForChannel_args
to_GetJoinedGroupIdsForChannel_args (T.TStruct fields) = GetJoinedGroupIdsForChannel_args{

  }
to_GetJoinedGroupIdsForChannel_args _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_args :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_args
read_GetJoinedGroupIdsForChannel_args iprot = to_GetJoinedGroupIdsForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args)
decode_GetJoinedGroupIdsForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_args
decode_GetJoinedGroupIdsForChannel_args iprot bs = to_GetJoinedGroupIdsForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_args) bs
typemap_GetJoinedGroupIdsForChannel_args :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_args = Map.fromList []
default_GetJoinedGroupIdsForChannel_args :: GetJoinedGroupIdsForChannel_args
default_GetJoinedGroupIdsForChannel_args = GetJoinedGroupIdsForChannel_args{
}
data GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result  { getJoinedGroupIdsForChannel_result_success :: (Vector.Vector LT.Text)
  , getJoinedGroupIdsForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetJoinedGroupIdsForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_success record   `H.hashWithSalt` getJoinedGroupIdsForChannel_result_e record  
instance QC.Arbitrary GetJoinedGroupIdsForChannel_result where 
  arbitrary = M.liftM GetJoinedGroupIdsForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetJoinedGroupIdsForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = getJoinedGroupIdsForChannel_result_success obj}
    , if obj == default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj} then P.Nothing else P.Just $ default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = getJoinedGroupIdsForChannel_result_e obj}
    ]
from_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result -> T.ThriftVal
from_GetJoinedGroupIdsForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4882 -> (1, ("e",from_TalkException _v4882))) <$> getJoinedGroupIdsForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4882 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v4884 -> T.TString $ E.encodeUtf8 _v4884) $ Vector.toList _v4882))) $ getJoinedGroupIdsForChannel_result_success record
    , (\_v4882 -> (1, ("e",from_TalkException _v4882))) <$> getJoinedGroupIdsForChannel_result_e record
    ]
    )
write_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> GetJoinedGroupIdsForChannel_result -> P.IO ()
write_GetJoinedGroupIdsForChannel_result oprot record = T.writeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
encode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> GetJoinedGroupIdsForChannel_result -> LBS.ByteString
encode_GetJoinedGroupIdsForChannel_result oprot record = T.serializeVal oprot $ from_GetJoinedGroupIdsForChannel_result record
to_GetJoinedGroupIdsForChannel_result :: T.ThriftVal -> GetJoinedGroupIdsForChannel_result
to_GetJoinedGroupIdsForChannel_result (T.TStruct fields) = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = P.maybe (getJoinedGroupIdsForChannel_result_success default_GetJoinedGroupIdsForChannel_result) (\(_,_val4886) -> (case _val4886 of {T.TList _ _val4887 -> (Vector.fromList $ P.map (\_v4888 -> (case _v4888 of {T.TString _val4889 -> E.decodeUtf8 _val4889; _ -> P.error "wrong type"})) _val4887); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getJoinedGroupIdsForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4886) -> P.Just (case _val4886 of {T.TStruct _val4890 -> (to_TalkException (T.TStruct _val4890)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetJoinedGroupIdsForChannel_result _ = P.error "not a struct"
read_GetJoinedGroupIdsForChannel_result :: T.Protocol p => p -> P.IO GetJoinedGroupIdsForChannel_result
read_GetJoinedGroupIdsForChannel_result iprot = to_GetJoinedGroupIdsForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result)
decode_GetJoinedGroupIdsForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetJoinedGroupIdsForChannel_result
decode_GetJoinedGroupIdsForChannel_result iprot bs = to_GetJoinedGroupIdsForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetJoinedGroupIdsForChannel_result) bs
typemap_GetJoinedGroupIdsForChannel_result :: T.TypeMap
typemap_GetJoinedGroupIdsForChannel_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetJoinedGroupIdsForChannel_result :: GetJoinedGroupIdsForChannel_result
default_GetJoinedGroupIdsForChannel_result = GetJoinedGroupIdsForChannel_result{
  getJoinedGroupIdsForChannel_result_success = Vector.empty,
  getJoinedGroupIdsForChannel_result_e = P.Nothing}
data GetMetaProfile_args = GetMetaProfile_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMetaProfile_args where 
  arbitrary = QC.elements [GetMetaProfile_args]
from_GetMetaProfile_args :: GetMetaProfile_args -> T.ThriftVal
from_GetMetaProfile_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMetaProfile_args :: T.Protocol p => p -> GetMetaProfile_args -> P.IO ()
write_GetMetaProfile_args oprot record = T.writeVal oprot $ from_GetMetaProfile_args record
encode_GetMetaProfile_args :: T.StatelessProtocol p => p -> GetMetaProfile_args -> LBS.ByteString
encode_GetMetaProfile_args oprot record = T.serializeVal oprot $ from_GetMetaProfile_args record
to_GetMetaProfile_args :: T.ThriftVal -> GetMetaProfile_args
to_GetMetaProfile_args (T.TStruct fields) = GetMetaProfile_args{

  }
to_GetMetaProfile_args _ = P.error "not a struct"
read_GetMetaProfile_args :: T.Protocol p => p -> P.IO GetMetaProfile_args
read_GetMetaProfile_args iprot = to_GetMetaProfile_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_args)
decode_GetMetaProfile_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_args
decode_GetMetaProfile_args iprot bs = to_GetMetaProfile_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_args) bs
typemap_GetMetaProfile_args :: T.TypeMap
typemap_GetMetaProfile_args = Map.fromList []
default_GetMetaProfile_args :: GetMetaProfile_args
default_GetMetaProfile_args = GetMetaProfile_args{
}
data GetMetaProfile_result = GetMetaProfile_result  { getMetaProfile_result_success :: MetaProfile
  , getMetaProfile_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMetaProfile_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMetaProfile_result_success record   `H.hashWithSalt` getMetaProfile_result_e record  
instance QC.Arbitrary GetMetaProfile_result where 
  arbitrary = M.liftM GetMetaProfile_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMetaProfile_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_success = getMetaProfile_result_success obj}
    , if obj == default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj} then P.Nothing else P.Just $ default_GetMetaProfile_result{getMetaProfile_result_e = getMetaProfile_result_e obj}
    ]
from_GetMetaProfile_result :: GetMetaProfile_result -> T.ThriftVal
from_GetMetaProfile_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4898 -> (1, ("e",from_TalkException _v4898))) <$> getMetaProfile_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4898 -> P.Just (0, ("success",from_MetaProfile _v4898))) $ getMetaProfile_result_success record
    , (\_v4898 -> (1, ("e",from_TalkException _v4898))) <$> getMetaProfile_result_e record
    ]
    )
write_GetMetaProfile_result :: T.Protocol p => p -> GetMetaProfile_result -> P.IO ()
write_GetMetaProfile_result oprot record = T.writeVal oprot $ from_GetMetaProfile_result record
encode_GetMetaProfile_result :: T.StatelessProtocol p => p -> GetMetaProfile_result -> LBS.ByteString
encode_GetMetaProfile_result oprot record = T.serializeVal oprot $ from_GetMetaProfile_result record
to_GetMetaProfile_result :: T.ThriftVal -> GetMetaProfile_result
to_GetMetaProfile_result (T.TStruct fields) = GetMetaProfile_result{
  getMetaProfile_result_success = P.maybe (getMetaProfile_result_success default_GetMetaProfile_result) (\(_,_val4900) -> (case _val4900 of {T.TStruct _val4901 -> (to_MetaProfile (T.TStruct _val4901)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMetaProfile_result_e = P.maybe (P.Nothing) (\(_,_val4900) -> P.Just (case _val4900 of {T.TStruct _val4902 -> (to_TalkException (T.TStruct _val4902)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMetaProfile_result _ = P.error "not a struct"
read_GetMetaProfile_result :: T.Protocol p => p -> P.IO GetMetaProfile_result
read_GetMetaProfile_result iprot = to_GetMetaProfile_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMetaProfile_result)
decode_GetMetaProfile_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMetaProfile_result
decode_GetMetaProfile_result iprot bs = to_GetMetaProfile_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMetaProfile_result) bs
typemap_GetMetaProfile_result :: T.TypeMap
typemap_GetMetaProfile_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_MetaProfile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMetaProfile_result :: GetMetaProfile_result
default_GetMetaProfile_result = GetMetaProfile_result{
  getMetaProfile_result_success = default_MetaProfile,
  getMetaProfile_result_e = P.Nothing}
data GetMid_args = GetMid_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetMid_args where 
  arbitrary = QC.elements [GetMid_args]
from_GetMid_args :: GetMid_args -> T.ThriftVal
from_GetMid_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetMid_args :: T.Protocol p => p -> GetMid_args -> P.IO ()
write_GetMid_args oprot record = T.writeVal oprot $ from_GetMid_args record
encode_GetMid_args :: T.StatelessProtocol p => p -> GetMid_args -> LBS.ByteString
encode_GetMid_args oprot record = T.serializeVal oprot $ from_GetMid_args record
to_GetMid_args :: T.ThriftVal -> GetMid_args
to_GetMid_args (T.TStruct fields) = GetMid_args{

  }
to_GetMid_args _ = P.error "not a struct"
read_GetMid_args :: T.Protocol p => p -> P.IO GetMid_args
read_GetMid_args iprot = to_GetMid_args <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_args)
decode_GetMid_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_args
decode_GetMid_args iprot bs = to_GetMid_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_args) bs
typemap_GetMid_args :: T.TypeMap
typemap_GetMid_args = Map.fromList []
default_GetMid_args :: GetMid_args
default_GetMid_args = GetMid_args{
}
data GetMid_result = GetMid_result  { getMid_result_success :: LT.Text
  , getMid_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetMid_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getMid_result_success record   `H.hashWithSalt` getMid_result_e record  
instance QC.Arbitrary GetMid_result where 
  arbitrary = M.liftM GetMid_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetMid_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetMid_result{getMid_result_success = getMid_result_success obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_success = getMid_result_success obj}
    , if obj == default_GetMid_result{getMid_result_e = getMid_result_e obj} then P.Nothing else P.Just $ default_GetMid_result{getMid_result_e = getMid_result_e obj}
    ]
from_GetMid_result :: GetMid_result -> T.ThriftVal
from_GetMid_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4910 -> (1, ("e",from_TalkException _v4910))) <$> getMid_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4910 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4910))) $ getMid_result_success record
    , (\_v4910 -> (1, ("e",from_TalkException _v4910))) <$> getMid_result_e record
    ]
    )
write_GetMid_result :: T.Protocol p => p -> GetMid_result -> P.IO ()
write_GetMid_result oprot record = T.writeVal oprot $ from_GetMid_result record
encode_GetMid_result :: T.StatelessProtocol p => p -> GetMid_result -> LBS.ByteString
encode_GetMid_result oprot record = T.serializeVal oprot $ from_GetMid_result record
to_GetMid_result :: T.ThriftVal -> GetMid_result
to_GetMid_result (T.TStruct fields) = GetMid_result{
  getMid_result_success = P.maybe (getMid_result_success default_GetMid_result) (\(_,_val4912) -> (case _val4912 of {T.TString _val4913 -> E.decodeUtf8 _val4913; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getMid_result_e = P.maybe (P.Nothing) (\(_,_val4912) -> P.Just (case _val4912 of {T.TStruct _val4914 -> (to_TalkException (T.TStruct _val4914)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetMid_result _ = P.error "not a struct"
read_GetMid_result :: T.Protocol p => p -> P.IO GetMid_result
read_GetMid_result iprot = to_GetMid_result <$> T.readVal iprot (T.T_STRUCT typemap_GetMid_result)
decode_GetMid_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetMid_result
decode_GetMid_result iprot bs = to_GetMid_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetMid_result) bs
typemap_GetMid_result :: T.TypeMap
typemap_GetMid_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetMid_result :: GetMid_result
default_GetMid_result = GetMid_result{
  getMid_result_success = "",
  getMid_result_e = P.Nothing}
data GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetPrimaryClientForChannel_args where 
  arbitrary = QC.elements [GetPrimaryClientForChannel_args]
from_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args -> T.ThriftVal
from_GetPrimaryClientForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetPrimaryClientForChannel_args :: T.Protocol p => p -> GetPrimaryClientForChannel_args -> P.IO ()
write_GetPrimaryClientForChannel_args oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_args record
encode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_args -> LBS.ByteString
encode_GetPrimaryClientForChannel_args oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_args record
to_GetPrimaryClientForChannel_args :: T.ThriftVal -> GetPrimaryClientForChannel_args
to_GetPrimaryClientForChannel_args (T.TStruct fields) = GetPrimaryClientForChannel_args{

  }
to_GetPrimaryClientForChannel_args _ = P.error "not a struct"
read_GetPrimaryClientForChannel_args :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_args
read_GetPrimaryClientForChannel_args iprot = to_GetPrimaryClientForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args)
decode_GetPrimaryClientForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_args
decode_GetPrimaryClientForChannel_args iprot bs = to_GetPrimaryClientForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_args) bs
typemap_GetPrimaryClientForChannel_args :: T.TypeMap
typemap_GetPrimaryClientForChannel_args = Map.fromList []
default_GetPrimaryClientForChannel_args :: GetPrimaryClientForChannel_args
default_GetPrimaryClientForChannel_args = GetPrimaryClientForChannel_args{
}
data GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result  { getPrimaryClientForChannel_result_success :: SimpleChannelClient
  , getPrimaryClientForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPrimaryClientForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPrimaryClientForChannel_result_success record   `H.hashWithSalt` getPrimaryClientForChannel_result_e record  
instance QC.Arbitrary GetPrimaryClientForChannel_result where 
  arbitrary = M.liftM GetPrimaryClientForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPrimaryClientForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = getPrimaryClientForChannel_result_success obj}
    , if obj == default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj} then P.Nothing else P.Just $ default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = getPrimaryClientForChannel_result_e obj}
    ]
from_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result -> T.ThriftVal
from_GetPrimaryClientForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4922 -> (1, ("e",from_TalkException _v4922))) <$> getPrimaryClientForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4922 -> P.Just (0, ("success",from_SimpleChannelClient _v4922))) $ getPrimaryClientForChannel_result_success record
    , (\_v4922 -> (1, ("e",from_TalkException _v4922))) <$> getPrimaryClientForChannel_result_e record
    ]
    )
write_GetPrimaryClientForChannel_result :: T.Protocol p => p -> GetPrimaryClientForChannel_result -> P.IO ()
write_GetPrimaryClientForChannel_result oprot record = T.writeVal oprot $ from_GetPrimaryClientForChannel_result record
encode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> GetPrimaryClientForChannel_result -> LBS.ByteString
encode_GetPrimaryClientForChannel_result oprot record = T.serializeVal oprot $ from_GetPrimaryClientForChannel_result record
to_GetPrimaryClientForChannel_result :: T.ThriftVal -> GetPrimaryClientForChannel_result
to_GetPrimaryClientForChannel_result (T.TStruct fields) = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = P.maybe (getPrimaryClientForChannel_result_success default_GetPrimaryClientForChannel_result) (\(_,_val4924) -> (case _val4924 of {T.TStruct _val4925 -> (to_SimpleChannelClient (T.TStruct _val4925)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPrimaryClientForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4924) -> P.Just (case _val4924 of {T.TStruct _val4926 -> (to_TalkException (T.TStruct _val4926)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPrimaryClientForChannel_result _ = P.error "not a struct"
read_GetPrimaryClientForChannel_result :: T.Protocol p => p -> P.IO GetPrimaryClientForChannel_result
read_GetPrimaryClientForChannel_result iprot = to_GetPrimaryClientForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result)
decode_GetPrimaryClientForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPrimaryClientForChannel_result
decode_GetPrimaryClientForChannel_result iprot bs = to_GetPrimaryClientForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPrimaryClientForChannel_result) bs
typemap_GetPrimaryClientForChannel_result :: T.TypeMap
typemap_GetPrimaryClientForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SimpleChannelClient))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetPrimaryClientForChannel_result :: GetPrimaryClientForChannel_result
default_GetPrimaryClientForChannel_result = GetPrimaryClientForChannel_result{
  getPrimaryClientForChannel_result_success = default_SimpleChannelClient,
  getPrimaryClientForChannel_result_e = P.Nothing}
data GetProfileForChannel_args = GetProfileForChannel_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetProfileForChannel_args where 
  arbitrary = QC.elements [GetProfileForChannel_args]
from_GetProfileForChannel_args :: GetProfileForChannel_args -> T.ThriftVal
from_GetProfileForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetProfileForChannel_args :: T.Protocol p => p -> GetProfileForChannel_args -> P.IO ()
write_GetProfileForChannel_args oprot record = T.writeVal oprot $ from_GetProfileForChannel_args record
encode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> GetProfileForChannel_args -> LBS.ByteString
encode_GetProfileForChannel_args oprot record = T.serializeVal oprot $ from_GetProfileForChannel_args record
to_GetProfileForChannel_args :: T.ThriftVal -> GetProfileForChannel_args
to_GetProfileForChannel_args (T.TStruct fields) = GetProfileForChannel_args{

  }
to_GetProfileForChannel_args _ = P.error "not a struct"
read_GetProfileForChannel_args :: T.Protocol p => p -> P.IO GetProfileForChannel_args
read_GetProfileForChannel_args iprot = to_GetProfileForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args)
decode_GetProfileForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_args
decode_GetProfileForChannel_args iprot bs = to_GetProfileForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_args) bs
typemap_GetProfileForChannel_args :: T.TypeMap
typemap_GetProfileForChannel_args = Map.fromList []
default_GetProfileForChannel_args :: GetProfileForChannel_args
default_GetProfileForChannel_args = GetProfileForChannel_args{
}
data GetProfileForChannel_result = GetProfileForChannel_result  { getProfileForChannel_result_success :: Profile
  , getProfileForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetProfileForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getProfileForChannel_result_success record   `H.hashWithSalt` getProfileForChannel_result_e record  
instance QC.Arbitrary GetProfileForChannel_result where 
  arbitrary = M.liftM GetProfileForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetProfileForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_success = getProfileForChannel_result_success obj}
    , if obj == default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj} then P.Nothing else P.Just $ default_GetProfileForChannel_result{getProfileForChannel_result_e = getProfileForChannel_result_e obj}
    ]
from_GetProfileForChannel_result :: GetProfileForChannel_result -> T.ThriftVal
from_GetProfileForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4934 -> (1, ("e",from_TalkException _v4934))) <$> getProfileForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4934 -> P.Just (0, ("success",from_Profile _v4934))) $ getProfileForChannel_result_success record
    , (\_v4934 -> (1, ("e",from_TalkException _v4934))) <$> getProfileForChannel_result_e record
    ]
    )
write_GetProfileForChannel_result :: T.Protocol p => p -> GetProfileForChannel_result -> P.IO ()
write_GetProfileForChannel_result oprot record = T.writeVal oprot $ from_GetProfileForChannel_result record
encode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> GetProfileForChannel_result -> LBS.ByteString
encode_GetProfileForChannel_result oprot record = T.serializeVal oprot $ from_GetProfileForChannel_result record
to_GetProfileForChannel_result :: T.ThriftVal -> GetProfileForChannel_result
to_GetProfileForChannel_result (T.TStruct fields) = GetProfileForChannel_result{
  getProfileForChannel_result_success = P.maybe (getProfileForChannel_result_success default_GetProfileForChannel_result) (\(_,_val4936) -> (case _val4936 of {T.TStruct _val4937 -> (to_Profile (T.TStruct _val4937)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getProfileForChannel_result_e = P.maybe (P.Nothing) (\(_,_val4936) -> P.Just (case _val4936 of {T.TStruct _val4938 -> (to_TalkException (T.TStruct _val4938)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetProfileForChannel_result _ = P.error "not a struct"
read_GetProfileForChannel_result :: T.Protocol p => p -> P.IO GetProfileForChannel_result
read_GetProfileForChannel_result iprot = to_GetProfileForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result)
decode_GetProfileForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetProfileForChannel_result
decode_GetProfileForChannel_result iprot bs = to_GetProfileForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetProfileForChannel_result) bs
typemap_GetProfileForChannel_result :: T.TypeMap
typemap_GetProfileForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Profile))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetProfileForChannel_result :: GetProfileForChannel_result
default_GetProfileForChannel_result = GetProfileForChannel_result{
  getProfileForChannel_result_success = default_Profile,
  getProfileForChannel_result_e = P.Nothing}
data GetSimpleChannelContacts_args = GetSimpleChannelContacts_args  { getSimpleChannelContacts_args_ids :: (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_args_ids record  
instance QC.Arbitrary GetSimpleChannelContacts_args where 
  arbitrary = M.liftM GetSimpleChannelContacts_args (QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_args{getSimpleChannelContacts_args_ids = getSimpleChannelContacts_args_ids obj}
    ]
from_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args -> T.ThriftVal
from_GetSimpleChannelContacts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4941 -> P.Just (1, ("ids",T.TList T.T_STRING $ P.map (\_v4943 -> T.TString $ E.encodeUtf8 _v4943) $ Vector.toList _v4941))) $ getSimpleChannelContacts_args_ids record
  ]
write_GetSimpleChannelContacts_args :: T.Protocol p => p -> GetSimpleChannelContacts_args -> P.IO ()
write_GetSimpleChannelContacts_args oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_args record
encode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_args -> LBS.ByteString
encode_GetSimpleChannelContacts_args oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_args record
to_GetSimpleChannelContacts_args :: T.ThriftVal -> GetSimpleChannelContacts_args
to_GetSimpleChannelContacts_args (T.TStruct fields) = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = P.maybe (getSimpleChannelContacts_args_ids default_GetSimpleChannelContacts_args) (\(_,_val4945) -> (case _val4945 of {T.TList _ _val4946 -> (Vector.fromList $ P.map (\_v4947 -> (case _v4947 of {T.TString _val4948 -> E.decodeUtf8 _val4948; _ -> P.error "wrong type"})) _val4946); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_args _ = P.error "not a struct"
read_GetSimpleChannelContacts_args :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_args
read_GetSimpleChannelContacts_args iprot = to_GetSimpleChannelContacts_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args)
decode_GetSimpleChannelContacts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_args
decode_GetSimpleChannelContacts_args iprot bs = to_GetSimpleChannelContacts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_args) bs
typemap_GetSimpleChannelContacts_args :: T.TypeMap
typemap_GetSimpleChannelContacts_args = Map.fromList [(1,("ids",(T.T_LIST T.T_STRING)))]
default_GetSimpleChannelContacts_args :: GetSimpleChannelContacts_args
default_GetSimpleChannelContacts_args = GetSimpleChannelContacts_args{
  getSimpleChannelContacts_args_ids = Vector.empty}
data GetSimpleChannelContacts_result = GetSimpleChannelContacts_result  { getSimpleChannelContacts_result_success :: (Vector.Vector SimpleChannelContact)
  , getSimpleChannelContacts_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSimpleChannelContacts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSimpleChannelContacts_result_success record   `H.hashWithSalt` getSimpleChannelContacts_result_e record  
instance QC.Arbitrary GetSimpleChannelContacts_result where 
  arbitrary = M.liftM GetSimpleChannelContacts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSimpleChannelContacts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = getSimpleChannelContacts_result_success obj}
    , if obj == default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj} then P.Nothing else P.Just $ default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = getSimpleChannelContacts_result_e obj}
    ]
from_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result -> T.ThriftVal
from_GetSimpleChannelContacts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4951 -> (1, ("e",from_TalkException _v4951))) <$> getSimpleChannelContacts_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4951 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_SimpleChannelContact) $ P.map (\_v4953 -> from_SimpleChannelContact _v4953) $ Vector.toList _v4951))) $ getSimpleChannelContacts_result_success record
    , (\_v4951 -> (1, ("e",from_TalkException _v4951))) <$> getSimpleChannelContacts_result_e record
    ]
    )
write_GetSimpleChannelContacts_result :: T.Protocol p => p -> GetSimpleChannelContacts_result -> P.IO ()
write_GetSimpleChannelContacts_result oprot record = T.writeVal oprot $ from_GetSimpleChannelContacts_result record
encode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> GetSimpleChannelContacts_result -> LBS.ByteString
encode_GetSimpleChannelContacts_result oprot record = T.serializeVal oprot $ from_GetSimpleChannelContacts_result record
to_GetSimpleChannelContacts_result :: T.ThriftVal -> GetSimpleChannelContacts_result
to_GetSimpleChannelContacts_result (T.TStruct fields) = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = P.maybe (getSimpleChannelContacts_result_success default_GetSimpleChannelContacts_result) (\(_,_val4955) -> (case _val4955 of {T.TList _ _val4956 -> (Vector.fromList $ P.map (\_v4957 -> (case _v4957 of {T.TStruct _val4958 -> (to_SimpleChannelContact (T.TStruct _val4958)); _ -> P.error "wrong type"})) _val4956); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSimpleChannelContacts_result_e = P.maybe (P.Nothing) (\(_,_val4955) -> P.Just (case _val4955 of {T.TStruct _val4959 -> (to_TalkException (T.TStruct _val4959)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSimpleChannelContacts_result _ = P.error "not a struct"
read_GetSimpleChannelContacts_result :: T.Protocol p => p -> P.IO GetSimpleChannelContacts_result
read_GetSimpleChannelContacts_result iprot = to_GetSimpleChannelContacts_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result)
decode_GetSimpleChannelContacts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSimpleChannelContacts_result
decode_GetSimpleChannelContacts_result iprot bs = to_GetSimpleChannelContacts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSimpleChannelContacts_result) bs
typemap_GetSimpleChannelContacts_result :: T.TypeMap
typemap_GetSimpleChannelContacts_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_SimpleChannelContact)))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetSimpleChannelContacts_result :: GetSimpleChannelContacts_result
default_GetSimpleChannelContacts_result = GetSimpleChannelContacts_result{
  getSimpleChannelContacts_result_success = Vector.empty,
  getSimpleChannelContacts_result_e = P.Nothing}
data GetUserCountryForBilling_args = GetUserCountryForBilling_args  { getUserCountryForBilling_args_country :: LT.Text
  , getUserCountryForBilling_args_remoteIp :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_args_country record   `H.hashWithSalt` getUserCountryForBilling_args_remoteIp record  
instance QC.Arbitrary GetUserCountryForBilling_args where 
  arbitrary = M.liftM GetUserCountryForBilling_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_country = getUserCountryForBilling_args_country obj}
    , if obj == default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_args{getUserCountryForBilling_args_remoteIp = getUserCountryForBilling_args_remoteIp obj}
    ]
from_GetUserCountryForBilling_args :: GetUserCountryForBilling_args -> T.ThriftVal
from_GetUserCountryForBilling_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v4962 -> P.Just (2, ("country",T.TString $ E.encodeUtf8 _v4962))) $ getUserCountryForBilling_args_country record
  , (\_v4962 -> P.Just (3, ("remoteIp",T.TString $ E.encodeUtf8 _v4962))) $ getUserCountryForBilling_args_remoteIp record
  ]
write_GetUserCountryForBilling_args :: T.Protocol p => p -> GetUserCountryForBilling_args -> P.IO ()
write_GetUserCountryForBilling_args oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_args record
encode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> GetUserCountryForBilling_args -> LBS.ByteString
encode_GetUserCountryForBilling_args oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_args record
to_GetUserCountryForBilling_args :: T.ThriftVal -> GetUserCountryForBilling_args
to_GetUserCountryForBilling_args (T.TStruct fields) = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = P.maybe (getUserCountryForBilling_args_country default_GetUserCountryForBilling_args) (\(_,_val4964) -> (case _val4964 of {T.TString _val4965 -> E.decodeUtf8 _val4965; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getUserCountryForBilling_args_remoteIp = P.maybe (getUserCountryForBilling_args_remoteIp default_GetUserCountryForBilling_args) (\(_,_val4964) -> (case _val4964 of {T.TString _val4966 -> E.decodeUtf8 _val4966; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetUserCountryForBilling_args _ = P.error "not a struct"
read_GetUserCountryForBilling_args :: T.Protocol p => p -> P.IO GetUserCountryForBilling_args
read_GetUserCountryForBilling_args iprot = to_GetUserCountryForBilling_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args)
decode_GetUserCountryForBilling_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_args
decode_GetUserCountryForBilling_args iprot bs = to_GetUserCountryForBilling_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_args) bs
typemap_GetUserCountryForBilling_args :: T.TypeMap
typemap_GetUserCountryForBilling_args = Map.fromList [(2,("country",T.T_STRING)),(3,("remoteIp",T.T_STRING))]
default_GetUserCountryForBilling_args :: GetUserCountryForBilling_args
default_GetUserCountryForBilling_args = GetUserCountryForBilling_args{
  getUserCountryForBilling_args_country = "",
  getUserCountryForBilling_args_remoteIp = ""}
data GetUserCountryForBilling_result = GetUserCountryForBilling_result  { getUserCountryForBilling_result_success :: LT.Text
  , getUserCountryForBilling_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCountryForBilling_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCountryForBilling_result_success record   `H.hashWithSalt` getUserCountryForBilling_result_e record  
instance QC.Arbitrary GetUserCountryForBilling_result where 
  arbitrary = M.liftM GetUserCountryForBilling_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCountryForBilling_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = getUserCountryForBilling_result_success obj}
    , if obj == default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj} then P.Nothing else P.Just $ default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = getUserCountryForBilling_result_e obj}
    ]
from_GetUserCountryForBilling_result :: GetUserCountryForBilling_result -> T.ThriftVal
from_GetUserCountryForBilling_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4969 -> (1, ("e",from_TalkException _v4969))) <$> getUserCountryForBilling_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4969 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v4969))) $ getUserCountryForBilling_result_success record
    , (\_v4969 -> (1, ("e",from_TalkException _v4969))) <$> getUserCountryForBilling_result_e record
    ]
    )
write_GetUserCountryForBilling_result :: T.Protocol p => p -> GetUserCountryForBilling_result -> P.IO ()
write_GetUserCountryForBilling_result oprot record = T.writeVal oprot $ from_GetUserCountryForBilling_result record
encode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> GetUserCountryForBilling_result -> LBS.ByteString
encode_GetUserCountryForBilling_result oprot record = T.serializeVal oprot $ from_GetUserCountryForBilling_result record
to_GetUserCountryForBilling_result :: T.ThriftVal -> GetUserCountryForBilling_result
to_GetUserCountryForBilling_result (T.TStruct fields) = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = P.maybe (getUserCountryForBilling_result_success default_GetUserCountryForBilling_result) (\(_,_val4971) -> (case _val4971 of {T.TString _val4972 -> E.decodeUtf8 _val4972; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCountryForBilling_result_e = P.maybe (P.Nothing) (\(_,_val4971) -> P.Just (case _val4971 of {T.TStruct _val4973 -> (to_TalkException (T.TStruct _val4973)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCountryForBilling_result _ = P.error "not a struct"
read_GetUserCountryForBilling_result :: T.Protocol p => p -> P.IO GetUserCountryForBilling_result
read_GetUserCountryForBilling_result iprot = to_GetUserCountryForBilling_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result)
decode_GetUserCountryForBilling_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCountryForBilling_result
decode_GetUserCountryForBilling_result iprot bs = to_GetUserCountryForBilling_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCountryForBilling_result) bs
typemap_GetUserCountryForBilling_result :: T.TypeMap
typemap_GetUserCountryForBilling_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCountryForBilling_result :: GetUserCountryForBilling_result
default_GetUserCountryForBilling_result = GetUserCountryForBilling_result{
  getUserCountryForBilling_result_success = "",
  getUserCountryForBilling_result_e = P.Nothing}
data GetUserCreateTime_args = GetUserCreateTime_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserCreateTime_args where 
  arbitrary = QC.elements [GetUserCreateTime_args]
from_GetUserCreateTime_args :: GetUserCreateTime_args -> T.ThriftVal
from_GetUserCreateTime_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserCreateTime_args :: T.Protocol p => p -> GetUserCreateTime_args -> P.IO ()
write_GetUserCreateTime_args oprot record = T.writeVal oprot $ from_GetUserCreateTime_args record
encode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> GetUserCreateTime_args -> LBS.ByteString
encode_GetUserCreateTime_args oprot record = T.serializeVal oprot $ from_GetUserCreateTime_args record
to_GetUserCreateTime_args :: T.ThriftVal -> GetUserCreateTime_args
to_GetUserCreateTime_args (T.TStruct fields) = GetUserCreateTime_args{

  }
to_GetUserCreateTime_args _ = P.error "not a struct"
read_GetUserCreateTime_args :: T.Protocol p => p -> P.IO GetUserCreateTime_args
read_GetUserCreateTime_args iprot = to_GetUserCreateTime_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args)
decode_GetUserCreateTime_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_args
decode_GetUserCreateTime_args iprot bs = to_GetUserCreateTime_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_args) bs
typemap_GetUserCreateTime_args :: T.TypeMap
typemap_GetUserCreateTime_args = Map.fromList []
default_GetUserCreateTime_args :: GetUserCreateTime_args
default_GetUserCreateTime_args = GetUserCreateTime_args{
}
data GetUserCreateTime_result = GetUserCreateTime_result  { getUserCreateTime_result_success :: I.Int64
  , getUserCreateTime_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserCreateTime_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserCreateTime_result_success record   `H.hashWithSalt` getUserCreateTime_result_e record  
instance QC.Arbitrary GetUserCreateTime_result where 
  arbitrary = M.liftM GetUserCreateTime_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserCreateTime_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_success = getUserCreateTime_result_success obj}
    , if obj == default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj} then P.Nothing else P.Just $ default_GetUserCreateTime_result{getUserCreateTime_result_e = getUserCreateTime_result_e obj}
    ]
from_GetUserCreateTime_result :: GetUserCreateTime_result -> T.ThriftVal
from_GetUserCreateTime_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4981 -> (1, ("e",from_TalkException _v4981))) <$> getUserCreateTime_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4981 -> P.Just (0, ("success",T.TI64 _v4981))) $ getUserCreateTime_result_success record
    , (\_v4981 -> (1, ("e",from_TalkException _v4981))) <$> getUserCreateTime_result_e record
    ]
    )
write_GetUserCreateTime_result :: T.Protocol p => p -> GetUserCreateTime_result -> P.IO ()
write_GetUserCreateTime_result oprot record = T.writeVal oprot $ from_GetUserCreateTime_result record
encode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> GetUserCreateTime_result -> LBS.ByteString
encode_GetUserCreateTime_result oprot record = T.serializeVal oprot $ from_GetUserCreateTime_result record
to_GetUserCreateTime_result :: T.ThriftVal -> GetUserCreateTime_result
to_GetUserCreateTime_result (T.TStruct fields) = GetUserCreateTime_result{
  getUserCreateTime_result_success = P.maybe (getUserCreateTime_result_success default_GetUserCreateTime_result) (\(_,_val4983) -> (case _val4983 of {T.TI64 _val4984 -> _val4984; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserCreateTime_result_e = P.maybe (P.Nothing) (\(_,_val4983) -> P.Just (case _val4983 of {T.TStruct _val4985 -> (to_TalkException (T.TStruct _val4985)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserCreateTime_result _ = P.error "not a struct"
read_GetUserCreateTime_result :: T.Protocol p => p -> P.IO GetUserCreateTime_result
read_GetUserCreateTime_result iprot = to_GetUserCreateTime_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result)
decode_GetUserCreateTime_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserCreateTime_result
decode_GetUserCreateTime_result iprot bs = to_GetUserCreateTime_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserCreateTime_result) bs
typemap_GetUserCreateTime_result :: T.TypeMap
typemap_GetUserCreateTime_result = Map.fromList [(0,("success",T.T_I64)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserCreateTime_result :: GetUserCreateTime_result
default_GetUserCreateTime_result = GetUserCreateTime_result{
  getUserCreateTime_result_success = 0,
  getUserCreateTime_result_e = P.Nothing}
data GetUserIdentities_args = GetUserIdentities_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserIdentities_args where 
  arbitrary = QC.elements [GetUserIdentities_args]
from_GetUserIdentities_args :: GetUserIdentities_args -> T.ThriftVal
from_GetUserIdentities_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserIdentities_args :: T.Protocol p => p -> GetUserIdentities_args -> P.IO ()
write_GetUserIdentities_args oprot record = T.writeVal oprot $ from_GetUserIdentities_args record
encode_GetUserIdentities_args :: T.StatelessProtocol p => p -> GetUserIdentities_args -> LBS.ByteString
encode_GetUserIdentities_args oprot record = T.serializeVal oprot $ from_GetUserIdentities_args record
to_GetUserIdentities_args :: T.ThriftVal -> GetUserIdentities_args
to_GetUserIdentities_args (T.TStruct fields) = GetUserIdentities_args{

  }
to_GetUserIdentities_args _ = P.error "not a struct"
read_GetUserIdentities_args :: T.Protocol p => p -> P.IO GetUserIdentities_args
read_GetUserIdentities_args iprot = to_GetUserIdentities_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_args)
decode_GetUserIdentities_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_args
decode_GetUserIdentities_args iprot bs = to_GetUserIdentities_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_args) bs
typemap_GetUserIdentities_args :: T.TypeMap
typemap_GetUserIdentities_args = Map.fromList []
default_GetUserIdentities_args :: GetUserIdentities_args
default_GetUserIdentities_args = GetUserIdentities_args{
}
data GetUserIdentities_result = GetUserIdentities_result  { getUserIdentities_result_success :: (Map.HashMap RegistrationType LT.Text)
  , getUserIdentities_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserIdentities_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserIdentities_result_success record   `H.hashWithSalt` getUserIdentities_result_e record  
instance QC.Arbitrary GetUserIdentities_result where 
  arbitrary = M.liftM GetUserIdentities_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserIdentities_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_success = getUserIdentities_result_success obj}
    , if obj == default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj} then P.Nothing else P.Just $ default_GetUserIdentities_result{getUserIdentities_result_e = getUserIdentities_result_e obj}
    ]
from_GetUserIdentities_result :: GetUserIdentities_result -> T.ThriftVal
from_GetUserIdentities_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v4993 -> (1, ("e",from_TalkException _v4993))) <$> getUserIdentities_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v4993 -> P.Just (0, ("success",T.TMap T.T_I32 T.T_STRING $ P.map (\(_k4994,_v4995) -> (T.TI32 $ P.fromIntegral $ P.fromEnum _k4994, T.TString $ E.encodeUtf8 _v4995)) $ Map.toList _v4993))) $ getUserIdentities_result_success record
    , (\_v4993 -> (1, ("e",from_TalkException _v4993))) <$> getUserIdentities_result_e record
    ]
    )
write_GetUserIdentities_result :: T.Protocol p => p -> GetUserIdentities_result -> P.IO ()
write_GetUserIdentities_result oprot record = T.writeVal oprot $ from_GetUserIdentities_result record
encode_GetUserIdentities_result :: T.StatelessProtocol p => p -> GetUserIdentities_result -> LBS.ByteString
encode_GetUserIdentities_result oprot record = T.serializeVal oprot $ from_GetUserIdentities_result record
to_GetUserIdentities_result :: T.ThriftVal -> GetUserIdentities_result
to_GetUserIdentities_result (T.TStruct fields) = GetUserIdentities_result{
  getUserIdentities_result_success = P.maybe (getUserIdentities_result_success default_GetUserIdentities_result) (\(_,_val4997) -> (case _val4997 of {T.TMap _ _ _val4998 -> (Map.fromList $ P.map (\(_k5000,_v4999) -> ((case _k5000 of {T.TI32 _val5001 -> P.toEnum $ P.fromIntegral _val5001; _ -> P.error "wrong type"}),(case _v4999 of {T.TString _val5002 -> E.decodeUtf8 _val5002; _ -> P.error "wrong type"}))) _val4998); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserIdentities_result_e = P.maybe (P.Nothing) (\(_,_val4997) -> P.Just (case _val4997 of {T.TStruct _val5003 -> (to_TalkException (T.TStruct _val5003)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserIdentities_result _ = P.error "not a struct"
read_GetUserIdentities_result :: T.Protocol p => p -> P.IO GetUserIdentities_result
read_GetUserIdentities_result iprot = to_GetUserIdentities_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserIdentities_result)
decode_GetUserIdentities_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserIdentities_result
decode_GetUserIdentities_result iprot bs = to_GetUserIdentities_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserIdentities_result) bs
typemap_GetUserIdentities_result :: T.TypeMap
typemap_GetUserIdentities_result = Map.fromList [(0,("success",(T.T_MAP T.T_I32 T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserIdentities_result :: GetUserIdentities_result
default_GetUserIdentities_result = GetUserIdentities_result{
  getUserIdentities_result_success = Map.empty,
  getUserIdentities_result_e = P.Nothing}
data GetUserLanguage_args = GetUserLanguage_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserLanguage_args where 
  arbitrary = QC.elements [GetUserLanguage_args]
from_GetUserLanguage_args :: GetUserLanguage_args -> T.ThriftVal
from_GetUserLanguage_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserLanguage_args :: T.Protocol p => p -> GetUserLanguage_args -> P.IO ()
write_GetUserLanguage_args oprot record = T.writeVal oprot $ from_GetUserLanguage_args record
encode_GetUserLanguage_args :: T.StatelessProtocol p => p -> GetUserLanguage_args -> LBS.ByteString
encode_GetUserLanguage_args oprot record = T.serializeVal oprot $ from_GetUserLanguage_args record
to_GetUserLanguage_args :: T.ThriftVal -> GetUserLanguage_args
to_GetUserLanguage_args (T.TStruct fields) = GetUserLanguage_args{

  }
to_GetUserLanguage_args _ = P.error "not a struct"
read_GetUserLanguage_args :: T.Protocol p => p -> P.IO GetUserLanguage_args
read_GetUserLanguage_args iprot = to_GetUserLanguage_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_args)
decode_GetUserLanguage_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_args
decode_GetUserLanguage_args iprot bs = to_GetUserLanguage_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_args) bs
typemap_GetUserLanguage_args :: T.TypeMap
typemap_GetUserLanguage_args = Map.fromList []
default_GetUserLanguage_args :: GetUserLanguage_args
default_GetUserLanguage_args = GetUserLanguage_args{
}
data GetUserLanguage_result = GetUserLanguage_result  { getUserLanguage_result_success :: LT.Text
  , getUserLanguage_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserLanguage_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserLanguage_result_success record   `H.hashWithSalt` getUserLanguage_result_e record  
instance QC.Arbitrary GetUserLanguage_result where 
  arbitrary = M.liftM GetUserLanguage_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserLanguage_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_success = getUserLanguage_result_success obj}
    , if obj == default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj} then P.Nothing else P.Just $ default_GetUserLanguage_result{getUserLanguage_result_e = getUserLanguage_result_e obj}
    ]
from_GetUserLanguage_result :: GetUserLanguage_result -> T.ThriftVal
from_GetUserLanguage_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5011 -> (1, ("e",from_TalkException _v5011))) <$> getUserLanguage_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5011 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5011))) $ getUserLanguage_result_success record
    , (\_v5011 -> (1, ("e",from_TalkException _v5011))) <$> getUserLanguage_result_e record
    ]
    )
write_GetUserLanguage_result :: T.Protocol p => p -> GetUserLanguage_result -> P.IO ()
write_GetUserLanguage_result oprot record = T.writeVal oprot $ from_GetUserLanguage_result record
encode_GetUserLanguage_result :: T.StatelessProtocol p => p -> GetUserLanguage_result -> LBS.ByteString
encode_GetUserLanguage_result oprot record = T.serializeVal oprot $ from_GetUserLanguage_result record
to_GetUserLanguage_result :: T.ThriftVal -> GetUserLanguage_result
to_GetUserLanguage_result (T.TStruct fields) = GetUserLanguage_result{
  getUserLanguage_result_success = P.maybe (getUserLanguage_result_success default_GetUserLanguage_result) (\(_,_val5013) -> (case _val5013 of {T.TString _val5014 -> E.decodeUtf8 _val5014; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserLanguage_result_e = P.maybe (P.Nothing) (\(_,_val5013) -> P.Just (case _val5013 of {T.TStruct _val5015 -> (to_TalkException (T.TStruct _val5015)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserLanguage_result _ = P.error "not a struct"
read_GetUserLanguage_result :: T.Protocol p => p -> P.IO GetUserLanguage_result
read_GetUserLanguage_result iprot = to_GetUserLanguage_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserLanguage_result)
decode_GetUserLanguage_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserLanguage_result
decode_GetUserLanguage_result iprot bs = to_GetUserLanguage_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserLanguage_result) bs
typemap_GetUserLanguage_result :: T.TypeMap
typemap_GetUserLanguage_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserLanguage_result :: GetUserLanguage_result
default_GetUserLanguage_result = GetUserLanguage_result{
  getUserLanguage_result_success = "",
  getUserLanguage_result_e = P.Nothing}
data GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_args where
  hashWithSalt salt record = salt  
instance QC.Arbitrary GetUserMidsWhoAddedMe_args where 
  arbitrary = QC.elements [GetUserMidsWhoAddedMe_args]
from_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args -> T.ThriftVal
from_GetUserMidsWhoAddedMe_args record = T.TStruct $ Map.fromList $ M.catMaybes
  []
write_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> GetUserMidsWhoAddedMe_args -> P.IO ()
write_GetUserMidsWhoAddedMe_args oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_args record
encode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_args -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_args oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_args record
to_GetUserMidsWhoAddedMe_args :: T.ThriftVal -> GetUserMidsWhoAddedMe_args
to_GetUserMidsWhoAddedMe_args (T.TStruct fields) = GetUserMidsWhoAddedMe_args{

  }
to_GetUserMidsWhoAddedMe_args _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_args :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_args
read_GetUserMidsWhoAddedMe_args iprot = to_GetUserMidsWhoAddedMe_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args)
decode_GetUserMidsWhoAddedMe_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_args
decode_GetUserMidsWhoAddedMe_args iprot bs = to_GetUserMidsWhoAddedMe_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_args) bs
typemap_GetUserMidsWhoAddedMe_args :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_args = Map.fromList []
default_GetUserMidsWhoAddedMe_args :: GetUserMidsWhoAddedMe_args
default_GetUserMidsWhoAddedMe_args = GetUserMidsWhoAddedMe_args{
}
data GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result  { getUserMidsWhoAddedMe_result_success :: (Vector.Vector LT.Text)
  , getUserMidsWhoAddedMe_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserMidsWhoAddedMe_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserMidsWhoAddedMe_result_success record   `H.hashWithSalt` getUserMidsWhoAddedMe_result_e record  
instance QC.Arbitrary GetUserMidsWhoAddedMe_result where 
  arbitrary = M.liftM GetUserMidsWhoAddedMe_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserMidsWhoAddedMe_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = getUserMidsWhoAddedMe_result_success obj}
    , if obj == default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj} then P.Nothing else P.Just $ default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = getUserMidsWhoAddedMe_result_e obj}
    ]
from_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result -> T.ThriftVal
from_GetUserMidsWhoAddedMe_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5023 -> (1, ("e",from_TalkException _v5023))) <$> getUserMidsWhoAddedMe_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5023 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v5025 -> T.TString $ E.encodeUtf8 _v5025) $ Vector.toList _v5023))) $ getUserMidsWhoAddedMe_result_success record
    , (\_v5023 -> (1, ("e",from_TalkException _v5023))) <$> getUserMidsWhoAddedMe_result_e record
    ]
    )
write_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> GetUserMidsWhoAddedMe_result -> P.IO ()
write_GetUserMidsWhoAddedMe_result oprot record = T.writeVal oprot $ from_GetUserMidsWhoAddedMe_result record
encode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> GetUserMidsWhoAddedMe_result -> LBS.ByteString
encode_GetUserMidsWhoAddedMe_result oprot record = T.serializeVal oprot $ from_GetUserMidsWhoAddedMe_result record
to_GetUserMidsWhoAddedMe_result :: T.ThriftVal -> GetUserMidsWhoAddedMe_result
to_GetUserMidsWhoAddedMe_result (T.TStruct fields) = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = P.maybe (getUserMidsWhoAddedMe_result_success default_GetUserMidsWhoAddedMe_result) (\(_,_val5027) -> (case _val5027 of {T.TList _ _val5028 -> (Vector.fromList $ P.map (\_v5029 -> (case _v5029 of {T.TString _val5030 -> E.decodeUtf8 _val5030; _ -> P.error "wrong type"})) _val5028); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserMidsWhoAddedMe_result_e = P.maybe (P.Nothing) (\(_,_val5027) -> P.Just (case _val5027 of {T.TStruct _val5031 -> (to_TalkException (T.TStruct _val5031)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserMidsWhoAddedMe_result _ = P.error "not a struct"
read_GetUserMidsWhoAddedMe_result :: T.Protocol p => p -> P.IO GetUserMidsWhoAddedMe_result
read_GetUserMidsWhoAddedMe_result iprot = to_GetUserMidsWhoAddedMe_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result)
decode_GetUserMidsWhoAddedMe_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserMidsWhoAddedMe_result
decode_GetUserMidsWhoAddedMe_result iprot bs = to_GetUserMidsWhoAddedMe_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserMidsWhoAddedMe_result) bs
typemap_GetUserMidsWhoAddedMe_result :: T.TypeMap
typemap_GetUserMidsWhoAddedMe_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_GetUserMidsWhoAddedMe_result :: GetUserMidsWhoAddedMe_result
default_GetUserMidsWhoAddedMe_result = GetUserMidsWhoAddedMe_result{
  getUserMidsWhoAddedMe_result_success = Vector.empty,
  getUserMidsWhoAddedMe_result_e = P.Nothing}
data IsGroupMember_args = IsGroupMember_args  { isGroupMember_args_groupId :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_args_groupId record  
instance QC.Arbitrary IsGroupMember_args where 
  arbitrary = M.liftM IsGroupMember_args (QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj} then P.Nothing else P.Just $ default_IsGroupMember_args{isGroupMember_args_groupId = isGroupMember_args_groupId obj}
    ]
from_IsGroupMember_args :: IsGroupMember_args -> T.ThriftVal
from_IsGroupMember_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5034 -> P.Just (1, ("groupId",T.TString $ E.encodeUtf8 _v5034))) $ isGroupMember_args_groupId record
  ]
write_IsGroupMember_args :: T.Protocol p => p -> IsGroupMember_args -> P.IO ()
write_IsGroupMember_args oprot record = T.writeVal oprot $ from_IsGroupMember_args record
encode_IsGroupMember_args :: T.StatelessProtocol p => p -> IsGroupMember_args -> LBS.ByteString
encode_IsGroupMember_args oprot record = T.serializeVal oprot $ from_IsGroupMember_args record
to_IsGroupMember_args :: T.ThriftVal -> IsGroupMember_args
to_IsGroupMember_args (T.TStruct fields) = IsGroupMember_args{
  isGroupMember_args_groupId = P.maybe (isGroupMember_args_groupId default_IsGroupMember_args) (\(_,_val5036) -> (case _val5036 of {T.TString _val5037 -> E.decodeUtf8 _val5037; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_args _ = P.error "not a struct"
read_IsGroupMember_args :: T.Protocol p => p -> P.IO IsGroupMember_args
read_IsGroupMember_args iprot = to_IsGroupMember_args <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_args)
decode_IsGroupMember_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_args
decode_IsGroupMember_args iprot bs = to_IsGroupMember_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_args) bs
typemap_IsGroupMember_args :: T.TypeMap
typemap_IsGroupMember_args = Map.fromList [(1,("groupId",T.T_STRING))]
default_IsGroupMember_args :: IsGroupMember_args
default_IsGroupMember_args = IsGroupMember_args{
  isGroupMember_args_groupId = ""}
data IsGroupMember_result = IsGroupMember_result  { isGroupMember_result_success :: P.Bool
  , isGroupMember_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsGroupMember_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isGroupMember_result_success record   `H.hashWithSalt` isGroupMember_result_e record  
instance QC.Arbitrary IsGroupMember_result where 
  arbitrary = M.liftM IsGroupMember_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsGroupMember_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_success = isGroupMember_result_success obj}
    , if obj == default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj} then P.Nothing else P.Just $ default_IsGroupMember_result{isGroupMember_result_e = isGroupMember_result_e obj}
    ]
from_IsGroupMember_result :: IsGroupMember_result -> T.ThriftVal
from_IsGroupMember_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5040 -> (1, ("e",from_TalkException _v5040))) <$> isGroupMember_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5040 -> P.Just (0, ("success",T.TBool _v5040))) $ isGroupMember_result_success record
    , (\_v5040 -> (1, ("e",from_TalkException _v5040))) <$> isGroupMember_result_e record
    ]
    )
write_IsGroupMember_result :: T.Protocol p => p -> IsGroupMember_result -> P.IO ()
write_IsGroupMember_result oprot record = T.writeVal oprot $ from_IsGroupMember_result record
encode_IsGroupMember_result :: T.StatelessProtocol p => p -> IsGroupMember_result -> LBS.ByteString
encode_IsGroupMember_result oprot record = T.serializeVal oprot $ from_IsGroupMember_result record
to_IsGroupMember_result :: T.ThriftVal -> IsGroupMember_result
to_IsGroupMember_result (T.TStruct fields) = IsGroupMember_result{
  isGroupMember_result_success = P.maybe (isGroupMember_result_success default_IsGroupMember_result) (\(_,_val5042) -> (case _val5042 of {T.TBool _val5043 -> _val5043; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isGroupMember_result_e = P.maybe (P.Nothing) (\(_,_val5042) -> P.Just (case _val5042 of {T.TStruct _val5044 -> (to_TalkException (T.TStruct _val5044)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsGroupMember_result _ = P.error "not a struct"
read_IsGroupMember_result :: T.Protocol p => p -> P.IO IsGroupMember_result
read_IsGroupMember_result iprot = to_IsGroupMember_result <$> T.readVal iprot (T.T_STRUCT typemap_IsGroupMember_result)
decode_IsGroupMember_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsGroupMember_result
decode_IsGroupMember_result iprot bs = to_IsGroupMember_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsGroupMember_result) bs
typemap_IsGroupMember_result :: T.TypeMap
typemap_IsGroupMember_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsGroupMember_result :: IsGroupMember_result
default_IsGroupMember_result = IsGroupMember_result{
  isGroupMember_result_success = P.False,
  isGroupMember_result_e = P.Nothing}
data IsInContact_args = IsInContact_args  { isInContact_args_mid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_args_mid record  
instance QC.Arbitrary IsInContact_args where 
  arbitrary = M.liftM IsInContact_args (QC.arbitrary)
  shrink obj | obj == default_IsInContact_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj} then P.Nothing else P.Just $ default_IsInContact_args{isInContact_args_mid = isInContact_args_mid obj}
    ]
from_IsInContact_args :: IsInContact_args -> T.ThriftVal
from_IsInContact_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5047 -> P.Just (2, ("mid",T.TString $ E.encodeUtf8 _v5047))) $ isInContact_args_mid record
  ]
write_IsInContact_args :: T.Protocol p => p -> IsInContact_args -> P.IO ()
write_IsInContact_args oprot record = T.writeVal oprot $ from_IsInContact_args record
encode_IsInContact_args :: T.StatelessProtocol p => p -> IsInContact_args -> LBS.ByteString
encode_IsInContact_args oprot record = T.serializeVal oprot $ from_IsInContact_args record
to_IsInContact_args :: T.ThriftVal -> IsInContact_args
to_IsInContact_args (T.TStruct fields) = IsInContact_args{
  isInContact_args_mid = P.maybe (isInContact_args_mid default_IsInContact_args) (\(_,_val5049) -> (case _val5049 of {T.TString _val5050 -> E.decodeUtf8 _val5050; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_IsInContact_args _ = P.error "not a struct"
read_IsInContact_args :: T.Protocol p => p -> P.IO IsInContact_args
read_IsInContact_args iprot = to_IsInContact_args <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_args)
decode_IsInContact_args :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_args
decode_IsInContact_args iprot bs = to_IsInContact_args $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_args) bs
typemap_IsInContact_args :: T.TypeMap
typemap_IsInContact_args = Map.fromList [(2,("mid",T.T_STRING))]
default_IsInContact_args :: IsInContact_args
default_IsInContact_args = IsInContact_args{
  isInContact_args_mid = ""}
data IsInContact_result = IsInContact_result  { isInContact_result_success :: P.Bool
  , isInContact_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable IsInContact_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` isInContact_result_success record   `H.hashWithSalt` isInContact_result_e record  
instance QC.Arbitrary IsInContact_result where 
  arbitrary = M.liftM IsInContact_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_IsInContact_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_IsInContact_result{isInContact_result_success = isInContact_result_success obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_success = isInContact_result_success obj}
    , if obj == default_IsInContact_result{isInContact_result_e = isInContact_result_e obj} then P.Nothing else P.Just $ default_IsInContact_result{isInContact_result_e = isInContact_result_e obj}
    ]
from_IsInContact_result :: IsInContact_result -> T.ThriftVal
from_IsInContact_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5053 -> (1, ("e",from_TalkException _v5053))) <$> isInContact_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5053 -> P.Just (0, ("success",T.TBool _v5053))) $ isInContact_result_success record
    , (\_v5053 -> (1, ("e",from_TalkException _v5053))) <$> isInContact_result_e record
    ]
    )
write_IsInContact_result :: T.Protocol p => p -> IsInContact_result -> P.IO ()
write_IsInContact_result oprot record = T.writeVal oprot $ from_IsInContact_result record
encode_IsInContact_result :: T.StatelessProtocol p => p -> IsInContact_result -> LBS.ByteString
encode_IsInContact_result oprot record = T.serializeVal oprot $ from_IsInContact_result record
to_IsInContact_result :: T.ThriftVal -> IsInContact_result
to_IsInContact_result (T.TStruct fields) = IsInContact_result{
  isInContact_result_success = P.maybe (isInContact_result_success default_IsInContact_result) (\(_,_val5055) -> (case _val5055 of {T.TBool _val5056 -> _val5056; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  isInContact_result_e = P.maybe (P.Nothing) (\(_,_val5055) -> P.Just (case _val5055 of {T.TStruct _val5057 -> (to_TalkException (T.TStruct _val5057)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_IsInContact_result _ = P.error "not a struct"
read_IsInContact_result :: T.Protocol p => p -> P.IO IsInContact_result
read_IsInContact_result iprot = to_IsInContact_result <$> T.readVal iprot (T.T_STRUCT typemap_IsInContact_result)
decode_IsInContact_result :: T.StatelessProtocol p => p -> LBS.ByteString -> IsInContact_result
decode_IsInContact_result iprot bs = to_IsInContact_result $ T.deserializeVal iprot (T.T_STRUCT typemap_IsInContact_result) bs
typemap_IsInContact_result :: T.TypeMap
typemap_IsInContact_result = Map.fromList [(0,("success",T.T_BOOL)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_IsInContact_result :: IsInContact_result
default_IsInContact_result = IsInContact_result{
  isInContact_result_success = P.False,
  isInContact_result_e = P.Nothing}
data RegisterChannelCP_args = RegisterChannelCP_args  { registerChannelCP_args_cpId :: LT.Text
  , registerChannelCP_args_registerPassword :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_args_cpId record   `H.hashWithSalt` registerChannelCP_args_registerPassword record  
instance QC.Arbitrary RegisterChannelCP_args where 
  arbitrary = M.liftM RegisterChannelCP_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_cpId = registerChannelCP_args_cpId obj}
    , if obj == default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj} then P.Nothing else P.Just $ default_RegisterChannelCP_args{registerChannelCP_args_registerPassword = registerChannelCP_args_registerPassword obj}
    ]
from_RegisterChannelCP_args :: RegisterChannelCP_args -> T.ThriftVal
from_RegisterChannelCP_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5060 -> P.Just (2, ("cpId",T.TString $ E.encodeUtf8 _v5060))) $ registerChannelCP_args_cpId record
  , (\_v5060 -> P.Just (3, ("registerPassword",T.TString $ E.encodeUtf8 _v5060))) $ registerChannelCP_args_registerPassword record
  ]
write_RegisterChannelCP_args :: T.Protocol p => p -> RegisterChannelCP_args -> P.IO ()
write_RegisterChannelCP_args oprot record = T.writeVal oprot $ from_RegisterChannelCP_args record
encode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> RegisterChannelCP_args -> LBS.ByteString
encode_RegisterChannelCP_args oprot record = T.serializeVal oprot $ from_RegisterChannelCP_args record
to_RegisterChannelCP_args :: T.ThriftVal -> RegisterChannelCP_args
to_RegisterChannelCP_args (T.TStruct fields) = RegisterChannelCP_args{
  registerChannelCP_args_cpId = P.maybe (registerChannelCP_args_cpId default_RegisterChannelCP_args) (\(_,_val5062) -> (case _val5062 of {T.TString _val5063 -> E.decodeUtf8 _val5063; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  registerChannelCP_args_registerPassword = P.maybe (registerChannelCP_args_registerPassword default_RegisterChannelCP_args) (\(_,_val5062) -> (case _val5062 of {T.TString _val5064 -> E.decodeUtf8 _val5064; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RegisterChannelCP_args _ = P.error "not a struct"
read_RegisterChannelCP_args :: T.Protocol p => p -> P.IO RegisterChannelCP_args
read_RegisterChannelCP_args iprot = to_RegisterChannelCP_args <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args)
decode_RegisterChannelCP_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_args
decode_RegisterChannelCP_args iprot bs = to_RegisterChannelCP_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_args) bs
typemap_RegisterChannelCP_args :: T.TypeMap
typemap_RegisterChannelCP_args = Map.fromList [(2,("cpId",T.T_STRING)),(3,("registerPassword",T.T_STRING))]
default_RegisterChannelCP_args :: RegisterChannelCP_args
default_RegisterChannelCP_args = RegisterChannelCP_args{
  registerChannelCP_args_cpId = "",
  registerChannelCP_args_registerPassword = ""}
data RegisterChannelCP_result = RegisterChannelCP_result  { registerChannelCP_result_success :: LT.Text
  , registerChannelCP_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RegisterChannelCP_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` registerChannelCP_result_success record   `H.hashWithSalt` registerChannelCP_result_e record  
instance QC.Arbitrary RegisterChannelCP_result where 
  arbitrary = M.liftM RegisterChannelCP_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RegisterChannelCP_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_success = registerChannelCP_result_success obj}
    , if obj == default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj} then P.Nothing else P.Just $ default_RegisterChannelCP_result{registerChannelCP_result_e = registerChannelCP_result_e obj}
    ]
from_RegisterChannelCP_result :: RegisterChannelCP_result -> T.ThriftVal
from_RegisterChannelCP_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5067 -> (1, ("e",from_TalkException _v5067))) <$> registerChannelCP_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5067 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v5067))) $ registerChannelCP_result_success record
    , (\_v5067 -> (1, ("e",from_TalkException _v5067))) <$> registerChannelCP_result_e record
    ]
    )
write_RegisterChannelCP_result :: T.Protocol p => p -> RegisterChannelCP_result -> P.IO ()
write_RegisterChannelCP_result oprot record = T.writeVal oprot $ from_RegisterChannelCP_result record
encode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> RegisterChannelCP_result -> LBS.ByteString
encode_RegisterChannelCP_result oprot record = T.serializeVal oprot $ from_RegisterChannelCP_result record
to_RegisterChannelCP_result :: T.ThriftVal -> RegisterChannelCP_result
to_RegisterChannelCP_result (T.TStruct fields) = RegisterChannelCP_result{
  registerChannelCP_result_success = P.maybe (registerChannelCP_result_success default_RegisterChannelCP_result) (\(_,_val5069) -> (case _val5069 of {T.TString _val5070 -> E.decodeUtf8 _val5070; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  registerChannelCP_result_e = P.maybe (P.Nothing) (\(_,_val5069) -> P.Just (case _val5069 of {T.TStruct _val5071 -> (to_TalkException (T.TStruct _val5071)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RegisterChannelCP_result _ = P.error "not a struct"
read_RegisterChannelCP_result :: T.Protocol p => p -> P.IO RegisterChannelCP_result
read_RegisterChannelCP_result iprot = to_RegisterChannelCP_result <$> T.readVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result)
decode_RegisterChannelCP_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RegisterChannelCP_result
decode_RegisterChannelCP_result iprot bs = to_RegisterChannelCP_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RegisterChannelCP_result) bs
typemap_RegisterChannelCP_result :: T.TypeMap
typemap_RegisterChannelCP_result = Map.fromList [(0,("success",T.T_STRING)),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RegisterChannelCP_result :: RegisterChannelCP_result
default_RegisterChannelCP_result = RegisterChannelCP_result{
  registerChannelCP_result_success = "",
  registerChannelCP_result_e = P.Nothing}
data RemoveNotificationStatus_args = RemoveNotificationStatus_args  { removeNotificationStatus_args_notificationStatus :: NotificationStatus
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveNotificationStatus_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeNotificationStatus_args_notificationStatus record  
instance QC.Arbitrary RemoveNotificationStatus_args where 
  arbitrary = M.liftM RemoveNotificationStatus_args (QC.arbitrary)
  shrink obj | obj == default_RemoveNotificationStatus_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveNotificationStatus_args{removeNotificationStatus_args_notificationStatus = removeNotificationStatus_args_notificationStatus obj} then P.Nothing else P.Just $ default_RemoveNotificationStatus_args{removeNotificationStatus_args_notificationStatus = removeNotificationStatus_args_notificationStatus obj}
    ]
from_RemoveNotificationStatus_args :: RemoveNotificationStatus_args -> T.ThriftVal
from_RemoveNotificationStatus_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5074 -> P.Just (2, ("notificationStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v5074))) $ removeNotificationStatus_args_notificationStatus record
  ]
write_RemoveNotificationStatus_args :: T.Protocol p => p -> RemoveNotificationStatus_args -> P.IO ()
write_RemoveNotificationStatus_args oprot record = T.writeVal oprot $ from_RemoveNotificationStatus_args record
encode_RemoveNotificationStatus_args :: T.StatelessProtocol p => p -> RemoveNotificationStatus_args -> LBS.ByteString
encode_RemoveNotificationStatus_args oprot record = T.serializeVal oprot $ from_RemoveNotificationStatus_args record
to_RemoveNotificationStatus_args :: T.ThriftVal -> RemoveNotificationStatus_args
to_RemoveNotificationStatus_args (T.TStruct fields) = RemoveNotificationStatus_args{
  removeNotificationStatus_args_notificationStatus = P.maybe (removeNotificationStatus_args_notificationStatus default_RemoveNotificationStatus_args) (\(_,_val5076) -> (case _val5076 of {T.TI32 _val5077 -> P.toEnum $ P.fromIntegral _val5077; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveNotificationStatus_args _ = P.error "not a struct"
read_RemoveNotificationStatus_args :: T.Protocol p => p -> P.IO RemoveNotificationStatus_args
read_RemoveNotificationStatus_args iprot = to_RemoveNotificationStatus_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_args)
decode_RemoveNotificationStatus_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveNotificationStatus_args
decode_RemoveNotificationStatus_args iprot bs = to_RemoveNotificationStatus_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_args) bs
typemap_RemoveNotificationStatus_args :: T.TypeMap
typemap_RemoveNotificationStatus_args = Map.fromList [(2,("notificationStatus",T.T_I32))]
default_RemoveNotificationStatus_args :: RemoveNotificationStatus_args
default_RemoveNotificationStatus_args = RemoveNotificationStatus_args{
  removeNotificationStatus_args_notificationStatus = (P.toEnum 0)}
data RemoveNotificationStatus_result = RemoveNotificationStatus_result  { removeNotificationStatus_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveNotificationStatus_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeNotificationStatus_result_e record  
instance QC.Arbitrary RemoveNotificationStatus_result where 
  arbitrary = M.liftM RemoveNotificationStatus_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveNotificationStatus_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = removeNotificationStatus_result_e obj} then P.Nothing else P.Just $ default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = removeNotificationStatus_result_e obj}
    ]
from_RemoveNotificationStatus_result :: RemoveNotificationStatus_result -> T.ThriftVal
from_RemoveNotificationStatus_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5080 -> (1, ("e",from_TalkException _v5080))) <$> removeNotificationStatus_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5080 -> (1, ("e",from_TalkException _v5080))) <$> removeNotificationStatus_result_e record
    ]
    )
write_RemoveNotificationStatus_result :: T.Protocol p => p -> RemoveNotificationStatus_result -> P.IO ()
write_RemoveNotificationStatus_result oprot record = T.writeVal oprot $ from_RemoveNotificationStatus_result record
encode_RemoveNotificationStatus_result :: T.StatelessProtocol p => p -> RemoveNotificationStatus_result -> LBS.ByteString
encode_RemoveNotificationStatus_result oprot record = T.serializeVal oprot $ from_RemoveNotificationStatus_result record
to_RemoveNotificationStatus_result :: T.ThriftVal -> RemoveNotificationStatus_result
to_RemoveNotificationStatus_result (T.TStruct fields) = RemoveNotificationStatus_result{
  removeNotificationStatus_result_e = P.maybe (P.Nothing) (\(_,_val5082) -> P.Just (case _val5082 of {T.TStruct _val5083 -> (to_TalkException (T.TStruct _val5083)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RemoveNotificationStatus_result _ = P.error "not a struct"
read_RemoveNotificationStatus_result :: T.Protocol p => p -> P.IO RemoveNotificationStatus_result
read_RemoveNotificationStatus_result iprot = to_RemoveNotificationStatus_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_result)
decode_RemoveNotificationStatus_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveNotificationStatus_result
decode_RemoveNotificationStatus_result iprot bs = to_RemoveNotificationStatus_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveNotificationStatus_result) bs
typemap_RemoveNotificationStatus_result :: T.TypeMap
typemap_RemoveNotificationStatus_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_RemoveNotificationStatus_result :: RemoveNotificationStatus_result
default_RemoveNotificationStatus_result = RemoveNotificationStatus_result{
  removeNotificationStatus_result_e = P.Nothing}
data SendMessageForChannel_args = SendMessageForChannel_args  { sendMessageForChannel_args_message :: Message
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_args_message record  
instance QC.Arbitrary SendMessageForChannel_args where 
  arbitrary = M.liftM SendMessageForChannel_args (QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj} then P.Nothing else P.Just $ default_SendMessageForChannel_args{sendMessageForChannel_args_message = sendMessageForChannel_args_message obj}
    ]
from_SendMessageForChannel_args :: SendMessageForChannel_args -> T.ThriftVal
from_SendMessageForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5086 -> P.Just (2, ("message",from_Message _v5086))) $ sendMessageForChannel_args_message record
  ]
write_SendMessageForChannel_args :: T.Protocol p => p -> SendMessageForChannel_args -> P.IO ()
write_SendMessageForChannel_args oprot record = T.writeVal oprot $ from_SendMessageForChannel_args record
encode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> SendMessageForChannel_args -> LBS.ByteString
encode_SendMessageForChannel_args oprot record = T.serializeVal oprot $ from_SendMessageForChannel_args record
to_SendMessageForChannel_args :: T.ThriftVal -> SendMessageForChannel_args
to_SendMessageForChannel_args (T.TStruct fields) = SendMessageForChannel_args{
  sendMessageForChannel_args_message = P.maybe (sendMessageForChannel_args_message default_SendMessageForChannel_args) (\(_,_val5088) -> (case _val5088 of {T.TStruct _val5089 -> (to_Message (T.TStruct _val5089)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SendMessageForChannel_args _ = P.error "not a struct"
read_SendMessageForChannel_args :: T.Protocol p => p -> P.IO SendMessageForChannel_args
read_SendMessageForChannel_args iprot = to_SendMessageForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args)
decode_SendMessageForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_args
decode_SendMessageForChannel_args iprot bs = to_SendMessageForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_args) bs
typemap_SendMessageForChannel_args :: T.TypeMap
typemap_SendMessageForChannel_args = Map.fromList [(2,("message",(T.T_STRUCT typemap_Message)))]
default_SendMessageForChannel_args :: SendMessageForChannel_args
default_SendMessageForChannel_args = SendMessageForChannel_args{
  sendMessageForChannel_args_message = default_Message}
data SendMessageForChannel_result = SendMessageForChannel_result  { sendMessageForChannel_result_success :: Message
  , sendMessageForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendMessageForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendMessageForChannel_result_success record   `H.hashWithSalt` sendMessageForChannel_result_e record  
instance QC.Arbitrary SendMessageForChannel_result where 
  arbitrary = M.liftM SendMessageForChannel_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendMessageForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_success = sendMessageForChannel_result_success obj}
    , if obj == default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj} then P.Nothing else P.Just $ default_SendMessageForChannel_result{sendMessageForChannel_result_e = sendMessageForChannel_result_e obj}
    ]
from_SendMessageForChannel_result :: SendMessageForChannel_result -> T.ThriftVal
from_SendMessageForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5092 -> (1, ("e",from_TalkException _v5092))) <$> sendMessageForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5092 -> P.Just (0, ("success",from_Message _v5092))) $ sendMessageForChannel_result_success record
    , (\_v5092 -> (1, ("e",from_TalkException _v5092))) <$> sendMessageForChannel_result_e record
    ]
    )
write_SendMessageForChannel_result :: T.Protocol p => p -> SendMessageForChannel_result -> P.IO ()
write_SendMessageForChannel_result oprot record = T.writeVal oprot $ from_SendMessageForChannel_result record
encode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> SendMessageForChannel_result -> LBS.ByteString
encode_SendMessageForChannel_result oprot record = T.serializeVal oprot $ from_SendMessageForChannel_result record
to_SendMessageForChannel_result :: T.ThriftVal -> SendMessageForChannel_result
to_SendMessageForChannel_result (T.TStruct fields) = SendMessageForChannel_result{
  sendMessageForChannel_result_success = P.maybe (sendMessageForChannel_result_success default_SendMessageForChannel_result) (\(_,_val5094) -> (case _val5094 of {T.TStruct _val5095 -> (to_Message (T.TStruct _val5095)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  sendMessageForChannel_result_e = P.maybe (P.Nothing) (\(_,_val5094) -> P.Just (case _val5094 of {T.TStruct _val5096 -> (to_TalkException (T.TStruct _val5096)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendMessageForChannel_result _ = P.error "not a struct"
read_SendMessageForChannel_result :: T.Protocol p => p -> P.IO SendMessageForChannel_result
read_SendMessageForChannel_result iprot = to_SendMessageForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result)
decode_SendMessageForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendMessageForChannel_result
decode_SendMessageForChannel_result iprot bs = to_SendMessageForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendMessageForChannel_result) bs
typemap_SendMessageForChannel_result :: T.TypeMap
typemap_SendMessageForChannel_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_Message))),(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendMessageForChannel_result :: SendMessageForChannel_result
default_SendMessageForChannel_result = SendMessageForChannel_result{
  sendMessageForChannel_result_success = default_Message,
  sendMessageForChannel_result_e = P.Nothing}
data SendPinCodeOperation_args = SendPinCodeOperation_args  { sendPinCodeOperation_args_verifier :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_args_verifier record  
instance QC.Arbitrary SendPinCodeOperation_args where 
  arbitrary = M.liftM SendPinCodeOperation_args (QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_args{sendPinCodeOperation_args_verifier = sendPinCodeOperation_args_verifier obj}
    ]
from_SendPinCodeOperation_args :: SendPinCodeOperation_args -> T.ThriftVal
from_SendPinCodeOperation_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5099 -> P.Just (1, ("verifier",T.TString $ E.encodeUtf8 _v5099))) $ sendPinCodeOperation_args_verifier record
  ]
write_SendPinCodeOperation_args :: T.Protocol p => p -> SendPinCodeOperation_args -> P.IO ()
write_SendPinCodeOperation_args oprot record = T.writeVal oprot $ from_SendPinCodeOperation_args record
encode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> SendPinCodeOperation_args -> LBS.ByteString
encode_SendPinCodeOperation_args oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_args record
to_SendPinCodeOperation_args :: T.ThriftVal -> SendPinCodeOperation_args
to_SendPinCodeOperation_args (T.TStruct fields) = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = P.maybe (sendPinCodeOperation_args_verifier default_SendPinCodeOperation_args) (\(_,_val5101) -> (case _val5101 of {T.TString _val5102 -> E.decodeUtf8 _val5102; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_args _ = P.error "not a struct"
read_SendPinCodeOperation_args :: T.Protocol p => p -> P.IO SendPinCodeOperation_args
read_SendPinCodeOperation_args iprot = to_SendPinCodeOperation_args <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args)
decode_SendPinCodeOperation_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_args
decode_SendPinCodeOperation_args iprot bs = to_SendPinCodeOperation_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_args) bs
typemap_SendPinCodeOperation_args :: T.TypeMap
typemap_SendPinCodeOperation_args = Map.fromList [(1,("verifier",T.T_STRING))]
default_SendPinCodeOperation_args :: SendPinCodeOperation_args
default_SendPinCodeOperation_args = SendPinCodeOperation_args{
  sendPinCodeOperation_args_verifier = ""}
data SendPinCodeOperation_result = SendPinCodeOperation_result  { sendPinCodeOperation_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SendPinCodeOperation_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` sendPinCodeOperation_result_e record  
instance QC.Arbitrary SendPinCodeOperation_result where 
  arbitrary = M.liftM SendPinCodeOperation_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SendPinCodeOperation_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj} then P.Nothing else P.Just $ default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = sendPinCodeOperation_result_e obj}
    ]
from_SendPinCodeOperation_result :: SendPinCodeOperation_result -> T.ThriftVal
from_SendPinCodeOperation_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5105 -> (1, ("e",from_TalkException _v5105))) <$> sendPinCodeOperation_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5105 -> (1, ("e",from_TalkException _v5105))) <$> sendPinCodeOperation_result_e record
    ]
    )
write_SendPinCodeOperation_result :: T.Protocol p => p -> SendPinCodeOperation_result -> P.IO ()
write_SendPinCodeOperation_result oprot record = T.writeVal oprot $ from_SendPinCodeOperation_result record
encode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> SendPinCodeOperation_result -> LBS.ByteString
encode_SendPinCodeOperation_result oprot record = T.serializeVal oprot $ from_SendPinCodeOperation_result record
to_SendPinCodeOperation_result :: T.ThriftVal -> SendPinCodeOperation_result
to_SendPinCodeOperation_result (T.TStruct fields) = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.maybe (P.Nothing) (\(_,_val5107) -> P.Just (case _val5107 of {T.TStruct _val5108 -> (to_TalkException (T.TStruct _val5108)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_SendPinCodeOperation_result _ = P.error "not a struct"
read_SendPinCodeOperation_result :: T.Protocol p => p -> P.IO SendPinCodeOperation_result
read_SendPinCodeOperation_result iprot = to_SendPinCodeOperation_result <$> T.readVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result)
decode_SendPinCodeOperation_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SendPinCodeOperation_result
decode_SendPinCodeOperation_result iprot bs = to_SendPinCodeOperation_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SendPinCodeOperation_result) bs
typemap_SendPinCodeOperation_result :: T.TypeMap
typemap_SendPinCodeOperation_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_SendPinCodeOperation_result :: SendPinCodeOperation_result
default_SendPinCodeOperation_result = SendPinCodeOperation_result{
  sendPinCodeOperation_result_e = P.Nothing}
data UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args  { updateProfileAttributeForChannel_args_profileAttribute :: ProfileAttribute
  , updateProfileAttributeForChannel_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_args_profileAttribute record   `H.hashWithSalt` updateProfileAttributeForChannel_args_value record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_args where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_profileAttribute = updateProfileAttributeForChannel_args_profileAttribute obj}
    , if obj == default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_args{updateProfileAttributeForChannel_args_value = updateProfileAttributeForChannel_args_value obj}
    ]
from_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args -> T.ThriftVal
from_UpdateProfileAttributeForChannel_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v5111 -> P.Just (2, ("profileAttribute",T.TI32 $ P.fromIntegral $ P.fromEnum _v5111))) $ updateProfileAttributeForChannel_args_profileAttribute record
  , (\_v5111 -> P.Just (3, ("value",T.TString $ E.encodeUtf8 _v5111))) $ updateProfileAttributeForChannel_args_value record
  ]
write_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> UpdateProfileAttributeForChannel_args -> P.IO ()
write_UpdateProfileAttributeForChannel_args oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_args record
encode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_args -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_args oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_args record
to_UpdateProfileAttributeForChannel_args :: T.ThriftVal -> UpdateProfileAttributeForChannel_args
to_UpdateProfileAttributeForChannel_args (T.TStruct fields) = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = P.maybe (updateProfileAttributeForChannel_args_profileAttribute default_UpdateProfileAttributeForChannel_args) (\(_,_val5113) -> (case _val5113 of {T.TI32 _val5114 -> P.toEnum $ P.fromIntegral _val5114; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateProfileAttributeForChannel_args_value = P.maybe (updateProfileAttributeForChannel_args_value default_UpdateProfileAttributeForChannel_args) (\(_,_val5113) -> (case _val5113 of {T.TString _val5115 -> E.decodeUtf8 _val5115; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateProfileAttributeForChannel_args _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_args :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_args
read_UpdateProfileAttributeForChannel_args iprot = to_UpdateProfileAttributeForChannel_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args)
decode_UpdateProfileAttributeForChannel_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_args
decode_UpdateProfileAttributeForChannel_args iprot bs = to_UpdateProfileAttributeForChannel_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_args) bs
typemap_UpdateProfileAttributeForChannel_args :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_args = Map.fromList [(2,("profileAttribute",T.T_I32)),(3,("value",T.T_STRING))]
default_UpdateProfileAttributeForChannel_args :: UpdateProfileAttributeForChannel_args
default_UpdateProfileAttributeForChannel_args = UpdateProfileAttributeForChannel_args{
  updateProfileAttributeForChannel_args_profileAttribute = (P.toEnum 0),
  updateProfileAttributeForChannel_args_value = ""}
data UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result  { updateProfileAttributeForChannel_result_e :: P.Maybe TalkException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateProfileAttributeForChannel_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateProfileAttributeForChannel_result_e record  
instance QC.Arbitrary UpdateProfileAttributeForChannel_result where 
  arbitrary = M.liftM UpdateProfileAttributeForChannel_result (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateProfileAttributeForChannel_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj} then P.Nothing else P.Just $ default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = updateProfileAttributeForChannel_result_e obj}
    ]
from_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result -> T.ThriftVal
from_UpdateProfileAttributeForChannel_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v5118 -> (1, ("e",from_TalkException _v5118))) <$> updateProfileAttributeForChannel_result_e record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v5118 -> (1, ("e",from_TalkException _v5118))) <$> updateProfileAttributeForChannel_result_e record
    ]
    )
write_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> UpdateProfileAttributeForChannel_result -> P.IO ()
write_UpdateProfileAttributeForChannel_result oprot record = T.writeVal oprot $ from_UpdateProfileAttributeForChannel_result record
encode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> UpdateProfileAttributeForChannel_result -> LBS.ByteString
encode_UpdateProfileAttributeForChannel_result oprot record = T.serializeVal oprot $ from_UpdateProfileAttributeForChannel_result record
to_UpdateProfileAttributeForChannel_result :: T.ThriftVal -> UpdateProfileAttributeForChannel_result
to_UpdateProfileAttributeForChannel_result (T.TStruct fields) = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.maybe (P.Nothing) (\(_,_val5120) -> P.Just (case _val5120 of {T.TStruct _val5121 -> (to_TalkException (T.TStruct _val5121)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_UpdateProfileAttributeForChannel_result _ = P.error "not a struct"
read_UpdateProfileAttributeForChannel_result :: T.Protocol p => p -> P.IO UpdateProfileAttributeForChannel_result
read_UpdateProfileAttributeForChannel_result iprot = to_UpdateProfileAttributeForChannel_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result)
decode_UpdateProfileAttributeForChannel_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateProfileAttributeForChannel_result
decode_UpdateProfileAttributeForChannel_result iprot bs = to_UpdateProfileAttributeForChannel_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateProfileAttributeForChannel_result) bs
typemap_UpdateProfileAttributeForChannel_result :: T.TypeMap
typemap_UpdateProfileAttributeForChannel_result = Map.fromList [(1,("e",(T.T_STRUCT typemap_TalkException)))]
default_UpdateProfileAttributeForChannel_result :: UpdateProfileAttributeForChannel_result
default_UpdateProfileAttributeForChannel_result = UpdateProfileAttributeForChannel_result{
  updateProfileAttributeForChannel_result_e = P.Nothing}
process_activeBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_ActiveBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.activeBuddySubscriberCount handler
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_ActiveBuddySubscriberCount_result{activeBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("activeBuddySubscriberCount", T.M_REPLY, seqid) $
          write_ActiveBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("activeBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_addOperationForChannel (seqid, iprot, oprot, handler) = do
  args <- read_AddOperationForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.addOperationForChannel handler (addOperationForChannel_args_opType args) (addOperationForChannel_args_param1 args) (addOperationForChannel_args_param2 args) (addOperationForChannel_args_param3 args)
        let res = default_AddOperationForChannel_result
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res)
      (\e  -> do
        let res = default_AddOperationForChannel_result{addOperationForChannel_result_e = P.Just e}
        T.writeMessage oprot ("addOperationForChannel", T.M_REPLY, seqid) $
          write_AddOperationForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("addOperationForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_displayBuddySubscriberCount (seqid, iprot, oprot, handler) = do
  args <- read_DisplayBuddySubscriberCount_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.displayBuddySubscriberCount handler
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_success = val}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res)
      (\e  -> do
        let res = default_DisplayBuddySubscriberCount_result{displayBuddySubscriberCount_result_e = P.Just e}
        T.writeMessage oprot ("displayBuddySubscriberCount", T.M_REPLY, seqid) $
          write_DisplayBuddySubscriberCount_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("displayBuddySubscriberCount", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findContactByUseridWithoutAbuseBlockForChannel (seqid, iprot, oprot, handler) = do
  args <- read_FindContactByUseridWithoutAbuseBlockForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.findContactByUseridWithoutAbuseBlockForChannel handler (findContactByUseridWithoutAbuseBlockForChannel_args_userid args)
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_success = val}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res)
      (\e  -> do
        let res = default_FindContactByUseridWithoutAbuseBlockForChannel_result{findContactByUseridWithoutAbuseBlockForChannel_result_e = P.Just e}
        T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_REPLY, seqid) $
          write_FindContactByUseridWithoutAbuseBlockForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findContactByUseridWithoutAbuseBlockForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAllContactIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetAllContactIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAllContactIdsForChannel handler
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_success = val}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetAllContactIdsForChannel_result{getAllContactIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getAllContactIdsForChannel", T.M_REPLY, seqid) $
          write_GetAllContactIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAllContactIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getCompactContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetCompactContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getCompactContacts handler (getCompactContacts_args_lastModifiedTimestamp args)
        let res = default_GetCompactContacts_result{getCompactContacts_result_success = val}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res)
      (\e  -> do
        let res = default_GetCompactContacts_result{getCompactContacts_result_e = P.Just e}
        T.writeMessage oprot ("getCompactContacts", T.M_REPLY, seqid) $
          write_GetCompactContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getCompactContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getContactsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetContactsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getContactsForChannel handler (getContactsForChannel_args_ids args)
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_success = val}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetContactsForChannel_result{getContactsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getContactsForChannel", T.M_REPLY, seqid) $
          write_GetContactsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getContactsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDisplayName (seqid, iprot, oprot, handler) = do
  args <- read_GetDisplayName_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getDisplayName handler (getDisplayName_args_mid args)
        let res = default_GetDisplayName_result{getDisplayName_result_success = val}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res)
      (\e  -> do
        let res = default_GetDisplayName_result{getDisplayName_result_e = P.Just e}
        T.writeMessage oprot ("getDisplayName", T.M_REPLY, seqid) $
          write_GetDisplayName_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDisplayName", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFavoriteMidsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetFavoriteMidsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFavoriteMidsForChannel handler
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_success = val}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetFavoriteMidsForChannel_result{getFavoriteMidsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_REPLY, seqid) $
          write_GetFavoriteMidsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFavoriteMidsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFriendMids (seqid, iprot, oprot, handler) = do
  args <- read_GetFriendMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getFriendMids handler
        let res = default_GetFriendMids_result{getFriendMids_result_success = val}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res)
      (\e  -> do
        let res = default_GetFriendMids_result{getFriendMids_result_e = P.Just e}
        T.writeMessage oprot ("getFriendMids", T.M_REPLY, seqid) $
          write_GetFriendMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFriendMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupMemberMids (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupMemberMids_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupMemberMids handler (getGroupMemberMids_args_groupId args)
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_success = val}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res)
      (\e  -> do
        let res = default_GetGroupMemberMids_result{getGroupMemberMids_result_e = P.Just e}
        T.writeMessage oprot ("getGroupMemberMids", T.M_REPLY, seqid) $
          write_GetGroupMemberMids_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupMemberMids", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getGroupsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetGroupsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getGroupsForChannel handler (getGroupsForChannel_args_groupIds args)
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_success = val}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetGroupsForChannel_result{getGroupsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getGroupsForChannel", T.M_REPLY, seqid) $
          write_GetGroupsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getGroupsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getIdentityCredential (seqid, iprot, oprot, handler) = do
  args <- read_GetIdentityCredential_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getIdentityCredential handler
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_success = val}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res)
      (\e  -> do
        let res = default_GetIdentityCredential_result{getIdentityCredential_result_e = P.Just e}
        T.writeMessage oprot ("getIdentityCredential", T.M_REPLY, seqid) $
          write_GetIdentityCredential_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getIdentityCredential", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getJoinedGroupIdsForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetJoinedGroupIdsForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getJoinedGroupIdsForChannel handler
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_success = val}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res)
      (\e  -> do
        let res = default_GetJoinedGroupIdsForChannel_result{getJoinedGroupIdsForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_REPLY, seqid) $
          write_GetJoinedGroupIdsForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getJoinedGroupIdsForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMetaProfile (seqid, iprot, oprot, handler) = do
  args <- read_GetMetaProfile_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMetaProfile handler
        let res = default_GetMetaProfile_result{getMetaProfile_result_success = val}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res)
      (\e  -> do
        let res = default_GetMetaProfile_result{getMetaProfile_result_e = P.Just e}
        T.writeMessage oprot ("getMetaProfile", T.M_REPLY, seqid) $
          write_GetMetaProfile_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMetaProfile", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getMid (seqid, iprot, oprot, handler) = do
  args <- read_GetMid_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getMid handler
        let res = default_GetMid_result{getMid_result_success = val}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res)
      (\e  -> do
        let res = default_GetMid_result{getMid_result_e = P.Just e}
        T.writeMessage oprot ("getMid", T.M_REPLY, seqid) $
          write_GetMid_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getMid", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPrimaryClientForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetPrimaryClientForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getPrimaryClientForChannel handler
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_success = val}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res)
      (\e  -> do
        let res = default_GetPrimaryClientForChannel_result{getPrimaryClientForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getPrimaryClientForChannel", T.M_REPLY, seqid) $
          write_GetPrimaryClientForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPrimaryClientForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getProfileForChannel (seqid, iprot, oprot, handler) = do
  args <- read_GetProfileForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getProfileForChannel handler
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_success = val}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res)
      (\e  -> do
        let res = default_GetProfileForChannel_result{getProfileForChannel_result_e = P.Just e}
        T.writeMessage oprot ("getProfileForChannel", T.M_REPLY, seqid) $
          write_GetProfileForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getProfileForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSimpleChannelContacts (seqid, iprot, oprot, handler) = do
  args <- read_GetSimpleChannelContacts_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getSimpleChannelContacts handler (getSimpleChannelContacts_args_ids args)
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_success = val}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res)
      (\e  -> do
        let res = default_GetSimpleChannelContacts_result{getSimpleChannelContacts_result_e = P.Just e}
        T.writeMessage oprot ("getSimpleChannelContacts", T.M_REPLY, seqid) $
          write_GetSimpleChannelContacts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSimpleChannelContacts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCountryForBilling (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCountryForBilling_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCountryForBilling handler (getUserCountryForBilling_args_country args) (getUserCountryForBilling_args_remoteIp args)
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_success = val}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res)
      (\e  -> do
        let res = default_GetUserCountryForBilling_result{getUserCountryForBilling_result_e = P.Just e}
        T.writeMessage oprot ("getUserCountryForBilling", T.M_REPLY, seqid) $
          write_GetUserCountryForBilling_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCountryForBilling", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserCreateTime (seqid, iprot, oprot, handler) = do
  args <- read_GetUserCreateTime_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserCreateTime handler
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_success = val}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res)
      (\e  -> do
        let res = default_GetUserCreateTime_result{getUserCreateTime_result_e = P.Just e}
        T.writeMessage oprot ("getUserCreateTime", T.M_REPLY, seqid) $
          write_GetUserCreateTime_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserCreateTime", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserIdentities (seqid, iprot, oprot, handler) = do
  args <- read_GetUserIdentities_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserIdentities handler
        let res = default_GetUserIdentities_result{getUserIdentities_result_success = val}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res)
      (\e  -> do
        let res = default_GetUserIdentities_result{getUserIdentities_result_e = P.Just e}
        T.writeMessage oprot ("getUserIdentities", T.M_REPLY, seqid) $
          write_GetUserIdentities_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserIdentities", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserLanguage (seqid, iprot, oprot, handler) = do
  args <- read_GetUserLanguage_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserLanguage handler
        let res = default_GetUserLanguage_result{getUserLanguage_result_success = val}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res)
      (\e  -> do
        let res = default_GetUserLanguage_result{getUserLanguage_result_e = P.Just e}
        T.writeMessage oprot ("getUserLanguage", T.M_REPLY, seqid) $
          write_GetUserLanguage_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserLanguage", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserMidsWhoAddedMe (seqid, iprot, oprot, handler) = do
  args <- read_GetUserMidsWhoAddedMe_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getUserMidsWhoAddedMe handler
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_success = val}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res)
      (\e  -> do
        let res = default_GetUserMidsWhoAddedMe_result{getUserMidsWhoAddedMe_result_e = P.Just e}
        T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_REPLY, seqid) $
          write_GetUserMidsWhoAddedMe_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserMidsWhoAddedMe", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isGroupMember (seqid, iprot, oprot, handler) = do
  args <- read_IsGroupMember_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isGroupMember handler (isGroupMember_args_groupId args)
        let res = default_IsGroupMember_result{isGroupMember_result_success = val}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res)
      (\e  -> do
        let res = default_IsGroupMember_result{isGroupMember_result_e = P.Just e}
        T.writeMessage oprot ("isGroupMember", T.M_REPLY, seqid) $
          write_IsGroupMember_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isGroupMember", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_isInContact (seqid, iprot, oprot, handler) = do
  args <- read_IsInContact_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.isInContact handler (isInContact_args_mid args)
        let res = default_IsInContact_result{isInContact_result_success = val}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res)
      (\e  -> do
        let res = default_IsInContact_result{isInContact_result_e = P.Just e}
        T.writeMessage oprot ("isInContact", T.M_REPLY, seqid) $
          write_IsInContact_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("isInContact", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_registerChannelCP (seqid, iprot, oprot, handler) = do
  args <- read_RegisterChannelCP_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.registerChannelCP handler (registerChannelCP_args_cpId args) (registerChannelCP_args_registerPassword args)
        let res = default_RegisterChannelCP_result{registerChannelCP_result_success = val}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res)
      (\e  -> do
        let res = default_RegisterChannelCP_result{registerChannelCP_result_e = P.Just e}
        T.writeMessage oprot ("registerChannelCP", T.M_REPLY, seqid) $
          write_RegisterChannelCP_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("registerChannelCP", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeNotificationStatus (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNotificationStatus_args iprot
  (X.catch
    (X.catch
      (do
        Iface.removeNotificationStatus handler (removeNotificationStatus_args_notificationStatus args)
        let res = default_RemoveNotificationStatus_result
        T.writeMessage oprot ("removeNotificationStatus", T.M_REPLY, seqid) $
          write_RemoveNotificationStatus_result oprot res)
      (\e  -> do
        let res = default_RemoveNotificationStatus_result{removeNotificationStatus_result_e = P.Just e}
        T.writeMessage oprot ("removeNotificationStatus", T.M_REPLY, seqid) $
          write_RemoveNotificationStatus_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeNotificationStatus", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendMessageForChannel (seqid, iprot, oprot, handler) = do
  args <- read_SendMessageForChannel_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.sendMessageForChannel handler (sendMessageForChannel_args_message args)
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_success = val}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res)
      (\e  -> do
        let res = default_SendMessageForChannel_result{sendMessageForChannel_result_e = P.Just e}
        T.writeMessage oprot ("sendMessageForChannel", T.M_REPLY, seqid) $
          write_SendMessageForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendMessageForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_sendPinCodeOperation (seqid, iprot, oprot, handler) = do
  args <- read_SendPinCodeOperation_args iprot
  (X.catch
    (X.catch
      (do
        Iface.sendPinCodeOperation handler (sendPinCodeOperation_args_verifier args)
        let res = default_SendPinCodeOperation_result
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res)
      (\e  -> do
        let res = default_SendPinCodeOperation_result{sendPinCodeOperation_result_e = P.Just e}
        T.writeMessage oprot ("sendPinCodeOperation", T.M_REPLY, seqid) $
          write_SendPinCodeOperation_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("sendPinCodeOperation", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateProfileAttributeForChannel (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProfileAttributeForChannel_args iprot
  (X.catch
    (X.catch
      (do
        Iface.updateProfileAttributeForChannel handler (updateProfileAttributeForChannel_args_profileAttribute args) (updateProfileAttributeForChannel_args_value args)
        let res = default_UpdateProfileAttributeForChannel_result
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res)
      (\e  -> do
        let res = default_UpdateProfileAttributeForChannel_result{updateProfileAttributeForChannel_result_e = P.Just e}
        T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_REPLY, seqid) $
          write_UpdateProfileAttributeForChannel_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateProfileAttributeForChannel", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "activeBuddySubscriberCount" -> process_activeBuddySubscriberCount (seqid,iprot,oprot,handler)
  "addOperationForChannel" -> process_addOperationForChannel (seqid,iprot,oprot,handler)
  "displayBuddySubscriberCount" -> process_displayBuddySubscriberCount (seqid,iprot,oprot,handler)
  "findContactByUseridWithoutAbuseBlockForChannel" -> process_findContactByUseridWithoutAbuseBlockForChannel (seqid,iprot,oprot,handler)
  "getAllContactIdsForChannel" -> process_getAllContactIdsForChannel (seqid,iprot,oprot,handler)
  "getCompactContacts" -> process_getCompactContacts (seqid,iprot,oprot,handler)
  "getContactsForChannel" -> process_getContactsForChannel (seqid,iprot,oprot,handler)
  "getDisplayName" -> process_getDisplayName (seqid,iprot,oprot,handler)
  "getFavoriteMidsForChannel" -> process_getFavoriteMidsForChannel (seqid,iprot,oprot,handler)
  "getFriendMids" -> process_getFriendMids (seqid,iprot,oprot,handler)
  "getGroupMemberMids" -> process_getGroupMemberMids (seqid,iprot,oprot,handler)
  "getGroupsForChannel" -> process_getGroupsForChannel (seqid,iprot,oprot,handler)
  "getIdentityCredential" -> process_getIdentityCredential (seqid,iprot,oprot,handler)
  "getJoinedGroupIdsForChannel" -> process_getJoinedGroupIdsForChannel (seqid,iprot,oprot,handler)
  "getMetaProfile" -> process_getMetaProfile (seqid,iprot,oprot,handler)
  "getMid" -> process_getMid (seqid,iprot,oprot,handler)
  "getPrimaryClientForChannel" -> process_getPrimaryClientForChannel (seqid,iprot,oprot,handler)
  "getProfileForChannel" -> process_getProfileForChannel (seqid,iprot,oprot,handler)
  "getSimpleChannelContacts" -> process_getSimpleChannelContacts (seqid,iprot,oprot,handler)
  "getUserCountryForBilling" -> process_getUserCountryForBilling (seqid,iprot,oprot,handler)
  "getUserCreateTime" -> process_getUserCreateTime (seqid,iprot,oprot,handler)
  "getUserIdentities" -> process_getUserIdentities (seqid,iprot,oprot,handler)
  "getUserLanguage" -> process_getUserLanguage (seqid,iprot,oprot,handler)
  "getUserMidsWhoAddedMe" -> process_getUserMidsWhoAddedMe (seqid,iprot,oprot,handler)
  "isGroupMember" -> process_isGroupMember (seqid,iprot,oprot,handler)
  "isInContact" -> process_isInContact (seqid,iprot,oprot,handler)
  "registerChannelCP" -> process_registerChannelCP (seqid,iprot,oprot,handler)
  "removeNotificationStatus" -> process_removeNotificationStatus (seqid,iprot,oprot,handler)
  "sendMessageForChannel" -> process_sendMessageForChannel (seqid,iprot,oprot,handler)
  "sendPinCodeOperation" -> process_sendPinCodeOperation (seqid,iprot,oprot,handler)
  "updateProfileAttributeForChannel" -> process_updateProfileAttributeForChannel (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
