--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'line_ttypes'

TalkServiceClient = __TObject.new(__TClient, {
  __type = 'TalkServiceClient'
})

function TalkServiceClient:searchCollection(query, param)
  self:send_searchCollection(query, param)
  return self:recv_searchCollection(query, param)
end

function TalkServiceClient:send_searchCollection(query, param)
  self.oprot:writeMessageBegin('searchCollection', TMessageType.CALL, self._seqid)
  local args = searchCollection_args:new{}
  args.query = query
  args.param = param
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_searchCollection(query, param)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = searchCollection_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getChatRoomAnnouncementsBulk(chatRoomMids)
  self:send_getChatRoomAnnouncementsBulk(chatRoomMids)
  return self:recv_getChatRoomAnnouncementsBulk(chatRoomMids)
end

function TalkServiceClient:send_getChatRoomAnnouncementsBulk(chatRoomMids)
  self.oprot:writeMessageBegin('getChatRoomAnnouncementsBulk', TMessageType.CALL, self._seqid)
  local args = getChatRoomAnnouncementsBulk_args:new{}
  args.chatRoomMids = chatRoomMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getChatRoomAnnouncementsBulk(chatRoomMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getChatRoomAnnouncementsBulk_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getChatRoomAnnouncements(chatRoomMid)
  self:send_getChatRoomAnnouncements(chatRoomMid)
  return self:recv_getChatRoomAnnouncements(chatRoomMid)
end

function TalkServiceClient:send_getChatRoomAnnouncements(chatRoomMid)
  self.oprot:writeMessageBegin('getChatRoomAnnouncements', TMessageType.CALL, self._seqid)
  local args = getChatRoomAnnouncements_args:new{}
  args.chatRoomMid = chatRoomMid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getChatRoomAnnouncements(chatRoomMid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getChatRoomAnnouncements_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createChatRoomAnnouncement(reqSeq, chatRoomMid, type, contents)
  self:send_createChatRoomAnnouncement(reqSeq, chatRoomMid, type, contents)
  return self:recv_createChatRoomAnnouncement(reqSeq, chatRoomMid, type, contents)
end

function TalkServiceClient:send_createChatRoomAnnouncement(reqSeq, chatRoomMid, type, contents)
  self.oprot:writeMessageBegin('createChatRoomAnnouncement', TMessageType.CALL, self._seqid)
  local args = createChatRoomAnnouncement_args:new{}
  args.reqSeq = reqSeq
  args.chatRoomMid = chatRoomMid
  args.type = type
  args.contents = contents
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createChatRoomAnnouncement(reqSeq, chatRoomMid, type, contents)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createChatRoomAnnouncement_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeChatRoomAnnouncement(reqSeq, chatRoomMid, announcementSeq)
  self:send_removeChatRoomAnnouncement(reqSeq, chatRoomMid, announcementSeq)
  self:recv_removeChatRoomAnnouncement(reqSeq, chatRoomMid, announcementSeq)
end

function TalkServiceClient:send_removeChatRoomAnnouncement(reqSeq, chatRoomMid, announcementSeq)
  self.oprot:writeMessageBegin('removeChatRoomAnnouncement', TMessageType.CALL, self._seqid)
  local args = removeChatRoomAnnouncement_args:new{}
  args.reqSeq = reqSeq
  args.chatRoomMid = chatRoomMid
  args.announcementSeq = announcementSeq
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeChatRoomAnnouncement(reqSeq, chatRoomMid, announcementSeq)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeChatRoomAnnouncement_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unsendMessage(seq, messageId)
  self:send_unsendMessage(seq, messageId)
  self:recv_unsendMessage(seq, messageId)
end

function TalkServiceClient:send_unsendMessage(seq, messageId)
  self.oprot:writeMessageBegin('unsendMessage', TMessageType.CALL, self._seqid)
  local args = unsendMessage_args:new{}
  args.seq = seq
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unsendMessage(seq, messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unsendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:getGroupWithoutMembers(groupId)
  self:send_getGroupWithoutMembers(groupId)
  return self:recv_getGroupWithoutMembers(groupId)
end

function TalkServiceClient:send_getGroupWithoutMembers(groupId)
  self.oprot:writeMessageBegin('getGroupWithoutMembers', TMessageType.CALL, self._seqid)
  local args = getGroupWithoutMembers_args:new{}
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupWithoutMembers(groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupWithoutMembers_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:requestResendMessage(reqSeq, senderMid, messageId)
  self:send_requestResendMessage(reqSeq, senderMid, messageId)
  self:recv_requestResendMessage(reqSeq, senderMid, messageId)
end

function TalkServiceClient:send_requestResendMessage(reqSeq, senderMid, messageId)
  self.oprot:writeMessageBegin('requestResendMessage', TMessageType.CALL, self._seqid)
  local args = requestResendMessage_args:new{}
  args.reqSeq = reqSeq
  args.senderMid = senderMid
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestResendMessage(reqSeq, senderMid, messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestResendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
  self:send_respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
  self:recv_respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
end

function TalkServiceClient:send_respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
  self.oprot:writeMessageBegin('respondResendMessage', TMessageType.CALL, self._seqid)
  local args = respondResendMessage_args:new{}
  args.reqSeq = reqSeq
  args.receiverMid = receiverMid
  args.originalMessageId = originalMessageId
  args.resendMessage = resendMessage
  args.errorCode = errorCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_respondResendMessage(reqSeq, receiverMid, originalMessageId, resendMessage, errorCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = respondResendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acceptGroupInvitation(reqSeq, groupId)
  self:send_acceptGroupInvitation(reqSeq, groupId)
  self:recv_acceptGroupInvitation(reqSeq, groupId)
end

function TalkServiceClient:send_acceptGroupInvitation(reqSeq, groupId)
  self.oprot:writeMessageBegin('acceptGroupInvitation', TMessageType.CALL, self._seqid)
  local args = acceptGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acceptGroupInvitation(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acceptGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acceptGroupInvitationByTicket(reqSeq, GroupMid, ticketId)
  self:send_acceptGroupInvitationByTicket(reqSeq, GroupMid, ticketId)
  self:recv_acceptGroupInvitationByTicket(reqSeq, GroupMid, ticketId)
end

function TalkServiceClient:send_acceptGroupInvitationByTicket(reqSeq, GroupMid, ticketId)
  self.oprot:writeMessageBegin('acceptGroupInvitationByTicket', TMessageType.CALL, self._seqid)
  local args = acceptGroupInvitationByTicket_args:new{}
  args.reqSeq = reqSeq
  args.GroupMid = GroupMid
  args.ticketId = ticketId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acceptGroupInvitationByTicket(reqSeq, GroupMid, ticketId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acceptGroupInvitationByTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acceptProximityMatches(sessionId, ids)
  self:send_acceptProximityMatches(sessionId, ids)
  self:recv_acceptProximityMatches(sessionId, ids)
end

function TalkServiceClient:send_acceptProximityMatches(sessionId, ids)
  self.oprot:writeMessageBegin('acceptProximityMatches', TMessageType.CALL, self._seqid)
  local args = acceptProximityMatches_args:new{}
  args.sessionId = sessionId
  args.ids = ids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acceptProximityMatches(sessionId, ids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acceptProximityMatches_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:acquireCallRoute(to)
  self:send_acquireCallRoute(to)
  return self:recv_acquireCallRoute(to)
end

function TalkServiceClient:send_acquireCallRoute(to)
  self.oprot:writeMessageBegin('acquireCallRoute', TMessageType.CALL, self._seqid)
  local args = acquireCallRoute_args:new{}
  args.to = to
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireCallRoute(to)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireCallRoute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:acquireCallTicket(to)
  self:send_acquireCallTicket(to)
  return self:recv_acquireCallTicket(to)
end

function TalkServiceClient:send_acquireCallTicket(to)
  self.oprot:writeMessageBegin('acquireCallTicket', TMessageType.CALL, self._seqid)
  local args = acquireCallTicket_args:new{}
  args.to = to
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireCallTicket(to)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireCallTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:acquireEncryptedAccessToken(featureType)
  self:send_acquireEncryptedAccessToken(featureType)
  return self:recv_acquireEncryptedAccessToken(featureType)
end

function TalkServiceClient:send_acquireEncryptedAccessToken(featureType)
  self.oprot:writeMessageBegin('acquireEncryptedAccessToken', TMessageType.CALL, self._seqid)
  local args = acquireEncryptedAccessToken_args:new{}
  args.featureType = featureType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_acquireEncryptedAccessToken(featureType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = acquireEncryptedAccessToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:addSnsId(snsIdType, snsAccessToken)
  self:send_addSnsId(snsIdType, snsAccessToken)
  return self:recv_addSnsId(snsIdType, snsAccessToken)
end

function TalkServiceClient:send_addSnsId(snsIdType, snsAccessToken)
  self.oprot:writeMessageBegin('addSnsId', TMessageType.CALL, self._seqid)
  local args = addSnsId_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_addSnsId(snsIdType, snsAccessToken)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = addSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:blockContact(reqSeq, id)
  self:send_blockContact(reqSeq, id)
  self:recv_blockContact(reqSeq, id)
end

function TalkServiceClient:send_blockContact(reqSeq, id)
  self.oprot:writeMessageBegin('blockContact', TMessageType.CALL, self._seqid)
  local args = blockContact_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_blockContact(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = blockContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:blockRecommendation(reqSeq, id)
  self:send_blockRecommendation(reqSeq, id)
  self:recv_blockRecommendation(reqSeq, id)
end

function TalkServiceClient:send_blockRecommendation(reqSeq, id)
  self.oprot:writeMessageBegin('blockRecommendation', TMessageType.CALL, self._seqid)
  local args = blockRecommendation_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_blockRecommendation(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = blockRecommendation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:cancelGroupInvitation(reqSeq, groupId, contactIds)
  self:send_cancelGroupInvitation(reqSeq, groupId, contactIds)
  self:recv_cancelGroupInvitation(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_cancelGroupInvitation(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('cancelGroupInvitation', TMessageType.CALL, self._seqid)
  local args = cancelGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_cancelGroupInvitation(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = cancelGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:changeVerificationMethod(sessionId, method)
  self:send_changeVerificationMethod(sessionId, method)
  return self:recv_changeVerificationMethod(sessionId, method)
end

function TalkServiceClient:send_changeVerificationMethod(sessionId, method)
  self.oprot:writeMessageBegin('changeVerificationMethod', TMessageType.CALL, self._seqid)
  local args = changeVerificationMethod_args:new{}
  args.sessionId = sessionId
  args.method = method
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_changeVerificationMethod(sessionId, method)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = changeVerificationMethod_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:clearIdentityCredential()
  self:send_clearIdentityCredential()
  self:recv_clearIdentityCredential()
end

function TalkServiceClient:send_clearIdentityCredential()
  self.oprot:writeMessageBegin('clearIdentityCredential', TMessageType.CALL, self._seqid)
  local args = clearIdentityCredential_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_clearIdentityCredential()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = clearIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:clearMessageBox(channelId, messageBoxId)
  self:send_clearMessageBox(channelId, messageBoxId)
  self:recv_clearMessageBox(channelId, messageBoxId)
end

function TalkServiceClient:send_clearMessageBox(channelId, messageBoxId)
  self.oprot:writeMessageBegin('clearMessageBox', TMessageType.CALL, self._seqid)
  local args = clearMessageBox_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_clearMessageBox(channelId, messageBoxId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = clearMessageBox_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:closeProximityMatch(sessionId)
  self:send_closeProximityMatch(sessionId)
  self:recv_closeProximityMatch(sessionId)
end

function TalkServiceClient:send_closeProximityMatch(sessionId)
  self.oprot:writeMessageBegin('closeProximityMatch', TMessageType.CALL, self._seqid)
  local args = closeProximityMatch_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_closeProximityMatch(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = closeProximityMatch_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:commitSendMessage(seq, messageId, receiverMids)
  self:send_commitSendMessage(seq, messageId, receiverMids)
  return self:recv_commitSendMessage(seq, messageId, receiverMids)
end

function TalkServiceClient:send_commitSendMessage(seq, messageId, receiverMids)
  self.oprot:writeMessageBegin('commitSendMessage', TMessageType.CALL, self._seqid)
  local args = commitSendMessage_args:new{}
  args.seq = seq
  args.messageId = messageId
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitSendMessage(seq, messageId, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitSendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:commitSendMessages(seq, messageIds, receiverMids)
  self:send_commitSendMessages(seq, messageIds, receiverMids)
  return self:recv_commitSendMessages(seq, messageIds, receiverMids)
end

function TalkServiceClient:send_commitSendMessages(seq, messageIds, receiverMids)
  self.oprot:writeMessageBegin('commitSendMessages', TMessageType.CALL, self._seqid)
  local args = commitSendMessages_args:new{}
  args.seq = seq
  args.messageIds = messageIds
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitSendMessages(seq, messageIds, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitSendMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:commitUpdateProfile(seq, attrs, receiverMids)
  self:send_commitUpdateProfile(seq, attrs, receiverMids)
  return self:recv_commitUpdateProfile(seq, attrs, receiverMids)
end

function TalkServiceClient:send_commitUpdateProfile(seq, attrs, receiverMids)
  self.oprot:writeMessageBegin('commitUpdateProfile', TMessageType.CALL, self._seqid)
  local args = commitUpdateProfile_args:new{}
  args.seq = seq
  args.attrs = attrs
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_commitUpdateProfile(seq, attrs, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = commitUpdateProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:confirmEmail(verifier, pinCode)
  self:send_confirmEmail(verifier, pinCode)
  self:recv_confirmEmail(verifier, pinCode)
end

function TalkServiceClient:send_confirmEmail(verifier, pinCode)
  self.oprot:writeMessageBegin('confirmEmail', TMessageType.CALL, self._seqid)
  local args = confirmEmail_args:new{}
  args.verifier = verifier
  args.pinCode = pinCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_confirmEmail(verifier, pinCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = confirmEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:createGroup(seq, name, contactIds)
  self:send_createGroup(seq, name, contactIds)
  return self:recv_createGroup(seq, name, contactIds)
end

function TalkServiceClient:send_createGroup(seq, name, contactIds)
  self.oprot:writeMessageBegin('createGroup', TMessageType.CALL, self._seqid)
  local args = createGroup_args:new{}
  args.seq = seq
  args.name = name
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createGroup(seq, name, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  self:send_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  return self:recv_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
end

function TalkServiceClient:send_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  self.oprot:writeMessageBegin('createQrcodeBase64Image', TMessageType.CALL, self._seqid)
  local args = createQrcodeBase64Image_args:new{}
  args.url = url
  args.characterSet = characterSet
  args.imageSize = imageSize
  args.x = x
  args.y = y
  args.width = width
  args.height = height
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createQrcodeBase64Image(url, characterSet, imageSize, x, y, width, height)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createQrcodeBase64Image_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createRoom(reqSeq, contactIds)
  self:send_createRoom(reqSeq, contactIds)
  return self:recv_createRoom(reqSeq, contactIds)
end

function TalkServiceClient:send_createRoom(reqSeq, contactIds)
  self.oprot:writeMessageBegin('createRoom', TMessageType.CALL, self._seqid)
  local args = createRoom_args:new{}
  args.reqSeq = reqSeq
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createRoom(reqSeq, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:createSession()
  self:send_createSession()
  return self:recv_createSession()
end

function TalkServiceClient:send_createSession()
  self.oprot:writeMessageBegin('createSession', TMessageType.CALL, self._seqid)
  local args = createSession_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createSession()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchAnnouncements(lastFetchedIndex)
  self:send_fetchAnnouncements(lastFetchedIndex)
  return self:recv_fetchAnnouncements(lastFetchedIndex)
end

function TalkServiceClient:send_fetchAnnouncements(lastFetchedIndex)
  self.oprot:writeMessageBegin('fetchAnnouncements', TMessageType.CALL, self._seqid)
  local args = fetchAnnouncements_args:new{}
  args.lastFetchedIndex = lastFetchedIndex
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchAnnouncements(lastFetchedIndex)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchAnnouncements_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchMessages(localTs, count)
  self:send_fetchMessages(localTs, count)
  return self:recv_fetchMessages(localTs, count)
end

function TalkServiceClient:send_fetchMessages(localTs, count)
  self.oprot:writeMessageBegin('fetchMessages', TMessageType.CALL, self._seqid)
  local args = fetchMessages_args:new{}
  args.localTs = localTs
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchMessages(localTs, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchOperations(localRev, count)
  self:send_fetchOperations(localRev, count)
  return self:recv_fetchOperations(localRev, count)
end

function TalkServiceClient:send_fetchOperations(localRev, count)
  self.oprot:writeMessageBegin('fetchOperations', TMessageType.CALL, self._seqid)
  local args = fetchOperations_args:new{}
  args.localRev = localRev
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchOperations(localRev, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchOperations_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:fetchOps(localRev, count, globalRev, individualRev)
  self:send_fetchOps(localRev, count, globalRev, individualRev)
  return self:recv_fetchOps(localRev, count, globalRev, individualRev)
end

function TalkServiceClient:send_fetchOps(localRev, count, globalRev, individualRev)
  self.oprot:writeMessageBegin('fetchOps', TMessageType.CALL, self._seqid)
  local args = fetchOps_args:new{}
  args.localRev = localRev
  args.count = count
  args.globalRev = globalRev
  args.individualRev = individualRev
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_fetchOps(localRev, count, globalRev, individualRev)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = fetchOps_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByEmail(reqSeq, emails)
  self:send_findAndAddContactsByEmail(reqSeq, emails)
  return self:recv_findAndAddContactsByEmail(reqSeq, emails)
end

function TalkServiceClient:send_findAndAddContactsByEmail(reqSeq, emails)
  self.oprot:writeMessageBegin('findAndAddContactsByEmail', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByEmail_args:new{}
  args.reqSeq = reqSeq
  args.emails = emails
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByEmail(reqSeq, emails)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByMid(reqSeq, mid, type, reference)
  self:send_findAndAddContactsByMid(reqSeq, mid, type, reference)
  return self:recv_findAndAddContactsByMid(reqSeq, mid, type, reference)
end

function TalkServiceClient:send_findAndAddContactsByMid(reqSeq, mid, type, reference)
  self.oprot:writeMessageBegin('findAndAddContactsByMid', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByMid_args:new{}
  args.reqSeq = reqSeq
  args.mid = mid
  args.type = type
  args.reference = reference
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByMid(reqSeq, mid, type, reference)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByMid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findGroupByTicketV2(ticketId)
  self:send_findGroupByTicketV2(ticketId)
  return self:recv_findGroupByTicketV2(ticketId)
end

function TalkServiceClient:send_findGroupByTicketV2(ticketId)
  self.oprot:writeMessageBegin('findGroupByTicketV2', TMessageType.CALL, self._seqid)
  local args = findGroupByTicketV2_args:new{}
  args.ticketId = ticketId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findGroupByTicketV2(ticketId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findGroupByTicketV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findAndAddContactsByPhone(reqSeq, phones)
  self:send_findAndAddContactsByPhone(reqSeq, phones)
  return self:recv_findAndAddContactsByPhone(reqSeq, phones)
end

function TalkServiceClient:send_findAndAddContactsByPhone(reqSeq, phones)
  self.oprot:writeMessageBegin('findAndAddContactsByPhone', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByPhone_args:new{}
  args.reqSeq = reqSeq
  args.phones = phones
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByPhone(reqSeq, phones)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getFriendRequests(direction, lastSeenSeqId)
  self:send_getFriendRequests(direction, lastSeenSeqId)
  return self:recv_getFriendRequests(direction, lastSeenSeqId)
end

function TalkServiceClient:send_getFriendRequests(direction, lastSeenSeqId)
  self.oprot:writeMessageBegin('getFriendRequests', TMessageType.CALL, self._seqid)
  local args = getFriendRequests_args:new{}
  args.direction = direction
  args.lastSeenSeqId = lastSeenSeqId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getFriendRequests(direction, lastSeenSeqId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getFriendRequests_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeFriendRequest(direction, midOrEMid)
  self:send_removeFriendRequest(direction, midOrEMid)
  self:recv_removeFriendRequest(direction, midOrEMid)
end

function TalkServiceClient:send_removeFriendRequest(direction, midOrEMid)
  self.oprot:writeMessageBegin('removeFriendRequest', TMessageType.CALL, self._seqid)
  local args = removeFriendRequest_args:new{}
  args.direction = direction
  args.midOrEMid = midOrEMid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeFriendRequest(direction, midOrEMid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeFriendRequest_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:findAndAddContactsByUserid(reqSeq, userid)
  self:send_findAndAddContactsByUserid(reqSeq, userid)
  return self:recv_findAndAddContactsByUserid(reqSeq, userid)
end

function TalkServiceClient:send_findAndAddContactsByUserid(reqSeq, userid)
  self.oprot:writeMessageBegin('findAndAddContactsByUserid', TMessageType.CALL, self._seqid)
  local args = findAndAddContactsByUserid_args:new{}
  args.reqSeq = reqSeq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactsByUserid(reqSeq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactsByUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactByUserid(userid)
  self:send_findContactByUserid(userid)
  return self:recv_findContactByUserid(userid)
end

function TalkServiceClient:send_findContactByUserid(userid)
  self.oprot:writeMessageBegin('findContactByUserid', TMessageType.CALL, self._seqid)
  local args = findContactByUserid_args:new{}
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactByUserid(userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactByUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactByUserTicket(ticketIdWithTag)
  self:send_findContactByUserTicket(ticketIdWithTag)
  return self:recv_findContactByUserTicket(ticketIdWithTag)
end

function TalkServiceClient:send_findContactByUserTicket(ticketIdWithTag)
  self.oprot:writeMessageBegin('findContactByUserTicket', TMessageType.CALL, self._seqid)
  local args = findContactByUserTicket_args:new{}
  args.ticketIdWithTag = ticketIdWithTag
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactByUserTicket(ticketIdWithTag)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactByUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactsByEmail(emails)
  self:send_findContactsByEmail(emails)
  return self:recv_findContactsByEmail(emails)
end

function TalkServiceClient:send_findContactsByEmail(emails)
  self.oprot:writeMessageBegin('findContactsByEmail', TMessageType.CALL, self._seqid)
  local args = findContactsByEmail_args:new{}
  args.emails = emails
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactsByEmail(emails)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactsByEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findContactsByPhone(phones)
  self:send_findContactsByPhone(phones)
  return self:recv_findContactsByPhone(phones)
end

function TalkServiceClient:send_findContactsByPhone(phones)
  self.oprot:writeMessageBegin('findContactsByPhone', TMessageType.CALL, self._seqid)
  local args = findContactsByPhone_args:new{}
  args.phones = phones
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactsByPhone(phones)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactsByPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  self:send_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  return self:recv_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
end

function TalkServiceClient:send_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  self.oprot:writeMessageBegin('findSnsIdUserStatus', TMessageType.CALL, self._seqid)
  local args = findSnsIdUserStatus_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.udidHash = udidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findSnsIdUserStatus(snsIdType, snsAccessToken, udidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findSnsIdUserStatus_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:finishUpdateVerification(sessionId)
  self:send_finishUpdateVerification(sessionId)
  self:recv_finishUpdateVerification(sessionId)
end

function TalkServiceClient:send_finishUpdateVerification(sessionId)
  self.oprot:writeMessageBegin('finishUpdateVerification', TMessageType.CALL, self._seqid)
  local args = finishUpdateVerification_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_finishUpdateVerification(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = finishUpdateVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:generateUserTicket(expirationTime, maxUseCount)
  self:send_generateUserTicket(expirationTime, maxUseCount)
  return self:recv_generateUserTicket(expirationTime, maxUseCount)
end

function TalkServiceClient:send_generateUserTicket(expirationTime, maxUseCount)
  self.oprot:writeMessageBegin('generateUserTicket', TMessageType.CALL, self._seqid)
  local args = generateUserTicket_args:new{}
  args.expirationTime = expirationTime
  args.maxUseCount = maxUseCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_generateUserTicket(expirationTime, maxUseCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = generateUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:destroyMessage(seq, chatId, messageId, sessionId)
  self:send_destroyMessage(seq, chatId, messageId, sessionId)
  self:recv_destroyMessage(seq, chatId, messageId, sessionId)
end

function TalkServiceClient:send_destroyMessage(seq, chatId, messageId, sessionId)
  self.oprot:writeMessageBegin('destroyMessage', TMessageType.CALL, self._seqid)
  local args = destroyMessage_args:new{}
  args.seq = seq
  args.chatId = chatId
  args.messageId = messageId
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_destroyMessage(seq, chatId, messageId, sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = destroyMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:getAcceptedProximityMatches(sessionId)
  self:send_getAcceptedProximityMatches(sessionId)
  return self:recv_getAcceptedProximityMatches(sessionId)
end

function TalkServiceClient:send_getAcceptedProximityMatches(sessionId)
  self.oprot:writeMessageBegin('getAcceptedProximityMatches', TMessageType.CALL, self._seqid)
  local args = getAcceptedProximityMatches_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAcceptedProximityMatches(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAcceptedProximityMatches_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getActiveBuddySubscriberIds()
  self:send_getActiveBuddySubscriberIds()
  return self:recv_getActiveBuddySubscriberIds()
end

function TalkServiceClient:send_getActiveBuddySubscriberIds()
  self.oprot:writeMessageBegin('getActiveBuddySubscriberIds', TMessageType.CALL, self._seqid)
  local args = getActiveBuddySubscriberIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getActiveBuddySubscriberIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getActiveBuddySubscriberIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAllContactIds()
  self:send_getAllContactIds()
  return self:recv_getAllContactIds()
end

function TalkServiceClient:send_getAllContactIds()
  self.oprot:writeMessageBegin('getAllContactIds', TMessageType.CALL, self._seqid)
  local args = getAllContactIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAllContactIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAllContactIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAuthQrcode(keepLoggedIn, systemName)
  self:send_getAuthQrcode(keepLoggedIn, systemName)
  return self:recv_getAuthQrcode(keepLoggedIn, systemName)
end

function TalkServiceClient:send_getAuthQrcode(keepLoggedIn, systemName)
  self.oprot:writeMessageBegin('getAuthQrcode', TMessageType.CALL, self._seqid)
  local args = getAuthQrcode_args:new{}
  args.keepLoggedIn = keepLoggedIn
  args.systemName = systemName
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAuthQrcode(keepLoggedIn, systemName)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAuthQrcode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedContactIds()
  self:send_getBlockedContactIds()
  return self:recv_getBlockedContactIds()
end

function TalkServiceClient:send_getBlockedContactIds()
  self.oprot:writeMessageBegin('getBlockedContactIds', TMessageType.CALL, self._seqid)
  local args = getBlockedContactIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedContactIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedContactIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithPhoneNumber(sessionId, migrationPincodeSessionId)
  self:send_registerWithPhoneNumber(sessionId, migrationPincodeSessionId)
  return self:recv_registerWithPhoneNumber(sessionId, migrationPincodeSessionId)
end

function TalkServiceClient:send_registerWithPhoneNumber(sessionId, migrationPincodeSessionId)
  self.oprot:writeMessageBegin('registerWithPhoneNumber', TMessageType.CALL, self._seqid)
  local args = registerWithPhoneNumber_args:new{}
  args.sessionId = sessionId
  args.migrationPincodeSessionId = migrationPincodeSessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithPhoneNumber(sessionId, migrationPincodeSessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithPhoneNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted)
  self:send_registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted)
  return self:recv_registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted)
end

function TalkServiceClient:send_registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted)
  self.oprot:writeMessageBegin('registerWithPhoneNumberAndPassword', TMessageType.CALL, self._seqid)
  local args = registerWithPhoneNumberAndPassword_args:new{}
  args.sessionId = sessionId
  args.keynm = keynm
  args.encrypted = encrypted
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithPhoneNumberAndPassword(sessionId, keynm, encrypted)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithPhoneNumberAndPassword_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getAnalyticsInfo()
  self:send_getAnalyticsInfo()
  return self:recv_getAnalyticsInfo()
end

function TalkServiceClient:send_getAnalyticsInfo()
  self.oprot:writeMessageBegin('getAnalyticsInfo', TMessageType.CALL, self._seqid)
  local args = getAnalyticsInfo_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getAnalyticsInfo()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getAnalyticsInfo_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reportClientStatistics(reqSeq, category, count)
  self:send_reportClientStatistics(reqSeq, category, count)
  self:recv_reportClientStatistics(reqSeq, category, count)
end

function TalkServiceClient:send_reportClientStatistics(reqSeq, category, count)
  self.oprot:writeMessageBegin('reportClientStatistics', TMessageType.CALL, self._seqid)
  local args = reportClientStatistics_args:new{}
  args.reqSeq = reqSeq
  args.category = category
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportClientStatistics(reqSeq, category, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportClientStatistics_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin)
  self:send_verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin)
  return self:recv_verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin)
end

function TalkServiceClient:send_verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin)
  self.oprot:writeMessageBegin('verifyPhoneNumberForLogin', TMessageType.CALL, self._seqid)
  local args = verifyPhoneNumberForLogin_args:new{}
  args.verifierFromPhone = verifierFromPhone
  args.pinCodeForPhone = pinCodeForPhone
  args.verifierFromLogin = verifierFromLogin
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyPhoneNumberForLogin(verifierFromPhone, pinCodeForPhone, verifierFromLogin)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyPhoneNumberForLogin_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
  self:send_verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
  return self:recv_verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
end

function TalkServiceClient:send_verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
  self.oprot:writeMessageBegin('verifyPhoneNumber', TMessageType.CALL, self._seqid)
  local args = verifyPhoneNumber_args:new{}
  args.sessionId = sessionId
  args.pinCode = pinCode
  args.udidHash = udidHash
  args.migrationPincodeSessionId = migrationPincodeSessionId
  args.oldUdidHash = oldUdidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyPhoneNumber(sessionId, pinCode, udidHash, migrationPincodeSessionId, oldUdidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyPhoneNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedContactIdsByRange(start, count)
  self:send_getBlockedContactIdsByRange(start, count)
  return self:recv_getBlockedContactIdsByRange(start, count)
end

function TalkServiceClient:send_getBlockedContactIdsByRange(start, count)
  self.oprot:writeMessageBegin('getBlockedContactIdsByRange', TMessageType.CALL, self._seqid)
  local args = getBlockedContactIdsByRange_args:new{}
  args.start = start
  args.count = count
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedContactIdsByRange(start, count)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedContactIdsByRange_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBlockedRecommendationIds()
  self:send_getBlockedRecommendationIds()
  return self:recv_getBlockedRecommendationIds()
end

function TalkServiceClient:send_getBlockedRecommendationIds()
  self.oprot:writeMessageBegin('getBlockedRecommendationIds', TMessageType.CALL, self._seqid)
  local args = getBlockedRecommendationIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBlockedRecommendationIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBlockedRecommendationIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBuddyBlockerIds()
  self:send_getBuddyBlockerIds()
  return self:recv_getBuddyBlockerIds()
end

function TalkServiceClient:send_getBuddyBlockerIds()
  self.oprot:writeMessageBegin('getBuddyBlockerIds', TMessageType.CALL, self._seqid)
  local args = getBuddyBlockerIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBuddyBlockerIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBuddyBlockerIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getBuddyLocation(mid, index)
  self:send_getBuddyLocation(mid, index)
  return self:recv_getBuddyLocation(mid, index)
end

function TalkServiceClient:send_getBuddyLocation(mid, index)
  self.oprot:writeMessageBegin('getBuddyLocation', TMessageType.CALL, self._seqid)
  local args = getBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getBuddyLocation(mid, index)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactContactsModifiedSince(timestamp)
  self:send_getCompactContactsModifiedSince(timestamp)
  return self:recv_getCompactContactsModifiedSince(timestamp)
end

function TalkServiceClient:send_getCompactContactsModifiedSince(timestamp)
  self.oprot:writeMessageBegin('getCompactContactsModifiedSince', TMessageType.CALL, self._seqid)
  local args = getCompactContactsModifiedSince_args:new{}
  args.timestamp = timestamp
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactContactsModifiedSince(timestamp)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactContactsModifiedSince_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactGroup(groupId)
  self:send_getCompactGroup(groupId)
  return self:recv_getCompactGroup(groupId)
end

function TalkServiceClient:send_getCompactGroup(groupId)
  self.oprot:writeMessageBegin('getCompactGroup', TMessageType.CALL, self._seqid)
  local args = getCompactGroup_args:new{}
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactGroup(groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCompactRoom(roomId)
  self:send_getCompactRoom(roomId)
  return self:recv_getCompactRoom(roomId)
end

function TalkServiceClient:send_getCompactRoom(roomId)
  self.oprot:writeMessageBegin('getCompactRoom', TMessageType.CALL, self._seqid)
  local args = getCompactRoom_args:new{}
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCompactRoom(roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCompactRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getContact(id)
  self:send_getContact(id)
  return self:recv_getContact(id)
end

function TalkServiceClient:send_getContact(id)
  self.oprot:writeMessageBegin('getContact', TMessageType.CALL, self._seqid)
  local args = getContact_args:new{}
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getContact(id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getContacts(ids)
  self:send_getContacts(ids)
  return self:recv_getContacts(ids)
end

function TalkServiceClient:send_getContacts(ids)
  self.oprot:writeMessageBegin('getContacts', TMessageType.CALL, self._seqid)
  local args = getContacts_args:new{}
  args.ids = ids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getContacts(ids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getContactWithFriendRequestStatus(id)
  self:send_getContactWithFriendRequestStatus(id)
  return self:recv_getContactWithFriendRequestStatus(id)
end

function TalkServiceClient:send_getContactWithFriendRequestStatus(id)
  self.oprot:writeMessageBegin('getContactWithFriendRequestStatus', TMessageType.CALL, self._seqid)
  local args = getContactWithFriendRequestStatus_args:new{}
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getContactWithFriendRequestStatus(id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getContactWithFriendRequestStatus_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getCountryWithRequestIp()
  self:send_getCountryWithRequestIp()
  return self:recv_getCountryWithRequestIp()
end

function TalkServiceClient:send_getCountryWithRequestIp()
  self.oprot:writeMessageBegin('getCountryWithRequestIp', TMessageType.CALL, self._seqid)
  local args = getCountryWithRequestIp_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getCountryWithRequestIp()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCountryWithRequestIp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getFavoriteMids()
  self:send_getFavoriteMids()
  return self:recv_getFavoriteMids()
end

function TalkServiceClient:send_getFavoriteMids()
  self.oprot:writeMessageBegin('getFavoriteMids', TMessageType.CALL, self._seqid)
  local args = getFavoriteMids_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getFavoriteMids()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getFavoriteMids_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroup(groupId)
  self:send_getGroup(groupId)
  return self:recv_getGroup(groupId)
end

function TalkServiceClient:send_getGroup(groupId)
  self.oprot:writeMessageBegin('getGroup', TMessageType.CALL, self._seqid)
  local args = getGroup_args:new{}
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroup(groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroupIdsInvited()
  self:send_getGroupIdsInvited()
  return self:recv_getGroupIdsInvited()
end

function TalkServiceClient:send_getGroupIdsInvited()
  self.oprot:writeMessageBegin('getGroupIdsInvited', TMessageType.CALL, self._seqid)
  local args = getGroupIdsInvited_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupIdsInvited()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupIdsInvited_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroupIdsJoined()
  self:send_getGroupIdsJoined()
  return self:recv_getGroupIdsJoined()
end

function TalkServiceClient:send_getGroupIdsJoined()
  self.oprot:writeMessageBegin('getGroupIdsJoined', TMessageType.CALL, self._seqid)
  local args = getGroupIdsJoined_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupIdsJoined()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupIdsJoined_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroups(groupIds)
  self:send_getGroups(groupIds)
  return self:recv_getGroups(groupIds)
end

function TalkServiceClient:send_getGroups(groupIds)
  self.oprot:writeMessageBegin('getGroups', TMessageType.CALL, self._seqid)
  local args = getGroups_args:new{}
  args.groupIds = groupIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroups(groupIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroups_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getHiddenContactMids()
  self:send_getHiddenContactMids()
  return self:recv_getHiddenContactMids()
end

function TalkServiceClient:send_getHiddenContactMids()
  self.oprot:writeMessageBegin('getHiddenContactMids', TMessageType.CALL, self._seqid)
  local args = getHiddenContactMids_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getHiddenContactMids()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getHiddenContactMids_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getIdentityIdentifier()
  self:send_getIdentityIdentifier()
  return self:recv_getIdentityIdentifier()
end

function TalkServiceClient:send_getIdentityIdentifier()
  self.oprot:writeMessageBegin('getIdentityIdentifier', TMessageType.CALL, self._seqid)
  local args = getIdentityIdentifier_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getIdentityIdentifier()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getIdentityIdentifier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getLastAnnouncementIndex()
  self:send_getLastAnnouncementIndex()
  return self:recv_getLastAnnouncementIndex()
end

function TalkServiceClient:send_getLastAnnouncementIndex()
  self.oprot:writeMessageBegin('getLastAnnouncementIndex', TMessageType.CALL, self._seqid)
  local args = getLastAnnouncementIndex_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getLastAnnouncementIndex()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getLastAnnouncementIndex_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getLastOpRevision()
  self:send_getLastOpRevision()
  return self:recv_getLastOpRevision()
end

function TalkServiceClient:send_getLastOpRevision()
  self.oprot:writeMessageBegin('getLastOpRevision', TMessageType.CALL, self._seqid)
  local args = getLastOpRevision_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getLastOpRevision()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getLastOpRevision_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSuggestRevisions()
  self:send_getSuggestRevisions()
  return self:recv_getSuggestRevisions()
end

function TalkServiceClient:send_getSuggestRevisions()
  self.oprot:writeMessageBegin('getSuggestRevisions', TMessageType.CALL, self._seqid)
  local args = getSuggestRevisions_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSuggestRevisions()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSuggestRevisions_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount)
  self:send_getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount)
  return self:recv_getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount)
end

function TalkServiceClient:send_getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount)
  self.oprot:writeMessageBegin('getPreviousMessagesV2WithReadCount', TMessageType.CALL, self._seqid)
  local args = getPreviousMessagesV2WithReadCount_args:new{}
  args.messageBoxId = messageBoxId
  args.endMessageId = endMessageId
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getPreviousMessagesV2WithReadCount(messageBoxId, endMessageId, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPreviousMessagesV2WithReadCount_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBox(channelId, messageBoxId, lastMessagesCount)
  self:send_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  return self:recv_getMessageBox(channelId, messageBoxId, lastMessagesCount)
end

function TalkServiceClient:send_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  self.oprot:writeMessageBegin('getMessageBox', TMessageType.CALL, self._seqid)
  local args = getMessageBox_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args.lastMessagesCount = lastMessagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBox(channelId, messageBoxId, lastMessagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBox_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxCompactWrapUp(mid)
  self:send_getMessageBoxCompactWrapUp(mid)
  return self:recv_getMessageBoxCompactWrapUp(mid)
end

function TalkServiceClient:send_getMessageBoxCompactWrapUp(mid)
  self.oprot:writeMessageBegin('getMessageBoxCompactWrapUp', TMessageType.CALL, self._seqid)
  local args = getMessageBoxCompactWrapUp_args:new{}
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxCompactWrapUp(mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxCompactWrapUp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxCompactWrapUpList(start, messageBoxCount)
  self:send_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  return self:recv_getMessageBoxCompactWrapUpList(start, messageBoxCount)
end

function TalkServiceClient:send_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  self.oprot:writeMessageBegin('getMessageBoxCompactWrapUpList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxCompactWrapUpList_args:new{}
  args.start = start
  args.messageBoxCount = messageBoxCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxCompactWrapUpList(start, messageBoxCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxCompactWrapUpList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxList(channelId, lastMessagesCount)
  self:send_getMessageBoxList(channelId, lastMessagesCount)
  return self:recv_getMessageBoxList(channelId, lastMessagesCount)
end

function TalkServiceClient:send_getMessageBoxList(channelId, lastMessagesCount)
  self.oprot:writeMessageBegin('getMessageBoxList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxList_args:new{}
  args.channelId = channelId
  args.lastMessagesCount = lastMessagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxList(channelId, lastMessagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  self:send_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  return self:recv_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
end

function TalkServiceClient:send_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  self.oprot:writeMessageBegin('getMessageBoxListByStatus', TMessageType.CALL, self._seqid)
  local args = getMessageBoxListByStatus_args:new{}
  args.channelId = channelId
  args.lastMessagesCount = lastMessagesCount
  args.status = status
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxListByStatus(channelId, lastMessagesCount, status)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxListByStatus_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxWrapUp(mid)
  self:send_getMessageBoxWrapUp(mid)
  return self:recv_getMessageBoxWrapUp(mid)
end

function TalkServiceClient:send_getMessageBoxWrapUp(mid)
  self.oprot:writeMessageBegin('getMessageBoxWrapUp', TMessageType.CALL, self._seqid)
  local args = getMessageBoxWrapUp_args:new{}
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxWrapUp(mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxWrapUp_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxWrapUpList(start, messageBoxCount)
  self:send_getMessageBoxWrapUpList(start, messageBoxCount)
  return self:recv_getMessageBoxWrapUpList(start, messageBoxCount)
end

function TalkServiceClient:send_getMessageBoxWrapUpList(start, messageBoxCount)
  self.oprot:writeMessageBegin('getMessageBoxWrapUpList', TMessageType.CALL, self._seqid)
  local args = getMessageBoxWrapUpList_args:new{}
  args.start = start
  args.messageBoxCount = messageBoxCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxWrapUpList(start, messageBoxCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxWrapUpList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  self:send_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  return self:recv_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
end

function TalkServiceClient:send_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  self.oprot:writeMessageBegin('getMessagesBySequenceNumber', TMessageType.CALL, self._seqid)
  local args = getMessagesBySequenceNumber_args:new{}
  args.channelId = channelId
  args.messageBoxId = messageBoxId
  args.startSeq = startSeq
  args.endSeq = endSeq
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessagesBySequenceNumber(channelId, messageBoxId, startSeq, endSeq)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessagesBySequenceNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getNextMessages(messageBoxId, startSeq, messagesCount)
  self:send_getNextMessages(messageBoxId, startSeq, messagesCount)
  return self:recv_getNextMessages(messageBoxId, startSeq, messagesCount)
end

function TalkServiceClient:send_getNextMessages(messageBoxId, startSeq, messagesCount)
  self.oprot:writeMessageBegin('getNextMessages', TMessageType.CALL, self._seqid)
  local args = getNextMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.startSeq = startSeq
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getNextMessages(messageBoxId, startSeq, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNextMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getNotificationPolicy(carrier)
  self:send_getNotificationPolicy(carrier)
  return self:recv_getNotificationPolicy(carrier)
end

function TalkServiceClient:send_getNotificationPolicy(carrier)
  self.oprot:writeMessageBegin('getNotificationPolicy', TMessageType.CALL, self._seqid)
  local args = getNotificationPolicy_args:new{}
  args.carrier = carrier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getNotificationPolicy(carrier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNotificationPolicy_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getPreviousMessages(messageBoxId, endSeq, messagesCount)
  self:send_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  return self:recv_getPreviousMessages(messageBoxId, endSeq, messagesCount)
end

function TalkServiceClient:send_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  self.oprot:writeMessageBegin('getPreviousMessages', TMessageType.CALL, self._seqid)
  local args = getPreviousMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.endSeq = endSeq
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getPreviousMessages(messageBoxId, endSeq, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPreviousMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProfile()
  self:send_getProfile()
  return self:recv_getProfile()
end

function TalkServiceClient:send_getProfile()
  self.oprot:writeMessageBegin('getProfile', TMessageType.CALL, self._seqid)
  local args = getProfile_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProfile()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProximityMatchCandidateList(sessionId)
  self:send_getProximityMatchCandidateList(sessionId)
  return self:recv_getProximityMatchCandidateList(sessionId)
end

function TalkServiceClient:send_getProximityMatchCandidateList(sessionId)
  self.oprot:writeMessageBegin('getProximityMatchCandidateList', TMessageType.CALL, self._seqid)
  local args = getProximityMatchCandidateList_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProximityMatchCandidateList(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProximityMatchCandidateList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getProximityMatchCandidates(sessionId)
  self:send_getProximityMatchCandidates(sessionId)
  return self:recv_getProximityMatchCandidates(sessionId)
end

function TalkServiceClient:send_getProximityMatchCandidates(sessionId)
  self.oprot:writeMessageBegin('getProximityMatchCandidates', TMessageType.CALL, self._seqid)
  local args = getProximityMatchCandidates_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getProximityMatchCandidates(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProximityMatchCandidates_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRecentMessages(messageBoxId, messagesCount)
  self:send_getRecentMessages(messageBoxId, messagesCount)
  return self:recv_getRecentMessages(messageBoxId, messagesCount)
end

function TalkServiceClient:send_getRecentMessages(messageBoxId, messagesCount)
  self.oprot:writeMessageBegin('getRecentMessages', TMessageType.CALL, self._seqid)
  local args = getRecentMessages_args:new{}
  args.messageBoxId = messageBoxId
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRecentMessages(messageBoxId, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRecentMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRecommendationIds()
  self:send_getRecommendationIds()
  return self:recv_getRecommendationIds()
end

function TalkServiceClient:send_getRecommendationIds()
  self.oprot:writeMessageBegin('getRecommendationIds', TMessageType.CALL, self._seqid)
  local args = getRecommendationIds_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRecommendationIds()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRecommendationIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRoom(roomId)
  self:send_getRoom(roomId)
  return self:recv_getRoom(roomId)
end

function TalkServiceClient:send_getRoom(roomId)
  self.oprot:writeMessageBegin('getRoom', TMessageType.CALL, self._seqid)
  local args = getRoom_args:new{}
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRoom(roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRSAKeyInfo(provider)
  self:send_getRSAKeyInfo(provider)
  return self:recv_getRSAKeyInfo(provider)
end

function TalkServiceClient:send_getRSAKeyInfo(provider)
  self.oprot:writeMessageBegin('getRSAKeyInfo', TMessageType.CALL, self._seqid)
  local args = getRSAKeyInfo_args:new{}
  args.provider = provider
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRSAKeyInfo(provider)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRSAKeyInfo_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getServerTime()
  self:send_getServerTime()
  return self:recv_getServerTime()
end

function TalkServiceClient:send_getServerTime()
  self.oprot:writeMessageBegin('getServerTime', TMessageType.CALL, self._seqid)
  local args = getServerTime_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getServerTime()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getServerTime_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSessions()
  self:send_getSessions()
  return self:recv_getSessions()
end

function TalkServiceClient:send_getSessions()
  self.oprot:writeMessageBegin('getSessions', TMessageType.CALL, self._seqid)
  local args = getSessions_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSessions()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSessions_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSettings()
  self:send_getSettings()
  return self:recv_getSettings()
end

function TalkServiceClient:send_getSettings()
  self.oprot:writeMessageBegin('getSettings', TMessageType.CALL, self._seqid)
  local args = getSettings_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSettings()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getGroupsV2(groupIds)
  self:send_getGroupsV2(groupIds)
  return self:recv_getGroupsV2(groupIds)
end

function TalkServiceClient:send_getGroupsV2(groupIds)
  self.oprot:writeMessageBegin('getGroupsV2', TMessageType.CALL, self._seqid)
  local args = getGroupsV2_args:new{}
  args.groupIds = groupIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getGroupsV2(groupIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getGroupsV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSettingsAttributes(attrBitset)
  self:send_getSettingsAttributes(attrBitset)
  return self:recv_getSettingsAttributes(attrBitset)
end

function TalkServiceClient:send_getSettingsAttributes(attrBitset)
  self.oprot:writeMessageBegin('getSettingsAttributes', TMessageType.CALL, self._seqid)
  local args = getSettingsAttributes_args:new{}
  args.attrBitset = attrBitset
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSettingsAttributes(attrBitset)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSettingsAttributes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getSystemConfiguration()
  self:send_getSystemConfiguration()
  return self:recv_getSystemConfiguration()
end

function TalkServiceClient:send_getSystemConfiguration()
  self.oprot:writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
  local args = getSystemConfiguration_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getSystemConfiguration()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getSystemConfiguration_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getUserTicket()
  self:send_getUserTicket()
  return self:recv_getUserTicket()
end

function TalkServiceClient:send_getUserTicket()
  self.oprot:writeMessageBegin('getUserTicket', TMessageType.CALL, self._seqid)
  local args = getUserTicket_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getUserTicket()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getWapInvitation(invitationHash)
  self:send_getWapInvitation(invitationHash)
  return self:recv_getWapInvitation(invitationHash)
end

function TalkServiceClient:send_getWapInvitation(invitationHash)
  self.oprot:writeMessageBegin('getWapInvitation', TMessageType.CALL, self._seqid)
  local args = getWapInvitation_args:new{}
  args.invitationHash = invitationHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getWapInvitation(invitationHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getWapInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:invalidateUserTicket()
  self:send_invalidateUserTicket()
  self:recv_invalidateUserTicket()
end

function TalkServiceClient:send_invalidateUserTicket()
  self.oprot:writeMessageBegin('invalidateUserTicket', TMessageType.CALL, self._seqid)
  local args = invalidateUserTicket_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_invalidateUserTicket()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = invalidateUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteFriendsBySms(phoneNumberList)
  self:send_inviteFriendsBySms(phoneNumberList)
  self:recv_inviteFriendsBySms(phoneNumberList)
end

function TalkServiceClient:send_inviteFriendsBySms(phoneNumberList)
  self.oprot:writeMessageBegin('inviteFriendsBySms', TMessageType.CALL, self._seqid)
  local args = inviteFriendsBySms_args:new{}
  args.phoneNumberList = phoneNumberList
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteFriendsBySms(phoneNumberList)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteFriendsBySms_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteIntoGroup(reqSeq, groupId, contactIds)
  self:send_inviteIntoGroup(reqSeq, groupId, contactIds)
  self:recv_inviteIntoGroup(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_inviteIntoGroup(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('inviteIntoGroup', TMessageType.CALL, self._seqid)
  local args = inviteIntoGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteIntoGroup(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteIntoGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteIntoRoom(reqSeq, roomId, contactIds)
  self:send_inviteIntoRoom(reqSeq, roomId, contactIds)
  self:recv_inviteIntoRoom(reqSeq, roomId, contactIds)
end

function TalkServiceClient:send_inviteIntoRoom(reqSeq, roomId, contactIds)
  self.oprot:writeMessageBegin('inviteIntoRoom', TMessageType.CALL, self._seqid)
  local args = inviteIntoRoom_args:new{}
  args.reqSeq = reqSeq
  args.roomId = roomId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteIntoRoom(reqSeq, roomId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteIntoRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:inviteViaEmail(reqSeq, email, name)
  self:send_inviteViaEmail(reqSeq, email, name)
  self:recv_inviteViaEmail(reqSeq, email, name)
end

function TalkServiceClient:send_inviteViaEmail(reqSeq, email, name)
  self.oprot:writeMessageBegin('inviteViaEmail', TMessageType.CALL, self._seqid)
  local args = inviteViaEmail_args:new{}
  args.reqSeq = reqSeq
  args.email = email
  args.name = name
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_inviteViaEmail(reqSeq, email, name)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = inviteViaEmail_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:isIdentityIdentifierAvailable(provider, identifier)
  self:send_isIdentityIdentifierAvailable(provider, identifier)
  return self:recv_isIdentityIdentifierAvailable(provider, identifier)
end

function TalkServiceClient:send_isIdentityIdentifierAvailable(provider, identifier)
  self.oprot:writeMessageBegin('isIdentityIdentifierAvailable', TMessageType.CALL, self._seqid)
  local args = isIdentityIdentifierAvailable_args:new{}
  args.provider = provider
  args.identifier = identifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_isIdentityIdentifierAvailable(provider, identifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = isIdentityIdentifierAvailable_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:isUseridAvailable(userid)
  self:send_isUseridAvailable(userid)
  return self:recv_isUseridAvailable(userid)
end

function TalkServiceClient:send_isUseridAvailable(userid)
  self.oprot:writeMessageBegin('isUseridAvailable', TMessageType.CALL, self._seqid)
  local args = isUseridAvailable_args:new{}
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_isUseridAvailable(userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = isUseridAvailable_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:kickoutFromGroup(reqSeq, groupId, contactIds)
  self:send_kickoutFromGroup(reqSeq, groupId, contactIds)
  self:recv_kickoutFromGroup(reqSeq, groupId, contactIds)
end

function TalkServiceClient:send_kickoutFromGroup(reqSeq, groupId, contactIds)
  self.oprot:writeMessageBegin('kickoutFromGroup', TMessageType.CALL, self._seqid)
  local args = kickoutFromGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_kickoutFromGroup(reqSeq, groupId, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = kickoutFromGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reissueGroupTicket(groupMid)
  self:send_reissueGroupTicket(groupMid)
  return self:recv_reissueGroupTicket(groupMid)
end

function TalkServiceClient:send_reissueGroupTicket(groupMid)
  self.oprot:writeMessageBegin('reissueGroupTicket', TMessageType.CALL, self._seqid)
  local args = reissueGroupTicket_args:new{}
  args.groupMid = groupMid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reissueGroupTicket(groupMid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reissueGroupTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:findGroupByTicket(ticketId)
  self:send_findGroupByTicket(ticketId)
  return self:recv_findGroupByTicket(ticketId)
end

function TalkServiceClient:send_findGroupByTicket(ticketId)
  self.oprot:writeMessageBegin('findGroupByTicket', TMessageType.CALL, self._seqid)
  local args = findGroupByTicket_args:new{}
  args.ticketId = ticketId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findGroupByTicket(ticketId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findGroupByTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:leaveGroup(reqSeq, groupId)
  self:send_leaveGroup(reqSeq, groupId)
  self:recv_leaveGroup(reqSeq, groupId)
end

function TalkServiceClient:send_leaveGroup(reqSeq, groupId)
  self.oprot:writeMessageBegin('leaveGroup', TMessageType.CALL, self._seqid)
  local args = leaveGroup_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_leaveGroup(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = leaveGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:leaveRoom(reqSeq, roomId)
  self:send_leaveRoom(reqSeq, roomId)
  self:recv_leaveRoom(reqSeq, roomId)
end

function TalkServiceClient:send_leaveRoom(reqSeq, roomId)
  self.oprot:writeMessageBegin('leaveRoom', TMessageType.CALL, self._seqid)
  local args = leaveRoom_args:new{}
  args.reqSeq = reqSeq
  args.roomId = roomId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_leaveRoom(reqSeq, roomId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = leaveRoom_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self:send_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  return self:recv_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
end

function TalkServiceClient:send_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self.oprot:writeMessageBegin('loginWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = loginWithIdentityCredential_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args.keepLoggedIn = keepLoggedIn
  args.accessLocation = accessLocation
  args.systemName = systemName
  args.certificate = certificate
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithIdentityCredential(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self:send_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  return self:recv_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
end

function TalkServiceClient:send_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  self.oprot:writeMessageBegin('loginWithIdentityCredentialForCertificate', TMessageType.CALL, self._seqid)
  local args = loginWithIdentityCredentialForCertificate_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args.keepLoggedIn = keepLoggedIn
  args.accessLocation = accessLocation
  args.systemName = systemName
  args.certificate = certificate
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithIdentityCredentialForCertificate(identityProvider, identifier, password, keepLoggedIn, accessLocation, systemName, certificate)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithIdentityCredentialForCertificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifier(verifier)
  self:send_loginWithVerifier(verifier)
  return self:recv_loginWithVerifier(verifier)
end

function TalkServiceClient:send_loginWithVerifier(verifier)
  self.oprot:writeMessageBegin('loginWithVerifier', TMessageType.CALL, self._seqid)
  local args = loginWithVerifier_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifier(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifierForCerificate(verifier)
  self:send_loginWithVerifierForCerificate(verifier)
  return self:recv_loginWithVerifierForCerificate(verifier)
end

function TalkServiceClient:send_loginWithVerifierForCerificate(verifier)
  self.oprot:writeMessageBegin('loginWithVerifierForCerificate', TMessageType.CALL, self._seqid)
  local args = loginWithVerifierForCerificate_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifierForCerificate(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifierForCerificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:loginWithVerifierForCertificate(verifier)
  self:send_loginWithVerifierForCertificate(verifier)
  return self:recv_loginWithVerifierForCertificate(verifier)
end

function TalkServiceClient:send_loginWithVerifierForCertificate(verifier)
  self.oprot:writeMessageBegin('loginWithVerifierForCertificate', TMessageType.CALL, self._seqid)
  local args = loginWithVerifierForCertificate_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_loginWithVerifierForCertificate(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = loginWithVerifierForCertificate_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:logout()
  self:send_logout()
  self:recv_logout()
end

function TalkServiceClient:send_logout()
  self.oprot:writeMessageBegin('logout', TMessageType.CALL, self._seqid)
  local args = logout_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_logout()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = logout_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:logoutSession(tokenKey)
  self:send_logoutSession(tokenKey)
  self:recv_logoutSession(tokenKey)
end

function TalkServiceClient:send_logoutSession(tokenKey)
  self.oprot:writeMessageBegin('logoutSession', TMessageType.CALL, self._seqid)
  local args = logoutSession_args:new{}
  args.tokenKey = tokenKey
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_logoutSession(tokenKey)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = logoutSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:noop()
  self:send_noop()
  self:recv_noop()
end

function TalkServiceClient:send_noop()
  self.oprot:writeMessageBegin('noop', TMessageType.CALL, self._seqid)
  local args = noop_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_noop()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = noop_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifiedRedirect(paramMap)
  self:send_notifiedRedirect(paramMap)
  self:recv_notifiedRedirect(paramMap)
end

function TalkServiceClient:send_notifiedRedirect(paramMap)
  self.oprot:writeMessageBegin('notifiedRedirect', TMessageType.CALL, self._seqid)
  local args = notifiedRedirect_args:new{}
  args.paramMap = paramMap
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifiedRedirect(paramMap)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifiedRedirect_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyBuddyOnAir(seq, receiverMids)
  self:send_notifyBuddyOnAir(seq, receiverMids)
  return self:recv_notifyBuddyOnAir(seq, receiverMids)
end

function TalkServiceClient:send_notifyBuddyOnAir(seq, receiverMids)
  self.oprot:writeMessageBegin('notifyBuddyOnAir', TMessageType.CALL, self._seqid)
  local args = notifyBuddyOnAir_args:new{}
  args.seq = seq
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyBuddyOnAir(seq, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyBuddyOnAir_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:notifyIndividualEvent(notificationStatus, receiverMids)
  self:send_notifyIndividualEvent(notificationStatus, receiverMids)
  self:recv_notifyIndividualEvent(notificationStatus, receiverMids)
end

function TalkServiceClient:send_notifyIndividualEvent(notificationStatus, receiverMids)
  self.oprot:writeMessageBegin('notifyIndividualEvent', TMessageType.CALL, self._seqid)
  local args = notifyIndividualEvent_args:new{}
  args.notificationStatus = notificationStatus
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyIndividualEvent(notificationStatus, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyIndividualEvent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyInstalled(udidHash, applicationTypeWithExtensions)
  self:send_notifyInstalled(udidHash, applicationTypeWithExtensions)
  self:recv_notifyInstalled(udidHash, applicationTypeWithExtensions)
end

function TalkServiceClient:send_notifyInstalled(udidHash, applicationTypeWithExtensions)
  self.oprot:writeMessageBegin('notifyInstalled', TMessageType.CALL, self._seqid)
  local args = notifyInstalled_args:new{}
  args.udidHash = udidHash
  args.applicationTypeWithExtensions = applicationTypeWithExtensions
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyInstalled(udidHash, applicationTypeWithExtensions)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyInstalled_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self:send_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self:recv_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
end

function TalkServiceClient:send_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  self.oprot:writeMessageBegin('notifyRegistrationComplete', TMessageType.CALL, self._seqid)
  local args = notifyRegistrationComplete_args:new{}
  args.udidHash = udidHash
  args.applicationTypeWithExtensions = applicationTypeWithExtensions
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyRegistrationComplete(udidHash, applicationTypeWithExtensions)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyRegistrationComplete_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifySleep(lastRev, badge)
  self:send_notifySleep(lastRev, badge)
  self:recv_notifySleep(lastRev, badge)
end

function TalkServiceClient:send_notifySleep(lastRev, badge)
  self.oprot:writeMessageBegin('notifySleep', TMessageType.CALL, self._seqid)
  local args = notifySleep_args:new{}
  args.lastRev = lastRev
  args.badge = badge
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifySleep(lastRev, badge)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifySleep_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:notifyUpdated(lastRev, deviceInfo)
  self:send_notifyUpdated(lastRev, deviceInfo)
  self:recv_notifyUpdated(lastRev, deviceInfo)
end

function TalkServiceClient:send_notifyUpdated(lastRev, deviceInfo)
  self.oprot:writeMessageBegin('notifyUpdated', TMessageType.CALL, self._seqid)
  local args = notifyUpdated_args:new{}
  args.lastRev = lastRev
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_notifyUpdated(lastRev, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyUpdated_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:openProximityMatch(location)
  self:send_openProximityMatch(location)
  return self:recv_openProximityMatch(location)
end

function TalkServiceClient:send_openProximityMatch(location)
  self.oprot:writeMessageBegin('openProximityMatch', TMessageType.CALL, self._seqid)
  local args = openProximityMatch_args:new{}
  args.location = location
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_openProximityMatch(location)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = openProximityMatch_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerBuddyUser(buddyId, registrarPassword)
  self:send_registerBuddyUser(buddyId, registrarPassword)
  return self:recv_registerBuddyUser(buddyId, registrarPassword)
end

function TalkServiceClient:send_registerBuddyUser(buddyId, registrarPassword)
  self.oprot:writeMessageBegin('registerBuddyUser', TMessageType.CALL, self._seqid)
  local args = registerBuddyUser_args:new{}
  args.buddyId = buddyId
  args.registrarPassword = registrarPassword
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerBuddyUser(buddyId, registrarPassword)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerBuddyUser_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerBuddyUserid(seq, userid)
  self:send_registerBuddyUserid(seq, userid)
  self:recv_registerBuddyUserid(seq, userid)
end

function TalkServiceClient:send_registerBuddyUserid(seq, userid)
  self.oprot:writeMessageBegin('registerBuddyUserid', TMessageType.CALL, self._seqid)
  local args = registerBuddyUserid_args:new{}
  args.seq = seq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerBuddyUserid(seq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerBuddyUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:registerDevice(sessionId)
  self:send_registerDevice(sessionId)
  return self:recv_registerDevice(sessionId)
end

function TalkServiceClient:send_registerDevice(sessionId)
  self.oprot:writeMessageBegin('registerDevice', TMessageType.CALL, self._seqid)
  local args = registerDevice_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDevice(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  self:send_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  return self:recv_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
end

function TalkServiceClient:send_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  self.oprot:writeMessageBegin('registerDeviceWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithIdentityCredential_args:new{}
  args.sessionId = sessionId
  args.provider = provider
  args.identifier = identifier
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithIdentityCredential(sessionId, provider, identifier, verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  self:send_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  return self:recv_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerDeviceWithoutPhoneNumber', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithoutPhoneNumber_args:new{}
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithoutPhoneNumber(region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithoutPhoneNumber_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
  self:send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
  return self:recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
end

function TalkServiceClient:send_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
  self.oprot:writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args:new{}
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.provider = provider
  args.identifier = identifier
  args.verifier = verifier
  args.mid = mid
  args.migrationPincodeSessionId = migrationPincodeSessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerDeviceWithoutPhoneNumberWithIdentityCredential(region, udidHash, deviceInfo, provider, identifier, verifier, mid, migrationPincodeSessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerUserid(reqSeq, userid)
  self:send_registerUserid(reqSeq, userid)
  return self:recv_registerUserid(reqSeq, userid)
end

function TalkServiceClient:send_registerUserid(reqSeq, userid)
  self.oprot:writeMessageBegin('registerUserid', TMessageType.CALL, self._seqid)
  local args = registerUserid_args:new{}
  args.reqSeq = reqSeq
  args.userid = userid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerUserid(reqSeq, userid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerUserid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  self:send_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  return self:recv_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
end

function TalkServiceClient:send_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  self.oprot:writeMessageBegin('registerWapDevice', TMessageType.CALL, self._seqid)
  local args = registerWapDevice_args:new{}
  args.invitationHash = invitationHash
  args.guidHash = guidHash
  args.email = email
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWapDevice(invitationHash, guidHash, email, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWapDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  self:send_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  return self:recv_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerWithExistingSnsIdAndIdentityCredential_args:new{}
  args.identityCredential = identityCredential
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithExistingSnsIdAndIdentityCredential(identityCredential, region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithExistingSnsIdAndIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  self:send_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  return self:recv_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
end

function TalkServiceClient:send_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  self.oprot:writeMessageBegin('registerWithSnsId', TMessageType.CALL, self._seqid)
  local args = registerWithSnsId_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithSnsId(snsIdType, snsAccessToken, region, udidHash, deviceInfo, mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  self:send_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  return self:recv_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
end

function TalkServiceClient:send_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  self.oprot:writeMessageBegin('registerWithSnsIdAndIdentityCredential', TMessageType.CALL, self._seqid)
  local args = registerWithSnsIdAndIdentityCredential_args:new{}
  args.snsIdType = snsIdType
  args.snsAccessToken = snsAccessToken
  args.identityCredential = identityCredential
  args.region = region
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerWithSnsIdAndIdentityCredential(snsIdType, snsAccessToken, identityCredential, region, udidHash, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerWithSnsIdAndIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reissueDeviceCredential()
  self:send_reissueDeviceCredential()
  return self:recv_reissueDeviceCredential()
end

function TalkServiceClient:send_reissueDeviceCredential()
  self.oprot:writeMessageBegin('reissueDeviceCredential', TMessageType.CALL, self._seqid)
  local args = reissueDeviceCredential_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reissueDeviceCredential()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reissueDeviceCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reissueUserTicket(expirationTime, maxUseCount)
  self:send_reissueUserTicket(expirationTime, maxUseCount)
  return self:recv_reissueUserTicket(expirationTime, maxUseCount)
end

function TalkServiceClient:send_reissueUserTicket(expirationTime, maxUseCount)
  self.oprot:writeMessageBegin('reissueUserTicket', TMessageType.CALL, self._seqid)
  local args = reissueUserTicket_args:new{}
  args.expirationTime = expirationTime
  args.maxUseCount = maxUseCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reissueUserTicket(expirationTime, maxUseCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reissueUserTicket_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageReadRange(chatIds)
  self:send_getMessageReadRange(chatIds)
  return self:recv_getMessageReadRange(chatIds)
end

function TalkServiceClient:send_getMessageReadRange(chatIds)
  self.oprot:writeMessageBegin('getMessageReadRange', TMessageType.CALL, self._seqid)
  local args = getMessageReadRange_args:new{}
  args.chatIds = chatIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageReadRange(chatIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageReadRange_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:rejectGroupInvitation(reqSeq, groupId)
  self:send_rejectGroupInvitation(reqSeq, groupId)
  self:recv_rejectGroupInvitation(reqSeq, groupId)
end

function TalkServiceClient:send_rejectGroupInvitation(reqSeq, groupId)
  self.oprot:writeMessageBegin('rejectGroupInvitation', TMessageType.CALL, self._seqid)
  local args = rejectGroupInvitation_args:new{}
  args.reqSeq = reqSeq
  args.groupId = groupId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_rejectGroupInvitation(reqSeq, groupId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = rejectGroupInvitation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:releaseSession()
  self:send_releaseSession()
  self:recv_releaseSession()
end

function TalkServiceClient:send_releaseSession()
  self.oprot:writeMessageBegin('releaseSession', TMessageType.CALL, self._seqid)
  local args = releaseSession_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_releaseSession()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = releaseSession_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeAllMessages(seq, lastMessageId)
  self:send_removeAllMessages(seq, lastMessageId)
  self:recv_removeAllMessages(seq, lastMessageId)
end

function TalkServiceClient:send_removeAllMessages(seq, lastMessageId)
  self.oprot:writeMessageBegin('removeAllMessages', TMessageType.CALL, self._seqid)
  local args = removeAllMessages_args:new{}
  args.seq = seq
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeAllMessages(seq, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeAllMessages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeBuddyLocation(mid, index)
  self:send_removeBuddyLocation(mid, index)
  self:recv_removeBuddyLocation(mid, index)
end

function TalkServiceClient:send_removeBuddyLocation(mid, index)
  self.oprot:writeMessageBegin('removeBuddyLocation', TMessageType.CALL, self._seqid)
  local args = removeBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeBuddyLocation(mid, index)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeMessage(messageId)
  self:send_removeMessage(messageId)
  return self:recv_removeMessage(messageId)
end

function TalkServiceClient:send_removeMessage(messageId)
  self.oprot:writeMessageBegin('removeMessage', TMessageType.CALL, self._seqid)
  local args = removeMessage_args:new{}
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeMessage(messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:makeUserAddMyselfAsContact(contactOwnerMid)
  self:send_makeUserAddMyselfAsContact(contactOwnerMid)
  return self:recv_makeUserAddMyselfAsContact(contactOwnerMid)
end

function TalkServiceClient:send_makeUserAddMyselfAsContact(contactOwnerMid)
  self.oprot:writeMessageBegin('makeUserAddMyselfAsContact', TMessageType.CALL, self._seqid)
  local args = makeUserAddMyselfAsContact_args:new{}
  args.contactOwnerMid = contactOwnerMid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_makeUserAddMyselfAsContact(contactOwnerMid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = makeUserAddMyselfAsContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeMessageFromMyHome(messageId)
  self:send_removeMessageFromMyHome(messageId)
  return self:recv_removeMessageFromMyHome(messageId)
end

function TalkServiceClient:send_removeMessageFromMyHome(messageId)
  self.oprot:writeMessageBegin('removeMessageFromMyHome', TMessageType.CALL, self._seqid)
  local args = removeMessageFromMyHome_args:new{}
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeMessageFromMyHome(messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeMessageFromMyHome_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:removeSnsId(snsIdType)
  self:send_removeSnsId(snsIdType)
  return self:recv_removeSnsId(snsIdType)
end

function TalkServiceClient:send_removeSnsId(snsIdType)
  self.oprot:writeMessageBegin('removeSnsId', TMessageType.CALL, self._seqid)
  local args = removeSnsId_args:new{}
  args.snsIdType = snsIdType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeSnsId(snsIdType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeSnsId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:report(syncOpRevision, category, report)
  self:send_report(syncOpRevision, category, report)
  self:recv_report(syncOpRevision, category, report)
end

function TalkServiceClient:send_report(syncOpRevision, category, report)
  self.oprot:writeMessageBegin('report', TMessageType.CALL, self._seqid)
  local args = report_args:new{}
  args.syncOpRevision = syncOpRevision
  args.category = category
  args.report = report
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_report(syncOpRevision, category, report)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = report_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportContacts(syncOpRevision, category, contactReports, actionType)
  self:send_reportContacts(syncOpRevision, category, contactReports, actionType)
  return self:recv_reportContacts(syncOpRevision, category, contactReports, actionType)
end

function TalkServiceClient:send_reportContacts(syncOpRevision, category, contactReports, actionType)
  self.oprot:writeMessageBegin('reportContacts', TMessageType.CALL, self._seqid)
  local args = reportContacts_args:new{}
  args.syncOpRevision = syncOpRevision
  args.category = category
  args.contactReports = contactReports
  args.actionType = actionType
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportContacts(syncOpRevision, category, contactReports, actionType)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reportGroups(syncOpRevision, groups)
  self:send_reportGroups(syncOpRevision, groups)
  self:recv_reportGroups(syncOpRevision, groups)
end

function TalkServiceClient:send_reportGroups(syncOpRevision, groups)
  self.oprot:writeMessageBegin('reportGroups', TMessageType.CALL, self._seqid)
  local args = reportGroups_args:new{}
  args.syncOpRevision = syncOpRevision
  args.groups = groups
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportGroups(syncOpRevision, groups)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportGroups_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportProfile(syncOpRevision, profile)
  self:send_reportProfile(syncOpRevision, profile)
  self:recv_reportProfile(syncOpRevision, profile)
end

function TalkServiceClient:send_reportProfile(syncOpRevision, profile)
  self.oprot:writeMessageBegin('reportProfile', TMessageType.CALL, self._seqid)
  local args = reportProfile_args:new{}
  args.syncOpRevision = syncOpRevision
  args.profile = profile
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportProfile(syncOpRevision, profile)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportRooms(syncOpRevision, rooms)
  self:send_reportRooms(syncOpRevision, rooms)
  self:recv_reportRooms(syncOpRevision, rooms)
end

function TalkServiceClient:send_reportRooms(syncOpRevision, rooms)
  self.oprot:writeMessageBegin('reportRooms', TMessageType.CALL, self._seqid)
  local args = reportRooms_args:new{}
  args.syncOpRevision = syncOpRevision
  args.rooms = rooms
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportRooms(syncOpRevision, rooms)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportRooms_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:findAndAddContactByMetaTag(reqSeq, userid, reference)
  self:send_findAndAddContactByMetaTag(reqSeq, userid, reference)
  return self:recv_findAndAddContactByMetaTag(reqSeq, userid, reference)
end

function TalkServiceClient:send_findAndAddContactByMetaTag(reqSeq, userid, reference)
  self.oprot:writeMessageBegin('findAndAddContactByMetaTag', TMessageType.CALL, self._seqid)
  local args = findAndAddContactByMetaTag_args:new{}
  args.reqSeq = reqSeq
  args.userid = userid
  args.reference = reference
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findAndAddContactByMetaTag(reqSeq, userid, reference)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findAndAddContactByMetaTag_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:reportSettings(syncOpRevision, settings)
  self:send_reportSettings(syncOpRevision, settings)
  self:recv_reportSettings(syncOpRevision, settings)
end

function TalkServiceClient:send_reportSettings(syncOpRevision, settings)
  self.oprot:writeMessageBegin('reportSettings', TMessageType.CALL, self._seqid)
  local args = reportSettings_args:new{}
  args.syncOpRevision = syncOpRevision
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportSettings(syncOpRevision, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
  self:send_reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
  self:recv_reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
end

function TalkServiceClient:send_reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
  self.oprot:writeMessageBegin('reportSpam', TMessageType.CALL, self._seqid)
  local args = reportSpam_args:new{}
  args.chatMid = chatMid
  args.memberMids = memberMids
  args.spammerReasons = spammerReasons
  args.senderMids = senderMids
  args.spamMessageIds = spamMessageIds
  args.spamMessages = spamMessages
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportSpam(chatMid, memberMids, spammerReasons, senderMids, spamMessageIds, spamMessages)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportSpam_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self:send_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self:recv_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
end

function TalkServiceClient:send_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  self.oprot:writeMessageBegin('reportSpammer', TMessageType.CALL, self._seqid)
  local args = reportSpammer_args:new{}
  args.spammerMid = spammerMid
  args.spammerReasons = spammerReasons
  args.spamMessageIds = spamMessageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_reportSpammer(spammerMid, spammerReasons, spamMessageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reportSpammer_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:requestAccountPasswordReset(provider, identifier, locale)
  self:send_requestAccountPasswordReset(provider, identifier, locale)
  self:recv_requestAccountPasswordReset(provider, identifier, locale)
end

function TalkServiceClient:send_requestAccountPasswordReset(provider, identifier, locale)
  self.oprot:writeMessageBegin('requestAccountPasswordReset', TMessageType.CALL, self._seqid)
  local args = requestAccountPasswordReset_args:new{}
  args.provider = provider
  args.identifier = identifier
  args.locale = locale
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestAccountPasswordReset(provider, identifier, locale)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestAccountPasswordReset_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:requestEmailConfirmation(emailConfirmation)
  self:send_requestEmailConfirmation(emailConfirmation)
  return self:recv_requestEmailConfirmation(emailConfirmation)
end

function TalkServiceClient:send_requestEmailConfirmation(emailConfirmation)
  self.oprot:writeMessageBegin('requestEmailConfirmation', TMessageType.CALL, self._seqid)
  local args = requestEmailConfirmation_args:new{}
  args.emailConfirmation = emailConfirmation
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestEmailConfirmation(emailConfirmation)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestEmailConfirmation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:requestIdentityUnbind(provider, identifier)
  self:send_requestIdentityUnbind(provider, identifier)
  self:recv_requestIdentityUnbind(provider, identifier)
end

function TalkServiceClient:send_requestIdentityUnbind(provider, identifier)
  self.oprot:writeMessageBegin('requestIdentityUnbind', TMessageType.CALL, self._seqid)
  local args = requestIdentityUnbind_args:new{}
  args.provider = provider
  args.identifier = identifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestIdentityUnbind(provider, identifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestIdentityUnbind_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:resendEmailConfirmation(verifier)
  self:send_resendEmailConfirmation(verifier)
  return self:recv_resendEmailConfirmation(verifier)
end

function TalkServiceClient:send_resendEmailConfirmation(verifier)
  self.oprot:writeMessageBegin('resendEmailConfirmation', TMessageType.CALL, self._seqid)
  local args = resendEmailConfirmation_args:new{}
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendEmailConfirmation(verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendEmailConfirmation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:resendPinCode(sessionId)
  self:send_resendPinCode(sessionId)
  self:recv_resendPinCode(sessionId)
end

function TalkServiceClient:send_resendPinCode(sessionId)
  self.oprot:writeMessageBegin('resendPinCode', TMessageType.CALL, self._seqid)
  local args = resendPinCode_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendPinCode(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendPinCode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:resendPinCodeBySMS(sessionId)
  self:send_resendPinCodeBySMS(sessionId)
  self:recv_resendPinCodeBySMS(sessionId)
end

function TalkServiceClient:send_resendPinCodeBySMS(sessionId)
  self.oprot:writeMessageBegin('resendPinCodeBySMS', TMessageType.CALL, self._seqid)
  local args = resendPinCodeBySMS_args:new{}
  args.sessionId = sessionId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_resendPinCodeBySMS(sessionId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = resendPinCodeBySMS_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendChatChecked(seq, consumer, lastMessageId)
  self:send_sendChatChecked(seq, consumer, lastMessageId)
  self:recv_sendChatChecked(seq, consumer, lastMessageId)
end

function TalkServiceClient:send_sendChatChecked(seq, consumer, lastMessageId)
  self.oprot:writeMessageBegin('sendChatChecked', TMessageType.CALL, self._seqid)
  local args = sendChatChecked_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendChatChecked(seq, consumer, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendChatChecked_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendMessageAwaitCommit(seq, message)
  self:send_sendMessageAwaitCommit(seq, message)
  return self:recv_sendMessageAwaitCommit(seq, message)
end

function TalkServiceClient:send_sendMessageAwaitCommit(seq, message)
  self.oprot:writeMessageBegin('sendMessageAwaitCommit', TMessageType.CALL, self._seqid)
  local args = sendMessageAwaitCommit_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageAwaitCommit(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageAwaitCommit_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendChatRemoved(seq, consumer, lastMessageId)
  self:send_sendChatRemoved(seq, consumer, lastMessageId)
  self:recv_sendChatRemoved(seq, consumer, lastMessageId)
end

function TalkServiceClient:send_sendChatRemoved(seq, consumer, lastMessageId)
  self.oprot:writeMessageBegin('sendChatRemoved', TMessageType.CALL, self._seqid)
  local args = sendChatRemoved_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.lastMessageId = lastMessageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendChatRemoved(seq, consumer, lastMessageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendChatRemoved_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendContentPreviewUpdated(esq, messageId, receiverMids)
  self:send_sendContentPreviewUpdated(esq, messageId, receiverMids)
  return self:recv_sendContentPreviewUpdated(esq, messageId, receiverMids)
end

function TalkServiceClient:send_sendContentPreviewUpdated(esq, messageId, receiverMids)
  self.oprot:writeMessageBegin('sendContentPreviewUpdated', TMessageType.CALL, self._seqid)
  local args = sendContentPreviewUpdated_args:new{}
  args.esq = esq
  args.messageId = messageId
  args.receiverMids = receiverMids
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendContentPreviewUpdated(esq, messageId, receiverMids)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendContentPreviewUpdated_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendContentReceipt(seq, consumer, messageId)
  self:send_sendContentReceipt(seq, consumer, messageId)
  self:recv_sendContentReceipt(seq, consumer, messageId)
end

function TalkServiceClient:send_sendContentReceipt(seq, consumer, messageId)
  self.oprot:writeMessageBegin('sendContentReceipt', TMessageType.CALL, self._seqid)
  local args = sendContentReceipt_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageId = messageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendContentReceipt(seq, consumer, messageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendContentReceipt_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendDummyPush()
  self:send_sendDummyPush()
  self:recv_sendDummyPush()
end

function TalkServiceClient:send_sendDummyPush()
  self.oprot:writeMessageBegin('sendDummyPush', TMessageType.CALL, self._seqid)
  local args = sendDummyPush_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendDummyPush()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendDummyPush_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:removeE2EEPublicKey(publicKey)
  self:send_removeE2EEPublicKey(publicKey)
  self:recv_removeE2EEPublicKey(publicKey)
end

function TalkServiceClient:send_removeE2EEPublicKey(publicKey)
  self.oprot:writeMessageBegin('removeE2EEPublicKey', TMessageType.CALL, self._seqid)
  local args = removeE2EEPublicKey_args:new{}
  args.publicKey = publicKey
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_removeE2EEPublicKey(publicKey)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = removeE2EEPublicKey_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:negotiateE2EEPublicKey(mid)
  self:send_negotiateE2EEPublicKey(mid)
  return self:recv_negotiateE2EEPublicKey(mid)
end

function TalkServiceClient:send_negotiateE2EEPublicKey(mid)
  self.oprot:writeMessageBegin('negotiateE2EEPublicKey', TMessageType.CALL, self._seqid)
  local args = negotiateE2EEPublicKey_args:new{}
  args.mid = mid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_negotiateE2EEPublicKey(mid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = negotiateE2EEPublicKey_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getE2EEPublicKey(mid, version, keyId)
  self:send_getE2EEPublicKey(mid, version, keyId)
  return self:recv_getE2EEPublicKey(mid, version, keyId)
end

function TalkServiceClient:send_getE2EEPublicKey(mid, version, keyId)
  self.oprot:writeMessageBegin('getE2EEPublicKey', TMessageType.CALL, self._seqid)
  local args = getE2EEPublicKey_args:new{}
  args.mid = mid
  args.version = version
  args.keyId = keyId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getE2EEPublicKey(mid, version, keyId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getE2EEPublicKey_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier)
  self:send_requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier)
  self:recv_requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier)
end

function TalkServiceClient:send_requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier)
  self.oprot:writeMessageBegin('requestE2EEKeyExchange', TMessageType.CALL, self._seqid)
  local args = requestE2EEKeyExchange_args:new{}
  args.reqSeq = reqSeq
  args.temporalPublicKey = temporalPublicKey
  args.publicKey = publicKey
  args.verifier = verifier
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_requestE2EEKeyExchange(reqSeq, temporalPublicKey, publicKey, verifier)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = requestE2EEKeyExchange_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:getLastE2EEPublicKeys(chatMid)
  self:send_getLastE2EEPublicKeys(chatMid)
  return self:recv_getLastE2EEPublicKeys(chatMid)
end

function TalkServiceClient:send_getLastE2EEPublicKeys(chatMid)
  self.oprot:writeMessageBegin('getLastE2EEPublicKeys', TMessageType.CALL, self._seqid)
  local args = getLastE2EEPublicKeys_args:new{}
  args.chatMid = chatMid
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getLastE2EEPublicKeys(chatMid)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getLastE2EEPublicKeys_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:registerE2EEPublicKey(reqSeq, publicKey)
  self:send_registerE2EEPublicKey(reqSeq, publicKey)
  return self:recv_registerE2EEPublicKey(reqSeq, publicKey)
end

function TalkServiceClient:send_registerE2EEPublicKey(reqSeq, publicKey)
  self.oprot:writeMessageBegin('registerE2EEPublicKey', TMessageType.CALL, self._seqid)
  local args = registerE2EEPublicKey_args:new{}
  args.reqSeq = reqSeq
  args.publicKey = publicKey
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_registerE2EEPublicKey(reqSeq, publicKey)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = registerE2EEPublicKey_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getE2EEPublicKeys()
  self:send_getE2EEPublicKeys()
  return self:recv_getE2EEPublicKeys()
end

function TalkServiceClient:send_getE2EEPublicKeys()
  self.oprot:writeMessageBegin('getE2EEPublicKeys', TMessageType.CALL, self._seqid)
  local args = getE2EEPublicKeys_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getE2EEPublicKeys()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getE2EEPublicKeys_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getE2EEPublicKeysEx(ignoreE2EEStatus)
  self:send_getE2EEPublicKeysEx(ignoreE2EEStatus)
  return self:recv_getE2EEPublicKeysEx(ignoreE2EEStatus)
end

function TalkServiceClient:send_getE2EEPublicKeysEx(ignoreE2EEStatus)
  self.oprot:writeMessageBegin('getE2EEPublicKeysEx', TMessageType.CALL, self._seqid)
  local args = getE2EEPublicKeysEx_args:new{}
  args.ignoreE2EEStatus = ignoreE2EEStatus
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getE2EEPublicKeysEx(ignoreE2EEStatus)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getE2EEPublicKeysEx_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getReadMessageOpsInBulk(chatIds)
  self:send_getReadMessageOpsInBulk(chatIds)
  return self:recv_getReadMessageOpsInBulk(chatIds)
end

function TalkServiceClient:send_getReadMessageOpsInBulk(chatIds)
  self.oprot:writeMessageBegin('getReadMessageOpsInBulk', TMessageType.CALL, self._seqid)
  local args = getReadMessageOpsInBulk_args:new{}
  args.chatIds = chatIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getReadMessageOpsInBulk(chatIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getReadMessageOpsInBulk_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendEvent(seq, message)
  self:send_sendEvent(seq, message)
  return self:recv_sendEvent(seq, message)
end

function TalkServiceClient:send_sendEvent(seq, message)
  self.oprot:writeMessageBegin('sendEvent', TMessageType.CALL, self._seqid)
  local args = sendEvent_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendEvent(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendEvent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendMessage(seq, message)
  self:send_sendMessage(seq, message)
  return self:recv_sendMessage(seq, message)
end

function TalkServiceClient:send_sendMessage(seq, message)
  self.oprot:writeMessageBegin('sendMessage', TMessageType.CALL, self._seqid)
  local args = sendMessage_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessage(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendMessageIgnored(seq, consumer, messageIds)
  self:send_sendMessageIgnored(seq, consumer, messageIds)
  self:recv_sendMessageIgnored(seq, consumer, messageIds)
end

function TalkServiceClient:send_sendMessageIgnored(seq, consumer, messageIds)
  self.oprot:writeMessageBegin('sendMessageIgnored', TMessageType.CALL, self._seqid)
  local args = sendMessageIgnored_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageIds = messageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageIgnored(seq, consumer, messageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageIgnored_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:sendMessageReceipt(seq, consumer, messageIds)
  self:send_sendMessageReceipt(seq, consumer, messageIds)
  self:recv_sendMessageReceipt(seq, consumer, messageIds)
end

function TalkServiceClient:send_sendMessageReceipt(seq, consumer, messageIds)
  self.oprot:writeMessageBegin('sendMessageReceipt', TMessageType.CALL, self._seqid)
  local args = sendMessageReceipt_args:new{}
  args.seq = seq
  args.consumer = consumer
  args.messageIds = messageIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageReceipt(seq, consumer, messageIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageReceipt_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:findContactByMetaTag(userid, reference)
  self:send_findContactByMetaTag(userid, reference)
  return self:recv_findContactByMetaTag(userid, reference)
end

function TalkServiceClient:send_findContactByMetaTag(userid, reference)
  self.oprot:writeMessageBegin('findContactByMetaTag', TMessageType.CALL, self._seqid)
  local args = findContactByMetaTag_args:new{}
  args.userid = userid
  args.reference = reference
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_findContactByMetaTag(userid, reference)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = findContactByMetaTag_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:sendMessageToMyHome(seq, message)
  self:send_sendMessageToMyHome(seq, message)
  return self:recv_sendMessageToMyHome(seq, message)
end

function TalkServiceClient:send_sendMessageToMyHome(seq, message)
  self.oprot:writeMessageBegin('sendMessageToMyHome', TMessageType.CALL, self._seqid)
  local args = sendMessageToMyHome_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_sendMessageToMyHome(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = sendMessageToMyHome_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:setBuddyLocation(mid, index, location)
  self:send_setBuddyLocation(mid, index, location)
  self:recv_setBuddyLocation(mid, index, location)
end

function TalkServiceClient:send_setBuddyLocation(mid, index, location)
  self.oprot:writeMessageBegin('setBuddyLocation', TMessageType.CALL, self._seqid)
  local args = setBuddyLocation_args:new{}
  args.mid = mid
  args.index = index
  args.location = location
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setBuddyLocation(mid, index, location)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setBuddyLocation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:setIdentityCredential(identifier, verifier, provider)
  self:send_setIdentityCredential(identifier, verifier, provider)
  self:recv_setIdentityCredential(identifier, verifier, provider)
end

function TalkServiceClient:send_setIdentityCredential(identifier, verifier, provider)
  self.oprot:writeMessageBegin('setIdentityCredential', TMessageType.CALL, self._seqid)
  local args = setIdentityCredential_args:new{}
  args.identifier = identifier
  args.verifier = verifier
  args.provider = provider
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setIdentityCredential(identifier, verifier, provider)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:setNotificationsEnabled(reqSeq, type, target, enablement)
  self:send_setNotificationsEnabled(reqSeq, type, target, enablement)
  self:recv_setNotificationsEnabled(reqSeq, type, target, enablement)
end

function TalkServiceClient:send_setNotificationsEnabled(reqSeq, type, target, enablement)
  self.oprot:writeMessageBegin('setNotificationsEnabled', TMessageType.CALL, self._seqid)
  local args = setNotificationsEnabled_args:new{}
  args.reqSeq = reqSeq
  args.type = type
  args.target = target
  args.enablement = enablement
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_setNotificationsEnabled(reqSeq, type, target, enablement)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = setNotificationsEnabled_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  self:send_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  return self:recv_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
end

function TalkServiceClient:send_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  self.oprot:writeMessageBegin('startUpdateVerification', TMessageType.CALL, self._seqid)
  local args = startUpdateVerification_args:new{}
  args.region = region
  args.carrier = carrier
  args.phone = phone
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.networkCode = networkCode
  args.locale = locale
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_startUpdateVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, locale)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = startUpdateVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
  self:send_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
  return self:recv_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
end

function TalkServiceClient:send_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
  self.oprot:writeMessageBegin('startVerification', TMessageType.CALL, self._seqid)
  local args = startVerification_args:new{}
  args.region = region
  args.carrier = carrier
  args.phone = phone
  args.udidHash = udidHash
  args.deviceInfo = deviceInfo
  args.networkCode = networkCode
  args.mid = mid
  args.locale = locale
  args.simInfo = simInfo
  args.oldUdidHash = oldUdidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_startVerification(region, carrier, phone, udidHash, deviceInfo, networkCode, mid, locale, simInfo, oldUdidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = startVerification_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs)
  self:send_updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs)
  self:recv_updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs)
end

function TalkServiceClient:send_updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs)
  self.oprot:writeMessageBegin('updateGroupPreferenceAttribute', TMessageType.CALL, self._seqid)
  local args = updateGroupPreferenceAttribute_args:new{}
  args.reqSeq = reqSeq
  args.groupMid = groupMid
  args.updatedAttrs = updatedAttrs
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateGroupPreferenceAttribute(reqSeq, groupMid, updatedAttrs)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateGroupPreferenceAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:createRoomV2(reqSeq, contactIds)
  self:send_createRoomV2(reqSeq, contactIds)
  return self:recv_createRoomV2(reqSeq, contactIds)
end

function TalkServiceClient:send_createRoomV2(reqSeq, contactIds)
  self.oprot:writeMessageBegin('createRoomV2', TMessageType.CALL, self._seqid)
  local args = createRoomV2_args:new{}
  args.reqSeq = reqSeq
  args.contactIds = contactIds
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_createRoomV2(reqSeq, contactIds)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = createRoomV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:storeUpdateProfileAttribute(seq, profileAttribute, value)
  self:send_storeUpdateProfileAttribute(seq, profileAttribute, value)
  self:recv_storeUpdateProfileAttribute(seq, profileAttribute, value)
end

function TalkServiceClient:send_storeUpdateProfileAttribute(seq, profileAttribute, value)
  self.oprot:writeMessageBegin('storeUpdateProfileAttribute', TMessageType.CALL, self._seqid)
  local args = storeUpdateProfileAttribute_args:new{}
  args.seq = seq
  args.profileAttribute = profileAttribute
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_storeUpdateProfileAttribute(seq, profileAttribute, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = storeUpdateProfileAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:syncContactBySnsIds(reqSeq, modifications)
  self:send_syncContactBySnsIds(reqSeq, modifications)
  return self:recv_syncContactBySnsIds(reqSeq, modifications)
end

function TalkServiceClient:send_syncContactBySnsIds(reqSeq, modifications)
  self.oprot:writeMessageBegin('syncContactBySnsIds', TMessageType.CALL, self._seqid)
  local args = syncContactBySnsIds_args:new{}
  args.reqSeq = reqSeq
  args.modifications = modifications
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_syncContactBySnsIds(reqSeq, modifications)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = syncContactBySnsIds_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:syncContacts(reqSeq, localContacts)
  self:send_syncContacts(reqSeq, localContacts)
  return self:recv_syncContacts(reqSeq, localContacts)
end

function TalkServiceClient:send_syncContacts(reqSeq, localContacts)
  self.oprot:writeMessageBegin('syncContacts', TMessageType.CALL, self._seqid)
  local args = syncContacts_args:new{}
  args.reqSeq = reqSeq
  args.localContacts = localContacts
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_syncContacts(reqSeq, localContacts)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = syncContacts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:trySendMessage(seq, message)
  self:send_trySendMessage(seq, message)
  return self:recv_trySendMessage(seq, message)
end

function TalkServiceClient:send_trySendMessage(seq, message)
  self.oprot:writeMessageBegin('trySendMessage', TMessageType.CALL, self._seqid)
  local args = trySendMessage_args:new{}
  args.seq = seq
  args.message = message
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_trySendMessage(seq, message)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = trySendMessage_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getNextMessagesV2(messageBoxId, startMessageId, messagesCount)
  self:send_getNextMessagesV2(messageBoxId, startMessageId, messagesCount)
  return self:recv_getNextMessagesV2(messageBoxId, startMessageId, messagesCount)
end

function TalkServiceClient:send_getNextMessagesV2(messageBoxId, startMessageId, messagesCount)
  self.oprot:writeMessageBegin('getNextMessagesV2', TMessageType.CALL, self._seqid)
  local args = getNextMessagesV2_args:new{}
  args.messageBoxId = messageBoxId
  args.startMessageId = startMessageId
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getNextMessagesV2(messageBoxId, startMessageId, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNextMessagesV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getMessageBoxCompactWrapUpV2(messageBoxId)
  self:send_getMessageBoxCompactWrapUpV2(messageBoxId)
  return self:recv_getMessageBoxCompactWrapUpV2(messageBoxId)
end

function TalkServiceClient:send_getMessageBoxCompactWrapUpV2(messageBoxId)
  self.oprot:writeMessageBegin('getMessageBoxCompactWrapUpV2', TMessageType.CALL, self._seqid)
  local args = getMessageBoxCompactWrapUpV2_args:new{}
  args.messageBoxId = messageBoxId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getMessageBoxCompactWrapUpV2(messageBoxId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getMessageBoxCompactWrapUpV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:getRecentMessagesV2(messageBoxId, messagesCount)
  self:send_getRecentMessagesV2(messageBoxId, messagesCount)
  return self:recv_getRecentMessagesV2(messageBoxId, messagesCount)
end

function TalkServiceClient:send_getRecentMessagesV2(messageBoxId, messagesCount)
  self.oprot:writeMessageBegin('getRecentMessagesV2', TMessageType.CALL, self._seqid)
  local args = getRecentMessagesV2_args:new{}
  args.messageBoxId = messageBoxId
  args.messagesCount = messagesCount
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_getRecentMessagesV2(messageBoxId, messagesCount)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getRecentMessagesV2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:validateContactsOnBot(contacts)
  self:send_validateContactsOnBot(contacts)
  return self:recv_validateContactsOnBot(contacts)
end

function TalkServiceClient:send_validateContactsOnBot(contacts)
  self.oprot:writeMessageBegin('validateContactsOnBot', TMessageType.CALL, self._seqid)
  local args = validateContactsOnBot_args:new{}
  args.contacts = contacts
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_validateContactsOnBot(contacts)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = validateContactsOnBot_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:tryFriendRequest(midOrEMid, method, friendRequestParams)
  self:send_tryFriendRequest(midOrEMid, method, friendRequestParams)
  self:recv_tryFriendRequest(midOrEMid, method, friendRequestParams)
end

function TalkServiceClient:send_tryFriendRequest(midOrEMid, method, friendRequestParams)
  self.oprot:writeMessageBegin('tryFriendRequest', TMessageType.CALL, self._seqid)
  local args = tryFriendRequest_args:new{}
  args.midOrEMid = midOrEMid
  args.method = method
  args.friendRequestParams = friendRequestParams
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_tryFriendRequest(midOrEMid, method, friendRequestParams)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = tryFriendRequest_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unblockContact(reqSeq, id)
  self:send_unblockContact(reqSeq, id)
  self:recv_unblockContact(reqSeq, id)
end

function TalkServiceClient:send_unblockContact(reqSeq, id)
  self.oprot:writeMessageBegin('unblockContact', TMessageType.CALL, self._seqid)
  local args = unblockContact_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unblockContact(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unblockContact_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unblockRecommendation(reqSeq, id)
  self:send_unblockRecommendation(reqSeq, id)
  self:recv_unblockRecommendation(reqSeq, id)
end

function TalkServiceClient:send_unblockRecommendation(reqSeq, id)
  self.oprot:writeMessageBegin('unblockRecommendation', TMessageType.CALL, self._seqid)
  local args = unblockRecommendation_args:new{}
  args.reqSeq = reqSeq
  args.id = id
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unblockRecommendation(reqSeq, id)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unblockRecommendation_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:unregisterUserAndDevice()
  self:send_unregisterUserAndDevice()
  return self:recv_unregisterUserAndDevice()
end

function TalkServiceClient:send_unregisterUserAndDevice()
  self.oprot:writeMessageBegin('unregisterUserAndDevice', TMessageType.CALL, self._seqid)
  local args = unregisterUserAndDevice_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_unregisterUserAndDevice()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = unregisterUserAndDevice_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:updateApnsDeviceToken(apnsDeviceToken)
  self:send_updateApnsDeviceToken(apnsDeviceToken)
  self:recv_updateApnsDeviceToken(apnsDeviceToken)
end

function TalkServiceClient:send_updateApnsDeviceToken(apnsDeviceToken)
  self.oprot:writeMessageBegin('updateApnsDeviceToken', TMessageType.CALL, self._seqid)
  local args = updateApnsDeviceToken_args:new{}
  args.apnsDeviceToken = apnsDeviceToken
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateApnsDeviceToken(apnsDeviceToken)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateApnsDeviceToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateBuddySetting(key, value)
  self:send_updateBuddySetting(key, value)
  self:recv_updateBuddySetting(key, value)
end

function TalkServiceClient:send_updateBuddySetting(key, value)
  self.oprot:writeMessageBegin('updateBuddySetting', TMessageType.CALL, self._seqid)
  local args = updateBuddySetting_args:new{}
  args.key = key
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateBuddySetting(key, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateBuddySetting_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateC2DMRegistrationId(registrationId)
  self:send_updateC2DMRegistrationId(registrationId)
  self:recv_updateC2DMRegistrationId(registrationId)
end

function TalkServiceClient:send_updateC2DMRegistrationId(registrationId)
  self.oprot:writeMessageBegin('updateC2DMRegistrationId', TMessageType.CALL, self._seqid)
  local args = updateC2DMRegistrationId_args:new{}
  args.registrationId = registrationId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateC2DMRegistrationId(registrationId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateC2DMRegistrationId_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateContactSetting(reqSeq, mid, flag, value)
  self:send_updateContactSetting(reqSeq, mid, flag, value)
  self:recv_updateContactSetting(reqSeq, mid, flag, value)
end

function TalkServiceClient:send_updateContactSetting(reqSeq, mid, flag, value)
  self.oprot:writeMessageBegin('updateContactSetting', TMessageType.CALL, self._seqid)
  local args = updateContactSetting_args:new{}
  args.reqSeq = reqSeq
  args.mid = mid
  args.flag = flag
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateContactSetting(reqSeq, mid, flag, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateContactSetting_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateCustomModeSettings(customMode, paramMap)
  self:send_updateCustomModeSettings(customMode, paramMap)
  self:recv_updateCustomModeSettings(customMode, paramMap)
end

function TalkServiceClient:send_updateCustomModeSettings(customMode, paramMap)
  self.oprot:writeMessageBegin('updateCustomModeSettings', TMessageType.CALL, self._seqid)
  local args = updateCustomModeSettings_args:new{}
  args.customMode = customMode
  args.paramMap = paramMap
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateCustomModeSettings(customMode, paramMap)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateCustomModeSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateDeviceInfo(deviceUid, deviceInfo)
  self:send_updateDeviceInfo(deviceUid, deviceInfo)
  self:recv_updateDeviceInfo(deviceUid, deviceInfo)
end

function TalkServiceClient:send_updateDeviceInfo(deviceUid, deviceInfo)
  self.oprot:writeMessageBegin('updateDeviceInfo', TMessageType.CALL, self._seqid)
  local args = updateDeviceInfo_args:new{}
  args.deviceUid = deviceUid
  args.deviceInfo = deviceInfo
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateDeviceInfo(deviceUid, deviceInfo)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateDeviceInfo_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateGroup(reqSeq, group)
  self:send_updateGroup(reqSeq, group)
  self:recv_updateGroup(reqSeq, group)
end

function TalkServiceClient:send_updateGroup(reqSeq, group)
  self.oprot:writeMessageBegin('updateGroup', TMessageType.CALL, self._seqid)
  local args = updateGroup_args:new{}
  args.reqSeq = reqSeq
  args.group = group
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateGroup(reqSeq, group)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateGroup_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateNotificationToken(type, token)
  self:send_updateNotificationToken(type, token)
  self:recv_updateNotificationToken(type, token)
end

function TalkServiceClient:send_updateNotificationToken(type, token)
  self.oprot:writeMessageBegin('updateNotificationToken', TMessageType.CALL, self._seqid)
  local args = updateNotificationToken_args:new{}
  args.type = type
  args.token = token
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateNotificationToken(type, token)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateNotificationToken_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateNotificationTokenWithBytes(type, token)
  self:send_updateNotificationTokenWithBytes(type, token)
  self:recv_updateNotificationTokenWithBytes(type, token)
end

function TalkServiceClient:send_updateNotificationTokenWithBytes(type, token)
  self.oprot:writeMessageBegin('updateNotificationTokenWithBytes', TMessageType.CALL, self._seqid)
  local args = updateNotificationTokenWithBytes_args:new{}
  args.type = type
  args.token = token
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateNotificationTokenWithBytes(type, token)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateNotificationTokenWithBytes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateProfile(reqSeq, profile)
  self:send_updateProfile(reqSeq, profile)
  self:recv_updateProfile(reqSeq, profile)
end

function TalkServiceClient:send_updateProfile(reqSeq, profile)
  self.oprot:writeMessageBegin('updateProfile', TMessageType.CALL, self._seqid)
  local args = updateProfile_args:new{}
  args.reqSeq = reqSeq
  args.profile = profile
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateProfile(reqSeq, profile)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateProfile_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateProfileAttribute(reqSeq, attr, value)
  self:send_updateProfileAttribute(reqSeq, attr, value)
  self:recv_updateProfileAttribute(reqSeq, attr, value)
end

function TalkServiceClient:send_updateProfileAttribute(reqSeq, attr, value)
  self.oprot:writeMessageBegin('updateProfileAttribute', TMessageType.CALL, self._seqid)
  local args = updateProfileAttribute_args:new{}
  args.reqSeq = reqSeq
  args.attr = attr
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateProfileAttribute(reqSeq, attr, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateProfileAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateProfileAttributes(reqSeq, request)
  self:send_updateProfileAttributes(reqSeq, request)
  self:recv_updateProfileAttributes(reqSeq, request)
end

function TalkServiceClient:send_updateProfileAttributes(reqSeq, request)
  self.oprot:writeMessageBegin('updateProfileAttributes', TMessageType.CALL, self._seqid)
  local args = updateProfileAttributes_args:new{}
  args.reqSeq = reqSeq
  args.request = request
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateProfileAttributes(reqSeq, request)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateProfileAttributes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateRegion(region)
  self:send_updateRegion(region)
  self:recv_updateRegion(region)
end

function TalkServiceClient:send_updateRegion(region)
  self.oprot:writeMessageBegin('updateRegion', TMessageType.CALL, self._seqid)
  local args = updateRegion_args:new{}
  args.region = region
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateRegion(region)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateRegion_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettings(reqSeq, settings)
  self:send_updateSettings(reqSeq, settings)
  self:recv_updateSettings(reqSeq, settings)
end

function TalkServiceClient:send_updateSettings(reqSeq, settings)
  self.oprot:writeMessageBegin('updateSettings', TMessageType.CALL, self._seqid)
  local args = updateSettings_args:new{}
  args.reqSeq = reqSeq
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettings(reqSeq, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettings_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettings2(reqSeq, settings)
  self:send_updateSettings2(reqSeq, settings)
  return self:recv_updateSettings2(reqSeq, settings)
end

function TalkServiceClient:send_updateSettings2(reqSeq, settings)
  self.oprot:writeMessageBegin('updateSettings2', TMessageType.CALL, self._seqid)
  local args = updateSettings2_args:new{}
  args.reqSeq = reqSeq
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettings2(reqSeq, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettings2_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:updateSettingsAttribute(reqSeq, attr, value)
  self:send_updateSettingsAttribute(reqSeq, attr, value)
  self:recv_updateSettingsAttribute(reqSeq, attr, value)
end

function TalkServiceClient:send_updateSettingsAttribute(reqSeq, attr, value)
  self.oprot:writeMessageBegin('updateSettingsAttribute', TMessageType.CALL, self._seqid)
  local args = updateSettingsAttribute_args:new{}
  args.reqSeq = reqSeq
  args.attr = attr
  args.value = value
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettingsAttribute(reqSeq, attr, value)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettingsAttribute_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:updateSettingsAttributes(reqSeq, attrBitset, settings)
  self:send_updateSettingsAttributes(reqSeq, attrBitset, settings)
  return self:recv_updateSettingsAttributes(reqSeq, attrBitset, settings)
end

function TalkServiceClient:send_updateSettingsAttributes(reqSeq, attrBitset, settings)
  self.oprot:writeMessageBegin('updateSettingsAttributes', TMessageType.CALL, self._seqid)
  local args = updateSettingsAttributes_args:new{}
  args.reqSeq = reqSeq
  args.attrBitset = attrBitset
  args.settings = settings
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_updateSettingsAttributes(reqSeq, attrBitset, settings)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = updateSettingsAttributes_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyIdentityCredential(identityProvider, identifier, password)
  self:send_verifyIdentityCredential(identityProvider, identifier, password)
  self:recv_verifyIdentityCredential(identityProvider, identifier, password)
end

function TalkServiceClient:send_verifyIdentityCredential(identityProvider, identifier, password)
  self.oprot:writeMessageBegin('verifyIdentityCredential', TMessageType.CALL, self._seqid)
  local args = verifyIdentityCredential_args:new{}
  args.identityProvider = identityProvider
  args.identifier = identifier
  args.password = password
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyIdentityCredential(identityProvider, identifier, password)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyIdentityCredential_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function TalkServiceClient:verifyIdentityCredentialWithResult(identityCredential)
  self:send_verifyIdentityCredentialWithResult(identityCredential)
  return self:recv_verifyIdentityCredentialWithResult(identityCredential)
end

function TalkServiceClient:send_verifyIdentityCredentialWithResult(identityCredential)
  self.oprot:writeMessageBegin('verifyIdentityCredentialWithResult', TMessageType.CALL, self._seqid)
  local args = verifyIdentityCredentialWithResult_args:new{}
  args.identityCredential = identityCredential
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyIdentityCredentialWithResult(identityCredential)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyIdentityCredentialWithResult_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyPhone(sessionId, pinCode, udidHash)
  self:send_verifyPhone(sessionId, pinCode, udidHash)
  return self:recv_verifyPhone(sessionId, pinCode, udidHash)
end

function TalkServiceClient:send_verifyPhone(sessionId, pinCode, udidHash)
  self.oprot:writeMessageBegin('verifyPhone', TMessageType.CALL, self._seqid)
  local args = verifyPhone_args:new{}
  args.sessionId = sessionId
  args.pinCode = pinCode
  args.udidHash = udidHash
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyPhone(sessionId, pinCode, udidHash)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyPhone_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function TalkServiceClient:verifyQrcode(verifier, pinCode)
  self:send_verifyQrcode(verifier, pinCode)
  return self:recv_verifyQrcode(verifier, pinCode)
end

function TalkServiceClient:send_verifyQrcode(verifier, pinCode)
  self.oprot:writeMessageBegin('verifyQrcode', TMessageType.CALL, self._seqid)
  local args = verifyQrcode_args:new{}
  args.verifier = verifier
  args.pinCode = pinCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function TalkServiceClient:recv_verifyQrcode(verifier, pinCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = verifyQrcode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end
TalkServiceIface = __TObject:new{
  __type = 'TalkServiceIface'
}


TalkServiceProcessor = __TObject.new(__TProcessor
, {
 __type = 'TalkServiceProcessor'
})

function TalkServiceProcessor:process(iprot, oprot, server_ctx)
  local name, mtype, seqid = iprot:readMessageBegin()
  local func_name = 'process_' .. name
  if not self[func_name] or ttype(self[func_name]) ~= 'function' then
    iprot:skip(TType.STRUCT)
    iprot:readMessageEnd()
    x = TApplicationException:new{
      errorCode = TApplicationException.UNKNOWN_METHOD
    }
    oprot:writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
    x:write(oprot)
    oprot:writeMessageEnd()
    oprot.trans:flush()
  else
    self[func_name](self, seqid, iprot, oprot, server_ctx)
  end
end

function TalkServiceProcessor:process_searchCollection(seqid, iprot, oprot, server_ctx)
  local args = searchCollection_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = searchCollection_result:new{}
  local status, res = pcall(self.handler.searchCollection, self.handler, args.query, args.param)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('searchCollection', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getChatRoomAnnouncementsBulk(seqid, iprot, oprot, server_ctx)
  local args = getChatRoomAnnouncementsBulk_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getChatRoomAnnouncementsBulk_result:new{}
  local status, res = pcall(self.handler.getChatRoomAnnouncementsBulk, self.handler, args.chatRoomMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getChatRoomAnnouncementsBulk', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getChatRoomAnnouncements(seqid, iprot, oprot, server_ctx)
  local args = getChatRoomAnnouncements_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getChatRoomAnnouncements_result:new{}
  local status, res = pcall(self.handler.getChatRoomAnnouncements, self.handler, args.chatRoomMid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getChatRoomAnnouncements', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createChatRoomAnnouncement(seqid, iprot, oprot, server_ctx)
  local args = createChatRoomAnnouncement_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createChatRoomAnnouncement_result:new{}
  local status, res = pcall(self.handler.createChatRoomAnnouncement, self.handler, args.reqSeq, args.chatRoomMid, args.type, args.contents)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createChatRoomAnnouncement', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeChatRoomAnnouncement(seqid, iprot, oprot, server_ctx)
  local args = removeChatRoomAnnouncement_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeChatRoomAnnouncement_result:new{}
  local status, res = pcall(self.handler.removeChatRoomAnnouncement, self.handler, args.reqSeq, args.chatRoomMid, args.announcementSeq)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeChatRoomAnnouncement', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unsendMessage(seqid, iprot, oprot, server_ctx)
  local args = unsendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unsendMessage_result:new{}
  local status, res = pcall(self.handler.unsendMessage, self.handler, args.seq, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unsendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupWithoutMembers(seqid, iprot, oprot, server_ctx)
  local args = getGroupWithoutMembers_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupWithoutMembers_result:new{}
  local status, res = pcall(self.handler.getGroupWithoutMembers, self.handler, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupWithoutMembers', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestResendMessage(seqid, iprot, oprot, server_ctx)
  local args = requestResendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestResendMessage_result:new{}
  local status, res = pcall(self.handler.requestResendMessage, self.handler, args.reqSeq, args.senderMid, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestResendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_respondResendMessage(seqid, iprot, oprot, server_ctx)
  local args = respondResendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = respondResendMessage_result:new{}
  local status, res = pcall(self.handler.respondResendMessage, self.handler, args.reqSeq, args.receiverMid, args.originalMessageId, args.resendMessage, args.errorCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('respondResendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acceptGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = acceptGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acceptGroupInvitation_result:new{}
  local status, res = pcall(self.handler.acceptGroupInvitation, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acceptGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acceptGroupInvitationByTicket(seqid, iprot, oprot, server_ctx)
  local args = acceptGroupInvitationByTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acceptGroupInvitationByTicket_result:new{}
  local status, res = pcall(self.handler.acceptGroupInvitationByTicket, self.handler, args.reqSeq, args.GroupMid, args.ticketId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acceptGroupInvitationByTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acceptProximityMatches(seqid, iprot, oprot, server_ctx)
  local args = acceptProximityMatches_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acceptProximityMatches_result:new{}
  local status, res = pcall(self.handler.acceptProximityMatches, self.handler, args.sessionId, args.ids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acceptProximityMatches', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireCallRoute(seqid, iprot, oprot, server_ctx)
  local args = acquireCallRoute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireCallRoute_result:new{}
  local status, res = pcall(self.handler.acquireCallRoute, self.handler, args.to)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireCallRoute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireCallTicket(seqid, iprot, oprot, server_ctx)
  local args = acquireCallTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireCallTicket_result:new{}
  local status, res = pcall(self.handler.acquireCallTicket, self.handler, args.to)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireCallTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_acquireEncryptedAccessToken(seqid, iprot, oprot, server_ctx)
  local args = acquireEncryptedAccessToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = acquireEncryptedAccessToken_result:new{}
  local status, res = pcall(self.handler.acquireEncryptedAccessToken, self.handler, args.featureType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('acquireEncryptedAccessToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_addSnsId(seqid, iprot, oprot, server_ctx)
  local args = addSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = addSnsId_result:new{}
  local status, res = pcall(self.handler.addSnsId, self.handler, args.snsIdType, args.snsAccessToken)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('addSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_blockContact(seqid, iprot, oprot, server_ctx)
  local args = blockContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = blockContact_result:new{}
  local status, res = pcall(self.handler.blockContact, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('blockContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_blockRecommendation(seqid, iprot, oprot, server_ctx)
  local args = blockRecommendation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = blockRecommendation_result:new{}
  local status, res = pcall(self.handler.blockRecommendation, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('blockRecommendation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_cancelGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = cancelGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = cancelGroupInvitation_result:new{}
  local status, res = pcall(self.handler.cancelGroupInvitation, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('cancelGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_changeVerificationMethod(seqid, iprot, oprot, server_ctx)
  local args = changeVerificationMethod_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = changeVerificationMethod_result:new{}
  local status, res = pcall(self.handler.changeVerificationMethod, self.handler, args.sessionId, args.method)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('changeVerificationMethod', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_clearIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = clearIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = clearIdentityCredential_result:new{}
  local status, res = pcall(self.handler.clearIdentityCredential, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('clearIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_clearMessageBox(seqid, iprot, oprot, server_ctx)
  local args = clearMessageBox_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = clearMessageBox_result:new{}
  local status, res = pcall(self.handler.clearMessageBox, self.handler, args.channelId, args.messageBoxId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('clearMessageBox', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_closeProximityMatch(seqid, iprot, oprot, server_ctx)
  local args = closeProximityMatch_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = closeProximityMatch_result:new{}
  local status, res = pcall(self.handler.closeProximityMatch, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('closeProximityMatch', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitSendMessage(seqid, iprot, oprot, server_ctx)
  local args = commitSendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitSendMessage_result:new{}
  local status, res = pcall(self.handler.commitSendMessage, self.handler, args.seq, args.messageId, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitSendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitSendMessages(seqid, iprot, oprot, server_ctx)
  local args = commitSendMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitSendMessages_result:new{}
  local status, res = pcall(self.handler.commitSendMessages, self.handler, args.seq, args.messageIds, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitSendMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_commitUpdateProfile(seqid, iprot, oprot, server_ctx)
  local args = commitUpdateProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = commitUpdateProfile_result:new{}
  local status, res = pcall(self.handler.commitUpdateProfile, self.handler, args.seq, args.attrs, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('commitUpdateProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_confirmEmail(seqid, iprot, oprot, server_ctx)
  local args = confirmEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = confirmEmail_result:new{}
  local status, res = pcall(self.handler.confirmEmail, self.handler, args.verifier, args.pinCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('confirmEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createGroup(seqid, iprot, oprot, server_ctx)
  local args = createGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createGroup_result:new{}
  local status, res = pcall(self.handler.createGroup, self.handler, args.seq, args.name, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createQrcodeBase64Image(seqid, iprot, oprot, server_ctx)
  local args = createQrcodeBase64Image_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createQrcodeBase64Image_result:new{}
  local status, res = pcall(self.handler.createQrcodeBase64Image, self.handler, args.url, args.characterSet, args.imageSize, args.x, args.y, args.width, args.height)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createQrcodeBase64Image', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createRoom(seqid, iprot, oprot, server_ctx)
  local args = createRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createRoom_result:new{}
  local status, res = pcall(self.handler.createRoom, self.handler, args.reqSeq, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createSession(seqid, iprot, oprot, server_ctx)
  local args = createSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createSession_result:new{}
  local status, res = pcall(self.handler.createSession, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchAnnouncements(seqid, iprot, oprot, server_ctx)
  local args = fetchAnnouncements_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchAnnouncements_result:new{}
  local status, res = pcall(self.handler.fetchAnnouncements, self.handler, args.lastFetchedIndex)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchAnnouncements', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchMessages(seqid, iprot, oprot, server_ctx)
  local args = fetchMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchMessages_result:new{}
  local status, res = pcall(self.handler.fetchMessages, self.handler, args.localTs, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchOperations(seqid, iprot, oprot, server_ctx)
  local args = fetchOperations_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchOperations_result:new{}
  local status, res = pcall(self.handler.fetchOperations, self.handler, args.localRev, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'ShouldSyncException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchOperations', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_fetchOps(seqid, iprot, oprot, server_ctx)
  local args = fetchOps_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = fetchOps_result:new{}
  local status, res = pcall(self.handler.fetchOps, self.handler, args.localRev, args.count, args.globalRev, args.individualRev)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'ShouldSyncException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('fetchOps', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByEmail(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByEmail_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByEmail, self.handler, args.reqSeq, args.emails)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByMid(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByMid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByMid_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByMid, self.handler, args.reqSeq, args.mid, args.type, args.reference)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByMid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findGroupByTicketV2(seqid, iprot, oprot, server_ctx)
  local args = findGroupByTicketV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findGroupByTicketV2_result:new{}
  local status, res = pcall(self.handler.findGroupByTicketV2, self.handler, args.ticketId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findGroupByTicketV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByPhone(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByPhone_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByPhone, self.handler, args.reqSeq, args.phones)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getFriendRequests(seqid, iprot, oprot, server_ctx)
  local args = getFriendRequests_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getFriendRequests_result:new{}
  local status, res = pcall(self.handler.getFriendRequests, self.handler, args.direction, args.lastSeenSeqId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getFriendRequests', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeFriendRequest(seqid, iprot, oprot, server_ctx)
  local args = removeFriendRequest_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeFriendRequest_result:new{}
  local status, res = pcall(self.handler.removeFriendRequest, self.handler, args.direction, args.midOrEMid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeFriendRequest', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactsByUserid(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactsByUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactsByUserid_result:new{}
  local status, res = pcall(self.handler.findAndAddContactsByUserid, self.handler, args.reqSeq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactsByUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactByUserid(seqid, iprot, oprot, server_ctx)
  local args = findContactByUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactByUserid_result:new{}
  local status, res = pcall(self.handler.findContactByUserid, self.handler, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactByUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactByUserTicket(seqid, iprot, oprot, server_ctx)
  local args = findContactByUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactByUserTicket_result:new{}
  local status, res = pcall(self.handler.findContactByUserTicket, self.handler, args.ticketIdWithTag)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactByUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactsByEmail(seqid, iprot, oprot, server_ctx)
  local args = findContactsByEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactsByEmail_result:new{}
  local status, res = pcall(self.handler.findContactsByEmail, self.handler, args.emails)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactsByEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactsByPhone(seqid, iprot, oprot, server_ctx)
  local args = findContactsByPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactsByPhone_result:new{}
  local status, res = pcall(self.handler.findContactsByPhone, self.handler, args.phones)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactsByPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findSnsIdUserStatus(seqid, iprot, oprot, server_ctx)
  local args = findSnsIdUserStatus_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findSnsIdUserStatus_result:new{}
  local status, res = pcall(self.handler.findSnsIdUserStatus, self.handler, args.snsIdType, args.snsAccessToken, args.udidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findSnsIdUserStatus', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_finishUpdateVerification(seqid, iprot, oprot, server_ctx)
  local args = finishUpdateVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = finishUpdateVerification_result:new{}
  local status, res = pcall(self.handler.finishUpdateVerification, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('finishUpdateVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_generateUserTicket(seqid, iprot, oprot, server_ctx)
  local args = generateUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = generateUserTicket_result:new{}
  local status, res = pcall(self.handler.generateUserTicket, self.handler, args.expirationTime, args.maxUseCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('generateUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_destroyMessage(seqid, iprot, oprot, server_ctx)
  local args = destroyMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = destroyMessage_result:new{}
  local status, res = pcall(self.handler.destroyMessage, self.handler, args.seq, args.chatId, args.messageId, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('destroyMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAcceptedProximityMatches(seqid, iprot, oprot, server_ctx)
  local args = getAcceptedProximityMatches_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAcceptedProximityMatches_result:new{}
  local status, res = pcall(self.handler.getAcceptedProximityMatches, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAcceptedProximityMatches', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getActiveBuddySubscriberIds(seqid, iprot, oprot, server_ctx)
  local args = getActiveBuddySubscriberIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getActiveBuddySubscriberIds_result:new{}
  local status, res = pcall(self.handler.getActiveBuddySubscriberIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getActiveBuddySubscriberIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAllContactIds(seqid, iprot, oprot, server_ctx)
  local args = getAllContactIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAllContactIds_result:new{}
  local status, res = pcall(self.handler.getAllContactIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAllContactIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAuthQrcode(seqid, iprot, oprot, server_ctx)
  local args = getAuthQrcode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAuthQrcode_result:new{}
  local status, res = pcall(self.handler.getAuthQrcode, self.handler, args.keepLoggedIn, args.systemName)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAuthQrcode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedContactIds(seqid, iprot, oprot, server_ctx)
  local args = getBlockedContactIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedContactIds_result:new{}
  local status, res = pcall(self.handler.getBlockedContactIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedContactIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithPhoneNumber(seqid, iprot, oprot, server_ctx)
  local args = registerWithPhoneNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithPhoneNumber_result:new{}
  local status, res = pcall(self.handler.registerWithPhoneNumber, self.handler, args.sessionId, args.migrationPincodeSessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithPhoneNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithPhoneNumberAndPassword(seqid, iprot, oprot, server_ctx)
  local args = registerWithPhoneNumberAndPassword_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithPhoneNumberAndPassword_result:new{}
  local status, res = pcall(self.handler.registerWithPhoneNumberAndPassword, self.handler, args.sessionId, args.keynm, args.encrypted)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithPhoneNumberAndPassword', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getAnalyticsInfo(seqid, iprot, oprot, server_ctx)
  local args = getAnalyticsInfo_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getAnalyticsInfo_result:new{}
  local status, res = pcall(self.handler.getAnalyticsInfo, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getAnalyticsInfo', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportClientStatistics(seqid, iprot, oprot, server_ctx)
  local args = reportClientStatistics_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportClientStatistics_result:new{}
  local status, res = pcall(self.handler.reportClientStatistics, self.handler, args.reqSeq, args.category, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportClientStatistics', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyPhoneNumberForLogin(seqid, iprot, oprot, server_ctx)
  local args = verifyPhoneNumberForLogin_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyPhoneNumberForLogin_result:new{}
  local status, res = pcall(self.handler.verifyPhoneNumberForLogin, self.handler, args.verifierFromPhone, args.pinCodeForPhone, args.verifierFromLogin)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyPhoneNumberForLogin', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyPhoneNumber(seqid, iprot, oprot, server_ctx)
  local args = verifyPhoneNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyPhoneNumber_result:new{}
  local status, res = pcall(self.handler.verifyPhoneNumber, self.handler, args.sessionId, args.pinCode, args.udidHash, args.migrationPincodeSessionId, args.oldUdidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyPhoneNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedContactIdsByRange(seqid, iprot, oprot, server_ctx)
  local args = getBlockedContactIdsByRange_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedContactIdsByRange_result:new{}
  local status, res = pcall(self.handler.getBlockedContactIdsByRange, self.handler, args.start, args.count)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedContactIdsByRange', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBlockedRecommendationIds(seqid, iprot, oprot, server_ctx)
  local args = getBlockedRecommendationIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBlockedRecommendationIds_result:new{}
  local status, res = pcall(self.handler.getBlockedRecommendationIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBlockedRecommendationIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBuddyBlockerIds(seqid, iprot, oprot, server_ctx)
  local args = getBuddyBlockerIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBuddyBlockerIds_result:new{}
  local status, res = pcall(self.handler.getBuddyBlockerIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBuddyBlockerIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = getBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getBuddyLocation_result:new{}
  local status, res = pcall(self.handler.getBuddyLocation, self.handler, args.mid, args.index)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactContactsModifiedSince(seqid, iprot, oprot, server_ctx)
  local args = getCompactContactsModifiedSince_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactContactsModifiedSince_result:new{}
  local status, res = pcall(self.handler.getCompactContactsModifiedSince, self.handler, args.timestamp)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactContactsModifiedSince', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactGroup(seqid, iprot, oprot, server_ctx)
  local args = getCompactGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactGroup_result:new{}
  local status, res = pcall(self.handler.getCompactGroup, self.handler, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCompactRoom(seqid, iprot, oprot, server_ctx)
  local args = getCompactRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCompactRoom_result:new{}
  local status, res = pcall(self.handler.getCompactRoom, self.handler, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCompactRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getContact(seqid, iprot, oprot, server_ctx)
  local args = getContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getContact_result:new{}
  local status, res = pcall(self.handler.getContact, self.handler, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getContacts(seqid, iprot, oprot, server_ctx)
  local args = getContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getContacts_result:new{}
  local status, res = pcall(self.handler.getContacts, self.handler, args.ids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getContactWithFriendRequestStatus(seqid, iprot, oprot, server_ctx)
  local args = getContactWithFriendRequestStatus_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getContactWithFriendRequestStatus_result:new{}
  local status, res = pcall(self.handler.getContactWithFriendRequestStatus, self.handler, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getContactWithFriendRequestStatus', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getCountryWithRequestIp(seqid, iprot, oprot, server_ctx)
  local args = getCountryWithRequestIp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCountryWithRequestIp_result:new{}
  local status, res = pcall(self.handler.getCountryWithRequestIp, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCountryWithRequestIp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getFavoriteMids(seqid, iprot, oprot, server_ctx)
  local args = getFavoriteMids_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getFavoriteMids_result:new{}
  local status, res = pcall(self.handler.getFavoriteMids, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getFavoriteMids', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroup(seqid, iprot, oprot, server_ctx)
  local args = getGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroup_result:new{}
  local status, res = pcall(self.handler.getGroup, self.handler, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupIdsInvited(seqid, iprot, oprot, server_ctx)
  local args = getGroupIdsInvited_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupIdsInvited_result:new{}
  local status, res = pcall(self.handler.getGroupIdsInvited, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupIdsInvited', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupIdsJoined(seqid, iprot, oprot, server_ctx)
  local args = getGroupIdsJoined_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupIdsJoined_result:new{}
  local status, res = pcall(self.handler.getGroupIdsJoined, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupIdsJoined', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroups(seqid, iprot, oprot, server_ctx)
  local args = getGroups_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroups_result:new{}
  local status, res = pcall(self.handler.getGroups, self.handler, args.groupIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroups', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getHiddenContactMids(seqid, iprot, oprot, server_ctx)
  local args = getHiddenContactMids_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getHiddenContactMids_result:new{}
  local status, res = pcall(self.handler.getHiddenContactMids, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getHiddenContactMids', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getIdentityIdentifier(seqid, iprot, oprot, server_ctx)
  local args = getIdentityIdentifier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getIdentityIdentifier_result:new{}
  local status, res = pcall(self.handler.getIdentityIdentifier, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getIdentityIdentifier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getLastAnnouncementIndex(seqid, iprot, oprot, server_ctx)
  local args = getLastAnnouncementIndex_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getLastAnnouncementIndex_result:new{}
  local status, res = pcall(self.handler.getLastAnnouncementIndex, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getLastAnnouncementIndex', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getLastOpRevision(seqid, iprot, oprot, server_ctx)
  local args = getLastOpRevision_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getLastOpRevision_result:new{}
  local status, res = pcall(self.handler.getLastOpRevision, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getLastOpRevision', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSuggestRevisions(seqid, iprot, oprot, server_ctx)
  local args = getSuggestRevisions_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSuggestRevisions_result:new{}
  local status, res = pcall(self.handler.getSuggestRevisions, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSuggestRevisions', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getPreviousMessagesV2WithReadCount(seqid, iprot, oprot, server_ctx)
  local args = getPreviousMessagesV2WithReadCount_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPreviousMessagesV2WithReadCount_result:new{}
  local status, res = pcall(self.handler.getPreviousMessagesV2WithReadCount, self.handler, args.messageBoxId, args.endMessageId, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPreviousMessagesV2WithReadCount', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBox(seqid, iprot, oprot, server_ctx)
  local args = getMessageBox_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBox_result:new{}
  local status, res = pcall(self.handler.getMessageBox, self.handler, args.channelId, args.messageBoxId, args.lastMessagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBox', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxCompactWrapUp(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxCompactWrapUp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxCompactWrapUp_result:new{}
  local status, res = pcall(self.handler.getMessageBoxCompactWrapUp, self.handler, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxCompactWrapUp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxCompactWrapUpList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxCompactWrapUpList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxCompactWrapUpList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxCompactWrapUpList, self.handler, args.start, args.messageBoxCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxCompactWrapUpList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxList, self.handler, args.channelId, args.lastMessagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxListByStatus(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxListByStatus_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxListByStatus_result:new{}
  local status, res = pcall(self.handler.getMessageBoxListByStatus, self.handler, args.channelId, args.lastMessagesCount, args.status)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxListByStatus', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxWrapUp(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxWrapUp_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxWrapUp_result:new{}
  local status, res = pcall(self.handler.getMessageBoxWrapUp, self.handler, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxWrapUp', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxWrapUpList(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxWrapUpList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxWrapUpList_result:new{}
  local status, res = pcall(self.handler.getMessageBoxWrapUpList, self.handler, args.start, args.messageBoxCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxWrapUpList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessagesBySequenceNumber(seqid, iprot, oprot, server_ctx)
  local args = getMessagesBySequenceNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessagesBySequenceNumber_result:new{}
  local status, res = pcall(self.handler.getMessagesBySequenceNumber, self.handler, args.channelId, args.messageBoxId, args.startSeq, args.endSeq)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessagesBySequenceNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getNextMessages(seqid, iprot, oprot, server_ctx)
  local args = getNextMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNextMessages_result:new{}
  local status, res = pcall(self.handler.getNextMessages, self.handler, args.messageBoxId, args.startSeq, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNextMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getNotificationPolicy(seqid, iprot, oprot, server_ctx)
  local args = getNotificationPolicy_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNotificationPolicy_result:new{}
  local status, res = pcall(self.handler.getNotificationPolicy, self.handler, args.carrier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNotificationPolicy', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getPreviousMessages(seqid, iprot, oprot, server_ctx)
  local args = getPreviousMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPreviousMessages_result:new{}
  local status, res = pcall(self.handler.getPreviousMessages, self.handler, args.messageBoxId, args.endSeq, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPreviousMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProfile(seqid, iprot, oprot, server_ctx)
  local args = getProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProfile_result:new{}
  local status, res = pcall(self.handler.getProfile, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProximityMatchCandidateList(seqid, iprot, oprot, server_ctx)
  local args = getProximityMatchCandidateList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProximityMatchCandidateList_result:new{}
  local status, res = pcall(self.handler.getProximityMatchCandidateList, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProximityMatchCandidateList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getProximityMatchCandidates(seqid, iprot, oprot, server_ctx)
  local args = getProximityMatchCandidates_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProximityMatchCandidates_result:new{}
  local status, res = pcall(self.handler.getProximityMatchCandidates, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProximityMatchCandidates', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRecentMessages(seqid, iprot, oprot, server_ctx)
  local args = getRecentMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRecentMessages_result:new{}
  local status, res = pcall(self.handler.getRecentMessages, self.handler, args.messageBoxId, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRecentMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRecommendationIds(seqid, iprot, oprot, server_ctx)
  local args = getRecommendationIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRecommendationIds_result:new{}
  local status, res = pcall(self.handler.getRecommendationIds, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRecommendationIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRoom(seqid, iprot, oprot, server_ctx)
  local args = getRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRoom_result:new{}
  local status, res = pcall(self.handler.getRoom, self.handler, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRSAKeyInfo(seqid, iprot, oprot, server_ctx)
  local args = getRSAKeyInfo_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRSAKeyInfo_result:new{}
  local status, res = pcall(self.handler.getRSAKeyInfo, self.handler, args.provider)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRSAKeyInfo', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getServerTime(seqid, iprot, oprot, server_ctx)
  local args = getServerTime_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getServerTime_result:new{}
  local status, res = pcall(self.handler.getServerTime, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getServerTime', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSessions(seqid, iprot, oprot, server_ctx)
  local args = getSessions_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSessions_result:new{}
  local status, res = pcall(self.handler.getSessions, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSessions', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSettings(seqid, iprot, oprot, server_ctx)
  local args = getSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSettings_result:new{}
  local status, res = pcall(self.handler.getSettings, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getGroupsV2(seqid, iprot, oprot, server_ctx)
  local args = getGroupsV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getGroupsV2_result:new{}
  local status, res = pcall(self.handler.getGroupsV2, self.handler, args.groupIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getGroupsV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSettingsAttributes(seqid, iprot, oprot, server_ctx)
  local args = getSettingsAttributes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSettingsAttributes_result:new{}
  local status, res = pcall(self.handler.getSettingsAttributes, self.handler, args.attrBitset)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSettingsAttributes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getSystemConfiguration(seqid, iprot, oprot, server_ctx)
  local args = getSystemConfiguration_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getSystemConfiguration_result:new{}
  local status, res = pcall(self.handler.getSystemConfiguration, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getSystemConfiguration', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getUserTicket(seqid, iprot, oprot, server_ctx)
  local args = getUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getUserTicket_result:new{}
  local status, res = pcall(self.handler.getUserTicket, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getWapInvitation(seqid, iprot, oprot, server_ctx)
  local args = getWapInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getWapInvitation_result:new{}
  local status, res = pcall(self.handler.getWapInvitation, self.handler, args.invitationHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getWapInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_invalidateUserTicket(seqid, iprot, oprot, server_ctx)
  local args = invalidateUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = invalidateUserTicket_result:new{}
  local status, res = pcall(self.handler.invalidateUserTicket, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('invalidateUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteFriendsBySms(seqid, iprot, oprot, server_ctx)
  local args = inviteFriendsBySms_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteFriendsBySms_result:new{}
  local status, res = pcall(self.handler.inviteFriendsBySms, self.handler, args.phoneNumberList)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteFriendsBySms', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteIntoGroup(seqid, iprot, oprot, server_ctx)
  local args = inviteIntoGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteIntoGroup_result:new{}
  local status, res = pcall(self.handler.inviteIntoGroup, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteIntoGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteIntoRoom(seqid, iprot, oprot, server_ctx)
  local args = inviteIntoRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteIntoRoom_result:new{}
  local status, res = pcall(self.handler.inviteIntoRoom, self.handler, args.reqSeq, args.roomId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteIntoRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_inviteViaEmail(seqid, iprot, oprot, server_ctx)
  local args = inviteViaEmail_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = inviteViaEmail_result:new{}
  local status, res = pcall(self.handler.inviteViaEmail, self.handler, args.reqSeq, args.email, args.name)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('inviteViaEmail', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_isIdentityIdentifierAvailable(seqid, iprot, oprot, server_ctx)
  local args = isIdentityIdentifierAvailable_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = isIdentityIdentifierAvailable_result:new{}
  local status, res = pcall(self.handler.isIdentityIdentifierAvailable, self.handler, args.provider, args.identifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('isIdentityIdentifierAvailable', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_isUseridAvailable(seqid, iprot, oprot, server_ctx)
  local args = isUseridAvailable_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = isUseridAvailable_result:new{}
  local status, res = pcall(self.handler.isUseridAvailable, self.handler, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('isUseridAvailable', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_kickoutFromGroup(seqid, iprot, oprot, server_ctx)
  local args = kickoutFromGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = kickoutFromGroup_result:new{}
  local status, res = pcall(self.handler.kickoutFromGroup, self.handler, args.reqSeq, args.groupId, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('kickoutFromGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reissueGroupTicket(seqid, iprot, oprot, server_ctx)
  local args = reissueGroupTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reissueGroupTicket_result:new{}
  local status, res = pcall(self.handler.reissueGroupTicket, self.handler, args.groupMid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reissueGroupTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findGroupByTicket(seqid, iprot, oprot, server_ctx)
  local args = findGroupByTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findGroupByTicket_result:new{}
  local status, res = pcall(self.handler.findGroupByTicket, self.handler, args.ticketId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findGroupByTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_leaveGroup(seqid, iprot, oprot, server_ctx)
  local args = leaveGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = leaveGroup_result:new{}
  local status, res = pcall(self.handler.leaveGroup, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('leaveGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_leaveRoom(seqid, iprot, oprot, server_ctx)
  local args = leaveRoom_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = leaveRoom_result:new{}
  local status, res = pcall(self.handler.leaveRoom, self.handler, args.reqSeq, args.roomId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('leaveRoom', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = loginWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.loginWithIdentityCredential, self.handler, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithIdentityCredentialForCertificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithIdentityCredentialForCertificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithIdentityCredentialForCertificate_result:new{}
  local status, res = pcall(self.handler.loginWithIdentityCredentialForCertificate, self.handler, args.identityProvider, args.identifier, args.password, args.keepLoggedIn, args.accessLocation, args.systemName, args.certificate)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithIdentityCredentialForCertificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifier(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifier_result:new{}
  local status, res = pcall(self.handler.loginWithVerifier, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifierForCerificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifierForCerificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifierForCerificate_result:new{}
  local status, res = pcall(self.handler.loginWithVerifierForCerificate, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifierForCerificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_loginWithVerifierForCertificate(seqid, iprot, oprot, server_ctx)
  local args = loginWithVerifierForCertificate_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = loginWithVerifierForCertificate_result:new{}
  local status, res = pcall(self.handler.loginWithVerifierForCertificate, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('loginWithVerifierForCertificate', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_logout(seqid, iprot, oprot, server_ctx)
  local args = logout_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = logout_result:new{}
  local status, res = pcall(self.handler.logout, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('logout', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_logoutSession(seqid, iprot, oprot, server_ctx)
  local args = logoutSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = logoutSession_result:new{}
  local status, res = pcall(self.handler.logoutSession, self.handler, args.tokenKey)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('logoutSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_noop(seqid, iprot, oprot, server_ctx)
  local args = noop_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = noop_result:new{}
  local status, res = pcall(self.handler.noop, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('noop', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifiedRedirect(seqid, iprot, oprot, server_ctx)
  local args = notifiedRedirect_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifiedRedirect_result:new{}
  local status, res = pcall(self.handler.notifiedRedirect, self.handler, args.paramMap)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifiedRedirect', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyBuddyOnAir(seqid, iprot, oprot, server_ctx)
  local args = notifyBuddyOnAir_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyBuddyOnAir_result:new{}
  local status, res = pcall(self.handler.notifyBuddyOnAir, self.handler, args.seq, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyBuddyOnAir', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyIndividualEvent(seqid, iprot, oprot, server_ctx)
  local args = notifyIndividualEvent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyIndividualEvent_result:new{}
  local status, res = pcall(self.handler.notifyIndividualEvent, self.handler, args.notificationStatus, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyIndividualEvent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyInstalled(seqid, iprot, oprot, server_ctx)
  local args = notifyInstalled_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyInstalled_result:new{}
  local status, res = pcall(self.handler.notifyInstalled, self.handler, args.udidHash, args.applicationTypeWithExtensions)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyInstalled', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyRegistrationComplete(seqid, iprot, oprot, server_ctx)
  local args = notifyRegistrationComplete_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyRegistrationComplete_result:new{}
  local status, res = pcall(self.handler.notifyRegistrationComplete, self.handler, args.udidHash, args.applicationTypeWithExtensions)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyRegistrationComplete', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifySleep(seqid, iprot, oprot, server_ctx)
  local args = notifySleep_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifySleep_result:new{}
  local status, res = pcall(self.handler.notifySleep, self.handler, args.lastRev, args.badge)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifySleep', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_notifyUpdated(seqid, iprot, oprot, server_ctx)
  local args = notifyUpdated_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyUpdated_result:new{}
  local status, res = pcall(self.handler.notifyUpdated, self.handler, args.lastRev, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyUpdated', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_openProximityMatch(seqid, iprot, oprot, server_ctx)
  local args = openProximityMatch_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = openProximityMatch_result:new{}
  local status, res = pcall(self.handler.openProximityMatch, self.handler, args.location)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('openProximityMatch', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerBuddyUser(seqid, iprot, oprot, server_ctx)
  local args = registerBuddyUser_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerBuddyUser_result:new{}
  local status, res = pcall(self.handler.registerBuddyUser, self.handler, args.buddyId, args.registrarPassword)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerBuddyUser', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerBuddyUserid(seqid, iprot, oprot, server_ctx)
  local args = registerBuddyUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerBuddyUserid_result:new{}
  local status, res = pcall(self.handler.registerBuddyUserid, self.handler, args.seq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerBuddyUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDevice(seqid, iprot, oprot, server_ctx)
  local args = registerDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDevice_result:new{}
  local status, res = pcall(self.handler.registerDevice, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithIdentityCredential, self.handler, args.sessionId, args.provider, args.identifier, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithoutPhoneNumber(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithoutPhoneNumber_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithoutPhoneNumber_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithoutPhoneNumber, self.handler, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithoutPhoneNumber', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerDeviceWithoutPhoneNumberWithIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerDeviceWithoutPhoneNumberWithIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerDeviceWithoutPhoneNumberWithIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerDeviceWithoutPhoneNumberWithIdentityCredential, self.handler, args.region, args.udidHash, args.deviceInfo, args.provider, args.identifier, args.verifier, args.mid, args.migrationPincodeSessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerUserid(seqid, iprot, oprot, server_ctx)
  local args = registerUserid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerUserid_result:new{}
  local status, res = pcall(self.handler.registerUserid, self.handler, args.reqSeq, args.userid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerUserid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWapDevice(seqid, iprot, oprot, server_ctx)
  local args = registerWapDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWapDevice_result:new{}
  local status, res = pcall(self.handler.registerWapDevice, self.handler, args.invitationHash, args.guidHash, args.email, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWapDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithExistingSnsIdAndIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerWithExistingSnsIdAndIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithExistingSnsIdAndIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerWithExistingSnsIdAndIdentityCredential, self.handler, args.identityCredential, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithExistingSnsIdAndIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithSnsId(seqid, iprot, oprot, server_ctx)
  local args = registerWithSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithSnsId_result:new{}
  local status, res = pcall(self.handler.registerWithSnsId, self.handler, args.snsIdType, args.snsAccessToken, args.region, args.udidHash, args.deviceInfo, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerWithSnsIdAndIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = registerWithSnsIdAndIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerWithSnsIdAndIdentityCredential_result:new{}
  local status, res = pcall(self.handler.registerWithSnsIdAndIdentityCredential, self.handler, args.snsIdType, args.snsAccessToken, args.identityCredential, args.region, args.udidHash, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerWithSnsIdAndIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reissueDeviceCredential(seqid, iprot, oprot, server_ctx)
  local args = reissueDeviceCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reissueDeviceCredential_result:new{}
  local status, res = pcall(self.handler.reissueDeviceCredential, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reissueDeviceCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reissueUserTicket(seqid, iprot, oprot, server_ctx)
  local args = reissueUserTicket_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reissueUserTicket_result:new{}
  local status, res = pcall(self.handler.reissueUserTicket, self.handler, args.expirationTime, args.maxUseCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reissueUserTicket', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageReadRange(seqid, iprot, oprot, server_ctx)
  local args = getMessageReadRange_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageReadRange_result:new{}
  local status, res = pcall(self.handler.getMessageReadRange, self.handler, args.chatIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageReadRange', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_rejectGroupInvitation(seqid, iprot, oprot, server_ctx)
  local args = rejectGroupInvitation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = rejectGroupInvitation_result:new{}
  local status, res = pcall(self.handler.rejectGroupInvitation, self.handler, args.reqSeq, args.groupId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('rejectGroupInvitation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_releaseSession(seqid, iprot, oprot, server_ctx)
  local args = releaseSession_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = releaseSession_result:new{}
  local status, res = pcall(self.handler.releaseSession, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('releaseSession', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeAllMessages(seqid, iprot, oprot, server_ctx)
  local args = removeAllMessages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeAllMessages_result:new{}
  local status, res = pcall(self.handler.removeAllMessages, self.handler, args.seq, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeAllMessages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = removeBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeBuddyLocation_result:new{}
  local status, res = pcall(self.handler.removeBuddyLocation, self.handler, args.mid, args.index)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeMessage(seqid, iprot, oprot, server_ctx)
  local args = removeMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeMessage_result:new{}
  local status, res = pcall(self.handler.removeMessage, self.handler, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_makeUserAddMyselfAsContact(seqid, iprot, oprot, server_ctx)
  local args = makeUserAddMyselfAsContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = makeUserAddMyselfAsContact_result:new{}
  local status, res = pcall(self.handler.makeUserAddMyselfAsContact, self.handler, args.contactOwnerMid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('makeUserAddMyselfAsContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeMessageFromMyHome(seqid, iprot, oprot, server_ctx)
  local args = removeMessageFromMyHome_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeMessageFromMyHome_result:new{}
  local status, res = pcall(self.handler.removeMessageFromMyHome, self.handler, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeMessageFromMyHome', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeSnsId(seqid, iprot, oprot, server_ctx)
  local args = removeSnsId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeSnsId_result:new{}
  local status, res = pcall(self.handler.removeSnsId, self.handler, args.snsIdType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeSnsId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_report(seqid, iprot, oprot, server_ctx)
  local args = report_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = report_result:new{}
  local status, res = pcall(self.handler.report, self.handler, args.syncOpRevision, args.category, args.report)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('report', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportContacts(seqid, iprot, oprot, server_ctx)
  local args = reportContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportContacts_result:new{}
  local status, res = pcall(self.handler.reportContacts, self.handler, args.syncOpRevision, args.category, args.contactReports, args.actionType)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportGroups(seqid, iprot, oprot, server_ctx)
  local args = reportGroups_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportGroups_result:new{}
  local status, res = pcall(self.handler.reportGroups, self.handler, args.syncOpRevision, args.groups)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportGroups', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportProfile(seqid, iprot, oprot, server_ctx)
  local args = reportProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportProfile_result:new{}
  local status, res = pcall(self.handler.reportProfile, self.handler, args.syncOpRevision, args.profile)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportRooms(seqid, iprot, oprot, server_ctx)
  local args = reportRooms_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportRooms_result:new{}
  local status, res = pcall(self.handler.reportRooms, self.handler, args.syncOpRevision, args.rooms)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportRooms', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findAndAddContactByMetaTag(seqid, iprot, oprot, server_ctx)
  local args = findAndAddContactByMetaTag_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findAndAddContactByMetaTag_result:new{}
  local status, res = pcall(self.handler.findAndAddContactByMetaTag, self.handler, args.reqSeq, args.userid, args.reference)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findAndAddContactByMetaTag', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportSettings(seqid, iprot, oprot, server_ctx)
  local args = reportSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportSettings_result:new{}
  local status, res = pcall(self.handler.reportSettings, self.handler, args.syncOpRevision, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportSpam(seqid, iprot, oprot, server_ctx)
  local args = reportSpam_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportSpam_result:new{}
  local status, res = pcall(self.handler.reportSpam, self.handler, args.chatMid, args.memberMids, args.spammerReasons, args.senderMids, args.spamMessageIds, args.spamMessages)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportSpam', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_reportSpammer(seqid, iprot, oprot, server_ctx)
  local args = reportSpammer_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reportSpammer_result:new{}
  local status, res = pcall(self.handler.reportSpammer, self.handler, args.spammerMid, args.spammerReasons, args.spamMessageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reportSpammer', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestAccountPasswordReset(seqid, iprot, oprot, server_ctx)
  local args = requestAccountPasswordReset_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestAccountPasswordReset_result:new{}
  local status, res = pcall(self.handler.requestAccountPasswordReset, self.handler, args.provider, args.identifier, args.locale)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestAccountPasswordReset', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestEmailConfirmation(seqid, iprot, oprot, server_ctx)
  local args = requestEmailConfirmation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestEmailConfirmation_result:new{}
  local status, res = pcall(self.handler.requestEmailConfirmation, self.handler, args.emailConfirmation)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestEmailConfirmation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestIdentityUnbind(seqid, iprot, oprot, server_ctx)
  local args = requestIdentityUnbind_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestIdentityUnbind_result:new{}
  local status, res = pcall(self.handler.requestIdentityUnbind, self.handler, args.provider, args.identifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestIdentityUnbind', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendEmailConfirmation(seqid, iprot, oprot, server_ctx)
  local args = resendEmailConfirmation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendEmailConfirmation_result:new{}
  local status, res = pcall(self.handler.resendEmailConfirmation, self.handler, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendEmailConfirmation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendPinCode(seqid, iprot, oprot, server_ctx)
  local args = resendPinCode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendPinCode_result:new{}
  local status, res = pcall(self.handler.resendPinCode, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendPinCode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_resendPinCodeBySMS(seqid, iprot, oprot, server_ctx)
  local args = resendPinCodeBySMS_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = resendPinCodeBySMS_result:new{}
  local status, res = pcall(self.handler.resendPinCodeBySMS, self.handler, args.sessionId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('resendPinCodeBySMS', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendChatChecked(seqid, iprot, oprot, server_ctx)
  local args = sendChatChecked_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendChatChecked_result:new{}
  local status, res = pcall(self.handler.sendChatChecked, self.handler, args.seq, args.consumer, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendChatChecked', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageAwaitCommit(seqid, iprot, oprot, server_ctx)
  local args = sendMessageAwaitCommit_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageAwaitCommit_result:new{}
  local status, res = pcall(self.handler.sendMessageAwaitCommit, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageAwaitCommit', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendChatRemoved(seqid, iprot, oprot, server_ctx)
  local args = sendChatRemoved_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendChatRemoved_result:new{}
  local status, res = pcall(self.handler.sendChatRemoved, self.handler, args.seq, args.consumer, args.lastMessageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendChatRemoved', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendContentPreviewUpdated(seqid, iprot, oprot, server_ctx)
  local args = sendContentPreviewUpdated_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendContentPreviewUpdated_result:new{}
  local status, res = pcall(self.handler.sendContentPreviewUpdated, self.handler, args.esq, args.messageId, args.receiverMids)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendContentPreviewUpdated', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendContentReceipt(seqid, iprot, oprot, server_ctx)
  local args = sendContentReceipt_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendContentReceipt_result:new{}
  local status, res = pcall(self.handler.sendContentReceipt, self.handler, args.seq, args.consumer, args.messageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendContentReceipt', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendDummyPush(seqid, iprot, oprot, server_ctx)
  local args = sendDummyPush_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendDummyPush_result:new{}
  local status, res = pcall(self.handler.sendDummyPush, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendDummyPush', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_removeE2EEPublicKey(seqid, iprot, oprot, server_ctx)
  local args = removeE2EEPublicKey_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = removeE2EEPublicKey_result:new{}
  local status, res = pcall(self.handler.removeE2EEPublicKey, self.handler, args.publicKey)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('removeE2EEPublicKey', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_negotiateE2EEPublicKey(seqid, iprot, oprot, server_ctx)
  local args = negotiateE2EEPublicKey_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = negotiateE2EEPublicKey_result:new{}
  local status, res = pcall(self.handler.negotiateE2EEPublicKey, self.handler, args.mid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('negotiateE2EEPublicKey', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getE2EEPublicKey(seqid, iprot, oprot, server_ctx)
  local args = getE2EEPublicKey_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getE2EEPublicKey_result:new{}
  local status, res = pcall(self.handler.getE2EEPublicKey, self.handler, args.mid, args.version, args.keyId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getE2EEPublicKey', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_requestE2EEKeyExchange(seqid, iprot, oprot, server_ctx)
  local args = requestE2EEKeyExchange_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = requestE2EEKeyExchange_result:new{}
  local status, res = pcall(self.handler.requestE2EEKeyExchange, self.handler, args.reqSeq, args.temporalPublicKey, args.publicKey, args.verifier)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('requestE2EEKeyExchange', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getLastE2EEPublicKeys(seqid, iprot, oprot, server_ctx)
  local args = getLastE2EEPublicKeys_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getLastE2EEPublicKeys_result:new{}
  local status, res = pcall(self.handler.getLastE2EEPublicKeys, self.handler, args.chatMid)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getLastE2EEPublicKeys', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_registerE2EEPublicKey(seqid, iprot, oprot, server_ctx)
  local args = registerE2EEPublicKey_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = registerE2EEPublicKey_result:new{}
  local status, res = pcall(self.handler.registerE2EEPublicKey, self.handler, args.reqSeq, args.publicKey)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('registerE2EEPublicKey', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getE2EEPublicKeys(seqid, iprot, oprot, server_ctx)
  local args = getE2EEPublicKeys_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getE2EEPublicKeys_result:new{}
  local status, res = pcall(self.handler.getE2EEPublicKeys, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getE2EEPublicKeys', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getE2EEPublicKeysEx(seqid, iprot, oprot, server_ctx)
  local args = getE2EEPublicKeysEx_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getE2EEPublicKeysEx_result:new{}
  local status, res = pcall(self.handler.getE2EEPublicKeysEx, self.handler, args.ignoreE2EEStatus)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getE2EEPublicKeysEx', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getReadMessageOpsInBulk(seqid, iprot, oprot, server_ctx)
  local args = getReadMessageOpsInBulk_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getReadMessageOpsInBulk_result:new{}
  local status, res = pcall(self.handler.getReadMessageOpsInBulk, self.handler, args.chatIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getReadMessageOpsInBulk', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendEvent(seqid, iprot, oprot, server_ctx)
  local args = sendEvent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendEvent_result:new{}
  local status, res = pcall(self.handler.sendEvent, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendEvent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessage(seqid, iprot, oprot, server_ctx)
  local args = sendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessage_result:new{}
  local status, res = pcall(self.handler.sendMessage, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageIgnored(seqid, iprot, oprot, server_ctx)
  local args = sendMessageIgnored_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageIgnored_result:new{}
  local status, res = pcall(self.handler.sendMessageIgnored, self.handler, args.seq, args.consumer, args.messageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageIgnored', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageReceipt(seqid, iprot, oprot, server_ctx)
  local args = sendMessageReceipt_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageReceipt_result:new{}
  local status, res = pcall(self.handler.sendMessageReceipt, self.handler, args.seq, args.consumer, args.messageIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageReceipt', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_findContactByMetaTag(seqid, iprot, oprot, server_ctx)
  local args = findContactByMetaTag_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = findContactByMetaTag_result:new{}
  local status, res = pcall(self.handler.findContactByMetaTag, self.handler, args.userid, args.reference)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('findContactByMetaTag', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_sendMessageToMyHome(seqid, iprot, oprot, server_ctx)
  local args = sendMessageToMyHome_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = sendMessageToMyHome_result:new{}
  local status, res = pcall(self.handler.sendMessageToMyHome, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('sendMessageToMyHome', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setBuddyLocation(seqid, iprot, oprot, server_ctx)
  local args = setBuddyLocation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setBuddyLocation_result:new{}
  local status, res = pcall(self.handler.setBuddyLocation, self.handler, args.mid, args.index, args.location)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setBuddyLocation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = setIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setIdentityCredential_result:new{}
  local status, res = pcall(self.handler.setIdentityCredential, self.handler, args.identifier, args.verifier, args.provider)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_setNotificationsEnabled(seqid, iprot, oprot, server_ctx)
  local args = setNotificationsEnabled_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = setNotificationsEnabled_result:new{}
  local status, res = pcall(self.handler.setNotificationsEnabled, self.handler, args.reqSeq, args.type, args.target, args.enablement)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('setNotificationsEnabled', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_startUpdateVerification(seqid, iprot, oprot, server_ctx)
  local args = startUpdateVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = startUpdateVerification_result:new{}
  local status, res = pcall(self.handler.startUpdateVerification, self.handler, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.locale)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('startUpdateVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_startVerification(seqid, iprot, oprot, server_ctx)
  local args = startVerification_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = startVerification_result:new{}
  local status, res = pcall(self.handler.startVerification, self.handler, args.region, args.carrier, args.phone, args.udidHash, args.deviceInfo, args.networkCode, args.mid, args.locale, args.simInfo, args.oldUdidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('startVerification', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateGroupPreferenceAttribute(seqid, iprot, oprot, server_ctx)
  local args = updateGroupPreferenceAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateGroupPreferenceAttribute_result:new{}
  local status, res = pcall(self.handler.updateGroupPreferenceAttribute, self.handler, args.reqSeq, args.groupMid, args.updatedAttrs)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateGroupPreferenceAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_createRoomV2(seqid, iprot, oprot, server_ctx)
  local args = createRoomV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = createRoomV2_result:new{}
  local status, res = pcall(self.handler.createRoomV2, self.handler, args.reqSeq, args.contactIds)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('createRoomV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_storeUpdateProfileAttribute(seqid, iprot, oprot, server_ctx)
  local args = storeUpdateProfileAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = storeUpdateProfileAttribute_result:new{}
  local status, res = pcall(self.handler.storeUpdateProfileAttribute, self.handler, args.seq, args.profileAttribute, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('storeUpdateProfileAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_syncContactBySnsIds(seqid, iprot, oprot, server_ctx)
  local args = syncContactBySnsIds_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = syncContactBySnsIds_result:new{}
  local status, res = pcall(self.handler.syncContactBySnsIds, self.handler, args.reqSeq, args.modifications)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('syncContactBySnsIds', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_syncContacts(seqid, iprot, oprot, server_ctx)
  local args = syncContacts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = syncContacts_result:new{}
  local status, res = pcall(self.handler.syncContacts, self.handler, args.reqSeq, args.localContacts)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('syncContacts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_trySendMessage(seqid, iprot, oprot, server_ctx)
  local args = trySendMessage_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = trySendMessage_result:new{}
  local status, res = pcall(self.handler.trySendMessage, self.handler, args.seq, args.message)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('trySendMessage', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getNextMessagesV2(seqid, iprot, oprot, server_ctx)
  local args = getNextMessagesV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNextMessagesV2_result:new{}
  local status, res = pcall(self.handler.getNextMessagesV2, self.handler, args.messageBoxId, args.startMessageId, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNextMessagesV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getMessageBoxCompactWrapUpV2(seqid, iprot, oprot, server_ctx)
  local args = getMessageBoxCompactWrapUpV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getMessageBoxCompactWrapUpV2_result:new{}
  local status, res = pcall(self.handler.getMessageBoxCompactWrapUpV2, self.handler, args.messageBoxId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getMessageBoxCompactWrapUpV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_getRecentMessagesV2(seqid, iprot, oprot, server_ctx)
  local args = getRecentMessagesV2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getRecentMessagesV2_result:new{}
  local status, res = pcall(self.handler.getRecentMessagesV2, self.handler, args.messageBoxId, args.messagesCount)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getRecentMessagesV2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_validateContactsOnBot(seqid, iprot, oprot, server_ctx)
  local args = validateContactsOnBot_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = validateContactsOnBot_result:new{}
  local status, res = pcall(self.handler.validateContactsOnBot, self.handler, args.contacts)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('validateContactsOnBot', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_tryFriendRequest(seqid, iprot, oprot, server_ctx)
  local args = tryFriendRequest_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = tryFriendRequest_result:new{}
  local status, res = pcall(self.handler.tryFriendRequest, self.handler, args.midOrEMid, args.method, args.friendRequestParams)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('tryFriendRequest', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unblockContact(seqid, iprot, oprot, server_ctx)
  local args = unblockContact_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unblockContact_result:new{}
  local status, res = pcall(self.handler.unblockContact, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unblockContact', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unblockRecommendation(seqid, iprot, oprot, server_ctx)
  local args = unblockRecommendation_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unblockRecommendation_result:new{}
  local status, res = pcall(self.handler.unblockRecommendation, self.handler, args.reqSeq, args.id)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unblockRecommendation', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_unregisterUserAndDevice(seqid, iprot, oprot, server_ctx)
  local args = unregisterUserAndDevice_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = unregisterUserAndDevice_result:new{}
  local status, res = pcall(self.handler.unregisterUserAndDevice, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('unregisterUserAndDevice', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateApnsDeviceToken(seqid, iprot, oprot, server_ctx)
  local args = updateApnsDeviceToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateApnsDeviceToken_result:new{}
  local status, res = pcall(self.handler.updateApnsDeviceToken, self.handler, args.apnsDeviceToken)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateApnsDeviceToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateBuddySetting(seqid, iprot, oprot, server_ctx)
  local args = updateBuddySetting_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateBuddySetting_result:new{}
  local status, res = pcall(self.handler.updateBuddySetting, self.handler, args.key, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateBuddySetting', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateC2DMRegistrationId(seqid, iprot, oprot, server_ctx)
  local args = updateC2DMRegistrationId_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateC2DMRegistrationId_result:new{}
  local status, res = pcall(self.handler.updateC2DMRegistrationId, self.handler, args.registrationId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateC2DMRegistrationId', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateContactSetting(seqid, iprot, oprot, server_ctx)
  local args = updateContactSetting_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateContactSetting_result:new{}
  local status, res = pcall(self.handler.updateContactSetting, self.handler, args.reqSeq, args.mid, args.flag, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateContactSetting', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateCustomModeSettings(seqid, iprot, oprot, server_ctx)
  local args = updateCustomModeSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateCustomModeSettings_result:new{}
  local status, res = pcall(self.handler.updateCustomModeSettings, self.handler, args.customMode, args.paramMap)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateCustomModeSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateDeviceInfo(seqid, iprot, oprot, server_ctx)
  local args = updateDeviceInfo_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateDeviceInfo_result:new{}
  local status, res = pcall(self.handler.updateDeviceInfo, self.handler, args.deviceUid, args.deviceInfo)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateDeviceInfo', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateGroup(seqid, iprot, oprot, server_ctx)
  local args = updateGroup_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateGroup_result:new{}
  local status, res = pcall(self.handler.updateGroup, self.handler, args.reqSeq, args.group)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateGroup', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateNotificationToken(seqid, iprot, oprot, server_ctx)
  local args = updateNotificationToken_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateNotificationToken_result:new{}
  local status, res = pcall(self.handler.updateNotificationToken, self.handler, args.type, args.token)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateNotificationToken', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateNotificationTokenWithBytes(seqid, iprot, oprot, server_ctx)
  local args = updateNotificationTokenWithBytes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateNotificationTokenWithBytes_result:new{}
  local status, res = pcall(self.handler.updateNotificationTokenWithBytes, self.handler, args.type, args.token)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateNotificationTokenWithBytes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateProfile(seqid, iprot, oprot, server_ctx)
  local args = updateProfile_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateProfile_result:new{}
  local status, res = pcall(self.handler.updateProfile, self.handler, args.reqSeq, args.profile)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateProfile', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateProfileAttribute(seqid, iprot, oprot, server_ctx)
  local args = updateProfileAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateProfileAttribute_result:new{}
  local status, res = pcall(self.handler.updateProfileAttribute, self.handler, args.reqSeq, args.attr, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateProfileAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateProfileAttributes(seqid, iprot, oprot, server_ctx)
  local args = updateProfileAttributes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateProfileAttributes_result:new{}
  local status, res = pcall(self.handler.updateProfileAttributes, self.handler, args.reqSeq, args.request)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateProfileAttributes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateRegion(seqid, iprot, oprot, server_ctx)
  local args = updateRegion_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateRegion_result:new{}
  local status, res = pcall(self.handler.updateRegion, self.handler, args.region)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateRegion', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettings(seqid, iprot, oprot, server_ctx)
  local args = updateSettings_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettings_result:new{}
  local status, res = pcall(self.handler.updateSettings, self.handler, args.reqSeq, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettings', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettings2(seqid, iprot, oprot, server_ctx)
  local args = updateSettings2_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettings2_result:new{}
  local status, res = pcall(self.handler.updateSettings2, self.handler, args.reqSeq, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettings2', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettingsAttribute(seqid, iprot, oprot, server_ctx)
  local args = updateSettingsAttribute_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettingsAttribute_result:new{}
  local status, res = pcall(self.handler.updateSettingsAttribute, self.handler, args.reqSeq, args.attr, args.value)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettingsAttribute', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_updateSettingsAttributes(seqid, iprot, oprot, server_ctx)
  local args = updateSettingsAttributes_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = updateSettingsAttributes_result:new{}
  local status, res = pcall(self.handler.updateSettingsAttributes, self.handler, args.reqSeq, args.attrBitset, args.settings)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('updateSettingsAttributes', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyIdentityCredential(seqid, iprot, oprot, server_ctx)
  local args = verifyIdentityCredential_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyIdentityCredential_result:new{}
  local status, res = pcall(self.handler.verifyIdentityCredential, self.handler, args.identityProvider, args.identifier, args.password)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyIdentityCredential', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyIdentityCredentialWithResult(seqid, iprot, oprot, server_ctx)
  local args = verifyIdentityCredentialWithResult_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyIdentityCredentialWithResult_result:new{}
  local status, res = pcall(self.handler.verifyIdentityCredentialWithResult, self.handler, args.identityCredential)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyIdentityCredentialWithResult', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyPhone(seqid, iprot, oprot, server_ctx)
  local args = verifyPhone_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyPhone_result:new{}
  local status, res = pcall(self.handler.verifyPhone, self.handler, args.sessionId, args.pinCode, args.udidHash)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyPhone', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function TalkServiceProcessor:process_verifyQrcode(seqid, iprot, oprot, server_ctx)
  local args = verifyQrcode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = verifyQrcode_result:new{}
  local status, res = pcall(self.handler.verifyQrcode, self.handler, args.verifier, args.pinCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('verifyQrcode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

-- HELPER FUNCTIONS AND STRUCTURES

searchCollection_args = __TObject:new{
  query,
  param
}

function searchCollection_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.query = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.param = SearchPagingParameter:new{}
        self.param:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function searchCollection_args:write(oprot)
  oprot:writeStructBegin('searchCollection_args')
  if self.query ~= nil then
    oprot:writeFieldBegin('query', TType.STRING, 1)
    oprot:writeString(self.query)
    oprot:writeFieldEnd()
  end
  if self.param ~= nil then
    oprot:writeFieldBegin('param', TType.STRUCT, 2)
    self.param:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

searchCollection_result = __TObject:new{
  success,
  e
}

function searchCollection_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SearchResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function searchCollection_result:write(oprot)
  oprot:writeStructBegin('searchCollection_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getChatRoomAnnouncementsBulk_args = __TObject:new{
  chatRoomMids
}

function getChatRoomAnnouncementsBulk_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.chatRoomMids = {}
        local _etype1305, _size1302 = iprot:readListBegin()
        for _i=1,_size1302 do
          local _elem1306 = iprot:readString()
          table.insert(self.chatRoomMids, _elem1306)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getChatRoomAnnouncementsBulk_args:write(oprot)
  oprot:writeStructBegin('getChatRoomAnnouncementsBulk_args')
  if self.chatRoomMids ~= nil then
    oprot:writeFieldBegin('chatRoomMids', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.chatRoomMids)
    for _,iter1307 in ipairs(self.chatRoomMids) do
      oprot:writeString(iter1307)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getChatRoomAnnouncementsBulk_result = __TObject:new{
  success,
  e
}

function getChatRoomAnnouncementsBulk_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1309, _vtype1310, _size1308 = iprot:readMapBegin() 
        for _i=1,_size1308 do
          local _key1312 = iprot:readString()
          local _val1313 = {}
          local _etype1317, _size1314 = iprot:readListBegin()
          for _i=1,_size1314 do
            local _elem1318 = ChatRoomAnnouncement:new{}
            _elem1318:read(iprot)
            table.insert(_val1313, _elem1318)
          end
          iprot:readListEnd()
          self.success[_key1312] = _val1313
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getChatRoomAnnouncementsBulk_result:write(oprot)
  oprot:writeStructBegin('getChatRoomAnnouncementsBulk_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.LIST, ttable_size(self.success))
    for kiter1319,viter1320 in pairs(self.success) do
      oprot:writeString(kiter1319)
      oprot:writeListBegin(TType.STRUCT, #viter1320)
      for _,iter1321 in ipairs(viter1320) do
        iter1321:write(oprot)
      end
      oprot:writeListEnd()
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getChatRoomAnnouncements_args = __TObject:new{
  chatRoomMid
}

function getChatRoomAnnouncements_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatRoomMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getChatRoomAnnouncements_args:write(oprot)
  oprot:writeStructBegin('getChatRoomAnnouncements_args')
  if self.chatRoomMid ~= nil then
    oprot:writeFieldBegin('chatRoomMid', TType.STRING, 2)
    oprot:writeString(self.chatRoomMid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getChatRoomAnnouncements_result = __TObject:new{
  success,
  e
}

function getChatRoomAnnouncements_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1325, _size1322 = iprot:readListBegin()
        for _i=1,_size1322 do
          local _elem1326 = ChatRoomAnnouncement:new{}
          _elem1326:read(iprot)
          table.insert(self.success, _elem1326)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getChatRoomAnnouncements_result:write(oprot)
  oprot:writeStructBegin('getChatRoomAnnouncements_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1327 in ipairs(self.success) do
      iter1327:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createChatRoomAnnouncement_args = __TObject:new{
  reqSeq,
  chatRoomMid,
  type,
  contents
}

function createChatRoomAnnouncement_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatRoomMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.contents = ChatRoomAnnouncementContents:new{}
        self.contents:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createChatRoomAnnouncement_args:write(oprot)
  oprot:writeStructBegin('createChatRoomAnnouncement_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.chatRoomMid ~= nil then
    oprot:writeFieldBegin('chatRoomMid', TType.STRING, 2)
    oprot:writeString(self.chatRoomMid)
    oprot:writeFieldEnd()
  end
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.contents ~= nil then
    oprot:writeFieldBegin('contents', TType.STRUCT, 4)
    self.contents:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createChatRoomAnnouncement_result = __TObject:new{
  success,
  e
}

function createChatRoomAnnouncement_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ChatRoomAnnouncement:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createChatRoomAnnouncement_result:write(oprot)
  oprot:writeStructBegin('createChatRoomAnnouncement_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeChatRoomAnnouncement_args = __TObject:new{
  reqSeq,
  chatRoomMid,
  announcementSeq
}

function removeChatRoomAnnouncement_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatRoomMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.announcementSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeChatRoomAnnouncement_args:write(oprot)
  oprot:writeStructBegin('removeChatRoomAnnouncement_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.chatRoomMid ~= nil then
    oprot:writeFieldBegin('chatRoomMid', TType.STRING, 2)
    oprot:writeString(self.chatRoomMid)
    oprot:writeFieldEnd()
  end
  if self.announcementSeq ~= nil then
    oprot:writeFieldBegin('announcementSeq', TType.I64, 3)
    oprot:writeI64(self.announcementSeq)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeChatRoomAnnouncement_result = __TObject:new{
  e
}

function removeChatRoomAnnouncement_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeChatRoomAnnouncement_result:write(oprot)
  oprot:writeStructBegin('removeChatRoomAnnouncement_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unsendMessage_args = __TObject:new{
  seq,
  messageId
}

function unsendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unsendMessage_args:write(oprot)
  oprot:writeStructBegin('unsendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unsendMessage_result = __TObject:new{
  e
}

function unsendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unsendMessage_result:write(oprot)
  oprot:writeStructBegin('unsendMessage_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupWithoutMembers_args = __TObject:new{
  groupId
}

function getGroupWithoutMembers_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupWithoutMembers_args:write(oprot)
  oprot:writeStructBegin('getGroupWithoutMembers_args')
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupWithoutMembers_result = __TObject:new{
  success,
  e
}

function getGroupWithoutMembers_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupWithoutMembers_result:write(oprot)
  oprot:writeStructBegin('getGroupWithoutMembers_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestResendMessage_args = __TObject:new{
  reqSeq,
  senderMid,
  messageId
}

function requestResendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.senderMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestResendMessage_args:write(oprot)
  oprot:writeStructBegin('requestResendMessage_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.senderMid ~= nil then
    oprot:writeFieldBegin('senderMid', TType.STRING, 2)
    oprot:writeString(self.senderMid)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 3)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestResendMessage_result = __TObject:new{
  e
}

function requestResendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestResendMessage_result:write(oprot)
  oprot:writeStructBegin('requestResendMessage_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

respondResendMessage_args = __TObject:new{
  reqSeq,
  receiverMid,
  originalMessageId,
  resendMessage,
  errorCode
}

function respondResendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.receiverMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.originalMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.resendMessage = Message:new{}
        self.resendMessage:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.errorCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function respondResendMessage_args:write(oprot)
  oprot:writeStructBegin('respondResendMessage_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.receiverMid ~= nil then
    oprot:writeFieldBegin('receiverMid', TType.STRING, 2)
    oprot:writeString(self.receiverMid)
    oprot:writeFieldEnd()
  end
  if self.originalMessageId ~= nil then
    oprot:writeFieldBegin('originalMessageId', TType.STRING, 3)
    oprot:writeString(self.originalMessageId)
    oprot:writeFieldEnd()
  end
  if self.resendMessage ~= nil then
    oprot:writeFieldBegin('resendMessage', TType.STRUCT, 4)
    self.resendMessage:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.errorCode ~= nil then
    oprot:writeFieldBegin('errorCode', TType.I32, 5)
    oprot:writeI32(self.errorCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

respondResendMessage_result = __TObject:new{
  e
}

function respondResendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function respondResendMessage_result:write(oprot)
  oprot:writeStructBegin('respondResendMessage_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId
}

function acceptGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptGroupInvitation_result = __TObject:new{
  e
}

function acceptGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptGroupInvitationByTicket_args = __TObject:new{
  reqSeq,
  GroupMid,
  ticketId
}

function acceptGroupInvitationByTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.GroupMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.ticketId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitationByTicket_args:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitationByTicket_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.GroupMid ~= nil then
    oprot:writeFieldBegin('GroupMid', TType.STRING, 2)
    oprot:writeString(self.GroupMid)
    oprot:writeFieldEnd()
  end
  if self.ticketId ~= nil then
    oprot:writeFieldBegin('ticketId', TType.STRING, 3)
    oprot:writeString(self.ticketId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptGroupInvitationByTicket_result = __TObject:new{
  e
}

function acceptGroupInvitationByTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptGroupInvitationByTicket_result:write(oprot)
  oprot:writeStructBegin('acceptGroupInvitationByTicket_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptProximityMatches_args = __TObject:new{
  sessionId,
  ids
}

function acceptProximityMatches_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.SET then
        self.ids = {}
        local _etype1331, _size1328 = iprot:readSetBegin()
        for _i=1,_size1328 do
          local _elem1332 = iprot:readString()
          self.ids[_elem1332] = _elem1332
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptProximityMatches_args:write(oprot)
  oprot:writeStructBegin('acceptProximityMatches_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.ids ~= nil then
    oprot:writeFieldBegin('ids', TType.SET, 3)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.ids))
    for iter1333,_ in pairs(self.ids) do
      oprot:writeString(iter1333)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acceptProximityMatches_result = __TObject:new{
  e
}

function acceptProximityMatches_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acceptProximityMatches_result:write(oprot)
  oprot:writeStructBegin('acceptProximityMatches_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallRoute_args = __TObject:new{
  to
}

function acquireCallRoute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.to = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallRoute_args:write(oprot)
  oprot:writeStructBegin('acquireCallRoute_args')
  if self.to ~= nil then
    oprot:writeFieldBegin('to', TType.STRING, 2)
    oprot:writeString(self.to)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallRoute_result = __TObject:new{
  success,
  e
}

function acquireCallRoute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1337, _size1334 = iprot:readListBegin()
        for _i=1,_size1334 do
          local _elem1338 = iprot:readString()
          table.insert(self.success, _elem1338)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallRoute_result:write(oprot)
  oprot:writeStructBegin('acquireCallRoute_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1339 in ipairs(self.success) do
      oprot:writeString(iter1339)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallTicket_args = __TObject:new{
  to
}

function acquireCallTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.to = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallTicket_args:write(oprot)
  oprot:writeStructBegin('acquireCallTicket_args')
  if self.to ~= nil then
    oprot:writeFieldBegin('to', TType.STRING, 2)
    oprot:writeString(self.to)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireCallTicket_result = __TObject:new{
  success,
  e
}

function acquireCallTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireCallTicket_result:write(oprot)
  oprot:writeStructBegin('acquireCallTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireEncryptedAccessToken_args = __TObject:new{
  featureType
}

function acquireEncryptedAccessToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.featureType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireEncryptedAccessToken_args:write(oprot)
  oprot:writeStructBegin('acquireEncryptedAccessToken_args')
  if self.featureType ~= nil then
    oprot:writeFieldBegin('featureType', TType.I32, 2)
    oprot:writeI32(self.featureType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

acquireEncryptedAccessToken_result = __TObject:new{
  success,
  e
}

function acquireEncryptedAccessToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function acquireEncryptedAccessToken_result:write(oprot)
  oprot:writeStructBegin('acquireEncryptedAccessToken_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

addSnsId_args = __TObject:new{
  snsIdType,
  snsAccessToken
}

function addSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function addSnsId_args:write(oprot)
  oprot:writeStructBegin('addSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

addSnsId_result = __TObject:new{
  success,
  e
}

function addSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function addSnsId_result:write(oprot)
  oprot:writeStructBegin('addSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockContact_args = __TObject:new{
  reqSeq,
  id
}

function blockContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockContact_args:write(oprot)
  oprot:writeStructBegin('blockContact_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockContact_result = __TObject:new{
  e
}

function blockContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockContact_result:write(oprot)
  oprot:writeStructBegin('blockContact_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockRecommendation_args = __TObject:new{
  reqSeq,
  id
}

function blockRecommendation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockRecommendation_args:write(oprot)
  oprot:writeStructBegin('blockRecommendation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

blockRecommendation_result = __TObject:new{
  e
}

function blockRecommendation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function blockRecommendation_result:write(oprot)
  oprot:writeStructBegin('blockRecommendation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

cancelGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function cancelGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1343, _size1340 = iprot:readListBegin()
        for _i=1,_size1340 do
          local _elem1344 = iprot:readString()
          table.insert(self.contactIds, _elem1344)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function cancelGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('cancelGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1345 in ipairs(self.contactIds) do
      oprot:writeString(iter1345)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

cancelGroupInvitation_result = __TObject:new{
  e
}

function cancelGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function cancelGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('cancelGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

changeVerificationMethod_args = __TObject:new{
  sessionId,
  method
}

function changeVerificationMethod_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.method = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function changeVerificationMethod_args:write(oprot)
  oprot:writeStructBegin('changeVerificationMethod_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.method ~= nil then
    oprot:writeFieldBegin('method', TType.I32, 3)
    oprot:writeI32(self.method)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

changeVerificationMethod_result = __TObject:new{
  success,
  e
}

function changeVerificationMethod_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function changeVerificationMethod_result:write(oprot)
  oprot:writeStructBegin('changeVerificationMethod_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearIdentityCredential_args = __TObject:new{

}

function clearIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('clearIdentityCredential_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearIdentityCredential_result = __TObject:new{
  e
}

function clearIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('clearIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearMessageBox_args = __TObject:new{
  channelId,
  messageBoxId
}

function clearMessageBox_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearMessageBox_args:write(oprot)
  oprot:writeStructBegin('clearMessageBox_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

clearMessageBox_result = __TObject:new{
  e
}

function clearMessageBox_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function clearMessageBox_result:write(oprot)
  oprot:writeStructBegin('clearMessageBox_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

closeProximityMatch_args = __TObject:new{
  sessionId
}

function closeProximityMatch_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function closeProximityMatch_args:write(oprot)
  oprot:writeStructBegin('closeProximityMatch_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

closeProximityMatch_result = __TObject:new{
  e
}

function closeProximityMatch_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function closeProximityMatch_result:write(oprot)
  oprot:writeStructBegin('closeProximityMatch_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessage_args = __TObject:new{
  seq,
  messageId,
  receiverMids
}

function commitSendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1349, _size1346 = iprot:readListBegin()
        for _i=1,_size1346 do
          local _elem1350 = iprot:readString()
          table.insert(self.receiverMids, _elem1350)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessage_args:write(oprot)
  oprot:writeStructBegin('commitSendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1351 in ipairs(self.receiverMids) do
      oprot:writeString(iter1351)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessage_result = __TObject:new{
  success,
  e
}

function commitSendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1353, _vtype1354, _size1352 = iprot:readMapBegin() 
        for _i=1,_size1352 do
          local _key1356 = iprot:readString()
          local _val1357 = iprot:readString()
          self.success[_key1356] = _val1357
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessage_result:write(oprot)
  oprot:writeStructBegin('commitSendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1358,viter1359 in pairs(self.success) do
      oprot:writeString(kiter1358)
      oprot:writeString(viter1359)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessages_args = __TObject:new{
  seq,
  messageIds,
  receiverMids
}

function commitSendMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype1363, _size1360 = iprot:readListBegin()
        for _i=1,_size1360 do
          local _elem1364 = iprot:readString()
          table.insert(self.messageIds, _elem1364)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1368, _size1365 = iprot:readListBegin()
        for _i=1,_size1365 do
          local _elem1369 = iprot:readString()
          table.insert(self.receiverMids, _elem1369)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessages_args:write(oprot)
  oprot:writeStructBegin('commitSendMessages_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter1370 in ipairs(self.messageIds) do
      oprot:writeString(iter1370)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1371 in ipairs(self.receiverMids) do
      oprot:writeString(iter1371)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitSendMessages_result = __TObject:new{
  success,
  e
}

function commitSendMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1373, _vtype1374, _size1372 = iprot:readMapBegin() 
        for _i=1,_size1372 do
          local _key1376 = iprot:readString()
          local _val1377 = iprot:readString()
          self.success[_key1376] = _val1377
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitSendMessages_result:write(oprot)
  oprot:writeStructBegin('commitSendMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1378,viter1379 in pairs(self.success) do
      oprot:writeString(kiter1378)
      oprot:writeString(viter1379)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitUpdateProfile_args = __TObject:new{
  seq,
  attrs,
  receiverMids
}

function commitUpdateProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.attrs = {}
        local _etype1383, _size1380 = iprot:readListBegin()
        for _i=1,_size1380 do
          local _elem1384 = iprot:readI32()
          table.insert(self.attrs, _elem1384)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1388, _size1385 = iprot:readListBegin()
        for _i=1,_size1385 do
          local _elem1389 = iprot:readString()
          table.insert(self.receiverMids, _elem1389)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitUpdateProfile_args:write(oprot)
  oprot:writeStructBegin('commitUpdateProfile_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.attrs ~= nil then
    oprot:writeFieldBegin('attrs', TType.LIST, 2)
    oprot:writeListBegin(TType.I32, #self.attrs)
    for _,iter1390 in ipairs(self.attrs) do
      oprot:writeI32(iter1390)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1391 in ipairs(self.receiverMids) do
      oprot:writeString(iter1391)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

commitUpdateProfile_result = __TObject:new{
  success,
  e
}

function commitUpdateProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1393, _vtype1394, _size1392 = iprot:readMapBegin() 
        for _i=1,_size1392 do
          local _key1396 = iprot:readString()
          local _val1397 = iprot:readString()
          self.success[_key1396] = _val1397
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function commitUpdateProfile_result:write(oprot)
  oprot:writeStructBegin('commitUpdateProfile_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1398,viter1399 in pairs(self.success) do
      oprot:writeString(kiter1398)
      oprot:writeString(viter1399)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

confirmEmail_args = __TObject:new{
  verifier,
  pinCode
}

function confirmEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function confirmEmail_args:write(oprot)
  oprot:writeStructBegin('confirmEmail_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

confirmEmail_result = __TObject:new{
  e
}

function confirmEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function confirmEmail_result:write(oprot)
  oprot:writeStructBegin('confirmEmail_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createGroup_args = __TObject:new{
  seq,
  name,
  contactIds
}

function createGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.name = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1403, _size1400 = iprot:readListBegin()
        for _i=1,_size1400 do
          local _elem1404 = iprot:readString()
          table.insert(self.contactIds, _elem1404)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createGroup_args:write(oprot)
  oprot:writeStructBegin('createGroup_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.name ~= nil then
    oprot:writeFieldBegin('name', TType.STRING, 2)
    oprot:writeString(self.name)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1405 in ipairs(self.contactIds) do
      oprot:writeString(iter1405)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createGroup_result = __TObject:new{
  success,
  e
}

function createGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createGroup_result:write(oprot)
  oprot:writeStructBegin('createGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createQrcodeBase64Image_args = __TObject:new{
  url,
  characterSet,
  imageSize,
  x,
  y,
  width,
  height
}

function createQrcodeBase64Image_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.url = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.characterSet = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.imageSize = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.x = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.I32 then
        self.y = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.I32 then
        self.width = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.height = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createQrcodeBase64Image_args:write(oprot)
  oprot:writeStructBegin('createQrcodeBase64Image_args')
  if self.url ~= nil then
    oprot:writeFieldBegin('url', TType.STRING, 2)
    oprot:writeString(self.url)
    oprot:writeFieldEnd()
  end
  if self.characterSet ~= nil then
    oprot:writeFieldBegin('characterSet', TType.STRING, 3)
    oprot:writeString(self.characterSet)
    oprot:writeFieldEnd()
  end
  if self.imageSize ~= nil then
    oprot:writeFieldBegin('imageSize', TType.I32, 4)
    oprot:writeI32(self.imageSize)
    oprot:writeFieldEnd()
  end
  if self.x ~= nil then
    oprot:writeFieldBegin('x', TType.I32, 5)
    oprot:writeI32(self.x)
    oprot:writeFieldEnd()
  end
  if self.y ~= nil then
    oprot:writeFieldBegin('y', TType.I32, 6)
    oprot:writeI32(self.y)
    oprot:writeFieldEnd()
  end
  if self.width ~= nil then
    oprot:writeFieldBegin('width', TType.I32, 7)
    oprot:writeI32(self.width)
    oprot:writeFieldEnd()
  end
  if self.height ~= nil then
    oprot:writeFieldBegin('height', TType.I32, 8)
    oprot:writeI32(self.height)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createQrcodeBase64Image_result = __TObject:new{
  success,
  e
}

function createQrcodeBase64Image_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createQrcodeBase64Image_result:write(oprot)
  oprot:writeStructBegin('createQrcodeBase64Image_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoom_args = __TObject:new{
  reqSeq,
  contactIds
}

function createRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1409, _size1406 = iprot:readListBegin()
        for _i=1,_size1406 do
          local _elem1410 = iprot:readString()
          table.insert(self.contactIds, _elem1410)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoom_args:write(oprot)
  oprot:writeStructBegin('createRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1411 in ipairs(self.contactIds) do
      oprot:writeString(iter1411)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoom_result = __TObject:new{
  success,
  e
}

function createRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoom_result:write(oprot)
  oprot:writeStructBegin('createRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createSession_args = __TObject:new{

}

function createSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createSession_args:write(oprot)
  oprot:writeStructBegin('createSession_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createSession_result = __TObject:new{
  success,
  e
}

function createSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createSession_result:write(oprot)
  oprot:writeStructBegin('createSession_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchAnnouncements_args = __TObject:new{
  lastFetchedIndex
}

function fetchAnnouncements_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.lastFetchedIndex = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchAnnouncements_args:write(oprot)
  oprot:writeStructBegin('fetchAnnouncements_args')
  if self.lastFetchedIndex ~= nil then
    oprot:writeFieldBegin('lastFetchedIndex', TType.I32, 2)
    oprot:writeI32(self.lastFetchedIndex)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchAnnouncements_result = __TObject:new{
  success,
  e
}

function fetchAnnouncements_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1415, _size1412 = iprot:readListBegin()
        for _i=1,_size1412 do
          local _elem1416 = Announcement:new{}
          _elem1416:read(iprot)
          table.insert(self.success, _elem1416)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchAnnouncements_result:write(oprot)
  oprot:writeStructBegin('fetchAnnouncements_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1417 in ipairs(self.success) do
      iter1417:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchMessages_args = __TObject:new{
  localTs,
  count
}

function fetchMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localTs = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchMessages_args:write(oprot)
  oprot:writeStructBegin('fetchMessages_args')
  if self.localTs ~= nil then
    oprot:writeFieldBegin('localTs', TType.I64, 2)
    oprot:writeI64(self.localTs)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchMessages_result = __TObject:new{
  success,
  e
}

function fetchMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1421, _size1418 = iprot:readListBegin()
        for _i=1,_size1418 do
          local _elem1422 = Message:new{}
          _elem1422:read(iprot)
          table.insert(self.success, _elem1422)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchMessages_result:write(oprot)
  oprot:writeStructBegin('fetchMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1423 in ipairs(self.success) do
      iter1423:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOperations_args = __TObject:new{
  localRev,
  count
}

function fetchOperations_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOperations_args:write(oprot)
  oprot:writeStructBegin('fetchOperations_args')
  if self.localRev ~= nil then
    oprot:writeFieldBegin('localRev', TType.I64, 2)
    oprot:writeI64(self.localRev)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOperations_result = __TObject:new{
  success,
  e
}

function fetchOperations_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1427, _size1424 = iprot:readListBegin()
        for _i=1,_size1424 do
          local _elem1428 = Operation:new{}
          _elem1428:read(iprot)
          table.insert(self.success, _elem1428)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = ShouldSyncException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOperations_result:write(oprot)
  oprot:writeStructBegin('fetchOperations_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1429 in ipairs(self.success) do
      iter1429:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOps_args = __TObject:new{
  localRev,
  count,
  globalRev,
  individualRev
}

function fetchOps_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.localRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.globalRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I64 then
        self.individualRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOps_args:write(oprot)
  oprot:writeStructBegin('fetchOps_args')
  if self.localRev ~= nil then
    oprot:writeFieldBegin('localRev', TType.I64, 2)
    oprot:writeI64(self.localRev)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  if self.globalRev ~= nil then
    oprot:writeFieldBegin('globalRev', TType.I64, 4)
    oprot:writeI64(self.globalRev)
    oprot:writeFieldEnd()
  end
  if self.individualRev ~= nil then
    oprot:writeFieldBegin('individualRev', TType.I64, 5)
    oprot:writeI64(self.individualRev)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

fetchOps_result = __TObject:new{
  success,
  e
}

function fetchOps_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1433, _size1430 = iprot:readListBegin()
        for _i=1,_size1430 do
          local _elem1434 = Operation:new{}
          _elem1434:read(iprot)
          table.insert(self.success, _elem1434)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = ShouldSyncException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function fetchOps_result:write(oprot)
  oprot:writeStructBegin('fetchOps_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1435 in ipairs(self.success) do
      iter1435:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByEmail_args = __TObject:new{
  reqSeq,
  emails
}

function findAndAddContactsByEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.SET then
        self.emails = {}
        local _etype1439, _size1436 = iprot:readSetBegin()
        for _i=1,_size1436 do
          local _elem1440 = iprot:readString()
          self.emails[_elem1440] = _elem1440
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByEmail_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByEmail_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.emails ~= nil then
    oprot:writeFieldBegin('emails', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.emails))
    for iter1441,_ in pairs(self.emails) do
      oprot:writeString(iter1441)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByEmail_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1443, _vtype1444, _size1442 = iprot:readMapBegin() 
        for _i=1,_size1442 do
          local _key1446 = iprot:readString()
          local _val1447 = Contact:new{}
          _val1447:read(iprot)
          self.success[_key1446] = _val1447
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByEmail_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByEmail_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1448,viter1449 in pairs(self.success) do
      oprot:writeString(kiter1448)
      viter1449:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByMid_args = __TObject:new{
  reqSeq,
  mid,
  type,
  reference
}

function findAndAddContactsByMid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.reference = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByMid_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByMid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.reference ~= nil then
    oprot:writeFieldBegin('reference', TType.STRING, 4)
    oprot:writeString(self.reference)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByMid_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByMid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1451, _vtype1452, _size1450 = iprot:readMapBegin() 
        for _i=1,_size1450 do
          local _key1454 = iprot:readString()
          local _val1455 = Contact:new{}
          _val1455:read(iprot)
          self.success[_key1454] = _val1455
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByMid_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByMid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1456,viter1457 in pairs(self.success) do
      oprot:writeString(kiter1456)
      viter1457:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findGroupByTicketV2_args = __TObject:new{
  ticketId
}

function findGroupByTicketV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.ticketId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findGroupByTicketV2_args:write(oprot)
  oprot:writeStructBegin('findGroupByTicketV2_args')
  if self.ticketId ~= nil then
    oprot:writeFieldBegin('ticketId', TType.STRING, 1)
    oprot:writeString(self.ticketId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findGroupByTicketV2_result = __TObject:new{
  success,
  e
}

function findGroupByTicketV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findGroupByTicketV2_result:write(oprot)
  oprot:writeStructBegin('findGroupByTicketV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByPhone_args = __TObject:new{
  reqSeq,
  phones
}

function findAndAddContactsByPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.SET then
        self.phones = {}
        local _etype1461, _size1458 = iprot:readSetBegin()
        for _i=1,_size1458 do
          local _elem1462 = iprot:readString()
          self.phones[_elem1462] = _elem1462
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByPhone_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByPhone_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.phones ~= nil then
    oprot:writeFieldBegin('phones', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.phones))
    for iter1463,_ in pairs(self.phones) do
      oprot:writeString(iter1463)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByPhone_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1465, _vtype1466, _size1464 = iprot:readMapBegin() 
        for _i=1,_size1464 do
          local _key1468 = iprot:readString()
          local _val1469 = Contact:new{}
          _val1469:read(iprot)
          self.success[_key1468] = _val1469
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByPhone_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1470,viter1471 in pairs(self.success) do
      oprot:writeString(kiter1470)
      viter1471:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFriendRequests_args = __TObject:new{
  direction,
  lastSeenSeqId
}

function getFriendRequests_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.direction = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.lastSeenSeqId = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFriendRequests_args:write(oprot)
  oprot:writeStructBegin('getFriendRequests_args')
  if self.direction ~= nil then
    oprot:writeFieldBegin('direction', TType.I32, 1)
    oprot:writeI32(self.direction)
    oprot:writeFieldEnd()
  end
  if self.lastSeenSeqId ~= nil then
    oprot:writeFieldBegin('lastSeenSeqId', TType.I64, 2)
    oprot:writeI64(self.lastSeenSeqId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFriendRequests_result = __TObject:new{
  success,
  e
}

function getFriendRequests_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1475, _size1472 = iprot:readListBegin()
        for _i=1,_size1472 do
          local _elem1476 = FriendRequest:new{}
          _elem1476:read(iprot)
          table.insert(self.success, _elem1476)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFriendRequests_result:write(oprot)
  oprot:writeStructBegin('getFriendRequests_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1477 in ipairs(self.success) do
      iter1477:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeFriendRequest_args = __TObject:new{
  direction,
  midOrEMid
}

function removeFriendRequest_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.direction = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.midOrEMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeFriendRequest_args:write(oprot)
  oprot:writeStructBegin('removeFriendRequest_args')
  if self.direction ~= nil then
    oprot:writeFieldBegin('direction', TType.I32, 1)
    oprot:writeI32(self.direction)
    oprot:writeFieldEnd()
  end
  if self.midOrEMid ~= nil then
    oprot:writeFieldBegin('midOrEMid', TType.STRING, 2)
    oprot:writeString(self.midOrEMid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeFriendRequest_result = __TObject:new{
  e
}

function removeFriendRequest_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeFriendRequest_result:write(oprot)
  oprot:writeStructBegin('removeFriendRequest_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByUserid_args = __TObject:new{
  reqSeq,
  userid
}

function findAndAddContactsByUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByUserid_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByUserid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactsByUserid_result = __TObject:new{
  success,
  e
}

function findAndAddContactsByUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1479, _vtype1480, _size1478 = iprot:readMapBegin() 
        for _i=1,_size1478 do
          local _key1482 = iprot:readString()
          local _val1483 = Contact:new{}
          _val1483:read(iprot)
          self.success[_key1482] = _val1483
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactsByUserid_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactsByUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1484,viter1485 in pairs(self.success) do
      oprot:writeString(kiter1484)
      viter1485:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserid_args = __TObject:new{
  userid
}

function findContactByUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserid_args:write(oprot)
  oprot:writeStructBegin('findContactByUserid_args')
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserid_result = __TObject:new{
  success,
  e
}

function findContactByUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserid_result:write(oprot)
  oprot:writeStructBegin('findContactByUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserTicket_args = __TObject:new{
  ticketIdWithTag
}

function findContactByUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.ticketIdWithTag = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserTicket_args:write(oprot)
  oprot:writeStructBegin('findContactByUserTicket_args')
  if self.ticketIdWithTag ~= nil then
    oprot:writeFieldBegin('ticketIdWithTag', TType.STRING, 2)
    oprot:writeString(self.ticketIdWithTag)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByUserTicket_result = __TObject:new{
  success,
  e
}

function findContactByUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByUserTicket_result:write(oprot)
  oprot:writeStructBegin('findContactByUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByEmail_args = __TObject:new{
  emails
}

function findContactsByEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.SET then
        self.emails = {}
        local _etype1489, _size1486 = iprot:readSetBegin()
        for _i=1,_size1486 do
          local _elem1490 = iprot:readString()
          self.emails[_elem1490] = _elem1490
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByEmail_args:write(oprot)
  oprot:writeStructBegin('findContactsByEmail_args')
  if self.emails ~= nil then
    oprot:writeFieldBegin('emails', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.emails))
    for iter1491,_ in pairs(self.emails) do
      oprot:writeString(iter1491)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByEmail_result = __TObject:new{
  success,
  e
}

function findContactsByEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1493, _vtype1494, _size1492 = iprot:readMapBegin() 
        for _i=1,_size1492 do
          local _key1496 = iprot:readString()
          local _val1497 = Contact:new{}
          _val1497:read(iprot)
          self.success[_key1496] = _val1497
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByEmail_result:write(oprot)
  oprot:writeStructBegin('findContactsByEmail_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1498,viter1499 in pairs(self.success) do
      oprot:writeString(kiter1498)
      viter1499:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByPhone_args = __TObject:new{
  phones
}

function findContactsByPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.SET then
        self.phones = {}
        local _etype1503, _size1500 = iprot:readSetBegin()
        for _i=1,_size1500 do
          local _elem1504 = iprot:readString()
          self.phones[_elem1504] = _elem1504
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByPhone_args:write(oprot)
  oprot:writeStructBegin('findContactsByPhone_args')
  if self.phones ~= nil then
    oprot:writeFieldBegin('phones', TType.SET, 2)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.phones))
    for iter1505,_ in pairs(self.phones) do
      oprot:writeString(iter1505)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactsByPhone_result = __TObject:new{
  success,
  e
}

function findContactsByPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1507, _vtype1508, _size1506 = iprot:readMapBegin() 
        for _i=1,_size1506 do
          local _key1510 = iprot:readString()
          local _val1511 = Contact:new{}
          _val1511:read(iprot)
          self.success[_key1510] = _val1511
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactsByPhone_result:write(oprot)
  oprot:writeStructBegin('findContactsByPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1512,viter1513 in pairs(self.success) do
      oprot:writeString(kiter1512)
      viter1513:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findSnsIdUserStatus_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  udidHash
}

function findSnsIdUserStatus_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findSnsIdUserStatus_args:write(oprot)
  oprot:writeStructBegin('findSnsIdUserStatus_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findSnsIdUserStatus_result = __TObject:new{
  success,
  e
}

function findSnsIdUserStatus_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SnsIdUserStatus:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findSnsIdUserStatus_result:write(oprot)
  oprot:writeStructBegin('findSnsIdUserStatus_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

finishUpdateVerification_args = __TObject:new{
  sessionId
}

function finishUpdateVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function finishUpdateVerification_args:write(oprot)
  oprot:writeStructBegin('finishUpdateVerification_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

finishUpdateVerification_result = __TObject:new{
  e
}

function finishUpdateVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function finishUpdateVerification_result:write(oprot)
  oprot:writeStructBegin('finishUpdateVerification_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

generateUserTicket_args = __TObject:new{
  expirationTime,
  maxUseCount
}

function generateUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.expirationTime = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.maxUseCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function generateUserTicket_args:write(oprot)
  oprot:writeStructBegin('generateUserTicket_args')
  if self.expirationTime ~= nil then
    oprot:writeFieldBegin('expirationTime', TType.I64, 3)
    oprot:writeI64(self.expirationTime)
    oprot:writeFieldEnd()
  end
  if self.maxUseCount ~= nil then
    oprot:writeFieldBegin('maxUseCount', TType.I32, 4)
    oprot:writeI32(self.maxUseCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

generateUserTicket_result = __TObject:new{
  success,
  e
}

function generateUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Ticket:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function generateUserTicket_result:write(oprot)
  oprot:writeStructBegin('generateUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

destroyMessage_args = __TObject:new{
  seq,
  chatId,
  messageId,
  sessionId
}

function destroyMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.sessionId = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function destroyMessage_args:write(oprot)
  oprot:writeStructBegin('destroyMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.chatId ~= nil then
    oprot:writeFieldBegin('chatId', TType.STRING, 2)
    oprot:writeString(self.chatId)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 3)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.I32, 4)
    oprot:writeI32(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

destroyMessage_result = __TObject:new{
  e
}

function destroyMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function destroyMessage_result:write(oprot)
  oprot:writeStructBegin('destroyMessage_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAcceptedProximityMatches_args = __TObject:new{
  sessionId
}

function getAcceptedProximityMatches_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAcceptedProximityMatches_args:write(oprot)
  oprot:writeStructBegin('getAcceptedProximityMatches_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAcceptedProximityMatches_result = __TObject:new{
  success,
  e
}

function getAcceptedProximityMatches_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.SET then
        self.success = {}
        local _etype1517, _size1514 = iprot:readSetBegin()
        for _i=1,_size1514 do
          local _elem1518 = iprot:readString()
          self.success[_elem1518] = _elem1518
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAcceptedProximityMatches_result:write(oprot)
  oprot:writeStructBegin('getAcceptedProximityMatches_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.SET, 0)
    oprot:writeSetBegin(TType.STRING, ttable_size(self.success))
    for iter1519,_ in pairs(self.success) do
      oprot:writeString(iter1519)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActiveBuddySubscriberIds_args = __TObject:new{

}

function getActiveBuddySubscriberIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActiveBuddySubscriberIds_args:write(oprot)
  oprot:writeStructBegin('getActiveBuddySubscriberIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActiveBuddySubscriberIds_result = __TObject:new{
  success,
  e
}

function getActiveBuddySubscriberIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1523, _size1520 = iprot:readListBegin()
        for _i=1,_size1520 do
          local _elem1524 = iprot:readString()
          table.insert(self.success, _elem1524)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActiveBuddySubscriberIds_result:write(oprot)
  oprot:writeStructBegin('getActiveBuddySubscriberIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1525 in ipairs(self.success) do
      oprot:writeString(iter1525)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAllContactIds_args = __TObject:new{

}

function getAllContactIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAllContactIds_args:write(oprot)
  oprot:writeStructBegin('getAllContactIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAllContactIds_result = __TObject:new{
  success,
  e
}

function getAllContactIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1529, _size1526 = iprot:readListBegin()
        for _i=1,_size1526 do
          local _elem1530 = iprot:readString()
          table.insert(self.success, _elem1530)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAllContactIds_result:write(oprot)
  oprot:writeStructBegin('getAllContactIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1531 in ipairs(self.success) do
      oprot:writeString(iter1531)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAuthQrcode_args = __TObject:new{
  keepLoggedIn,
  systemName
}

function getAuthQrcode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAuthQrcode_args:write(oprot)
  oprot:writeStructBegin('getAuthQrcode_args')
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 2)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 3)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAuthQrcode_result = __TObject:new{
  success,
  e
}

function getAuthQrcode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = AuthQrcode:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAuthQrcode_result:write(oprot)
  oprot:writeStructBegin('getAuthQrcode_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIds_args = __TObject:new{

}

function getBlockedContactIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIds_args:write(oprot)
  oprot:writeStructBegin('getBlockedContactIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIds_result = __TObject:new{
  success,
  e
}

function getBlockedContactIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1535, _size1532 = iprot:readListBegin()
        for _i=1,_size1532 do
          local _elem1536 = iprot:readString()
          table.insert(self.success, _elem1536)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIds_result:write(oprot)
  oprot:writeStructBegin('getBlockedContactIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1537 in ipairs(self.success) do
      oprot:writeString(iter1537)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithPhoneNumber_args = __TObject:new{
  sessionId,
  migrationPincodeSessionId
}

function registerWithPhoneNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.migrationPincodeSessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithPhoneNumber_args:write(oprot)
  oprot:writeStructBegin('registerWithPhoneNumber_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.migrationPincodeSessionId ~= nil then
    oprot:writeFieldBegin('migrationPincodeSessionId', TType.STRING, 3)
    oprot:writeString(self.migrationPincodeSessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithPhoneNumber_result = __TObject:new{
  success,
  e
}

function registerWithPhoneNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RegisterWithPhoneNumberResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithPhoneNumber_result:write(oprot)
  oprot:writeStructBegin('registerWithPhoneNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithPhoneNumberAndPassword_args = __TObject:new{
  sessionId,
  keynm,
  encrypted
}

function registerWithPhoneNumberAndPassword_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.keynm = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.encrypted = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithPhoneNumberAndPassword_args:write(oprot)
  oprot:writeStructBegin('registerWithPhoneNumberAndPassword_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.keynm ~= nil then
    oprot:writeFieldBegin('keynm', TType.STRING, 3)
    oprot:writeString(self.keynm)
    oprot:writeFieldEnd()
  end
  if self.encrypted ~= nil then
    oprot:writeFieldBegin('encrypted', TType.STRING, 4)
    oprot:writeString(self.encrypted)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithPhoneNumberAndPassword_result = __TObject:new{
  success,
  e
}

function registerWithPhoneNumberAndPassword_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RegisterWithPhoneNumberResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithPhoneNumberAndPassword_result:write(oprot)
  oprot:writeStructBegin('registerWithPhoneNumberAndPassword_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAnalyticsInfo_args = __TObject:new{

}

function getAnalyticsInfo_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAnalyticsInfo_args:write(oprot)
  oprot:writeStructBegin('getAnalyticsInfo_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getAnalyticsInfo_result = __TObject:new{
  success,
  e
}

function getAnalyticsInfo_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = AnalyticsInfo:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getAnalyticsInfo_result:write(oprot)
  oprot:writeStructBegin('getAnalyticsInfo_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportClientStatistics_args = __TObject:new{
  reqSeq,
  category,
  count
}

function reportClientStatistics_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.category = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportClientStatistics_args:write(oprot)
  oprot:writeStructBegin('reportClientStatistics_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.category ~= nil then
    oprot:writeFieldBegin('category', TType.I32, 2)
    oprot:writeI32(self.category)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportClientStatistics_result = __TObject:new{
  e
}

function reportClientStatistics_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportClientStatistics_result:write(oprot)
  oprot:writeStructBegin('reportClientStatistics_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhoneNumberForLogin_args = __TObject:new{
  verifierFromPhone,
  pinCodeForPhone,
  verifierFromLogin
}

function verifyPhoneNumberForLogin_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifierFromPhone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCodeForPhone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.verifierFromLogin = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhoneNumberForLogin_args:write(oprot)
  oprot:writeStructBegin('verifyPhoneNumberForLogin_args')
  if self.verifierFromPhone ~= nil then
    oprot:writeFieldBegin('verifierFromPhone', TType.STRING, 2)
    oprot:writeString(self.verifierFromPhone)
    oprot:writeFieldEnd()
  end
  if self.pinCodeForPhone ~= nil then
    oprot:writeFieldBegin('pinCodeForPhone', TType.STRING, 3)
    oprot:writeString(self.pinCodeForPhone)
    oprot:writeFieldEnd()
  end
  if self.verifierFromLogin ~= nil then
    oprot:writeFieldBegin('verifierFromLogin', TType.STRING, 4)
    oprot:writeString(self.verifierFromLogin)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhoneNumberForLogin_result = __TObject:new{
  success,
  e
}

function verifyPhoneNumberForLogin_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhoneNumberForLogin_result:write(oprot)
  oprot:writeStructBegin('verifyPhoneNumberForLogin_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhoneNumber_args = __TObject:new{
  sessionId,
  pinCode,
  udidHash,
  migrationPincodeSessionId,
  oldUdidHash
}

function verifyPhoneNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.migrationPincodeSessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.oldUdidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhoneNumber_args:write(oprot)
  oprot:writeStructBegin('verifyPhoneNumber_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.migrationPincodeSessionId ~= nil then
    oprot:writeFieldBegin('migrationPincodeSessionId', TType.STRING, 5)
    oprot:writeString(self.migrationPincodeSessionId)
    oprot:writeFieldEnd()
  end
  if self.oldUdidHash ~= nil then
    oprot:writeFieldBegin('oldUdidHash', TType.STRING, 6)
    oprot:writeString(self.oldUdidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhoneNumber_result = __TObject:new{
  success,
  e
}

function verifyPhoneNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = PhoneVerificationResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhoneNumber_result:write(oprot)
  oprot:writeStructBegin('verifyPhoneNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIdsByRange_args = __TObject:new{
  start,
  count
}

function getBlockedContactIdsByRange_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.count = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIdsByRange_args:write(oprot)
  oprot:writeStructBegin('getBlockedContactIdsByRange_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.count ~= nil then
    oprot:writeFieldBegin('count', TType.I32, 3)
    oprot:writeI32(self.count)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedContactIdsByRange_result = __TObject:new{
  success,
  e
}

function getBlockedContactIdsByRange_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1541, _size1538 = iprot:readListBegin()
        for _i=1,_size1538 do
          local _elem1542 = iprot:readString()
          table.insert(self.success, _elem1542)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedContactIdsByRange_result:write(oprot)
  oprot:writeStructBegin('getBlockedContactIdsByRange_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1543 in ipairs(self.success) do
      oprot:writeString(iter1543)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedRecommendationIds_args = __TObject:new{

}

function getBlockedRecommendationIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedRecommendationIds_args:write(oprot)
  oprot:writeStructBegin('getBlockedRecommendationIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBlockedRecommendationIds_result = __TObject:new{
  success,
  e
}

function getBlockedRecommendationIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1547, _size1544 = iprot:readListBegin()
        for _i=1,_size1544 do
          local _elem1548 = iprot:readString()
          table.insert(self.success, _elem1548)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBlockedRecommendationIds_result:write(oprot)
  oprot:writeStructBegin('getBlockedRecommendationIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1549 in ipairs(self.success) do
      oprot:writeString(iter1549)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyBlockerIds_args = __TObject:new{

}

function getBuddyBlockerIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyBlockerIds_args:write(oprot)
  oprot:writeStructBegin('getBuddyBlockerIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyBlockerIds_result = __TObject:new{
  success,
  e
}

function getBuddyBlockerIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1553, _size1550 = iprot:readListBegin()
        for _i=1,_size1550 do
          local _elem1554 = iprot:readString()
          table.insert(self.success, _elem1554)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyBlockerIds_result:write(oprot)
  oprot:writeStructBegin('getBuddyBlockerIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1555 in ipairs(self.success) do
      oprot:writeString(iter1555)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyLocation_args = __TObject:new{
  mid,
  index
}

function getBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('getBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getBuddyLocation_result = __TObject:new{
  success,
  e
}

function getBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Geolocation:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('getBuddyLocation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactContactsModifiedSince_args = __TObject:new{
  timestamp
}

function getCompactContactsModifiedSince_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactContactsModifiedSince_args:write(oprot)
  oprot:writeStructBegin('getCompactContactsModifiedSince_args')
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 2)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactContactsModifiedSince_result = __TObject:new{
  success,
  e
}

function getCompactContactsModifiedSince_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1559, _size1556 = iprot:readListBegin()
        for _i=1,_size1556 do
          local _elem1560 = CompactContact:new{}
          _elem1560:read(iprot)
          table.insert(self.success, _elem1560)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactContactsModifiedSince_result:write(oprot)
  oprot:writeStructBegin('getCompactContactsModifiedSince_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1561 in ipairs(self.success) do
      iter1561:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactGroup_args = __TObject:new{
  groupId
}

function getCompactGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactGroup_args:write(oprot)
  oprot:writeStructBegin('getCompactGroup_args')
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactGroup_result = __TObject:new{
  success,
  e
}

function getCompactGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactGroup_result:write(oprot)
  oprot:writeStructBegin('getCompactGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactRoom_args = __TObject:new{
  roomId
}

function getCompactRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactRoom_args:write(oprot)
  oprot:writeStructBegin('getCompactRoom_args')
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCompactRoom_result = __TObject:new{
  success,
  e
}

function getCompactRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCompactRoom_result:write(oprot)
  oprot:writeStructBegin('getCompactRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContact_args = __TObject:new{
  id
}

function getContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContact_args:write(oprot)
  oprot:writeStructBegin('getContact_args')
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContact_result = __TObject:new{
  success,
  e
}

function getContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContact_result:write(oprot)
  oprot:writeStructBegin('getContact_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContacts_args = __TObject:new{
  ids
}

function getContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.ids = {}
        local _etype1565, _size1562 = iprot:readListBegin()
        for _i=1,_size1562 do
          local _elem1566 = iprot:readString()
          table.insert(self.ids, _elem1566)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContacts_args:write(oprot)
  oprot:writeStructBegin('getContacts_args')
  if self.ids ~= nil then
    oprot:writeFieldBegin('ids', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.ids)
    for _,iter1567 in ipairs(self.ids) do
      oprot:writeString(iter1567)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContacts_result = __TObject:new{
  success,
  e
}

function getContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1571, _size1568 = iprot:readListBegin()
        for _i=1,_size1568 do
          local _elem1572 = Contact:new{}
          _elem1572:read(iprot)
          table.insert(self.success, _elem1572)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContacts_result:write(oprot)
  oprot:writeStructBegin('getContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1573 in ipairs(self.success) do
      iter1573:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContactWithFriendRequestStatus_args = __TObject:new{
  id
}

function getContactWithFriendRequestStatus_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContactWithFriendRequestStatus_args:write(oprot)
  oprot:writeStructBegin('getContactWithFriendRequestStatus_args')
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getContactWithFriendRequestStatus_result = __TObject:new{
  success,
  e
}

function getContactWithFriendRequestStatus_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getContactWithFriendRequestStatus_result:write(oprot)
  oprot:writeStructBegin('getContactWithFriendRequestStatus_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCountryWithRequestIp_args = __TObject:new{

}

function getCountryWithRequestIp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCountryWithRequestIp_args:write(oprot)
  oprot:writeStructBegin('getCountryWithRequestIp_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCountryWithRequestIp_result = __TObject:new{
  success,
  e
}

function getCountryWithRequestIp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCountryWithRequestIp_result:write(oprot)
  oprot:writeStructBegin('getCountryWithRequestIp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFavoriteMids_args = __TObject:new{

}

function getFavoriteMids_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFavoriteMids_args:write(oprot)
  oprot:writeStructBegin('getFavoriteMids_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getFavoriteMids_result = __TObject:new{
  success,
  e
}

function getFavoriteMids_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1577, _size1574 = iprot:readListBegin()
        for _i=1,_size1574 do
          local _elem1578 = iprot:readString()
          table.insert(self.success, _elem1578)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getFavoriteMids_result:write(oprot)
  oprot:writeStructBegin('getFavoriteMids_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1579 in ipairs(self.success) do
      oprot:writeString(iter1579)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroup_args = __TObject:new{
  groupId
}

function getGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroup_args:write(oprot)
  oprot:writeStructBegin('getGroup_args')
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroup_result = __TObject:new{
  success,
  e
}

function getGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroup_result:write(oprot)
  oprot:writeStructBegin('getGroup_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsInvited_args = __TObject:new{

}

function getGroupIdsInvited_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsInvited_args:write(oprot)
  oprot:writeStructBegin('getGroupIdsInvited_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsInvited_result = __TObject:new{
  success,
  e
}

function getGroupIdsInvited_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1583, _size1580 = iprot:readListBegin()
        for _i=1,_size1580 do
          local _elem1584 = iprot:readString()
          table.insert(self.success, _elem1584)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsInvited_result:write(oprot)
  oprot:writeStructBegin('getGroupIdsInvited_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1585 in ipairs(self.success) do
      oprot:writeString(iter1585)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsJoined_args = __TObject:new{

}

function getGroupIdsJoined_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsJoined_args:write(oprot)
  oprot:writeStructBegin('getGroupIdsJoined_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupIdsJoined_result = __TObject:new{
  success,
  e
}

function getGroupIdsJoined_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1589, _size1586 = iprot:readListBegin()
        for _i=1,_size1586 do
          local _elem1590 = iprot:readString()
          table.insert(self.success, _elem1590)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupIdsJoined_result:write(oprot)
  oprot:writeStructBegin('getGroupIdsJoined_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1591 in ipairs(self.success) do
      oprot:writeString(iter1591)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroups_args = __TObject:new{
  groupIds
}

function getGroups_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.groupIds = {}
        local _etype1595, _size1592 = iprot:readListBegin()
        for _i=1,_size1592 do
          local _elem1596 = iprot:readString()
          table.insert(self.groupIds, _elem1596)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroups_args:write(oprot)
  oprot:writeStructBegin('getGroups_args')
  if self.groupIds ~= nil then
    oprot:writeFieldBegin('groupIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.groupIds)
    for _,iter1597 in ipairs(self.groupIds) do
      oprot:writeString(iter1597)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroups_result = __TObject:new{
  success,
  e
}

function getGroups_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1601, _size1598 = iprot:readListBegin()
        for _i=1,_size1598 do
          local _elem1602 = Group:new{}
          _elem1602:read(iprot)
          table.insert(self.success, _elem1602)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroups_result:write(oprot)
  oprot:writeStructBegin('getGroups_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1603 in ipairs(self.success) do
      iter1603:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getHiddenContactMids_args = __TObject:new{

}

function getHiddenContactMids_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getHiddenContactMids_args:write(oprot)
  oprot:writeStructBegin('getHiddenContactMids_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getHiddenContactMids_result = __TObject:new{
  success,
  e
}

function getHiddenContactMids_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1607, _size1604 = iprot:readListBegin()
        for _i=1,_size1604 do
          local _elem1608 = iprot:readString()
          table.insert(self.success, _elem1608)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getHiddenContactMids_result:write(oprot)
  oprot:writeStructBegin('getHiddenContactMids_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1609 in ipairs(self.success) do
      oprot:writeString(iter1609)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getIdentityIdentifier_args = __TObject:new{

}

function getIdentityIdentifier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getIdentityIdentifier_args:write(oprot)
  oprot:writeStructBegin('getIdentityIdentifier_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getIdentityIdentifier_result = __TObject:new{
  success,
  e
}

function getIdentityIdentifier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getIdentityIdentifier_result:write(oprot)
  oprot:writeStructBegin('getIdentityIdentifier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastAnnouncementIndex_args = __TObject:new{

}

function getLastAnnouncementIndex_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastAnnouncementIndex_args:write(oprot)
  oprot:writeStructBegin('getLastAnnouncementIndex_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastAnnouncementIndex_result = __TObject:new{
  success,
  e
}

function getLastAnnouncementIndex_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastAnnouncementIndex_result:write(oprot)
  oprot:writeStructBegin('getLastAnnouncementIndex_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastOpRevision_args = __TObject:new{

}

function getLastOpRevision_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastOpRevision_args:write(oprot)
  oprot:writeStructBegin('getLastOpRevision_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastOpRevision_result = __TObject:new{
  success,
  e
}

function getLastOpRevision_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastOpRevision_result:write(oprot)
  oprot:writeStructBegin('getLastOpRevision_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSuggestRevisions_args = __TObject:new{

}

function getSuggestRevisions_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSuggestRevisions_args:write(oprot)
  oprot:writeStructBegin('getSuggestRevisions_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSuggestRevisions_result = __TObject:new{
  success,
  e
}

function getSuggestRevisions_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SuggestDictionaryRevisions:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSuggestRevisions_result:write(oprot)
  oprot:writeStructBegin('getSuggestRevisions_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessagesV2WithReadCount_args = __TObject:new{
  messageBoxId,
  endMessageId,
  messagesCount
}

function getPreviousMessagesV2WithReadCount_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.endMessageId = MessageBoxV2MessageId:new{}
        self.endMessageId:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessagesV2WithReadCount_args:write(oprot)
  oprot:writeStructBegin('getPreviousMessagesV2WithReadCount_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.endMessageId ~= nil then
    oprot:writeFieldBegin('endMessageId', TType.STRUCT, 3)
    self.endMessageId:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessagesV2WithReadCount_result = __TObject:new{
  success,
  e
}

function getPreviousMessagesV2WithReadCount_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1613, _size1610 = iprot:readListBegin()
        for _i=1,_size1610 do
          local _elem1614 = Message:new{}
          _elem1614:read(iprot)
          table.insert(self.success, _elem1614)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessagesV2WithReadCount_result:write(oprot)
  oprot:writeStructBegin('getPreviousMessagesV2WithReadCount_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1615 in ipairs(self.success) do
      iter1615:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBox_args = __TObject:new{
  channelId,
  messageBoxId,
  lastMessagesCount
}

function getMessageBox_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBox_args:write(oprot)
  oprot:writeStructBegin('getMessageBox_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 4)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBox_result = __TObject:new{
  success,
  e
}

function getMessageBox_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBox:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBox_result:write(oprot)
  oprot:writeStructBegin('getMessageBox_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUp_args = __TObject:new{
  mid
}

function getMessageBoxCompactWrapUp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUp_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUp_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUp_result = __TObject:new{
  success,
  e
}

function getMessageBoxCompactWrapUp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUp:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUp_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpList_args = __TObject:new{
  start,
  messageBoxCount
}

function getMessageBoxCompactWrapUpList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messageBoxCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpList_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.messageBoxCount ~= nil then
    oprot:writeFieldBegin('messageBoxCount', TType.I32, 3)
    oprot:writeI32(self.messageBoxCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpList_result = __TObject:new{
  success,
  e
}

function getMessageBoxCompactWrapUpList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUpResponse:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxList_args = __TObject:new{
  channelId,
  lastMessagesCount
}

function getMessageBoxList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxList_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 3)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxList_result = __TObject:new{
  success,
  e
}

function getMessageBoxList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1619, _size1616 = iprot:readListBegin()
        for _i=1,_size1616 do
          local _elem1620 = TMessageBox:new{}
          _elem1620:read(iprot)
          table.insert(self.success, _elem1620)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1621 in ipairs(self.success) do
      iter1621:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxListByStatus_args = __TObject:new{
  channelId,
  lastMessagesCount,
  status
}

function getMessageBoxListByStatus_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.lastMessagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.status = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxListByStatus_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxListByStatus_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.lastMessagesCount ~= nil then
    oprot:writeFieldBegin('lastMessagesCount', TType.I32, 3)
    oprot:writeI32(self.lastMessagesCount)
    oprot:writeFieldEnd()
  end
  if self.status ~= nil then
    oprot:writeFieldBegin('status', TType.I32, 4)
    oprot:writeI32(self.status)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxListByStatus_result = __TObject:new{
  success,
  e
}

function getMessageBoxListByStatus_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1625, _size1622 = iprot:readListBegin()
        for _i=1,_size1622 do
          local _elem1626 = TMessageBox:new{}
          _elem1626:read(iprot)
          table.insert(self.success, _elem1626)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxListByStatus_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxListByStatus_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1627 in ipairs(self.success) do
      iter1627:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUp_args = __TObject:new{
  mid
}

function getMessageBoxWrapUp_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUp_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUp_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUp_result = __TObject:new{
  success,
  e
}

function getMessageBoxWrapUp_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUp:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUp_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUp_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUpList_args = __TObject:new{
  start,
  messageBoxCount
}

function getMessageBoxWrapUpList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.start = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messageBoxCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUpList_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUpList_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I32, 2)
    oprot:writeI32(self.start)
    oprot:writeFieldEnd()
  end
  if self.messageBoxCount ~= nil then
    oprot:writeFieldBegin('messageBoxCount', TType.I32, 3)
    oprot:writeI32(self.messageBoxCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxWrapUpList_result = __TObject:new{
  success,
  e
}

function getMessageBoxWrapUpList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUpResponse:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxWrapUpList_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxWrapUpList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessagesBySequenceNumber_args = __TObject:new{
  channelId,
  messageBoxId,
  startSeq,
  endSeq
}

function getMessagesBySequenceNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.channelId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.startSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I64 then
        self.endSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessagesBySequenceNumber_args:write(oprot)
  oprot:writeStructBegin('getMessagesBySequenceNumber_args')
  if self.channelId ~= nil then
    oprot:writeFieldBegin('channelId', TType.STRING, 2)
    oprot:writeString(self.channelId)
    oprot:writeFieldEnd()
  end
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 3)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.startSeq ~= nil then
    oprot:writeFieldBegin('startSeq', TType.I64, 4)
    oprot:writeI64(self.startSeq)
    oprot:writeFieldEnd()
  end
  if self.endSeq ~= nil then
    oprot:writeFieldBegin('endSeq', TType.I64, 5)
    oprot:writeI64(self.endSeq)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessagesBySequenceNumber_result = __TObject:new{
  success,
  e
}

function getMessagesBySequenceNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1631, _size1628 = iprot:readListBegin()
        for _i=1,_size1628 do
          local _elem1632 = Message:new{}
          _elem1632:read(iprot)
          table.insert(self.success, _elem1632)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessagesBySequenceNumber_result:write(oprot)
  oprot:writeStructBegin('getMessagesBySequenceNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1633 in ipairs(self.success) do
      iter1633:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessages_args = __TObject:new{
  messageBoxId,
  startSeq,
  messagesCount
}

function getNextMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.startSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessages_args:write(oprot)
  oprot:writeStructBegin('getNextMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.startSeq ~= nil then
    oprot:writeFieldBegin('startSeq', TType.I64, 3)
    oprot:writeI64(self.startSeq)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessages_result = __TObject:new{
  success,
  e
}

function getNextMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1637, _size1634 = iprot:readListBegin()
        for _i=1,_size1634 do
          local _elem1638 = Message:new{}
          _elem1638:read(iprot)
          table.insert(self.success, _elem1638)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessages_result:write(oprot)
  oprot:writeStructBegin('getNextMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1639 in ipairs(self.success) do
      iter1639:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNotificationPolicy_args = __TObject:new{
  carrier
}

function getNotificationPolicy_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNotificationPolicy_args:write(oprot)
  oprot:writeStructBegin('getNotificationPolicy_args')
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 2)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNotificationPolicy_result = __TObject:new{
  success,
  e
}

function getNotificationPolicy_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1643, _size1640 = iprot:readListBegin()
        for _i=1,_size1640 do
          local _elem1644 = iprot:readI32()
          table.insert(self.success, _elem1644)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNotificationPolicy_result:write(oprot)
  oprot:writeStructBegin('getNotificationPolicy_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.I32, #self.success)
    for _,iter1645 in ipairs(self.success) do
      oprot:writeI32(iter1645)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessages_args = __TObject:new{
  messageBoxId,
  endSeq,
  messagesCount
}

function getPreviousMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.endSeq = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessages_args:write(oprot)
  oprot:writeStructBegin('getPreviousMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.endSeq ~= nil then
    oprot:writeFieldBegin('endSeq', TType.I64, 3)
    oprot:writeI64(self.endSeq)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPreviousMessages_result = __TObject:new{
  success,
  e
}

function getPreviousMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1649, _size1646 = iprot:readListBegin()
        for _i=1,_size1646 do
          local _elem1650 = Message:new{}
          _elem1650:read(iprot)
          table.insert(self.success, _elem1650)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPreviousMessages_result:write(oprot)
  oprot:writeStructBegin('getPreviousMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1651 in ipairs(self.success) do
      iter1651:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProfile_args = __TObject:new{

}

function getProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProfile_args:write(oprot)
  oprot:writeStructBegin('getProfile_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProfile_result = __TObject:new{
  success,
  e
}

function getProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Profile:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProfile_result:write(oprot)
  oprot:writeStructBegin('getProfile_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidateList_args = __TObject:new{
  sessionId
}

function getProximityMatchCandidateList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidateList_args:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidateList_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidateList_result = __TObject:new{
  success,
  e
}

function getProximityMatchCandidateList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProximityMatchCandidateResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidateList_result:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidateList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidates_args = __TObject:new{
  sessionId
}

function getProximityMatchCandidates_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidates_args:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidates_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProximityMatchCandidates_result = __TObject:new{
  success,
  e
}

function getProximityMatchCandidates_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.SET then
        self.success = {}
        local _etype1655, _size1652 = iprot:readSetBegin()
        for _i=1,_size1652 do
          local _elem1656 = Contact:new{}
          _elem1656:read(iprot)
          self.success[_elem1656] = _elem1656
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProximityMatchCandidates_result:write(oprot)
  oprot:writeStructBegin('getProximityMatchCandidates_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.SET, 0)
    oprot:writeSetBegin(TType.STRUCT, ttable_size(self.success))
    for iter1657,_ in pairs(self.success) do
      iter1657:write(oprot)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessages_args = __TObject:new{
  messageBoxId,
  messagesCount
}

function getRecentMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessages_args:write(oprot)
  oprot:writeStructBegin('getRecentMessages_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 3)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessages_result = __TObject:new{
  success,
  e
}

function getRecentMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1661, _size1658 = iprot:readListBegin()
        for _i=1,_size1658 do
          local _elem1662 = Message:new{}
          _elem1662:read(iprot)
          table.insert(self.success, _elem1662)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessages_result:write(oprot)
  oprot:writeStructBegin('getRecentMessages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1663 in ipairs(self.success) do
      iter1663:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecommendationIds_args = __TObject:new{

}

function getRecommendationIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecommendationIds_args:write(oprot)
  oprot:writeStructBegin('getRecommendationIds_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecommendationIds_result = __TObject:new{
  success,
  e
}

function getRecommendationIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1667, _size1664 = iprot:readListBegin()
        for _i=1,_size1664 do
          local _elem1668 = iprot:readString()
          table.insert(self.success, _elem1668)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecommendationIds_result:write(oprot)
  oprot:writeStructBegin('getRecommendationIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRING, #self.success)
    for _,iter1669 in ipairs(self.success) do
      oprot:writeString(iter1669)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRoom_args = __TObject:new{
  roomId
}

function getRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRoom_args:write(oprot)
  oprot:writeStructBegin('getRoom_args')
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRoom_result = __TObject:new{
  success,
  e
}

function getRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRoom_result:write(oprot)
  oprot:writeStructBegin('getRoom_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRSAKeyInfo_args = __TObject:new{
  provider
}

function getRSAKeyInfo_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRSAKeyInfo_args:write(oprot)
  oprot:writeStructBegin('getRSAKeyInfo_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 2)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRSAKeyInfo_result = __TObject:new{
  success,
  e
}

function getRSAKeyInfo_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RSAKey:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRSAKeyInfo_result:write(oprot)
  oprot:writeStructBegin('getRSAKeyInfo_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getServerTime_args = __TObject:new{

}

function getServerTime_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getServerTime_args:write(oprot)
  oprot:writeStructBegin('getServerTime_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getServerTime_result = __TObject:new{
  success,
  e
}

function getServerTime_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getServerTime_result:write(oprot)
  oprot:writeStructBegin('getServerTime_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSessions_args = __TObject:new{

}

function getSessions_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSessions_args:write(oprot)
  oprot:writeStructBegin('getSessions_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSessions_result = __TObject:new{
  success,
  e
}

function getSessions_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1673, _size1670 = iprot:readListBegin()
        for _i=1,_size1670 do
          local _elem1674 = LoginSession:new{}
          _elem1674:read(iprot)
          table.insert(self.success, _elem1674)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSessions_result:write(oprot)
  oprot:writeStructBegin('getSessions_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1675 in ipairs(self.success) do
      iter1675:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettings_args = __TObject:new{

}

function getSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettings_args:write(oprot)
  oprot:writeStructBegin('getSettings_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettings_result = __TObject:new{
  success,
  e
}

function getSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Settings:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettings_result:write(oprot)
  oprot:writeStructBegin('getSettings_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupsV2_args = __TObject:new{
  groupIds
}

function getGroupsV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.groupIds = {}
        local _etype1679, _size1676 = iprot:readListBegin()
        for _i=1,_size1676 do
          local _elem1680 = iprot:readString()
          table.insert(self.groupIds, _elem1680)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupsV2_args:write(oprot)
  oprot:writeStructBegin('getGroupsV2_args')
  if self.groupIds ~= nil then
    oprot:writeFieldBegin('groupIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.groupIds)
    for _,iter1681 in ipairs(self.groupIds) do
      oprot:writeString(iter1681)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getGroupsV2_result = __TObject:new{
  success,
  e
}

function getGroupsV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1685, _size1682 = iprot:readListBegin()
        for _i=1,_size1682 do
          local _elem1686 = Group:new{}
          _elem1686:read(iprot)
          table.insert(self.success, _elem1686)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getGroupsV2_result:write(oprot)
  oprot:writeStructBegin('getGroupsV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1687 in ipairs(self.success) do
      iter1687:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettingsAttributes_args = __TObject:new{
  attrBitset
}

function getSettingsAttributes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attrBitset = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettingsAttributes_args:write(oprot)
  oprot:writeStructBegin('getSettingsAttributes_args')
  if self.attrBitset ~= nil then
    oprot:writeFieldBegin('attrBitset', TType.I32, 2)
    oprot:writeI32(self.attrBitset)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSettingsAttributes_result = __TObject:new{
  success,
  e
}

function getSettingsAttributes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Settings:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSettingsAttributes_result:write(oprot)
  oprot:writeStructBegin('getSettingsAttributes_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSystemConfiguration_args = __TObject:new{

}

function getSystemConfiguration_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSystemConfiguration_args:write(oprot)
  oprot:writeStructBegin('getSystemConfiguration_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getSystemConfiguration_result = __TObject:new{
  success,
  e
}

function getSystemConfiguration_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = SystemConfiguration:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getSystemConfiguration_result:write(oprot)
  oprot:writeStructBegin('getSystemConfiguration_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getUserTicket_args = __TObject:new{

}

function getUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getUserTicket_args:write(oprot)
  oprot:writeStructBegin('getUserTicket_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getUserTicket_result = __TObject:new{
  success,
  e
}

function getUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Ticket:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getUserTicket_result:write(oprot)
  oprot:writeStructBegin('getUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getWapInvitation_args = __TObject:new{
  invitationHash
}

function getWapInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.invitationHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getWapInvitation_args:write(oprot)
  oprot:writeStructBegin('getWapInvitation_args')
  if self.invitationHash ~= nil then
    oprot:writeFieldBegin('invitationHash', TType.STRING, 2)
    oprot:writeString(self.invitationHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getWapInvitation_result = __TObject:new{
  success,
  e
}

function getWapInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = WapInvitation:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getWapInvitation_result:write(oprot)
  oprot:writeStructBegin('getWapInvitation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

invalidateUserTicket_args = __TObject:new{

}

function invalidateUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function invalidateUserTicket_args:write(oprot)
  oprot:writeStructBegin('invalidateUserTicket_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

invalidateUserTicket_result = __TObject:new{
  e
}

function invalidateUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function invalidateUserTicket_result:write(oprot)
  oprot:writeStructBegin('invalidateUserTicket_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteFriendsBySms_args = __TObject:new{
  phoneNumberList
}

function inviteFriendsBySms_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.phoneNumberList = {}
        local _etype1691, _size1688 = iprot:readListBegin()
        for _i=1,_size1688 do
          local _elem1692 = iprot:readString()
          table.insert(self.phoneNumberList, _elem1692)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteFriendsBySms_args:write(oprot)
  oprot:writeStructBegin('inviteFriendsBySms_args')
  if self.phoneNumberList ~= nil then
    oprot:writeFieldBegin('phoneNumberList', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.phoneNumberList)
    for _,iter1693 in ipairs(self.phoneNumberList) do
      oprot:writeString(iter1693)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteFriendsBySms_result = __TObject:new{
  e
}

function inviteFriendsBySms_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteFriendsBySms_result:write(oprot)
  oprot:writeStructBegin('inviteFriendsBySms_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoGroup_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function inviteIntoGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1697, _size1694 = iprot:readListBegin()
        for _i=1,_size1694 do
          local _elem1698 = iprot:readString()
          table.insert(self.contactIds, _elem1698)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoGroup_args:write(oprot)
  oprot:writeStructBegin('inviteIntoGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1699 in ipairs(self.contactIds) do
      oprot:writeString(iter1699)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoGroup_result = __TObject:new{
  e
}

function inviteIntoGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoGroup_result:write(oprot)
  oprot:writeStructBegin('inviteIntoGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoRoom_args = __TObject:new{
  reqSeq,
  roomId,
  contactIds
}

function inviteIntoRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1703, _size1700 = iprot:readListBegin()
        for _i=1,_size1700 do
          local _elem1704 = iprot:readString()
          table.insert(self.contactIds, _elem1704)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoRoom_args:write(oprot)
  oprot:writeStructBegin('inviteIntoRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1705 in ipairs(self.contactIds) do
      oprot:writeString(iter1705)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteIntoRoom_result = __TObject:new{
  e
}

function inviteIntoRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteIntoRoom_result:write(oprot)
  oprot:writeStructBegin('inviteIntoRoom_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteViaEmail_args = __TObject:new{
  reqSeq,
  email,
  name
}

function inviteViaEmail_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.email = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.name = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteViaEmail_args:write(oprot)
  oprot:writeStructBegin('inviteViaEmail_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.email ~= nil then
    oprot:writeFieldBegin('email', TType.STRING, 2)
    oprot:writeString(self.email)
    oprot:writeFieldEnd()
  end
  if self.name ~= nil then
    oprot:writeFieldBegin('name', TType.STRING, 3)
    oprot:writeString(self.name)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

inviteViaEmail_result = __TObject:new{
  e
}

function inviteViaEmail_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function inviteViaEmail_result:write(oprot)
  oprot:writeStructBegin('inviteViaEmail_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isIdentityIdentifierAvailable_args = __TObject:new{
  provider,
  identifier
}

function isIdentityIdentifierAvailable_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isIdentityIdentifierAvailable_args:write(oprot)
  oprot:writeStructBegin('isIdentityIdentifierAvailable_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 3)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isIdentityIdentifierAvailable_result = __TObject:new{
  success,
  e
}

function isIdentityIdentifierAvailable_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isIdentityIdentifierAvailable_result:write(oprot)
  oprot:writeStructBegin('isIdentityIdentifierAvailable_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isUseridAvailable_args = __TObject:new{
  userid
}

function isUseridAvailable_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isUseridAvailable_args:write(oprot)
  oprot:writeStructBegin('isUseridAvailable_args')
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

isUseridAvailable_result = __TObject:new{
  success,
  e
}

function isUseridAvailable_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function isUseridAvailable_result:write(oprot)
  oprot:writeStructBegin('isUseridAvailable_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

kickoutFromGroup_args = __TObject:new{
  reqSeq,
  groupId,
  contactIds
}

function kickoutFromGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1709, _size1706 = iprot:readListBegin()
        for _i=1,_size1706 do
          local _elem1710 = iprot:readString()
          table.insert(self.contactIds, _elem1710)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function kickoutFromGroup_args:write(oprot)
  oprot:writeStructBegin('kickoutFromGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1711 in ipairs(self.contactIds) do
      oprot:writeString(iter1711)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

kickoutFromGroup_result = __TObject:new{
  e
}

function kickoutFromGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function kickoutFromGroup_result:write(oprot)
  oprot:writeStructBegin('kickoutFromGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueGroupTicket_args = __TObject:new{
  groupMid
}

function reissueGroupTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.groupMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueGroupTicket_args:write(oprot)
  oprot:writeStructBegin('reissueGroupTicket_args')
  if self.groupMid ~= nil then
    oprot:writeFieldBegin('groupMid', TType.STRING, 1)
    oprot:writeString(self.groupMid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueGroupTicket_result = __TObject:new{
  success,
  e
}

function reissueGroupTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueGroupTicket_result:write(oprot)
  oprot:writeStructBegin('reissueGroupTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findGroupByTicket_args = __TObject:new{
  ticketId
}

function findGroupByTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.ticketId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findGroupByTicket_args:write(oprot)
  oprot:writeStructBegin('findGroupByTicket_args')
  if self.ticketId ~= nil then
    oprot:writeFieldBegin('ticketId', TType.STRING, 1)
    oprot:writeString(self.ticketId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findGroupByTicket_result = __TObject:new{
  success,
  e
}

function findGroupByTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Group:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findGroupByTicket_result:write(oprot)
  oprot:writeStructBegin('findGroupByTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveGroup_args = __TObject:new{
  reqSeq,
  groupId
}

function leaveGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveGroup_args:write(oprot)
  oprot:writeStructBegin('leaveGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveGroup_result = __TObject:new{
  e
}

function leaveGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveGroup_result:write(oprot)
  oprot:writeStructBegin('leaveGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveRoom_args = __TObject:new{
  reqSeq,
  roomId
}

function leaveRoom_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.roomId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveRoom_args:write(oprot)
  oprot:writeStructBegin('leaveRoom_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.roomId ~= nil then
    oprot:writeFieldBegin('roomId', TType.STRING, 2)
    oprot:writeString(self.roomId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

leaveRoom_result = __TObject:new{
  e
}

function leaveRoom_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function leaveRoom_result:write(oprot)
  oprot:writeStructBegin('leaveRoom_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredential_args = __TObject:new{
  identityProvider,
  identifier,
  password,
  keepLoggedIn,
  accessLocation,
  systemName,
  certificate
}

function loginWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.accessLocation = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.certificate = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredential_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.accessLocation ~= nil then
    oprot:writeFieldBegin('accessLocation', TType.STRING, 6)
    oprot:writeString(self.accessLocation)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 7)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  if self.certificate ~= nil then
    oprot:writeFieldBegin('certificate', TType.STRING, 9)
    oprot:writeString(self.certificate)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function loginWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredentialForCertificate_args = __TObject:new{
  identityProvider,
  identifier,
  password,
  keepLoggedIn,
  accessLocation,
  systemName,
  certificate
}

function loginWithIdentityCredentialForCertificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.BOOL then
        self.keepLoggedIn = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.accessLocation = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.systemName = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.certificate = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredentialForCertificate_args:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredentialForCertificate_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  if self.keepLoggedIn ~= nil then
    oprot:writeFieldBegin('keepLoggedIn', TType.BOOL, 5)
    oprot:writeBool(self.keepLoggedIn)
    oprot:writeFieldEnd()
  end
  if self.accessLocation ~= nil then
    oprot:writeFieldBegin('accessLocation', TType.STRING, 6)
    oprot:writeString(self.accessLocation)
    oprot:writeFieldEnd()
  end
  if self.systemName ~= nil then
    oprot:writeFieldBegin('systemName', TType.STRING, 7)
    oprot:writeString(self.systemName)
    oprot:writeFieldEnd()
  end
  if self.certificate ~= nil then
    oprot:writeFieldBegin('certificate', TType.STRING, 9)
    oprot:writeString(self.certificate)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithIdentityCredentialForCertificate_result = __TObject:new{
  success,
  e
}

function loginWithIdentityCredentialForCertificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithIdentityCredentialForCertificate_result:write(oprot)
  oprot:writeStructBegin('loginWithIdentityCredentialForCertificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifier_args = __TObject:new{
  verifier
}

function loginWithVerifier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifier_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifier_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifier_result = __TObject:new{
  success,
  e
}

function loginWithVerifier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifier_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCerificate_args = __TObject:new{
  verifier
}

function loginWithVerifierForCerificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCerificate_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCerificate_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCerificate_result = __TObject:new{
  success,
  e
}

function loginWithVerifierForCerificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCerificate_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCerificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCertificate_args = __TObject:new{
  verifier
}

function loginWithVerifierForCertificate_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCertificate_args:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCertificate_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

loginWithVerifierForCertificate_result = __TObject:new{
  success,
  e
}

function loginWithVerifierForCertificate_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = LoginResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function loginWithVerifierForCertificate_result:write(oprot)
  oprot:writeStructBegin('loginWithVerifierForCertificate_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logout_args = __TObject:new{

}

function logout_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logout_args:write(oprot)
  oprot:writeStructBegin('logout_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logout_result = __TObject:new{
  e
}

function logout_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logout_result:write(oprot)
  oprot:writeStructBegin('logout_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logoutSession_args = __TObject:new{
  tokenKey
}

function logoutSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.tokenKey = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logoutSession_args:write(oprot)
  oprot:writeStructBegin('logoutSession_args')
  if self.tokenKey ~= nil then
    oprot:writeFieldBegin('tokenKey', TType.STRING, 2)
    oprot:writeString(self.tokenKey)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

logoutSession_result = __TObject:new{
  e
}

function logoutSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function logoutSession_result:write(oprot)
  oprot:writeStructBegin('logoutSession_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

noop_args = __TObject:new{

}

function noop_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function noop_args:write(oprot)
  oprot:writeStructBegin('noop_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

noop_result = __TObject:new{
  e
}

function noop_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function noop_result:write(oprot)
  oprot:writeStructBegin('noop_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifiedRedirect_args = __TObject:new{
  paramMap
}

function notifiedRedirect_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.MAP then
        self.paramMap = {}
        local _ktype1713, _vtype1714, _size1712 = iprot:readMapBegin() 
        for _i=1,_size1712 do
          local _key1716 = iprot:readString()
          local _val1717 = iprot:readString()
          self.paramMap[_key1716] = _val1717
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifiedRedirect_args:write(oprot)
  oprot:writeStructBegin('notifiedRedirect_args')
  if self.paramMap ~= nil then
    oprot:writeFieldBegin('paramMap', TType.MAP, 2)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.paramMap))
    for kiter1718,viter1719 in pairs(self.paramMap) do
      oprot:writeString(kiter1718)
      oprot:writeString(viter1719)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifiedRedirect_result = __TObject:new{
  e
}

function notifiedRedirect_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifiedRedirect_result:write(oprot)
  oprot:writeStructBegin('notifiedRedirect_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyBuddyOnAir_args = __TObject:new{
  seq,
  receiverMids
}

function notifyBuddyOnAir_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1723, _size1720 = iprot:readListBegin()
        for _i=1,_size1720 do
          local _elem1724 = iprot:readString()
          table.insert(self.receiverMids, _elem1724)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyBuddyOnAir_args:write(oprot)
  oprot:writeStructBegin('notifyBuddyOnAir_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1725 in ipairs(self.receiverMids) do
      oprot:writeString(iter1725)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyBuddyOnAir_result = __TObject:new{
  success,
  e
}

function notifyBuddyOnAir_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1727, _vtype1728, _size1726 = iprot:readMapBegin() 
        for _i=1,_size1726 do
          local _key1730 = iprot:readString()
          local _val1731 = iprot:readString()
          self.success[_key1730] = _val1731
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyBuddyOnAir_result:write(oprot)
  oprot:writeStructBegin('notifyBuddyOnAir_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1732,viter1733 in pairs(self.success) do
      oprot:writeString(kiter1732)
      oprot:writeString(viter1733)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyIndividualEvent_args = __TObject:new{
  notificationStatus,
  receiverMids
}

function notifyIndividualEvent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.notificationStatus = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1737, _size1734 = iprot:readListBegin()
        for _i=1,_size1734 do
          local _elem1738 = iprot:readString()
          table.insert(self.receiverMids, _elem1738)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyIndividualEvent_args:write(oprot)
  oprot:writeStructBegin('notifyIndividualEvent_args')
  if self.notificationStatus ~= nil then
    oprot:writeFieldBegin('notificationStatus', TType.I32, 2)
    oprot:writeI32(self.notificationStatus)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1739 in ipairs(self.receiverMids) do
      oprot:writeString(iter1739)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyIndividualEvent_result = __TObject:new{
  e
}

function notifyIndividualEvent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyIndividualEvent_result:write(oprot)
  oprot:writeStructBegin('notifyIndividualEvent_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyInstalled_args = __TObject:new{
  udidHash,
  applicationTypeWithExtensions
}

function notifyInstalled_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.applicationTypeWithExtensions = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyInstalled_args:write(oprot)
  oprot:writeStructBegin('notifyInstalled_args')
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 2)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.applicationTypeWithExtensions ~= nil then
    oprot:writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
    oprot:writeString(self.applicationTypeWithExtensions)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyInstalled_result = __TObject:new{
  e
}

function notifyInstalled_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyInstalled_result:write(oprot)
  oprot:writeStructBegin('notifyInstalled_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyRegistrationComplete_args = __TObject:new{
  udidHash,
  applicationTypeWithExtensions
}

function notifyRegistrationComplete_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.applicationTypeWithExtensions = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyRegistrationComplete_args:write(oprot)
  oprot:writeStructBegin('notifyRegistrationComplete_args')
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 2)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.applicationTypeWithExtensions ~= nil then
    oprot:writeFieldBegin('applicationTypeWithExtensions', TType.STRING, 3)
    oprot:writeString(self.applicationTypeWithExtensions)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyRegistrationComplete_result = __TObject:new{
  e
}

function notifyRegistrationComplete_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyRegistrationComplete_result:write(oprot)
  oprot:writeStructBegin('notifyRegistrationComplete_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifySleep_args = __TObject:new{
  lastRev,
  badge
}

function notifySleep_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.lastRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.badge = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifySleep_args:write(oprot)
  oprot:writeStructBegin('notifySleep_args')
  if self.lastRev ~= nil then
    oprot:writeFieldBegin('lastRev', TType.I64, 2)
    oprot:writeI64(self.lastRev)
    oprot:writeFieldEnd()
  end
  if self.badge ~= nil then
    oprot:writeFieldBegin('badge', TType.I32, 3)
    oprot:writeI32(self.badge)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifySleep_result = __TObject:new{
  e
}

function notifySleep_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifySleep_result:write(oprot)
  oprot:writeStructBegin('notifySleep_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyUpdated_args = __TObject:new{
  lastRev,
  deviceInfo
}

function notifyUpdated_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.lastRev = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyUpdated_args:write(oprot)
  oprot:writeStructBegin('notifyUpdated_args')
  if self.lastRev ~= nil then
    oprot:writeFieldBegin('lastRev', TType.I64, 2)
    oprot:writeI64(self.lastRev)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 3)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyUpdated_result = __TObject:new{
  e
}

function notifyUpdated_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyUpdated_result:write(oprot)
  oprot:writeStructBegin('notifyUpdated_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

openProximityMatch_args = __TObject:new{
  location
}

function openProximityMatch_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.location = Location:new{}
        self.location:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function openProximityMatch_args:write(oprot)
  oprot:writeStructBegin('openProximityMatch_args')
  if self.location ~= nil then
    oprot:writeFieldBegin('location', TType.STRUCT, 2)
    self.location:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

openProximityMatch_result = __TObject:new{
  success,
  e
}

function openProximityMatch_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function openProximityMatch_result:write(oprot)
  oprot:writeStructBegin('openProximityMatch_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUser_args = __TObject:new{
  buddyId,
  registrarPassword
}

function registerBuddyUser_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.buddyId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.registrarPassword = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUser_args:write(oprot)
  oprot:writeStructBegin('registerBuddyUser_args')
  if self.buddyId ~= nil then
    oprot:writeFieldBegin('buddyId', TType.STRING, 2)
    oprot:writeString(self.buddyId)
    oprot:writeFieldEnd()
  end
  if self.registrarPassword ~= nil then
    oprot:writeFieldBegin('registrarPassword', TType.STRING, 3)
    oprot:writeString(self.registrarPassword)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUser_result = __TObject:new{
  success,
  e
}

function registerBuddyUser_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUser_result:write(oprot)
  oprot:writeStructBegin('registerBuddyUser_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUserid_args = __TObject:new{
  seq,
  userid
}

function registerBuddyUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUserid_args:write(oprot)
  oprot:writeStructBegin('registerBuddyUserid_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 2)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 3)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerBuddyUserid_result = __TObject:new{
  e
}

function registerBuddyUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerBuddyUserid_result:write(oprot)
  oprot:writeStructBegin('registerBuddyUserid_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDevice_args = __TObject:new{
  sessionId
}

function registerDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDevice_args:write(oprot)
  oprot:writeStructBegin('registerDevice_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDevice_result = __TObject:new{
  success,
  e
}

function registerDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDevice_result:write(oprot)
  oprot:writeStructBegin('registerDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithIdentityCredential_args = __TObject:new{
  sessionId,
  provider,
  identifier,
  verifier
}

function registerDeviceWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithIdentityCredential_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 5)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 4)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerDeviceWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumber_args = __TObject:new{
  region,
  udidHash,
  deviceInfo
}

function registerDeviceWithoutPhoneNumber_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumber_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumber_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 3)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 4)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumber_result = __TObject:new{
  success,
  e
}

function registerDeviceWithoutPhoneNumber_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumber_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumber_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumberWithIdentityCredential_args = __TObject:new{
  region,
  udidHash,
  deviceInfo,
  provider,
  identifier,
  verifier,
  mid,
  migrationPincodeSessionId
}

function registerDeviceWithoutPhoneNumberWithIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.migrationPincodeSessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumberWithIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 3)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 4)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 5)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 6)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 7)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 8)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.migrationPincodeSessionId ~= nil then
    oprot:writeFieldBegin('migrationPincodeSessionId', TType.STRING, 9)
    oprot:writeString(self.migrationPincodeSessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerDeviceWithoutPhoneNumberWithIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerDeviceWithoutPhoneNumberWithIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerDeviceWithoutPhoneNumberWithIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerDeviceWithoutPhoneNumberWithIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerUserid_args = __TObject:new{
  reqSeq,
  userid
}

function registerUserid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerUserid_args:write(oprot)
  oprot:writeStructBegin('registerUserid_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerUserid_result = __TObject:new{
  success,
  e
}

function registerUserid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerUserid_result:write(oprot)
  oprot:writeStructBegin('registerUserid_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWapDevice_args = __TObject:new{
  invitationHash,
  guidHash,
  email,
  deviceInfo
}

function registerWapDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.invitationHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.guidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.email = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWapDevice_args:write(oprot)
  oprot:writeStructBegin('registerWapDevice_args')
  if self.invitationHash ~= nil then
    oprot:writeFieldBegin('invitationHash', TType.STRING, 2)
    oprot:writeString(self.invitationHash)
    oprot:writeFieldEnd()
  end
  if self.guidHash ~= nil then
    oprot:writeFieldBegin('guidHash', TType.STRING, 3)
    oprot:writeString(self.guidHash)
    oprot:writeFieldEnd()
  end
  if self.email ~= nil then
    oprot:writeFieldBegin('email', TType.STRING, 4)
    oprot:writeString(self.email)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 5)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWapDevice_result = __TObject:new{
  success,
  e
}

function registerWapDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWapDevice_result:write(oprot)
  oprot:writeStructBegin('registerWapDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithExistingSnsIdAndIdentityCredential_args = __TObject:new{
  identityCredential,
  region,
  udidHash,
  deviceInfo
}

function registerWithExistingSnsIdAndIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithExistingSnsIdAndIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_args')
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 2)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 3)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 5)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithExistingSnsIdAndIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerWithExistingSnsIdAndIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithExistingSnsIdAndIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerWithExistingSnsIdAndIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsId_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  region,
  udidHash,
  deviceInfo,
  mid
}

function registerWithSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsId_args:write(oprot)
  oprot:writeStructBegin('registerWithSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 4)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 7)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsId_result = __TObject:new{
  success,
  e
}

function registerWithSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = RegisterWithSnsIdResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsId_result:write(oprot)
  oprot:writeStructBegin('registerWithSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsIdAndIdentityCredential_args = __TObject:new{
  snsIdType,
  snsAccessToken,
  identityCredential,
  region,
  udidHash,
  deviceInfo
}

function registerWithSnsIdAndIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.snsAccessToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsIdAndIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('registerWithSnsIdAndIdentityCredential_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  if self.snsAccessToken ~= nil then
    oprot:writeFieldBegin('snsAccessToken', TType.STRING, 3)
    oprot:writeString(self.snsAccessToken)
    oprot:writeFieldEnd()
  end
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 4)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 5)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 6)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 7)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerWithSnsIdAndIdentityCredential_result = __TObject:new{
  success,
  e
}

function registerWithSnsIdAndIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerWithSnsIdAndIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('registerWithSnsIdAndIdentityCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueDeviceCredential_args = __TObject:new{

}

function reissueDeviceCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueDeviceCredential_args:write(oprot)
  oprot:writeStructBegin('reissueDeviceCredential_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueDeviceCredential_result = __TObject:new{
  success,
  e
}

function reissueDeviceCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueDeviceCredential_result:write(oprot)
  oprot:writeStructBegin('reissueDeviceCredential_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueUserTicket_args = __TObject:new{
  expirationTime,
  maxUseCount
}

function reissueUserTicket_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.expirationTime = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.maxUseCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueUserTicket_args:write(oprot)
  oprot:writeStructBegin('reissueUserTicket_args')
  if self.expirationTime ~= nil then
    oprot:writeFieldBegin('expirationTime', TType.I64, 3)
    oprot:writeI64(self.expirationTime)
    oprot:writeFieldEnd()
  end
  if self.maxUseCount ~= nil then
    oprot:writeFieldBegin('maxUseCount', TType.I32, 4)
    oprot:writeI32(self.maxUseCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reissueUserTicket_result = __TObject:new{
  success,
  e
}

function reissueUserTicket_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reissueUserTicket_result:write(oprot)
  oprot:writeStructBegin('reissueUserTicket_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageReadRange_args = __TObject:new{
  chatIds
}

function getMessageReadRange_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.chatIds = {}
        local _etype1743, _size1740 = iprot:readListBegin()
        for _i=1,_size1740 do
          local _elem1744 = iprot:readString()
          table.insert(self.chatIds, _elem1744)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageReadRange_args:write(oprot)
  oprot:writeStructBegin('getMessageReadRange_args')
  if self.chatIds ~= nil then
    oprot:writeFieldBegin('chatIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.chatIds)
    for _,iter1745 in ipairs(self.chatIds) do
      oprot:writeString(iter1745)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageReadRange_result = __TObject:new{
  success,
  e
}

function getMessageReadRange_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1749, _size1746 = iprot:readListBegin()
        for _i=1,_size1746 do
          local _elem1750 = TMessageReadRange:new{}
          _elem1750:read(iprot)
          table.insert(self.success, _elem1750)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageReadRange_result:write(oprot)
  oprot:writeStructBegin('getMessageReadRange_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1751 in ipairs(self.success) do
      iter1751:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

rejectGroupInvitation_args = __TObject:new{
  reqSeq,
  groupId
}

function rejectGroupInvitation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function rejectGroupInvitation_args:write(oprot)
  oprot:writeStructBegin('rejectGroupInvitation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupId ~= nil then
    oprot:writeFieldBegin('groupId', TType.STRING, 2)
    oprot:writeString(self.groupId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

rejectGroupInvitation_result = __TObject:new{
  e
}

function rejectGroupInvitation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function rejectGroupInvitation_result:write(oprot)
  oprot:writeStructBegin('rejectGroupInvitation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

releaseSession_args = __TObject:new{

}

function releaseSession_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function releaseSession_args:write(oprot)
  oprot:writeStructBegin('releaseSession_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

releaseSession_result = __TObject:new{
  e
}

function releaseSession_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function releaseSession_result:write(oprot)
  oprot:writeStructBegin('releaseSession_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeAllMessages_args = __TObject:new{
  seq,
  lastMessageId
}

function removeAllMessages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeAllMessages_args:write(oprot)
  oprot:writeStructBegin('removeAllMessages_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 2)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeAllMessages_result = __TObject:new{
  e
}

function removeAllMessages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeAllMessages_result:write(oprot)
  oprot:writeStructBegin('removeAllMessages_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeBuddyLocation_args = __TObject:new{
  mid,
  index
}

function removeBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('removeBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeBuddyLocation_result = __TObject:new{
  e
}

function removeBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('removeBuddyLocation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessage_args = __TObject:new{
  messageId
}

function removeMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessage_args:write(oprot)
  oprot:writeStructBegin('removeMessage_args')
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessage_result = __TObject:new{
  success,
  e
}

function removeMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessage_result:write(oprot)
  oprot:writeStructBegin('removeMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

makeUserAddMyselfAsContact_args = __TObject:new{
  contactOwnerMid
}

function makeUserAddMyselfAsContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.contactOwnerMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function makeUserAddMyselfAsContact_args:write(oprot)
  oprot:writeStructBegin('makeUserAddMyselfAsContact_args')
  if self.contactOwnerMid ~= nil then
    oprot:writeFieldBegin('contactOwnerMid', TType.STRING, 1)
    oprot:writeString(self.contactOwnerMid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

makeUserAddMyselfAsContact_result = __TObject:new{
  success,
  e
}

function makeUserAddMyselfAsContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ContactTransition:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function makeUserAddMyselfAsContact_result:write(oprot)
  oprot:writeStructBegin('makeUserAddMyselfAsContact_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessageFromMyHome_args = __TObject:new{
  messageId
}

function removeMessageFromMyHome_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessageFromMyHome_args:write(oprot)
  oprot:writeStructBegin('removeMessageFromMyHome_args')
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeMessageFromMyHome_result = __TObject:new{
  success,
  e
}

function removeMessageFromMyHome_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BOOL then
        self.success = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeMessageFromMyHome_result:write(oprot)
  oprot:writeStructBegin('removeMessageFromMyHome_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.BOOL, 0)
    oprot:writeBool(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeSnsId_args = __TObject:new{
  snsIdType
}

function removeSnsId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.snsIdType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeSnsId_args:write(oprot)
  oprot:writeStructBegin('removeSnsId_args')
  if self.snsIdType ~= nil then
    oprot:writeFieldBegin('snsIdType', TType.I32, 2)
    oprot:writeI32(self.snsIdType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeSnsId_result = __TObject:new{
  success,
  e
}

function removeSnsId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeSnsId_result:write(oprot)
  oprot:writeStructBegin('removeSnsId_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

report_args = __TObject:new{
  syncOpRevision,
  category,
  report
}

function report_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.category = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.report = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function report_args:write(oprot)
  oprot:writeStructBegin('report_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.category ~= nil then
    oprot:writeFieldBegin('category', TType.I32, 3)
    oprot:writeI32(self.category)
    oprot:writeFieldEnd()
  end
  if self.report ~= nil then
    oprot:writeFieldBegin('report', TType.STRING, 4)
    oprot:writeString(self.report)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

report_result = __TObject:new{
  e
}

function report_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function report_result:write(oprot)
  oprot:writeStructBegin('report_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportContacts_args = __TObject:new{
  syncOpRevision,
  category,
  contactReports,
  actionType
}

function reportContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.category = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.contactReports = {}
        local _etype1755, _size1752 = iprot:readListBegin()
        for _i=1,_size1752 do
          local _elem1756 = ContactReport:new{}
          _elem1756:read(iprot)
          table.insert(self.contactReports, _elem1756)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.actionType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportContacts_args:write(oprot)
  oprot:writeStructBegin('reportContacts_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.category ~= nil then
    oprot:writeFieldBegin('category', TType.I32, 3)
    oprot:writeI32(self.category)
    oprot:writeFieldEnd()
  end
  if self.contactReports ~= nil then
    oprot:writeFieldBegin('contactReports', TType.LIST, 4)
    oprot:writeListBegin(TType.STRUCT, #self.contactReports)
    for _,iter1757 in ipairs(self.contactReports) do
      iter1757:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.actionType ~= nil then
    oprot:writeFieldBegin('actionType', TType.I32, 5)
    oprot:writeI32(self.actionType)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportContacts_result = __TObject:new{
  success,
  e
}

function reportContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1761, _size1758 = iprot:readListBegin()
        for _i=1,_size1758 do
          local _elem1762 = ContactReportResult:new{}
          _elem1762:read(iprot)
          table.insert(self.success, _elem1762)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportContacts_result:write(oprot)
  oprot:writeStructBegin('reportContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1763 in ipairs(self.success) do
      iter1763:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportGroups_args = __TObject:new{
  syncOpRevision,
  groups
}

function reportGroups_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.groups = {}
        local _etype1767, _size1764 = iprot:readListBegin()
        for _i=1,_size1764 do
          local _elem1768 = Group:new{}
          _elem1768:read(iprot)
          table.insert(self.groups, _elem1768)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportGroups_args:write(oprot)
  oprot:writeStructBegin('reportGroups_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.groups ~= nil then
    oprot:writeFieldBegin('groups', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.groups)
    for _,iter1769 in ipairs(self.groups) do
      iter1769:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportGroups_result = __TObject:new{
  e
}

function reportGroups_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportGroups_result:write(oprot)
  oprot:writeStructBegin('reportGroups_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportProfile_args = __TObject:new{
  syncOpRevision,
  profile
}

function reportProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.profile = Profile:new{}
        self.profile:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportProfile_args:write(oprot)
  oprot:writeStructBegin('reportProfile_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.profile ~= nil then
    oprot:writeFieldBegin('profile', TType.STRUCT, 3)
    self.profile:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportProfile_result = __TObject:new{
  e
}

function reportProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportProfile_result:write(oprot)
  oprot:writeStructBegin('reportProfile_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportRooms_args = __TObject:new{
  syncOpRevision,
  rooms
}

function reportRooms_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.rooms = {}
        local _etype1773, _size1770 = iprot:readListBegin()
        for _i=1,_size1770 do
          local _elem1774 = Room:new{}
          _elem1774:read(iprot)
          table.insert(self.rooms, _elem1774)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportRooms_args:write(oprot)
  oprot:writeStructBegin('reportRooms_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.rooms ~= nil then
    oprot:writeFieldBegin('rooms', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.rooms)
    for _,iter1775 in ipairs(self.rooms) do
      iter1775:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportRooms_result = __TObject:new{
  e
}

function reportRooms_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportRooms_result:write(oprot)
  oprot:writeStructBegin('reportRooms_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactByMetaTag_args = __TObject:new{
  reqSeq,
  userid,
  reference
}

function findAndAddContactByMetaTag_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.reference = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactByMetaTag_args:write(oprot)
  oprot:writeStructBegin('findAndAddContactByMetaTag_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  if self.reference ~= nil then
    oprot:writeFieldBegin('reference', TType.STRING, 3)
    oprot:writeString(self.reference)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findAndAddContactByMetaTag_result = __TObject:new{
  success,
  e
}

function findAndAddContactByMetaTag_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findAndAddContactByMetaTag_result:write(oprot)
  oprot:writeStructBegin('findAndAddContactByMetaTag_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSettings_args = __TObject:new{
  syncOpRevision,
  settings
}

function reportSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.syncOpRevision = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSettings_args:write(oprot)
  oprot:writeStructBegin('reportSettings_args')
  if self.syncOpRevision ~= nil then
    oprot:writeFieldBegin('syncOpRevision', TType.I64, 2)
    oprot:writeI64(self.syncOpRevision)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 3)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSettings_result = __TObject:new{
  e
}

function reportSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSettings_result:write(oprot)
  oprot:writeStructBegin('reportSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpam_args = __TObject:new{
  chatMid,
  memberMids,
  spammerReasons,
  senderMids,
  spamMessageIds,
  spamMessages
}

function reportSpam_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.memberMids = {}
        local _etype1779, _size1776 = iprot:readListBegin()
        for _i=1,_size1776 do
          local _elem1780 = iprot:readString()
          table.insert(self.memberMids, _elem1780)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.spammerReasons = {}
        local _etype1784, _size1781 = iprot:readListBegin()
        for _i=1,_size1781 do
          local _elem1785 = iprot:readI32()
          table.insert(self.spammerReasons, _elem1785)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.LIST then
        self.senderMids = {}
        local _etype1789, _size1786 = iprot:readListBegin()
        for _i=1,_size1786 do
          local _elem1790 = iprot:readString()
          table.insert(self.senderMids, _elem1790)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.LIST then
        self.spamMessageIds = {}
        local _etype1794, _size1791 = iprot:readListBegin()
        for _i=1,_size1791 do
          local _elem1795 = iprot:readString()
          table.insert(self.spamMessageIds, _elem1795)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.LIST then
        self.spamMessages = {}
        local _etype1799, _size1796 = iprot:readListBegin()
        for _i=1,_size1796 do
          local _elem1800 = iprot:readString()
          table.insert(self.spamMessages, _elem1800)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpam_args:write(oprot)
  oprot:writeStructBegin('reportSpam_args')
  if self.chatMid ~= nil then
    oprot:writeFieldBegin('chatMid', TType.STRING, 2)
    oprot:writeString(self.chatMid)
    oprot:writeFieldEnd()
  end
  if self.memberMids ~= nil then
    oprot:writeFieldBegin('memberMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.memberMids)
    for _,iter1801 in ipairs(self.memberMids) do
      oprot:writeString(iter1801)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.spammerReasons ~= nil then
    oprot:writeFieldBegin('spammerReasons', TType.LIST, 4)
    oprot:writeListBegin(TType.I32, #self.spammerReasons)
    for _,iter1802 in ipairs(self.spammerReasons) do
      oprot:writeI32(iter1802)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.senderMids ~= nil then
    oprot:writeFieldBegin('senderMids', TType.LIST, 5)
    oprot:writeListBegin(TType.STRING, #self.senderMids)
    for _,iter1803 in ipairs(self.senderMids) do
      oprot:writeString(iter1803)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.spamMessageIds ~= nil then
    oprot:writeFieldBegin('spamMessageIds', TType.LIST, 6)
    oprot:writeListBegin(TType.STRING, #self.spamMessageIds)
    for _,iter1804 in ipairs(self.spamMessageIds) do
      oprot:writeString(iter1804)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.spamMessages ~= nil then
    oprot:writeFieldBegin('spamMessages', TType.LIST, 7)
    oprot:writeListBegin(TType.STRING, #self.spamMessages)
    for _,iter1805 in ipairs(self.spamMessages) do
      oprot:writeString(iter1805)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpam_result = __TObject:new{
  e
}

function reportSpam_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpam_result:write(oprot)
  oprot:writeStructBegin('reportSpam_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpammer_args = __TObject:new{
  spammerMid,
  spammerReasons,
  spamMessageIds
}

function reportSpammer_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.spammerMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.spammerReasons = {}
        local _etype1809, _size1806 = iprot:readListBegin()
        for _i=1,_size1806 do
          local _elem1810 = iprot:readI32()
          table.insert(self.spammerReasons, _elem1810)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.LIST then
        self.spamMessageIds = {}
        local _etype1814, _size1811 = iprot:readListBegin()
        for _i=1,_size1811 do
          local _elem1815 = iprot:readString()
          table.insert(self.spamMessageIds, _elem1815)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpammer_args:write(oprot)
  oprot:writeStructBegin('reportSpammer_args')
  if self.spammerMid ~= nil then
    oprot:writeFieldBegin('spammerMid', TType.STRING, 2)
    oprot:writeString(self.spammerMid)
    oprot:writeFieldEnd()
  end
  if self.spammerReasons ~= nil then
    oprot:writeFieldBegin('spammerReasons', TType.LIST, 3)
    oprot:writeListBegin(TType.I32, #self.spammerReasons)
    for _,iter1816 in ipairs(self.spammerReasons) do
      oprot:writeI32(iter1816)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.spamMessageIds ~= nil then
    oprot:writeFieldBegin('spamMessageIds', TType.LIST, 4)
    oprot:writeListBegin(TType.STRING, #self.spamMessageIds)
    for _,iter1817 in ipairs(self.spamMessageIds) do
      oprot:writeString(iter1817)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reportSpammer_result = __TObject:new{
  e
}

function reportSpammer_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reportSpammer_result:write(oprot)
  oprot:writeStructBegin('reportSpammer_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestAccountPasswordReset_args = __TObject:new{
  provider,
  identifier,
  locale
}

function requestAccountPasswordReset_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestAccountPasswordReset_args:write(oprot)
  oprot:writeStructBegin('requestAccountPasswordReset_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 5)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestAccountPasswordReset_result = __TObject:new{
  e
}

function requestAccountPasswordReset_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestAccountPasswordReset_result:write(oprot)
  oprot:writeStructBegin('requestAccountPasswordReset_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestEmailConfirmation_args = __TObject:new{
  emailConfirmation
}

function requestEmailConfirmation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.emailConfirmation = EmailConfirmation:new{}
        self.emailConfirmation:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestEmailConfirmation_args:write(oprot)
  oprot:writeStructBegin('requestEmailConfirmation_args')
  if self.emailConfirmation ~= nil then
    oprot:writeFieldBegin('emailConfirmation', TType.STRUCT, 2)
    self.emailConfirmation:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestEmailConfirmation_result = __TObject:new{
  success,
  e
}

function requestEmailConfirmation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = EmailConfirmationSession:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestEmailConfirmation_result:write(oprot)
  oprot:writeStructBegin('requestEmailConfirmation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestIdentityUnbind_args = __TObject:new{
  provider,
  identifier
}

function requestIdentityUnbind_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestIdentityUnbind_args:write(oprot)
  oprot:writeStructBegin('requestIdentityUnbind_args')
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestIdentityUnbind_result = __TObject:new{
  e
}

function requestIdentityUnbind_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestIdentityUnbind_result:write(oprot)
  oprot:writeStructBegin('requestIdentityUnbind_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendEmailConfirmation_args = __TObject:new{
  verifier
}

function resendEmailConfirmation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendEmailConfirmation_args:write(oprot)
  oprot:writeStructBegin('resendEmailConfirmation_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendEmailConfirmation_result = __TObject:new{
  success,
  e
}

function resendEmailConfirmation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = EmailConfirmationSession:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendEmailConfirmation_result:write(oprot)
  oprot:writeStructBegin('resendEmailConfirmation_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCode_args = __TObject:new{
  sessionId
}

function resendPinCode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCode_args:write(oprot)
  oprot:writeStructBegin('resendPinCode_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCode_result = __TObject:new{
  e
}

function resendPinCode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCode_result:write(oprot)
  oprot:writeStructBegin('resendPinCode_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCodeBySMS_args = __TObject:new{
  sessionId
}

function resendPinCodeBySMS_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCodeBySMS_args:write(oprot)
  oprot:writeStructBegin('resendPinCodeBySMS_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

resendPinCodeBySMS_result = __TObject:new{
  e
}

function resendPinCodeBySMS_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function resendPinCodeBySMS_result:write(oprot)
  oprot:writeStructBegin('resendPinCodeBySMS_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatChecked_args = __TObject:new{
  seq,
  consumer,
  lastMessageId
}

function sendChatChecked_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatChecked_args:write(oprot)
  oprot:writeStructBegin('sendChatChecked_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 3)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatChecked_result = __TObject:new{
  e
}

function sendChatChecked_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatChecked_result:write(oprot)
  oprot:writeStructBegin('sendChatChecked_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageAwaitCommit_args = __TObject:new{
  seq,
  message
}

function sendMessageAwaitCommit_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageAwaitCommit_args:write(oprot)
  oprot:writeStructBegin('sendMessageAwaitCommit_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageAwaitCommit_result = __TObject:new{
  success,
  e
}

function sendMessageAwaitCommit_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = CommitMessageResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageAwaitCommit_result:write(oprot)
  oprot:writeStructBegin('sendMessageAwaitCommit_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatRemoved_args = __TObject:new{
  seq,
  consumer,
  lastMessageId
}

function sendChatRemoved_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.lastMessageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatRemoved_args:write(oprot)
  oprot:writeStructBegin('sendChatRemoved_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.lastMessageId ~= nil then
    oprot:writeFieldBegin('lastMessageId', TType.STRING, 3)
    oprot:writeString(self.lastMessageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendChatRemoved_result = __TObject:new{
  e
}

function sendChatRemoved_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendChatRemoved_result:write(oprot)
  oprot:writeStructBegin('sendChatRemoved_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentPreviewUpdated_args = __TObject:new{
  esq,
  messageId,
  receiverMids
}

function sendContentPreviewUpdated_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.esq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.receiverMids = {}
        local _etype1821, _size1818 = iprot:readListBegin()
        for _i=1,_size1818 do
          local _elem1822 = iprot:readString()
          table.insert(self.receiverMids, _elem1822)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentPreviewUpdated_args:write(oprot)
  oprot:writeStructBegin('sendContentPreviewUpdated_args')
  if self.esq ~= nil then
    oprot:writeFieldBegin('esq', TType.I32, 1)
    oprot:writeI32(self.esq)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 2)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  if self.receiverMids ~= nil then
    oprot:writeFieldBegin('receiverMids', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.receiverMids)
    for _,iter1823 in ipairs(self.receiverMids) do
      oprot:writeString(iter1823)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentPreviewUpdated_result = __TObject:new{
  success,
  e
}

function sendContentPreviewUpdated_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1825, _vtype1826, _size1824 = iprot:readMapBegin() 
        for _i=1,_size1824 do
          local _key1828 = iprot:readString()
          local _val1829 = iprot:readString()
          self.success[_key1828] = _val1829
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentPreviewUpdated_result:write(oprot)
  oprot:writeStructBegin('sendContentPreviewUpdated_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1830,viter1831 in pairs(self.success) do
      oprot:writeString(kiter1830)
      oprot:writeString(viter1831)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentReceipt_args = __TObject:new{
  seq,
  consumer,
  messageId
}

function sendContentReceipt_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.messageId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentReceipt_args:write(oprot)
  oprot:writeStructBegin('sendContentReceipt_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageId ~= nil then
    oprot:writeFieldBegin('messageId', TType.STRING, 3)
    oprot:writeString(self.messageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendContentReceipt_result = __TObject:new{
  e
}

function sendContentReceipt_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendContentReceipt_result:write(oprot)
  oprot:writeStructBegin('sendContentReceipt_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendDummyPush_args = __TObject:new{

}

function sendDummyPush_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendDummyPush_args:write(oprot)
  oprot:writeStructBegin('sendDummyPush_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendDummyPush_result = __TObject:new{
  e
}

function sendDummyPush_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendDummyPush_result:write(oprot)
  oprot:writeStructBegin('sendDummyPush_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeE2EEPublicKey_args = __TObject:new{
  publicKey
}

function removeE2EEPublicKey_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.publicKey = E2EEPublicKey:new{}
        self.publicKey:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeE2EEPublicKey_args:write(oprot)
  oprot:writeStructBegin('removeE2EEPublicKey_args')
  if self.publicKey ~= nil then
    oprot:writeFieldBegin('publicKey', TType.STRUCT, 2)
    self.publicKey:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

removeE2EEPublicKey_result = __TObject:new{
  e
}

function removeE2EEPublicKey_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function removeE2EEPublicKey_result:write(oprot)
  oprot:writeStructBegin('removeE2EEPublicKey_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

negotiateE2EEPublicKey_args = __TObject:new{
  mid
}

function negotiateE2EEPublicKey_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function negotiateE2EEPublicKey_args:write(oprot)
  oprot:writeStructBegin('negotiateE2EEPublicKey_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

negotiateE2EEPublicKey_result = __TObject:new{
  success,
  e
}

function negotiateE2EEPublicKey_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = E2EENegotiationResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function negotiateE2EEPublicKey_result:write(oprot)
  oprot:writeStructBegin('negotiateE2EEPublicKey_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKey_args = __TObject:new{
  mid,
  version,
  keyId
}

function getE2EEPublicKey_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.version = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.keyId = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKey_args:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKey_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.version ~= nil then
    oprot:writeFieldBegin('version', TType.I32, 3)
    oprot:writeI32(self.version)
    oprot:writeFieldEnd()
  end
  if self.keyId ~= nil then
    oprot:writeFieldBegin('keyId', TType.I32, 4)
    oprot:writeI32(self.keyId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKey_result = __TObject:new{
  success,
  e
}

function getE2EEPublicKey_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = E2EEPublicKey:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKey_result:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKey_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestE2EEKeyExchange_args = __TObject:new{
  reqSeq,
  temporalPublicKey,
  publicKey,
  verifier
}

function requestE2EEKeyExchange_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.temporalPublicKey = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.publicKey = E2EEPublicKey:new{}
        self.publicKey:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestE2EEKeyExchange_args:write(oprot)
  oprot:writeStructBegin('requestE2EEKeyExchange_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.temporalPublicKey ~= nil then
    oprot:writeFieldBegin('temporalPublicKey', TType.STRING, 2)
    oprot:writeString(self.temporalPublicKey)
    oprot:writeFieldEnd()
  end
  if self.publicKey ~= nil then
    oprot:writeFieldBegin('publicKey', TType.STRUCT, 3)
    self.publicKey:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 4)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

requestE2EEKeyExchange_result = __TObject:new{
  e
}

function requestE2EEKeyExchange_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function requestE2EEKeyExchange_result:write(oprot)
  oprot:writeStructBegin('requestE2EEKeyExchange_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastE2EEPublicKeys_args = __TObject:new{
  chatMid
}

function getLastE2EEPublicKeys_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.chatMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastE2EEPublicKeys_args:write(oprot)
  oprot:writeStructBegin('getLastE2EEPublicKeys_args')
  if self.chatMid ~= nil then
    oprot:writeFieldBegin('chatMid', TType.STRING, 2)
    oprot:writeString(self.chatMid)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getLastE2EEPublicKeys_result = __TObject:new{
  success,
  e
}

function getLastE2EEPublicKeys_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1833, _vtype1834, _size1832 = iprot:readMapBegin() 
        for _i=1,_size1832 do
          local _key1836 = iprot:readString()
          local _val1837 = E2EEPublicKey:new{}
          _val1837:read(iprot)
          self.success[_key1836] = _val1837
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getLastE2EEPublicKeys_result:write(oprot)
  oprot:writeStructBegin('getLastE2EEPublicKeys_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1838,viter1839 in pairs(self.success) do
      oprot:writeString(kiter1838)
      viter1839:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerE2EEPublicKey_args = __TObject:new{
  reqSeq,
  publicKey
}

function registerE2EEPublicKey_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.publicKey = E2EEPublicKey:new{}
        self.publicKey:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerE2EEPublicKey_args:write(oprot)
  oprot:writeStructBegin('registerE2EEPublicKey_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.publicKey ~= nil then
    oprot:writeFieldBegin('publicKey', TType.STRUCT, 2)
    self.publicKey:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

registerE2EEPublicKey_result = __TObject:new{
  success,
  e
}

function registerE2EEPublicKey_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = E2EEPublicKey:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function registerE2EEPublicKey_result:write(oprot)
  oprot:writeStructBegin('registerE2EEPublicKey_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKeys_args = __TObject:new{

}

function getE2EEPublicKeys_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKeys_args:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKeys_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKeys_result = __TObject:new{
  success,
  e
}

function getE2EEPublicKeys_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1843, _size1840 = iprot:readListBegin()
        for _i=1,_size1840 do
          local _elem1844 = E2EEPublicKey:new{}
          _elem1844:read(iprot)
          table.insert(self.success, _elem1844)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKeys_result:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKeys_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1845 in ipairs(self.success) do
      iter1845:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKeysEx_args = __TObject:new{
  ignoreE2EEStatus
}

function getE2EEPublicKeysEx_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.ignoreE2EEStatus = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKeysEx_args:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKeysEx_args')
  if self.ignoreE2EEStatus ~= nil then
    oprot:writeFieldBegin('ignoreE2EEStatus', TType.BOOL, 2)
    oprot:writeBool(self.ignoreE2EEStatus)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getE2EEPublicKeysEx_result = __TObject:new{
  success,
  e
}

function getE2EEPublicKeysEx_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1849, _size1846 = iprot:readListBegin()
        for _i=1,_size1846 do
          local _elem1850 = E2EEPublicKey:new{}
          _elem1850:read(iprot)
          table.insert(self.success, _elem1850)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getE2EEPublicKeysEx_result:write(oprot)
  oprot:writeStructBegin('getE2EEPublicKeysEx_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1851 in ipairs(self.success) do
      iter1851:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getReadMessageOpsInBulk_args = __TObject:new{
  chatIds
}

function getReadMessageOpsInBulk_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.chatIds = {}
        local _etype1855, _size1852 = iprot:readListBegin()
        for _i=1,_size1852 do
          local _elem1856 = iprot:readString()
          table.insert(self.chatIds, _elem1856)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getReadMessageOpsInBulk_args:write(oprot)
  oprot:writeStructBegin('getReadMessageOpsInBulk_args')
  if self.chatIds ~= nil then
    oprot:writeFieldBegin('chatIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.chatIds)
    for _,iter1857 in ipairs(self.chatIds) do
      oprot:writeString(iter1857)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getReadMessageOpsInBulk_result = __TObject:new{
  success,
  e
}

function getReadMessageOpsInBulk_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1861, _size1858 = iprot:readListBegin()
        for _i=1,_size1858 do
          local _elem1862 = Operation:new{}
          _elem1862:read(iprot)
          table.insert(self.success, _elem1862)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getReadMessageOpsInBulk_result:write(oprot)
  oprot:writeStructBegin('getReadMessageOpsInBulk_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1863 in ipairs(self.success) do
      iter1863:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendEvent_args = __TObject:new{
  seq,
  message
}

function sendEvent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendEvent_args:write(oprot)
  oprot:writeStructBegin('sendEvent_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendEvent_result = __TObject:new{
  success,
  e
}

function sendEvent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendEvent_result:write(oprot)
  oprot:writeStructBegin('sendEvent_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessage_args = __TObject:new{
  seq,
  message
}

function sendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessage_args:write(oprot)
  oprot:writeStructBegin('sendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessage_result = __TObject:new{
  success,
  e
}

function sendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessage_result:write(oprot)
  oprot:writeStructBegin('sendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageIgnored_args = __TObject:new{
  seq,
  consumer,
  messageIds
}

function sendMessageIgnored_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype1867, _size1864 = iprot:readListBegin()
        for _i=1,_size1864 do
          local _elem1868 = iprot:readString()
          table.insert(self.messageIds, _elem1868)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageIgnored_args:write(oprot)
  oprot:writeStructBegin('sendMessageIgnored_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter1869 in ipairs(self.messageIds) do
      oprot:writeString(iter1869)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageIgnored_result = __TObject:new{
  e
}

function sendMessageIgnored_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageIgnored_result:write(oprot)
  oprot:writeStructBegin('sendMessageIgnored_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageReceipt_args = __TObject:new{
  seq,
  consumer,
  messageIds
}

function sendMessageReceipt_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.consumer = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.messageIds = {}
        local _etype1873, _size1870 = iprot:readListBegin()
        for _i=1,_size1870 do
          local _elem1874 = iprot:readString()
          table.insert(self.messageIds, _elem1874)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageReceipt_args:write(oprot)
  oprot:writeStructBegin('sendMessageReceipt_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.consumer ~= nil then
    oprot:writeFieldBegin('consumer', TType.STRING, 2)
    oprot:writeString(self.consumer)
    oprot:writeFieldEnd()
  end
  if self.messageIds ~= nil then
    oprot:writeFieldBegin('messageIds', TType.LIST, 3)
    oprot:writeListBegin(TType.STRING, #self.messageIds)
    for _,iter1875 in ipairs(self.messageIds) do
      oprot:writeString(iter1875)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageReceipt_result = __TObject:new{
  e
}

function sendMessageReceipt_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageReceipt_result:write(oprot)
  oprot:writeStructBegin('sendMessageReceipt_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByMetaTag_args = __TObject:new{
  userid,
  reference
}

function findContactByMetaTag_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.userid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.reference = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByMetaTag_args:write(oprot)
  oprot:writeStructBegin('findContactByMetaTag_args')
  if self.userid ~= nil then
    oprot:writeFieldBegin('userid', TType.STRING, 2)
    oprot:writeString(self.userid)
    oprot:writeFieldEnd()
  end
  if self.reference ~= nil then
    oprot:writeFieldBegin('reference', TType.STRING, 3)
    oprot:writeString(self.reference)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

findContactByMetaTag_result = __TObject:new{
  success,
  e
}

function findContactByMetaTag_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Contact:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function findContactByMetaTag_result:write(oprot)
  oprot:writeStructBegin('findContactByMetaTag_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageToMyHome_args = __TObject:new{
  seq,
  message
}

function sendMessageToMyHome_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageToMyHome_args:write(oprot)
  oprot:writeStructBegin('sendMessageToMyHome_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

sendMessageToMyHome_result = __TObject:new{
  success,
  e
}

function sendMessageToMyHome_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function sendMessageToMyHome_result:write(oprot)
  oprot:writeStructBegin('sendMessageToMyHome_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setBuddyLocation_args = __TObject:new{
  mid,
  index,
  location
}

function setBuddyLocation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.index = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.location = Geolocation:new{}
        self.location:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setBuddyLocation_args:write(oprot)
  oprot:writeStructBegin('setBuddyLocation_args')
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.index ~= nil then
    oprot:writeFieldBegin('index', TType.I32, 3)
    oprot:writeI32(self.index)
    oprot:writeFieldEnd()
  end
  if self.location ~= nil then
    oprot:writeFieldBegin('location', TType.STRUCT, 4)
    self.location:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setBuddyLocation_result = __TObject:new{
  e
}

function setBuddyLocation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setBuddyLocation_result:write(oprot)
  oprot:writeStructBegin('setBuddyLocation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setIdentityCredential_args = __TObject:new{
  identifier,
  verifier,
  provider
}

function setIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.provider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('setIdentityCredential_args')
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 2)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 3)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.provider ~= nil then
    oprot:writeFieldBegin('provider', TType.I32, 4)
    oprot:writeI32(self.provider)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setIdentityCredential_result = __TObject:new{
  e
}

function setIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('setIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setNotificationsEnabled_args = __TObject:new{
  reqSeq,
  type,
  target,
  enablement
}

function setNotificationsEnabled_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.target = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.BOOL then
        self.enablement = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setNotificationsEnabled_args:write(oprot)
  oprot:writeStructBegin('setNotificationsEnabled_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 2)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.target ~= nil then
    oprot:writeFieldBegin('target', TType.STRING, 3)
    oprot:writeString(self.target)
    oprot:writeFieldEnd()
  end
  if self.enablement ~= nil then
    oprot:writeFieldBegin('enablement', TType.BOOL, 4)
    oprot:writeBool(self.enablement)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

setNotificationsEnabled_result = __TObject:new{
  e
}

function setNotificationsEnabled_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function setNotificationsEnabled_result:write(oprot)
  oprot:writeStructBegin('setNotificationsEnabled_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startUpdateVerification_args = __TObject:new{
  region,
  carrier,
  phone,
  udidHash,
  deviceInfo,
  networkCode,
  locale
}

function startUpdateVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.phone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.networkCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startUpdateVerification_args:write(oprot)
  oprot:writeStructBegin('startUpdateVerification_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 3)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  if self.phone ~= nil then
    oprot:writeFieldBegin('phone', TType.STRING, 4)
    oprot:writeString(self.phone)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.networkCode ~= nil then
    oprot:writeFieldBegin('networkCode', TType.STRING, 7)
    oprot:writeString(self.networkCode)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 8)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startUpdateVerification_result = __TObject:new{
  success,
  e
}

function startUpdateVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startUpdateVerification_result:write(oprot)
  oprot:writeStructBegin('startUpdateVerification_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startVerification_args = __TObject:new{
  region,
  carrier,
  phone,
  udidHash,
  deviceInfo,
  networkCode,
  mid,
  locale,
  simInfo,
  oldUdidHash
}

function startVerification_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.carrier = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.phone = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.networkCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.STRING then
        self.locale = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.STRUCT then
        self.simInfo = SIMInfo:new{}
        self.simInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.STRING then
        self.oldUdidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startVerification_args:write(oprot)
  oprot:writeStructBegin('startVerification_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  if self.carrier ~= nil then
    oprot:writeFieldBegin('carrier', TType.I32, 3)
    oprot:writeI32(self.carrier)
    oprot:writeFieldEnd()
  end
  if self.phone ~= nil then
    oprot:writeFieldBegin('phone', TType.STRING, 4)
    oprot:writeString(self.phone)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 5)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 6)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.networkCode ~= nil then
    oprot:writeFieldBegin('networkCode', TType.STRING, 7)
    oprot:writeString(self.networkCode)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 8)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.locale ~= nil then
    oprot:writeFieldBegin('locale', TType.STRING, 9)
    oprot:writeString(self.locale)
    oprot:writeFieldEnd()
  end
  if self.simInfo ~= nil then
    oprot:writeFieldBegin('simInfo', TType.STRUCT, 10)
    self.simInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.oldUdidHash ~= nil then
    oprot:writeFieldBegin('oldUdidHash', TType.STRING, 11)
    oprot:writeString(self.oldUdidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

startVerification_result = __TObject:new{
  success,
  e
}

function startVerification_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = VerificationSessionData:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function startVerification_result:write(oprot)
  oprot:writeStructBegin('startVerification_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroupPreferenceAttribute_args = __TObject:new{
  reqSeq,
  groupMid,
  updatedAttrs
}

function updateGroupPreferenceAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.groupMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.updatedAttrs = {}
        local _ktype1877, _vtype1878, _size1876 = iprot:readMapBegin() 
        for _i=1,_size1876 do
          local _key1880 = iprot:readI32()
          local _val1881 = iprot:readString()
          self.updatedAttrs[_key1880] = _val1881
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroupPreferenceAttribute_args:write(oprot)
  oprot:writeStructBegin('updateGroupPreferenceAttribute_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.groupMid ~= nil then
    oprot:writeFieldBegin('groupMid', TType.STRING, 2)
    oprot:writeString(self.groupMid)
    oprot:writeFieldEnd()
  end
  if self.updatedAttrs ~= nil then
    oprot:writeFieldBegin('updatedAttrs', TType.MAP, 3)
    oprot:writeMapBegin(TType.I32, TType.STRING, ttable_size(self.updatedAttrs))
    for kiter1882,viter1883 in pairs(self.updatedAttrs) do
      oprot:writeI32(kiter1882)
      oprot:writeString(viter1883)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroupPreferenceAttribute_result = __TObject:new{
  e
}

function updateGroupPreferenceAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroupPreferenceAttribute_result:write(oprot)
  oprot:writeStructBegin('updateGroupPreferenceAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoomV2_args = __TObject:new{
  reqSeq,
  contactIds
}

function createRoomV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.contactIds = {}
        local _etype1887, _size1884 = iprot:readListBegin()
        for _i=1,_size1884 do
          local _elem1888 = iprot:readString()
          table.insert(self.contactIds, _elem1888)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoomV2_args:write(oprot)
  oprot:writeStructBegin('createRoomV2_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.contactIds ~= nil then
    oprot:writeFieldBegin('contactIds', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.contactIds)
    for _,iter1889 in ipairs(self.contactIds) do
      oprot:writeString(iter1889)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

createRoomV2_result = __TObject:new{
  success,
  e
}

function createRoomV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Room:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function createRoomV2_result:write(oprot)
  oprot:writeStructBegin('createRoomV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

storeUpdateProfileAttribute_args = __TObject:new{
  seq,
  profileAttribute,
  value
}

function storeUpdateProfileAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.profileAttribute = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function storeUpdateProfileAttribute_args:write(oprot)
  oprot:writeStructBegin('storeUpdateProfileAttribute_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.profileAttribute ~= nil then
    oprot:writeFieldBegin('profileAttribute', TType.I32, 2)
    oprot:writeI32(self.profileAttribute)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

storeUpdateProfileAttribute_result = __TObject:new{
  e
}

function storeUpdateProfileAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function storeUpdateProfileAttribute_result:write(oprot)
  oprot:writeStructBegin('storeUpdateProfileAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContactBySnsIds_args = __TObject:new{
  reqSeq,
  modifications
}

function syncContactBySnsIds_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.modifications = {}
        local _etype1893, _size1890 = iprot:readListBegin()
        for _i=1,_size1890 do
          local _elem1894 = SnsFriendModification:new{}
          _elem1894:read(iprot)
          table.insert(self.modifications, _elem1894)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContactBySnsIds_args:write(oprot)
  oprot:writeStructBegin('syncContactBySnsIds_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.modifications ~= nil then
    oprot:writeFieldBegin('modifications', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.modifications)
    for _,iter1895 in ipairs(self.modifications) do
      iter1895:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContactBySnsIds_result = __TObject:new{
  success,
  e
}

function syncContactBySnsIds_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1899, _size1896 = iprot:readListBegin()
        for _i=1,_size1896 do
          local _elem1900 = SnsFriendContactRegistration:new{}
          _elem1900:read(iprot)
          table.insert(self.success, _elem1900)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContactBySnsIds_result:write(oprot)
  oprot:writeStructBegin('syncContactBySnsIds_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1901 in ipairs(self.success) do
      iter1901:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContacts_args = __TObject:new{
  reqSeq,
  localContacts
}

function syncContacts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.localContacts = {}
        local _etype1905, _size1902 = iprot:readListBegin()
        for _i=1,_size1902 do
          local _elem1906 = ContactModification:new{}
          _elem1906:read(iprot)
          table.insert(self.localContacts, _elem1906)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContacts_args:write(oprot)
  oprot:writeStructBegin('syncContacts_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.localContacts ~= nil then
    oprot:writeFieldBegin('localContacts', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.localContacts)
    for _,iter1907 in ipairs(self.localContacts) do
      iter1907:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

syncContacts_result = __TObject:new{
  success,
  e
}

function syncContacts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1909, _vtype1910, _size1908 = iprot:readMapBegin() 
        for _i=1,_size1908 do
          local _key1912 = iprot:readString()
          local _val1913 = ContactRegistration:new{}
          _val1913:read(iprot)
          self.success[_key1912] = _val1913
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function syncContacts_result:write(oprot)
  oprot:writeStructBegin('syncContacts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.success))
    for kiter1914,viter1915 in pairs(self.success) do
      oprot:writeString(kiter1914)
      viter1915:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

trySendMessage_args = __TObject:new{
  seq,
  message
}

function trySendMessage_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.seq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.message = Message:new{}
        self.message:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function trySendMessage_args:write(oprot)
  oprot:writeStructBegin('trySendMessage_args')
  if self.seq ~= nil then
    oprot:writeFieldBegin('seq', TType.I32, 1)
    oprot:writeI32(self.seq)
    oprot:writeFieldEnd()
  end
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRUCT, 2)
    self.message:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

trySendMessage_result = __TObject:new{
  success,
  e
}

function trySendMessage_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Message:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function trySendMessage_result:write(oprot)
  oprot:writeStructBegin('trySendMessage_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessagesV2_args = __TObject:new{
  messageBoxId,
  startMessageId,
  messagesCount
}

function getNextMessagesV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.startMessageId = MessageBoxV2MessageId:new{}
        self.startMessageId:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessagesV2_args:write(oprot)
  oprot:writeStructBegin('getNextMessagesV2_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.startMessageId ~= nil then
    oprot:writeFieldBegin('startMessageId', TType.STRUCT, 3)
    self.startMessageId:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 4)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNextMessagesV2_result = __TObject:new{
  success,
  e
}

function getNextMessagesV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1919, _size1916 = iprot:readListBegin()
        for _i=1,_size1916 do
          local _elem1920 = Message:new{}
          _elem1920:read(iprot)
          table.insert(self.success, _elem1920)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNextMessagesV2_result:write(oprot)
  oprot:writeStructBegin('getNextMessagesV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1921 in ipairs(self.success) do
      iter1921:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpV2_args = __TObject:new{
  messageBoxId
}

function getMessageBoxCompactWrapUpV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpV2_args:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpV2_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getMessageBoxCompactWrapUpV2_result = __TObject:new{
  success,
  e
}

function getMessageBoxCompactWrapUpV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = TMessageBoxWrapUp:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getMessageBoxCompactWrapUpV2_result:write(oprot)
  oprot:writeStructBegin('getMessageBoxCompactWrapUpV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessagesV2_args = __TObject:new{
  messageBoxId,
  messagesCount
}

function getRecentMessagesV2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.messageBoxId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.messagesCount = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessagesV2_args:write(oprot)
  oprot:writeStructBegin('getRecentMessagesV2_args')
  if self.messageBoxId ~= nil then
    oprot:writeFieldBegin('messageBoxId', TType.STRING, 2)
    oprot:writeString(self.messageBoxId)
    oprot:writeFieldEnd()
  end
  if self.messagesCount ~= nil then
    oprot:writeFieldBegin('messagesCount', TType.I32, 3)
    oprot:writeI32(self.messagesCount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getRecentMessagesV2_result = __TObject:new{
  success,
  e
}

function getRecentMessagesV2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1925, _size1922 = iprot:readListBegin()
        for _i=1,_size1922 do
          local _elem1926 = Message:new{}
          _elem1926:read(iprot)
          table.insert(self.success, _elem1926)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getRecentMessagesV2_result:write(oprot)
  oprot:writeStructBegin('getRecentMessagesV2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1927 in ipairs(self.success) do
      iter1927:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

validateContactsOnBot_args = __TObject:new{
  contacts
}

function validateContactsOnBot_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.contacts = {}
        local _etype1931, _size1928 = iprot:readListBegin()
        for _i=1,_size1928 do
          local _elem1932 = iprot:readString()
          table.insert(self.contacts, _elem1932)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function validateContactsOnBot_args:write(oprot)
  oprot:writeStructBegin('validateContactsOnBot_args')
  if self.contacts ~= nil then
    oprot:writeFieldBegin('contacts', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.contacts)
    for _,iter1933 in ipairs(self.contacts) do
      oprot:writeString(iter1933)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

validateContactsOnBot_result = __TObject:new{
  success,
  e
}

function validateContactsOnBot_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype1935, _vtype1936, _size1934 = iprot:readMapBegin() 
        for _i=1,_size1934 do
          local _key1938 = iprot:readString()
          local _val1939 = iprot:readString()
          self.success[_key1938] = _val1939
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function validateContactsOnBot_result:write(oprot)
  oprot:writeStructBegin('validateContactsOnBot_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.success))
    for kiter1940,viter1941 in pairs(self.success) do
      oprot:writeString(kiter1940)
      oprot:writeString(viter1941)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

tryFriendRequest_args = __TObject:new{
  midOrEMid,
  method,
  friendRequestParams
}

function tryFriendRequest_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.midOrEMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.method = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.friendRequestParams = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function tryFriendRequest_args:write(oprot)
  oprot:writeStructBegin('tryFriendRequest_args')
  if self.midOrEMid ~= nil then
    oprot:writeFieldBegin('midOrEMid', TType.STRING, 1)
    oprot:writeString(self.midOrEMid)
    oprot:writeFieldEnd()
  end
  if self.method ~= nil then
    oprot:writeFieldBegin('method', TType.I32, 2)
    oprot:writeI32(self.method)
    oprot:writeFieldEnd()
  end
  if self.friendRequestParams ~= nil then
    oprot:writeFieldBegin('friendRequestParams', TType.STRING, 3)
    oprot:writeString(self.friendRequestParams)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

tryFriendRequest_result = __TObject:new{
  e
}

function tryFriendRequest_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function tryFriendRequest_result:write(oprot)
  oprot:writeStructBegin('tryFriendRequest_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockContact_args = __TObject:new{
  reqSeq,
  id
}

function unblockContact_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockContact_args:write(oprot)
  oprot:writeStructBegin('unblockContact_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockContact_result = __TObject:new{
  e
}

function unblockContact_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockContact_result:write(oprot)
  oprot:writeStructBegin('unblockContact_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockRecommendation_args = __TObject:new{
  reqSeq,
  id
}

function unblockRecommendation_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.id = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockRecommendation_args:write(oprot)
  oprot:writeStructBegin('unblockRecommendation_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.id ~= nil then
    oprot:writeFieldBegin('id', TType.STRING, 2)
    oprot:writeString(self.id)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unblockRecommendation_result = __TObject:new{
  e
}

function unblockRecommendation_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unblockRecommendation_result:write(oprot)
  oprot:writeStructBegin('unblockRecommendation_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unregisterUserAndDevice_args = __TObject:new{

}

function unregisterUserAndDevice_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unregisterUserAndDevice_args:write(oprot)
  oprot:writeStructBegin('unregisterUserAndDevice_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

unregisterUserAndDevice_result = __TObject:new{
  success,
  e
}

function unregisterUserAndDevice_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function unregisterUserAndDevice_result:write(oprot)
  oprot:writeStructBegin('unregisterUserAndDevice_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateApnsDeviceToken_args = __TObject:new{
  apnsDeviceToken
}

function updateApnsDeviceToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.apnsDeviceToken = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateApnsDeviceToken_args:write(oprot)
  oprot:writeStructBegin('updateApnsDeviceToken_args')
  if self.apnsDeviceToken ~= nil then
    oprot:writeFieldBegin('apnsDeviceToken', TType.STRING, 2)
    oprot:writeString(self.apnsDeviceToken)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateApnsDeviceToken_result = __TObject:new{
  e
}

function updateApnsDeviceToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateApnsDeviceToken_result:write(oprot)
  oprot:writeStructBegin('updateApnsDeviceToken_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateBuddySetting_args = __TObject:new{
  key,
  value
}

function updateBuddySetting_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.key = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateBuddySetting_args:write(oprot)
  oprot:writeStructBegin('updateBuddySetting_args')
  if self.key ~= nil then
    oprot:writeFieldBegin('key', TType.STRING, 2)
    oprot:writeString(self.key)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateBuddySetting_result = __TObject:new{
  e
}

function updateBuddySetting_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateBuddySetting_result:write(oprot)
  oprot:writeStructBegin('updateBuddySetting_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateC2DMRegistrationId_args = __TObject:new{
  registrationId
}

function updateC2DMRegistrationId_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.registrationId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateC2DMRegistrationId_args:write(oprot)
  oprot:writeStructBegin('updateC2DMRegistrationId_args')
  if self.registrationId ~= nil then
    oprot:writeFieldBegin('registrationId', TType.STRING, 2)
    oprot:writeString(self.registrationId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateC2DMRegistrationId_result = __TObject:new{
  e
}

function updateC2DMRegistrationId_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateC2DMRegistrationId_result:write(oprot)
  oprot:writeStructBegin('updateC2DMRegistrationId_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateContactSetting_args = __TObject:new{
  reqSeq,
  mid,
  flag,
  value
}

function updateContactSetting_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.mid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.flag = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateContactSetting_args:write(oprot)
  oprot:writeStructBegin('updateContactSetting_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.mid ~= nil then
    oprot:writeFieldBegin('mid', TType.STRING, 2)
    oprot:writeString(self.mid)
    oprot:writeFieldEnd()
  end
  if self.flag ~= nil then
    oprot:writeFieldBegin('flag', TType.I32, 3)
    oprot:writeI32(self.flag)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 4)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateContactSetting_result = __TObject:new{
  e
}

function updateContactSetting_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateContactSetting_result:write(oprot)
  oprot:writeStructBegin('updateContactSetting_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateCustomModeSettings_args = __TObject:new{
  customMode,
  paramMap
}

function updateCustomModeSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.customMode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.paramMap = {}
        local _ktype1943, _vtype1944, _size1942 = iprot:readMapBegin() 
        for _i=1,_size1942 do
          local _key1946 = iprot:readString()
          local _val1947 = iprot:readString()
          self.paramMap[_key1946] = _val1947
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateCustomModeSettings_args:write(oprot)
  oprot:writeStructBegin('updateCustomModeSettings_args')
  if self.customMode ~= nil then
    oprot:writeFieldBegin('customMode', TType.I32, 2)
    oprot:writeI32(self.customMode)
    oprot:writeFieldEnd()
  end
  if self.paramMap ~= nil then
    oprot:writeFieldBegin('paramMap', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.paramMap))
    for kiter1948,viter1949 in pairs(self.paramMap) do
      oprot:writeString(kiter1948)
      oprot:writeString(viter1949)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateCustomModeSettings_result = __TObject:new{
  e
}

function updateCustomModeSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateCustomModeSettings_result:write(oprot)
  oprot:writeStructBegin('updateCustomModeSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateDeviceInfo_args = __TObject:new{
  deviceUid,
  deviceInfo
}

function updateDeviceInfo_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.deviceUid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.deviceInfo = DeviceInfo:new{}
        self.deviceInfo:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateDeviceInfo_args:write(oprot)
  oprot:writeStructBegin('updateDeviceInfo_args')
  if self.deviceUid ~= nil then
    oprot:writeFieldBegin('deviceUid', TType.STRING, 2)
    oprot:writeString(self.deviceUid)
    oprot:writeFieldEnd()
  end
  if self.deviceInfo ~= nil then
    oprot:writeFieldBegin('deviceInfo', TType.STRUCT, 3)
    self.deviceInfo:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateDeviceInfo_result = __TObject:new{
  e
}

function updateDeviceInfo_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateDeviceInfo_result:write(oprot)
  oprot:writeStructBegin('updateDeviceInfo_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroup_args = __TObject:new{
  reqSeq,
  group
}

function updateGroup_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.group = Group:new{}
        self.group:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroup_args:write(oprot)
  oprot:writeStructBegin('updateGroup_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.group ~= nil then
    oprot:writeFieldBegin('group', TType.STRUCT, 2)
    self.group:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateGroup_result = __TObject:new{
  e
}

function updateGroup_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateGroup_result:write(oprot)
  oprot:writeStructBegin('updateGroup_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationToken_args = __TObject:new{
  type,
  token
}

function updateNotificationToken_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.token = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationToken_args:write(oprot)
  oprot:writeStructBegin('updateNotificationToken_args')
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.token ~= nil then
    oprot:writeFieldBegin('token', TType.STRING, 2)
    oprot:writeString(self.token)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationToken_result = __TObject:new{
  e
}

function updateNotificationToken_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationToken_result:write(oprot)
  oprot:writeStructBegin('updateNotificationToken_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationTokenWithBytes_args = __TObject:new{
  type,
  token
}

function updateNotificationTokenWithBytes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.token = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationTokenWithBytes_args:write(oprot)
  oprot:writeStructBegin('updateNotificationTokenWithBytes_args')
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.token ~= nil then
    oprot:writeFieldBegin('token', TType.STRING, 2)
    oprot:writeString(self.token)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateNotificationTokenWithBytes_result = __TObject:new{
  e
}

function updateNotificationTokenWithBytes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateNotificationTokenWithBytes_result:write(oprot)
  oprot:writeStructBegin('updateNotificationTokenWithBytes_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfile_args = __TObject:new{
  reqSeq,
  profile
}

function updateProfile_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.profile = Profile:new{}
        self.profile:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfile_args:write(oprot)
  oprot:writeStructBegin('updateProfile_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.profile ~= nil then
    oprot:writeFieldBegin('profile', TType.STRUCT, 2)
    self.profile:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfile_result = __TObject:new{
  e
}

function updateProfile_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfile_result:write(oprot)
  oprot:writeStructBegin('updateProfile_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttribute_args = __TObject:new{
  reqSeq,
  attr,
  value
}

function updateProfileAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attr = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttribute_args:write(oprot)
  oprot:writeStructBegin('updateProfileAttribute_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attr ~= nil then
    oprot:writeFieldBegin('attr', TType.I32, 2)
    oprot:writeI32(self.attr)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttribute_result = __TObject:new{
  e
}

function updateProfileAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttribute_result:write(oprot)
  oprot:writeStructBegin('updateProfileAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttributes_args = __TObject:new{
  reqSeq,
  request
}

function updateProfileAttributes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.request = UpdateProfileAttributesRequest:new{}
        self.request:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttributes_args:write(oprot)
  oprot:writeStructBegin('updateProfileAttributes_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.request ~= nil then
    oprot:writeFieldBegin('request', TType.STRUCT, 2)
    self.request:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateProfileAttributes_result = __TObject:new{

}

function updateProfileAttributes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateProfileAttributes_result:write(oprot)
  oprot:writeStructBegin('updateProfileAttributes_result')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateRegion_args = __TObject:new{
  region
}

function updateRegion_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.region = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateRegion_args:write(oprot)
  oprot:writeStructBegin('updateRegion_args')
  if self.region ~= nil then
    oprot:writeFieldBegin('region', TType.STRING, 2)
    oprot:writeString(self.region)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateRegion_result = __TObject:new{
  e
}

function updateRegion_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateRegion_result:write(oprot)
  oprot:writeStructBegin('updateRegion_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings_args = __TObject:new{
  reqSeq,
  settings
}

function updateSettings_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings_args:write(oprot)
  oprot:writeStructBegin('updateSettings_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 2)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings_result = __TObject:new{
  e
}

function updateSettings_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings_result:write(oprot)
  oprot:writeStructBegin('updateSettings_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings2_args = __TObject:new{
  reqSeq,
  settings
}

function updateSettings2_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings2_args:write(oprot)
  oprot:writeStructBegin('updateSettings2_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 2)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettings2_result = __TObject:new{
  success,
  e
}

function updateSettings2_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettings2_result:write(oprot)
  oprot:writeStructBegin('updateSettings2_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttribute_args = __TObject:new{
  reqSeq,
  attr,
  value
}

function updateSettingsAttribute_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attr = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttribute_args:write(oprot)
  oprot:writeStructBegin('updateSettingsAttribute_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attr ~= nil then
    oprot:writeFieldBegin('attr', TType.I32, 2)
    oprot:writeI32(self.attr)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttribute_result = __TObject:new{
  e
}

function updateSettingsAttribute_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttribute_result:write(oprot)
  oprot:writeStructBegin('updateSettingsAttribute_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttributes_args = __TObject:new{
  reqSeq,
  attrBitset,
  settings
}

function updateSettingsAttributes_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.reqSeq = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.attrBitset = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRUCT then
        self.settings = Settings:new{}
        self.settings:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttributes_args:write(oprot)
  oprot:writeStructBegin('updateSettingsAttributes_args')
  if self.reqSeq ~= nil then
    oprot:writeFieldBegin('reqSeq', TType.I32, 1)
    oprot:writeI32(self.reqSeq)
    oprot:writeFieldEnd()
  end
  if self.attrBitset ~= nil then
    oprot:writeFieldBegin('attrBitset', TType.I32, 2)
    oprot:writeI32(self.attrBitset)
    oprot:writeFieldEnd()
  end
  if self.settings ~= nil then
    oprot:writeFieldBegin('settings', TType.STRUCT, 3)
    self.settings:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

updateSettingsAttributes_result = __TObject:new{
  success,
  e
}

function updateSettingsAttributes_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function updateSettingsAttributes_result:write(oprot)
  oprot:writeStructBegin('updateSettingsAttributes_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredential_args = __TObject:new{
  identityProvider,
  identifier,
  password
}

function verifyIdentityCredential_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.identityProvider = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.identifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.password = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredential_args:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredential_args')
  if self.identityProvider ~= nil then
    oprot:writeFieldBegin('identityProvider', TType.I32, 8)
    oprot:writeI32(self.identityProvider)
    oprot:writeFieldEnd()
  end
  if self.identifier ~= nil then
    oprot:writeFieldBegin('identifier', TType.STRING, 3)
    oprot:writeString(self.identifier)
    oprot:writeFieldEnd()
  end
  if self.password ~= nil then
    oprot:writeFieldBegin('password', TType.STRING, 4)
    oprot:writeString(self.password)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredential_result = __TObject:new{
  e
}

function verifyIdentityCredential_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredential_result:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredential_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredentialWithResult_args = __TObject:new{
  identityCredential
}

function verifyIdentityCredentialWithResult_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.identityCredential = IdentityCredential:new{}
        self.identityCredential:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredentialWithResult_args:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredentialWithResult_args')
  if self.identityCredential ~= nil then
    oprot:writeFieldBegin('identityCredential', TType.STRUCT, 2)
    self.identityCredential:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyIdentityCredentialWithResult_result = __TObject:new{
  success,
  e
}

function verifyIdentityCredentialWithResult_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = UserAuthStatus:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyIdentityCredentialWithResult_result:write(oprot)
  oprot:writeStructBegin('verifyIdentityCredentialWithResult_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhone_args = __TObject:new{
  sessionId,
  pinCode,
  udidHash
}

function verifyPhone_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.sessionId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.udidHash = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhone_args:write(oprot)
  oprot:writeStructBegin('verifyPhone_args')
  if self.sessionId ~= nil then
    oprot:writeFieldBegin('sessionId', TType.STRING, 2)
    oprot:writeString(self.sessionId)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  if self.udidHash ~= nil then
    oprot:writeFieldBegin('udidHash', TType.STRING, 4)
    oprot:writeString(self.udidHash)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyPhone_result = __TObject:new{
  success,
  e
}

function verifyPhone_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyPhone_result:write(oprot)
  oprot:writeStructBegin('verifyPhone_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyQrcode_args = __TObject:new{
  verifier,
  pinCode
}

function verifyQrcode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.verifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.pinCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyQrcode_args:write(oprot)
  oprot:writeStructBegin('verifyQrcode_args')
  if self.verifier ~= nil then
    oprot:writeFieldBegin('verifier', TType.STRING, 2)
    oprot:writeString(self.verifier)
    oprot:writeFieldEnd()
  end
  if self.pinCode ~= nil then
    oprot:writeFieldBegin('pinCode', TType.STRING, 3)
    oprot:writeString(self.pinCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

verifyQrcode_result = __TObject:new{
  success,
  e
}

function verifyQrcode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function verifyQrcode_result:write(oprot)
  oprot:writeStructBegin('verifyQrcode_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end