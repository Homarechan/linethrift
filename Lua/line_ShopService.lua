--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'line_ttypes'

ShopServiceClient = __TObject.new(__TClient, {
  __type = 'ShopServiceClient'
})

function ShopServiceClient:buyCoinProduct(paymentReservation)
  self:send_buyCoinProduct(paymentReservation)
  self:recv_buyCoinProduct(paymentReservation)
end

function ShopServiceClient:send_buyCoinProduct(paymentReservation)
  self.oprot:writeMessageBegin('buyCoinProduct', TMessageType.CALL, self._seqid)
  local args = buyCoinProduct_args:new{}
  args.paymentReservation = paymentReservation
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_buyCoinProduct(paymentReservation)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = buyCoinProduct_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ShopServiceClient:buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
  self:send_buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
  self:recv_buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
end

function ShopServiceClient:send_buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
  self.oprot:writeMessageBegin('buyFreeProduct', TMessageType.CALL, self._seqid)
  local args = buyFreeProduct_args:new{}
  args.receiverMid = receiverMid
  args.productId = productId
  args.messageTemplate = messageTemplate
  args.language = language
  args.country = country
  args.packageId = packageId
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_buyFreeProduct(receiverMid, productId, messageTemplate, language, country, packageId)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = buyFreeProduct_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ShopServiceClient:buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
  self:send_buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
  self:recv_buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
end

function ShopServiceClient:send_buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
  self.oprot:writeMessageBegin('buyMustbuyProduct', TMessageType.CALL, self._seqid)
  local args = buyMustbuyProduct_args:new{}
  args.receiverMid = receiverMid
  args.productId = productId
  args.messageTemplate = messageTemplate
  args.language = language
  args.country = country
  args.packageId = packageId
  args.serialNumber = serialNumber
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_buyMustbuyProduct(receiverMid, productId, messageTemplate, language, country, packageId, serialNumber)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = buyMustbuyProduct_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ShopServiceClient:checkCanReceivePresent(recipientMid, packageId, language, country)
  self:send_checkCanReceivePresent(recipientMid, packageId, language, country)
  self:recv_checkCanReceivePresent(recipientMid, packageId, language, country)
end

function ShopServiceClient:send_checkCanReceivePresent(recipientMid, packageId, language, country)
  self.oprot:writeMessageBegin('checkCanReceivePresent', TMessageType.CALL, self._seqid)
  local args = checkCanReceivePresent_args:new{}
  args.recipientMid = recipientMid
  args.packageId = packageId
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_checkCanReceivePresent(recipientMid, packageId, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = checkCanReceivePresent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ShopServiceClient:getActivePurchases(start, size, language, country)
  self:send_getActivePurchases(start, size, language, country)
  return self:recv_getActivePurchases(start, size, language, country)
end

function ShopServiceClient:send_getActivePurchases(start, size, language, country)
  self.oprot:writeMessageBegin('getActivePurchases', TMessageType.CALL, self._seqid)
  local args = getActivePurchases_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getActivePurchases(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getActivePurchases_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getActivePurchaseVersions(start, size, language, country)
  self:send_getActivePurchaseVersions(start, size, language, country)
  return self:recv_getActivePurchaseVersions(start, size, language, country)
end

function ShopServiceClient:send_getActivePurchaseVersions(start, size, language, country)
  self.oprot:writeMessageBegin('getActivePurchaseVersions', TMessageType.CALL, self._seqid)
  local args = getActivePurchaseVersions_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getActivePurchaseVersions(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getActivePurchaseVersions_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getCoinProducts(appStoreCode, country, language)
  self:send_getCoinProducts(appStoreCode, country, language)
  return self:recv_getCoinProducts(appStoreCode, country, language)
end

function ShopServiceClient:send_getCoinProducts(appStoreCode, country, language)
  self.oprot:writeMessageBegin('getCoinProducts', TMessageType.CALL, self._seqid)
  local args = getCoinProducts_args:new{}
  args.appStoreCode = appStoreCode
  args.country = country
  args.language = language
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getCoinProducts(appStoreCode, country, language)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCoinProducts_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
  self:send_getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
  return self:recv_getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
end

function ShopServiceClient:send_getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
  self.oprot:writeMessageBegin('getCoinProductsByPgCode', TMessageType.CALL, self._seqid)
  local args = getCoinProductsByPgCode_args:new{}
  args.appStoreCode = appStoreCode
  args.pgCode = pgCode
  args.country = country
  args.language = language
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getCoinProductsByPgCode(appStoreCode, pgCode, country, language)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCoinProductsByPgCode_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getCoinPurchaseHistory(request)
  self:send_getCoinPurchaseHistory(request)
  return self:recv_getCoinPurchaseHistory(request)
end

function ShopServiceClient:send_getCoinPurchaseHistory(request)
  self.oprot:writeMessageBegin('getCoinPurchaseHistory', TMessageType.CALL, self._seqid)
  local args = getCoinPurchaseHistory_args:new{}
  args.request = request
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getCoinPurchaseHistory(request)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCoinPurchaseHistory_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getCoinUseAndRefundHistory(request)
  self:send_getCoinUseAndRefundHistory(request)
  return self:recv_getCoinUseAndRefundHistory(request)
end

function ShopServiceClient:send_getCoinUseAndRefundHistory(request)
  self.oprot:writeMessageBegin('getCoinUseAndRefundHistory', TMessageType.CALL, self._seqid)
  local args = getCoinUseAndRefundHistory_args:new{}
  args.request = request
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getCoinUseAndRefundHistory(request)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getCoinUseAndRefundHistory_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getDownloads(start, size, language, country)
  self:send_getDownloads(start, size, language, country)
  return self:recv_getDownloads(start, size, language, country)
end

function ShopServiceClient:send_getDownloads(start, size, language, country)
  self.oprot:writeMessageBegin('getDownloads', TMessageType.CALL, self._seqid)
  local args = getDownloads_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getDownloads(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getDownloads_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getEventPackages(start, size, language, country)
  self:send_getEventPackages(start, size, language, country)
  return self:recv_getEventPackages(start, size, language, country)
end

function ShopServiceClient:send_getEventPackages(start, size, language, country)
  self.oprot:writeMessageBegin('getEventPackages', TMessageType.CALL, self._seqid)
  local args = getEventPackages_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getEventPackages(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getEventPackages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getNewlyReleasedPackages(start, size, language, country)
  self:send_getNewlyReleasedPackages(start, size, language, country)
  return self:recv_getNewlyReleasedPackages(start, size, language, country)
end

function ShopServiceClient:send_getNewlyReleasedPackages(start, size, language, country)
  self.oprot:writeMessageBegin('getNewlyReleasedPackages', TMessageType.CALL, self._seqid)
  local args = getNewlyReleasedPackages_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getNewlyReleasedPackages(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getNewlyReleasedPackages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getPopularPackages(start, size, language, country)
  self:send_getPopularPackages(start, size, language, country)
  return self:recv_getPopularPackages(start, size, language, country)
end

function ShopServiceClient:send_getPopularPackages(start, size, language, country)
  self.oprot:writeMessageBegin('getPopularPackages', TMessageType.CALL, self._seqid)
  local args = getPopularPackages_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getPopularPackages(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPopularPackages_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getPresentsReceived(start, size, language, country)
  self:send_getPresentsReceived(start, size, language, country)
  return self:recv_getPresentsReceived(start, size, language, country)
end

function ShopServiceClient:send_getPresentsReceived(start, size, language, country)
  self.oprot:writeMessageBegin('getPresentsReceived', TMessageType.CALL, self._seqid)
  local args = getPresentsReceived_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getPresentsReceived(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPresentsReceived_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getPresentsSent(start, size, language, country)
  self:send_getPresentsSent(start, size, language, country)
  return self:recv_getPresentsSent(start, size, language, country)
end

function ShopServiceClient:send_getPresentsSent(start, size, language, country)
  self.oprot:writeMessageBegin('getPresentsSent', TMessageType.CALL, self._seqid)
  local args = getPresentsSent_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getPresentsSent(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPresentsSent_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getProduct(packageID, language, country)
  self:send_getProduct(packageID, language, country)
  return self:recv_getProduct(packageID, language, country)
end

function ShopServiceClient:send_getProduct(packageID, language, country)
  self.oprot:writeMessageBegin('getProduct', TMessageType.CALL, self._seqid)
  local args = getProduct_args:new{}
  args.packageID = packageID
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getProduct(packageID, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProduct_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getProductList(productIdList, language, country)
  self:send_getProductList(productIdList, language, country)
  return self:recv_getProductList(productIdList, language, country)
end

function ShopServiceClient:send_getProductList(productIdList, language, country)
  self.oprot:writeMessageBegin('getProductList', TMessageType.CALL, self._seqid)
  local args = getProductList_args:new{}
  args.productIdList = productIdList
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getProductList(productIdList, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProductList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getProductListWithCarrier(productIdList, language, country, carrierCode)
  self:send_getProductListWithCarrier(productIdList, language, country, carrierCode)
  return self:recv_getProductListWithCarrier(productIdList, language, country, carrierCode)
end

function ShopServiceClient:send_getProductListWithCarrier(productIdList, language, country, carrierCode)
  self.oprot:writeMessageBegin('getProductListWithCarrier', TMessageType.CALL, self._seqid)
  local args = getProductListWithCarrier_args:new{}
  args.productIdList = productIdList
  args.language = language
  args.country = country
  args.carrierCode = carrierCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getProductListWithCarrier(productIdList, language, country, carrierCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProductListWithCarrier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getProductWithCarrier(packageID, language, country, carrierCode)
  self:send_getProductWithCarrier(packageID, language, country, carrierCode)
  return self:recv_getProductWithCarrier(packageID, language, country, carrierCode)
end

function ShopServiceClient:send_getProductWithCarrier(packageID, language, country, carrierCode)
  self.oprot:writeMessageBegin('getProductWithCarrier', TMessageType.CALL, self._seqid)
  local args = getProductWithCarrier_args:new{}
  args.packageID = packageID
  args.language = language
  args.country = country
  args.carrierCode = carrierCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getProductWithCarrier(packageID, language, country, carrierCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getProductWithCarrier_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getPurchaseHistory(start, size, language, country)
  self:send_getPurchaseHistory(start, size, language, country)
  return self:recv_getPurchaseHistory(start, size, language, country)
end

function ShopServiceClient:send_getPurchaseHistory(start, size, language, country)
  self.oprot:writeMessageBegin('getPurchaseHistory', TMessageType.CALL, self._seqid)
  local args = getPurchaseHistory_args:new{}
  args.start = start
  args.size = size
  args.language = language
  args.country = country
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getPurchaseHistory(start, size, language, country)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getPurchaseHistory_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:getTotalBalance(appStoreCode)
  self:send_getTotalBalance(appStoreCode)
  return self:recv_getTotalBalance(appStoreCode)
end

function ShopServiceClient:send_getTotalBalance(appStoreCode)
  self.oprot:writeMessageBegin('getTotalBalance', TMessageType.CALL, self._seqid)
  local args = getTotalBalance_args:new{}
  args.appStoreCode = appStoreCode
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_getTotalBalance(appStoreCode)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = getTotalBalance_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:notifyDownloaded(packageId, language)
  self:send_notifyDownloaded(packageId, language)
  return self:recv_notifyDownloaded(packageId, language)
end

function ShopServiceClient:send_notifyDownloaded(packageId, language)
  self.oprot:writeMessageBegin('notifyDownloaded', TMessageType.CALL, self._seqid)
  local args = notifyDownloaded_args:new{}
  args.packageId = packageId
  args.language = language
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_notifyDownloaded(packageId, language)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = notifyDownloaded_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:reserveCoinPurchase(request)
  self:send_reserveCoinPurchase(request)
  return self:recv_reserveCoinPurchase(request)
end

function ShopServiceClient:send_reserveCoinPurchase(request)
  self.oprot:writeMessageBegin('reserveCoinPurchase', TMessageType.CALL, self._seqid)
  local args = reserveCoinPurchase_args:new{}
  args.request = request
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_reserveCoinPurchase(request)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reserveCoinPurchase_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ShopServiceClient:reservePayment(paymentReservation)
  self:send_reservePayment(paymentReservation)
  return self:recv_reservePayment(paymentReservation)
end

function ShopServiceClient:send_reservePayment(paymentReservation)
  self.oprot:writeMessageBegin('reservePayment', TMessageType.CALL, self._seqid)
  local args = reservePayment_args:new{}
  args.paymentReservation = paymentReservation
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ShopServiceClient:recv_reservePayment(paymentReservation)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = reservePayment_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success ~= nil then
    return result.success
  elseif result.e then
    error(result.e)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end
ShopServiceIface = __TObject:new{
  __type = 'ShopServiceIface'
}


ShopServiceProcessor = __TObject.new(__TProcessor
, {
 __type = 'ShopServiceProcessor'
})

function ShopServiceProcessor:process(iprot, oprot, server_ctx)
  local name, mtype, seqid = iprot:readMessageBegin()
  local func_name = 'process_' .. name
  if not self[func_name] or ttype(self[func_name]) ~= 'function' then
    iprot:skip(TType.STRUCT)
    iprot:readMessageEnd()
    x = TApplicationException:new{
      errorCode = TApplicationException.UNKNOWN_METHOD
    }
    oprot:writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
    x:write(oprot)
    oprot:writeMessageEnd()
    oprot.trans:flush()
  else
    self[func_name](self, seqid, iprot, oprot, server_ctx)
  end
end

function ShopServiceProcessor:process_buyCoinProduct(seqid, iprot, oprot, server_ctx)
  local args = buyCoinProduct_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = buyCoinProduct_result:new{}
  local status, res = pcall(self.handler.buyCoinProduct, self.handler, args.paymentReservation)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('buyCoinProduct', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_buyFreeProduct(seqid, iprot, oprot, server_ctx)
  local args = buyFreeProduct_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = buyFreeProduct_result:new{}
  local status, res = pcall(self.handler.buyFreeProduct, self.handler, args.receiverMid, args.productId, args.messageTemplate, args.language, args.country, args.packageId)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('buyFreeProduct', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_buyMustbuyProduct(seqid, iprot, oprot, server_ctx)
  local args = buyMustbuyProduct_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = buyMustbuyProduct_result:new{}
  local status, res = pcall(self.handler.buyMustbuyProduct, self.handler, args.receiverMid, args.productId, args.messageTemplate, args.language, args.country, args.packageId, args.serialNumber)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('buyMustbuyProduct', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_checkCanReceivePresent(seqid, iprot, oprot, server_ctx)
  local args = checkCanReceivePresent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = checkCanReceivePresent_result:new{}
  local status, res = pcall(self.handler.checkCanReceivePresent, self.handler, args.recipientMid, args.packageId, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('checkCanReceivePresent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getActivePurchases(seqid, iprot, oprot, server_ctx)
  local args = getActivePurchases_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getActivePurchases_result:new{}
  local status, res = pcall(self.handler.getActivePurchases, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getActivePurchases', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getActivePurchaseVersions(seqid, iprot, oprot, server_ctx)
  local args = getActivePurchaseVersions_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getActivePurchaseVersions_result:new{}
  local status, res = pcall(self.handler.getActivePurchaseVersions, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getActivePurchaseVersions', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getCoinProducts(seqid, iprot, oprot, server_ctx)
  local args = getCoinProducts_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCoinProducts_result:new{}
  local status, res = pcall(self.handler.getCoinProducts, self.handler, args.appStoreCode, args.country, args.language)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCoinProducts', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getCoinProductsByPgCode(seqid, iprot, oprot, server_ctx)
  local args = getCoinProductsByPgCode_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCoinProductsByPgCode_result:new{}
  local status, res = pcall(self.handler.getCoinProductsByPgCode, self.handler, args.appStoreCode, args.pgCode, args.country, args.language)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCoinProductsByPgCode', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getCoinPurchaseHistory(seqid, iprot, oprot, server_ctx)
  local args = getCoinPurchaseHistory_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCoinPurchaseHistory_result:new{}
  local status, res = pcall(self.handler.getCoinPurchaseHistory, self.handler, args.request)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCoinPurchaseHistory', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getCoinUseAndRefundHistory(seqid, iprot, oprot, server_ctx)
  local args = getCoinUseAndRefundHistory_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getCoinUseAndRefundHistory_result:new{}
  local status, res = pcall(self.handler.getCoinUseAndRefundHistory, self.handler, args.request)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getCoinUseAndRefundHistory', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getDownloads(seqid, iprot, oprot, server_ctx)
  local args = getDownloads_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getDownloads_result:new{}
  local status, res = pcall(self.handler.getDownloads, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getDownloads', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getEventPackages(seqid, iprot, oprot, server_ctx)
  local args = getEventPackages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getEventPackages_result:new{}
  local status, res = pcall(self.handler.getEventPackages, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getEventPackages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getNewlyReleasedPackages(seqid, iprot, oprot, server_ctx)
  local args = getNewlyReleasedPackages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getNewlyReleasedPackages_result:new{}
  local status, res = pcall(self.handler.getNewlyReleasedPackages, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getNewlyReleasedPackages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getPopularPackages(seqid, iprot, oprot, server_ctx)
  local args = getPopularPackages_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPopularPackages_result:new{}
  local status, res = pcall(self.handler.getPopularPackages, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPopularPackages', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getPresentsReceived(seqid, iprot, oprot, server_ctx)
  local args = getPresentsReceived_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPresentsReceived_result:new{}
  local status, res = pcall(self.handler.getPresentsReceived, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPresentsReceived', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getPresentsSent(seqid, iprot, oprot, server_ctx)
  local args = getPresentsSent_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPresentsSent_result:new{}
  local status, res = pcall(self.handler.getPresentsSent, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPresentsSent', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getProduct(seqid, iprot, oprot, server_ctx)
  local args = getProduct_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProduct_result:new{}
  local status, res = pcall(self.handler.getProduct, self.handler, args.packageID, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProduct', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getProductList(seqid, iprot, oprot, server_ctx)
  local args = getProductList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProductList_result:new{}
  local status, res = pcall(self.handler.getProductList, self.handler, args.productIdList, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProductList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getProductListWithCarrier(seqid, iprot, oprot, server_ctx)
  local args = getProductListWithCarrier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProductListWithCarrier_result:new{}
  local status, res = pcall(self.handler.getProductListWithCarrier, self.handler, args.productIdList, args.language, args.country, args.carrierCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProductListWithCarrier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getProductWithCarrier(seqid, iprot, oprot, server_ctx)
  local args = getProductWithCarrier_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getProductWithCarrier_result:new{}
  local status, res = pcall(self.handler.getProductWithCarrier, self.handler, args.packageID, args.language, args.country, args.carrierCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getProductWithCarrier', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getPurchaseHistory(seqid, iprot, oprot, server_ctx)
  local args = getPurchaseHistory_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getPurchaseHistory_result:new{}
  local status, res = pcall(self.handler.getPurchaseHistory, self.handler, args.start, args.size, args.language, args.country)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getPurchaseHistory', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_getTotalBalance(seqid, iprot, oprot, server_ctx)
  local args = getTotalBalance_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = getTotalBalance_result:new{}
  local status, res = pcall(self.handler.getTotalBalance, self.handler, args.appStoreCode)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('getTotalBalance', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_notifyDownloaded(seqid, iprot, oprot, server_ctx)
  local args = notifyDownloaded_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = notifyDownloaded_result:new{}
  local status, res = pcall(self.handler.notifyDownloaded, self.handler, args.packageId, args.language)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('notifyDownloaded', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_reserveCoinPurchase(seqid, iprot, oprot, server_ctx)
  local args = reserveCoinPurchase_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reserveCoinPurchase_result:new{}
  local status, res = pcall(self.handler.reserveCoinPurchase, self.handler, args.request)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reserveCoinPurchase', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ShopServiceProcessor:process_reservePayment(seqid, iprot, oprot, server_ctx)
  local args = reservePayment_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = reservePayment_result:new{}
  local status, res = pcall(self.handler.reservePayment, self.handler, args.paymentReservation)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'TalkException' then
    result.e = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('reservePayment', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

-- HELPER FUNCTIONS AND STRUCTURES

buyCoinProduct_args = __TObject:new{
  paymentReservation
}

function buyCoinProduct_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.paymentReservation = PaymentReservation:new{}
        self.paymentReservation:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyCoinProduct_args:write(oprot)
  oprot:writeStructBegin('buyCoinProduct_args')
  if self.paymentReservation ~= nil then
    oprot:writeFieldBegin('paymentReservation', TType.STRUCT, 2)
    self.paymentReservation:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

buyCoinProduct_result = __TObject:new{
  e
}

function buyCoinProduct_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyCoinProduct_result:write(oprot)
  oprot:writeStructBegin('buyCoinProduct_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

buyFreeProduct_args = __TObject:new{
  receiverMid,
  productId,
  messageTemplate,
  language,
  country,
  packageId
}

function buyFreeProduct_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.receiverMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.productId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messageTemplate = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.I64 then
        self.packageId = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyFreeProduct_args:write(oprot)
  oprot:writeStructBegin('buyFreeProduct_args')
  if self.receiverMid ~= nil then
    oprot:writeFieldBegin('receiverMid', TType.STRING, 2)
    oprot:writeString(self.receiverMid)
    oprot:writeFieldEnd()
  end
  if self.productId ~= nil then
    oprot:writeFieldBegin('productId', TType.STRING, 3)
    oprot:writeString(self.productId)
    oprot:writeFieldEnd()
  end
  if self.messageTemplate ~= nil then
    oprot:writeFieldBegin('messageTemplate', TType.I32, 4)
    oprot:writeI32(self.messageTemplate)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 5)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 6)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.packageId ~= nil then
    oprot:writeFieldBegin('packageId', TType.I64, 7)
    oprot:writeI64(self.packageId)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

buyFreeProduct_result = __TObject:new{
  e
}

function buyFreeProduct_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyFreeProduct_result:write(oprot)
  oprot:writeStructBegin('buyFreeProduct_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

buyMustbuyProduct_args = __TObject:new{
  receiverMid,
  productId,
  messageTemplate,
  language,
  country,
  packageId,
  serialNumber
}

function buyMustbuyProduct_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.receiverMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.productId = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.messageTemplate = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.I64 then
        self.packageId = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRING then
        self.serialNumber = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyMustbuyProduct_args:write(oprot)
  oprot:writeStructBegin('buyMustbuyProduct_args')
  if self.receiverMid ~= nil then
    oprot:writeFieldBegin('receiverMid', TType.STRING, 2)
    oprot:writeString(self.receiverMid)
    oprot:writeFieldEnd()
  end
  if self.productId ~= nil then
    oprot:writeFieldBegin('productId', TType.STRING, 3)
    oprot:writeString(self.productId)
    oprot:writeFieldEnd()
  end
  if self.messageTemplate ~= nil then
    oprot:writeFieldBegin('messageTemplate', TType.I32, 4)
    oprot:writeI32(self.messageTemplate)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 5)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 6)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.packageId ~= nil then
    oprot:writeFieldBegin('packageId', TType.I64, 7)
    oprot:writeI64(self.packageId)
    oprot:writeFieldEnd()
  end
  if self.serialNumber ~= nil then
    oprot:writeFieldBegin('serialNumber', TType.STRING, 8)
    oprot:writeString(self.serialNumber)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

buyMustbuyProduct_result = __TObject:new{
  e
}

function buyMustbuyProduct_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function buyMustbuyProduct_result:write(oprot)
  oprot:writeStructBegin('buyMustbuyProduct_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

checkCanReceivePresent_args = __TObject:new{
  recipientMid,
  packageId,
  language,
  country
}

function checkCanReceivePresent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.recipientMid = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.packageId = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function checkCanReceivePresent_args:write(oprot)
  oprot:writeStructBegin('checkCanReceivePresent_args')
  if self.recipientMid ~= nil then
    oprot:writeFieldBegin('recipientMid', TType.STRING, 2)
    oprot:writeString(self.recipientMid)
    oprot:writeFieldEnd()
  end
  if self.packageId ~= nil then
    oprot:writeFieldBegin('packageId', TType.I64, 3)
    oprot:writeI64(self.packageId)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

checkCanReceivePresent_result = __TObject:new{
  e
}

function checkCanReceivePresent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function checkCanReceivePresent_result:write(oprot)
  oprot:writeStructBegin('checkCanReceivePresent_result')
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActivePurchases_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getActivePurchases_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActivePurchases_args:write(oprot)
  oprot:writeStructBegin('getActivePurchases_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActivePurchases_result = __TObject:new{
  success,
  e
}

function getActivePurchases_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActivePurchases_result:write(oprot)
  oprot:writeStructBegin('getActivePurchases_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActivePurchaseVersions_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getActivePurchaseVersions_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActivePurchaseVersions_args:write(oprot)
  oprot:writeStructBegin('getActivePurchaseVersions_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getActivePurchaseVersions_result = __TObject:new{
  success,
  e
}

function getActivePurchaseVersions_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductSimpleList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getActivePurchaseVersions_result:write(oprot)
  oprot:writeStructBegin('getActivePurchaseVersions_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinProducts_args = __TObject:new{
  appStoreCode,
  country,
  language
}

function getCoinProducts_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.appStoreCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinProducts_args:write(oprot)
  oprot:writeStructBegin('getCoinProducts_args')
  if self.appStoreCode ~= nil then
    oprot:writeFieldBegin('appStoreCode', TType.I32, 2)
    oprot:writeI32(self.appStoreCode)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 3)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinProducts_result = __TObject:new{
  success,
  e
}

function getCoinProducts_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1281, _size1278 = iprot:readListBegin()
        for _i=1,_size1278 do
          local _elem1282 = CoinProductItem:new{}
          _elem1282:read(iprot)
          table.insert(self.success, _elem1282)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinProducts_result:write(oprot)
  oprot:writeStructBegin('getCoinProducts_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1283 in ipairs(self.success) do
      iter1283:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinProductsByPgCode_args = __TObject:new{
  appStoreCode,
  pgCode,
  country,
  language
}

function getCoinProductsByPgCode_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.appStoreCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.pgCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinProductsByPgCode_args:write(oprot)
  oprot:writeStructBegin('getCoinProductsByPgCode_args')
  if self.appStoreCode ~= nil then
    oprot:writeFieldBegin('appStoreCode', TType.I32, 2)
    oprot:writeI32(self.appStoreCode)
    oprot:writeFieldEnd()
  end
  if self.pgCode ~= nil then
    oprot:writeFieldBegin('pgCode', TType.I32, 3)
    oprot:writeI32(self.pgCode)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 4)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 5)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinProductsByPgCode_result = __TObject:new{
  success,
  e
}

function getCoinProductsByPgCode_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype1287, _size1284 = iprot:readListBegin()
        for _i=1,_size1284 do
          local _elem1288 = CoinProductItem:new{}
          _elem1288:read(iprot)
          table.insert(self.success, _elem1288)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinProductsByPgCode_result:write(oprot)
  oprot:writeStructBegin('getCoinProductsByPgCode_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.STRUCT, #self.success)
    for _,iter1289 in ipairs(self.success) do
      iter1289:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinPurchaseHistory_args = __TObject:new{
  request
}

function getCoinPurchaseHistory_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.request = CoinHistoryCondition:new{}
        self.request:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinPurchaseHistory_args:write(oprot)
  oprot:writeStructBegin('getCoinPurchaseHistory_args')
  if self.request ~= nil then
    oprot:writeFieldBegin('request', TType.STRUCT, 2)
    self.request:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinPurchaseHistory_result = __TObject:new{
  success,
  e
}

function getCoinPurchaseHistory_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = CoinHistoryResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinPurchaseHistory_result:write(oprot)
  oprot:writeStructBegin('getCoinPurchaseHistory_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinUseAndRefundHistory_args = __TObject:new{
  request
}

function getCoinUseAndRefundHistory_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.request = CoinHistoryCondition:new{}
        self.request:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinUseAndRefundHistory_args:write(oprot)
  oprot:writeStructBegin('getCoinUseAndRefundHistory_args')
  if self.request ~= nil then
    oprot:writeFieldBegin('request', TType.STRUCT, 2)
    self.request:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getCoinUseAndRefundHistory_result = __TObject:new{
  success,
  e
}

function getCoinUseAndRefundHistory_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = CoinHistoryResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getCoinUseAndRefundHistory_result:write(oprot)
  oprot:writeStructBegin('getCoinUseAndRefundHistory_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getDownloads_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getDownloads_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getDownloads_args:write(oprot)
  oprot:writeStructBegin('getDownloads_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getDownloads_result = __TObject:new{
  success,
  e
}

function getDownloads_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getDownloads_result:write(oprot)
  oprot:writeStructBegin('getDownloads_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getEventPackages_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getEventPackages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getEventPackages_args:write(oprot)
  oprot:writeStructBegin('getEventPackages_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getEventPackages_result = __TObject:new{
  success,
  e
}

function getEventPackages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getEventPackages_result:write(oprot)
  oprot:writeStructBegin('getEventPackages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNewlyReleasedPackages_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getNewlyReleasedPackages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNewlyReleasedPackages_args:write(oprot)
  oprot:writeStructBegin('getNewlyReleasedPackages_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getNewlyReleasedPackages_result = __TObject:new{
  success,
  e
}

function getNewlyReleasedPackages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getNewlyReleasedPackages_result:write(oprot)
  oprot:writeStructBegin('getNewlyReleasedPackages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPopularPackages_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getPopularPackages_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPopularPackages_args:write(oprot)
  oprot:writeStructBegin('getPopularPackages_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPopularPackages_result = __TObject:new{
  success,
  e
}

function getPopularPackages_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPopularPackages_result:write(oprot)
  oprot:writeStructBegin('getPopularPackages_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPresentsReceived_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getPresentsReceived_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPresentsReceived_args:write(oprot)
  oprot:writeStructBegin('getPresentsReceived_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPresentsReceived_result = __TObject:new{
  success,
  e
}

function getPresentsReceived_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPresentsReceived_result:write(oprot)
  oprot:writeStructBegin('getPresentsReceived_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPresentsSent_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getPresentsSent_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPresentsSent_args:write(oprot)
  oprot:writeStructBegin('getPresentsSent_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPresentsSent_result = __TObject:new{
  success,
  e
}

function getPresentsSent_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPresentsSent_result:write(oprot)
  oprot:writeStructBegin('getPresentsSent_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProduct_args = __TObject:new{
  packageID,
  language,
  country
}

function getProduct_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.packageID = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProduct_args:write(oprot)
  oprot:writeStructBegin('getProduct_args')
  if self.packageID ~= nil then
    oprot:writeFieldBegin('packageID', TType.I64, 2)
    oprot:writeI64(self.packageID)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 3)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 4)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProduct_result = __TObject:new{
  success,
  e
}

function getProduct_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Product:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProduct_result:write(oprot)
  oprot:writeStructBegin('getProduct_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductList_args = __TObject:new{
  productIdList,
  language,
  country
}

function getProductList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.productIdList = {}
        local _etype1293, _size1290 = iprot:readListBegin()
        for _i=1,_size1290 do
          local _elem1294 = iprot:readString()
          table.insert(self.productIdList, _elem1294)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductList_args:write(oprot)
  oprot:writeStructBegin('getProductList_args')
  if self.productIdList ~= nil then
    oprot:writeFieldBegin('productIdList', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.productIdList)
    for _,iter1295 in ipairs(self.productIdList) do
      oprot:writeString(iter1295)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 3)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 4)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductList_result = __TObject:new{
  success,
  e
}

function getProductList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductList_result:write(oprot)
  oprot:writeStructBegin('getProductList_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductListWithCarrier_args = __TObject:new{
  productIdList,
  language,
  country,
  carrierCode
}

function getProductListWithCarrier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.productIdList = {}
        local _etype1299, _size1296 = iprot:readListBegin()
        for _i=1,_size1296 do
          local _elem1300 = iprot:readString()
          table.insert(self.productIdList, _elem1300)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.carrierCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductListWithCarrier_args:write(oprot)
  oprot:writeStructBegin('getProductListWithCarrier_args')
  if self.productIdList ~= nil then
    oprot:writeFieldBegin('productIdList', TType.LIST, 2)
    oprot:writeListBegin(TType.STRING, #self.productIdList)
    for _,iter1301 in ipairs(self.productIdList) do
      oprot:writeString(iter1301)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 3)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 4)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.carrierCode ~= nil then
    oprot:writeFieldBegin('carrierCode', TType.STRING, 5)
    oprot:writeString(self.carrierCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductListWithCarrier_result = __TObject:new{
  success,
  e
}

function getProductListWithCarrier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductListWithCarrier_result:write(oprot)
  oprot:writeStructBegin('getProductListWithCarrier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductWithCarrier_args = __TObject:new{
  packageID,
  language,
  country,
  carrierCode
}

function getProductWithCarrier_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.packageID = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.carrierCode = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductWithCarrier_args:write(oprot)
  oprot:writeStructBegin('getProductWithCarrier_args')
  if self.packageID ~= nil then
    oprot:writeFieldBegin('packageID', TType.I64, 2)
    oprot:writeI64(self.packageID)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 3)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 4)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  if self.carrierCode ~= nil then
    oprot:writeFieldBegin('carrierCode', TType.STRING, 5)
    oprot:writeString(self.carrierCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getProductWithCarrier_result = __TObject:new{
  success,
  e
}

function getProductWithCarrier_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Product:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getProductWithCarrier_result:write(oprot)
  oprot:writeStructBegin('getProductWithCarrier_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPurchaseHistory_args = __TObject:new{
  start,
  size,
  language,
  country
}

function getPurchaseHistory_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.start = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.size = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.country = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPurchaseHistory_args:write(oprot)
  oprot:writeStructBegin('getPurchaseHistory_args')
  if self.start ~= nil then
    oprot:writeFieldBegin('start', TType.I64, 2)
    oprot:writeI64(self.start)
    oprot:writeFieldEnd()
  end
  if self.size ~= nil then
    oprot:writeFieldBegin('size', TType.I32, 3)
    oprot:writeI32(self.size)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 4)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  if self.country ~= nil then
    oprot:writeFieldBegin('country', TType.STRING, 5)
    oprot:writeString(self.country)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getPurchaseHistory_result = __TObject:new{
  success,
  e
}

function getPurchaseHistory_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = ProductList:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getPurchaseHistory_result:write(oprot)
  oprot:writeStructBegin('getPurchaseHistory_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getTotalBalance_args = __TObject:new{
  appStoreCode
}

function getTotalBalance_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.appStoreCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getTotalBalance_args:write(oprot)
  oprot:writeStructBegin('getTotalBalance_args')
  if self.appStoreCode ~= nil then
    oprot:writeFieldBegin('appStoreCode', TType.I32, 2)
    oprot:writeI32(self.appStoreCode)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

getTotalBalance_result = __TObject:new{
  success,
  e
}

function getTotalBalance_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Coin:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function getTotalBalance_result:write(oprot)
  oprot:writeStructBegin('getTotalBalance_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyDownloaded_args = __TObject:new{
  packageId,
  language
}

function notifyDownloaded_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.packageId = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.language = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyDownloaded_args:write(oprot)
  oprot:writeStructBegin('notifyDownloaded_args')
  if self.packageId ~= nil then
    oprot:writeFieldBegin('packageId', TType.I64, 2)
    oprot:writeI64(self.packageId)
    oprot:writeFieldEnd()
  end
  if self.language ~= nil then
    oprot:writeFieldBegin('language', TType.STRING, 3)
    oprot:writeString(self.language)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

notifyDownloaded_result = __TObject:new{
  success,
  e
}

function notifyDownloaded_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function notifyDownloaded_result:write(oprot)
  oprot:writeStructBegin('notifyDownloaded_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reserveCoinPurchase_args = __TObject:new{
  request
}

function reserveCoinPurchase_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.request = CoinPurchaseReservation:new{}
        self.request:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reserveCoinPurchase_args:write(oprot)
  oprot:writeStructBegin('reserveCoinPurchase_args')
  if self.request ~= nil then
    oprot:writeFieldBegin('request', TType.STRUCT, 2)
    self.request:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reserveCoinPurchase_result = __TObject:new{
  success,
  e
}

function reserveCoinPurchase_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = PaymentReservationResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reserveCoinPurchase_result:write(oprot)
  oprot:writeStructBegin('reserveCoinPurchase_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reservePayment_args = __TObject:new{
  paymentReservation
}

function reservePayment_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.paymentReservation = PaymentReservation:new{}
        self.paymentReservation:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reservePayment_args:write(oprot)
  oprot:writeStructBegin('reservePayment_args')
  if self.paymentReservation ~= nil then
    oprot:writeFieldBegin('paymentReservation', TType.STRUCT, 2)
    self.paymentReservation:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

reservePayment_result = __TObject:new{
  success,
  e
}

function reservePayment_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = PaymentReservationResult:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.e = TalkException:new{}
        self.e:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function reservePayment_result:write(oprot)
  oprot:writeStructBegin('reservePayment_result')
  if self.success ~= nil then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.e ~= nil then
    oprot:writeFieldBegin('e', TType.STRUCT, 1)
    self.e:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end