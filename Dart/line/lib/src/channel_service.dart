/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library line.src.channel_service;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart';
import 'package:line/line.dart';


abstract class ChannelService {

  Future<OTPResult> issueOTP(String channelId);

  Future<ChannelToken> approveChannelAndIssueChannelToken(String channelId);

  Future<String> approveChannelAndIssueRequestToken(String channelId, String otpId);

  Future<NotificationFetchResult> fetchNotificationItems(int localRev);

  Future<ApprovedChannelInfos> getApprovedChannels(int lastSynced, String locale);

  Future<ChannelInfo> getChannelInfo(String channelId, String locale);

  Future<ChannelNotificationSetting> getChannelNotificationSetting(String channelId, String locale);

  Future<List<ChannelNotificationSetting>> getChannelNotificationSettings(String locale);

  Future<ChannelInfos> getChannels(int lastSynced, String locale);

  Future<ChannelDomains> getDomains(int lastSynced);

  Future<FriendChannelMatricesResponse> getFriendChannelMatrices(List<String> channelIds);

  Future<bool> updateChannelSettings(ChannelSettings channelSettings);

  Future<ChannelDomains> getCommonDomains(int lastSynced);

  Future<int> getNotificationBadgeCount(int localRev);

  Future<ChannelToken> issueChannelToken(String channelId);

  Future<String> issueRequestToken(String channelId, String otpId);

  Future<RequestTokenResponse> issueRequestTokenWithAuthScheme(String channelId, String otpId, List<String> authScheme, String returnUrl);

  Future<String> issueRequestTokenForAutoLogin(String channelId, String otpId, String redirectUrl);

  Future<List<String>> getUpdatedChannelIds(List<ChannelIdWithLastUpdated> channelIds);

  Future<String> reserveCoinUse(CoinUseReservation request, String locale);

  Future revokeChannel(String channelId);

  Future<ChannelSyncDatas> syncChannelData(int lastSynced, String locale);

  Future updateChannelNotificationSetting(List<ChannelNotificationSetting> setting);
}

class ChannelServiceClient implements ChannelService {

  ChannelServiceClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<OTPResult> issueOTP(String channelId) async {
    oprot.writeMessageBegin(new TMessage("issueOTP", TMessageType.CALL, nextSeqid()));
    issueOTP_args args = new issueOTP_args();
    args.channelId = channelId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    issueOTP_result result = new issueOTP_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "issueOTP failed: unknown result");
  }

  Future<ChannelToken> approveChannelAndIssueChannelToken(String channelId) async {
    oprot.writeMessageBegin(new TMessage("approveChannelAndIssueChannelToken", TMessageType.CALL, nextSeqid()));
    approveChannelAndIssueChannelToken_args args = new approveChannelAndIssueChannelToken_args();
    args.channelId = channelId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    approveChannelAndIssueChannelToken_result result = new approveChannelAndIssueChannelToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "approveChannelAndIssueChannelToken failed: unknown result");
  }

  Future<String> approveChannelAndIssueRequestToken(String channelId, String otpId) async {
    oprot.writeMessageBegin(new TMessage("approveChannelAndIssueRequestToken", TMessageType.CALL, nextSeqid()));
    approveChannelAndIssueRequestToken_args args = new approveChannelAndIssueRequestToken_args();
    args.channelId = channelId;
    args.otpId = otpId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    approveChannelAndIssueRequestToken_result result = new approveChannelAndIssueRequestToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "approveChannelAndIssueRequestToken failed: unknown result");
  }

  Future<NotificationFetchResult> fetchNotificationItems(int localRev) async {
    oprot.writeMessageBegin(new TMessage("fetchNotificationItems", TMessageType.CALL, nextSeqid()));
    fetchNotificationItems_args args = new fetchNotificationItems_args();
    args.localRev = localRev;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    fetchNotificationItems_result result = new fetchNotificationItems_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "fetchNotificationItems failed: unknown result");
  }

  Future<ApprovedChannelInfos> getApprovedChannels(int lastSynced, String locale) async {
    oprot.writeMessageBegin(new TMessage("getApprovedChannels", TMessageType.CALL, nextSeqid()));
    getApprovedChannels_args args = new getApprovedChannels_args();
    args.lastSynced = lastSynced;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getApprovedChannels_result result = new getApprovedChannels_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getApprovedChannels failed: unknown result");
  }

  Future<ChannelInfo> getChannelInfo(String channelId, String locale) async {
    oprot.writeMessageBegin(new TMessage("getChannelInfo", TMessageType.CALL, nextSeqid()));
    getChannelInfo_args args = new getChannelInfo_args();
    args.channelId = channelId;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChannelInfo_result result = new getChannelInfo_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChannelInfo failed: unknown result");
  }

  Future<ChannelNotificationSetting> getChannelNotificationSetting(String channelId, String locale) async {
    oprot.writeMessageBegin(new TMessage("getChannelNotificationSetting", TMessageType.CALL, nextSeqid()));
    getChannelNotificationSetting_args args = new getChannelNotificationSetting_args();
    args.channelId = channelId;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChannelNotificationSetting_result result = new getChannelNotificationSetting_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChannelNotificationSetting failed: unknown result");
  }

  Future<List<ChannelNotificationSetting>> getChannelNotificationSettings(String locale) async {
    oprot.writeMessageBegin(new TMessage("getChannelNotificationSettings", TMessageType.CALL, nextSeqid()));
    getChannelNotificationSettings_args args = new getChannelNotificationSettings_args();
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChannelNotificationSettings_result result = new getChannelNotificationSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChannelNotificationSettings failed: unknown result");
  }

  Future<ChannelInfos> getChannels(int lastSynced, String locale) async {
    oprot.writeMessageBegin(new TMessage("getChannels", TMessageType.CALL, nextSeqid()));
    getChannels_args args = new getChannels_args();
    args.lastSynced = lastSynced;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getChannels_result result = new getChannels_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getChannels failed: unknown result");
  }

  Future<ChannelDomains> getDomains(int lastSynced) async {
    oprot.writeMessageBegin(new TMessage("getDomains", TMessageType.CALL, nextSeqid()));
    getDomains_args args = new getDomains_args();
    args.lastSynced = lastSynced;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getDomains_result result = new getDomains_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getDomains failed: unknown result");
  }

  Future<FriendChannelMatricesResponse> getFriendChannelMatrices(List<String> channelIds) async {
    oprot.writeMessageBegin(new TMessage("getFriendChannelMatrices", TMessageType.CALL, nextSeqid()));
    getFriendChannelMatrices_args args = new getFriendChannelMatrices_args();
    args.channelIds = channelIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFriendChannelMatrices_result result = new getFriendChannelMatrices_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFriendChannelMatrices failed: unknown result");
  }

  Future<bool> updateChannelSettings(ChannelSettings channelSettings) async {
    oprot.writeMessageBegin(new TMessage("updateChannelSettings", TMessageType.CALL, nextSeqid()));
    updateChannelSettings_args args = new updateChannelSettings_args();
    args.channelSettings = channelSettings;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateChannelSettings_result result = new updateChannelSettings_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "updateChannelSettings failed: unknown result");
  }

  Future<ChannelDomains> getCommonDomains(int lastSynced) async {
    oprot.writeMessageBegin(new TMessage("getCommonDomains", TMessageType.CALL, nextSeqid()));
    getCommonDomains_args args = new getCommonDomains_args();
    args.lastSynced = lastSynced;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCommonDomains_result result = new getCommonDomains_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCommonDomains failed: unknown result");
  }

  Future<int> getNotificationBadgeCount(int localRev) async {
    oprot.writeMessageBegin(new TMessage("getNotificationBadgeCount", TMessageType.CALL, nextSeqid()));
    getNotificationBadgeCount_args args = new getNotificationBadgeCount_args();
    args.localRev = localRev;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getNotificationBadgeCount_result result = new getNotificationBadgeCount_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getNotificationBadgeCount failed: unknown result");
  }

  Future<ChannelToken> issueChannelToken(String channelId) async {
    oprot.writeMessageBegin(new TMessage("issueChannelToken", TMessageType.CALL, nextSeqid()));
    issueChannelToken_args args = new issueChannelToken_args();
    args.channelId = channelId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    issueChannelToken_result result = new issueChannelToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "issueChannelToken failed: unknown result");
  }

  Future<String> issueRequestToken(String channelId, String otpId) async {
    oprot.writeMessageBegin(new TMessage("issueRequestToken", TMessageType.CALL, nextSeqid()));
    issueRequestToken_args args = new issueRequestToken_args();
    args.channelId = channelId;
    args.otpId = otpId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    issueRequestToken_result result = new issueRequestToken_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "issueRequestToken failed: unknown result");
  }

  Future<RequestTokenResponse> issueRequestTokenWithAuthScheme(String channelId, String otpId, List<String> authScheme, String returnUrl) async {
    oprot.writeMessageBegin(new TMessage("issueRequestTokenWithAuthScheme", TMessageType.CALL, nextSeqid()));
    issueRequestTokenWithAuthScheme_args args = new issueRequestTokenWithAuthScheme_args();
    args.channelId = channelId;
    args.otpId = otpId;
    args.authScheme = authScheme;
    args.returnUrl = returnUrl;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    issueRequestTokenWithAuthScheme_result result = new issueRequestTokenWithAuthScheme_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "issueRequestTokenWithAuthScheme failed: unknown result");
  }

  Future<String> issueRequestTokenForAutoLogin(String channelId, String otpId, String redirectUrl) async {
    oprot.writeMessageBegin(new TMessage("issueRequestTokenForAutoLogin", TMessageType.CALL, nextSeqid()));
    issueRequestTokenForAutoLogin_args args = new issueRequestTokenForAutoLogin_args();
    args.channelId = channelId;
    args.otpId = otpId;
    args.redirectUrl = redirectUrl;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    issueRequestTokenForAutoLogin_result result = new issueRequestTokenForAutoLogin_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "issueRequestTokenForAutoLogin failed: unknown result");
  }

  Future<List<String>> getUpdatedChannelIds(List<ChannelIdWithLastUpdated> channelIds) async {
    oprot.writeMessageBegin(new TMessage("getUpdatedChannelIds", TMessageType.CALL, nextSeqid()));
    getUpdatedChannelIds_args args = new getUpdatedChannelIds_args();
    args.channelIds = channelIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUpdatedChannelIds_result result = new getUpdatedChannelIds_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUpdatedChannelIds failed: unknown result");
  }

  Future<String> reserveCoinUse(CoinUseReservation request, String locale) async {
    oprot.writeMessageBegin(new TMessage("reserveCoinUse", TMessageType.CALL, nextSeqid()));
    reserveCoinUse_args args = new reserveCoinUse_args();
    args.request = request;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reserveCoinUse_result result = new reserveCoinUse_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reserveCoinUse failed: unknown result");
  }

  Future revokeChannel(String channelId) async {
    oprot.writeMessageBegin(new TMessage("revokeChannel", TMessageType.CALL, nextSeqid()));
    revokeChannel_args args = new revokeChannel_args();
    args.channelId = channelId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    revokeChannel_result result = new revokeChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<ChannelSyncDatas> syncChannelData(int lastSynced, String locale) async {
    oprot.writeMessageBegin(new TMessage("syncChannelData", TMessageType.CALL, nextSeqid()));
    syncChannelData_args args = new syncChannelData_args();
    args.lastSynced = lastSynced;
    args.locale = locale;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    syncChannelData_result result = new syncChannelData_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "syncChannelData failed: unknown result");
  }

  Future updateChannelNotificationSetting(List<ChannelNotificationSetting> setting) async {
    oprot.writeMessageBegin(new TMessage("updateChannelNotificationSetting", TMessageType.CALL, nextSeqid()));
    updateChannelNotificationSetting_args args = new updateChannelNotificationSetting_args();
    args.setting = setting;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateChannelNotificationSetting_result result = new updateChannelNotificationSetting_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class ChannelServiceProcessor implements TProcessor {
  ChannelServiceProcessor(ChannelService iface) {
    iface_ = iface;
    PROCESS_MAP["issueOTP"] = issueOTP;
    PROCESS_MAP["approveChannelAndIssueChannelToken"] = approveChannelAndIssueChannelToken;
    PROCESS_MAP["approveChannelAndIssueRequestToken"] = approveChannelAndIssueRequestToken;
    PROCESS_MAP["fetchNotificationItems"] = fetchNotificationItems;
    PROCESS_MAP["getApprovedChannels"] = getApprovedChannels;
    PROCESS_MAP["getChannelInfo"] = getChannelInfo;
    PROCESS_MAP["getChannelNotificationSetting"] = getChannelNotificationSetting;
    PROCESS_MAP["getChannelNotificationSettings"] = getChannelNotificationSettings;
    PROCESS_MAP["getChannels"] = getChannels;
    PROCESS_MAP["getDomains"] = getDomains;
    PROCESS_MAP["getFriendChannelMatrices"] = getFriendChannelMatrices;
    PROCESS_MAP["updateChannelSettings"] = updateChannelSettings;
    PROCESS_MAP["getCommonDomains"] = getCommonDomains;
    PROCESS_MAP["getNotificationBadgeCount"] = getNotificationBadgeCount;
    PROCESS_MAP["issueChannelToken"] = issueChannelToken;
    PROCESS_MAP["issueRequestToken"] = issueRequestToken;
    PROCESS_MAP["issueRequestTokenWithAuthScheme"] = issueRequestTokenWithAuthScheme;
    PROCESS_MAP["issueRequestTokenForAutoLogin"] = issueRequestTokenForAutoLogin;
    PROCESS_MAP["getUpdatedChannelIds"] = getUpdatedChannelIds;
    PROCESS_MAP["reserveCoinUse"] = reserveCoinUse;
    PROCESS_MAP["revokeChannel"] = revokeChannel;
    PROCESS_MAP["syncChannelData"] = syncChannelData;
    PROCESS_MAP["updateChannelNotificationSetting"] = updateChannelNotificationSetting;
  }

  ChannelService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  issueOTP(int seqid, TProtocol iprot, TProtocol oprot) async {
    issueOTP_args args = new issueOTP_args();
    args.read(iprot);
    iprot.readMessageEnd();
    issueOTP_result result = new issueOTP_result();
    try {
      result.success = await iface_.issueOTP(args.channelId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing issueOTP");
      oprot.writeMessageBegin(new TMessage("issueOTP", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("issueOTP", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  approveChannelAndIssueChannelToken(int seqid, TProtocol iprot, TProtocol oprot) async {
    approveChannelAndIssueChannelToken_args args = new approveChannelAndIssueChannelToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    approveChannelAndIssueChannelToken_result result = new approveChannelAndIssueChannelToken_result();
    try {
      result.success = await iface_.approveChannelAndIssueChannelToken(args.channelId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing approveChannelAndIssueChannelToken");
      oprot.writeMessageBegin(new TMessage("approveChannelAndIssueChannelToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("approveChannelAndIssueChannelToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  approveChannelAndIssueRequestToken(int seqid, TProtocol iprot, TProtocol oprot) async {
    approveChannelAndIssueRequestToken_args args = new approveChannelAndIssueRequestToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    approveChannelAndIssueRequestToken_result result = new approveChannelAndIssueRequestToken_result();
    try {
      result.success = await iface_.approveChannelAndIssueRequestToken(args.channelId, args.otpId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing approveChannelAndIssueRequestToken");
      oprot.writeMessageBegin(new TMessage("approveChannelAndIssueRequestToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("approveChannelAndIssueRequestToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  fetchNotificationItems(int seqid, TProtocol iprot, TProtocol oprot) async {
    fetchNotificationItems_args args = new fetchNotificationItems_args();
    args.read(iprot);
    iprot.readMessageEnd();
    fetchNotificationItems_result result = new fetchNotificationItems_result();
    try {
      result.success = await iface_.fetchNotificationItems(args.localRev);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing fetchNotificationItems");
      oprot.writeMessageBegin(new TMessage("fetchNotificationItems", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("fetchNotificationItems", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getApprovedChannels(int seqid, TProtocol iprot, TProtocol oprot) async {
    getApprovedChannels_args args = new getApprovedChannels_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getApprovedChannels_result result = new getApprovedChannels_result();
    try {
      result.success = await iface_.getApprovedChannels(args.lastSynced, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getApprovedChannels");
      oprot.writeMessageBegin(new TMessage("getApprovedChannels", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getApprovedChannels", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getChannelInfo(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChannelInfo_args args = new getChannelInfo_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChannelInfo_result result = new getChannelInfo_result();
    try {
      result.success = await iface_.getChannelInfo(args.channelId, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChannelInfo");
      oprot.writeMessageBegin(new TMessage("getChannelInfo", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChannelInfo", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getChannelNotificationSetting(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChannelNotificationSetting_args args = new getChannelNotificationSetting_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChannelNotificationSetting_result result = new getChannelNotificationSetting_result();
    try {
      result.success = await iface_.getChannelNotificationSetting(args.channelId, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChannelNotificationSetting");
      oprot.writeMessageBegin(new TMessage("getChannelNotificationSetting", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChannelNotificationSetting", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getChannelNotificationSettings(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChannelNotificationSettings_args args = new getChannelNotificationSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChannelNotificationSettings_result result = new getChannelNotificationSettings_result();
    try {
      result.success = await iface_.getChannelNotificationSettings(args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChannelNotificationSettings");
      oprot.writeMessageBegin(new TMessage("getChannelNotificationSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChannelNotificationSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getChannels(int seqid, TProtocol iprot, TProtocol oprot) async {
    getChannels_args args = new getChannels_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getChannels_result result = new getChannels_result();
    try {
      result.success = await iface_.getChannels(args.lastSynced, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getChannels");
      oprot.writeMessageBegin(new TMessage("getChannels", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getChannels", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getDomains(int seqid, TProtocol iprot, TProtocol oprot) async {
    getDomains_args args = new getDomains_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getDomains_result result = new getDomains_result();
    try {
      result.success = await iface_.getDomains(args.lastSynced);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getDomains");
      oprot.writeMessageBegin(new TMessage("getDomains", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getDomains", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFriendChannelMatrices(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFriendChannelMatrices_args args = new getFriendChannelMatrices_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFriendChannelMatrices_result result = new getFriendChannelMatrices_result();
    try {
      result.success = await iface_.getFriendChannelMatrices(args.channelIds);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFriendChannelMatrices");
      oprot.writeMessageBegin(new TMessage("getFriendChannelMatrices", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFriendChannelMatrices", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateChannelSettings(int seqid, TProtocol iprot, TProtocol oprot) async {
    updateChannelSettings_args args = new updateChannelSettings_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateChannelSettings_result result = new updateChannelSettings_result();
    try {
      result.success = await iface_.updateChannelSettings(args.channelSettings);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateChannelSettings");
      oprot.writeMessageBegin(new TMessage("updateChannelSettings", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateChannelSettings", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCommonDomains(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCommonDomains_args args = new getCommonDomains_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCommonDomains_result result = new getCommonDomains_result();
    try {
      result.success = await iface_.getCommonDomains(args.lastSynced);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCommonDomains");
      oprot.writeMessageBegin(new TMessage("getCommonDomains", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCommonDomains", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getNotificationBadgeCount(int seqid, TProtocol iprot, TProtocol oprot) async {
    getNotificationBadgeCount_args args = new getNotificationBadgeCount_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getNotificationBadgeCount_result result = new getNotificationBadgeCount_result();
    try {
      result.success = await iface_.getNotificationBadgeCount(args.localRev);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getNotificationBadgeCount");
      oprot.writeMessageBegin(new TMessage("getNotificationBadgeCount", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getNotificationBadgeCount", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  issueChannelToken(int seqid, TProtocol iprot, TProtocol oprot) async {
    issueChannelToken_args args = new issueChannelToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    issueChannelToken_result result = new issueChannelToken_result();
    try {
      result.success = await iface_.issueChannelToken(args.channelId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing issueChannelToken");
      oprot.writeMessageBegin(new TMessage("issueChannelToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("issueChannelToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  issueRequestToken(int seqid, TProtocol iprot, TProtocol oprot) async {
    issueRequestToken_args args = new issueRequestToken_args();
    args.read(iprot);
    iprot.readMessageEnd();
    issueRequestToken_result result = new issueRequestToken_result();
    try {
      result.success = await iface_.issueRequestToken(args.channelId, args.otpId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing issueRequestToken");
      oprot.writeMessageBegin(new TMessage("issueRequestToken", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("issueRequestToken", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  issueRequestTokenWithAuthScheme(int seqid, TProtocol iprot, TProtocol oprot) async {
    issueRequestTokenWithAuthScheme_args args = new issueRequestTokenWithAuthScheme_args();
    args.read(iprot);
    iprot.readMessageEnd();
    issueRequestTokenWithAuthScheme_result result = new issueRequestTokenWithAuthScheme_result();
    try {
      result.success = await iface_.issueRequestTokenWithAuthScheme(args.channelId, args.otpId, args.authScheme, args.returnUrl);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing issueRequestTokenWithAuthScheme");
      oprot.writeMessageBegin(new TMessage("issueRequestTokenWithAuthScheme", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("issueRequestTokenWithAuthScheme", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  issueRequestTokenForAutoLogin(int seqid, TProtocol iprot, TProtocol oprot) async {
    issueRequestTokenForAutoLogin_args args = new issueRequestTokenForAutoLogin_args();
    args.read(iprot);
    iprot.readMessageEnd();
    issueRequestTokenForAutoLogin_result result = new issueRequestTokenForAutoLogin_result();
    try {
      result.success = await iface_.issueRequestTokenForAutoLogin(args.channelId, args.otpId, args.redirectUrl);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing issueRequestTokenForAutoLogin");
      oprot.writeMessageBegin(new TMessage("issueRequestTokenForAutoLogin", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("issueRequestTokenForAutoLogin", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUpdatedChannelIds(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUpdatedChannelIds_args args = new getUpdatedChannelIds_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUpdatedChannelIds_result result = new getUpdatedChannelIds_result();
    try {
      result.success = await iface_.getUpdatedChannelIds(args.channelIds);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUpdatedChannelIds");
      oprot.writeMessageBegin(new TMessage("getUpdatedChannelIds", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUpdatedChannelIds", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reserveCoinUse(int seqid, TProtocol iprot, TProtocol oprot) async {
    reserveCoinUse_args args = new reserveCoinUse_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reserveCoinUse_result result = new reserveCoinUse_result();
    try {
      result.success = await iface_.reserveCoinUse(args.request, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reserveCoinUse");
      oprot.writeMessageBegin(new TMessage("reserveCoinUse", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reserveCoinUse", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  revokeChannel(int seqid, TProtocol iprot, TProtocol oprot) {
    revokeChannel_args args = new revokeChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    revokeChannel_result result = new revokeChannel_result();
    try {
      iface_.revokeChannel(args.channelId);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing revokeChannel");
      oprot.writeMessageBegin(new TMessage("revokeChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("revokeChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  syncChannelData(int seqid, TProtocol iprot, TProtocol oprot) async {
    syncChannelData_args args = new syncChannelData_args();
    args.read(iprot);
    iprot.readMessageEnd();
    syncChannelData_result result = new syncChannelData_result();
    try {
      result.success = await iface_.syncChannelData(args.lastSynced, args.locale);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing syncChannelData");
      oprot.writeMessageBegin(new TMessage("syncChannelData", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("syncChannelData", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateChannelNotificationSetting(int seqid, TProtocol iprot, TProtocol oprot) {
    updateChannelNotificationSetting_args args = new updateChannelNotificationSetting_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateChannelNotificationSetting_result result = new updateChannelNotificationSetting_result();
    try {
      iface_.updateChannelNotificationSetting(args.setting);
    } on ChannelException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateChannelNotificationSetting");
      oprot.writeMessageBegin(new TMessage("updateChannelNotificationSetting", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateChannelNotificationSetting", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class issueOTP_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueOTP_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);

  String _channelId;
  static const int CHANNELID = 2;


  issueOTP_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueOTP_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueOTP_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueOTP_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  OTPResult _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  issueOTP_result() {
  }

  // success
  OTPResult get success => this._success;

  set success(OTPResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new OTPResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueOTP_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class approveChannelAndIssueChannelToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("approveChannelAndIssueChannelToken_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);

  String _channelId;
  static const int CHANNELID = 1;


  approveChannelAndIssueChannelToken_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("approveChannelAndIssueChannelToken_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class approveChannelAndIssueChannelToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("approveChannelAndIssueChannelToken_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelToken _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  approveChannelAndIssueChannelToken_result() {
  }

  // success
  ChannelToken get success => this._success;

  set success(ChannelToken success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelToken();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("approveChannelAndIssueChannelToken_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class approveChannelAndIssueRequestToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("approveChannelAndIssueRequestToken_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);
  static final TField _OTP_ID_FIELD_DESC = new TField("otpId", TType.STRING, 2);

  String _channelId;
  static const int CHANNELID = 1;
  String _otpId;
  static const int OTPID = 2;


  approveChannelAndIssueRequestToken_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // otpId
  String get otpId => this._otpId;

  set otpId(String otpId) {
    this._otpId = otpId;
  }

  bool isSetOtpId() => this.otpId != null;

  unsetOtpId() {
    this.otpId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case OTPID:
        return this.otpId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case OTPID:
        if (value == null) {
          unsetOtpId();
        } else {
          this.otpId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case OTPID:
        return isSetOtpId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OTPID:
          if (field.type == TType.STRING) {
            this.otpId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.otpId != null) {
      oprot.writeFieldBegin(_OTP_ID_FIELD_DESC);
      oprot.writeString(this.otpId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("approveChannelAndIssueRequestToken_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("otpId:");
    if (this.otpId == null) {
      ret.write("null");
    } else {
      ret.write(this.otpId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class approveChannelAndIssueRequestToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("approveChannelAndIssueRequestToken_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  approveChannelAndIssueRequestToken_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("approveChannelAndIssueRequestToken_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchNotificationItems_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchNotificationItems_args");
  static final TField _LOCAL_REV_FIELD_DESC = new TField("localRev", TType.I64, 2);

  int _localRev = 0;
  static const int LOCALREV = 2;

  bool __isset_localRev = false;

  fetchNotificationItems_args() {
  }

  // localRev
  int get localRev => this._localRev;

  set localRev(int localRev) {
    this._localRev = localRev;
    this.__isset_localRev = true;
  }

  bool isSetLocalRev() => this.__isset_localRev;

  unsetLocalRev() {
    this.__isset_localRev = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return this.localRev;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALREV:
        if (value == null) {
          unsetLocalRev();
        } else {
          this.localRev = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return isSetLocalRev();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALREV:
          if (field.type == TType.I64) {
            this.localRev = iprot.readI64();
            this.__isset_localRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LOCAL_REV_FIELD_DESC);
    oprot.writeI64(this.localRev);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchNotificationItems_args(");

    ret.write("localRev:");
    ret.write(this.localRev);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class fetchNotificationItems_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("fetchNotificationItems_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  NotificationFetchResult _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  fetchNotificationItems_result() {
  }

  // success
  NotificationFetchResult get success => this._success;

  set success(NotificationFetchResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new NotificationFetchResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("fetchNotificationItems_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getApprovedChannels_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getApprovedChannels_args");
  static final TField _LAST_SYNCED_FIELD_DESC = new TField("lastSynced", TType.I64, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 3);

  int _lastSynced = 0;
  static const int LASTSYNCED = 2;
  String _locale;
  static const int LOCALE = 3;

  bool __isset_lastSynced = false;

  getApprovedChannels_args() {
  }

  // lastSynced
  int get lastSynced => this._lastSynced;

  set lastSynced(int lastSynced) {
    this._lastSynced = lastSynced;
    this.__isset_lastSynced = true;
  }

  bool isSetLastSynced() => this.__isset_lastSynced;

  unsetLastSynced() {
    this.__isset_lastSynced = false;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return this.lastSynced;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTSYNCED:
        if (value == null) {
          unsetLastSynced();
        } else {
          this.lastSynced = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return isSetLastSynced();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTSYNCED:
          if (field.type == TType.I64) {
            this.lastSynced = iprot.readI64();
            this.__isset_lastSynced = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_SYNCED_FIELD_DESC);
    oprot.writeI64(this.lastSynced);
    oprot.writeFieldEnd();
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getApprovedChannels_args(");

    ret.write("lastSynced:");
    ret.write(this.lastSynced);

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getApprovedChannels_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getApprovedChannels_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ApprovedChannelInfos _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getApprovedChannels_result() {
  }

  // success
  ApprovedChannelInfos get success => this._success;

  set success(ApprovedChannelInfos success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ApprovedChannelInfos();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getApprovedChannels_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelInfo_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelInfo_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 3);

  String _channelId;
  static const int CHANNELID = 2;
  String _locale;
  static const int LOCALE = 3;


  getChannelInfo_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelInfo_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelInfo_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelInfo_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelInfo _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getChannelInfo_result() {
  }

  // success
  ChannelInfo get success => this._success;

  set success(ChannelInfo success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelInfo();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelInfo_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelNotificationSetting_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelNotificationSetting_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 2);

  String _channelId;
  static const int CHANNELID = 1;
  String _locale;
  static const int LOCALE = 2;


  getChannelNotificationSetting_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelNotificationSetting_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelNotificationSetting_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelNotificationSetting_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelNotificationSetting _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getChannelNotificationSetting_result() {
  }

  // success
  ChannelNotificationSetting get success => this._success;

  set success(ChannelNotificationSetting success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelNotificationSetting();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelNotificationSetting_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelNotificationSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelNotificationSettings_args");
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 1);

  String _locale;
  static const int LOCALE = 1;


  getChannelNotificationSettings_args() {
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelNotificationSettings_args(");

    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannelNotificationSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannelNotificationSettings_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<ChannelNotificationSetting> _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getChannelNotificationSettings_result() {
  }

  // success
  List<ChannelNotificationSetting> get success => this._success;

  set success(List<ChannelNotificationSetting> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list754 = iprot.readListBegin();
              this.success = new List<ChannelNotificationSetting>();
              for (int _i755 = 0; _i755 < _list754.length; ++_i755) {
                ChannelNotificationSetting _elem756;
                _elem756 = new ChannelNotificationSetting();
                _elem756.read(iprot);
                this.success.add(_elem756);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem757 in this.success) {
          elem757.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannelNotificationSettings_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannels_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannels_args");
  static final TField _LAST_SYNCED_FIELD_DESC = new TField("lastSynced", TType.I64, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 3);

  int _lastSynced = 0;
  static const int LASTSYNCED = 2;
  String _locale;
  static const int LOCALE = 3;

  bool __isset_lastSynced = false;

  getChannels_args() {
  }

  // lastSynced
  int get lastSynced => this._lastSynced;

  set lastSynced(int lastSynced) {
    this._lastSynced = lastSynced;
    this.__isset_lastSynced = true;
  }

  bool isSetLastSynced() => this.__isset_lastSynced;

  unsetLastSynced() {
    this.__isset_lastSynced = false;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return this.lastSynced;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTSYNCED:
        if (value == null) {
          unsetLastSynced();
        } else {
          this.lastSynced = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return isSetLastSynced();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTSYNCED:
          if (field.type == TType.I64) {
            this.lastSynced = iprot.readI64();
            this.__isset_lastSynced = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_SYNCED_FIELD_DESC);
    oprot.writeI64(this.lastSynced);
    oprot.writeFieldEnd();
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannels_args(");

    ret.write("lastSynced:");
    ret.write(this.lastSynced);

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getChannels_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getChannels_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelInfos _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getChannels_result() {
  }

  // success
  ChannelInfos get success => this._success;

  set success(ChannelInfos success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelInfos();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getChannels_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDomains_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDomains_args");
  static final TField _LAST_SYNCED_FIELD_DESC = new TField("lastSynced", TType.I64, 2);

  int _lastSynced = 0;
  static const int LASTSYNCED = 2;

  bool __isset_lastSynced = false;

  getDomains_args() {
  }

  // lastSynced
  int get lastSynced => this._lastSynced;

  set lastSynced(int lastSynced) {
    this._lastSynced = lastSynced;
    this.__isset_lastSynced = true;
  }

  bool isSetLastSynced() => this.__isset_lastSynced;

  unsetLastSynced() {
    this.__isset_lastSynced = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return this.lastSynced;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTSYNCED:
        if (value == null) {
          unsetLastSynced();
        } else {
          this.lastSynced = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return isSetLastSynced();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTSYNCED:
          if (field.type == TType.I64) {
            this.lastSynced = iprot.readI64();
            this.__isset_lastSynced = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_SYNCED_FIELD_DESC);
    oprot.writeI64(this.lastSynced);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDomains_args(");

    ret.write("lastSynced:");
    ret.write(this.lastSynced);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDomains_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDomains_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelDomains _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getDomains_result() {
  }

  // success
  ChannelDomains get success => this._success;

  set success(ChannelDomains success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelDomains();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDomains_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFriendChannelMatrices_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendChannelMatrices_args");
  static final TField _CHANNEL_IDS_FIELD_DESC = new TField("channelIds", TType.LIST, 1);

  List<String> _channelIds;
  static const int CHANNELIDS = 1;


  getFriendChannelMatrices_args() {
  }

  // channelIds
  List<String> get channelIds => this._channelIds;

  set channelIds(List<String> channelIds) {
    this._channelIds = channelIds;
  }

  bool isSetChannelIds() => this.channelIds != null;

  unsetChannelIds() {
    this.channelIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELIDS:
        return this.channelIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELIDS:
        if (value == null) {
          unsetChannelIds();
        } else {
          this.channelIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELIDS:
        return isSetChannelIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELIDS:
          if (field.type == TType.LIST) {
            {
              TList _list758 = iprot.readListBegin();
              this.channelIds = new List<String>();
              for (int _i759 = 0; _i759 < _list758.length; ++_i759) {
                String _elem760;
                _elem760 = iprot.readString();
                this.channelIds.add(_elem760);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelIds != null) {
      oprot.writeFieldBegin(_CHANNEL_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.channelIds.length));
        for (var elem761 in this.channelIds) {
          oprot.writeString(elem761);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendChannelMatrices_args(");

    ret.write("channelIds:");
    if (this.channelIds == null) {
      ret.write("null");
    } else {
      ret.write(this.channelIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFriendChannelMatrices_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendChannelMatrices_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  FriendChannelMatricesResponse _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getFriendChannelMatrices_result() {
  }

  // success
  FriendChannelMatricesResponse get success => this._success;

  set success(FriendChannelMatricesResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new FriendChannelMatricesResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendChannelMatrices_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateChannelSettings_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateChannelSettings_args");
  static final TField _CHANNEL_SETTINGS_FIELD_DESC = new TField("channelSettings", TType.STRUCT, 1);

  ChannelSettings _channelSettings;
  static const int CHANNELSETTINGS = 1;


  updateChannelSettings_args() {
  }

  // channelSettings
  ChannelSettings get channelSettings => this._channelSettings;

  set channelSettings(ChannelSettings channelSettings) {
    this._channelSettings = channelSettings;
  }

  bool isSetChannelSettings() => this.channelSettings != null;

  unsetChannelSettings() {
    this.channelSettings = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELSETTINGS:
        return this.channelSettings;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELSETTINGS:
        if (value == null) {
          unsetChannelSettings();
        } else {
          this.channelSettings = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELSETTINGS:
        return isSetChannelSettings();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELSETTINGS:
          if (field.type == TType.STRUCT) {
            this.channelSettings = new ChannelSettings();
            this.channelSettings.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelSettings != null) {
      oprot.writeFieldBegin(_CHANNEL_SETTINGS_FIELD_DESC);
      this.channelSettings.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateChannelSettings_args(");

    ret.write("channelSettings:");
    if (this.channelSettings == null) {
      ret.write("null");
    } else {
      ret.write(this.channelSettings);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateChannelSettings_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateChannelSettings_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;

  bool __isset_success = false;

  updateChannelSettings_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateChannelSettings_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCommonDomains_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCommonDomains_args");
  static final TField _LAST_SYNCED_FIELD_DESC = new TField("lastSynced", TType.I64, 1);

  int _lastSynced = 0;
  static const int LASTSYNCED = 1;

  bool __isset_lastSynced = false;

  getCommonDomains_args() {
  }

  // lastSynced
  int get lastSynced => this._lastSynced;

  set lastSynced(int lastSynced) {
    this._lastSynced = lastSynced;
    this.__isset_lastSynced = true;
  }

  bool isSetLastSynced() => this.__isset_lastSynced;

  unsetLastSynced() {
    this.__isset_lastSynced = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return this.lastSynced;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTSYNCED:
        if (value == null) {
          unsetLastSynced();
        } else {
          this.lastSynced = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return isSetLastSynced();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTSYNCED:
          if (field.type == TType.I64) {
            this.lastSynced = iprot.readI64();
            this.__isset_lastSynced = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_SYNCED_FIELD_DESC);
    oprot.writeI64(this.lastSynced);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCommonDomains_args(");

    ret.write("lastSynced:");
    ret.write(this.lastSynced);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCommonDomains_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCommonDomains_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelDomains _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getCommonDomains_result() {
  }

  // success
  ChannelDomains get success => this._success;

  set success(ChannelDomains success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelDomains();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCommonDomains_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNotificationBadgeCount_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNotificationBadgeCount_args");
  static final TField _LOCAL_REV_FIELD_DESC = new TField("localRev", TType.I64, 2);

  int _localRev = 0;
  static const int LOCALREV = 2;

  bool __isset_localRev = false;

  getNotificationBadgeCount_args() {
  }

  // localRev
  int get localRev => this._localRev;

  set localRev(int localRev) {
    this._localRev = localRev;
    this.__isset_localRev = true;
  }

  bool isSetLocalRev() => this.__isset_localRev;

  unsetLocalRev() {
    this.__isset_localRev = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return this.localRev;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LOCALREV:
        if (value == null) {
          unsetLocalRev();
        } else {
          this.localRev = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LOCALREV:
        return isSetLocalRev();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LOCALREV:
          if (field.type == TType.I64) {
            this.localRev = iprot.readI64();
            this.__isset_localRev = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LOCAL_REV_FIELD_DESC);
    oprot.writeI64(this.localRev);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNotificationBadgeCount_args(");

    ret.write("localRev:");
    ret.write(this.localRev);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNotificationBadgeCount_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getNotificationBadgeCount_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;

  bool __isset_success = false;

  getNotificationBadgeCount_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getNotificationBadgeCount_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueChannelToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueChannelToken_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);

  String _channelId;
  static const int CHANNELID = 1;


  issueChannelToken_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueChannelToken_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueChannelToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueChannelToken_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelToken _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  issueChannelToken_result() {
  }

  // success
  ChannelToken get success => this._success;

  set success(ChannelToken success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelToken();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueChannelToken_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestToken_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestToken_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);
  static final TField _OTP_ID_FIELD_DESC = new TField("otpId", TType.STRING, 2);

  String _channelId;
  static const int CHANNELID = 1;
  String _otpId;
  static const int OTPID = 2;


  issueRequestToken_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // otpId
  String get otpId => this._otpId;

  set otpId(String otpId) {
    this._otpId = otpId;
  }

  bool isSetOtpId() => this.otpId != null;

  unsetOtpId() {
    this.otpId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case OTPID:
        return this.otpId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case OTPID:
        if (value == null) {
          unsetOtpId();
        } else {
          this.otpId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case OTPID:
        return isSetOtpId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OTPID:
          if (field.type == TType.STRING) {
            this.otpId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.otpId != null) {
      oprot.writeFieldBegin(_OTP_ID_FIELD_DESC);
      oprot.writeString(this.otpId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestToken_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("otpId:");
    if (this.otpId == null) {
      ret.write("null");
    } else {
      ret.write(this.otpId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestToken_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestToken_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  issueRequestToken_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestToken_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestTokenWithAuthScheme_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestTokenWithAuthScheme_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);
  static final TField _OTP_ID_FIELD_DESC = new TField("otpId", TType.STRING, 2);
  static final TField _AUTH_SCHEME_FIELD_DESC = new TField("authScheme", TType.LIST, 3);
  static final TField _RETURN_URL_FIELD_DESC = new TField("returnUrl", TType.STRING, 4);

  String _channelId;
  static const int CHANNELID = 1;
  String _otpId;
  static const int OTPID = 2;
  List<String> _authScheme;
  static const int AUTHSCHEME = 3;
  String _returnUrl;
  static const int RETURNURL = 4;


  issueRequestTokenWithAuthScheme_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // otpId
  String get otpId => this._otpId;

  set otpId(String otpId) {
    this._otpId = otpId;
  }

  bool isSetOtpId() => this.otpId != null;

  unsetOtpId() {
    this.otpId = null;
  }

  // authScheme
  List<String> get authScheme => this._authScheme;

  set authScheme(List<String> authScheme) {
    this._authScheme = authScheme;
  }

  bool isSetAuthScheme() => this.authScheme != null;

  unsetAuthScheme() {
    this.authScheme = null;
  }

  // returnUrl
  String get returnUrl => this._returnUrl;

  set returnUrl(String returnUrl) {
    this._returnUrl = returnUrl;
  }

  bool isSetReturnUrl() => this.returnUrl != null;

  unsetReturnUrl() {
    this.returnUrl = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case OTPID:
        return this.otpId;
      case AUTHSCHEME:
        return this.authScheme;
      case RETURNURL:
        return this.returnUrl;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case OTPID:
        if (value == null) {
          unsetOtpId();
        } else {
          this.otpId = value;
        }
        break;

      case AUTHSCHEME:
        if (value == null) {
          unsetAuthScheme();
        } else {
          this.authScheme = value;
        }
        break;

      case RETURNURL:
        if (value == null) {
          unsetReturnUrl();
        } else {
          this.returnUrl = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case OTPID:
        return isSetOtpId();
      case AUTHSCHEME:
        return isSetAuthScheme();
      case RETURNURL:
        return isSetReturnUrl();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OTPID:
          if (field.type == TType.STRING) {
            this.otpId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AUTHSCHEME:
          if (field.type == TType.LIST) {
            {
              TList _list762 = iprot.readListBegin();
              this.authScheme = new List<String>();
              for (int _i763 = 0; _i763 < _list762.length; ++_i763) {
                String _elem764;
                _elem764 = iprot.readString();
                this.authScheme.add(_elem764);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RETURNURL:
          if (field.type == TType.STRING) {
            this.returnUrl = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.otpId != null) {
      oprot.writeFieldBegin(_OTP_ID_FIELD_DESC);
      oprot.writeString(this.otpId);
      oprot.writeFieldEnd();
    }
    if (this.authScheme != null) {
      oprot.writeFieldBegin(_AUTH_SCHEME_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.authScheme.length));
        for (var elem765 in this.authScheme) {
          oprot.writeString(elem765);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.returnUrl != null) {
      oprot.writeFieldBegin(_RETURN_URL_FIELD_DESC);
      oprot.writeString(this.returnUrl);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestTokenWithAuthScheme_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("otpId:");
    if (this.otpId == null) {
      ret.write("null");
    } else {
      ret.write(this.otpId);
    }

    ret.write(", ");
    ret.write("authScheme:");
    if (this.authScheme == null) {
      ret.write("null");
    } else {
      ret.write(this.authScheme);
    }

    ret.write(", ");
    ret.write("returnUrl:");
    if (this.returnUrl == null) {
      ret.write("null");
    } else {
      ret.write(this.returnUrl);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestTokenWithAuthScheme_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestTokenWithAuthScheme_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  RequestTokenResponse _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  issueRequestTokenWithAuthScheme_result() {
  }

  // success
  RequestTokenResponse get success => this._success;

  set success(RequestTokenResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RequestTokenResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestTokenWithAuthScheme_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestTokenForAutoLogin_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestTokenForAutoLogin_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 2);
  static final TField _OTP_ID_FIELD_DESC = new TField("otpId", TType.STRING, 3);
  static final TField _REDIRECT_URL_FIELD_DESC = new TField("redirectUrl", TType.STRING, 4);

  String _channelId;
  static const int CHANNELID = 2;
  String _otpId;
  static const int OTPID = 3;
  String _redirectUrl;
  static const int REDIRECTURL = 4;


  issueRequestTokenForAutoLogin_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  // otpId
  String get otpId => this._otpId;

  set otpId(String otpId) {
    this._otpId = otpId;
  }

  bool isSetOtpId() => this.otpId != null;

  unsetOtpId() {
    this.otpId = null;
  }

  // redirectUrl
  String get redirectUrl => this._redirectUrl;

  set redirectUrl(String redirectUrl) {
    this._redirectUrl = redirectUrl;
  }

  bool isSetRedirectUrl() => this.redirectUrl != null;

  unsetRedirectUrl() {
    this.redirectUrl = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      case OTPID:
        return this.otpId;
      case REDIRECTURL:
        return this.redirectUrl;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      case OTPID:
        if (value == null) {
          unsetOtpId();
        } else {
          this.otpId = value;
        }
        break;

      case REDIRECTURL:
        if (value == null) {
          unsetRedirectUrl();
        } else {
          this.redirectUrl = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      case OTPID:
        return isSetOtpId();
      case REDIRECTURL:
        return isSetRedirectUrl();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OTPID:
          if (field.type == TType.STRING) {
            this.otpId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REDIRECTURL:
          if (field.type == TType.STRING) {
            this.redirectUrl = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    if (this.otpId != null) {
      oprot.writeFieldBegin(_OTP_ID_FIELD_DESC);
      oprot.writeString(this.otpId);
      oprot.writeFieldEnd();
    }
    if (this.redirectUrl != null) {
      oprot.writeFieldBegin(_REDIRECT_URL_FIELD_DESC);
      oprot.writeString(this.redirectUrl);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestTokenForAutoLogin_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(", ");
    ret.write("otpId:");
    if (this.otpId == null) {
      ret.write("null");
    } else {
      ret.write(this.otpId);
    }

    ret.write(", ");
    ret.write("redirectUrl:");
    if (this.redirectUrl == null) {
      ret.write("null");
    } else {
      ret.write(this.redirectUrl);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class issueRequestTokenForAutoLogin_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("issueRequestTokenForAutoLogin_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  issueRequestTokenForAutoLogin_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("issueRequestTokenForAutoLogin_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUpdatedChannelIds_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUpdatedChannelIds_args");
  static final TField _CHANNEL_IDS_FIELD_DESC = new TField("channelIds", TType.LIST, 1);

  List<ChannelIdWithLastUpdated> _channelIds;
  static const int CHANNELIDS = 1;


  getUpdatedChannelIds_args() {
  }

  // channelIds
  List<ChannelIdWithLastUpdated> get channelIds => this._channelIds;

  set channelIds(List<ChannelIdWithLastUpdated> channelIds) {
    this._channelIds = channelIds;
  }

  bool isSetChannelIds() => this.channelIds != null;

  unsetChannelIds() {
    this.channelIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELIDS:
        return this.channelIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELIDS:
        if (value == null) {
          unsetChannelIds();
        } else {
          this.channelIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELIDS:
        return isSetChannelIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELIDS:
          if (field.type == TType.LIST) {
            {
              TList _list766 = iprot.readListBegin();
              this.channelIds = new List<ChannelIdWithLastUpdated>();
              for (int _i767 = 0; _i767 < _list766.length; ++_i767) {
                ChannelIdWithLastUpdated _elem768;
                _elem768 = new ChannelIdWithLastUpdated();
                _elem768.read(iprot);
                this.channelIds.add(_elem768);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelIds != null) {
      oprot.writeFieldBegin(_CHANNEL_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.channelIds.length));
        for (var elem769 in this.channelIds) {
          elem769.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUpdatedChannelIds_args(");

    ret.write("channelIds:");
    if (this.channelIds == null) {
      ret.write("null");
    } else {
      ret.write(this.channelIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUpdatedChannelIds_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUpdatedChannelIds_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  getUpdatedChannelIds_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list770 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i771 = 0; _i771 < _list770.length; ++_i771) {
                String _elem772;
                _elem772 = iprot.readString();
                this.success.add(_elem772);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem773 in this.success) {
          oprot.writeString(elem773);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUpdatedChannelIds_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCoinUse_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCoinUse_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 3);

  CoinUseReservation _request;
  static const int REQUEST = 2;
  String _locale;
  static const int LOCALE = 3;


  reserveCoinUse_args() {
  }

  // request
  CoinUseReservation get request => this._request;

  set request(CoinUseReservation request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinUseReservation();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCoinUse_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCoinUse_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCoinUse_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  reserveCoinUse_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCoinUse_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class revokeChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("revokeChannel_args");
  static final TField _CHANNEL_ID_FIELD_DESC = new TField("channelId", TType.STRING, 1);

  String _channelId;
  static const int CHANNELID = 1;


  revokeChannel_args() {
  }

  // channelId
  String get channelId => this._channelId;

  set channelId(String channelId) {
    this._channelId = channelId;
  }

  bool isSetChannelId() => this.channelId != null;

  unsetChannelId() {
    this.channelId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return this.channelId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHANNELID:
        if (value == null) {
          unsetChannelId();
        } else {
          this.channelId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHANNELID:
        return isSetChannelId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHANNELID:
          if (field.type == TType.STRING) {
            this.channelId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.channelId != null) {
      oprot.writeFieldBegin(_CHANNEL_ID_FIELD_DESC);
      oprot.writeString(this.channelId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("revokeChannel_args(");

    ret.write("channelId:");
    if (this.channelId == null) {
      ret.write("null");
    } else {
      ret.write(this.channelId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class revokeChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("revokeChannel_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelException _e;
  static const int E = 1;


  revokeChannel_result() {
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("revokeChannel_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncChannelData_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncChannelData_args");
  static final TField _LAST_SYNCED_FIELD_DESC = new TField("lastSynced", TType.I64, 2);
  static final TField _LOCALE_FIELD_DESC = new TField("locale", TType.STRING, 3);

  int _lastSynced = 0;
  static const int LASTSYNCED = 2;
  String _locale;
  static const int LOCALE = 3;

  bool __isset_lastSynced = false;

  syncChannelData_args() {
  }

  // lastSynced
  int get lastSynced => this._lastSynced;

  set lastSynced(int lastSynced) {
    this._lastSynced = lastSynced;
    this.__isset_lastSynced = true;
  }

  bool isSetLastSynced() => this.__isset_lastSynced;

  unsetLastSynced() {
    this.__isset_lastSynced = false;
  }

  // locale
  String get locale => this._locale;

  set locale(String locale) {
    this._locale = locale;
  }

  bool isSetLocale() => this.locale != null;

  unsetLocale() {
    this.locale = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return this.lastSynced;
      case LOCALE:
        return this.locale;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTSYNCED:
        if (value == null) {
          unsetLastSynced();
        } else {
          this.lastSynced = value;
        }
        break;

      case LOCALE:
        if (value == null) {
          unsetLocale();
        } else {
          this.locale = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTSYNCED:
        return isSetLastSynced();
      case LOCALE:
        return isSetLocale();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTSYNCED:
          if (field.type == TType.I64) {
            this.lastSynced = iprot.readI64();
            this.__isset_lastSynced = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_SYNCED_FIELD_DESC);
    oprot.writeI64(this.lastSynced);
    oprot.writeFieldEnd();
    if (this.locale != null) {
      oprot.writeFieldBegin(_LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncChannelData_args(");

    ret.write("lastSynced:");
    ret.write(this.lastSynced);

    ret.write(", ");
    ret.write("locale:");
    if (this.locale == null) {
      ret.write("null");
    } else {
      ret.write(this.locale);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class syncChannelData_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("syncChannelData_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelSyncDatas _success;
  static const int SUCCESS = 0;
  ChannelException _e;
  static const int E = 1;


  syncChannelData_result() {
  }

  // success
  ChannelSyncDatas get success => this._success;

  set success(ChannelSyncDatas success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ChannelSyncDatas();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("syncChannelData_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateChannelNotificationSetting_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateChannelNotificationSetting_args");
  static final TField _SETTING_FIELD_DESC = new TField("setting", TType.LIST, 1);

  List<ChannelNotificationSetting> _setting;
  static const int SETTING = 1;


  updateChannelNotificationSetting_args() {
  }

  // setting
  List<ChannelNotificationSetting> get setting => this._setting;

  set setting(List<ChannelNotificationSetting> setting) {
    this._setting = setting;
  }

  bool isSetSetting() => this.setting != null;

  unsetSetting() {
    this.setting = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SETTING:
        return this.setting;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SETTING:
        if (value == null) {
          unsetSetting();
        } else {
          this.setting = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SETTING:
        return isSetSetting();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SETTING:
          if (field.type == TType.LIST) {
            {
              TList _list774 = iprot.readListBegin();
              this.setting = new List<ChannelNotificationSetting>();
              for (int _i775 = 0; _i775 < _list774.length; ++_i775) {
                ChannelNotificationSetting _elem776;
                _elem776 = new ChannelNotificationSetting();
                _elem776.read(iprot);
                this.setting.add(_elem776);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.setting != null) {
      oprot.writeFieldBegin(_SETTING_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.setting.length));
        for (var elem777 in this.setting) {
          elem777.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateChannelNotificationSetting_args(");

    ret.write("setting:");
    if (this.setting == null) {
      ret.write("null");
    } else {
      ret.write(this.setting);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateChannelNotificationSetting_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateChannelNotificationSetting_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ChannelException _e;
  static const int E = 1;


  updateChannelNotificationSetting_result() {
  }

  // e
  ChannelException get e => this._e;

  set e(ChannelException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new ChannelException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateChannelNotificationSetting_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

