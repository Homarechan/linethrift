/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library line.src.call_service;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart';
import 'package:line/line.dart';


abstract class CallService {

  Future<int> getUserStatus(String mid);

  Future updateProfileAttributeForChannel(int profileAttribute, String value);

  Future updateExtendedProfileAttribute(int attr, ExtendedProfile extendedProfile);

  Future<List<SimpleChannelContact>> getAllSimpleChannelContacts(bool statusSticonFallbackDisabled);

  Future<Map<int, String>> getUserIdentities();

  Future<PaidCallDialing> markPaidCallAd(String dialedNumber, String language, bool disableCallerId);

  Future<bool> isGroupMember(String groupId);

  Future<PhoneInfoForChannel> getPhoneInfoFromPhoneNumber(String region, String phoneNumber);

  Future<PaidCallRedeemResult> redeemPaidCallVoucher(String serial, String language);

  Future<Map<String, String>> getPreferredDisplayName(List<String> mids);

  Future<List<Contact>> getContactsForChannel(List<String> ids);

  Future<List<CoinProductItem>> getCallCreditProducts(int appStoreCode, int pgCode, String country, String language);

  Future<List<CompactContact>> getCompactContacts(int lastModifiedTimestamp);

  Future notifyNotiCenterEvent(NotiCenterEventData event);

  Future<bool> isInContact(String mid);

  Future<List<SimpleChannelContact>> lookupGroupMembers(String groupId, List<String> mids);

  Future<Room> getRoomInformation(String roomMid);

  Future<GroupCall> getGroupCall(String chatMid);

  Future<bool> isAllowSecondaryDeviceLogin();

  Future<SimpleChannelClient> getPrimaryClientForChannel();

  Future<Room> createRoomWithBuddy(int reqSeq, String buddyMid, List<String> contactIds);

  Future<String> getDisplayName(String mid);

  Future<PaidCallMetadataResult> getPaidCallMetadata(String language);

  Future<String> getMid();

  Future<String> getUserCountryForBilling(String country, String remoteIp);

  Future<List<String>> getFavoriteGroupIdsForChannel();

  Future<PaidCallHistoryResult> getPaidCallHistory(int start, int size, String language);

  Future sendPinCodeOperation(String verifier);

  Future inviteIntoGroupCall(String chatMid, List<String> memberMids, int mediaType);

  Future<List<String>> getFriendMids();

  Future<MetaProfile> getMetaProfile();

  Future<Message> sendMessageForChannel(Message message);

  Future<int> activeBuddySubscriberCount();

  Future<CoinHistoryResult> getCallCreditPurchaseHistory(CoinHistoryCondition request);

  Future<bool> isRoomMember(String roomId);

  Future<Message> sendSystemOAMessage(Message message);

  Future<PaidCallResponse> acquirePaidCallRoute(int paidCallType, String dialedNumber, String language, String networkCode, bool disableCallerId, String referer, String adSessionId);

  Future<List<Group>> getGroupsForChannel(List<String> groupIds);

  Future<int> getUserCreateTime();

  Future<String> registerChannelCP(String cpId, String registerPassword);

  Future<PaymentReservationResult> reserveCallCreditPurchase(CoinPurchaseReservation request);

  Future<List<PaidCallCurrencyExchangeRate>> acquirePaidCallCurrencyExchangeRate(String language);

  Future<List<String>> getRoomMemberMidsForAppPlatform(String roomId);

  Future<List<PaidCallBalance>> getPaidCallBalanceList(String language);

  Future<Map<int, String>> getPersonalInfos(Set<int> requiredPersonalInfos);

  Future<List<SimpleChannelClient>> getPrimaryClientsForChannel(List<String> userMids);

  Future<ContactTransition> addBuddyToContact(String buddyMid);

  Future<List<String>> getGroupMemberMidsForAppPlatform(String groupId);

  Future<String> getUserLanguage();

  Future<PaidCallResponse> lookupPaidCall(String dialedNumber, String language, String referer);

  Future<ExtendedProfile> getExtendedProfile();

  Future<Map<String, CompactContact>> getReverseCompactContacts(List<String> ids);

  Future<PaidCallAdResult> getPaidCallAdStatus();

  Future<Contact> findContactByUseridWithoutAbuseBlockForChannel(String userid);

  Future<List<String>> getGroupMemberMids(String groupId);

  Future<Message> sendMessageWithoutRelationship(Message message);

  Future<Map<String, int>> displayBuddySubscriberCountInBulk(List<String> mids);

  Future<List<SimpleChannelContact>> lookupRoomMembers(String roomId, List<String> mids);

  Future<List<String>> getFavoriteMidsForChannel();

  Future<List<String>> getAllContactIdsForChannel();

  Future<int> displayBuddySubscriberCount();

  Future<Profile> getProfileForChannel();

  Future<List<UserTicketResponse>> getUserTickets(List<String> userMids);

  Future<List<String>> getOAFriendMids();

  Future<List<PaidCallUserRate>> searchPaidCallUserRate(String countryCode, String language);

  Future<List<String>> getJoinedGroupIdsForChannel();

  Future<GroupCallRoute> acquireGroupCallRoute(String chatMid, int mediaType);

  Future<List<String>> getUserMidsWhoAddedMe();

  Future<IdentityCredential> getIdentityCredential();

  Future addOperationForChannel(int opType, String param1, String param2, String param3);

  Future<List<SimpleChannelContact>> getSimpleChannelContacts(List<String> ids, bool statusSticonFallbackDisabled);

  Future<int> getUserLastSentMessageTimeStamp(String mid);
}

class CallServiceClient implements CallService {

  CallServiceClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<int> getUserStatus(String mid) async {
    oprot.writeMessageBegin(new TMessage("getUserStatus", TMessageType.CALL, nextSeqid()));
    getUserStatus_args args = new getUserStatus_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserStatus_result result = new getUserStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserStatus failed: unknown result");
  }

  Future updateProfileAttributeForChannel(int profileAttribute, String value) async {
    oprot.writeMessageBegin(new TMessage("updateProfileAttributeForChannel", TMessageType.CALL, nextSeqid()));
    updateProfileAttributeForChannel_args args = new updateProfileAttributeForChannel_args();
    args.profileAttribute = profileAttribute;
    args.value = value;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateProfileAttributeForChannel_result result = new updateProfileAttributeForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future updateExtendedProfileAttribute(int attr, ExtendedProfile extendedProfile) async {
    oprot.writeMessageBegin(new TMessage("updateExtendedProfileAttribute", TMessageType.CALL, nextSeqid()));
    updateExtendedProfileAttribute_args args = new updateExtendedProfileAttribute_args();
    args.attr = attr;
    args.extendedProfile = extendedProfile;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateExtendedProfileAttribute_result result = new updateExtendedProfileAttribute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<SimpleChannelContact>> getAllSimpleChannelContacts(bool statusSticonFallbackDisabled) async {
    oprot.writeMessageBegin(new TMessage("getAllSimpleChannelContacts", TMessageType.CALL, nextSeqid()));
    getAllSimpleChannelContacts_args args = new getAllSimpleChannelContacts_args();
    args.statusSticonFallbackDisabled = statusSticonFallbackDisabled;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAllSimpleChannelContacts_result result = new getAllSimpleChannelContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAllSimpleChannelContacts failed: unknown result");
  }

  Future<Map<int, String>> getUserIdentities() async {
    oprot.writeMessageBegin(new TMessage("getUserIdentities", TMessageType.CALL, nextSeqid()));
    getUserIdentities_args args = new getUserIdentities_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserIdentities_result result = new getUserIdentities_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserIdentities failed: unknown result");
  }

  Future<PaidCallDialing> markPaidCallAd(String dialedNumber, String language, bool disableCallerId) async {
    oprot.writeMessageBegin(new TMessage("markPaidCallAd", TMessageType.CALL, nextSeqid()));
    markPaidCallAd_args args = new markPaidCallAd_args();
    args.dialedNumber = dialedNumber;
    args.language = language;
    args.disableCallerId = disableCallerId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    markPaidCallAd_result result = new markPaidCallAd_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "markPaidCallAd failed: unknown result");
  }

  Future<bool> isGroupMember(String groupId) async {
    oprot.writeMessageBegin(new TMessage("isGroupMember", TMessageType.CALL, nextSeqid()));
    isGroupMember_args args = new isGroupMember_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isGroupMember_result result = new isGroupMember_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isGroupMember failed: unknown result");
  }

  Future<PhoneInfoForChannel> getPhoneInfoFromPhoneNumber(String region, String phoneNumber) async {
    oprot.writeMessageBegin(new TMessage("getPhoneInfoFromPhoneNumber", TMessageType.CALL, nextSeqid()));
    getPhoneInfoFromPhoneNumber_args args = new getPhoneInfoFromPhoneNumber_args();
    args.region = region;
    args.phoneNumber = phoneNumber;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPhoneInfoFromPhoneNumber_result result = new getPhoneInfoFromPhoneNumber_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPhoneInfoFromPhoneNumber failed: unknown result");
  }

  Future<PaidCallRedeemResult> redeemPaidCallVoucher(String serial, String language) async {
    oprot.writeMessageBegin(new TMessage("redeemPaidCallVoucher", TMessageType.CALL, nextSeqid()));
    redeemPaidCallVoucher_args args = new redeemPaidCallVoucher_args();
    args.serial = serial;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    redeemPaidCallVoucher_result result = new redeemPaidCallVoucher_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "redeemPaidCallVoucher failed: unknown result");
  }

  Future<Map<String, String>> getPreferredDisplayName(List<String> mids) async {
    oprot.writeMessageBegin(new TMessage("getPreferredDisplayName", TMessageType.CALL, nextSeqid()));
    getPreferredDisplayName_args args = new getPreferredDisplayName_args();
    args.mids = mids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPreferredDisplayName_result result = new getPreferredDisplayName_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPreferredDisplayName failed: unknown result");
  }

  Future<List<Contact>> getContactsForChannel(List<String> ids) async {
    oprot.writeMessageBegin(new TMessage("getContactsForChannel", TMessageType.CALL, nextSeqid()));
    getContactsForChannel_args args = new getContactsForChannel_args();
    args.ids = ids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getContactsForChannel_result result = new getContactsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getContactsForChannel failed: unknown result");
  }

  Future<List<CoinProductItem>> getCallCreditProducts(int appStoreCode, int pgCode, String country, String language) async {
    oprot.writeMessageBegin(new TMessage("getCallCreditProducts", TMessageType.CALL, nextSeqid()));
    getCallCreditProducts_args args = new getCallCreditProducts_args();
    args.appStoreCode = appStoreCode;
    args.pgCode = pgCode;
    args.country = country;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCallCreditProducts_result result = new getCallCreditProducts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCallCreditProducts failed: unknown result");
  }

  Future<List<CompactContact>> getCompactContacts(int lastModifiedTimestamp) async {
    oprot.writeMessageBegin(new TMessage("getCompactContacts", TMessageType.CALL, nextSeqid()));
    getCompactContacts_args args = new getCompactContacts_args();
    args.lastModifiedTimestamp = lastModifiedTimestamp;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCompactContacts_result result = new getCompactContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCompactContacts failed: unknown result");
  }

  Future notifyNotiCenterEvent(NotiCenterEventData event) async {
    oprot.writeMessageBegin(new TMessage("notifyNotiCenterEvent", TMessageType.CALL, nextSeqid()));
    notifyNotiCenterEvent_args args = new notifyNotiCenterEvent_args();
    args.event = event;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    notifyNotiCenterEvent_result result = new notifyNotiCenterEvent_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<bool> isInContact(String mid) async {
    oprot.writeMessageBegin(new TMessage("isInContact", TMessageType.CALL, nextSeqid()));
    isInContact_args args = new isInContact_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isInContact_result result = new isInContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isInContact failed: unknown result");
  }

  Future<List<SimpleChannelContact>> lookupGroupMembers(String groupId, List<String> mids) async {
    oprot.writeMessageBegin(new TMessage("lookupGroupMembers", TMessageType.CALL, nextSeqid()));
    lookupGroupMembers_args args = new lookupGroupMembers_args();
    args.groupId = groupId;
    args.mids = mids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    lookupGroupMembers_result result = new lookupGroupMembers_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "lookupGroupMembers failed: unknown result");
  }

  Future<Room> getRoomInformation(String roomMid) async {
    oprot.writeMessageBegin(new TMessage("getRoomInformation", TMessageType.CALL, nextSeqid()));
    getRoomInformation_args args = new getRoomInformation_args();
    args.roomMid = roomMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRoomInformation_result result = new getRoomInformation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRoomInformation failed: unknown result");
  }

  Future<GroupCall> getGroupCall(String chatMid) async {
    oprot.writeMessageBegin(new TMessage("getGroupCall", TMessageType.CALL, nextSeqid()));
    getGroupCall_args args = new getGroupCall_args();
    args.chatMid = chatMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupCall_result result = new getGroupCall_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupCall failed: unknown result");
  }

  Future<bool> isAllowSecondaryDeviceLogin() async {
    oprot.writeMessageBegin(new TMessage("isAllowSecondaryDeviceLogin", TMessageType.CALL, nextSeqid()));
    isAllowSecondaryDeviceLogin_args args = new isAllowSecondaryDeviceLogin_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isAllowSecondaryDeviceLogin_result result = new isAllowSecondaryDeviceLogin_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isAllowSecondaryDeviceLogin failed: unknown result");
  }

  Future<SimpleChannelClient> getPrimaryClientForChannel() async {
    oprot.writeMessageBegin(new TMessage("getPrimaryClientForChannel", TMessageType.CALL, nextSeqid()));
    getPrimaryClientForChannel_args args = new getPrimaryClientForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPrimaryClientForChannel_result result = new getPrimaryClientForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPrimaryClientForChannel failed: unknown result");
  }

  Future<Room> createRoomWithBuddy(int reqSeq, String buddyMid, List<String> contactIds) async {
    oprot.writeMessageBegin(new TMessage("createRoomWithBuddy", TMessageType.CALL, nextSeqid()));
    createRoomWithBuddy_args args = new createRoomWithBuddy_args();
    args.reqSeq = reqSeq;
    args.buddyMid = buddyMid;
    args.contactIds = contactIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createRoomWithBuddy_result result = new createRoomWithBuddy_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "createRoomWithBuddy failed: unknown result");
  }

  Future<String> getDisplayName(String mid) async {
    oprot.writeMessageBegin(new TMessage("getDisplayName", TMessageType.CALL, nextSeqid()));
    getDisplayName_args args = new getDisplayName_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getDisplayName_result result = new getDisplayName_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getDisplayName failed: unknown result");
  }

  Future<PaidCallMetadataResult> getPaidCallMetadata(String language) async {
    oprot.writeMessageBegin(new TMessage("getPaidCallMetadata", TMessageType.CALL, nextSeqid()));
    getPaidCallMetadata_args args = new getPaidCallMetadata_args();
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPaidCallMetadata_result result = new getPaidCallMetadata_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPaidCallMetadata failed: unknown result");
  }

  Future<String> getMid() async {
    oprot.writeMessageBegin(new TMessage("getMid", TMessageType.CALL, nextSeqid()));
    getMid_args args = new getMid_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMid_result result = new getMid_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMid failed: unknown result");
  }

  Future<String> getUserCountryForBilling(String country, String remoteIp) async {
    oprot.writeMessageBegin(new TMessage("getUserCountryForBilling", TMessageType.CALL, nextSeqid()));
    getUserCountryForBilling_args args = new getUserCountryForBilling_args();
    args.country = country;
    args.remoteIp = remoteIp;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserCountryForBilling_result result = new getUserCountryForBilling_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserCountryForBilling failed: unknown result");
  }

  Future<List<String>> getFavoriteGroupIdsForChannel() async {
    oprot.writeMessageBegin(new TMessage("getFavoriteGroupIdsForChannel", TMessageType.CALL, nextSeqid()));
    getFavoriteGroupIdsForChannel_args args = new getFavoriteGroupIdsForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFavoriteGroupIdsForChannel_result result = new getFavoriteGroupIdsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFavoriteGroupIdsForChannel failed: unknown result");
  }

  Future<PaidCallHistoryResult> getPaidCallHistory(int start, int size, String language) async {
    oprot.writeMessageBegin(new TMessage("getPaidCallHistory", TMessageType.CALL, nextSeqid()));
    getPaidCallHistory_args args = new getPaidCallHistory_args();
    args.start = start;
    args.size = size;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPaidCallHistory_result result = new getPaidCallHistory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPaidCallHistory failed: unknown result");
  }

  Future sendPinCodeOperation(String verifier) async {
    oprot.writeMessageBegin(new TMessage("sendPinCodeOperation", TMessageType.CALL, nextSeqid()));
    sendPinCodeOperation_args args = new sendPinCodeOperation_args();
    args.verifier = verifier;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendPinCodeOperation_result result = new sendPinCodeOperation_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future inviteIntoGroupCall(String chatMid, List<String> memberMids, int mediaType) async {
    oprot.writeMessageBegin(new TMessage("inviteIntoGroupCall", TMessageType.CALL, nextSeqid()));
    inviteIntoGroupCall_args args = new inviteIntoGroupCall_args();
    args.chatMid = chatMid;
    args.memberMids = memberMids;
    args.mediaType = mediaType;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    inviteIntoGroupCall_result result = new inviteIntoGroupCall_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<String>> getFriendMids() async {
    oprot.writeMessageBegin(new TMessage("getFriendMids", TMessageType.CALL, nextSeqid()));
    getFriendMids_args args = new getFriendMids_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFriendMids_result result = new getFriendMids_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFriendMids failed: unknown result");
  }

  Future<MetaProfile> getMetaProfile() async {
    oprot.writeMessageBegin(new TMessage("getMetaProfile", TMessageType.CALL, nextSeqid()));
    getMetaProfile_args args = new getMetaProfile_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMetaProfile_result result = new getMetaProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getMetaProfile failed: unknown result");
  }

  Future<Message> sendMessageForChannel(Message message) async {
    oprot.writeMessageBegin(new TMessage("sendMessageForChannel", TMessageType.CALL, nextSeqid()));
    sendMessageForChannel_args args = new sendMessageForChannel_args();
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageForChannel_result result = new sendMessageForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendMessageForChannel failed: unknown result");
  }

  Future<int> activeBuddySubscriberCount() async {
    oprot.writeMessageBegin(new TMessage("activeBuddySubscriberCount", TMessageType.CALL, nextSeqid()));
    activeBuddySubscriberCount_args args = new activeBuddySubscriberCount_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    activeBuddySubscriberCount_result result = new activeBuddySubscriberCount_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "activeBuddySubscriberCount failed: unknown result");
  }

  Future<CoinHistoryResult> getCallCreditPurchaseHistory(CoinHistoryCondition request) async {
    oprot.writeMessageBegin(new TMessage("getCallCreditPurchaseHistory", TMessageType.CALL, nextSeqid()));
    getCallCreditPurchaseHistory_args args = new getCallCreditPurchaseHistory_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getCallCreditPurchaseHistory_result result = new getCallCreditPurchaseHistory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getCallCreditPurchaseHistory failed: unknown result");
  }

  Future<bool> isRoomMember(String roomId) async {
    oprot.writeMessageBegin(new TMessage("isRoomMember", TMessageType.CALL, nextSeqid()));
    isRoomMember_args args = new isRoomMember_args();
    args.roomId = roomId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    isRoomMember_result result = new isRoomMember_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "isRoomMember failed: unknown result");
  }

  Future<Message> sendSystemOAMessage(Message message) async {
    oprot.writeMessageBegin(new TMessage("sendSystemOAMessage", TMessageType.CALL, nextSeqid()));
    sendSystemOAMessage_args args = new sendSystemOAMessage_args();
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendSystemOAMessage_result result = new sendSystemOAMessage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendSystemOAMessage failed: unknown result");
  }

  Future<PaidCallResponse> acquirePaidCallRoute(int paidCallType, String dialedNumber, String language, String networkCode, bool disableCallerId, String referer, String adSessionId) async {
    oprot.writeMessageBegin(new TMessage("acquirePaidCallRoute", TMessageType.CALL, nextSeqid()));
    acquirePaidCallRoute_args args = new acquirePaidCallRoute_args();
    args.paidCallType = paidCallType;
    args.dialedNumber = dialedNumber;
    args.language = language;
    args.networkCode = networkCode;
    args.disableCallerId = disableCallerId;
    args.referer = referer;
    args.adSessionId = adSessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquirePaidCallRoute_result result = new acquirePaidCallRoute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquirePaidCallRoute failed: unknown result");
  }

  Future<List<Group>> getGroupsForChannel(List<String> groupIds) async {
    oprot.writeMessageBegin(new TMessage("getGroupsForChannel", TMessageType.CALL, nextSeqid()));
    getGroupsForChannel_args args = new getGroupsForChannel_args();
    args.groupIds = groupIds;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupsForChannel_result result = new getGroupsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupsForChannel failed: unknown result");
  }

  Future<int> getUserCreateTime() async {
    oprot.writeMessageBegin(new TMessage("getUserCreateTime", TMessageType.CALL, nextSeqid()));
    getUserCreateTime_args args = new getUserCreateTime_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserCreateTime_result result = new getUserCreateTime_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserCreateTime failed: unknown result");
  }

  Future<String> registerChannelCP(String cpId, String registerPassword) async {
    oprot.writeMessageBegin(new TMessage("registerChannelCP", TMessageType.CALL, nextSeqid()));
    registerChannelCP_args args = new registerChannelCP_args();
    args.cpId = cpId;
    args.registerPassword = registerPassword;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    registerChannelCP_result result = new registerChannelCP_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "registerChannelCP failed: unknown result");
  }

  Future<PaymentReservationResult> reserveCallCreditPurchase(CoinPurchaseReservation request) async {
    oprot.writeMessageBegin(new TMessage("reserveCallCreditPurchase", TMessageType.CALL, nextSeqid()));
    reserveCallCreditPurchase_args args = new reserveCallCreditPurchase_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reserveCallCreditPurchase_result result = new reserveCallCreditPurchase_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "reserveCallCreditPurchase failed: unknown result");
  }

  Future<List<PaidCallCurrencyExchangeRate>> acquirePaidCallCurrencyExchangeRate(String language) async {
    oprot.writeMessageBegin(new TMessage("acquirePaidCallCurrencyExchangeRate", TMessageType.CALL, nextSeqid()));
    acquirePaidCallCurrencyExchangeRate_args args = new acquirePaidCallCurrencyExchangeRate_args();
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquirePaidCallCurrencyExchangeRate_result result = new acquirePaidCallCurrencyExchangeRate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquirePaidCallCurrencyExchangeRate failed: unknown result");
  }

  Future<List<String>> getRoomMemberMidsForAppPlatform(String roomId) async {
    oprot.writeMessageBegin(new TMessage("getRoomMemberMidsForAppPlatform", TMessageType.CALL, nextSeqid()));
    getRoomMemberMidsForAppPlatform_args args = new getRoomMemberMidsForAppPlatform_args();
    args.roomId = roomId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getRoomMemberMidsForAppPlatform_result result = new getRoomMemberMidsForAppPlatform_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getRoomMemberMidsForAppPlatform failed: unknown result");
  }

  Future<List<PaidCallBalance>> getPaidCallBalanceList(String language) async {
    oprot.writeMessageBegin(new TMessage("getPaidCallBalanceList", TMessageType.CALL, nextSeqid()));
    getPaidCallBalanceList_args args = new getPaidCallBalanceList_args();
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPaidCallBalanceList_result result = new getPaidCallBalanceList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPaidCallBalanceList failed: unknown result");
  }

  Future<Map<int, String>> getPersonalInfos(Set<int> requiredPersonalInfos) async {
    oprot.writeMessageBegin(new TMessage("getPersonalInfos", TMessageType.CALL, nextSeqid()));
    getPersonalInfos_args args = new getPersonalInfos_args();
    args.requiredPersonalInfos = requiredPersonalInfos;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPersonalInfos_result result = new getPersonalInfos_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPersonalInfos failed: unknown result");
  }

  Future<List<SimpleChannelClient>> getPrimaryClientsForChannel(List<String> userMids) async {
    oprot.writeMessageBegin(new TMessage("getPrimaryClientsForChannel", TMessageType.CALL, nextSeqid()));
    getPrimaryClientsForChannel_args args = new getPrimaryClientsForChannel_args();
    args.userMids = userMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPrimaryClientsForChannel_result result = new getPrimaryClientsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPrimaryClientsForChannel failed: unknown result");
  }

  Future<ContactTransition> addBuddyToContact(String buddyMid) async {
    oprot.writeMessageBegin(new TMessage("addBuddyToContact", TMessageType.CALL, nextSeqid()));
    addBuddyToContact_args args = new addBuddyToContact_args();
    args.buddyMid = buddyMid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addBuddyToContact_result result = new addBuddyToContact_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "addBuddyToContact failed: unknown result");
  }

  Future<List<String>> getGroupMemberMidsForAppPlatform(String groupId) async {
    oprot.writeMessageBegin(new TMessage("getGroupMemberMidsForAppPlatform", TMessageType.CALL, nextSeqid()));
    getGroupMemberMidsForAppPlatform_args args = new getGroupMemberMidsForAppPlatform_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupMemberMidsForAppPlatform_result result = new getGroupMemberMidsForAppPlatform_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupMemberMidsForAppPlatform failed: unknown result");
  }

  Future<String> getUserLanguage() async {
    oprot.writeMessageBegin(new TMessage("getUserLanguage", TMessageType.CALL, nextSeqid()));
    getUserLanguage_args args = new getUserLanguage_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserLanguage_result result = new getUserLanguage_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserLanguage failed: unknown result");
  }

  Future<PaidCallResponse> lookupPaidCall(String dialedNumber, String language, String referer) async {
    oprot.writeMessageBegin(new TMessage("lookupPaidCall", TMessageType.CALL, nextSeqid()));
    lookupPaidCall_args args = new lookupPaidCall_args();
    args.dialedNumber = dialedNumber;
    args.language = language;
    args.referer = referer;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    lookupPaidCall_result result = new lookupPaidCall_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "lookupPaidCall failed: unknown result");
  }

  Future<ExtendedProfile> getExtendedProfile() async {
    oprot.writeMessageBegin(new TMessage("getExtendedProfile", TMessageType.CALL, nextSeqid()));
    getExtendedProfile_args args = new getExtendedProfile_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getExtendedProfile_result result = new getExtendedProfile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getExtendedProfile failed: unknown result");
  }

  Future<Map<String, CompactContact>> getReverseCompactContacts(List<String> ids) async {
    oprot.writeMessageBegin(new TMessage("getReverseCompactContacts", TMessageType.CALL, nextSeqid()));
    getReverseCompactContacts_args args = new getReverseCompactContacts_args();
    args.ids = ids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getReverseCompactContacts_result result = new getReverseCompactContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getReverseCompactContacts failed: unknown result");
  }

  Future<PaidCallAdResult> getPaidCallAdStatus() async {
    oprot.writeMessageBegin(new TMessage("getPaidCallAdStatus", TMessageType.CALL, nextSeqid()));
    getPaidCallAdStatus_args args = new getPaidCallAdStatus_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPaidCallAdStatus_result result = new getPaidCallAdStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getPaidCallAdStatus failed: unknown result");
  }

  Future<Contact> findContactByUseridWithoutAbuseBlockForChannel(String userid) async {
    oprot.writeMessageBegin(new TMessage("findContactByUseridWithoutAbuseBlockForChannel", TMessageType.CALL, nextSeqid()));
    findContactByUseridWithoutAbuseBlockForChannel_args args = new findContactByUseridWithoutAbuseBlockForChannel_args();
    args.userid = userid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    findContactByUseridWithoutAbuseBlockForChannel_result result = new findContactByUseridWithoutAbuseBlockForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "findContactByUseridWithoutAbuseBlockForChannel failed: unknown result");
  }

  Future<List<String>> getGroupMemberMids(String groupId) async {
    oprot.writeMessageBegin(new TMessage("getGroupMemberMids", TMessageType.CALL, nextSeqid()));
    getGroupMemberMids_args args = new getGroupMemberMids_args();
    args.groupId = groupId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getGroupMemberMids_result result = new getGroupMemberMids_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getGroupMemberMids failed: unknown result");
  }

  Future<Message> sendMessageWithoutRelationship(Message message) async {
    oprot.writeMessageBegin(new TMessage("sendMessageWithoutRelationship", TMessageType.CALL, nextSeqid()));
    sendMessageWithoutRelationship_args args = new sendMessageWithoutRelationship_args();
    args.message = message;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sendMessageWithoutRelationship_result result = new sendMessageWithoutRelationship_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sendMessageWithoutRelationship failed: unknown result");
  }

  Future<Map<String, int>> displayBuddySubscriberCountInBulk(List<String> mids) async {
    oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCountInBulk", TMessageType.CALL, nextSeqid()));
    displayBuddySubscriberCountInBulk_args args = new displayBuddySubscriberCountInBulk_args();
    args.mids = mids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    displayBuddySubscriberCountInBulk_result result = new displayBuddySubscriberCountInBulk_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "displayBuddySubscriberCountInBulk failed: unknown result");
  }

  Future<List<SimpleChannelContact>> lookupRoomMembers(String roomId, List<String> mids) async {
    oprot.writeMessageBegin(new TMessage("lookupRoomMembers", TMessageType.CALL, nextSeqid()));
    lookupRoomMembers_args args = new lookupRoomMembers_args();
    args.roomId = roomId;
    args.mids = mids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    lookupRoomMembers_result result = new lookupRoomMembers_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "lookupRoomMembers failed: unknown result");
  }

  Future<List<String>> getFavoriteMidsForChannel() async {
    oprot.writeMessageBegin(new TMessage("getFavoriteMidsForChannel", TMessageType.CALL, nextSeqid()));
    getFavoriteMidsForChannel_args args = new getFavoriteMidsForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getFavoriteMidsForChannel_result result = new getFavoriteMidsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getFavoriteMidsForChannel failed: unknown result");
  }

  Future<List<String>> getAllContactIdsForChannel() async {
    oprot.writeMessageBegin(new TMessage("getAllContactIdsForChannel", TMessageType.CALL, nextSeqid()));
    getAllContactIdsForChannel_args args = new getAllContactIdsForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getAllContactIdsForChannel_result result = new getAllContactIdsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getAllContactIdsForChannel failed: unknown result");
  }

  Future<int> displayBuddySubscriberCount() async {
    oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCount", TMessageType.CALL, nextSeqid()));
    displayBuddySubscriberCount_args args = new displayBuddySubscriberCount_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    displayBuddySubscriberCount_result result = new displayBuddySubscriberCount_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "displayBuddySubscriberCount failed: unknown result");
  }

  Future<Profile> getProfileForChannel() async {
    oprot.writeMessageBegin(new TMessage("getProfileForChannel", TMessageType.CALL, nextSeqid()));
    getProfileForChannel_args args = new getProfileForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getProfileForChannel_result result = new getProfileForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getProfileForChannel failed: unknown result");
  }

  Future<List<UserTicketResponse>> getUserTickets(List<String> userMids) async {
    oprot.writeMessageBegin(new TMessage("getUserTickets", TMessageType.CALL, nextSeqid()));
    getUserTickets_args args = new getUserTickets_args();
    args.userMids = userMids;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserTickets_result result = new getUserTickets_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserTickets failed: unknown result");
  }

  Future<List<String>> getOAFriendMids() async {
    oprot.writeMessageBegin(new TMessage("getOAFriendMids", TMessageType.CALL, nextSeqid()));
    getOAFriendMids_args args = new getOAFriendMids_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getOAFriendMids_result result = new getOAFriendMids_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getOAFriendMids failed: unknown result");
  }

  Future<List<PaidCallUserRate>> searchPaidCallUserRate(String countryCode, String language) async {
    oprot.writeMessageBegin(new TMessage("searchPaidCallUserRate", TMessageType.CALL, nextSeqid()));
    searchPaidCallUserRate_args args = new searchPaidCallUserRate_args();
    args.countryCode = countryCode;
    args.language = language;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    searchPaidCallUserRate_result result = new searchPaidCallUserRate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "searchPaidCallUserRate failed: unknown result");
  }

  Future<List<String>> getJoinedGroupIdsForChannel() async {
    oprot.writeMessageBegin(new TMessage("getJoinedGroupIdsForChannel", TMessageType.CALL, nextSeqid()));
    getJoinedGroupIdsForChannel_args args = new getJoinedGroupIdsForChannel_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getJoinedGroupIdsForChannel_result result = new getJoinedGroupIdsForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getJoinedGroupIdsForChannel failed: unknown result");
  }

  Future<GroupCallRoute> acquireGroupCallRoute(String chatMid, int mediaType) async {
    oprot.writeMessageBegin(new TMessage("acquireGroupCallRoute", TMessageType.CALL, nextSeqid()));
    acquireGroupCallRoute_args args = new acquireGroupCallRoute_args();
    args.chatMid = chatMid;
    args.mediaType = mediaType;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    acquireGroupCallRoute_result result = new acquireGroupCallRoute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "acquireGroupCallRoute failed: unknown result");
  }

  Future<List<String>> getUserMidsWhoAddedMe() async {
    oprot.writeMessageBegin(new TMessage("getUserMidsWhoAddedMe", TMessageType.CALL, nextSeqid()));
    getUserMidsWhoAddedMe_args args = new getUserMidsWhoAddedMe_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserMidsWhoAddedMe_result result = new getUserMidsWhoAddedMe_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserMidsWhoAddedMe failed: unknown result");
  }

  Future<IdentityCredential> getIdentityCredential() async {
    oprot.writeMessageBegin(new TMessage("getIdentityCredential", TMessageType.CALL, nextSeqid()));
    getIdentityCredential_args args = new getIdentityCredential_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getIdentityCredential_result result = new getIdentityCredential_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getIdentityCredential failed: unknown result");
  }

  Future addOperationForChannel(int opType, String param1, String param2, String param3) async {
    oprot.writeMessageBegin(new TMessage("addOperationForChannel", TMessageType.CALL, nextSeqid()));
    addOperationForChannel_args args = new addOperationForChannel_args();
    args.opType = opType;
    args.param1 = param1;
    args.param2 = param2;
    args.param3 = param3;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addOperationForChannel_result result = new addOperationForChannel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<List<SimpleChannelContact>> getSimpleChannelContacts(List<String> ids, bool statusSticonFallbackDisabled) async {
    oprot.writeMessageBegin(new TMessage("getSimpleChannelContacts", TMessageType.CALL, nextSeqid()));
    getSimpleChannelContacts_args args = new getSimpleChannelContacts_args();
    args.ids = ids;
    args.statusSticonFallbackDisabled = statusSticonFallbackDisabled;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSimpleChannelContacts_result result = new getSimpleChannelContacts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getSimpleChannelContacts failed: unknown result");
  }

  Future<int> getUserLastSentMessageTimeStamp(String mid) async {
    oprot.writeMessageBegin(new TMessage("getUserLastSentMessageTimeStamp", TMessageType.CALL, nextSeqid()));
    getUserLastSentMessageTimeStamp_args args = new getUserLastSentMessageTimeStamp_args();
    args.mid = mid;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserLastSentMessageTimeStamp_result result = new getUserLastSentMessageTimeStamp_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "getUserLastSentMessageTimeStamp failed: unknown result");
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class CallServiceProcessor implements TProcessor {
  CallServiceProcessor(CallService iface) {
    iface_ = iface;
    PROCESS_MAP["getUserStatus"] = getUserStatus;
    PROCESS_MAP["updateProfileAttributeForChannel"] = updateProfileAttributeForChannel;
    PROCESS_MAP["updateExtendedProfileAttribute"] = updateExtendedProfileAttribute;
    PROCESS_MAP["getAllSimpleChannelContacts"] = getAllSimpleChannelContacts;
    PROCESS_MAP["getUserIdentities"] = getUserIdentities;
    PROCESS_MAP["markPaidCallAd"] = markPaidCallAd;
    PROCESS_MAP["isGroupMember"] = isGroupMember;
    PROCESS_MAP["getPhoneInfoFromPhoneNumber"] = getPhoneInfoFromPhoneNumber;
    PROCESS_MAP["redeemPaidCallVoucher"] = redeemPaidCallVoucher;
    PROCESS_MAP["getPreferredDisplayName"] = getPreferredDisplayName;
    PROCESS_MAP["getContactsForChannel"] = getContactsForChannel;
    PROCESS_MAP["getCallCreditProducts"] = getCallCreditProducts;
    PROCESS_MAP["getCompactContacts"] = getCompactContacts;
    PROCESS_MAP["notifyNotiCenterEvent"] = notifyNotiCenterEvent;
    PROCESS_MAP["isInContact"] = isInContact;
    PROCESS_MAP["lookupGroupMembers"] = lookupGroupMembers;
    PROCESS_MAP["getRoomInformation"] = getRoomInformation;
    PROCESS_MAP["getGroupCall"] = getGroupCall;
    PROCESS_MAP["isAllowSecondaryDeviceLogin"] = isAllowSecondaryDeviceLogin;
    PROCESS_MAP["getPrimaryClientForChannel"] = getPrimaryClientForChannel;
    PROCESS_MAP["createRoomWithBuddy"] = createRoomWithBuddy;
    PROCESS_MAP["getDisplayName"] = getDisplayName;
    PROCESS_MAP["getPaidCallMetadata"] = getPaidCallMetadata;
    PROCESS_MAP["getMid"] = getMid;
    PROCESS_MAP["getUserCountryForBilling"] = getUserCountryForBilling;
    PROCESS_MAP["getFavoriteGroupIdsForChannel"] = getFavoriteGroupIdsForChannel;
    PROCESS_MAP["getPaidCallHistory"] = getPaidCallHistory;
    PROCESS_MAP["sendPinCodeOperation"] = sendPinCodeOperation;
    PROCESS_MAP["inviteIntoGroupCall"] = inviteIntoGroupCall;
    PROCESS_MAP["getFriendMids"] = getFriendMids;
    PROCESS_MAP["getMetaProfile"] = getMetaProfile;
    PROCESS_MAP["sendMessageForChannel"] = sendMessageForChannel;
    PROCESS_MAP["activeBuddySubscriberCount"] = activeBuddySubscriberCount;
    PROCESS_MAP["getCallCreditPurchaseHistory"] = getCallCreditPurchaseHistory;
    PROCESS_MAP["isRoomMember"] = isRoomMember;
    PROCESS_MAP["sendSystemOAMessage"] = sendSystemOAMessage;
    PROCESS_MAP["acquirePaidCallRoute"] = acquirePaidCallRoute;
    PROCESS_MAP["getGroupsForChannel"] = getGroupsForChannel;
    PROCESS_MAP["getUserCreateTime"] = getUserCreateTime;
    PROCESS_MAP["registerChannelCP"] = registerChannelCP;
    PROCESS_MAP["reserveCallCreditPurchase"] = reserveCallCreditPurchase;
    PROCESS_MAP["acquirePaidCallCurrencyExchangeRate"] = acquirePaidCallCurrencyExchangeRate;
    PROCESS_MAP["getRoomMemberMidsForAppPlatform"] = getRoomMemberMidsForAppPlatform;
    PROCESS_MAP["getPaidCallBalanceList"] = getPaidCallBalanceList;
    PROCESS_MAP["getPersonalInfos"] = getPersonalInfos;
    PROCESS_MAP["getPrimaryClientsForChannel"] = getPrimaryClientsForChannel;
    PROCESS_MAP["addBuddyToContact"] = addBuddyToContact;
    PROCESS_MAP["getGroupMemberMidsForAppPlatform"] = getGroupMemberMidsForAppPlatform;
    PROCESS_MAP["getUserLanguage"] = getUserLanguage;
    PROCESS_MAP["lookupPaidCall"] = lookupPaidCall;
    PROCESS_MAP["getExtendedProfile"] = getExtendedProfile;
    PROCESS_MAP["getReverseCompactContacts"] = getReverseCompactContacts;
    PROCESS_MAP["getPaidCallAdStatus"] = getPaidCallAdStatus;
    PROCESS_MAP["findContactByUseridWithoutAbuseBlockForChannel"] = findContactByUseridWithoutAbuseBlockForChannel;
    PROCESS_MAP["getGroupMemberMids"] = getGroupMemberMids;
    PROCESS_MAP["sendMessageWithoutRelationship"] = sendMessageWithoutRelationship;
    PROCESS_MAP["displayBuddySubscriberCountInBulk"] = displayBuddySubscriberCountInBulk;
    PROCESS_MAP["lookupRoomMembers"] = lookupRoomMembers;
    PROCESS_MAP["getFavoriteMidsForChannel"] = getFavoriteMidsForChannel;
    PROCESS_MAP["getAllContactIdsForChannel"] = getAllContactIdsForChannel;
    PROCESS_MAP["displayBuddySubscriberCount"] = displayBuddySubscriberCount;
    PROCESS_MAP["getProfileForChannel"] = getProfileForChannel;
    PROCESS_MAP["getUserTickets"] = getUserTickets;
    PROCESS_MAP["getOAFriendMids"] = getOAFriendMids;
    PROCESS_MAP["searchPaidCallUserRate"] = searchPaidCallUserRate;
    PROCESS_MAP["getJoinedGroupIdsForChannel"] = getJoinedGroupIdsForChannel;
    PROCESS_MAP["acquireGroupCallRoute"] = acquireGroupCallRoute;
    PROCESS_MAP["getUserMidsWhoAddedMe"] = getUserMidsWhoAddedMe;
    PROCESS_MAP["getIdentityCredential"] = getIdentityCredential;
    PROCESS_MAP["addOperationForChannel"] = addOperationForChannel;
    PROCESS_MAP["getSimpleChannelContacts"] = getSimpleChannelContacts;
    PROCESS_MAP["getUserLastSentMessageTimeStamp"] = getUserLastSentMessageTimeStamp;
  }

  CallService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  getUserStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserStatus_args args = new getUserStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserStatus_result result = new getUserStatus_result();
    try {
      result.success = await iface_.getUserStatus(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserStatus");
      oprot.writeMessageBegin(new TMessage("getUserStatus", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateProfileAttributeForChannel(int seqid, TProtocol iprot, TProtocol oprot) {
    updateProfileAttributeForChannel_args args = new updateProfileAttributeForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateProfileAttributeForChannel_result result = new updateProfileAttributeForChannel_result();
    try {
      iface_.updateProfileAttributeForChannel(args.profileAttribute, args.value);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateProfileAttributeForChannel");
      oprot.writeMessageBegin(new TMessage("updateProfileAttributeForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateProfileAttributeForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  updateExtendedProfileAttribute(int seqid, TProtocol iprot, TProtocol oprot) {
    updateExtendedProfileAttribute_args args = new updateExtendedProfileAttribute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateExtendedProfileAttribute_result result = new updateExtendedProfileAttribute_result();
    try {
      iface_.updateExtendedProfileAttribute(args.attr, args.extendedProfile);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing updateExtendedProfileAttribute");
      oprot.writeMessageBegin(new TMessage("updateExtendedProfileAttribute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("updateExtendedProfileAttribute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAllSimpleChannelContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAllSimpleChannelContacts_args args = new getAllSimpleChannelContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAllSimpleChannelContacts_result result = new getAllSimpleChannelContacts_result();
    try {
      result.success = await iface_.getAllSimpleChannelContacts(args.statusSticonFallbackDisabled);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAllSimpleChannelContacts");
      oprot.writeMessageBegin(new TMessage("getAllSimpleChannelContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAllSimpleChannelContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserIdentities(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserIdentities_args args = new getUserIdentities_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserIdentities_result result = new getUserIdentities_result();
    try {
      result.success = await iface_.getUserIdentities();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserIdentities");
      oprot.writeMessageBegin(new TMessage("getUserIdentities", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserIdentities", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  markPaidCallAd(int seqid, TProtocol iprot, TProtocol oprot) async {
    markPaidCallAd_args args = new markPaidCallAd_args();
    args.read(iprot);
    iprot.readMessageEnd();
    markPaidCallAd_result result = new markPaidCallAd_result();
    try {
      result.success = await iface_.markPaidCallAd(args.dialedNumber, args.language, args.disableCallerId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing markPaidCallAd");
      oprot.writeMessageBegin(new TMessage("markPaidCallAd", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("markPaidCallAd", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isGroupMember(int seqid, TProtocol iprot, TProtocol oprot) async {
    isGroupMember_args args = new isGroupMember_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isGroupMember_result result = new isGroupMember_result();
    try {
      result.success = await iface_.isGroupMember(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isGroupMember");
      oprot.writeMessageBegin(new TMessage("isGroupMember", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isGroupMember", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPhoneInfoFromPhoneNumber(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPhoneInfoFromPhoneNumber_args args = new getPhoneInfoFromPhoneNumber_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPhoneInfoFromPhoneNumber_result result = new getPhoneInfoFromPhoneNumber_result();
    try {
      result.success = await iface_.getPhoneInfoFromPhoneNumber(args.region, args.phoneNumber);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPhoneInfoFromPhoneNumber");
      oprot.writeMessageBegin(new TMessage("getPhoneInfoFromPhoneNumber", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPhoneInfoFromPhoneNumber", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  redeemPaidCallVoucher(int seqid, TProtocol iprot, TProtocol oprot) async {
    redeemPaidCallVoucher_args args = new redeemPaidCallVoucher_args();
    args.read(iprot);
    iprot.readMessageEnd();
    redeemPaidCallVoucher_result result = new redeemPaidCallVoucher_result();
    try {
      result.success = await iface_.redeemPaidCallVoucher(args.serial, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing redeemPaidCallVoucher");
      oprot.writeMessageBegin(new TMessage("redeemPaidCallVoucher", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("redeemPaidCallVoucher", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPreferredDisplayName(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPreferredDisplayName_args args = new getPreferredDisplayName_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPreferredDisplayName_result result = new getPreferredDisplayName_result();
    try {
      result.success = await iface_.getPreferredDisplayName(args.mids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPreferredDisplayName");
      oprot.writeMessageBegin(new TMessage("getPreferredDisplayName", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPreferredDisplayName", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getContactsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getContactsForChannel_args args = new getContactsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getContactsForChannel_result result = new getContactsForChannel_result();
    try {
      result.success = await iface_.getContactsForChannel(args.ids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getContactsForChannel");
      oprot.writeMessageBegin(new TMessage("getContactsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getContactsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCallCreditProducts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCallCreditProducts_args args = new getCallCreditProducts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCallCreditProducts_result result = new getCallCreditProducts_result();
    try {
      result.success = await iface_.getCallCreditProducts(args.appStoreCode, args.pgCode, args.country, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCallCreditProducts");
      oprot.writeMessageBegin(new TMessage("getCallCreditProducts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCallCreditProducts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCompactContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCompactContacts_args args = new getCompactContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCompactContacts_result result = new getCompactContacts_result();
    try {
      result.success = await iface_.getCompactContacts(args.lastModifiedTimestamp);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCompactContacts");
      oprot.writeMessageBegin(new TMessage("getCompactContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCompactContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  notifyNotiCenterEvent(int seqid, TProtocol iprot, TProtocol oprot) {
    notifyNotiCenterEvent_args args = new notifyNotiCenterEvent_args();
    args.read(iprot);
    iprot.readMessageEnd();
    notifyNotiCenterEvent_result result = new notifyNotiCenterEvent_result();
    try {
      iface_.notifyNotiCenterEvent(args.event);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing notifyNotiCenterEvent");
      oprot.writeMessageBegin(new TMessage("notifyNotiCenterEvent", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("notifyNotiCenterEvent", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isInContact(int seqid, TProtocol iprot, TProtocol oprot) async {
    isInContact_args args = new isInContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isInContact_result result = new isInContact_result();
    try {
      result.success = await iface_.isInContact(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isInContact");
      oprot.writeMessageBegin(new TMessage("isInContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isInContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  lookupGroupMembers(int seqid, TProtocol iprot, TProtocol oprot) async {
    lookupGroupMembers_args args = new lookupGroupMembers_args();
    args.read(iprot);
    iprot.readMessageEnd();
    lookupGroupMembers_result result = new lookupGroupMembers_result();
    try {
      result.success = await iface_.lookupGroupMembers(args.groupId, args.mids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing lookupGroupMembers");
      oprot.writeMessageBegin(new TMessage("lookupGroupMembers", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("lookupGroupMembers", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRoomInformation(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRoomInformation_args args = new getRoomInformation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRoomInformation_result result = new getRoomInformation_result();
    try {
      result.success = await iface_.getRoomInformation(args.roomMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRoomInformation");
      oprot.writeMessageBegin(new TMessage("getRoomInformation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRoomInformation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupCall(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupCall_args args = new getGroupCall_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupCall_result result = new getGroupCall_result();
    try {
      result.success = await iface_.getGroupCall(args.chatMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupCall");
      oprot.writeMessageBegin(new TMessage("getGroupCall", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupCall", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isAllowSecondaryDeviceLogin(int seqid, TProtocol iprot, TProtocol oprot) async {
    isAllowSecondaryDeviceLogin_args args = new isAllowSecondaryDeviceLogin_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isAllowSecondaryDeviceLogin_result result = new isAllowSecondaryDeviceLogin_result();
    try {
      result.success = await iface_.isAllowSecondaryDeviceLogin();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isAllowSecondaryDeviceLogin");
      oprot.writeMessageBegin(new TMessage("isAllowSecondaryDeviceLogin", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isAllowSecondaryDeviceLogin", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPrimaryClientForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPrimaryClientForChannel_args args = new getPrimaryClientForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPrimaryClientForChannel_result result = new getPrimaryClientForChannel_result();
    try {
      result.success = await iface_.getPrimaryClientForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPrimaryClientForChannel");
      oprot.writeMessageBegin(new TMessage("getPrimaryClientForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPrimaryClientForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  createRoomWithBuddy(int seqid, TProtocol iprot, TProtocol oprot) async {
    createRoomWithBuddy_args args = new createRoomWithBuddy_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createRoomWithBuddy_result result = new createRoomWithBuddy_result();
    try {
      result.success = await iface_.createRoomWithBuddy(args.reqSeq, args.buddyMid, args.contactIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing createRoomWithBuddy");
      oprot.writeMessageBegin(new TMessage("createRoomWithBuddy", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("createRoomWithBuddy", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getDisplayName(int seqid, TProtocol iprot, TProtocol oprot) async {
    getDisplayName_args args = new getDisplayName_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getDisplayName_result result = new getDisplayName_result();
    try {
      result.success = await iface_.getDisplayName(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getDisplayName");
      oprot.writeMessageBegin(new TMessage("getDisplayName", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getDisplayName", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPaidCallMetadata(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPaidCallMetadata_args args = new getPaidCallMetadata_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPaidCallMetadata_result result = new getPaidCallMetadata_result();
    try {
      result.success = await iface_.getPaidCallMetadata(args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPaidCallMetadata");
      oprot.writeMessageBegin(new TMessage("getPaidCallMetadata", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPaidCallMetadata", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMid(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMid_args args = new getMid_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMid_result result = new getMid_result();
    try {
      result.success = await iface_.getMid();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMid");
      oprot.writeMessageBegin(new TMessage("getMid", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMid", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserCountryForBilling(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserCountryForBilling_args args = new getUserCountryForBilling_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserCountryForBilling_result result = new getUserCountryForBilling_result();
    try {
      result.success = await iface_.getUserCountryForBilling(args.country, args.remoteIp);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserCountryForBilling");
      oprot.writeMessageBegin(new TMessage("getUserCountryForBilling", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserCountryForBilling", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFavoriteGroupIdsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFavoriteGroupIdsForChannel_args args = new getFavoriteGroupIdsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFavoriteGroupIdsForChannel_result result = new getFavoriteGroupIdsForChannel_result();
    try {
      result.success = await iface_.getFavoriteGroupIdsForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFavoriteGroupIdsForChannel");
      oprot.writeMessageBegin(new TMessage("getFavoriteGroupIdsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFavoriteGroupIdsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPaidCallHistory(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPaidCallHistory_args args = new getPaidCallHistory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPaidCallHistory_result result = new getPaidCallHistory_result();
    try {
      result.success = await iface_.getPaidCallHistory(args.start, args.size, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPaidCallHistory");
      oprot.writeMessageBegin(new TMessage("getPaidCallHistory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPaidCallHistory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendPinCodeOperation(int seqid, TProtocol iprot, TProtocol oprot) {
    sendPinCodeOperation_args args = new sendPinCodeOperation_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendPinCodeOperation_result result = new sendPinCodeOperation_result();
    try {
      iface_.sendPinCodeOperation(args.verifier);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendPinCodeOperation");
      oprot.writeMessageBegin(new TMessage("sendPinCodeOperation", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendPinCodeOperation", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  inviteIntoGroupCall(int seqid, TProtocol iprot, TProtocol oprot) {
    inviteIntoGroupCall_args args = new inviteIntoGroupCall_args();
    args.read(iprot);
    iprot.readMessageEnd();
    inviteIntoGroupCall_result result = new inviteIntoGroupCall_result();
    try {
      iface_.inviteIntoGroupCall(args.chatMid, args.memberMids, args.mediaType);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing inviteIntoGroupCall");
      oprot.writeMessageBegin(new TMessage("inviteIntoGroupCall", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("inviteIntoGroupCall", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFriendMids(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFriendMids_args args = new getFriendMids_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFriendMids_result result = new getFriendMids_result();
    try {
      result.success = await iface_.getFriendMids();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFriendMids");
      oprot.writeMessageBegin(new TMessage("getFriendMids", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFriendMids", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getMetaProfile(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMetaProfile_args args = new getMetaProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMetaProfile_result result = new getMetaProfile_result();
    try {
      result.success = await iface_.getMetaProfile();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getMetaProfile");
      oprot.writeMessageBegin(new TMessage("getMetaProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getMetaProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendMessageForChannel_args args = new sendMessageForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageForChannel_result result = new sendMessageForChannel_result();
    try {
      result.success = await iface_.sendMessageForChannel(args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageForChannel");
      oprot.writeMessageBegin(new TMessage("sendMessageForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  activeBuddySubscriberCount(int seqid, TProtocol iprot, TProtocol oprot) async {
    activeBuddySubscriberCount_args args = new activeBuddySubscriberCount_args();
    args.read(iprot);
    iprot.readMessageEnd();
    activeBuddySubscriberCount_result result = new activeBuddySubscriberCount_result();
    try {
      result.success = await iface_.activeBuddySubscriberCount();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing activeBuddySubscriberCount");
      oprot.writeMessageBegin(new TMessage("activeBuddySubscriberCount", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("activeBuddySubscriberCount", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getCallCreditPurchaseHistory(int seqid, TProtocol iprot, TProtocol oprot) async {
    getCallCreditPurchaseHistory_args args = new getCallCreditPurchaseHistory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getCallCreditPurchaseHistory_result result = new getCallCreditPurchaseHistory_result();
    try {
      result.success = await iface_.getCallCreditPurchaseHistory(args.request);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getCallCreditPurchaseHistory");
      oprot.writeMessageBegin(new TMessage("getCallCreditPurchaseHistory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getCallCreditPurchaseHistory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  isRoomMember(int seqid, TProtocol iprot, TProtocol oprot) async {
    isRoomMember_args args = new isRoomMember_args();
    args.read(iprot);
    iprot.readMessageEnd();
    isRoomMember_result result = new isRoomMember_result();
    try {
      result.success = await iface_.isRoomMember(args.roomId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing isRoomMember");
      oprot.writeMessageBegin(new TMessage("isRoomMember", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("isRoomMember", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendSystemOAMessage(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendSystemOAMessage_args args = new sendSystemOAMessage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendSystemOAMessage_result result = new sendSystemOAMessage_result();
    try {
      result.success = await iface_.sendSystemOAMessage(args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendSystemOAMessage");
      oprot.writeMessageBegin(new TMessage("sendSystemOAMessage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendSystemOAMessage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquirePaidCallRoute(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquirePaidCallRoute_args args = new acquirePaidCallRoute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquirePaidCallRoute_result result = new acquirePaidCallRoute_result();
    try {
      result.success = await iface_.acquirePaidCallRoute(args.paidCallType, args.dialedNumber, args.language, args.networkCode, args.disableCallerId, args.referer, args.adSessionId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquirePaidCallRoute");
      oprot.writeMessageBegin(new TMessage("acquirePaidCallRoute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquirePaidCallRoute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupsForChannel_args args = new getGroupsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupsForChannel_result result = new getGroupsForChannel_result();
    try {
      result.success = await iface_.getGroupsForChannel(args.groupIds);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupsForChannel");
      oprot.writeMessageBegin(new TMessage("getGroupsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserCreateTime(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserCreateTime_args args = new getUserCreateTime_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserCreateTime_result result = new getUserCreateTime_result();
    try {
      result.success = await iface_.getUserCreateTime();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserCreateTime");
      oprot.writeMessageBegin(new TMessage("getUserCreateTime", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserCreateTime", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  registerChannelCP(int seqid, TProtocol iprot, TProtocol oprot) async {
    registerChannelCP_args args = new registerChannelCP_args();
    args.read(iprot);
    iprot.readMessageEnd();
    registerChannelCP_result result = new registerChannelCP_result();
    try {
      result.success = await iface_.registerChannelCP(args.cpId, args.registerPassword);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing registerChannelCP");
      oprot.writeMessageBegin(new TMessage("registerChannelCP", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("registerChannelCP", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  reserveCallCreditPurchase(int seqid, TProtocol iprot, TProtocol oprot) async {
    reserveCallCreditPurchase_args args = new reserveCallCreditPurchase_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reserveCallCreditPurchase_result result = new reserveCallCreditPurchase_result();
    try {
      result.success = await iface_.reserveCallCreditPurchase(args.request);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing reserveCallCreditPurchase");
      oprot.writeMessageBegin(new TMessage("reserveCallCreditPurchase", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("reserveCallCreditPurchase", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquirePaidCallCurrencyExchangeRate(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquirePaidCallCurrencyExchangeRate_args args = new acquirePaidCallCurrencyExchangeRate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquirePaidCallCurrencyExchangeRate_result result = new acquirePaidCallCurrencyExchangeRate_result();
    try {
      result.success = await iface_.acquirePaidCallCurrencyExchangeRate(args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquirePaidCallCurrencyExchangeRate");
      oprot.writeMessageBegin(new TMessage("acquirePaidCallCurrencyExchangeRate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquirePaidCallCurrencyExchangeRate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getRoomMemberMidsForAppPlatform(int seqid, TProtocol iprot, TProtocol oprot) async {
    getRoomMemberMidsForAppPlatform_args args = new getRoomMemberMidsForAppPlatform_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getRoomMemberMidsForAppPlatform_result result = new getRoomMemberMidsForAppPlatform_result();
    try {
      result.success = await iface_.getRoomMemberMidsForAppPlatform(args.roomId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getRoomMemberMidsForAppPlatform");
      oprot.writeMessageBegin(new TMessage("getRoomMemberMidsForAppPlatform", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getRoomMemberMidsForAppPlatform", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPaidCallBalanceList(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPaidCallBalanceList_args args = new getPaidCallBalanceList_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPaidCallBalanceList_result result = new getPaidCallBalanceList_result();
    try {
      result.success = await iface_.getPaidCallBalanceList(args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPaidCallBalanceList");
      oprot.writeMessageBegin(new TMessage("getPaidCallBalanceList", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPaidCallBalanceList", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPersonalInfos(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPersonalInfos_args args = new getPersonalInfos_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPersonalInfos_result result = new getPersonalInfos_result();
    try {
      result.success = await iface_.getPersonalInfos(args.requiredPersonalInfos);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPersonalInfos");
      oprot.writeMessageBegin(new TMessage("getPersonalInfos", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPersonalInfos", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPrimaryClientsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPrimaryClientsForChannel_args args = new getPrimaryClientsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPrimaryClientsForChannel_result result = new getPrimaryClientsForChannel_result();
    try {
      result.success = await iface_.getPrimaryClientsForChannel(args.userMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPrimaryClientsForChannel");
      oprot.writeMessageBegin(new TMessage("getPrimaryClientsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPrimaryClientsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  addBuddyToContact(int seqid, TProtocol iprot, TProtocol oprot) async {
    addBuddyToContact_args args = new addBuddyToContact_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addBuddyToContact_result result = new addBuddyToContact_result();
    try {
      result.success = await iface_.addBuddyToContact(args.buddyMid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing addBuddyToContact");
      oprot.writeMessageBegin(new TMessage("addBuddyToContact", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("addBuddyToContact", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupMemberMidsForAppPlatform(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupMemberMidsForAppPlatform_args args = new getGroupMemberMidsForAppPlatform_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupMemberMidsForAppPlatform_result result = new getGroupMemberMidsForAppPlatform_result();
    try {
      result.success = await iface_.getGroupMemberMidsForAppPlatform(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupMemberMidsForAppPlatform");
      oprot.writeMessageBegin(new TMessage("getGroupMemberMidsForAppPlatform", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupMemberMidsForAppPlatform", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserLanguage(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserLanguage_args args = new getUserLanguage_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserLanguage_result result = new getUserLanguage_result();
    try {
      result.success = await iface_.getUserLanguage();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserLanguage");
      oprot.writeMessageBegin(new TMessage("getUserLanguage", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserLanguage", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  lookupPaidCall(int seqid, TProtocol iprot, TProtocol oprot) async {
    lookupPaidCall_args args = new lookupPaidCall_args();
    args.read(iprot);
    iprot.readMessageEnd();
    lookupPaidCall_result result = new lookupPaidCall_result();
    try {
      result.success = await iface_.lookupPaidCall(args.dialedNumber, args.language, args.referer);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing lookupPaidCall");
      oprot.writeMessageBegin(new TMessage("lookupPaidCall", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("lookupPaidCall", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getExtendedProfile(int seqid, TProtocol iprot, TProtocol oprot) async {
    getExtendedProfile_args args = new getExtendedProfile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getExtendedProfile_result result = new getExtendedProfile_result();
    try {
      result.success = await iface_.getExtendedProfile();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getExtendedProfile");
      oprot.writeMessageBegin(new TMessage("getExtendedProfile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getExtendedProfile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getReverseCompactContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getReverseCompactContacts_args args = new getReverseCompactContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getReverseCompactContacts_result result = new getReverseCompactContacts_result();
    try {
      result.success = await iface_.getReverseCompactContacts(args.ids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getReverseCompactContacts");
      oprot.writeMessageBegin(new TMessage("getReverseCompactContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getReverseCompactContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getPaidCallAdStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPaidCallAdStatus_args args = new getPaidCallAdStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPaidCallAdStatus_result result = new getPaidCallAdStatus_result();
    try {
      result.success = await iface_.getPaidCallAdStatus();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getPaidCallAdStatus");
      oprot.writeMessageBegin(new TMessage("getPaidCallAdStatus", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getPaidCallAdStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  findContactByUseridWithoutAbuseBlockForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    findContactByUseridWithoutAbuseBlockForChannel_args args = new findContactByUseridWithoutAbuseBlockForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    findContactByUseridWithoutAbuseBlockForChannel_result result = new findContactByUseridWithoutAbuseBlockForChannel_result();
    try {
      result.success = await iface_.findContactByUseridWithoutAbuseBlockForChannel(args.userid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing findContactByUseridWithoutAbuseBlockForChannel");
      oprot.writeMessageBegin(new TMessage("findContactByUseridWithoutAbuseBlockForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("findContactByUseridWithoutAbuseBlockForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getGroupMemberMids(int seqid, TProtocol iprot, TProtocol oprot) async {
    getGroupMemberMids_args args = new getGroupMemberMids_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getGroupMemberMids_result result = new getGroupMemberMids_result();
    try {
      result.success = await iface_.getGroupMemberMids(args.groupId);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getGroupMemberMids");
      oprot.writeMessageBegin(new TMessage("getGroupMemberMids", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getGroupMemberMids", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sendMessageWithoutRelationship(int seqid, TProtocol iprot, TProtocol oprot) async {
    sendMessageWithoutRelationship_args args = new sendMessageWithoutRelationship_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sendMessageWithoutRelationship_result result = new sendMessageWithoutRelationship_result();
    try {
      result.success = await iface_.sendMessageWithoutRelationship(args.message);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sendMessageWithoutRelationship");
      oprot.writeMessageBegin(new TMessage("sendMessageWithoutRelationship", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sendMessageWithoutRelationship", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  displayBuddySubscriberCountInBulk(int seqid, TProtocol iprot, TProtocol oprot) async {
    displayBuddySubscriberCountInBulk_args args = new displayBuddySubscriberCountInBulk_args();
    args.read(iprot);
    iprot.readMessageEnd();
    displayBuddySubscriberCountInBulk_result result = new displayBuddySubscriberCountInBulk_result();
    try {
      result.success = await iface_.displayBuddySubscriberCountInBulk(args.mids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing displayBuddySubscriberCountInBulk");
      oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCountInBulk", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCountInBulk", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  lookupRoomMembers(int seqid, TProtocol iprot, TProtocol oprot) async {
    lookupRoomMembers_args args = new lookupRoomMembers_args();
    args.read(iprot);
    iprot.readMessageEnd();
    lookupRoomMembers_result result = new lookupRoomMembers_result();
    try {
      result.success = await iface_.lookupRoomMembers(args.roomId, args.mids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing lookupRoomMembers");
      oprot.writeMessageBegin(new TMessage("lookupRoomMembers", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("lookupRoomMembers", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getFavoriteMidsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getFavoriteMidsForChannel_args args = new getFavoriteMidsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getFavoriteMidsForChannel_result result = new getFavoriteMidsForChannel_result();
    try {
      result.success = await iface_.getFavoriteMidsForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getFavoriteMidsForChannel");
      oprot.writeMessageBegin(new TMessage("getFavoriteMidsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getFavoriteMidsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getAllContactIdsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getAllContactIdsForChannel_args args = new getAllContactIdsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getAllContactIdsForChannel_result result = new getAllContactIdsForChannel_result();
    try {
      result.success = await iface_.getAllContactIdsForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getAllContactIdsForChannel");
      oprot.writeMessageBegin(new TMessage("getAllContactIdsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getAllContactIdsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  displayBuddySubscriberCount(int seqid, TProtocol iprot, TProtocol oprot) async {
    displayBuddySubscriberCount_args args = new displayBuddySubscriberCount_args();
    args.read(iprot);
    iprot.readMessageEnd();
    displayBuddySubscriberCount_result result = new displayBuddySubscriberCount_result();
    try {
      result.success = await iface_.displayBuddySubscriberCount();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing displayBuddySubscriberCount");
      oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCount", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("displayBuddySubscriberCount", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getProfileForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getProfileForChannel_args args = new getProfileForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getProfileForChannel_result result = new getProfileForChannel_result();
    try {
      result.success = await iface_.getProfileForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getProfileForChannel");
      oprot.writeMessageBegin(new TMessage("getProfileForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getProfileForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserTickets(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserTickets_args args = new getUserTickets_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserTickets_result result = new getUserTickets_result();
    try {
      result.success = await iface_.getUserTickets(args.userMids);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserTickets");
      oprot.writeMessageBegin(new TMessage("getUserTickets", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserTickets", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getOAFriendMids(int seqid, TProtocol iprot, TProtocol oprot) async {
    getOAFriendMids_args args = new getOAFriendMids_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getOAFriendMids_result result = new getOAFriendMids_result();
    try {
      result.success = await iface_.getOAFriendMids();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getOAFriendMids");
      oprot.writeMessageBegin(new TMessage("getOAFriendMids", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getOAFriendMids", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  searchPaidCallUserRate(int seqid, TProtocol iprot, TProtocol oprot) async {
    searchPaidCallUserRate_args args = new searchPaidCallUserRate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    searchPaidCallUserRate_result result = new searchPaidCallUserRate_result();
    try {
      result.success = await iface_.searchPaidCallUserRate(args.countryCode, args.language);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing searchPaidCallUserRate");
      oprot.writeMessageBegin(new TMessage("searchPaidCallUserRate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("searchPaidCallUserRate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getJoinedGroupIdsForChannel(int seqid, TProtocol iprot, TProtocol oprot) async {
    getJoinedGroupIdsForChannel_args args = new getJoinedGroupIdsForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getJoinedGroupIdsForChannel_result result = new getJoinedGroupIdsForChannel_result();
    try {
      result.success = await iface_.getJoinedGroupIdsForChannel();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getJoinedGroupIdsForChannel");
      oprot.writeMessageBegin(new TMessage("getJoinedGroupIdsForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getJoinedGroupIdsForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  acquireGroupCallRoute(int seqid, TProtocol iprot, TProtocol oprot) async {
    acquireGroupCallRoute_args args = new acquireGroupCallRoute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    acquireGroupCallRoute_result result = new acquireGroupCallRoute_result();
    try {
      result.success = await iface_.acquireGroupCallRoute(args.chatMid, args.mediaType);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing acquireGroupCallRoute");
      oprot.writeMessageBegin(new TMessage("acquireGroupCallRoute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("acquireGroupCallRoute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserMidsWhoAddedMe(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserMidsWhoAddedMe_args args = new getUserMidsWhoAddedMe_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserMidsWhoAddedMe_result result = new getUserMidsWhoAddedMe_result();
    try {
      result.success = await iface_.getUserMidsWhoAddedMe();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserMidsWhoAddedMe");
      oprot.writeMessageBegin(new TMessage("getUserMidsWhoAddedMe", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserMidsWhoAddedMe", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getIdentityCredential(int seqid, TProtocol iprot, TProtocol oprot) async {
    getIdentityCredential_args args = new getIdentityCredential_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getIdentityCredential_result result = new getIdentityCredential_result();
    try {
      result.success = await iface_.getIdentityCredential();
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getIdentityCredential");
      oprot.writeMessageBegin(new TMessage("getIdentityCredential", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getIdentityCredential", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  addOperationForChannel(int seqid, TProtocol iprot, TProtocol oprot) {
    addOperationForChannel_args args = new addOperationForChannel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addOperationForChannel_result result = new addOperationForChannel_result();
    try {
      iface_.addOperationForChannel(args.opType, args.param1, args.param2, args.param3);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing addOperationForChannel");
      oprot.writeMessageBegin(new TMessage("addOperationForChannel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("addOperationForChannel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getSimpleChannelContacts(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSimpleChannelContacts_args args = new getSimpleChannelContacts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSimpleChannelContacts_result result = new getSimpleChannelContacts_result();
    try {
      result.success = await iface_.getSimpleChannelContacts(args.ids, args.statusSticonFallbackDisabled);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getSimpleChannelContacts");
      oprot.writeMessageBegin(new TMessage("getSimpleChannelContacts", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getSimpleChannelContacts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getUserLastSentMessageTimeStamp(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserLastSentMessageTimeStamp_args args = new getUserLastSentMessageTimeStamp_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserLastSentMessageTimeStamp_result result = new getUserLastSentMessageTimeStamp_result();
    try {
      result.success = await iface_.getUserLastSentMessageTimeStamp(args.mid);
    } on TalkException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing getUserLastSentMessageTimeStamp");
      oprot.writeMessageBegin(new TMessage("getUserLastSentMessageTimeStamp", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("getUserLastSentMessageTimeStamp", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class getUserStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserStatus_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 1);

  String _mid;
  static const int MID = 1;


  getUserStatus_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserStatus_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserStatus_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I32, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getUserStatus_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserStatus_result(");

    ret.write("success:");
    String success_name = UserStatus.VALUES_TO_NAMES[this.success];
    if (success_name != null) {
      ret.write(success_name);
      ret.write(" (");
    }
    ret.write(this.success);
    if (success_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetSuccess() && !UserStatus.VALID_VALUES.contains(success)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'success' has been assigned the invalid value $success");
    }
  }

}

class updateProfileAttributeForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfileAttributeForChannel_args");
  static final TField _PROFILE_ATTRIBUTE_FIELD_DESC = new TField("profileAttribute", TType.I32, 2);
  static final TField _VALUE_FIELD_DESC = new TField("value", TType.STRING, 3);

  int _profileAttribute;
  static const int PROFILEATTRIBUTE = 2;
  String _value;
  static const int VALUE = 3;

  bool __isset_profileAttribute = false;

  updateProfileAttributeForChannel_args() {
  }

  // profileAttribute
  int get profileAttribute => this._profileAttribute;

  set profileAttribute(int profileAttribute) {
    this._profileAttribute = profileAttribute;
    this.__isset_profileAttribute = true;
  }

  bool isSetProfileAttribute() => this.__isset_profileAttribute;

  unsetProfileAttribute() {
    this.__isset_profileAttribute = false;
  }

  // value
  String get value => this._value;

  set value(String value) {
    this._value = value;
  }

  bool isSetValue() => this.value != null;

  unsetValue() {
    this.value = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PROFILEATTRIBUTE:
        return this.profileAttribute;
      case VALUE:
        return this.value;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PROFILEATTRIBUTE:
        if (value == null) {
          unsetProfileAttribute();
        } else {
          this.profileAttribute = value;
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          this.value = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PROFILEATTRIBUTE:
        return isSetProfileAttribute();
      case VALUE:
        return isSetValue();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PROFILEATTRIBUTE:
          if (field.type == TType.I32) {
            this.profileAttribute = iprot.readI32();
            this.__isset_profileAttribute = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PROFILE_ATTRIBUTE_FIELD_DESC);
    oprot.writeI32(this.profileAttribute);
    oprot.writeFieldEnd();
    if (this.value != null) {
      oprot.writeFieldBegin(_VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfileAttributeForChannel_args(");

    ret.write("profileAttribute:");
    String profileAttribute_name = ProfileAttribute.VALUES_TO_NAMES[this.profileAttribute];
    if (profileAttribute_name != null) {
      ret.write(profileAttribute_name);
      ret.write(" (");
    }
    ret.write(this.profileAttribute);
    if (profileAttribute_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("value:");
    if (this.value == null) {
      ret.write("null");
    } else {
      ret.write(this.value);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetProfileAttribute() && !ProfileAttribute.VALID_VALUES.contains(profileAttribute)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'profileAttribute' has been assigned the invalid value $profileAttribute");
    }
  }

}

class updateProfileAttributeForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateProfileAttributeForChannel_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateProfileAttributeForChannel_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateProfileAttributeForChannel_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateExtendedProfileAttribute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateExtendedProfileAttribute_args");
  static final TField _ATTR_FIELD_DESC = new TField("attr", TType.I32, 1);
  static final TField _EXTENDED_PROFILE_FIELD_DESC = new TField("extendedProfile", TType.STRUCT, 2);

  int _attr;
  static const int ATTR = 1;
  ExtendedProfile _extendedProfile;
  static const int EXTENDEDPROFILE = 2;

  bool __isset_attr = false;

  updateExtendedProfileAttribute_args() {
  }

  // attr
  int get attr => this._attr;

  set attr(int attr) {
    this._attr = attr;
    this.__isset_attr = true;
  }

  bool isSetAttr() => this.__isset_attr;

  unsetAttr() {
    this.__isset_attr = false;
  }

  // extendedProfile
  ExtendedProfile get extendedProfile => this._extendedProfile;

  set extendedProfile(ExtendedProfile extendedProfile) {
    this._extendedProfile = extendedProfile;
  }

  bool isSetExtendedProfile() => this.extendedProfile != null;

  unsetExtendedProfile() {
    this.extendedProfile = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ATTR:
        return this.attr;
      case EXTENDEDPROFILE:
        return this.extendedProfile;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ATTR:
        if (value == null) {
          unsetAttr();
        } else {
          this.attr = value;
        }
        break;

      case EXTENDEDPROFILE:
        if (value == null) {
          unsetExtendedProfile();
        } else {
          this.extendedProfile = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ATTR:
        return isSetAttr();
      case EXTENDEDPROFILE:
        return isSetExtendedProfile();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ATTR:
          if (field.type == TType.I32) {
            this.attr = iprot.readI32();
            this.__isset_attr = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EXTENDEDPROFILE:
          if (field.type == TType.STRUCT) {
            this.extendedProfile = new ExtendedProfile();
            this.extendedProfile.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ATTR_FIELD_DESC);
    oprot.writeI32(this.attr);
    oprot.writeFieldEnd();
    if (this.extendedProfile != null) {
      oprot.writeFieldBegin(_EXTENDED_PROFILE_FIELD_DESC);
      this.extendedProfile.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateExtendedProfileAttribute_args(");

    ret.write("attr:");
    String attr_name = ExtendedProfileAttribute.VALUES_TO_NAMES[this.attr];
    if (attr_name != null) {
      ret.write(attr_name);
      ret.write(" (");
    }
    ret.write(this.attr);
    if (attr_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("extendedProfile:");
    if (this.extendedProfile == null) {
      ret.write("null");
    } else {
      ret.write(this.extendedProfile);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAttr() && !ExtendedProfileAttribute.VALID_VALUES.contains(attr)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'attr' has been assigned the invalid value $attr");
    }
  }

}

class updateExtendedProfileAttribute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateExtendedProfileAttribute_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  updateExtendedProfileAttribute_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateExtendedProfileAttribute_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllSimpleChannelContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllSimpleChannelContacts_args");
  static final TField _STATUS_STICON_FALLBACK_DISABLED_FIELD_DESC = new TField("statusSticonFallbackDisabled", TType.BOOL, 1);

  bool _statusSticonFallbackDisabled = false;
  static const int STATUSSTICONFALLBACKDISABLED = 1;

  bool __isset_statusSticonFallbackDisabled = false;

  getAllSimpleChannelContacts_args() {
  }

  // statusSticonFallbackDisabled
  bool get statusSticonFallbackDisabled => this._statusSticonFallbackDisabled;

  set statusSticonFallbackDisabled(bool statusSticonFallbackDisabled) {
    this._statusSticonFallbackDisabled = statusSticonFallbackDisabled;
    this.__isset_statusSticonFallbackDisabled = true;
  }

  bool isSetStatusSticonFallbackDisabled() => this.__isset_statusSticonFallbackDisabled;

  unsetStatusSticonFallbackDisabled() {
    this.__isset_statusSticonFallbackDisabled = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case STATUSSTICONFALLBACKDISABLED:
        return this.statusSticonFallbackDisabled;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case STATUSSTICONFALLBACKDISABLED:
        if (value == null) {
          unsetStatusSticonFallbackDisabled();
        } else {
          this.statusSticonFallbackDisabled = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case STATUSSTICONFALLBACKDISABLED:
        return isSetStatusSticonFallbackDisabled();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case STATUSSTICONFALLBACKDISABLED:
          if (field.type == TType.BOOL) {
            this.statusSticonFallbackDisabled = iprot.readBool();
            this.__isset_statusSticonFallbackDisabled = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_STATUS_STICON_FALLBACK_DISABLED_FIELD_DESC);
    oprot.writeBool(this.statusSticonFallbackDisabled);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllSimpleChannelContacts_args(");

    ret.write("statusSticonFallbackDisabled:");
    ret.write(this.statusSticonFallbackDisabled);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllSimpleChannelContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllSimpleChannelContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SimpleChannelContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAllSimpleChannelContacts_result() {
  }

  // success
  List<SimpleChannelContact> get success => this._success;

  set success(List<SimpleChannelContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1342 = iprot.readListBegin();
              this.success = new List<SimpleChannelContact>();
              for (int _i1343 = 0; _i1343 < _list1342.length; ++_i1343) {
                SimpleChannelContact _elem1344;
                _elem1344 = new SimpleChannelContact();
                _elem1344.read(iprot);
                this.success.add(_elem1344);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1345 in this.success) {
          elem1345.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllSimpleChannelContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserIdentities_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserIdentities_args");



  getUserIdentities_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserIdentities_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserIdentities_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserIdentities_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<int, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserIdentities_result() {
  }

  // success
  Map<int, String> get success => this._success;

  set success(Map<int, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1346 = iprot.readMapBegin();
              this.success = new Map<int, String>();
              for (int _i1347 = 0; _i1347 < _map1346.length; ++_i1347) {
                int _key1348;
                String _val1349;
                _key1348 = iprot.readI32();
                _val1349 = iprot.readString();
                this.success[_key1348] = _val1349;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, this.success.length));
        for (var elem1351 in this.success.keys) {
          oprot.writeI32(elem1351);
          oprot.writeString(this.success[elem1351]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserIdentities_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class markPaidCallAd_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("markPaidCallAd_args");
  static final TField _DIALED_NUMBER_FIELD_DESC = new TField("dialedNumber", TType.STRING, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _DISABLE_CALLER_ID_FIELD_DESC = new TField("disableCallerId", TType.BOOL, 4);

  String _dialedNumber;
  static const int DIALEDNUMBER = 2;
  String _language;
  static const int LANGUAGE = 3;
  bool _disableCallerId = false;
  static const int DISABLECALLERID = 4;

  bool __isset_disableCallerId = false;

  markPaidCallAd_args() {
  }

  // dialedNumber
  String get dialedNumber => this._dialedNumber;

  set dialedNumber(String dialedNumber) {
    this._dialedNumber = dialedNumber;
  }

  bool isSetDialedNumber() => this.dialedNumber != null;

  unsetDialedNumber() {
    this.dialedNumber = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // disableCallerId
  bool get disableCallerId => this._disableCallerId;

  set disableCallerId(bool disableCallerId) {
    this._disableCallerId = disableCallerId;
    this.__isset_disableCallerId = true;
  }

  bool isSetDisableCallerId() => this.__isset_disableCallerId;

  unsetDisableCallerId() {
    this.__isset_disableCallerId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case DIALEDNUMBER:
        return this.dialedNumber;
      case LANGUAGE:
        return this.language;
      case DISABLECALLERID:
        return this.disableCallerId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case DIALEDNUMBER:
        if (value == null) {
          unsetDialedNumber();
        } else {
          this.dialedNumber = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case DISABLECALLERID:
        if (value == null) {
          unsetDisableCallerId();
        } else {
          this.disableCallerId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case DIALEDNUMBER:
        return isSetDialedNumber();
      case LANGUAGE:
        return isSetLanguage();
      case DISABLECALLERID:
        return isSetDisableCallerId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DIALEDNUMBER:
          if (field.type == TType.STRING) {
            this.dialedNumber = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DISABLECALLERID:
          if (field.type == TType.BOOL) {
            this.disableCallerId = iprot.readBool();
            this.__isset_disableCallerId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.dialedNumber != null) {
      oprot.writeFieldBegin(_DIALED_NUMBER_FIELD_DESC);
      oprot.writeString(this.dialedNumber);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_DISABLE_CALLER_ID_FIELD_DESC);
    oprot.writeBool(this.disableCallerId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("markPaidCallAd_args(");

    ret.write("dialedNumber:");
    if (this.dialedNumber == null) {
      ret.write("null");
    } else {
      ret.write(this.dialedNumber);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("disableCallerId:");
    ret.write(this.disableCallerId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class markPaidCallAd_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("markPaidCallAd_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallDialing _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  markPaidCallAd_result() {
  }

  // success
  PaidCallDialing get success => this._success;

  set success(PaidCallDialing success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallDialing();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("markPaidCallAd_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isGroupMember_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isGroupMember_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 1);

  String _groupId;
  static const int GROUPID = 1;


  isGroupMember_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isGroupMember_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isGroupMember_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isGroupMember_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isGroupMember_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isGroupMember_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPhoneInfoFromPhoneNumber_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPhoneInfoFromPhoneNumber_args");
  static final TField _REGION_FIELD_DESC = new TField("region", TType.STRING, 1);
  static final TField _PHONE_NUMBER_FIELD_DESC = new TField("phoneNumber", TType.STRING, 2);

  String _region;
  static const int REGION = 1;
  String _phoneNumber;
  static const int PHONENUMBER = 2;


  getPhoneInfoFromPhoneNumber_args() {
  }

  // region
  String get region => this._region;

  set region(String region) {
    this._region = region;
  }

  bool isSetRegion() => this.region != null;

  unsetRegion() {
    this.region = null;
  }

  // phoneNumber
  String get phoneNumber => this._phoneNumber;

  set phoneNumber(String phoneNumber) {
    this._phoneNumber = phoneNumber;
  }

  bool isSetPhoneNumber() => this.phoneNumber != null;

  unsetPhoneNumber() {
    this.phoneNumber = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REGION:
        return this.region;
      case PHONENUMBER:
        return this.phoneNumber;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REGION:
        if (value == null) {
          unsetRegion();
        } else {
          this.region = value;
        }
        break;

      case PHONENUMBER:
        if (value == null) {
          unsetPhoneNumber();
        } else {
          this.phoneNumber = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REGION:
        return isSetRegion();
      case PHONENUMBER:
        return isSetPhoneNumber();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REGION:
          if (field.type == TType.STRING) {
            this.region = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PHONENUMBER:
          if (field.type == TType.STRING) {
            this.phoneNumber = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.region != null) {
      oprot.writeFieldBegin(_REGION_FIELD_DESC);
      oprot.writeString(this.region);
      oprot.writeFieldEnd();
    }
    if (this.phoneNumber != null) {
      oprot.writeFieldBegin(_PHONE_NUMBER_FIELD_DESC);
      oprot.writeString(this.phoneNumber);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPhoneInfoFromPhoneNumber_args(");

    ret.write("region:");
    if (this.region == null) {
      ret.write("null");
    } else {
      ret.write(this.region);
    }

    ret.write(", ");
    ret.write("phoneNumber:");
    if (this.phoneNumber == null) {
      ret.write("null");
    } else {
      ret.write(this.phoneNumber);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPhoneInfoFromPhoneNumber_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPhoneInfoFromPhoneNumber_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PhoneInfoForChannel _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPhoneInfoFromPhoneNumber_result() {
  }

  // success
  PhoneInfoForChannel get success => this._success;

  set success(PhoneInfoForChannel success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PhoneInfoForChannel();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPhoneInfoFromPhoneNumber_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class redeemPaidCallVoucher_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("redeemPaidCallVoucher_args");
  static final TField _SERIAL_FIELD_DESC = new TField("serial", TType.STRING, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);

  String _serial;
  static const int SERIAL = 2;
  String _language;
  static const int LANGUAGE = 3;


  redeemPaidCallVoucher_args() {
  }

  // serial
  String get serial => this._serial;

  set serial(String serial) {
    this._serial = serial;
  }

  bool isSetSerial() => this.serial != null;

  unsetSerial() {
    this.serial = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SERIAL:
        return this.serial;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SERIAL:
        if (value == null) {
          unsetSerial();
        } else {
          this.serial = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SERIAL:
        return isSetSerial();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SERIAL:
          if (field.type == TType.STRING) {
            this.serial = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.serial != null) {
      oprot.writeFieldBegin(_SERIAL_FIELD_DESC);
      oprot.writeString(this.serial);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("redeemPaidCallVoucher_args(");

    ret.write("serial:");
    if (this.serial == null) {
      ret.write("null");
    } else {
      ret.write(this.serial);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class redeemPaidCallVoucher_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("redeemPaidCallVoucher_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallRedeemResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  redeemPaidCallVoucher_result() {
  }

  // success
  PaidCallRedeemResult get success => this._success;

  set success(PaidCallRedeemResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallRedeemResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("redeemPaidCallVoucher_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreferredDisplayName_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreferredDisplayName_args");
  static final TField _MIDS_FIELD_DESC = new TField("mids", TType.LIST, 1);

  List<String> _mids;
  static const int MIDS = 1;


  getPreferredDisplayName_args() {
  }

  // mids
  List<String> get mids => this._mids;

  set mids(List<String> mids) {
    this._mids = mids;
  }

  bool isSetMids() => this.mids != null;

  unsetMids() {
    this.mids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MIDS:
        return this.mids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MIDS:
        if (value == null) {
          unsetMids();
        } else {
          this.mids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MIDS:
        return isSetMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1352 = iprot.readListBegin();
              this.mids = new List<String>();
              for (int _i1353 = 0; _i1353 < _list1352.length; ++_i1353) {
                String _elem1354;
                _elem1354 = iprot.readString();
                this.mids.add(_elem1354);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mids != null) {
      oprot.writeFieldBegin(_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.mids.length));
        for (var elem1355 in this.mids) {
          oprot.writeString(elem1355);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreferredDisplayName_args(");

    ret.write("mids:");
    if (this.mids == null) {
      ret.write("null");
    } else {
      ret.write(this.mids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPreferredDisplayName_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPreferredDisplayName_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPreferredDisplayName_result() {
  }

  // success
  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1356 = iprot.readMapBegin();
              this.success = new Map<String, String>();
              for (int _i1357 = 0; _i1357 < _map1356.length; ++_i1357) {
                String _key1358;
                String _val1359;
                _key1358 = iprot.readString();
                _val1359 = iprot.readString();
                this.success[_key1358] = _val1359;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.length));
        for (var elem1361 in this.success.keys) {
          oprot.writeString(elem1361);
          oprot.writeString(this.success[elem1361]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPreferredDisplayName_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContactsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContactsForChannel_args");
  static final TField _IDS_FIELD_DESC = new TField("ids", TType.LIST, 2);

  List<String> _ids;
  static const int IDS = 2;


  getContactsForChannel_args() {
  }

  // ids
  List<String> get ids => this._ids;

  set ids(List<String> ids) {
    this._ids = ids;
  }

  bool isSetIds() => this.ids != null;

  unsetIds() {
    this.ids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDS:
        return this.ids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDS:
        if (value == null) {
          unsetIds();
        } else {
          this.ids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDS:
        return isSetIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDS:
          if (field.type == TType.LIST) {
            {
              TList _list1362 = iprot.readListBegin();
              this.ids = new List<String>();
              for (int _i1363 = 0; _i1363 < _list1362.length; ++_i1363) {
                String _elem1364;
                _elem1364 = iprot.readString();
                this.ids.add(_elem1364);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ids != null) {
      oprot.writeFieldBegin(_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.ids.length));
        for (var elem1365 in this.ids) {
          oprot.writeString(elem1365);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContactsForChannel_args(");

    ret.write("ids:");
    if (this.ids == null) {
      ret.write("null");
    } else {
      ret.write(this.ids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getContactsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getContactsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Contact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getContactsForChannel_result() {
  }

  // success
  List<Contact> get success => this._success;

  set success(List<Contact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1366 = iprot.readListBegin();
              this.success = new List<Contact>();
              for (int _i1367 = 0; _i1367 < _list1366.length; ++_i1367) {
                Contact _elem1368;
                _elem1368 = new Contact();
                _elem1368.read(iprot);
                this.success.add(_elem1368);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1369 in this.success) {
          elem1369.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getContactsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCallCreditProducts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCallCreditProducts_args");
  static final TField _APP_STORE_CODE_FIELD_DESC = new TField("appStoreCode", TType.I32, 2);
  static final TField _PG_CODE_FIELD_DESC = new TField("pgCode", TType.I32, 3);
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 4);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 5);

  int _appStoreCode;
  static const int APPSTORECODE = 2;
  int _pgCode;
  static const int PGCODE = 3;
  String _country;
  static const int COUNTRY = 4;
  String _language;
  static const int LANGUAGE = 5;

  bool __isset_appStoreCode = false;
  bool __isset_pgCode = false;

  getCallCreditProducts_args() {
  }

  // appStoreCode
  int get appStoreCode => this._appStoreCode;

  set appStoreCode(int appStoreCode) {
    this._appStoreCode = appStoreCode;
    this.__isset_appStoreCode = true;
  }

  bool isSetAppStoreCode() => this.__isset_appStoreCode;

  unsetAppStoreCode() {
    this.__isset_appStoreCode = false;
  }

  // pgCode
  int get pgCode => this._pgCode;

  set pgCode(int pgCode) {
    this._pgCode = pgCode;
    this.__isset_pgCode = true;
  }

  bool isSetPgCode() => this.__isset_pgCode;

  unsetPgCode() {
    this.__isset_pgCode = false;
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return this.appStoreCode;
      case PGCODE:
        return this.pgCode;
      case COUNTRY:
        return this.country;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case APPSTORECODE:
        if (value == null) {
          unsetAppStoreCode();
        } else {
          this.appStoreCode = value;
        }
        break;

      case PGCODE:
        if (value == null) {
          unsetPgCode();
        } else {
          this.pgCode = value;
        }
        break;

      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case APPSTORECODE:
        return isSetAppStoreCode();
      case PGCODE:
        return isSetPgCode();
      case COUNTRY:
        return isSetCountry();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case APPSTORECODE:
          if (field.type == TType.I32) {
            this.appStoreCode = iprot.readI32();
            this.__isset_appStoreCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PGCODE:
          if (field.type == TType.I32) {
            this.pgCode = iprot.readI32();
            this.__isset_pgCode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_APP_STORE_CODE_FIELD_DESC);
    oprot.writeI32(this.appStoreCode);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_PG_CODE_FIELD_DESC);
    oprot.writeI32(this.pgCode);
    oprot.writeFieldEnd();
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCallCreditProducts_args(");

    ret.write("appStoreCode:");
    String appStoreCode_name = PaymentType.VALUES_TO_NAMES[this.appStoreCode];
    if (appStoreCode_name != null) {
      ret.write(appStoreCode_name);
      ret.write(" (");
    }
    ret.write(this.appStoreCode);
    if (appStoreCode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("pgCode:");
    String pgCode_name = PaymentPgType.VALUES_TO_NAMES[this.pgCode];
    if (pgCode_name != null) {
      ret.write(pgCode_name);
      ret.write(" (");
    }
    ret.write(this.pgCode);
    if (pgCode_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetAppStoreCode() && !PaymentType.VALID_VALUES.contains(appStoreCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'appStoreCode' has been assigned the invalid value $appStoreCode");
    }
    if (isSetPgCode() && !PaymentPgType.VALID_VALUES.contains(pgCode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'pgCode' has been assigned the invalid value $pgCode");
    }
  }

}

class getCallCreditProducts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCallCreditProducts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<CoinProductItem> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCallCreditProducts_result() {
  }

  // success
  List<CoinProductItem> get success => this._success;

  set success(List<CoinProductItem> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1370 = iprot.readListBegin();
              this.success = new List<CoinProductItem>();
              for (int _i1371 = 0; _i1371 < _list1370.length; ++_i1371) {
                CoinProductItem _elem1372;
                _elem1372 = new CoinProductItem();
                _elem1372.read(iprot);
                this.success.add(_elem1372);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1373 in this.success) {
          elem1373.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCallCreditProducts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactContacts_args");
  static final TField _LAST_MODIFIED_TIMESTAMP_FIELD_DESC = new TField("lastModifiedTimestamp", TType.I64, 2);

  int _lastModifiedTimestamp = 0;
  static const int LASTMODIFIEDTIMESTAMP = 2;

  bool __isset_lastModifiedTimestamp = false;

  getCompactContacts_args() {
  }

  // lastModifiedTimestamp
  int get lastModifiedTimestamp => this._lastModifiedTimestamp;

  set lastModifiedTimestamp(int lastModifiedTimestamp) {
    this._lastModifiedTimestamp = lastModifiedTimestamp;
    this.__isset_lastModifiedTimestamp = true;
  }

  bool isSetLastModifiedTimestamp() => this.__isset_lastModifiedTimestamp;

  unsetLastModifiedTimestamp() {
    this.__isset_lastModifiedTimestamp = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LASTMODIFIEDTIMESTAMP:
        return this.lastModifiedTimestamp;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LASTMODIFIEDTIMESTAMP:
        if (value == null) {
          unsetLastModifiedTimestamp();
        } else {
          this.lastModifiedTimestamp = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LASTMODIFIEDTIMESTAMP:
        return isSetLastModifiedTimestamp();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LASTMODIFIEDTIMESTAMP:
          if (field.type == TType.I64) {
            this.lastModifiedTimestamp = iprot.readI64();
            this.__isset_lastModifiedTimestamp = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_LAST_MODIFIED_TIMESTAMP_FIELD_DESC);
    oprot.writeI64(this.lastModifiedTimestamp);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactContacts_args(");

    ret.write("lastModifiedTimestamp:");
    ret.write(this.lastModifiedTimestamp);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCompactContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCompactContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<CompactContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCompactContacts_result() {
  }

  // success
  List<CompactContact> get success => this._success;

  set success(List<CompactContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1374 = iprot.readListBegin();
              this.success = new List<CompactContact>();
              for (int _i1375 = 0; _i1375 < _list1374.length; ++_i1375) {
                CompactContact _elem1376;
                _elem1376 = new CompactContact();
                _elem1376.read(iprot);
                this.success.add(_elem1376);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1377 in this.success) {
          elem1377.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCompactContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyNotiCenterEvent_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyNotiCenterEvent_args");
  static final TField _EVENT_FIELD_DESC = new TField("event", TType.STRUCT, 1);

  NotiCenterEventData _event;
  static const int EVENT = 1;


  notifyNotiCenterEvent_args() {
  }

  // event
  NotiCenterEventData get event => this._event;

  set event(NotiCenterEventData event) {
    this._event = event;
  }

  bool isSetEvent() => this.event != null;

  unsetEvent() {
    this.event = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case EVENT:
        return this.event;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case EVENT:
        if (value == null) {
          unsetEvent();
        } else {
          this.event = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case EVENT:
        return isSetEvent();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EVENT:
          if (field.type == TType.STRUCT) {
            this.event = new NotiCenterEventData();
            this.event.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.event != null) {
      oprot.writeFieldBegin(_EVENT_FIELD_DESC);
      this.event.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyNotiCenterEvent_args(");

    ret.write("event:");
    if (this.event == null) {
      ret.write("null");
    } else {
      ret.write(this.event);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class notifyNotiCenterEvent_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("notifyNotiCenterEvent_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  notifyNotiCenterEvent_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("notifyNotiCenterEvent_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isInContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isInContact_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);

  String _mid;
  static const int MID = 2;


  isInContact_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isInContact_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isInContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isInContact_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isInContact_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isInContact_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupGroupMembers_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupGroupMembers_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 1);
  static final TField _MIDS_FIELD_DESC = new TField("mids", TType.LIST, 2);

  String _groupId;
  static const int GROUPID = 1;
  List<String> _mids;
  static const int MIDS = 2;


  lookupGroupMembers_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  // mids
  List<String> get mids => this._mids;

  set mids(List<String> mids) {
    this._mids = mids;
  }

  bool isSetMids() => this.mids != null;

  unsetMids() {
    this.mids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      case MIDS:
        return this.mids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      case MIDS:
        if (value == null) {
          unsetMids();
        } else {
          this.mids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      case MIDS:
        return isSetMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1378 = iprot.readListBegin();
              this.mids = new List<String>();
              for (int _i1379 = 0; _i1379 < _list1378.length; ++_i1379) {
                String _elem1380;
                _elem1380 = iprot.readString();
                this.mids.add(_elem1380);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    if (this.mids != null) {
      oprot.writeFieldBegin(_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.mids.length));
        for (var elem1381 in this.mids) {
          oprot.writeString(elem1381);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupGroupMembers_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(", ");
    ret.write("mids:");
    if (this.mids == null) {
      ret.write("null");
    } else {
      ret.write(this.mids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupGroupMembers_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupGroupMembers_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SimpleChannelContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  lookupGroupMembers_result() {
  }

  // success
  List<SimpleChannelContact> get success => this._success;

  set success(List<SimpleChannelContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1382 = iprot.readListBegin();
              this.success = new List<SimpleChannelContact>();
              for (int _i1383 = 0; _i1383 < _list1382.length; ++_i1383) {
                SimpleChannelContact _elem1384;
                _elem1384 = new SimpleChannelContact();
                _elem1384.read(iprot);
                this.success.add(_elem1384);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1385 in this.success) {
          elem1385.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupGroupMembers_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoomInformation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoomInformation_args");
  static final TField _ROOM_MID_FIELD_DESC = new TField("roomMid", TType.STRING, 1);

  String _roomMid;
  static const int ROOMMID = 1;


  getRoomInformation_args() {
  }

  // roomMid
  String get roomMid => this._roomMid;

  set roomMid(String roomMid) {
    this._roomMid = roomMid;
  }

  bool isSetRoomMid() => this.roomMid != null;

  unsetRoomMid() {
    this.roomMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMMID:
        return this.roomMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMMID:
        if (value == null) {
          unsetRoomMid();
        } else {
          this.roomMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMMID:
        return isSetRoomMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMMID:
          if (field.type == TType.STRING) {
            this.roomMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomMid != null) {
      oprot.writeFieldBegin(_ROOM_MID_FIELD_DESC);
      oprot.writeString(this.roomMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoomInformation_args(");

    ret.write("roomMid:");
    if (this.roomMid == null) {
      ret.write("null");
    } else {
      ret.write(this.roomMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoomInformation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoomInformation_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRoomInformation_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoomInformation_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupCall_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupCall_args");
  static final TField _CHAT_MID_FIELD_DESC = new TField("chatMid", TType.STRING, 2);

  String _chatMid;
  static const int CHATMID = 2;


  getGroupCall_args() {
  }

  // chatMid
  String get chatMid => this._chatMid;

  set chatMid(String chatMid) {
    this._chatMid = chatMid;
  }

  bool isSetChatMid() => this.chatMid != null;

  unsetChatMid() {
    this.chatMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return this.chatMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATMID:
        if (value == null) {
          unsetChatMid();
        } else {
          this.chatMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return isSetChatMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATMID:
          if (field.type == TType.STRING) {
            this.chatMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatMid != null) {
      oprot.writeFieldBegin(_CHAT_MID_FIELD_DESC);
      oprot.writeString(this.chatMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupCall_args(");

    ret.write("chatMid:");
    if (this.chatMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupCall_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupCall_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  GroupCall _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupCall_result() {
  }

  // success
  GroupCall get success => this._success;

  set success(GroupCall success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GroupCall();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupCall_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isAllowSecondaryDeviceLogin_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isAllowSecondaryDeviceLogin_args");



  isAllowSecondaryDeviceLogin_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isAllowSecondaryDeviceLogin_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isAllowSecondaryDeviceLogin_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isAllowSecondaryDeviceLogin_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isAllowSecondaryDeviceLogin_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isAllowSecondaryDeviceLogin_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPrimaryClientForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPrimaryClientForChannel_args");



  getPrimaryClientForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPrimaryClientForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPrimaryClientForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPrimaryClientForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  SimpleChannelClient _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPrimaryClientForChannel_result() {
  }

  // success
  SimpleChannelClient get success => this._success;

  set success(SimpleChannelClient success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SimpleChannelClient();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPrimaryClientForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoomWithBuddy_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoomWithBuddy_args");
  static final TField _REQ_SEQ_FIELD_DESC = new TField("reqSeq", TType.I32, 1);
  static final TField _BUDDY_MID_FIELD_DESC = new TField("buddyMid", TType.STRING, 2);
  static final TField _CONTACT_IDS_FIELD_DESC = new TField("contactIds", TType.LIST, 3);

  int _reqSeq = 0;
  static const int REQSEQ = 1;
  String _buddyMid;
  static const int BUDDYMID = 2;
  List<String> _contactIds;
  static const int CONTACTIDS = 3;

  bool __isset_reqSeq = false;

  createRoomWithBuddy_args() {
  }

  // reqSeq
  int get reqSeq => this._reqSeq;

  set reqSeq(int reqSeq) {
    this._reqSeq = reqSeq;
    this.__isset_reqSeq = true;
  }

  bool isSetReqSeq() => this.__isset_reqSeq;

  unsetReqSeq() {
    this.__isset_reqSeq = false;
  }

  // buddyMid
  String get buddyMid => this._buddyMid;

  set buddyMid(String buddyMid) {
    this._buddyMid = buddyMid;
  }

  bool isSetBuddyMid() => this.buddyMid != null;

  unsetBuddyMid() {
    this.buddyMid = null;
  }

  // contactIds
  List<String> get contactIds => this._contactIds;

  set contactIds(List<String> contactIds) {
    this._contactIds = contactIds;
  }

  bool isSetContactIds() => this.contactIds != null;

  unsetContactIds() {
    this.contactIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return this.reqSeq;
      case BUDDYMID:
        return this.buddyMid;
      case CONTACTIDS:
        return this.contactIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQSEQ:
        if (value == null) {
          unsetReqSeq();
        } else {
          this.reqSeq = value;
        }
        break;

      case BUDDYMID:
        if (value == null) {
          unsetBuddyMid();
        } else {
          this.buddyMid = value;
        }
        break;

      case CONTACTIDS:
        if (value == null) {
          unsetContactIds();
        } else {
          this.contactIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQSEQ:
        return isSetReqSeq();
      case BUDDYMID:
        return isSetBuddyMid();
      case CONTACTIDS:
        return isSetContactIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQSEQ:
          if (field.type == TType.I32) {
            this.reqSeq = iprot.readI32();
            this.__isset_reqSeq = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case BUDDYMID:
          if (field.type == TType.STRING) {
            this.buddyMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTACTIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1386 = iprot.readListBegin();
              this.contactIds = new List<String>();
              for (int _i1387 = 0; _i1387 < _list1386.length; ++_i1387) {
                String _elem1388;
                _elem1388 = iprot.readString();
                this.contactIds.add(_elem1388);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQ_SEQ_FIELD_DESC);
    oprot.writeI32(this.reqSeq);
    oprot.writeFieldEnd();
    if (this.buddyMid != null) {
      oprot.writeFieldBegin(_BUDDY_MID_FIELD_DESC);
      oprot.writeString(this.buddyMid);
      oprot.writeFieldEnd();
    }
    if (this.contactIds != null) {
      oprot.writeFieldBegin(_CONTACT_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.contactIds.length));
        for (var elem1389 in this.contactIds) {
          oprot.writeString(elem1389);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoomWithBuddy_args(");

    ret.write("reqSeq:");
    ret.write(this.reqSeq);

    ret.write(", ");
    ret.write("buddyMid:");
    if (this.buddyMid == null) {
      ret.write("null");
    } else {
      ret.write(this.buddyMid);
    }

    ret.write(", ");
    ret.write("contactIds:");
    if (this.contactIds == null) {
      ret.write("null");
    } else {
      ret.write(this.contactIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createRoomWithBuddy_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createRoomWithBuddy_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Room _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  createRoomWithBuddy_result() {
  }

  // success
  Room get success => this._success;

  set success(Room success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Room();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createRoomWithBuddy_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDisplayName_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDisplayName_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 2);

  String _mid;
  static const int MID = 2;


  getDisplayName_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDisplayName_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDisplayName_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getDisplayName_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getDisplayName_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getDisplayName_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallMetadata_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallMetadata_args");
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 2);

  String _language;
  static const int LANGUAGE = 2;


  getPaidCallMetadata_args() {
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallMetadata_args(");

    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallMetadata_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallMetadata_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallMetadataResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPaidCallMetadata_result() {
  }

  // success
  PaidCallMetadataResult get success => this._success;

  set success(PaidCallMetadataResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallMetadataResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallMetadata_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMid_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMid_args");



  getMid_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMid_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMid_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMid_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMid_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMid_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserCountryForBilling_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserCountryForBilling_args");
  static final TField _COUNTRY_FIELD_DESC = new TField("country", TType.STRING, 2);
  static final TField _REMOTE_IP_FIELD_DESC = new TField("remoteIp", TType.STRING, 3);

  String _country;
  static const int COUNTRY = 2;
  String _remoteIp;
  static const int REMOTEIP = 3;


  getUserCountryForBilling_args() {
  }

  // country
  String get country => this._country;

  set country(String country) {
    this._country = country;
  }

  bool isSetCountry() => this.country != null;

  unsetCountry() {
    this.country = null;
  }

  // remoteIp
  String get remoteIp => this._remoteIp;

  set remoteIp(String remoteIp) {
    this._remoteIp = remoteIp;
  }

  bool isSetRemoteIp() => this.remoteIp != null;

  unsetRemoteIp() {
    this.remoteIp = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case COUNTRY:
        return this.country;
      case REMOTEIP:
        return this.remoteIp;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case COUNTRY:
        if (value == null) {
          unsetCountry();
        } else {
          this.country = value;
        }
        break;

      case REMOTEIP:
        if (value == null) {
          unsetRemoteIp();
        } else {
          this.remoteIp = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case COUNTRY:
        return isSetCountry();
      case REMOTEIP:
        return isSetRemoteIp();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case COUNTRY:
          if (field.type == TType.STRING) {
            this.country = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REMOTEIP:
          if (field.type == TType.STRING) {
            this.remoteIp = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.country != null) {
      oprot.writeFieldBegin(_COUNTRY_FIELD_DESC);
      oprot.writeString(this.country);
      oprot.writeFieldEnd();
    }
    if (this.remoteIp != null) {
      oprot.writeFieldBegin(_REMOTE_IP_FIELD_DESC);
      oprot.writeString(this.remoteIp);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserCountryForBilling_args(");

    ret.write("country:");
    if (this.country == null) {
      ret.write("null");
    } else {
      ret.write(this.country);
    }

    ret.write(", ");
    ret.write("remoteIp:");
    if (this.remoteIp == null) {
      ret.write("null");
    } else {
      ret.write(this.remoteIp);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserCountryForBilling_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserCountryForBilling_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserCountryForBilling_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserCountryForBilling_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteGroupIdsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteGroupIdsForChannel_args");



  getFavoriteGroupIdsForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteGroupIdsForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteGroupIdsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteGroupIdsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getFavoriteGroupIdsForChannel_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1390 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1391 = 0; _i1391 < _list1390.length; ++_i1391) {
                String _elem1392;
                _elem1392 = iprot.readString();
                this.success.add(_elem1392);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1393 in this.success) {
          oprot.writeString(elem1393);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteGroupIdsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallHistory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallHistory_args");
  static final TField _START_FIELD_DESC = new TField("start", TType.I64, 2);
  static final TField _SIZE_FIELD_DESC = new TField("size", TType.I32, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);

  int _start = 0;
  static const int START = 2;
  int _size = 0;
  static const int SIZE = 3;
  String _language;
  static const int LANGUAGE = 4;

  bool __isset_start = false;
  bool __isset_size = false;

  getPaidCallHistory_args() {
  }

  // start
  int get start => this._start;

  set start(int start) {
    this._start = start;
    this.__isset_start = true;
  }

  bool isSetStart() => this.__isset_start;

  unsetStart() {
    this.__isset_start = false;
  }

  // size
  int get size => this._size;

  set size(int size) {
    this._size = size;
    this.__isset_size = true;
  }

  bool isSetSize() => this.__isset_size;

  unsetSize() {
    this.__isset_size = false;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case START:
        return this.start;
      case SIZE:
        return this.size;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case START:
        if (value == null) {
          unsetStart();
        } else {
          this.start = value;
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          this.size = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case START:
        return isSetStart();
      case SIZE:
        return isSetSize();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case START:
          if (field.type == TType.I64) {
            this.start = iprot.readI64();
            this.__isset_start = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SIZE:
          if (field.type == TType.I32) {
            this.size = iprot.readI32();
            this.__isset_size = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_START_FIELD_DESC);
    oprot.writeI64(this.start);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_SIZE_FIELD_DESC);
    oprot.writeI32(this.size);
    oprot.writeFieldEnd();
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallHistory_args(");

    ret.write("start:");
    ret.write(this.start);

    ret.write(", ");
    ret.write("size:");
    ret.write(this.size);

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallHistory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallHistory_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallHistoryResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPaidCallHistory_result() {
  }

  // success
  PaidCallHistoryResult get success => this._success;

  set success(PaidCallHistoryResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallHistoryResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallHistory_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendPinCodeOperation_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendPinCodeOperation_args");
  static final TField _VERIFIER_FIELD_DESC = new TField("verifier", TType.STRING, 1);

  String _verifier;
  static const int VERIFIER = 1;


  sendPinCodeOperation_args() {
  }

  // verifier
  String get verifier => this._verifier;

  set verifier(String verifier) {
    this._verifier = verifier;
  }

  bool isSetVerifier() => this.verifier != null;

  unsetVerifier() {
    this.verifier = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return this.verifier;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case VERIFIER:
        if (value == null) {
          unsetVerifier();
        } else {
          this.verifier = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case VERIFIER:
        return isSetVerifier();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case VERIFIER:
          if (field.type == TType.STRING) {
            this.verifier = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.verifier != null) {
      oprot.writeFieldBegin(_VERIFIER_FIELD_DESC);
      oprot.writeString(this.verifier);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendPinCodeOperation_args(");

    ret.write("verifier:");
    if (this.verifier == null) {
      ret.write("null");
    } else {
      ret.write(this.verifier);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendPinCodeOperation_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendPinCodeOperation_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  sendPinCodeOperation_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendPinCodeOperation_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class inviteIntoGroupCall_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoGroupCall_args");
  static final TField _CHAT_MID_FIELD_DESC = new TField("chatMid", TType.STRING, 2);
  static final TField _MEMBER_MIDS_FIELD_DESC = new TField("memberMids", TType.LIST, 3);
  static final TField _MEDIA_TYPE_FIELD_DESC = new TField("mediaType", TType.I32, 4);

  String _chatMid;
  static const int CHATMID = 2;
  List<String> _memberMids;
  static const int MEMBERMIDS = 3;
  int _mediaType;
  static const int MEDIATYPE = 4;

  bool __isset_mediaType = false;

  inviteIntoGroupCall_args() {
  }

  // chatMid
  String get chatMid => this._chatMid;

  set chatMid(String chatMid) {
    this._chatMid = chatMid;
  }

  bool isSetChatMid() => this.chatMid != null;

  unsetChatMid() {
    this.chatMid = null;
  }

  // memberMids
  List<String> get memberMids => this._memberMids;

  set memberMids(List<String> memberMids) {
    this._memberMids = memberMids;
  }

  bool isSetMemberMids() => this.memberMids != null;

  unsetMemberMids() {
    this.memberMids = null;
  }

  // mediaType
  int get mediaType => this._mediaType;

  set mediaType(int mediaType) {
    this._mediaType = mediaType;
    this.__isset_mediaType = true;
  }

  bool isSetMediaType() => this.__isset_mediaType;

  unsetMediaType() {
    this.__isset_mediaType = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return this.chatMid;
      case MEMBERMIDS:
        return this.memberMids;
      case MEDIATYPE:
        return this.mediaType;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATMID:
        if (value == null) {
          unsetChatMid();
        } else {
          this.chatMid = value;
        }
        break;

      case MEMBERMIDS:
        if (value == null) {
          unsetMemberMids();
        } else {
          this.memberMids = value;
        }
        break;

      case MEDIATYPE:
        if (value == null) {
          unsetMediaType();
        } else {
          this.mediaType = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return isSetChatMid();
      case MEMBERMIDS:
        return isSetMemberMids();
      case MEDIATYPE:
        return isSetMediaType();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATMID:
          if (field.type == TType.STRING) {
            this.chatMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MEMBERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1394 = iprot.readListBegin();
              this.memberMids = new List<String>();
              for (int _i1395 = 0; _i1395 < _list1394.length; ++_i1395) {
                String _elem1396;
                _elem1396 = iprot.readString();
                this.memberMids.add(_elem1396);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MEDIATYPE:
          if (field.type == TType.I32) {
            this.mediaType = iprot.readI32();
            this.__isset_mediaType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatMid != null) {
      oprot.writeFieldBegin(_CHAT_MID_FIELD_DESC);
      oprot.writeString(this.chatMid);
      oprot.writeFieldEnd();
    }
    if (this.memberMids != null) {
      oprot.writeFieldBegin(_MEMBER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.memberMids.length));
        for (var elem1397 in this.memberMids) {
          oprot.writeString(elem1397);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MEDIA_TYPE_FIELD_DESC);
    oprot.writeI32(this.mediaType);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoGroupCall_args(");

    ret.write("chatMid:");
    if (this.chatMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatMid);
    }

    ret.write(", ");
    ret.write("memberMids:");
    if (this.memberMids == null) {
      ret.write("null");
    } else {
      ret.write(this.memberMids);
    }

    ret.write(", ");
    ret.write("mediaType:");
    String mediaType_name = GroupCallMediaType.VALUES_TO_NAMES[this.mediaType];
    if (mediaType_name != null) {
      ret.write(mediaType_name);
      ret.write(" (");
    }
    ret.write(this.mediaType);
    if (mediaType_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetMediaType() && !GroupCallMediaType.VALID_VALUES.contains(mediaType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'mediaType' has been assigned the invalid value $mediaType");
    }
  }

}

class inviteIntoGroupCall_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("inviteIntoGroupCall_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  inviteIntoGroupCall_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("inviteIntoGroupCall_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFriendMids_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendMids_args");



  getFriendMids_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendMids_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFriendMids_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFriendMids_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getFriendMids_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1398 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1399 = 0; _i1399 < _list1398.length; ++_i1399) {
                String _elem1400;
                _elem1400 = iprot.readString();
                this.success.add(_elem1400);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1401 in this.success) {
          oprot.writeString(elem1401);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFriendMids_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMetaProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMetaProfile_args");



  getMetaProfile_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMetaProfile_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getMetaProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMetaProfile_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  MetaProfile _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getMetaProfile_result() {
  }

  // success
  MetaProfile get success => this._success;

  set success(MetaProfile success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new MetaProfile();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMetaProfile_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageForChannel_args");
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  Message _message;
  static const int MESSAGE = 2;


  sendMessageForChannel_args() {
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageForChannel_args(");

    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendMessageForChannel_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class activeBuddySubscriberCount_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("activeBuddySubscriberCount_args");



  activeBuddySubscriberCount_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("activeBuddySubscriberCount_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class activeBuddySubscriberCount_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("activeBuddySubscriberCount_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  activeBuddySubscriberCount_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("activeBuddySubscriberCount_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCallCreditPurchaseHistory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCallCreditPurchaseHistory_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);

  CoinHistoryCondition _request;
  static const int REQUEST = 2;


  getCallCreditPurchaseHistory_args() {
  }

  // request
  CoinHistoryCondition get request => this._request;

  set request(CoinHistoryCondition request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinHistoryCondition();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCallCreditPurchaseHistory_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getCallCreditPurchaseHistory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getCallCreditPurchaseHistory_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  CoinHistoryResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getCallCreditPurchaseHistory_result() {
  }

  // success
  CoinHistoryResult get success => this._success;

  set success(CoinHistoryResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CoinHistoryResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getCallCreditPurchaseHistory_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isRoomMember_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isRoomMember_args");
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 1);

  String _roomId;
  static const int ROOMID = 1;


  isRoomMember_args() {
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return this.roomId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return isSetRoomId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isRoomMember_args(");

    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class isRoomMember_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("isRoomMember_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  bool _success = false;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  isRoomMember_result() {
  }

  // success
  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("isRoomMember_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendSystemOAMessage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendSystemOAMessage_args");
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 1);

  Message _message;
  static const int MESSAGE = 1;


  sendSystemOAMessage_args() {
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendSystemOAMessage_args(");

    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendSystemOAMessage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendSystemOAMessage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendSystemOAMessage_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendSystemOAMessage_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquirePaidCallRoute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquirePaidCallRoute_args");
  static final TField _PAID_CALL_TYPE_FIELD_DESC = new TField("paidCallType", TType.I32, 2);
  static final TField _DIALED_NUMBER_FIELD_DESC = new TField("dialedNumber", TType.STRING, 3);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 4);
  static final TField _NETWORK_CODE_FIELD_DESC = new TField("networkCode", TType.STRING, 5);
  static final TField _DISABLE_CALLER_ID_FIELD_DESC = new TField("disableCallerId", TType.BOOL, 6);
  static final TField _REFERER_FIELD_DESC = new TField("referer", TType.STRING, 7);
  static final TField _AD_SESSION_ID_FIELD_DESC = new TField("adSessionId", TType.STRING, 8);

  int _paidCallType;
  static const int PAIDCALLTYPE = 2;
  String _dialedNumber;
  static const int DIALEDNUMBER = 3;
  String _language;
  static const int LANGUAGE = 4;
  String _networkCode;
  static const int NETWORKCODE = 5;
  bool _disableCallerId = false;
  static const int DISABLECALLERID = 6;
  String _referer;
  static const int REFERER = 7;
  String _adSessionId;
  static const int ADSESSIONID = 8;

  bool __isset_paidCallType = false;
  bool __isset_disableCallerId = false;

  acquirePaidCallRoute_args() {
  }

  // paidCallType
  int get paidCallType => this._paidCallType;

  set paidCallType(int paidCallType) {
    this._paidCallType = paidCallType;
    this.__isset_paidCallType = true;
  }

  bool isSetPaidCallType() => this.__isset_paidCallType;

  unsetPaidCallType() {
    this.__isset_paidCallType = false;
  }

  // dialedNumber
  String get dialedNumber => this._dialedNumber;

  set dialedNumber(String dialedNumber) {
    this._dialedNumber = dialedNumber;
  }

  bool isSetDialedNumber() => this.dialedNumber != null;

  unsetDialedNumber() {
    this.dialedNumber = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // networkCode
  String get networkCode => this._networkCode;

  set networkCode(String networkCode) {
    this._networkCode = networkCode;
  }

  bool isSetNetworkCode() => this.networkCode != null;

  unsetNetworkCode() {
    this.networkCode = null;
  }

  // disableCallerId
  bool get disableCallerId => this._disableCallerId;

  set disableCallerId(bool disableCallerId) {
    this._disableCallerId = disableCallerId;
    this.__isset_disableCallerId = true;
  }

  bool isSetDisableCallerId() => this.__isset_disableCallerId;

  unsetDisableCallerId() {
    this.__isset_disableCallerId = false;
  }

  // referer
  String get referer => this._referer;

  set referer(String referer) {
    this._referer = referer;
  }

  bool isSetReferer() => this.referer != null;

  unsetReferer() {
    this.referer = null;
  }

  // adSessionId
  String get adSessionId => this._adSessionId;

  set adSessionId(String adSessionId) {
    this._adSessionId = adSessionId;
  }

  bool isSetAdSessionId() => this.adSessionId != null;

  unsetAdSessionId() {
    this.adSessionId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PAIDCALLTYPE:
        return this.paidCallType;
      case DIALEDNUMBER:
        return this.dialedNumber;
      case LANGUAGE:
        return this.language;
      case NETWORKCODE:
        return this.networkCode;
      case DISABLECALLERID:
        return this.disableCallerId;
      case REFERER:
        return this.referer;
      case ADSESSIONID:
        return this.adSessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PAIDCALLTYPE:
        if (value == null) {
          unsetPaidCallType();
        } else {
          this.paidCallType = value;
        }
        break;

      case DIALEDNUMBER:
        if (value == null) {
          unsetDialedNumber();
        } else {
          this.dialedNumber = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case NETWORKCODE:
        if (value == null) {
          unsetNetworkCode();
        } else {
          this.networkCode = value;
        }
        break;

      case DISABLECALLERID:
        if (value == null) {
          unsetDisableCallerId();
        } else {
          this.disableCallerId = value;
        }
        break;

      case REFERER:
        if (value == null) {
          unsetReferer();
        } else {
          this.referer = value;
        }
        break;

      case ADSESSIONID:
        if (value == null) {
          unsetAdSessionId();
        } else {
          this.adSessionId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PAIDCALLTYPE:
        return isSetPaidCallType();
      case DIALEDNUMBER:
        return isSetDialedNumber();
      case LANGUAGE:
        return isSetLanguage();
      case NETWORKCODE:
        return isSetNetworkCode();
      case DISABLECALLERID:
        return isSetDisableCallerId();
      case REFERER:
        return isSetReferer();
      case ADSESSIONID:
        return isSetAdSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PAIDCALLTYPE:
          if (field.type == TType.I32) {
            this.paidCallType = iprot.readI32();
            this.__isset_paidCallType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DIALEDNUMBER:
          if (field.type == TType.STRING) {
            this.dialedNumber = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NETWORKCODE:
          if (field.type == TType.STRING) {
            this.networkCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DISABLECALLERID:
          if (field.type == TType.BOOL) {
            this.disableCallerId = iprot.readBool();
            this.__isset_disableCallerId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REFERER:
          if (field.type == TType.STRING) {
            this.referer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ADSESSIONID:
          if (field.type == TType.STRING) {
            this.adSessionId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PAID_CALL_TYPE_FIELD_DESC);
    oprot.writeI32(this.paidCallType);
    oprot.writeFieldEnd();
    if (this.dialedNumber != null) {
      oprot.writeFieldBegin(_DIALED_NUMBER_FIELD_DESC);
      oprot.writeString(this.dialedNumber);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.networkCode != null) {
      oprot.writeFieldBegin(_NETWORK_CODE_FIELD_DESC);
      oprot.writeString(this.networkCode);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_DISABLE_CALLER_ID_FIELD_DESC);
    oprot.writeBool(this.disableCallerId);
    oprot.writeFieldEnd();
    if (this.referer != null) {
      oprot.writeFieldBegin(_REFERER_FIELD_DESC);
      oprot.writeString(this.referer);
      oprot.writeFieldEnd();
    }
    if (this.adSessionId != null) {
      oprot.writeFieldBegin(_AD_SESSION_ID_FIELD_DESC);
      oprot.writeString(this.adSessionId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquirePaidCallRoute_args(");

    ret.write("paidCallType:");
    String paidCallType_name = PaidCallType.VALUES_TO_NAMES[this.paidCallType];
    if (paidCallType_name != null) {
      ret.write(paidCallType_name);
      ret.write(" (");
    }
    ret.write(this.paidCallType);
    if (paidCallType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("dialedNumber:");
    if (this.dialedNumber == null) {
      ret.write("null");
    } else {
      ret.write(this.dialedNumber);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("networkCode:");
    if (this.networkCode == null) {
      ret.write("null");
    } else {
      ret.write(this.networkCode);
    }

    ret.write(", ");
    ret.write("disableCallerId:");
    ret.write(this.disableCallerId);

    ret.write(", ");
    ret.write("referer:");
    if (this.referer == null) {
      ret.write("null");
    } else {
      ret.write(this.referer);
    }

    ret.write(", ");
    ret.write("adSessionId:");
    if (this.adSessionId == null) {
      ret.write("null");
    } else {
      ret.write(this.adSessionId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetPaidCallType() && !PaidCallType.VALID_VALUES.contains(paidCallType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'paidCallType' has been assigned the invalid value $paidCallType");
    }
  }

}

class acquirePaidCallRoute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquirePaidCallRoute_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallResponse _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquirePaidCallRoute_result() {
  }

  // success
  PaidCallResponse get success => this._success;

  set success(PaidCallResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquirePaidCallRoute_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupsForChannel_args");
  static final TField _GROUP_IDS_FIELD_DESC = new TField("groupIds", TType.LIST, 1);

  List<String> _groupIds;
  static const int GROUPIDS = 1;


  getGroupsForChannel_args() {
  }

  // groupIds
  List<String> get groupIds => this._groupIds;

  set groupIds(List<String> groupIds) {
    this._groupIds = groupIds;
  }

  bool isSetGroupIds() => this.groupIds != null;

  unsetGroupIds() {
    this.groupIds = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return this.groupIds;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPIDS:
        if (value == null) {
          unsetGroupIds();
        } else {
          this.groupIds = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPIDS:
        return isSetGroupIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1402 = iprot.readListBegin();
              this.groupIds = new List<String>();
              for (int _i1403 = 0; _i1403 < _list1402.length; ++_i1403) {
                String _elem1404;
                _elem1404 = iprot.readString();
                this.groupIds.add(_elem1404);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupIds != null) {
      oprot.writeFieldBegin(_GROUP_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.groupIds.length));
        for (var elem1405 in this.groupIds) {
          oprot.writeString(elem1405);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupsForChannel_args(");

    ret.write("groupIds:");
    if (this.groupIds == null) {
      ret.write("null");
    } else {
      ret.write(this.groupIds);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<Group> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupsForChannel_result() {
  }

  // success
  List<Group> get success => this._success;

  set success(List<Group> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1406 = iprot.readListBegin();
              this.success = new List<Group>();
              for (int _i1407 = 0; _i1407 < _list1406.length; ++_i1407) {
                Group _elem1408;
                _elem1408 = new Group();
                _elem1408.read(iprot);
                this.success.add(_elem1408);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1409 in this.success) {
          elem1409.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserCreateTime_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserCreateTime_args");



  getUserCreateTime_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserCreateTime_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserCreateTime_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserCreateTime_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getUserCreateTime_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserCreateTime_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerChannelCP_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerChannelCP_args");
  static final TField _CP_ID_FIELD_DESC = new TField("cpId", TType.STRING, 2);
  static final TField _REGISTER_PASSWORD_FIELD_DESC = new TField("registerPassword", TType.STRING, 3);

  String _cpId;
  static const int CPID = 2;
  String _registerPassword;
  static const int REGISTERPASSWORD = 3;


  registerChannelCP_args() {
  }

  // cpId
  String get cpId => this._cpId;

  set cpId(String cpId) {
    this._cpId = cpId;
  }

  bool isSetCpId() => this.cpId != null;

  unsetCpId() {
    this.cpId = null;
  }

  // registerPassword
  String get registerPassword => this._registerPassword;

  set registerPassword(String registerPassword) {
    this._registerPassword = registerPassword;
  }

  bool isSetRegisterPassword() => this.registerPassword != null;

  unsetRegisterPassword() {
    this.registerPassword = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CPID:
        return this.cpId;
      case REGISTERPASSWORD:
        return this.registerPassword;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CPID:
        if (value == null) {
          unsetCpId();
        } else {
          this.cpId = value;
        }
        break;

      case REGISTERPASSWORD:
        if (value == null) {
          unsetRegisterPassword();
        } else {
          this.registerPassword = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CPID:
        return isSetCpId();
      case REGISTERPASSWORD:
        return isSetRegisterPassword();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CPID:
          if (field.type == TType.STRING) {
            this.cpId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REGISTERPASSWORD:
          if (field.type == TType.STRING) {
            this.registerPassword = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.cpId != null) {
      oprot.writeFieldBegin(_CP_ID_FIELD_DESC);
      oprot.writeString(this.cpId);
      oprot.writeFieldEnd();
    }
    if (this.registerPassword != null) {
      oprot.writeFieldBegin(_REGISTER_PASSWORD_FIELD_DESC);
      oprot.writeString(this.registerPassword);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerChannelCP_args(");

    ret.write("cpId:");
    if (this.cpId == null) {
      ret.write("null");
    } else {
      ret.write(this.cpId);
    }

    ret.write(", ");
    ret.write("registerPassword:");
    if (this.registerPassword == null) {
      ret.write("null");
    } else {
      ret.write(this.registerPassword);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class registerChannelCP_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("registerChannelCP_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  registerChannelCP_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("registerChannelCP_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCallCreditPurchase_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCallCreditPurchase_args");
  static final TField _REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, 2);

  CoinPurchaseReservation _request;
  static const int REQUEST = 2;


  reserveCallCreditPurchase_args() {
  }

  // request
  CoinPurchaseReservation get request => this._request;

  set request(CoinPurchaseReservation request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUEST:
          if (field.type == TType.STRUCT) {
            this.request = new CoinPurchaseReservation();
            this.request.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      this.request.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCallCreditPurchase_args(");

    ret.write("request:");
    if (this.request == null) {
      ret.write("null");
    } else {
      ret.write(this.request);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class reserveCallCreditPurchase_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reserveCallCreditPurchase_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaymentReservationResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  reserveCallCreditPurchase_result() {
  }

  // success
  PaymentReservationResult get success => this._success;

  set success(PaymentReservationResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaymentReservationResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reserveCallCreditPurchase_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquirePaidCallCurrencyExchangeRate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquirePaidCallCurrencyExchangeRate_args");
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 2);

  String _language;
  static const int LANGUAGE = 2;


  acquirePaidCallCurrencyExchangeRate_args() {
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquirePaidCallCurrencyExchangeRate_args(");

    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquirePaidCallCurrencyExchangeRate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquirePaidCallCurrencyExchangeRate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<PaidCallCurrencyExchangeRate> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquirePaidCallCurrencyExchangeRate_result() {
  }

  // success
  List<PaidCallCurrencyExchangeRate> get success => this._success;

  set success(List<PaidCallCurrencyExchangeRate> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1410 = iprot.readListBegin();
              this.success = new List<PaidCallCurrencyExchangeRate>();
              for (int _i1411 = 0; _i1411 < _list1410.length; ++_i1411) {
                PaidCallCurrencyExchangeRate _elem1412;
                _elem1412 = new PaidCallCurrencyExchangeRate();
                _elem1412.read(iprot);
                this.success.add(_elem1412);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1413 in this.success) {
          elem1413.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquirePaidCallCurrencyExchangeRate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoomMemberMidsForAppPlatform_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoomMemberMidsForAppPlatform_args");
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 1);

  String _roomId;
  static const int ROOMID = 1;


  getRoomMemberMidsForAppPlatform_args() {
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return this.roomId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return isSetRoomId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoomMemberMidsForAppPlatform_args(");

    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRoomMemberMidsForAppPlatform_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getRoomMemberMidsForAppPlatform_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getRoomMemberMidsForAppPlatform_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1414 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1415 = 0; _i1415 < _list1414.length; ++_i1415) {
                String _elem1416;
                _elem1416 = iprot.readString();
                this.success.add(_elem1416);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1417 in this.success) {
          oprot.writeString(elem1417);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getRoomMemberMidsForAppPlatform_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallBalanceList_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallBalanceList_args");
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 2);

  String _language;
  static const int LANGUAGE = 2;


  getPaidCallBalanceList_args() {
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallBalanceList_args(");

    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallBalanceList_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallBalanceList_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<PaidCallBalance> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPaidCallBalanceList_result() {
  }

  // success
  List<PaidCallBalance> get success => this._success;

  set success(List<PaidCallBalance> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1418 = iprot.readListBegin();
              this.success = new List<PaidCallBalance>();
              for (int _i1419 = 0; _i1419 < _list1418.length; ++_i1419) {
                PaidCallBalance _elem1420;
                _elem1420 = new PaidCallBalance();
                _elem1420.read(iprot);
                this.success.add(_elem1420);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1421 in this.success) {
          elem1421.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallBalanceList_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPersonalInfos_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPersonalInfos_args");
  static final TField _REQUIRED_PERSONAL_INFOS_FIELD_DESC = new TField("requiredPersonalInfos", TType.SET, 1);

  Set<int> _requiredPersonalInfos;
  static const int REQUIREDPERSONALINFOS = 1;


  getPersonalInfos_args() {
  }

  // requiredPersonalInfos
  Set<int> get requiredPersonalInfos => this._requiredPersonalInfos;

  set requiredPersonalInfos(Set<int> requiredPersonalInfos) {
    this._requiredPersonalInfos = requiredPersonalInfos;
  }

  bool isSetRequiredPersonalInfos() => this.requiredPersonalInfos != null;

  unsetRequiredPersonalInfos() {
    this.requiredPersonalInfos = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUIREDPERSONALINFOS:
        return this.requiredPersonalInfos;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUIREDPERSONALINFOS:
        if (value == null) {
          unsetRequiredPersonalInfos();
        } else {
          this.requiredPersonalInfos = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUIREDPERSONALINFOS:
        return isSetRequiredPersonalInfos();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUIREDPERSONALINFOS:
          if (field.type == TType.SET) {
            {
              TSet _set1422 = iprot.readSetBegin();
              this.requiredPersonalInfos = new Set<int>();
              for (int _i1423 = 0; _i1423 < _set1422.length; ++_i1423) {
                int _elem1424;
                _elem1424 = iprot.readI32();
                this.requiredPersonalInfos.add(_elem1424);
              }
              iprot.readSetEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.requiredPersonalInfos != null) {
      oprot.writeFieldBegin(_REQUIRED_PERSONAL_INFOS_FIELD_DESC);
      {
        oprot.writeSetBegin(new TSet(TType.I32, this.requiredPersonalInfos.length));
        for (var elem1425 in this.requiredPersonalInfos) {
          oprot.writeI32(elem1425);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPersonalInfos_args(");

    ret.write("requiredPersonalInfos:");
    if (this.requiredPersonalInfos == null) {
      ret.write("null");
    } else {
      ret.write(this.requiredPersonalInfos);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPersonalInfos_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPersonalInfos_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<int, String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPersonalInfos_result() {
  }

  // success
  Map<int, String> get success => this._success;

  set success(Map<int, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1426 = iprot.readMapBegin();
              this.success = new Map<int, String>();
              for (int _i1427 = 0; _i1427 < _map1426.length; ++_i1427) {
                int _key1428;
                String _val1429;
                _key1428 = iprot.readI32();
                _val1429 = iprot.readString();
                this.success[_key1428] = _val1429;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, this.success.length));
        for (var elem1431 in this.success.keys) {
          oprot.writeI32(elem1431);
          oprot.writeString(this.success[elem1431]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPersonalInfos_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPrimaryClientsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPrimaryClientsForChannel_args");
  static final TField _USER_MIDS_FIELD_DESC = new TField("userMids", TType.LIST, 1);

  List<String> _userMids;
  static const int USERMIDS = 1;


  getPrimaryClientsForChannel_args() {
  }

  // userMids
  List<String> get userMids => this._userMids;

  set userMids(List<String> userMids) {
    this._userMids = userMids;
  }

  bool isSetUserMids() => this.userMids != null;

  unsetUserMids() {
    this.userMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERMIDS:
        return this.userMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERMIDS:
        if (value == null) {
          unsetUserMids();
        } else {
          this.userMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERMIDS:
        return isSetUserMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1432 = iprot.readListBegin();
              this.userMids = new List<String>();
              for (int _i1433 = 0; _i1433 < _list1432.length; ++_i1433) {
                String _elem1434;
                _elem1434 = iprot.readString();
                this.userMids.add(_elem1434);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userMids != null) {
      oprot.writeFieldBegin(_USER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.userMids.length));
        for (var elem1435 in this.userMids) {
          oprot.writeString(elem1435);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPrimaryClientsForChannel_args(");

    ret.write("userMids:");
    if (this.userMids == null) {
      ret.write("null");
    } else {
      ret.write(this.userMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPrimaryClientsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPrimaryClientsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SimpleChannelClient> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPrimaryClientsForChannel_result() {
  }

  // success
  List<SimpleChannelClient> get success => this._success;

  set success(List<SimpleChannelClient> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1436 = iprot.readListBegin();
              this.success = new List<SimpleChannelClient>();
              for (int _i1437 = 0; _i1437 < _list1436.length; ++_i1437) {
                SimpleChannelClient _elem1438;
                _elem1438 = new SimpleChannelClient();
                _elem1438.read(iprot);
                this.success.add(_elem1438);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1439 in this.success) {
          elem1439.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPrimaryClientsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class addBuddyToContact_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addBuddyToContact_args");
  static final TField _BUDDY_MID_FIELD_DESC = new TField("buddyMid", TType.STRING, 1);

  String _buddyMid;
  static const int BUDDYMID = 1;


  addBuddyToContact_args() {
  }

  // buddyMid
  String get buddyMid => this._buddyMid;

  set buddyMid(String buddyMid) {
    this._buddyMid = buddyMid;
  }

  bool isSetBuddyMid() => this.buddyMid != null;

  unsetBuddyMid() {
    this.buddyMid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case BUDDYMID:
        return this.buddyMid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case BUDDYMID:
        if (value == null) {
          unsetBuddyMid();
        } else {
          this.buddyMid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case BUDDYMID:
        return isSetBuddyMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case BUDDYMID:
          if (field.type == TType.STRING) {
            this.buddyMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.buddyMid != null) {
      oprot.writeFieldBegin(_BUDDY_MID_FIELD_DESC);
      oprot.writeString(this.buddyMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addBuddyToContact_args(");

    ret.write("buddyMid:");
    if (this.buddyMid == null) {
      ret.write("null");
    } else {
      ret.write(this.buddyMid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class addBuddyToContact_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addBuddyToContact_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ContactTransition _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  addBuddyToContact_result() {
  }

  // success
  ContactTransition get success => this._success;

  set success(ContactTransition success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ContactTransition();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addBuddyToContact_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupMemberMidsForAppPlatform_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupMemberMidsForAppPlatform_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 1);

  String _groupId;
  static const int GROUPID = 1;


  getGroupMemberMidsForAppPlatform_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupMemberMidsForAppPlatform_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupMemberMidsForAppPlatform_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupMemberMidsForAppPlatform_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupMemberMidsForAppPlatform_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1440 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1441 = 0; _i1441 < _list1440.length; ++_i1441) {
                String _elem1442;
                _elem1442 = iprot.readString();
                this.success.add(_elem1442);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1443 in this.success) {
          oprot.writeString(elem1443);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupMemberMidsForAppPlatform_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserLanguage_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserLanguage_args");



  getUserLanguage_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserLanguage_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserLanguage_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserLanguage_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserLanguage_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserLanguage_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupPaidCall_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupPaidCall_args");
  static final TField _DIALED_NUMBER_FIELD_DESC = new TField("dialedNumber", TType.STRING, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);
  static final TField _REFERER_FIELD_DESC = new TField("referer", TType.STRING, 4);

  String _dialedNumber;
  static const int DIALEDNUMBER = 2;
  String _language;
  static const int LANGUAGE = 3;
  String _referer;
  static const int REFERER = 4;


  lookupPaidCall_args() {
  }

  // dialedNumber
  String get dialedNumber => this._dialedNumber;

  set dialedNumber(String dialedNumber) {
    this._dialedNumber = dialedNumber;
  }

  bool isSetDialedNumber() => this.dialedNumber != null;

  unsetDialedNumber() {
    this.dialedNumber = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  // referer
  String get referer => this._referer;

  set referer(String referer) {
    this._referer = referer;
  }

  bool isSetReferer() => this.referer != null;

  unsetReferer() {
    this.referer = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case DIALEDNUMBER:
        return this.dialedNumber;
      case LANGUAGE:
        return this.language;
      case REFERER:
        return this.referer;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case DIALEDNUMBER:
        if (value == null) {
          unsetDialedNumber();
        } else {
          this.dialedNumber = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      case REFERER:
        if (value == null) {
          unsetReferer();
        } else {
          this.referer = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case DIALEDNUMBER:
        return isSetDialedNumber();
      case LANGUAGE:
        return isSetLanguage();
      case REFERER:
        return isSetReferer();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DIALEDNUMBER:
          if (field.type == TType.STRING) {
            this.dialedNumber = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REFERER:
          if (field.type == TType.STRING) {
            this.referer = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.dialedNumber != null) {
      oprot.writeFieldBegin(_DIALED_NUMBER_FIELD_DESC);
      oprot.writeString(this.dialedNumber);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    if (this.referer != null) {
      oprot.writeFieldBegin(_REFERER_FIELD_DESC);
      oprot.writeString(this.referer);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupPaidCall_args(");

    ret.write("dialedNumber:");
    if (this.dialedNumber == null) {
      ret.write("null");
    } else {
      ret.write(this.dialedNumber);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(", ");
    ret.write("referer:");
    if (this.referer == null) {
      ret.write("null");
    } else {
      ret.write(this.referer);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupPaidCall_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupPaidCall_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallResponse _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  lookupPaidCall_result() {
  }

  // success
  PaidCallResponse get success => this._success;

  set success(PaidCallResponse success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallResponse();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupPaidCall_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getExtendedProfile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getExtendedProfile_args");



  getExtendedProfile_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getExtendedProfile_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getExtendedProfile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getExtendedProfile_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  ExtendedProfile _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getExtendedProfile_result() {
  }

  // success
  ExtendedProfile get success => this._success;

  set success(ExtendedProfile success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExtendedProfile();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getExtendedProfile_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getReverseCompactContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getReverseCompactContacts_args");
  static final TField _IDS_FIELD_DESC = new TField("ids", TType.LIST, 1);

  List<String> _ids;
  static const int IDS = 1;


  getReverseCompactContacts_args() {
  }

  // ids
  List<String> get ids => this._ids;

  set ids(List<String> ids) {
    this._ids = ids;
  }

  bool isSetIds() => this.ids != null;

  unsetIds() {
    this.ids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDS:
        return this.ids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDS:
        if (value == null) {
          unsetIds();
        } else {
          this.ids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDS:
        return isSetIds();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDS:
          if (field.type == TType.LIST) {
            {
              TList _list1444 = iprot.readListBegin();
              this.ids = new List<String>();
              for (int _i1445 = 0; _i1445 < _list1444.length; ++_i1445) {
                String _elem1446;
                _elem1446 = iprot.readString();
                this.ids.add(_elem1446);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ids != null) {
      oprot.writeFieldBegin(_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.ids.length));
        for (var elem1447 in this.ids) {
          oprot.writeString(elem1447);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getReverseCompactContacts_args(");

    ret.write("ids:");
    if (this.ids == null) {
      ret.write("null");
    } else {
      ret.write(this.ids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getReverseCompactContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getReverseCompactContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, CompactContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getReverseCompactContacts_result() {
  }

  // success
  Map<String, CompactContact> get success => this._success;

  set success(Map<String, CompactContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1448 = iprot.readMapBegin();
              this.success = new Map<String, CompactContact>();
              for (int _i1449 = 0; _i1449 < _map1448.length; ++_i1449) {
                String _key1450;
                CompactContact _val1451;
                _key1450 = iprot.readString();
                _val1451 = new CompactContact();
                _val1451.read(iprot);
                this.success[_key1450] = _val1451;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem1453 in this.success.keys) {
          oprot.writeString(elem1453);
          this.success[elem1453].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getReverseCompactContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallAdStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallAdStatus_args");



  getPaidCallAdStatus_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallAdStatus_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPaidCallAdStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPaidCallAdStatus_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  PaidCallAdResult _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getPaidCallAdStatus_result() {
  }

  // success
  PaidCallAdResult get success => this._success;

  set success(PaidCallAdResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PaidCallAdResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPaidCallAdStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUseridWithoutAbuseBlockForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUseridWithoutAbuseBlockForChannel_args");
  static final TField _USERID_FIELD_DESC = new TField("userid", TType.STRING, 2);

  String _userid;
  static const int USERID = 2;


  findContactByUseridWithoutAbuseBlockForChannel_args() {
  }

  // userid
  String get userid => this._userid;

  set userid(String userid) {
    this._userid = userid;
  }

  bool isSetUserid() => this.userid != null;

  unsetUserid() {
    this.userid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERID:
        return this.userid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERID:
        if (value == null) {
          unsetUserid();
        } else {
          this.userid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERID:
        return isSetUserid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERID:
          if (field.type == TType.STRING) {
            this.userid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userid != null) {
      oprot.writeFieldBegin(_USERID_FIELD_DESC);
      oprot.writeString(this.userid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUseridWithoutAbuseBlockForChannel_args(");

    ret.write("userid:");
    if (this.userid == null) {
      ret.write("null");
    } else {
      ret.write(this.userid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findContactByUseridWithoutAbuseBlockForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("findContactByUseridWithoutAbuseBlockForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Contact _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  findContactByUseridWithoutAbuseBlockForChannel_result() {
  }

  // success
  Contact get success => this._success;

  set success(Contact success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Contact();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("findContactByUseridWithoutAbuseBlockForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupMemberMids_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupMemberMids_args");
  static final TField _GROUP_ID_FIELD_DESC = new TField("groupId", TType.STRING, 1);

  String _groupId;
  static const int GROUPID = 1;


  getGroupMemberMids_args() {
  }

  // groupId
  String get groupId => this._groupId;

  set groupId(String groupId) {
    this._groupId = groupId;
  }

  bool isSetGroupId() => this.groupId != null;

  unsetGroupId() {
    this.groupId = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return this.groupId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case GROUPID:
        if (value == null) {
          unsetGroupId();
        } else {
          this.groupId = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case GROUPID:
        return isSetGroupId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GROUPID:
          if (field.type == TType.STRING) {
            this.groupId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.groupId != null) {
      oprot.writeFieldBegin(_GROUP_ID_FIELD_DESC);
      oprot.writeString(this.groupId);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupMemberMids_args(");

    ret.write("groupId:");
    if (this.groupId == null) {
      ret.write("null");
    } else {
      ret.write(this.groupId);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getGroupMemberMids_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getGroupMemberMids_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getGroupMemberMids_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1454 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1455 = 0; _i1455 < _list1454.length; ++_i1455) {
                String _elem1456;
                _elem1456 = iprot.readString();
                this.success.add(_elem1456);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1457 in this.success) {
          oprot.writeString(elem1457);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getGroupMemberMids_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageWithoutRelationship_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageWithoutRelationship_args");
  static final TField _MESSAGE_FIELD_DESC = new TField("message", TType.STRUCT, 2);

  Message _message;
  static const int MESSAGE = 2;


  sendMessageWithoutRelationship_args() {
  }

  // message
  Message get message => this._message;

  set message(Message message) {
    this._message = message;
  }

  bool isSetMessage() => this.message != null;

  unsetMessage() {
    this.message = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return this.message;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MESSAGE:
        if (value == null) {
          unsetMessage();
        } else {
          this.message = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MESSAGE:
        return isSetMessage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MESSAGE:
          if (field.type == TType.STRUCT) {
            this.message = new Message();
            this.message.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.message != null) {
      oprot.writeFieldBegin(_MESSAGE_FIELD_DESC);
      this.message.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageWithoutRelationship_args(");

    ret.write("message:");
    if (this.message == null) {
      ret.write("null");
    } else {
      ret.write(this.message);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageWithoutRelationship_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sendMessageWithoutRelationship_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Message _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  sendMessageWithoutRelationship_result() {
  }

  // success
  Message get success => this._success;

  set success(Message success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Message();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sendMessageWithoutRelationship_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class displayBuddySubscriberCountInBulk_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("displayBuddySubscriberCountInBulk_args");
  static final TField _MIDS_FIELD_DESC = new TField("mids", TType.LIST, 1);

  List<String> _mids;
  static const int MIDS = 1;


  displayBuddySubscriberCountInBulk_args() {
  }

  // mids
  List<String> get mids => this._mids;

  set mids(List<String> mids) {
    this._mids = mids;
  }

  bool isSetMids() => this.mids != null;

  unsetMids() {
    this.mids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MIDS:
        return this.mids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MIDS:
        if (value == null) {
          unsetMids();
        } else {
          this.mids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MIDS:
        return isSetMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1458 = iprot.readListBegin();
              this.mids = new List<String>();
              for (int _i1459 = 0; _i1459 < _list1458.length; ++_i1459) {
                String _elem1460;
                _elem1460 = iprot.readString();
                this.mids.add(_elem1460);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mids != null) {
      oprot.writeFieldBegin(_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.mids.length));
        for (var elem1461 in this.mids) {
          oprot.writeString(elem1461);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("displayBuddySubscriberCountInBulk_args(");

    ret.write("mids:");
    if (this.mids == null) {
      ret.write("null");
    } else {
      ret.write(this.mids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class displayBuddySubscriberCountInBulk_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("displayBuddySubscriberCountInBulk_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, int> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  displayBuddySubscriberCountInBulk_result() {
  }

  // success
  Map<String, int> get success => this._success;

  set success(Map<String, int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map1462 = iprot.readMapBegin();
              this.success = new Map<String, int>();
              for (int _i1463 = 0; _i1463 < _map1462.length; ++_i1463) {
                String _key1464;
                int _val1465;
                _key1464 = iprot.readString();
                _val1465 = iprot.readI64();
                this.success[_key1464] = _val1465;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.I64, this.success.length));
        for (var elem1467 in this.success.keys) {
          oprot.writeString(elem1467);
          oprot.writeI64(this.success[elem1467]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("displayBuddySubscriberCountInBulk_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupRoomMembers_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupRoomMembers_args");
  static final TField _ROOM_ID_FIELD_DESC = new TField("roomId", TType.STRING, 1);
  static final TField _MIDS_FIELD_DESC = new TField("mids", TType.LIST, 2);

  String _roomId;
  static const int ROOMID = 1;
  List<String> _mids;
  static const int MIDS = 2;


  lookupRoomMembers_args() {
  }

  // roomId
  String get roomId => this._roomId;

  set roomId(String roomId) {
    this._roomId = roomId;
  }

  bool isSetRoomId() => this.roomId != null;

  unsetRoomId() {
    this.roomId = null;
  }

  // mids
  List<String> get mids => this._mids;

  set mids(List<String> mids) {
    this._mids = mids;
  }

  bool isSetMids() => this.mids != null;

  unsetMids() {
    this.mids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return this.roomId;
      case MIDS:
        return this.mids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ROOMID:
        if (value == null) {
          unsetRoomId();
        } else {
          this.roomId = value;
        }
        break;

      case MIDS:
        if (value == null) {
          unsetMids();
        } else {
          this.mids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ROOMID:
        return isSetRoomId();
      case MIDS:
        return isSetMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ROOMID:
          if (field.type == TType.STRING) {
            this.roomId = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1468 = iprot.readListBegin();
              this.mids = new List<String>();
              for (int _i1469 = 0; _i1469 < _list1468.length; ++_i1469) {
                String _elem1470;
                _elem1470 = iprot.readString();
                this.mids.add(_elem1470);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.roomId != null) {
      oprot.writeFieldBegin(_ROOM_ID_FIELD_DESC);
      oprot.writeString(this.roomId);
      oprot.writeFieldEnd();
    }
    if (this.mids != null) {
      oprot.writeFieldBegin(_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.mids.length));
        for (var elem1471 in this.mids) {
          oprot.writeString(elem1471);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupRoomMembers_args(");

    ret.write("roomId:");
    if (this.roomId == null) {
      ret.write("null");
    } else {
      ret.write(this.roomId);
    }

    ret.write(", ");
    ret.write("mids:");
    if (this.mids == null) {
      ret.write("null");
    } else {
      ret.write(this.mids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class lookupRoomMembers_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("lookupRoomMembers_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SimpleChannelContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  lookupRoomMembers_result() {
  }

  // success
  List<SimpleChannelContact> get success => this._success;

  set success(List<SimpleChannelContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1472 = iprot.readListBegin();
              this.success = new List<SimpleChannelContact>();
              for (int _i1473 = 0; _i1473 < _list1472.length; ++_i1473) {
                SimpleChannelContact _elem1474;
                _elem1474 = new SimpleChannelContact();
                _elem1474.read(iprot);
                this.success.add(_elem1474);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1475 in this.success) {
          elem1475.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("lookupRoomMembers_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteMidsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteMidsForChannel_args");



  getFavoriteMidsForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteMidsForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFavoriteMidsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getFavoriteMidsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getFavoriteMidsForChannel_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1476 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1477 = 0; _i1477 < _list1476.length; ++_i1477) {
                String _elem1478;
                _elem1478 = iprot.readString();
                this.success.add(_elem1478);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1479 in this.success) {
          oprot.writeString(elem1479);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getFavoriteMidsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllContactIdsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllContactIdsForChannel_args");



  getAllContactIdsForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllContactIdsForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAllContactIdsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getAllContactIdsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getAllContactIdsForChannel_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1480 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1481 = 0; _i1481 < _list1480.length; ++_i1481) {
                String _elem1482;
                _elem1482 = iprot.readString();
                this.success.add(_elem1482);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1483 in this.success) {
          oprot.writeString(elem1483);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getAllContactIdsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class displayBuddySubscriberCount_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("displayBuddySubscriberCount_args");



  displayBuddySubscriberCount_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("displayBuddySubscriberCount_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class displayBuddySubscriberCount_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("displayBuddySubscriberCount_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  displayBuddySubscriberCount_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("displayBuddySubscriberCount_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProfileForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProfileForChannel_args");



  getProfileForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProfileForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getProfileForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getProfileForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Profile _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getProfileForChannel_result() {
  }

  // success
  Profile get success => this._success;

  set success(Profile success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Profile();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getProfileForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserTickets_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserTickets_args");
  static final TField _USER_MIDS_FIELD_DESC = new TField("userMids", TType.LIST, 1);

  List<String> _userMids;
  static const int USERMIDS = 1;


  getUserTickets_args() {
  }

  // userMids
  List<String> get userMids => this._userMids;

  set userMids(List<String> userMids) {
    this._userMids = userMids;
  }

  bool isSetUserMids() => this.userMids != null;

  unsetUserMids() {
    this.userMids = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERMIDS:
        return this.userMids;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERMIDS:
        if (value == null) {
          unsetUserMids();
        } else {
          this.userMids = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERMIDS:
        return isSetUserMids();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERMIDS:
          if (field.type == TType.LIST) {
            {
              TList _list1484 = iprot.readListBegin();
              this.userMids = new List<String>();
              for (int _i1485 = 0; _i1485 < _list1484.length; ++_i1485) {
                String _elem1486;
                _elem1486 = iprot.readString();
                this.userMids.add(_elem1486);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.userMids != null) {
      oprot.writeFieldBegin(_USER_MIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.userMids.length));
        for (var elem1487 in this.userMids) {
          oprot.writeString(elem1487);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserTickets_args(");

    ret.write("userMids:");
    if (this.userMids == null) {
      ret.write("null");
    } else {
      ret.write(this.userMids);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserTickets_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserTickets_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<UserTicketResponse> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserTickets_result() {
  }

  // success
  List<UserTicketResponse> get success => this._success;

  set success(List<UserTicketResponse> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1488 = iprot.readListBegin();
              this.success = new List<UserTicketResponse>();
              for (int _i1489 = 0; _i1489 < _list1488.length; ++_i1489) {
                UserTicketResponse _elem1490;
                _elem1490 = new UserTicketResponse();
                _elem1490.read(iprot);
                this.success.add(_elem1490);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1491 in this.success) {
          elem1491.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserTickets_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getOAFriendMids_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getOAFriendMids_args");



  getOAFriendMids_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getOAFriendMids_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getOAFriendMids_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getOAFriendMids_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getOAFriendMids_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1492 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1493 = 0; _i1493 < _list1492.length; ++_i1493) {
                String _elem1494;
                _elem1494 = iprot.readString();
                this.success.add(_elem1494);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1495 in this.success) {
          oprot.writeString(elem1495);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getOAFriendMids_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class searchPaidCallUserRate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("searchPaidCallUserRate_args");
  static final TField _COUNTRY_CODE_FIELD_DESC = new TField("countryCode", TType.STRING, 2);
  static final TField _LANGUAGE_FIELD_DESC = new TField("language", TType.STRING, 3);

  String _countryCode;
  static const int COUNTRYCODE = 2;
  String _language;
  static const int LANGUAGE = 3;


  searchPaidCallUserRate_args() {
  }

  // countryCode
  String get countryCode => this._countryCode;

  set countryCode(String countryCode) {
    this._countryCode = countryCode;
  }

  bool isSetCountryCode() => this.countryCode != null;

  unsetCountryCode() {
    this.countryCode = null;
  }

  // language
  String get language => this._language;

  set language(String language) {
    this._language = language;
  }

  bool isSetLanguage() => this.language != null;

  unsetLanguage() {
    this.language = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case COUNTRYCODE:
        return this.countryCode;
      case LANGUAGE:
        return this.language;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case COUNTRYCODE:
        if (value == null) {
          unsetCountryCode();
        } else {
          this.countryCode = value;
        }
        break;

      case LANGUAGE:
        if (value == null) {
          unsetLanguage();
        } else {
          this.language = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case COUNTRYCODE:
        return isSetCountryCode();
      case LANGUAGE:
        return isSetLanguage();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case COUNTRYCODE:
          if (field.type == TType.STRING) {
            this.countryCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANGUAGE:
          if (field.type == TType.STRING) {
            this.language = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.countryCode != null) {
      oprot.writeFieldBegin(_COUNTRY_CODE_FIELD_DESC);
      oprot.writeString(this.countryCode);
      oprot.writeFieldEnd();
    }
    if (this.language != null) {
      oprot.writeFieldBegin(_LANGUAGE_FIELD_DESC);
      oprot.writeString(this.language);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("searchPaidCallUserRate_args(");

    ret.write("countryCode:");
    if (this.countryCode == null) {
      ret.write("null");
    } else {
      ret.write(this.countryCode);
    }

    ret.write(", ");
    ret.write("language:");
    if (this.language == null) {
      ret.write("null");
    } else {
      ret.write(this.language);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class searchPaidCallUserRate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("searchPaidCallUserRate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<PaidCallUserRate> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  searchPaidCallUserRate_result() {
  }

  // success
  List<PaidCallUserRate> get success => this._success;

  set success(List<PaidCallUserRate> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1496 = iprot.readListBegin();
              this.success = new List<PaidCallUserRate>();
              for (int _i1497 = 0; _i1497 < _list1496.length; ++_i1497) {
                PaidCallUserRate _elem1498;
                _elem1498 = new PaidCallUserRate();
                _elem1498.read(iprot);
                this.success.add(_elem1498);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1499 in this.success) {
          elem1499.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("searchPaidCallUserRate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getJoinedGroupIdsForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getJoinedGroupIdsForChannel_args");



  getJoinedGroupIdsForChannel_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getJoinedGroupIdsForChannel_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getJoinedGroupIdsForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getJoinedGroupIdsForChannel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getJoinedGroupIdsForChannel_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1500 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1501 = 0; _i1501 < _list1500.length; ++_i1501) {
                String _elem1502;
                _elem1502 = iprot.readString();
                this.success.add(_elem1502);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1503 in this.success) {
          oprot.writeString(elem1503);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getJoinedGroupIdsForChannel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class acquireGroupCallRoute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireGroupCallRoute_args");
  static final TField _CHAT_MID_FIELD_DESC = new TField("chatMid", TType.STRING, 2);
  static final TField _MEDIA_TYPE_FIELD_DESC = new TField("mediaType", TType.I32, 3);

  String _chatMid;
  static const int CHATMID = 2;
  int _mediaType;
  static const int MEDIATYPE = 3;

  bool __isset_mediaType = false;

  acquireGroupCallRoute_args() {
  }

  // chatMid
  String get chatMid => this._chatMid;

  set chatMid(String chatMid) {
    this._chatMid = chatMid;
  }

  bool isSetChatMid() => this.chatMid != null;

  unsetChatMid() {
    this.chatMid = null;
  }

  // mediaType
  int get mediaType => this._mediaType;

  set mediaType(int mediaType) {
    this._mediaType = mediaType;
    this.__isset_mediaType = true;
  }

  bool isSetMediaType() => this.__isset_mediaType;

  unsetMediaType() {
    this.__isset_mediaType = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return this.chatMid;
      case MEDIATYPE:
        return this.mediaType;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case CHATMID:
        if (value == null) {
          unsetChatMid();
        } else {
          this.chatMid = value;
        }
        break;

      case MEDIATYPE:
        if (value == null) {
          unsetMediaType();
        } else {
          this.mediaType = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case CHATMID:
        return isSetChatMid();
      case MEDIATYPE:
        return isSetMediaType();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case CHATMID:
          if (field.type == TType.STRING) {
            this.chatMid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MEDIATYPE:
          if (field.type == TType.I32) {
            this.mediaType = iprot.readI32();
            this.__isset_mediaType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.chatMid != null) {
      oprot.writeFieldBegin(_CHAT_MID_FIELD_DESC);
      oprot.writeString(this.chatMid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MEDIA_TYPE_FIELD_DESC);
    oprot.writeI32(this.mediaType);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireGroupCallRoute_args(");

    ret.write("chatMid:");
    if (this.chatMid == null) {
      ret.write("null");
    } else {
      ret.write(this.chatMid);
    }

    ret.write(", ");
    ret.write("mediaType:");
    String mediaType_name = GroupCallMediaType.VALUES_TO_NAMES[this.mediaType];
    if (mediaType_name != null) {
      ret.write(mediaType_name);
      ret.write(" (");
    }
    ret.write(this.mediaType);
    if (mediaType_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetMediaType() && !GroupCallMediaType.VALID_VALUES.contains(mediaType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'mediaType' has been assigned the invalid value $mediaType");
    }
  }

}

class acquireGroupCallRoute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("acquireGroupCallRoute_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  GroupCallRoute _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  acquireGroupCallRoute_result() {
  }

  // success
  GroupCallRoute get success => this._success;

  set success(GroupCallRoute success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GroupCallRoute();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("acquireGroupCallRoute_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserMidsWhoAddedMe_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserMidsWhoAddedMe_args");



  getUserMidsWhoAddedMe_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserMidsWhoAddedMe_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserMidsWhoAddedMe_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserMidsWhoAddedMe_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getUserMidsWhoAddedMe_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1504 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i1505 = 0; _i1505 < _list1504.length; ++_i1505) {
                String _elem1506;
                _elem1506 = iprot.readString();
                this.success.add(_elem1506);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem1507 in this.success) {
          oprot.writeString(elem1507);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserMidsWhoAddedMe_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getIdentityCredential_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getIdentityCredential_args");



  getIdentityCredential_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getIdentityCredential_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getIdentityCredential_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getIdentityCredential_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  IdentityCredential _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getIdentityCredential_result() {
  }

  // success
  IdentityCredential get success => this._success;

  set success(IdentityCredential success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new IdentityCredential();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getIdentityCredential_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class addOperationForChannel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addOperationForChannel_args");
  static final TField _OP_TYPE_FIELD_DESC = new TField("opType", TType.I32, 1);
  static final TField _PARAM1_FIELD_DESC = new TField("param1", TType.STRING, 2);
  static final TField _PARAM2_FIELD_DESC = new TField("param2", TType.STRING, 3);
  static final TField _PARAM3_FIELD_DESC = new TField("param3", TType.STRING, 4);

  int _opType;
  static const int OPTYPE = 1;
  String _param1;
  static const int PARAM1 = 2;
  String _param2;
  static const int PARAM2 = 3;
  String _param3;
  static const int PARAM3 = 4;

  bool __isset_opType = false;

  addOperationForChannel_args() {
  }

  // opType
  int get opType => this._opType;

  set opType(int opType) {
    this._opType = opType;
    this.__isset_opType = true;
  }

  bool isSetOpType() => this.__isset_opType;

  unsetOpType() {
    this.__isset_opType = false;
  }

  // param1
  String get param1 => this._param1;

  set param1(String param1) {
    this._param1 = param1;
  }

  bool isSetParam1() => this.param1 != null;

  unsetParam1() {
    this.param1 = null;
  }

  // param2
  String get param2 => this._param2;

  set param2(String param2) {
    this._param2 = param2;
  }

  bool isSetParam2() => this.param2 != null;

  unsetParam2() {
    this.param2 = null;
  }

  // param3
  String get param3 => this._param3;

  set param3(String param3) {
    this._param3 = param3;
  }

  bool isSetParam3() => this.param3 != null;

  unsetParam3() {
    this.param3 = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case OPTYPE:
        return this.opType;
      case PARAM1:
        return this.param1;
      case PARAM2:
        return this.param2;
      case PARAM3:
        return this.param3;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case OPTYPE:
        if (value == null) {
          unsetOpType();
        } else {
          this.opType = value;
        }
        break;

      case PARAM1:
        if (value == null) {
          unsetParam1();
        } else {
          this.param1 = value;
        }
        break;

      case PARAM2:
        if (value == null) {
          unsetParam2();
        } else {
          this.param2 = value;
        }
        break;

      case PARAM3:
        if (value == null) {
          unsetParam3();
        } else {
          this.param3 = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case OPTYPE:
        return isSetOpType();
      case PARAM1:
        return isSetParam1();
      case PARAM2:
        return isSetParam2();
      case PARAM3:
        return isSetParam3();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OPTYPE:
          if (field.type == TType.I32) {
            this.opType = iprot.readI32();
            this.__isset_opType = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAM1:
          if (field.type == TType.STRING) {
            this.param1 = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAM2:
          if (field.type == TType.STRING) {
            this.param2 = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAM3:
          if (field.type == TType.STRING) {
            this.param3 = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OP_TYPE_FIELD_DESC);
    oprot.writeI32(this.opType);
    oprot.writeFieldEnd();
    if (this.param1 != null) {
      oprot.writeFieldBegin(_PARAM1_FIELD_DESC);
      oprot.writeString(this.param1);
      oprot.writeFieldEnd();
    }
    if (this.param2 != null) {
      oprot.writeFieldBegin(_PARAM2_FIELD_DESC);
      oprot.writeString(this.param2);
      oprot.writeFieldEnd();
    }
    if (this.param3 != null) {
      oprot.writeFieldBegin(_PARAM3_FIELD_DESC);
      oprot.writeString(this.param3);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addOperationForChannel_args(");

    ret.write("opType:");
    String opType_name = OpType.VALUES_TO_NAMES[this.opType];
    if (opType_name != null) {
      ret.write(opType_name);
      ret.write(" (");
    }
    ret.write(this.opType);
    if (opType_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("param1:");
    if (this.param1 == null) {
      ret.write("null");
    } else {
      ret.write(this.param1);
    }

    ret.write(", ");
    ret.write("param2:");
    if (this.param2 == null) {
      ret.write("null");
    } else {
      ret.write(this.param2);
    }

    ret.write(", ");
    ret.write("param3:");
    if (this.param3 == null) {
      ret.write("null");
    } else {
      ret.write(this.param3);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetOpType() && !OpType.VALID_VALUES.contains(opType)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'opType' has been assigned the invalid value $opType");
    }
  }

}

class addOperationForChannel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addOperationForChannel_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TalkException _e;
  static const int E = 1;


  addOperationForChannel_result() {
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addOperationForChannel_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSimpleChannelContacts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSimpleChannelContacts_args");
  static final TField _IDS_FIELD_DESC = new TField("ids", TType.LIST, 1);
  static final TField _STATUS_STICON_FALLBACK_DISABLED_FIELD_DESC = new TField("statusSticonFallbackDisabled", TType.BOOL, 2);

  List<String> _ids;
  static const int IDS = 1;
  bool _statusSticonFallbackDisabled = false;
  static const int STATUSSTICONFALLBACKDISABLED = 2;

  bool __isset_statusSticonFallbackDisabled = false;

  getSimpleChannelContacts_args() {
  }

  // ids
  List<String> get ids => this._ids;

  set ids(List<String> ids) {
    this._ids = ids;
  }

  bool isSetIds() => this.ids != null;

  unsetIds() {
    this.ids = null;
  }

  // statusSticonFallbackDisabled
  bool get statusSticonFallbackDisabled => this._statusSticonFallbackDisabled;

  set statusSticonFallbackDisabled(bool statusSticonFallbackDisabled) {
    this._statusSticonFallbackDisabled = statusSticonFallbackDisabled;
    this.__isset_statusSticonFallbackDisabled = true;
  }

  bool isSetStatusSticonFallbackDisabled() => this.__isset_statusSticonFallbackDisabled;

  unsetStatusSticonFallbackDisabled() {
    this.__isset_statusSticonFallbackDisabled = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case IDS:
        return this.ids;
      case STATUSSTICONFALLBACKDISABLED:
        return this.statusSticonFallbackDisabled;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case IDS:
        if (value == null) {
          unsetIds();
        } else {
          this.ids = value;
        }
        break;

      case STATUSSTICONFALLBACKDISABLED:
        if (value == null) {
          unsetStatusSticonFallbackDisabled();
        } else {
          this.statusSticonFallbackDisabled = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case IDS:
        return isSetIds();
      case STATUSSTICONFALLBACKDISABLED:
        return isSetStatusSticonFallbackDisabled();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case IDS:
          if (field.type == TType.LIST) {
            {
              TList _list1508 = iprot.readListBegin();
              this.ids = new List<String>();
              for (int _i1509 = 0; _i1509 < _list1508.length; ++_i1509) {
                String _elem1510;
                _elem1510 = iprot.readString();
                this.ids.add(_elem1510);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STATUSSTICONFALLBACKDISABLED:
          if (field.type == TType.BOOL) {
            this.statusSticonFallbackDisabled = iprot.readBool();
            this.__isset_statusSticonFallbackDisabled = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.ids != null) {
      oprot.writeFieldBegin(_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.ids.length));
        for (var elem1511 in this.ids) {
          oprot.writeString(elem1511);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_STATUS_STICON_FALLBACK_DISABLED_FIELD_DESC);
    oprot.writeBool(this.statusSticonFallbackDisabled);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSimpleChannelContacts_args(");

    ret.write("ids:");
    if (this.ids == null) {
      ret.write("null");
    } else {
      ret.write(this.ids);
    }

    ret.write(", ");
    ret.write("statusSticonFallbackDisabled:");
    ret.write(this.statusSticonFallbackDisabled);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSimpleChannelContacts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSimpleChannelContacts_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<SimpleChannelContact> _success;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;


  getSimpleChannelContacts_result() {
  }

  // success
  List<SimpleChannelContact> get success => this._success;

  set success(List<SimpleChannelContact> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list1512 = iprot.readListBegin();
              this.success = new List<SimpleChannelContact>();
              for (int _i1513 = 0; _i1513 < _list1512.length; ++_i1513) {
                SimpleChannelContact _elem1514;
                _elem1514 = new SimpleChannelContact();
                _elem1514.read(iprot);
                this.success.add(_elem1514);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem1515 in this.success) {
          elem1515.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSimpleChannelContacts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserLastSentMessageTimeStamp_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserLastSentMessageTimeStamp_args");
  static final TField _MID_FIELD_DESC = new TField("mid", TType.STRING, 1);

  String _mid;
  static const int MID = 1;


  getUserLastSentMessageTimeStamp_args() {
  }

  // mid
  String get mid => this._mid;

  set mid(String mid) {
    this._mid = mid;
  }

  bool isSetMid() => this.mid != null;

  unsetMid() {
    this.mid = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MID:
        return this.mid;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MID:
        if (value == null) {
          unsetMid();
        } else {
          this.mid = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MID:
        return isSetMid();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case MID:
          if (field.type == TType.STRING) {
            this.mid = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.mid != null) {
      oprot.writeFieldBegin(_MID_FIELD_DESC);
      oprot.writeString(this.mid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserLastSentMessageTimeStamp_args(");

    ret.write("mid:");
    if (this.mid == null) {
      ret.write("null");
    } else {
      ret.write(this.mid);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUserLastSentMessageTimeStamp_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserLastSentMessageTimeStamp_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  int _success = 0;
  static const int SUCCESS = 0;
  TalkException _e;
  static const int E = 1;

  bool __isset_success = false;

  getUserLastSentMessageTimeStamp_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // e
  TalkException get e => this._e;

  set e(TalkException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TalkException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserLastSentMessageTimeStamp_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

